
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>Easy Scalaz 3, ReaderWriterState with Kleisli</title>
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Easy Scalaz 3, ReaderWriterState with Kleisli">
  <meta name="twitter:description" content="Composition (합성) 은 함수형 언어에서 중요한 테마중 하나인데요, 이번 시간에는 Kleisli 를 이용해 어떻게 함수를 타입으로 표현하고, 합성할 수 있는지 살펴보겠습니다. 그리고 나서, Reader, Writer 에 대해 알아보고, 이것들과 State 를 같이 사용하는 RWST 에 대해 알아보겠습니다. Kleisli State 가 (S) =&gt; (S, A) 를 타입클래스로 표현한 것이라면, A =&gt;">
  <meta name="twitter:creator" content="@yourTwitterUsername">
  <meta name="twitter:image" content="">
  <meta name="twitter:url" content="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/">
  <meta name="twitter:domain" content="http://1ambda.github.io">


  <link rel="author" href="https://plus.google.com/101105410053351451441?rel=author">

  <link rel="shortcut icon" href="../favicon.ico">

  <link rel="stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Droid+Serif">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:600,300">
  <link rel="stylesheet" type="text/css" href="../assets/stylesheets/xpressio.css">
  <link rel="stylesheet" type="text/css" href="../assets/1ambda/1ambda.css">
  <script type="text/javascript" src="../assets/1ambda/modernizr.js">
  </script>
  <script type="text/javascript" src="../assets/1ambda/detectizr.min.js">
  </script>

  <!--load css if windows -->
  <script type="text/javascript">
    if (Modernizr.windows) {
      file = location.pathname.split( "/" ).pop();
      link = document.createElement( "link" );
      link.href = "/assets/1ambda/1ambda_windows.css";
      link.type = "text/css";
      link.rel = "stylesheet";
      link.media = "screen,print";
      document.getElementsByTagName("head")[0].appendChild( link );
    }
  </script>


  <link rel="stylesheet" href="../assets/highlight/styles/github.css">
<script src="../assets/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  <link rel="canonical" href="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/">
    <meta name="referrer" content="origin">
    
    <meta property="og:site_name" content="Old Lisper">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Easy Scalaz 3, ReaderWriterState with Kleisli">
    <meta property="og:description" content="Composition (합성) 은 함수형 언어에서 중요한 테마중 하나인데요, 이번 시간에는 Kleisli 를 이용해 어떻게 함수를 타입으로 표현하고, 합성할 수 있는지 살펴보겠습니다. 그리고 나서, Reader, Writer 에 대해 알아보고, 이것들과 State 를 같이 사용하는 RWST 에 대해 알아보겠습니다. Kleisli State 가...">
    <meta property="og:url" content="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/">
    <meta property="article:published_time" content="2015-11-17T11:32:42.885Z">
    <meta property="article:modified_time" content="2015-11-17T11:34:00.095Z">
    <meta property="article:tag" content="scala">
    <meta property="article:tag" content="scalaz">
    <meta property="article:tag" content="readerwriterstate">
    <meta property="article:tag" content="kleisli">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Easy Scalaz 3, ReaderWriterState with Kleisli">
    <meta name="twitter:description" content="Composition (합성) 은 함수형 언어에서 중요한 테마중 하나인데요, 이번 시간에는 Kleisli 를 이용해 어떻게 함수를 타입으로 표현하고, 합성할 수 있는지 살펴보겠습니다. 그리고 나서, Reader, Writer 에 대해 알아보고, 이것들과 State 를 같이 사용하는 RWST 에 대해 알아보겠습니다. Kleisli State 가...">
    <meta name="twitter:url" content="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/">
    
    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Article",
    "publisher": "Old Lisper",
    "author": {
        "@type": "Person",
        "name": "1ambda",
        "image": "//www.gravatar.com/avatar/aa2032ba2302419e3c2ede54f1fbf687?d=404&s=250",
        "url": "http://1ambda.github.io/author/1ambda",
        "sameAs": "http://1ambda.github.io",
        "description": "Functional, Scala, Akka, Rx and Haskell"
    },
    "headline": "Easy Scalaz 3, ReaderWriterState with Kleisli",
    "url": "http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/",
    "datePublished": "2015-11-17T11:32:42.885Z",
    "dateModified": "2015-11-17T11:34:00.095Z",
    "keywords": "scala, scalaz, readerwriterstate, kleisli",
    "description": "Composition (합성) 은 함수형 언어에서 중요한 테마중 하나인데요, 이번 시간에는 Kleisli 를 이용해 어떻게 함수를 타입으로 표현하고, 합성할 수 있는지 살펴보겠습니다. 그리고 나서, Reader, Writer 에 대해 알아보고, 이것들과 State 를 같이 사용하는 RWST 에 대해 알아보겠습니다. Kleisli State 가..."
}
    </script>

    <meta name="generator" content="Ghost 0.6">
    <link rel="alternate" type="application/rss+xml" title="Old Lisper" href="http://1ambda.github.io/rss/">

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52181619-1', '1ambda.github.io');
  ga('send', 'pageview');
</script>
  
</head>
<body>

  <script src="../public/jquery.js?v=1d8e3b39d8"></script>

  
<header class="site_width text center padding_top_big margin_bottom_big">
  
  <h1 class="blog_title margin_bottom_small"><a href="http://1ambda.github.io">Old Lisper</a></h1>
  <h4 class="text book">Functional Programming World</h4>
  <div class="social border solid top_small bottom_small padding_medium">
  <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="http://1ambda.github.io/articles/"><i class="fa fa-columns"></i> <span class="margin_lefarticlest_small desktop">Article</span></a></h6>
  <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="http://kr.linkedin.com/in/1ambda" target="_blank"><i class="fa fa-linkedin-square"></i> <span class="margin_left_small desktop">Linkedin</span></a></h6>
  <h6 class="text book color c_black_medium without_margin"><a href="http://github.com/1ambda" target="_blank"><i class="fa fa-github"></i> <span class="margin_left_small desktop">GitHub</span></a></h6>
</div>
</header>

<main class="site_width" role="main">
  <article class="post tag-scala tag-scalaz tag-readerwriterstate tag-kleisli">


    <header class="text center margin_bottom_medium">
      <h5 class="text book small uppercase color c_black_light margin_bottom_small">Posted in <a href="../tag/scala/">scala</a>, <a href="../tag/scalaz/">scalaz</a>, <a href="../tag/readerwriterstate/">readerwriterstate</a>, <a href="../tag/kleisli/">kleisli</a></h5>
      <h1 class="margin_bottom_medium">Easy Scalaz 3, ReaderWriterState with Kleisli</h1>
      <h5 class="text book small uppercase color c_black_light margin_bottom_small"><time datetime="2015-11-17">Tuesday, November 17, 2015</time>
      <br><br>
       <a href="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/#disqus_thread">Comment</a>
      </h5>
    </header>

    <section>
      <p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p><em>Composition</em> (합성) 은 함수형 언어에서 중요한 테마중 하나인데요, 이번 시간에는 <em>Kleisli</em> 를 이용해 어떻게 함수를 타입으로 표현하고, 합성할 수 있는지 살펴보겠습니다. 그리고 나서, <em>Reader</em>, <em>Writer</em> 에 대해 알아보고, 이것들과 <em>State</em> 를 같이 사용하는 <em>RWST</em> 에 대해 알아보겠습니다.</p>

<h2 id="kleisli">Kleisli</h2>

<p><em>State</em> 가 <code>(S) =&gt; (S, A)</code> 를 타입클래스로 표현한 것이라면, <code>A =&gt; B</code> 를 타입클래스로 표현한 것도 있지 않을까요? 그렇게 되면, 스칼라에서 지원하는 <code>andThen</code>, <code>compose</code> 을 이용해서 함수를 조합하는 것처럼, 타입 클래스를 조합할 수 있을겁니다. <code>Kleisli</code> 가 바로, 그런 역할을 하는 타입 클래스입니다.</p>

<blockquote>
  <p>Kleisli represents a function <code>A =&gt; M[B]</code></p>
</blockquote>

<p>타입을 보면, 단순히 <code>A =&gt; B</code> 이 아니라 <code>A =&gt; M[B]</code> 를 나타냅니다. 이는 <code>Kleisli</code> 가 <code>M</code> 을 해석하고, 조합할 수 있는 방법을 제공한다는 것을 의미합니다. 실제 구현을 보면,</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Kleisli.scala#L8

final case class Kleisli[M[_], A, B](run: A =&gt; M[B]) { self =&gt;  
  ...

  def &gt;=&gt;[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] =  kleisli((a: A) =&gt; b.bind(this(a))(k.run))

  def andThen[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &gt;=&gt; k

  def &gt;==&gt;[C](k: B =&gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &gt;=&gt; kleisli(k)

  def andThenK[C](k: B =&gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &gt;==&gt; k

  /** alias for `compose` */
  def &lt;=&lt;[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &gt;=&gt; this

  def compose[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &gt;=&gt; this

  def &lt;==&lt;[C](k: C =&gt; M[A])(implicit b: Bind[M]): Kleisli[M, C, B] = kleisli(k) &gt;=&gt; this

  def composeK[C](k: C =&gt; M[A])(implicit b: Bind[M]): Kleisli[M, C, B] = this &lt;==&lt; k
  ...
}
</code></pre>

<p><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/KleisliUsage.scala">Kleisli Example</a> 에서 간단한 예제를 가져와서 사용법을 살펴보도록 하겠습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/KleisliUsage.scala

case class Continent(name: String, countries: List[Country] = List.empty)  
case class Country(name: String, cities: List[City] = List.empty)  
case class City(name: String, isCapital: Boolean = false, inhabitants: Int = 20)

val data: List[Continent] = List(  
  Continent("Europe"),
  Continent("America",
    List(
      Country("Canada",
        List(
          City("Ottawa"), City("Vancouver"))),
      Country("USA",
        List(
          City("Washington"), City("New York"))))),
  Continent("Asia",
    List(
      Country("India",
        List(City("New Dehli"), City("Calcutta"))))))
</code></pre>

<p>여기에 다음의 함수를 정의하면 </p>

<pre><code class="language-scala">def continents(name: String): List[Continent] =  
  data.filter(k =&gt; k.name.contains(name))

def countries(continent: Continent): List[Country] = continent.countries

def cities(country: Country): List[City] = country.cities

def save(cities: List[City]): Try[Unit] =  
  Try {
    // do IO or some side-effectful operations
    cities.foreach(c =&gt; println("Saving " + c.name))
  }

def inhabitants(c: City): Int = c.inhabitants  
</code></pre>

<p>이제 <code>A =&gt; M[B]</code> 형태의 여러 함수들을 만들었으므로 이를 <code>Kleisli</code> 를 이용해 조합할 수 있습니다. (이 예제에서 <code>M == List</code>)</p>

<pre><code class="language-scala">// Kleisli[List, String, City]
val allCities = kleisli(continents) &gt;==&gt; countries &gt;==&gt; cities

// Kleisli[List, String, Int]
val cityInhabitants = allCities map inhabitants  
</code></pre>

<p><code>allCities</code> 는 <code>String</code> 을 인자로 받기도 하고, <code>M == List</code> 의 <code>Kleisli</code> 기 때문에 <code>List</code> 를 인자로 받을 수도 있습니다. (<code>=&lt;&lt;</code>)</p>

<pre><code class="language-scala">allCities("America") map(println)

// output
City(Ottawa,false,20)  
City(Vancouver,false,20)  
City(Washington,false,20)  
City(New York,false,20)

(allCities =&lt;&lt; List("America", "Asia")).map(println)

// output
City(Ottawa,false,20)  
City(Vancouver,false,20)  
City(Washington,false,20)  
City(New York,false,20)  
City(New Dehli,false,20)  
City(Calcutta,false,20)  
</code></pre>

<p><code>Kleisli</code> 가 제공하는 함수를 다시 살펴보면,</p>

<pre><code class="language-scala">def =&lt;&lt;(a: M[A])(implicit m: Bind[M]): M[B] = m.bind(a)(run)

def map[C](f: B =&gt; C)(implicit M: Functor[M]): Kleisli[M, A, C] =  
  kleisli(a =&gt; M.map(run(a))(f))

def mapK[N[_], C](f: M[B] =&gt; N[C]): Kleisli[N, A, C] =  
  kleisli(run andThen f)

def flatMapK[C](f: B =&gt; M[C])(implicit M: Bind[M]): Kleisli[M, A, C] =  
  kleisli(a =&gt; M.bind(run(a))(f))

def flatMap[C](f: B =&gt; Kleisli[M, A, C])(implicit M: Bind[M]): Kleisli[M, A, C] =  
  kleisli((r: A) =&gt; M.bind[B, C](run(r))(((b: B) =&gt; f(b).run(r))))
</code></pre>

<p>여기서 <code>mapK :: M[B] =&gt; N[C]</code> 를 이용하면 현재 <code>Kleisli[M, _, _]</code> 를 <code>Kleisli[N, _, _]</code> 로 변경할 수 있습니다.</p>

<p>위에서 정의한 <code>save</code> 함수는 <code>List[A]</code> 를 받아 <code>Try[Unit]</code> 를 여기에 사용할 수 있습니다.</p>

<pre><code class="language-scala">// Kleisli[Try, String, Unit]
val getAndSaveCities = allCities mapK save  
</code></pre>

<p><code>local</code> 을 이용하면 함수를 <em>prepend</em> 할 수 있습니다.</p>

<pre><code class="language-scala">// def local[AA](f: AA =&gt; A): Kleisli[M, AA, B] =
//   kleisli(f andThen run)

def index(i: Int): String = data(i).name

// Kleisli[List, Int, City]
val allCitiesWithIndex = allCities local index

allCitiesWithIndex(1) map(println)

// output
City(Ottawa,false,20)  
City(Vancouver,false,20)  
City(Washington,false,20)  
City(New York,false,20)  
</code></pre>

<p><code>Kleisli</code> 에 대한 더 읽을거리는 아래 링크를 참조해주세요. </p>

<ul>
<li><a href="http://eed3si9n.com/learning-scalaz/Arrow.html">Scalaz Arrow</a></li>
<li><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Kleisli.scala#L209">Scalaz - Kleisli.scala#KleisliArrow</a></li>
</ul>

<h2 id="reader">Reader</h2>

<p><code>Kleisli</code> 가 <code>A =&gt; M[B]</code> 를 나타낸다면, <code>Reader</code> 는 <code>A =&gt; B</code> (<code>Function1</code>) 를 의미하는 타입클래스입니다. 얼핏 생각하기에 <code>Kleisli[Id, A, B]</code> 일것 같죠? 실제 구현을 보면 (<em>scalaz</em> 에서 타입 얼라이어스는 <code>package.scala</code> 에 정의되어 있습니다.)</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/package.scala

type ReaderT[F[_], E, A] = Kleisli[F, E, A]  
val ReaderT = Kleisli  
type Reader[E, A] = ReaderT[Id, E, A]

object Reader {  
    def apply[E, A](f: E =&gt; A): Reader[E, A] = Kleisli[Id, E, A](f)
  }
</code></pre>

<p><code>Reader</code> 도 <code>Klelsli</code> 이므로, <code>Reader[A, B] &gt;==&gt; Reader[B, C]</code> 는 <code>Reader[A, C]</code> 가 됩니다. 게다가 <code>Kleisli</code> 는 <code>flatMap</code> 을 정의하고 있으므로 <em>monadic composition</em> 을 작성할 수 있습니다.</p>

<blockquote>
  <p>The point of a <code>Reader</code> is to supply some configuration object without having to manually (or <em>implicitly</em>) pass i around all the functions.</p>
</blockquote>

<p>요는, 함수 사이의 체인을 엮어 새로운 함수를 만들수 있고 이로인해 직접 파라미터를 넘겨줄 필요가 없습니다. 예를 들어</p>

<pre><code class="language-scala">type URI = String  
type Key = String  
type Value = String

val uri: Reader[Get, URI]  
val queryString: Reader[URI, String]  
val body: Reader[String, Map[Key, Value]

// Get =&gt; Map[Key, Value]
val queryStringToBody = uri &gt;==&gt; queryString &gt;==&gt; body  
</code></pre>

<p>간단히 구현을 해보겠습니다. 예외 처리는 외부에서 <code>Try</code> 혹은 <code>\/.fromTryCatchThrowable</code> 등으로 한다 가정하고 로직에만 집중해보면,</p>

<pre><code class="language-scala">// model
trait HttpRequest {  
  def url: String
}
case class GET(url: String) extends HttpRequest  
case class POST(url: String, body: Map[String, String]) extends HttpRequest

val uri: Reader[GET, String] = Reader { req: GET =&gt; req.url }  
val queryString: Reader[String, String] = Reader { url: String =&gt; url.split("\\?")(1) }  
val body: Reader[String, Map[String, String]] = Reader { queries: String =&gt;  
  val qs = queries.split("&amp;").toList
  qs.foldLeft(Map.empty[String, String]) { (acc: Map[String, String], q) =&gt;
    val kv = q.split("=")
    acc.updated(kv(0), kv(1))
  }
}

val queryStringToBody: Reader[GET, Map[String, String]] = uri &gt;==&gt; queryString &gt;==&gt; body  
</code></pre>

<p><code>queryStringToBody</code> 를 사용해 보면,</p>

<pre><code class="language-scala">val get1 = GET("http://www.google.com/search?query=scalaz&amp;site=github")  
val post1 = POST("http://www.google.com/search", Map("query" -&gt; "scalaz", "site" -&gt; "github"))  
val post2 = POST("https://www.google.com/search", Map("query" -&gt; "scalaz", "site" -&gt; "github"))

queryStringToBody.run(get1) shouldBe Map("query" -&gt; "scalaz", "site" -&gt; "github")  
</code></pre>

<p>함수를 몇개 더 작성해보면,</p>

<pre><code class="language-scala">val toHttpsRequest = Reader { url: String =&gt; url.replaceAll("http://$", "https://") }  
val sslProxy: Reader[_ &gt;: readerwriterstate.HttpRequest, readerwriterstate.HttpRequest] = Reader { req: readerwriterstate.HttpRequest =&gt;  
  req match {
    case request if request.url.startsWith("https://") =&gt; request
    case request: POST =&gt; request.copy(url = toHttpsRequest(request.url))
    case request: GET  =&gt; request.copy(url = toHttpsRequest(request.url))
  }
}

val convertGetToPost: Reader[_ &gt;: readerwriterstate.HttpRequest, POST] = Reader { req : readerwriterstate.HttpRequest =&gt;  
  req match {
    case get: GET =&gt;
      val split = get.url.split("\\?")
      val (path, query) = (split(0), split(1))
      val postBody = body.run(query)

      POST(path, postBody)

    case post: POST =&gt; post
  }
}
</code></pre>

<p>이제 <code>HttpRequest</code> 서브타입을 받아, 프록시를 적용하고, <code>GET</code> 이면 <code>POST</code> 로 변경하는 함수를 조합해보면 아래와 같습니다.</p>

<p>(<code>:&gt;</code> 등 <em>Type Bound</em> 에 대해서는 <a href="http://twitter.github.io/scala_school/type-basics.html">Scala School - Type &amp; Polymorphism</a> 과 <a href="http://twitter.github.io/scala_school/advanced-types.html">Scala School - Advanced Types</a> 를 참조해주세요.) </p>

<pre><code class="language-scala">val proxiedPost: Reader[_ &gt;: HttpRequest, POST] = sslProxy &gt;==&gt; convertGetToPost

// spec
proxiedPost.run(get1) shouldBe post2  
</code></pre>

<h2 id="flatmapforreader">flatMap for Reader</h2>

<p><code>Reader</code> 는 <code>Kleisli</code> 고, 이것간의 합성은 <code>&gt;==&gt;</code> 을 이용한다는것을 확인했습니다. 그럼 <code>flatMap</code> 은 어디에 쓰는걸까요? </p>

<pre><code class="language-scala">type ReaderT[F[_], E, A] = Kleisli[F, E, A]  
type Reader[E, A] = ReaderT[Id, E, A]

final case class Kleisli[M[_], A, B](run: A =&gt; M[B]) { self =&gt;  
  ...

  // andThen
  def &gt;=&gt;[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] =  kleisli((a: A) =&gt; b.bind(this(a))(k.run))

  def &gt;==&gt;[C](k: B =&gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &gt;=&gt; kleisli(k)

  def flatMapK[C](f: B =&gt; M[C])(implicit M: Bind[M]): Kleisli[M, A, C] =
    kleisli(a =&gt; M.bind(run(a))(f))

  def flatMap[C](f: B =&gt; Kleisli[M, A, C])(implicit M: Bind[M]): Kleisli[M, A, C] =
    kleisli((r: A) =&gt; M.bind[B, C](run(r))(((b: B) =&gt; f(b).run(r))))

  ...
}
</code></pre>

<p><code>flatMap</code> 을 보면 재미난 점이 보입니다. <code>Kleisli[M, A, B]</code> 와 <code>Kleisli[M, A, C]</code> 를 <code>flatMap</code> 으로 엮는데, <code>r: A</code> 를 넣어서 <code>run(r)</code> 을 실행하는걸 보실 수 있습니다. <code>Kleisli[M, A, C]</code> 까지도요! </p>

<p>즉 <code>A</code> 자체가 일종의 설정(<em>Configuration</em>) 값으로써 모든 <code>Kleisli</code> 에서 사용됩니다. 그렇기에 </p>

<ul>
<li><code>Reader[A, B]</code> 와 <code>Reader[B, C]</code> 는 <code>&gt;==&gt;</code> 으로</li>
<li><code>Reader[A, B]</code> 와 <code>Reader[A, C]</code> 는 <code>flatMap</code> 으로 엮을 수 있습니다.</li>
</ul>

<h3 id="dependencyinjectionusingreader">Dependency Injection using Reader</h3>

<p><code>Reader</code> 를 이용하면 스칼라에서 별도의 라이브러리 없이 <em>Dependency Injection</em> (이하 <em>DI</em>) 를 구현할 수 있습니다. 이는 위에서 보았던 <code>flatMap</code> 의 특징을 이용하면 됩니다. 다음과 같은 모델이 있다고 할  때, </p>

<pre><code class="language-scala">case class User(id: Long,  
                name: String,
                age: Int,
                email: String,
                supervisorId: Long)

trait UserRepository {  
  def get(id: Long): User
  def find(name: String): User
}

trait UserService {  
  def getUser(id: Long): Reader[UserRepository, User] =
    Reader(repo =&gt; repo.get(id))

  def findUser(userName: String): Reader[UserRepository, User] =
    Reader(repo =&gt; repo.find(userName))

  def getUserInfo(userName: String): Reader[UserRepository, Map[String, String]] = for {
    user &lt;- findUser(userName)
    supervisor &lt;- getUser(user.supervisorId)
  } yield Map(
    "email" -&gt; s"${user.email}",
    "boss"  -&gt; s"${supervisor.name}"
  )
}
</code></pre>

<p>다음처럼 주입할 수 있습니다.</p>

<pre><code class="language-scala">object UserRepositoryDummyImpl extends UserRepository {  
  override def get(id: Long): User = ???
  override def find(name: String): User = ???
}

class UserApplication(userRepository: UserRepository) extends UserService  
object UserApplication extends UserApplication(UserRepositoryDummyImpl)  
</code></pre>

<p>이외에도 스칼라에서 언어 자체의 기능만으로 DI 를 구현하는 방법으로 <em>Cake Pattern</em> , <em>Implicit</em> 등이 있습니다. (<a href="http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/">Scala Dependency Injection using Reader</a> 참조)</p>

<p>위의 두 방법과 <code>Reader</code> 를 사용한 방법을 비교하면, </p>

<ul>
<li><em>Cake Pattern</em> 에 비해 코드가 짧고</li>
<li><em>Implicit</em> 를 이용하지 않으므로 함수 시그니쳐가 간단합니다.</li>
</ul>

<h2 id="writer">Writer</h2>

<p><code>Writer[W, A]</code> 는 <code>run: (W, A)</code> 을 값으로 가지는 <em>case class</em> 입니다. 재미난 점은, <code>flatMap</code> 을 이용해 두개의 <code>Writer</code> 를 엮으면 각각의 값인 <code>(w1, a1)</code>, <code>(w2, a2)</code> 에 대해서 사용자가 다루는 값인 <code>a1, a2</code> 를 제하고 <code>w1</code> 과 <code>w2</code> 가 일종의 <a href="http://1ambda.github.io/easy-scalaz-1-state/">State</a> 처럼 관리되어 자동으로 <em>append</em> 된다는 점입니다. 따라서 많은 튜토리얼들이 <em>logging</em> 을 예로 들어 <code>Writer</code> 를 설명하곤 합니다.</p>

<pre><code class="language-scala">test("WriterOps") {  
  val w1: Writer[String, Int] = 10.set("w1 created")
  val w2: Writer[String, Int] = 20.set("w2 created")

  val result: Writer[String, Int] = for {
    n1 &lt;- w1
    n2 &lt;- w2
  } yield n1 + n2

  // What if we use `List[String]` instead of `String`?
  result.run shouldBe ("w1 createdw2 created", 30)
}
</code></pre>

<p><em>Scalaz</em> 구현을 보면</p>

<pre><code class="language-scala">type Writer[W, A] = WriterT[Id, W, A]

final case class WriterT[F[_], W, A](run: F[(W, A)]) { self =&gt;  
  ...

  def flatMap[B](f: A =&gt; WriterT[F, W, B])(implicit F: Bind[F], s: Semigroup[W]): WriterT[F, W, B] =
    flatMapF(f.andThen(_.run))

  def flatMapF[B](f: A =&gt; F[(W, B)])(implicit F: Bind[F], s: Semigroup[W]): WriterT[F, W, B] =
    writerT(F.bind(run){wa =&gt;
      val z = f(wa._2)
      F.map(z)(wb =&gt; (s.append(wa._1, wb._1), wb._2))
    })

  ...
</code></pre>

<p><code>WriterT</code> 에서 <code>F</code> 를 <code>Id</code> 라 하면 <code>Writer</code> 가 되고 <code>flatMap</code> 로직은 다음처럼 단순화 할 수 있습니다.</p>

<pre><code class="language-scala">case class Writer[W, A](run: (W, A)) { self =&gt;  
  def flatMap[B](f: A =&gt; Writer[W, B])(implicit s: Semigroup[W]) {
    val (w1, a) = self.run
    val (w2, b) = f(a)
    (s.append(w1, w2), b)
  }
}
</code></pre>

<p>여기서 <a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Semigroup.scala">Semigroup.scala</a> 은, <em>Associativity</em> (결합법칙) 을 만족하는 <em>binary operator</em> 를 정의하는 타입 클래스입니다. (위에서 <code>append</code>)</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Semigroup.scala#L55

 /**
   * A semigroup in type F must satisfy two laws:
    *
    *  - '''closure''': `∀ a, b in F, append(a, b)` is also in `F`. This is enforced by the type system.
    *  - '''associativity''': `∀ a, b, c` in `F`, the equation `append(append(a, b), c) = append(a, append(b , c))` holds.
   */
  trait SemigroupLaw {
    def associative(f1: F, f2: F, f3: F)(implicit F: Equal[F]): Boolean =
      F.equal(append(f1, append(f2, f3)), append(append(f1, f2), f3))
  }
</code></pre>

<p><a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Monoid.scala">Monoid</a> 는 결합법칙을 만족하는 덧셈 연산과, 항등원 연산을 정의하는 타입 클래스인데, <em>Scalaz</em> 에서는 <code>Monoid</code> 가 <code>Semigroup</code> 을 상속받습니다.</p>

<pre><code class="language-scala">trait Monoid[F] extends Semigroup[F] { self =&gt;  
  ...
</code></pre>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png" alt="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png"></p>

<p><br></p>

<p>따라서 <code>Writer[W, A]</code> 의 <code>flatMap</code> 을 이용하기 위해서는 <code>W</code> 가 <code>Semigroup</code> 여야 하고 그래야만 <code>flatMap</code> 내부에서 자동으로 <code>W</code> 를 <em>append</em> 할 수 있습니다. </p>

<p>스칼라에서 제공하는 <code>List</code> 등의 기본 타입은 <em>Scalaz</em> 에서 <code>Monoid</code> 를 제공합니다. (<a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/std/List.scala#L109">scalaz.std.List</a>, <a href="https://github.com/scalaz/scalaz/tree/series/7.1.x/core/src/main/scala/scalaz/std">scalaz.std</a> 참조)</p>

<p>정리하면, <code>Writer[W, A]</code> 를 이용하면 값인 <code>A</code> 를 조작하면서 <code>W</code> 를 신경쓰지 않고, 자동으로 <code>append</code> 시킬 수 있습니다. (e.g <em>logging</em>)</p>

<h2 id="writerexample">Writer Example</h2>

<p>간단한 모델을 만들면,</p>

<pre><code class="language-scala">import scalaz._, Scalaz._

trait ThreadState  
case object Waiting    extends ThreadState  
case object Running    extends ThreadState  
case object Terminated extends ThreadState  
case class Thread(tid: String, name: String, state: ThreadState)  
case class Process(pid: String, threads: List[Thread])

object Process {  
  type Logger[A] = Writer[Vector[String], A]

  def genRandomID: String = java.util.UUID.randomUUID().toString.replace("-", "")

  def createThread(name: String): Logger[Thread] = {
    val tid = genRandomID
    Thread(tid, name, Waiting).set(Vector(s"Thread [$tid] was created"))
  }

  def createEmptyProcess: Logger[Process] = {
    val pid = genRandomID
    Process(pid, Nil).set(Vector(s"Empty Process [$pid] was created"))
  }

  def createNewProcess: Logger[Process] = for {
    mainThread &lt;- createThread("main")
    process &lt;- createEmptyProcess
    _ &lt;- Vector(s"Main Thread [${mainThread.tid}] was added to Process [${process.pid}").tell
  } yield process.copy(threads = mainThread.copy(state = Running) :: process.threads)
}
</code></pre>

<p>여기서 <code>W</code> 로 <code>List[String]</code> 대신 <code>Vector[String]</code> 을 사용하는 이유는, <em>append</em> 가 더 빠르기 때문입니다. (<a href="http://docs.scala-lang.org/overviews/collections/performance-characteristics.html">Scala Collection Performance Characteristics</a> 참조)</p>

<pre><code class="language-scala">test("Writer usage2") {  
  import readerwriterstate.Process._

  val (written, process) = createNewProcess.run

  process.threads.length shouldBe 1
  process.threads.head.name shouldBe "main"

  /* map lets you map over the value side */
  val ts: Logger[List[Thread]] = createNewProcess.map(p =&gt; p.threads)
  ts.value.length shouldBe 1

  /* with mapWritten you can map over the written side */
  val edited: Vector[String] = createNewProcess.mapWritten(_.map { log =&gt; "[LOG]" + log }).written
  println(edited.mkString("\n"))

  /** output
   * [LOG]Thread [557ad5bd0f3b4d49bac85b05ebedcd7b] was created
   * [LOG]Empty Process [710bd940ebdd4a82b949a32b585a12d9] was created
   * [LOG]Main Thread [557ad5bd0f3b4d49bac85b05ebedcd7b] was added to Process [710bd940ebdd4a82b949a32b585a12d9]
   */

  /* with mapValue, you can map over both sides */
  createNewProcess.mapValue { case (log, p) =&gt;
    (log :+ "Add an IO thread",
     p.copy(threads = Thread(genRandomID, "IO-1", Waiting) :: p.threads))
  }

  // `:++&gt;` `:++&gt;&gt;`, `&lt;++:`, `&lt;&lt;++:`
  createNewProcess :++&gt; Vector("add some log")
  val emptyWithLog = createEmptyProcess :++&gt;&gt; { process =&gt;
    Vector(s"${process.pid} is an empty process")
  }

   println(emptyWithLog.written)

  // output: Vector(Empty Process [cf211fc366ab4d20a0c25a27d173accd] was created, cf211fc366ab4d20a0c25a27d173accd is an empty process)

  // Writer is an applicative
  val emptyProcesses: Logger[List[readerwriterstate.Process]] =
    (createEmptyProcess |@| createEmptyProcess) { List(_) |+| List(_) }

  val ps = emptyProcesses.value
  ps.length shouldBe 2
}
</code></pre>

<p><a href="http://eed3si9n.com/learning-scalaz/Applicative+Builder.html">Applicative Builder</a>, <a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/WriterT.scala#L30">WriterT Functions</a> 를 참고하시면 이해가 더 쉽습니다.</p>

<h2 id="rwst">RWST</h2>

<p><a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala">ReaderWriterState</a> 는 다름이 아니라, 이제까지 보았던 <code>Reader</code>, <code>Writer</code>, <code>State</code> 를 모두 이용하는 타입 클래스입니다. <code>Reader</code> 로 설정값을 읽고, <code>Writer</code> 로 중간 과정을 기록하고, <code>State</code> 로 상태를 변경 또는 유지해 가며 연산을 수행할 수 있습니다. <em>Scalaz</em> 에서는 예제로 <a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/ReaderWriterStateTUsage.scala">ReaderWriterStateTUsage.scala</a> 를 제공하고 있습니다.</p>

<p>이제까지 늘 그래왔듯이, <code>ReaderWriterState[R, W, S, A]</code> 또한 <code>ReaderWriterStateT[Id, R, W, S, A]</code> 의 <em>type alias</em> 입니다. <code>Reader</code>, <code>Writer</code>, <code>State</code> 에서 사용했었던 함수들도 같이 제공됩니다.</p>

<pre><code class="language-scala">type ReaderWriterState[-R, W, S, A] = ReaderWriterStateT[Id, R, W, S, A]  
type ReaderWriterStateT[F[_], -R, W, S, A] = IndexedReaderWriterStateT[F, R, W, S, S, A]

object ReaderWriterState extends ReaderWriterStateTInstances with ReaderWriterStateTFunctions {  
  def apply[R, W, S, A](f: (R, S) =&gt; (W, A, S)): ReaderWriterState[R, W, S, A] = IndexedReaderWriterStateT[Id, R, W, S, S, A] { (r: R, s: S) =&gt; f(r, s) }
}
</code></pre>

<p><code>apply</code> 를 보면, <code>ReaderWriterState</code> 는 타입 <code>(R, S) =&gt; (W, A, S)</code> 함수를 넘겨주어 생성할 수 있습니다. <code>Reader</code>, <code>State</code> 를 받고, <code>Writer</code>, <code>A</code> (결과값), <code>State</code> 를 돌려주는 것으로 해석할 수 있습니다.</p>

<p><code>ReadwrWriterState.flatMap</code> 은 <code>State</code>, <code>Writer</code>, <code>Reader</code> 의 <code>flatMap</code> 을 모두 조합한것처럼 생겼습니다. 하는일도 그렇구요. </p>

<pre><code class="language-scala">/** A monad transformer stack yielding `(R, S1) =&gt; F[(W, A, S2)]`. */
sealed abstract class IndexedReaderWriterStateT[F[_], -R, W, -S1, S2, A] {

  ...

  def flatMap[B, RR &lt;: R, S3](f: A =&gt; IndexedReaderWriterStateT[F, RR, W, S2, S3, B])(implicit F: Bind[F], W: Semigroup[W]): IndexedReaderWriterStateT[F, RR, W, S1, S3, B] =
    new IndexedReaderWriterStateT[F, RR, W, S1, S3, B] {
      def run(r: RR, s1: S1): F[(W, B, S3)] = {
        F.bind(self.run(r, s1)) {
          case (w1, a, s2) =&gt; {
            F.map(f(a).run(r, s2)) {
              case (w2, b, s3) =&gt; (W.append(w1, w2), b, s3)
            }
          }
        }
      }
    }

  ...
</code></pre>

<ul>
<li><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala#L4">Scalaz - IndexedReaderWriterStateT</a></li>
<li><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala#L179">Scalaz - ReaderWriterStateTMonad</a></li>
</ul>

<h2 id="rwstexample">RWST Example</h2>

<p>예제를 위해 간단한 모델을 만들어 보겠습니다. </p>

<ul>
<li><code>Reader</code> 로 <code>DatabaseConfig</code> 를</li>
<li><code>Writer</code> 로 <code>Vector[String]</code> 을</li>
<li><code>State</code> 로 <code>Connection</code> 을 이용하고</li>
</ul>

<p>결과값으로 타입 <code>A</code> 를 돌려주는 <code>Task[A]</code> 를 만들면 아래와 같습니다.</p>

<pre><code class="language-scala">object Database {  
  type Task[A] = ReaderWriterState[DatabaseConfig, Vector[String] /* log */, Connection, A]
  ...
</code></pre>

<p>여기에 몇 가지 제약조건을 걸어보겠습니다.</p>

<ul>
<li><code>DatabaseConfig.operationTimeoutMillis</code> 에 의해서 타임아웃(<code>OperationTimeoutException</code>) 발생</li>
<li><code>OperationTimeoutException</code> 발생시, 연산을 즉시 중단하고, 오류 없이 수행이 되었을 경우 <em>commit</em> </li>
<li><em>Post Commit Action</em> 등록을 할 수 있어야 하며, <em>commit</em> 후 순차대로 자동 실행</li>
</ul>

<p>이제 필요한 몇몇 클래스를 만들고</p>

<pre><code class="language-scala">type Action = () =&gt; Unit  
case class PostCommitAction(id: String, action: Action)  
case class DatabaseConfig(operationTimeoutMillis: Long)  
case class ResultSet() /* dummy */

case class Connection(id: String,  
                      actions: List[PostCommitAction] = Nil) {

  def commit = {}
  def executeAndReturn(query: String): ResultSet = ResultSet()
  def execute(query: String): Unit = {}
}

class OperationTimeoutException private(ex: RuntimeException) extends RuntimeException(ex) {  
  def this(message:String) = this(new RuntimeException(message))
  def this(message:String, throwable: Throwable) = this(new RuntimeException(message, throwable))
}

object OperationTimeoutException {  
  def apply(message:String) = new OperationTimeoutException(message)
  def apply(message:String, throwable: Throwable) = new OperationTimeoutException(message, throwable)
}
</code></pre>

<p>이제 사용자가 API 를 사용하는 것을 한번 상상해보겠습니다. <em>commit</em> 이 어쨌건, 사용자가 하고싶은 일은 쿼리를 실행해서 결과값을 받아오거나, 필요한 <em>post commit action</em> 을 등록하는 일일겁니다. 나머지는 다 알아서 해주겠거니 하고 기대하고 있겠지요. 아래와 같은 API 가 있다면,</p>

<pre><code class="language-scala">def createTask[A](f: Connection =&gt; A): Task[A]  
def addPostCommitAction(action: Action): Task[Unit]  
def run[A](task: Task[A]): Option[A]  
</code></pre>

<p>사용자들이 이런 방식으로 사용할 수 있습니다.</p>

<pre><code class="language-scala">case class Person(name: String, address: Address)  
case class Address(street: String)

def getPerson(name: String): Task[Person] = createTask { conn =&gt;  
  val rs: ResultSet = conn.executeAndReturn(s"SELECT * FROM USER WHERE name == '$name'")

  /* get a person using the result set */
  ...
}

def updateAddress(person : Person): Task[Unit] = createTask { conn =&gt;  
  /* do something */
  conn.execute(
    s"UPDATE ADDRESS SET street = '${person.address.street}' where person_name = '${person.name}'")
}

val getAndUpdatePersonTask: Task[Person] = for {  
  p &lt;- getPerson("1ambda")
  updatedP = p.copy(address = Address("BACON STREET 234"))
  _ &lt;- addPostCommitAction(() =&gt; println("post commit action1"))
  _ &lt;- updateAddress(updatedP)
  _ &lt;- addPostCommitAction(() =&gt; println("post commit action2"))
} yield updatedP

val person: Option[Person] = Database.run(getAndUpdatePersonTask)  
</code></pre>

<p>이제 상상했던 함수를 구현해 보면,</p>

<pre><code class="language-scala">// https://github.com/1ambda/scala/blob/master/learning-scalaz/src/main/scala/readerwriterstate/Database.scala

import java.util.UUID  
import scalaz._, Scalaz._  
import Database._  
import com.github.nscala_time.time.Imports._

object Database {

  ...
  object Implicit {
    implicit def defaultConnection: Connection = Connection(genRandomUUID)
    implicit def defaultConfig = DatabaseConfig(500)
  }

  private def genRandomUUID: String = UUID.randomUUID().toString

  private def execute[A](f: =&gt; A, conf: DatabaseConfig): A = {
    val start = DateTime.now

    val a = f

    val end = DateTime.now

    val time: Long = (start to end).millis

    if (time &gt; conf.operationTimeoutMillis)
      throw OperationTimeoutException(s"Operation timeout: $time millis")

    a
  }

  def createTask[A](f: Connection =&gt; A): Task[A] =
    ReaderWriterState { (conf, conn) =&gt;
      val a = execute(f(conn), conf)
      (Vector(s"Task was created with connection[${conn.id}]"), a, conn)
    }

  def addPostCommitAction(action: Action): Task[Unit] =
    ReaderWriterState { (conf, conn: Connection) =&gt;

      val postCommitAction = PostCommitAction(genRandomUUID, action)
      (Vector(s"Add PostCommitAction(${postCommitAction.id})"),
        Unit,
        conn.copy(actions = conn.actions :+ postCommitAction))
    }

  def run[A](task: Task[A])
            (implicit defaultConf: DatabaseConfig, defaultConn: Connection): Option[A] = {

    \/.fromTryCatchThrowable[(Vector[String], A, Connection), Throwable](
      task.run(defaultConf, defaultConn)
    ) match {
      case -\/(t) =&gt;
        println(s"Operation failed due to ${t.getMessage}") /* logging */
        none[A]

      case \/-((log: Vector[String], a: A, conn: Connection)) =&gt;
        conn.commit /* close connection */

        log.foreach { text =&gt; println(s"[LOG] $text")} /* logging */

        /* run post commit actions */
        conn.actions foreach { _.action() }

        a.some
    }
  }
</code></pre>

<p>이제 실제로 <em>500 ms</em> 를 초과하는 연산을 실행하면, 예외가 발생하는 것을 확인할 수 있습니다.</p>

<pre><code class="language-scala">  test("Database example") {

    val slowQuery: Task[Person] = createTask { conn =&gt;
      sleep(600)
      Person("Sherlock", Address("BACON ST 221-B"))
    }

    val getPeopleTask: Task[List[Person]] = for {
      p1 &lt;- getPerson("Mycroft")
      p2 &lt;- getPerson("Watson")
      p3 &lt;- slowQuery
      _ &lt;- addPostCommitAction(() =&gt; println("post commit1"))
    } yield p1 :: p2 :: p3 :: Nil

    import Database.Implicit._
    val people = Database.run(getPeopleTask)

    // log: Operation failed due to java.lang.RuntimeException: Operation timeout: 603 millis
    people shouldBe None
}
</code></pre>

<h2 id="previousposts">Previous Posts</h2>

<ul>
<li><a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1, State</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/">Easy Scalaz 2, Monad Transformer</a></li>
</ul>

<h2 id="references">References</h2>

<ul>
<li><a href="http://cs.lth.se/edan40">Haskell Image</a></li>
<li><a href="https://coderwall.com/p/ye_s_w/tooling-the-reader-monad">Tooling The Reader Monad</a></li>
<li><a href="http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/">Reader Monad For Dependency Injection</a></li>
<li><a href="http://slides.com/danielbedo/reader-monad">Slideshare: Reader Monad</a></li>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia Image</a></li>
<li><a href="http://docs.scala-lang.org/overviews/collections/performance-characteristics.html">Scala Collection Performance Characteristics</a></li>
</ul>
    </section>

    <footer>
      <section class="author_info margin_top_big">
        <div class="alignleft border rad_circle" style="height: 87px; width: 87px; background-image: url(http://www.gravatar.com/avatar/aa2032ba2302419e3c2ede54f1fbf687?d=404&amp;s=250); background-size: cover;"></div>
        <p class="margin_left_medium text small">Author</p>
        <p class="margin_left_medium text bold"><a href="http://1ambda.github.io">1ambda</a></p>
        <p class="margin_left_medium text small">Functional, Scala, Akka, Rx and Haskell</p>
      </section>
    </footer>


    <div id="disqus_thread" class="margin_top_big"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = '1ambda'; // required: replace example with your forum shortname
  var disqus_identifier = '134';
  var disqus_url = 'http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/';

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
    </article>
</main>


  <script src="../assets/fitvids/jquery.fitvids.js"></script>
<script>
$(document).ready(function(){
  // Target your .container, .wrapper, .post, etc.
  $("section").fitVids();
});
</script>

  <footer class="blog_info margin_top_big padding_medium text center">
    <h5 class="text book small">© 2015 <a href="../">Old Lisper</a>. All rights reserved.</h5>
    <h5 class="text book small"><a href="https://github.com/dreyacosta/velox" target="_blank" class="text bold">Velox theme</a> by <a href="http://dreyacosta.com/">David Rey</a></h5>
    <h5 class="text book small">Proudly published with <a href="http://ghost.org"><span>Ghost</span></a></h5>

  </footer>

  <script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = '1ambda'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function () {
 var s = document.createElement('script'); s.async = true;
 s.type = 'text/javascript';
 s.src = '//' + disqus_shortname + '.disqus.com/count.js';
 (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
 }());
</script>


  </body>
  