<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/Blog">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

  <title>Graph Challenges, Minimum Spanning Trees, Shortest Paths</title>
  <meta name="description" content="" />

  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Graph Challenges, Minimum Spanning Trees, Shortest Paths">
  <meta name="twitter:description" content="Graph Process Challenge 1 Is a graph bipartite? 그래프가 bipartite 인가 하는 문제는, 그래프의 노드를 이렇게 두 그룹으로 나눌 수 있느냐 하는 문제다. (http://en.wikipedia.org) 알고리즘이 얼마나 어려운가는 이렇게 나눠볼 수 있겠는데 Any programmer could do it   Typical diligen algorithms student could do it   Hire an expert   Intractable">
  <meta name="twitter:creator" content="@yourTwitterUsername">
  <meta name="twitter:image" content="">
  <meta name="twitter:url" content="http://1ambda.github.io/graph-challenges-minimum-spanning-trees/">
  <meta name="twitter:domain" content="http://1ambda.github.io">

  

  <link rel="author" href="https://plus.google.com/101105410053351451441?rel=author" />

  <link rel="shortcut icon" href="../favicon.ico">

  <link rel="stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Droid+Serif" />
  <link rel='stylesheet' type='text/css' href="http://fonts.googleapis.com/css?family=Open+Sans:600,300" />
  <link rel="stylesheet" type="text/css" href="../assets/stylesheets/xpressio.css" />
  <link rel="stylesheet" type="text/css" href="../assets/1ambda/1ambda.css" />
  <script type="text/javascript" src="../assets/1ambda/modernizr.js">
  </script>
  <script type="text/javascript" src="../assets/1ambda/detectizr.min.js">
  </script>

  <!--load css if windows -->
  <script type="text/javascript">
    if (Modernizr.windows) {
      file = location.pathname.split( "/" ).pop();
      link = document.createElement( "link" );
      link.href = "/assets/1ambda/1ambda_windows.css";
      link.type = "text/css";
      link.rel = "stylesheet";
      link.media = "screen,print";
      document.getElementsByTagName("head")[0].appendChild( link );
    }
  </script>


  
  <link rel="stylesheet" href="../assets/highlight/styles/github.css">
<script src="../assets/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


  <meta name="generator" content="Ghost 0.5" />
<link rel="alternate" type="application/rss+xml" title="Old Lisper" href="../rss">
<link rel="canonical" href="http://1ambda.github.io/graph-challenges-minimum-spanning-trees/" />

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52181619-1', '1ambda.github.io');
  ga('send', 'pageview');
</script>

  
</head>
<body>

  
  <script src="../public/jquery.js?v=72f001fdfc"></script>

  

<header class="site_width text center padding_top_big margin_bottom_big">
  
  <h1 class="blog_title margin_bottom_small"><a href="http://1ambda.github.io">Old Lisper</a></h1>
  <h4 class="text book">Functional Programming</h4>
  
  <div class="social border solid top_small bottom_small padding_medium">
  <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="/about-me"><i class="fa fa-user"></i> <span class="margin_left_small desktop">About me</span></a></h6>
  <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="http://kr.linkedin.com/in/1ambda" target="_blank"><i class="fa fa-linkedin-square"></i> <span class="margin_left_small desktop">Linkedin</span></a></h6>
  <h6 class="text book color c_black_medium without_margin"><a href="http://github.com/1ambda" target="_blank"><i class="fa fa-github"></i> <span class="margin_left_small desktop">GitHub</span></a></h6>
</div>

</header>

<main class="site_width" role="main">
  <article class="post tag-algorithm tag-coursera tag-graph tag-minimum-spanning-tree tag-shortest-path">

    

    <header class="text center margin_bottom_medium">
      <h5 class="text book small uppercase color c_black_light margin_bottom_small">Posted in <a href="../tag/algorithm">Algorithm</a>, <a href="../tag/coursera">coursera</a>, <a href="../tag/graph">graph</a>, <a href="../tag/minimum-spanning-tree">minimum spanning tree</a>, <a href="../tag/shortest-path">shortest-path</a></h5>
      <h1 class="margin_bottom_medium">Graph Challenges, Minimum Spanning Trees, Shortest Paths</h1>
      <h5 class="text book small uppercase color c_black_light margin_bottom_small"><time datetime="2014-12-03">Wednesday, December 03, 2014</time>
      <br/><br/>
       <a href="http://1ambda.github.io/graph-challenges-minimum-spanning-trees/#disqus_thread">Comment</a>
      </h5>
    </header>

    <section>
      <h3 id="graphprocesschallenge1">Graph Process Challenge 1</h3>

<h4 id="isagraphbipartite">Is a graph bipartite?</h4>

<p>그래프가 <em>bipartite</em> 인가 하는 문제는, 그래프의 노드를 이렇게 두 그룹으로 나눌 수 있느냐 하는 문제다.</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/e/e8/Simple-bipartite-graph.svg/330px-Simple-bipartite-graph.svg.png" alt="" /></p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Biclique_K_3_5.svg/330px-Biclique_K_3_5.svg.png" alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org'>http://en.wikipedia.org</a>)</p>

<p>알고리즘이 얼마나 어려운가는 이렇게 나눠볼 수 있겠는데</p>

<ol>
<li>Any programmer could do it  </li>
<li>Typical diligen algorithms student could do it  </li>
<li>Hire an expert  </li>
<li>Intractable  </li>
<li>No one knows  </li>
<li>Impossile</li>
</ol>

<p><em>biparting</em> 문제는 <em>DFS-based solution</em> 을 이용할 수 있으므로, 난이도 2정도에 해당한다 볼 수 있겠다. </p>

<p>생각해 볼 수 있는 응용은, 질병의 전파 경로를 그래프로 그리고 <em>biparting</em> 이 가능한지 보는 것이다.</p>

<h4 id="findacycle">Find a cycle</h4>

<p>이것도 난이도 (2) 정도. 마찬가지로 <em>simple DFS-based solution</em> 을 이용하자.</p>

<p>잘 알려진 응용으로, <em>euler tour</em> 가 있다. 각 <em>edge</em> 를 단 한번씩만 방문하는 <em>cycle</em> 이 있는지를 검사하는 문제다. 여기서 시작점과 끝 점이 같으면 <em>euler circuit</em> 이고, 다르면 <em>euler path</em> 라 부른다.</p>

<p><a href="http://ko.wikipedia.org/wiki/%EC%98%A4%EC%9D%BC%EB%9F%AC_%EA%B2%BD%EB%A1%9C">여기</a>에 의하면 그래프에 오일러 회로가 존재하려면 </p>

<p>(1) 연결된 그래프여야 하고 <br />
(2) 모든 꼭지점의 차수가 짝수여야 한다.</p>

<p>반면 오일러 경로라면, 연결그래프에서 정확히 두 개의 꼭지점만 홀수 차수여야 한다.</p>

<p>각 <em>node</em> 를 정확히 한번씩만 지나는 <em>cycle</em> 을 <em>traveling salesman problem, TSP</em> 혹은 <em>hamiltonian path problem</em> 이라 부른다.</p>

<p>오일러 순회와 경로처럼 시작점과 끝점이 같은지, 아닌지에 따라 구분할 수 있다. <em>hamiltonian cycle</em> 은 전형적인 <em>NP-complete problem</em> 으로 알려져있다. 난이도로 구분하자면 <em>(4) intractable</em> 정도 되시겠다.</p>

<h4 id="graphisomorphismproblem">Graph Isomorphism Problem</h4>

<blockquote>
  <p>Are two graphs identical except for vertex names?</p>
</blockquote>

<p>그래프의 형태가 같은지 묻는 문제다. 예를 들어 다음의 두 그래프는 같은 형태다.</p>

<p><img src="http://www.biodatamining.org/content/figures/1756-0381-4-10-3-l.jpg" alt="" /></p>

<p align="center">(<a href='http://www.biodatamining.org/'>http://www.biodatamining.org/</a>)</p>

<p>두 그래프의 노드를 <code>n!</code> 으로 배열해 가면서 같은지 비교하는 단순한 방법은 그래프가 커지면 기하 급수적으로 성능이 느려진다. 더 나은 알고리즘이 있는지 연구자들이 노력하고 있지만, 아직 모른다. 난이도는 <em>(5) No one knows</em></p>

<h4 id="graphsplanarity">Graphs Planarity</h4>

<p>그래프를 <em>crossing edge</em> 가 없는 그래프로 그릴 수 있느냐 하는 문제다.</p>

<blockquote>
  <p>평면 그래프(planar graph)는 평면 상에 그래프를 그렸을 때, 두 변이 꼭지점 이외에 만나지 않도록 그릴 수 있는 그래프를 의미한다.</p>
</blockquote>

<p>이건 난이도 <em>(3) Hier an expert</em> 문제다. <em>DFS</em> 기반의 <em>linear time</em> 알고리즘이 1970년대에 발표되었다.</p>

<h3 id="minimumspanningtrees">Minimum Spanning Trees</h3>

<p><em>undirected, positive edge weights</em> 그래프에서 </p>

<p>(1) <em>connected, acyclic</em> <strong>(tree)</strong> <br />
(2) <em>includes all of the vertices</em> <strong>(spanning)</strong>   </p>

<p>인 서브 그래프를 <strong><em>spanning tree</em></strong> 라 부른다.</p>

<p><strong><em>minimum spanning tree</em></strong> 는 여기서 <em>min weight</em> 를 갖는 <em>spanning tree</em> 를 찾는 문제다.</p>

<h4 id="applications">Applications</h4>

<ul>
<li>dithering</li>
<li>cluster analysis</li>
<li>max bottleneck paths</li>
<li>network design</li>
</ul>

<p>등에 활용할 수 있다.</p>

<h3 id="mstgreedyalgorithm">MST: Greedy Algorithm</h3>

<p>간단한 설명을 위해서 그래프가 연결되어있고 <em>weight</em> 가 모두 다르다 하자. 그럼 <em>MST</em> 는 하나만 존재할 것이다.</p>

<p>먼저 <em>cut, crossing edge</em> 용어 정리를 하면</p>

<blockquote>
  <p><strong>Cut:</strong> A cut is a graph is a partition of its vertices into two (nonempty) sets</p>
  
  <p><strong>Crossing edge:</strong> A crossing edge connects a vertex in one set with a vertex in the other</p>
</blockquote>

<p>그러면, 이런 <em>cut property</em> 가 존재한다.</p>

<blockquote>
  <p>Given any <strong>cut</strong>, the crossing edge of min weight is in the MST</p>
</blockquote>

<p>증명은 <em>min-weight crossing edge</em> <code>e</code> 가 <em>MST</em> 내에 없다고 하자. <em>MST</em> 는 연결되야 하므로 다른 <em>crossing edge</em> <code>f</code> 가 대신 사용될 것이다. </p>

<p>(1) 다른 <em>crossing edge</em> <code>f</code> 가 없으면 <em>connected</em> 가 아니므로 <em>MST</em> 가 아니다. <br />
(2) 만약 <code>f</code> 가 있어서 <code>f</code> 를 대신 사용하는 <em>MST</em> 에 <code>e</code> 를 추가하면 사이클이 생긴다. 이 때 <code>f</code> 를 제거하면 <em>weight</em> 가 더 짧다. 따라서 <code>f</code> 가 포함되면 <em>MST</em> 가 아니다.</p>

<p>따라서 <em>min-weight crossing edge</em> 가 <em>MST</em> 내에 존재한다. 이 사실을 이용하면 <em>MST</em> 를 찾는 <em>greedy algorithm</em> 을 만들 수 있다.</p>

<pre><code>- Start with all edges colored gray
- Find cut with no black corssing edges; 
   color its min-weight edge black
- Repeat until V - 1 edges are colored black
</code></pre>

<p>즉 어떤 <em>cut</em> 에 대해서 <em>min-weight crossing edge</em> 가 <em>MST</em> 에 포함되므로, 이미 찾은 <em>MST edge</em> 를 포함하지 않는 <em>cut</em> 을 찾아, <em>min-weight crossing edge</em> 을 추가해 나가면 된다.</p>

<h4 id="correcteness">Correcteness</h4>

<p>(1) Any edge colored black is in the MST (vis cut property) <br />
(2) Fewer than <code>V - 1</code> black edges => cut with no black crossing edges</p>

<p>모든 <em>MST</em> 는 <code>V - 1</code> 개의 <em>edge</em> 로 구성된다. 따라서 <code>V - 1</code> 개의 <em>black edge</em>, 즉 <em>MST</em> 의 원소를 찾아내면 된다. </p>

<h3 id="edgeweightedgraphapi">Edge-Weighted Graph API</h3>

<pre><code class="java">public class Edge implements Comparable&lt;Edge&gt; {  
  Edge(int v, int w, double weight)
  int either()
  int other(int v)
  int compareTo(Edge that)
  ...
}

// allow self-loops and parallel edges
public class EdgeWeightedGraph {  
  EdgeWeightedGraph(int V) // V vertices
  void addEdge(Edge e)
  Iterable&lt;Edge&gt; adj(int v) // edges incident to v
  Iterable&lt;Edge&gt; edges() // all edges
  Int V() // # of vertices
  int E() // # of edges
}

public class MST {  
  MST(EdgeWeigtedGraph G)
  Iterable&lt;Edge&gt; edges()
  double totalWeight()
}
</code></pre>

<h4 id="removingassumptions">Removing assumptions</h4>

<ul>
<li>What if edge weights are not all distinct?</li>
</ul>

<blockquote>
  <p>Greedy MST algorithm still correct if equal weights are present. (our correctness proof fails, but that can be fixed)</p>
</blockquote>

<ul>
<li>What if graph is not connected?</li>
</ul>

<blockquote>
  <p>Compute MS forest = MST of each components</p>
</blockquote>

<h3 id="kruskalsalgorithm">Kruskal's Algorithm</h3>

<pre><code>- Sort edges in ascending order of weight. 
- Add next edge to tree T 
  unless doing so would create a cycle 
  (until V - 1 edges added) 
</code></pre>

<p><em>kruskal's algorithm</em> 은 <em>greedy MST</em> 의 일종이라 볼 수 있다.</p>

<p>선택된 <em>edge</em> <code>e = v &lt;-&gt; w</code> 라 하고 이것을 <em>crossing edge</em> (<em>cut</em> 이라 볼 수 있다), 하면 </p>

<p><em>black edge</em> 간 <em>no cycle</em> 인 <code>e</code> 를 선택한 것이므로 <code>v &lt;-&gt; w</code> 사이엔 <em>black crossing edge</em> 가 없다. </p>

<p>게다가 선택하는 <em>crossing edge</em> 는 가장 작은 <em>weight</em> 를 가진다. 이 전에 이미 더 작은 <em>weight</em> 의 <em>edge</em> 를 모두 선택했기 때문이다.</p>

<p>따라서 크루스칼 알고리즘은 <em>greedy MST</em> 의 일종이다.</p>

<h4 id="cyclecheck">Cycle Check</h4>

<p>어떻게 <em>Cycle check</em> 를 할까? 한 가지 방법은 <em>edge <code>e = v - w</code></em> 에 대해 <code>v - w</code> 가 연결되어있는지 <em>DFS</em> 를 돌리면 된다. 그러면 <code>O(V)</code> 로 사이클을 검사할 수 있다.</p>

<p>단순히 연결되어있는지만 검사하는 것이므로 <em>union find</em> 를 쓰면 <code>O(log* V)</code> 로도 가능하다. <a href="http://1ambda.github.io/union-find-algorithms-week-1/">Union-find</a> 를 참고하자.</p>

<h4 id="kruskalmstimplementation">Kruskal MST Implementation</h4>

<pre><code class="java">EdgeWeightedGraph G;  
int V = G.V()  
UF uf = new UF(V);

Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;();  
MinPQ&lt;Edge&gt; pq = new MinQP&lt;Edge&gt;();

for (Edge e : G.edges())  
  pq.enqueue(e);

while (!pq.isEmpty() &amp;&amp; mst.size() &lt; V - 1) {  
  Edge e = pq.dequeue();
  int v = e.either();
  int w = e.other(v);

  if (!uf.connected(v, w)) {
    uf.union(v, w);
    mst.enqueue(e);
  }
}
</code></pre>

<p><em>running time</em> 은 <code>E log E</code> 다. </p>

<ul>
<li>build <code>pq</code>: <code>1 * E</code></li>
<li>dequeue: <code>E * log E</code></li>
<li>union: <code>V * log* V</code></li>
<li>connected: <code>E * log* V</code> </li>
</ul>

<h3 id="primsalgorithm">Prim's Algorithm</h3>

<pre><code>- start with vertex 0 and greedily grow tree T
- add to T the min weight edge with exactly one endpoint in T
- repate until V - 1 edge
</code></pre>

<h4 id="correctness">Correctness</h4>

<p>마찬가지로 <em>prim's algorithm</em> 도 <em>greedy MST</em> 의 일종이다.</p>

<p>방문한 노드와 방문하지 않은 노드를 <em>cut</em> 해 거기서 <em>min-weight edge</em> 를 선택한다. 따라서 <em>cut</em> 자체가 방문하지 않은 노드와 방문한 노드 두 집합을 만드므로 <em>crossing edge</em> 중에는 <em>black edge</em> 가 없다. </p>

<h4 id="primmstimplementation">Prim MST Implementation</h4>

<p><em>lazy implementation</em> 으로 현재 선택할 수 있는 <em>edge</em> 를 <em>weight</em> 기준으로 <em>priority queue</em> 에 유지하는 방법이 있다.</p>

<p><em>queue</em> 에 있는 <em>edge</em> <code>e = (v, w)</code> 를 꺼낸 뒤</p>

<p>(1) <code>v, w</code> 둘 다 이미 방문했으면 패스하고, <br />
(2) <code>v</code> 혹은 <code>w</code> 둘 중 하나만 방문했을 경우에만 <code>w or v</code> 의 <em>edge</em> 를 추가하고, <code>w or w</code> 를 방문 처리 한다. </p>

<pre><code class="java">// lazy Prim MST

boolean[] marked // MST vertices  
Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;();  
MinPQ&lt;Edge&gt; pq = new MinPQ&lt;Edge&gt;();  
WeightedGraph G;

visit(G, 0);

while (!pq.isEmpty()) {  
  Edge e = pq.dequeue();
  int v = e.either();
  int w = e.other(v);

  if (marked[v] &amp;&amp; marked[w]) continue;

  mst.enqueue(e);

  // add v or w
  if (!marked[v]) visit(G, v);
  if (!marked[w]) visit(G, w);
}

void visit(int v) {  
  marked[v] = true;
  for (Edge g : G.adj(v)) {
    if (!marked[e.other(v)]) pq.insert(e);
  }
}
</code></pre>

<p><em>running time</em> 은 <code>O(E log E)</code> 다.</p>

<p>좀 더 나은 알고리즘은 <em>MST</em> 에 <em>edge</em> <code>e = (v, w)</code> 를 추가할때, 이미 방문한 <code>w</code> 와 방문하지 않은 <code>v</code> 에 대해</p>

<p><code>v</code> 에서 갈 수 있는 모든 <em>edge</em> <code>e = (v, x)</code> 을 생각해 보면, </p>

<p>(1) <code>x</code> 가 이미 방문한 <em>vertex</em> 면 패스 <br />
(2) <em>queue</em> 에 <code>(k, x)</code> 가 없으면 추가 (<code>k</code> 는 이미 방문한 <em>vertex</em>) <br />
(3) <code>x</code> 까지의 거리가, <code>e = (v, x)</code> 가 더 짧으면 업데이트 (<em>decreaseKey operation</em>)</p>

<p>여기서 <code>decreaseKey</code> 연산을 빠르게 구현하기 위해 <em>indexed priority queue</em> 를 이용할 수 있다.</p>

<pre><code>void decreaseKey(int i, Key key)  
</code></pre>

<p>전체 러닝타임은 </p>

<ul>
<li><code>V</code> <em>insert</em></li>
<li><code>V</code> <em>delete min</em></li>
<li><code>E</code> <em>decrease key</em></li>
</ul>

<p>인데, <em>Priority Queue</em> 구현하는데 어떤 자료구조를 사용하느냐에 따라 각 연산의 시간이 달라진다.</p>

<p>(1) Array implementation optimal for dnse graph  </p>

<p>O(<code>V^2</code>)</p>

<p>(2) Binary heap much faser for sparse graphs  </p>

<p>O(<code>E log V</code>)</p>

<p>(3) 4-way heap worth the trouble in performance-critical situations  </p>

<p>O(<code>E log_(1/V) V</code>)</p>

<p>(4) Fibonacchi heap best in theor, but not worth implementing  </p>

<p>O(<code>E + V log V</code>)</p>

<h3 id="mstcontext">MST Context</h3>

<p><em>linear time MST</em> 알고리즘이 있을까? 1995년에 <em>linear time randomized MST</em> 가 발견 되었지만 <em>deterministic</em> 알고리즘은 여전히 연구중이다.</p>

<h3 id="shortestpathsapi">Shortest Paths API</h3>

<pre><code class="java">public class Directed Edge {

  DirectedEdge(int v, int w, deouble weight)
  int from()
  int to()
  double weight()
}

// allow self-loop, parallel
public class EdgeWeightedDigraph {

  EdgeWeightedDigraph(int V)
  void addEdge(DirectedEdge e)
  Iterable&lt;DirectedEdge&gt; adj(int v)
  int V() // # of vertices
}

// shortest path
public class SP {

  SP(EdgeWeightedDigraph G, int s)
  double distTo(int v)
  Iterable &lt;DirectedEdge&gt; pathTo(int v)
}
</code></pre>

<h3 id="shortestpathproperties">Shortest Path Properties</h3>

<p><em>directed, weighted graph</em> 에서 <em>shortest path tree, SPT</em> 가 존재하는데, 이는 <em>cycle</em> 이면 <em>shortest</em> 가 될 수 없기 때문이다.</p>

<p>위에서 본 <code>pathTo</code> 함수는 이렇게 구현할 수 있다.</p>

<pre><code class="java">// edgeTo[v] is last edge on shortest path from s to v
public Iterable&lt;DirectedEdge&gt; pathTo(int v) {  
  Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;();
  for (DirectedEdge e = edgeTo(v); e != null; e = edgeTo(e.from())
    path.push(e);

  return path;
}
</code></pre>

<h4 id="edgerelaxation">Edge relaxation</h4>

<p><em>relax edge <code>e = v -&gt; w</code></em>,</p>

<ul>
<li><code>distTo[v]</code> is length of shortest known path from <code>s</code> to <code>v</code></li>
<li><code>distTo[w]</code> is length of shortest known path from <code>s</code> to <code>w</code></li>
<li><code>edgeTo[w]</code> is last edge on shortest known path from <code>s</code> to <code>w</code></li>
</ul>

<p>여기서 만약 <code>e = v -&gt; w</code> 가 <code>w</code> 로의 더 짧은 거리라면, <code>distTo[w]</code> 와 <code>edgeTo[w]</code> 를 업데이트하면 된다.</p>

<p><img src="http://www.csupomona.edu/~ftang/courses/CS241/notes/images/graph/relax1.jpg" alt="" title="" />  </p>

<p><img src="http://faculty.ycp.edu/~dbabcock/PastCourses/cs360/lectures/images/lecture21/relaxation.png" alt="" /></p>

<p align="center">(<a href='http://www.csupomona.edu/~ftang'>http://www.csupomona.edu/~ftang</a>)</p>

<pre><code class="java">void relax(DirectedEdge e) {  
  int v = e.from();
  int w = e.to();

  if (distTo(w) &gt; distTo(v) + e.weight()) {
    distTo[w] = distTo[v] + e.weight();
    edgeTo[w] = e;
  }
}
</code></pre>

<h4 id="shortestpathsoptimalityconditions">Shortest-paths optimality conditions</h4>

<blockquote>
  <p>Let <code>G</code> be an edge-weighted digraph, then <code>distTo[]</code> are the shortest path distance from s iff:</p>
</blockquote>

<ul>
<li><code>distTo[s]</code> = 0</li>
<li>For each vertex <code>v</code>, <code>distTo[v]</code> is the length of some path from <code>s</code> to <code>v</code></li>
<li>For each edge <code>e = v -&gt; w</code>, <code>distTo[w] &lt;= distTo[v] + e.weight()</code></li>
</ul>

<p><strong>necessary condition</strong> </p>

<p>만약 어떤 <code>e = v -&gt; w</code>에 대해 <code>distTo[w] &gt; distTo[v] + e.weight()</code> 이면, <code>e</code> 를 이용한 <code>w</code> 까지의 거리가 <code>distTo[w]</code> 보다 더 짧다. 그러면 <code>distTo[w]</code> 는 <em>shortest path</em> 가 아니다.</p>

<p><strong>sufficient condition</strong></p>

<ul>
<li>Suppose <code>s = v0 -&gt; v1, ... -&gt; vk = w</code> is a shortest path from <code>s</code> to <code>v</code></li>
</ul>

<p>그러면</p>

<pre><code>distTo[v1] &lt;= distTo[v0] + e1.weight();  
...
distTo[vk] &lt;= distTo[v_k-1] + ek.weight(); 

// e_i is, i th edge on shortest path from s to w
</code></pre>

<p>이제 <code>distTo[v] = 0</code> 이라 하면</p>

<p><code>distTo[w] &lt;= e1.weight + ..., + ek.weight()</code></p>

<p>이 때 우변이 <em>shortest path</em> 위에 있는 <em>edge</em> 의 <em>weight</em> 값이므로, <code>distTo[w]</code> 는 <code>w</code> 까지의 <em>shortest path</em> 다.</p>

<p>(여기서는 필요충분조건 <code>p &lt;=&gt; q</code> 를 증명하기 위해 <code>p -&gt; q</code>, <code>q -&gt; p</code> 를 증명했다.)</p>

<h4 id="genericshortestpathsalgorithm">Generic Shortest-paths Algorithm</h4>

<pre><code>initialize distTo[s] = 0 and distTo[v] = infinity for all other vertices

Repeat until optimality conditions are satisfied,  
  Relax any edge
</code></pre>

<p>어떤 <em>edge</em> 를 고를까 하는 문제로 발전할 수 있다.</p>

<p>(1) <em>Dijkstra's algorithm</em>: <strong>non-negative weights</strong> <br />
(2) <em>Topological sort</em>: <strong>no directed cycles</strong> <br />
(3) <em>Bllman-Ford algorithm</em>: <strong>no negative cycles</strong></p>

<h3 id="dijkstrasalgorithm">Dijkstra's Algorithm</h3>

<pre><code>- Consider vertices in increasing order of dinstance from s
  (non-tree vertex with the lowest distTo[] value)

- Add vertex to tree and relax all edges pointing from that vertex
</code></pre>

<h4 id="correctness">Correctness</h4>

<blockquote>
  <p>Dijkstra's algorithm computes a SPT in any edge-weighted digraph with non-negative weights</p>
</blockquote>

<p>모든 <code>e = v -&gt; w</code> 는 단 한번씩만 <em>relaxed</em> 되기 때문에 알고리즘은 언젠간 종료된다. (<code>v</code> 가 <code>T</code> 에 추가되었을 때) </p>

<p>그리고 이 과정에서 <code>distTo[w] &lt;= distTo[v] + e.weight()</code> 가 유지된다. 왜냐하면 <code>distTo[w]</code> 는 줄어들기만 하고, <em>weight</em> 가 음수인 <em>edge</em> 가 없기 때문에 <code>distTo[v]</code> 는 변함이 없기 때문이다. </p>

<pre><code class="java">DirectedEdge[] edgeTo;  
double[] distTo;  
IndexMinPQ&lt;Double&gt; pq;

void DijkstraSP(EdgeWeightedDigraph G, int s) {  
  int V = G.V();
  edgeTo = new DirectedEdge[V];
  distTo = new double[V];
  pq = new IndexMinPQ&lt;Double&gt;(V);

  for(int v = 0; v &lt; V; v++) {
    distTo[v] = Double.POSITIVE_INFINITY;
  }

  distTo[s] = 0.0;
  pq.insert(s, 0.0);

  while (!ps.isEmpty()) {
    int v = pq.dequeue();
    for(DirectedEdge e: G.adj(v))
      relax(e);
  }
}

void relax(DirectedEdge e) {  
  int v = e.from();
  int w = e.to();

  if (distTo[w] &gt; distTo[v] + e.weight()) {
    distTo[w] = distTo[v] + e.weight();
    edgeTo[w] = e;

    if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
    else pq.insert(w, distTo[w]);
  }
}
</code></pre>

<p>프림 알고리즘과 마찬가지로 </p>

<p><code>T(n) = V insert + V delete-min + E decrease key</code> 인데, 이 연산들은 <em>Priority Queue</em> 구현에 따라 다를 수 있다. </p>

<p><em>undordered array</em> 라면 <code>V^2</code>, <em>binary heap</em> 이라면 <code>E log V</code> </p>

<p>따라서 <em>dense graph</em> 에서는 <em>array</em> 를, <em>sparse graph</em> 라면 <em>binary heap</em> 이 낫다.</p>

<h4 id="dijkstraandprim">Dijkstra and Prim</h4>

<p>둘 다 <em>spanning tree</em> 를 만들어 낸다. </p>

<ul>
<li>다익스트라는 <em>directed path</em> 에서 <em>source</em> 에서 가장 가까운 <em>vertex</em> 를 선택한다면, </li>
<li>프림 알고리즘은 <em>undirected edge</em> 내 에서 <em>tree</em> 에서 가장 가까운 <em>vertex</em> 를 선택한다.</li>
</ul>

<h3 id="edgeweighteddags">Edge-Weighted DAGs</h3>

<p><em>cycle</em> 이 없는 그래프는 <em>shortest path</em> 를 찾기 더 쉽다.</p>

<p><em>toplogical order</em> 순서로 <em>relaxing</em> 해 가면 된다. 어차피 방문 자체는 <em>topological order</em> 로 해야만 모든 <em>vertex</em> 를 방문할 수 있기 때문이다. </p>

<p>이 알고리즘에서 재미난 점은 음수 <em>weight</em> 가 있던 말던 상관이 없다는 것이다.</p>

<blockquote>
  <p>Topological sort algorithm computes SPT in <strong>any</strong> edge-weighted DAG in time proprotional to <code>E + V</code></p>
</blockquote>

<p>다익스트라와 마찬가지로 모든 <em>edge <code>e = v -&gt; w</code></em> 는 단 한번만 <em>relaxed</em> 되고, 이 과정에서 <code>distTo[w] &lt;= distTo[v] + e.weight()</code> 다.</p>

<p>(1) <code>distTo[w]</code> 는 줄어들기만 하고, <br />
(2) <em>topological order</em> 이기 때문에 한번 방문된 <code>v</code> 에 대해 이후의 <em>vertex</em> 에서 <code>v</code> 로 갈 수 없다. 있다면 <em>cycle</em> 이고 그럼 <em>toplogical order</em> 가 안된다. 따라서 <code>distTo[v]</code> 는 변하지 않는다. 따라서 <em>weight</em> 가 음수든 양수든 상관이 없다.</p>

<pre><code class="java">DirectedEdge[] edgeTo;  
double[] distTo;

public AcyclicSP(EdgeWeightedDigraph G, int s) {  
  int V = G.V();
  edgeTo = new DirectedEdge[V];
  distTo = new double[V];

  for(int v = 0; v &lt; V; v++) {
    distTo[v] = Double.POSITIVE_INFINITY;
  }

  distTo[s] = 0.0;

  Topological t = new Topological(G);

  for (int v : t.order()) {
    for (DirectedEdge e : G.adj(v)) {
      relax(e);
    }
  }
}
</code></pre>

<p>응용으로 <em>seam carving</em> 이 있다. 수직이나 수평으로 <em>shortest path</em> 를 찾아서 제거하면 된다.</p>

<p><img src="http://rahuldotgarg.appspot.com/data/SeamCarvingWeb/evaluation_files/image002.jpg" alt="" /></p>

<p align="center">(<a href='http://rahuldotgarg.appspot.com'>http://rahuldotgarg.appspot.com</a>)</p>

<p><em>longest path</em> 를 찾는법은 모든 <em>weight</em> 를 <em>negate</em> 하고, 찾고, 다시 결과의 <em>weight</em> 에 마이너스를 붙이면 된다. 이게 가능한 이유는 <em>no cycle</em> 이기 때문에 <em>weight</em> 가 음수든, 양수든 상관이 없기 때문이다.</p>

<p>응용해서 <em>Critical path method, CPM</em> 에 활용할 수 있다.</p>

<p>작업간 의존관계가 있으므로 이를 이용해서 <em>DAG</em> 를 그리면 된다. 각 <em>job</em> 당 <em>start vertex, finish vertex</em> 가 되며, 그 <em>weight</em> 는 <em>duration</em> 으로 하고 한 작업과 다음 작업의 <em>weight</em> 는 <code>0</code> 으로 했을때의 <em>longest path</em> 를 찾으면 된다. </p>

<p><img src="http://algs4.cs.princeton.edu/44sp/images/scheduling-critical-path.png" alt="" /></p>

<p align="center">(<a href='http://algs4.cs.princeton.edu/44sp/'>http://algs4.cs.princeton.edu/44sp/</a>)</p>

<h3 id="negativeweights">Negative Weights</h3>

<p>다익스트라 알고리즘은 <em>negative weight</em> 에 대해서 작동하지 않는다. 모든 <em>weight</em> 에 일정 수 <code>n</code> 을 더해 모두 양수로 만들어도 똑같다. 심지어 이 경우는  <em>shortest path</em> 자체가 바뀐다. 따라서 다른 알고리즘이 필요하다.</p>

<p>진도를 빼기 전에 용어를 좀 정의하고 가면</p>

<p><em>negative cycle</em> 은, <em>directed cycle</em> 내의 모든 <em>weight</em> 를 더했을 때 음수인 경우를 말한다. 이 경우 <em>SPT</em> 는 없다. 이는 쉽게 보일 수 있는데</p>

<p><em>negative cycle</em> 이 존재하면 한번 이 사이클을 돌면, 전체 값이 음수이므로 어느 경로를 택해도 이전보다 더 짧아진다.</p>

<p>따라서 이 사이클을 돌면 내부 <em>vertex</em> 를 무한정 <em>relaxing</em> 할 수 있다.  </p>

<h4 id="bellmanfordalgorihm">Bellman-Ford Algorihm</h4>

<p><em>Bellman-Ford Algorihm</em> 은 <em>negative cycle</em> 이 있는지 검사할 수 있다.</p>

<ul>
<li>Initialize <code>distTo[s] = 0</code> and <code>distTo[v] = inf</code> 
for all other vertice</li>
<li>Repeat V times, relax each Edge</li>
</ul>

<pre><code>for (int i = 0; i &lt; G.V(); i++)  
  for(int v = 0; v &lt; G.V(); v++)
    for(DirectedEdge e: G.adj(v)) // pass i
      relax(e);     
</code></pre>

<p>벨만 포드 알고리즘은 <em>negative cycle</em> 이 없을때 <code>O(E * V)</code> 로 <em>shortest path</em> 를 찾아낸다. </p>

<p>증명은 <a href="http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm#Proof_of_correctness">여기</a>를 참조하도록 하자.</p>

<p>알고리즘을 잘 보면, 한 <em>pass</em> 에서 <code>distTo[v]</code> 가 변하지 않으면 그 이후에도 안 변한다. </p>

<blockquote>
  <p>If <code>distTo[v]</code> does not change during pass <code>i</code>, no need to relax any edge pointing from <code>v</code> in pass <code>i + 1</code></p>
</blockquote>

<p>따라서 <code>distTo[]</code> 가 변화한 <code>v</code> 의 리스트를 유지해서, 이것 대상으로 <em>relax</em> 하면 성능을 더 개선할 수 있다.</p>

<h4 id="findinganegativecycle">Finding a negative cycle</h4>

<p>벨만 포드 알고리즘은 <em>negative cycle</em> 을 찾아내는데 사용할 수도 있다. <em>negative cycle</em> 이 있을 경우 무한히 <em>relax</em> 를 해 내기 때문이다.</p>

<p>따라서 <code>V - 1</code> 까지 진행 한 후 <code>V</code> 번째에서 어느 <em>vertex</em> <code>v</code> 라도 업데이트 된다면, <em>negative</em> 사이클이 있다.</p>

<p><em>negative cycle</em> 은 <em>arbitrage detection</em> 에 사용할 수 있다.</p>

<h3 id="shortestpathcostsummary">Shortest Path Cost Summary</h3>

<p>(1) <strong>Topological Sort:</strong> No directed cycles</p>

<p>다익스트보다 더 빠르고, <em>negative weight</em> 도 문제 없다.</p>

<ul>
<li>typical: <code>E + V</code></li>
<li>worst: <code>E + V</code></li>
<li>extra space: <code>V</code></li>
</ul>

<p>(2) <strong>Dijkstra(binary heap):</strong> No negative weights</p>

<p>거의 <em>linear time</em> 이다.</p>

<ul>
<li>typical: <code>E logV</code></li>
<li>worst: <code>E logV</code></li>
<li>extra space: <code>V</code></li>
</ul>

<p>(3) <strong>Bellman Ford:</strong> No negative cycles</p>

<ul>
<li>typical: <code>E * V</code></li>
<li>worst: <code>E * V</code></li>
<li>extra space: <code>V</code></li>
</ul>

<p>(4) <strong>Bellman Ford(queue):</strong> No directed Cycles</p>

<ul>
<li>typical: <code>E + V</code></li>
<li>worst: <code>E * V</code></li>
<li>extra space: <code>V</code></li>
</ul>

<p><em>SPT</em> 를 정리하면</p>

<p><em>directed cycle</em> 은 문제를 더 어렵게 만들고,
<em>negative weight</em> 도 문제를 더 어렵게 만들고,
<em>negative cycles</em> 는 문제를 풀 수 없게 만든다. (내가 배운 한도 내에서는)</p>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href="http://en.wikipedia.org/wiki/Bipartite_graph">Wikipedia: Bipartite Graph</a> <br />
(3) <a href="http://www.biodatamining.org/content/4/1/10/figure/F3?highres=y">http://www.biodatamining.org/</a> <br />
(4) <a href="http://ko.wikipedia.org/wiki/%ED%8F%89%EB%A9%B4_%EA%B7%B8%EB%9E%98%ED%94%84">Wikipedia: 평면그래프</a> <br />
(5) <a href="http://www.csupomona.edu/~ftang">CS241 Lecture Notes: Graph Algorithms</a> <br />
(6) <a href="http://rahuldotgarg.appspot.com/data/SeamCarvingWeb/evaluation.htm">Seam Carving for Content-Aware Image Resizing</a> <br />
(7) <a href="http://algs4.cs.princeton.edu/44sp/">Algorithms: Shortest Path</a> <br />
(8) <a href="http://stackoverflow.com/questions/19760077/what-does-bellman-ford-algorithm-detects-negative-weight-or-negative-cycle">What does bellman ford algorithm</a></p>
    </section>

    <footer>
      
      <section class="author_info margin_top_big">
        <div class="alignleft border rad_circle" style="height: 87px; width: 87px; background-image: url(http://www.gravatar.com/avatar/aa2032ba2302419e3c2ede54f1fbf687?d=404&amp;s=250); background-size: cover;"></div>
        <p class="margin_left_medium text small">Author</p>
        <p class="margin_left_medium text bold"><a href="http://language.is">1ambda</a></p>
        <p class="margin_left_medium text small">Lisp, Emacs, FP</p>
      </section>
      
    </footer>

    

    
    <div id="disqus_thread" class="margin_top_big"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = '1ambda'; // required: replace example with your forum shortname
  var disqus_identifier = '72';
  var disqus_url = 'http://1ambda.github.io/graph-challenges-minimum-spanning-trees/';

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    </article>
</main>


  
  <script src="../assets/fitvids/jquery.fitvids.js"></script>
<script>
$(document).ready(function(){
  // Target your .container, .wrapper, .post, etc.
  $("section").fitVids();
});
</script>


  <footer class="blog_info margin_top_big padding_medium text center">
    <h5 class="text book small">&copy; 2015 <a href="..">Old Lisper</a>. All rights reserved.</h5>
    <h5 class="text book small"><a href="https://github.com/dreyacosta/velox" target="_blank" class="text bold">Velox theme</a> by <a href="http://dreyacosta.com/">David Rey</a></h5>
    <h5 class="text book small">Proudly published with <a href="http://ghost.org"><span>Ghost</span></a></h5>

  </footer>

  
  <script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = '1ambda'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function () {
 var s = document.createElement('script'); s.async = true;
 s.type = 'text/javascript';
 s.src = '//' + disqus_shortname + '.disqus.com/count.js';
 (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
 }());
</script>



  </body>
  </html>
