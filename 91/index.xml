<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>91s on Old Lisper</title>
    <link>https://1ambda.github.io/91/</link>
    <description>Recent content in 91s on Old Lisper</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Sat, 25 Jun 2016 10:05:04 +0900</lastBuildDate>
    <atom:link href="https://1ambda.github.io/91/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Algorithm</title>
      <link>https://1ambda.github.io/91/algorithm/</link>
      <pubDate>Sat, 25 Jun 2016 10:05:04 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/</guid>
      <description>

&lt;h2 id=&#34;algorithms&#34;&gt;Algorithms&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;design-and-analysis-part1-1&#34;&gt;Design And Analysis Part 1&lt;/a&gt; - Divide And Conquer&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;design-and-analysis-part1-2&#34;&gt;Design And Analysis Part 1&lt;/a&gt; - Randomized Selection&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;design-and-analysis-part1-3&#34;&gt;Design And Analysis Part 1 &lt;/a&gt; - Graphs, The Contraction Algorithm&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;design-and-analysis-part1-4&#34;&gt;Design And Analysis Part 1&lt;/a&gt; - Graph Search and Connectivity&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;design-and-analysis-part1-5&#34;&gt;Design And Analysis Part 1&lt;/a&gt; - Dijkstra, Heap, Red-Black Tree&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;design-and-analysis-part1-6&#34;&gt;Design And Analysis Part 1&lt;/a&gt; - Hash Table, Universal Hashing, Bloom filters&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;algorithm-part1-1&#34;&gt;Algorithm Part 1&lt;/a&gt; - Union Find&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;algorithm-part1-2&#34;&gt;Algorithm Part 1&lt;/a&gt; - Analysis of Algorithms&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;algorithm-part2-1&#34;&gt;Algorithm Part 2&lt;/a&gt; - Spanning Tree, Shortest Paths&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;algorithm-part2-2&#34;&gt;Algorithm Part 2&lt;/a&gt; - Radix Sort, Suffix Sort&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;algorithm-part2-3&#34;&gt;Algorithm Part 2&lt;/a&gt; - R-way, Ternary Tries&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;algorithm-part2-4&#34;&gt;Algorithm Part 2&lt;/a&gt; - KMP, Boyer-Moore, Rabin-Karp&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;algorithm-part2-5&#34;&gt;Algorithm Part 2&lt;/a&gt; - Maximum Flow (Ford-Fulkerson)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;algorithm-part2-6&#34;&gt;Algorithm Part 2&lt;/a&gt; - Data Compression, Huffman, LZW&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;artificial-intelligence&#34;&gt;Artificial Intelligence&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;artificial-intelligence-cs188-1&#34;&gt;Artificial Intelligence (CS188)&lt;/a&gt; - Intro&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;artificial-intelligence-cs188-2&#34;&gt;Artificial Intelligence (CS188)&lt;/a&gt; - Search&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;artificial-intelligence-planning-1&#34;&gt;Artificial Intelligence Planning&lt;/a&gt; - Intro&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;artificial-intelligence-planning-2&#34;&gt;Artificial Intelligence Planning&lt;/a&gt; - A*, STRIPS, forward and backward search&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;artificial-intelligence-planning-3&#34;&gt;Artificial Intelligence Planning&lt;/a&gt; - PSP, PoP&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;artificial-intelligence-planning-4&#34;&gt;Artificial Intelligence Planning&lt;/a&gt; - STN, HTN&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Design and Analysis: Divide &amp; Conquer</title>
      <link>https://1ambda.github.io/91/algorithm/design-and-analysis-part1-1/</link>
      <pubDate>Sat, 25 Jun 2016 12:54:35 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/design-and-analysis-part1-1/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Divide and Conquer (분할 정복)&lt;/em&gt; 을 배운다. &lt;em&gt;merge, quick sort&lt;/em&gt; 를 배우고 이 과정에서 왜 &lt;em&gt;combine&lt;/em&gt; 단계가 &lt;code&gt;O(n)&lt;/code&gt; 이 되어야 하는지 알아본다. 뒷부분에서는 &lt;em&gt;Big O&lt;/em&gt; 뿐만 아니라 &lt;em&gt;master method&lt;/em&gt;, &lt;em&gt;decomposition approach&lt;/em&gt; 를 이용해 성능을 분석한다.&lt;/p&gt;

&lt;h3 id=&#34;divide-and-conquer&#34;&gt;Divide and Conquer&lt;/h3&gt;

&lt;p&gt;각 level 의 문제 갯수는 &lt;code&gt;2^j (j = 0, 1, 2, ... , log2n)&lt;/code&gt; 이고 문제의 사이즈는 &lt;code&gt;n / 2^j&lt;/code&gt; 이므로 연산수를 &lt;code&gt;k&lt;/code&gt; 라 하면, 각 레벨에서 연산 수는 &lt;code&gt;k * n&lt;/code&gt;, 레벨의 &lt;em&gt;depth&lt;/em&gt; 가 &lt;code&gt;log2n + 1&lt;/code&gt; 이므로,&lt;/p&gt;

&lt;p&gt;&lt;em&gt;merge sort&lt;/em&gt; 같은 경우는 연산수 &lt;code&gt;k = 6&lt;/code&gt; 에서 &lt;code&gt;6n (log2n + 1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Big O 는 &lt;code&gt;O(f(n))&lt;/code&gt; 이라 했을때 &lt;em&gt;at most&lt;/em&gt;, &lt;code&gt;f(n)&lt;/code&gt; 에 proportional 하므로 upper 바운드.
반면 Omega 는 &lt;code&gt;omega(f(n))&lt;/code&gt; 이라 했을 때 &lt;em&gt;at least&lt;/em&gt; &lt;code&gt;f(n)&lt;/code&gt; 에 proportional 하므로 lower 바운드.&lt;/p&gt;

&lt;p&gt;분할 정복의 핵심은 각 sub-problem 에서 연산 수를 o(n) 으로 맞출 수 있느냐 없느냐, 맞춘다면 nlogn 알고리즘이 되는 것이다.&lt;/p&gt;

&lt;p&gt;알고리즘은 3단계로 구성된다.&lt;/p&gt;

&lt;p&gt;(1) Divide&lt;br /&gt;
(2) Conquer sub problems&lt;br /&gt;
(3) combine (merge)&lt;/p&gt;

&lt;p&gt;여기서 중요한건, combine 단계인데 이게 O(n) 이기만 하면 전체 알고리즘의 성능을 O(nlogn) 으로 보장할 수 있음.&lt;/p&gt;

&lt;h3 id=&#34;master-method-motivation&#34;&gt;Master Method: Motivation&lt;/h3&gt;

&lt;p&gt;T(n) 을 O(n) 으로 upper bound 를 구하긴 했지만 O(n) 연산 수 구하는게 좀 힘들다. 재귀 호출의 갯수나, 문제의 분할 사이즈로 O(n) 을 쉽게 구해보자.&lt;/p&gt;

&lt;p&gt;가우스 곱셈? 의 경우에 T(n) &amp;lt;= 4 * T(n/2) + O(n)&lt;/p&gt;

&lt;p&gt;그러나 더 작아질 수 있음. (a+b)(c+d) 에서 ad+bc = (a+b)(c+d) - ad - bd 로 구할 수 있음&lt;/p&gt;

&lt;p&gt;즉 3개의 부분식만 구해도 됌.&lt;/p&gt;

&lt;p&gt;T(n) &amp;lt;= 3 * T(n/2) + O(n)&lt;/p&gt;

&lt;p&gt;머지소트는 2 * T(n/2) + O(n) 쯤 되니까 가우스보다 더 낫긴 함. 그럼 가우스의 그것은 얼마일까?&lt;/p&gt;

&lt;h4 id=&#34;master-method&#34;&gt;Master Method&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Master method&lt;/em&gt; 는 재귀 문제의 러닝타임을 구하는데 &lt;em&gt;black box&lt;/em&gt; 같은 역할을 한다. 대강의 코드만으로도 러닝타임을 추측할 수 있다.&lt;/p&gt;

&lt;p&gt;그러나 &lt;em&gt;master method&lt;/em&gt; 는 가정을 하나 하는데, 바로 모든 문제가 같은 사이즈로 분할 된다는 것.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;All sub priblems have equal size&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 이 충분히 작다면, &lt;code&gt;T(n)&lt;/code&gt; 은 상수라 볼 수 있고 만약 &lt;code&gt;n&lt;/code&gt; 이 충분히 크다면 &lt;em&gt;master method&lt;/em&gt; 는 다음의 포맷을 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://acrocontext.files.wordpress.com/2014/01/master-method.png?w=300&amp;h=160&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;https://acrocontext.wordpress.com&#34;&gt;https://acrocontext.wordpress.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;a&lt;/code&gt; 는 재귀 함수 호출의 수고, &lt;code&gt;b&lt;/code&gt; 는 분할된 문제의 사이즈다. &lt;code&gt;d&lt;/code&gt; 는 &lt;em&gt;combine&lt;/em&gt; 스텝에서 사용하는 함수의 러닝타임의 지수다. (&lt;em&gt;merge-sort&lt;/em&gt; 에서 머징하는 함수라 보면 된다.)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;: number of recursive calls (&lt;code&gt;&amp;gt;= 1&lt;/code&gt;)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;: input size shrinkage factor (&lt;code&gt;&amp;gt; 1&lt;/code&gt;)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt;: exponent in running time of &lt;em&gt;combine step&lt;/em&gt; (&lt;code&gt;&amp;gt;= 0&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 몇 가지 예제를 좀 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;merge sort&lt;/em&gt; 의 경우는 &lt;code&gt;a = 2, b = 2, d = 1&lt;/code&gt; 이므로 &lt;code&gt;2 = 2^1&lt;/code&gt; 이어서 &lt;code&gt;O(n^1 * logn)&lt;/code&gt; 즉 &lt;code&gt;O(nlogn)&lt;/code&gt; 의 러닝타임을 가진다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;binary search&lt;/em&gt; 는 문제 수가 절반으로 줄긴 하나 반쪽만 사용하고, 매 재귀호출 마다 한번의 비교만 하므로 &lt;code&gt;a = 1, b = 2, d = 0&lt;/code&gt; 이므로 &lt;code&gt;a = b^d&lt;/code&gt; 는 &lt;code&gt;1 = 1^1&lt;/code&gt; 이 되어 &lt;code&gt;O(nlogn)&lt;/code&gt; 이 된다.&lt;/p&gt;

&lt;p&gt;가우스 곱셈은 &lt;code&gt;a = 3, b = 2, d = 1&lt;/code&gt; 이므로 &lt;code&gt;O(n^log2_3)&lt;/code&gt; 이 된다. 더 정확히는 &lt;code&gt;O(n^1.59)&lt;/code&gt; &lt;em&gt;merge-sort&lt;/em&gt; 보다 빠르진 않지만 &lt;em&gt;quadratic&lt;/em&gt; 보단 빠르다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;strassen&lt;/em&gt; 행렬 곱셈은 어떨까? &lt;code&gt;a = 7, b = 2, d = 2&lt;/code&gt; 에서 마찬가지로 &lt;em&gt;case 3&lt;/em&gt; 이므로 &lt;code&gt;O(n^log2_7)&lt;/code&gt; 이다. &lt;code&gt;O(n^2.81)&lt;/code&gt; 쯤 되므로 &lt;code&gt;O(n^3)&lt;/code&gt; 보다는 훨씬 낫다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;merge-sort&lt;/em&gt; 에서 &lt;code&gt;d = 2&lt;/code&gt; 라면 &lt;code&gt;O(n^2)&lt;/code&gt; 이 나온다. 사실 일반적으로 생각하기에는 &lt;code&gt;O(n^2 * logn)&lt;/code&gt; 이 나올거 같은데, 사실 이건 &lt;em&gt;upper bound&lt;/em&gt; 이므로 &lt;code&gt;O(n^2)&lt;/code&gt; 이 좀 더 나은 &lt;em&gt;upper bound&lt;/em&gt; 임을 알 수 있다. 이 사실은  &lt;em&gt;master method&lt;/em&gt; 를 이용하면 수학적으로 더 근사한 값을 찾아낼 수 있다는걸 알려준다.&lt;/p&gt;

&lt;h4 id=&#34;proof-master-method&#34;&gt;Proof: Master Method&lt;/h4&gt;

&lt;p&gt;재귀의 각 단계를 &lt;code&gt;j = 0, 1, 2, ... , logb_n (base b)&lt;/code&gt; 라 하면 각 단계에서는 &lt;code&gt;a^j&lt;/code&gt; 사이즈의 &lt;em&gt;sub-problem&lt;/em&gt; 수와 &lt;code&gt;n / b^j&lt;/code&gt; 사이즈의 문제가 있다.&lt;/p&gt;

&lt;p&gt;단계 &lt;code&gt;j&lt;/code&gt; 에서의 연산은 &lt;code&gt;a^j * c * (n / b^j)^d&lt;/code&gt; 즉 &lt;em&gt;문제의 수 x 각 문제의 사이즈와 일어나는 거기서 일어나는 연산 수&lt;/em&gt; 로 정의할 수 있다. 수식을 &lt;code&gt;j&lt;/code&gt; 로 다시 정리하면&lt;/p&gt;

&lt;p&gt;각 단계의 &lt;em&gt;sub problem&lt;/em&gt; 에서 일어나는 연산은 &lt;code&gt;c * n ^d * (a / b^d)^j&lt;/code&gt; 다. 따라서 전체 단계를 구하려면 여기에 시그마를 씌우면 된다.&lt;/p&gt;

&lt;p&gt;식을 좀 더 자세히 보면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;code&gt;a&lt;/code&gt;:&lt;/em&gt; rate of sub problem proliferation &lt;em&gt;(RSP)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;code&gt;b^d&lt;/code&gt;:&lt;/em&gt; rate of work shirinkage &lt;em&gt;(RWS)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;d&lt;/code&gt; 가 &lt;code&gt;n^d&lt;/code&gt; 에도 섞여있어 좀 복잡하긴 한데 느낌만 알아보자면 &lt;code&gt;b = 2, d = 1&lt;/code&gt; 일때는 &lt;em&gt;sub-problem&lt;/em&gt; 당 문제가 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; 씩 줄어든다. 하지만 &lt;code&gt;b = 2, d  = 2&lt;/code&gt; 라면 문제의 수가 2배가 될때 문제 사이즈는 4배가 되고, &lt;code&gt;b^d = 4&lt;/code&gt; 가 되어 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; 만큼의 연산만 줄어든다. 따라서 &lt;code&gt;d&lt;/code&gt; 가 커지는 건 생각보다 영향이 큰 걸 알 수 있다.&lt;/p&gt;

&lt;p&gt;위 식으로부터 다음의 관계를 이끌어 낼 수 있다.&lt;/p&gt;

&lt;p&gt;(1) if &lt;em&gt;RSP &amp;lt; RWS&lt;/em&gt;, then the amount of work is decreasing with the recursion level &lt;code&gt;j&lt;/code&gt;&lt;br /&gt;
(2) if &lt;em&gt;RSP &amp;gt; RWS&lt;/em&gt;, then the amount of work is increasing with the recursion level &lt;code&gt;j&lt;/code&gt;&lt;br /&gt;
(3) if &lt;em&gt;RSP = RWS&lt;/em&gt;, then the amount of work is same at every recursion level &lt;code&gt;j&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;(3)&lt;/code&gt; 의 경우 각 단계에서의 연산이 &lt;code&gt;c* n^d * 1^j&lt;/code&gt; 이므로 깊이 &lt;code&gt;logb_n (base b)&lt;/code&gt; 을 곱하면 &lt;code&gt;O(n^d * logn)&lt;/code&gt; 이다. &lt;em&gt;(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; 는 문제의 사이즈와 관계가 없다 그리고 더 정확히는 시그마를 더하면 &lt;code&gt;O(n^d * (1 + logb_n)&lt;/code&gt; 이다)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(2)&lt;/code&gt; 의 경우 깊이가 깊어질 수록 각 단계에서의 연산이 급격하게 줄어들고, 루트에서의 (&lt;code&gt;j = 0&lt;/code&gt;) 연산이 가장 크므로 루트에서의 연산을 &lt;em&gt;upper bound&lt;/em&gt; 로 보면 &lt;code&gt;O(n^d)&lt;/code&gt; 라 볼 수 있다.&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;code&gt;(1)&lt;/code&gt; 의 경우 깊이가 깊어질수록 연산이 늘어나고, 대충 생각하면 마지막 노드의 개수에 비례하는 &lt;em&gt;Big O&lt;/em&gt; 를 가지리라는 생각을 해볼 수 있다.&lt;/p&gt;

&lt;p&gt;좀 더 수식에 대한 이해를 얻기 위해 수학적으로 접근해 보자.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1 + r + r^2 + ... + r^k&lt;/code&gt; 를 귀납법으로 풀면 &lt;code&gt;r^(k+1) - 1 / r - 1&lt;/code&gt; 이란 값이 나온다. &lt;code&gt;(r != 1)&lt;/code&gt; 이 때&lt;/p&gt;

&lt;p&gt;&lt;code&gt;r &amp;lt; 1&lt;/code&gt; 이고 &lt;code&gt;k&lt;/code&gt; 가 충분히 크다면 이 식은 &lt;code&gt;1 / (1 - r)&lt;/code&gt; 이라 보아도 된다. 다시 말해서 &lt;code&gt;k&lt;/code&gt; 와는 관련 없는 상수라 보아도 된다는 뜻이다. 그리고 첫번 째 항이 다른 것들의 합보다 크다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;r &amp;gt; 1&lt;/code&gt; 이라 했을때, 우측 식 &lt;code&gt;r^(k+1) - 1 / r - 1&lt;/code&gt; 은 &lt;code&gt;r^k * (1 + 1 / r - 1)&lt;/code&gt; 보다 항상 작거나 같다는 사실을 알 수 있다 &lt;em&gt;(upper bound)&lt;/em&gt; 다시 말해서 마지막 항 &lt;code&gt;r^k&lt;/code&gt; 의 2배보다 작거나 같다는 사실을 알 수 있다. 이것도 &lt;code&gt;r = 2&lt;/code&gt; 일때나 맥시멈 두배다.&lt;/p&gt;

&lt;p&gt;1 부터 256까지 더해봐도 512 보다 작거나 같다는 사실을 알 수 있다. 다시 말해서 마지막 항이 그 전 모든 항을 합한 것 보다 크다.&lt;/p&gt;

&lt;p&gt;이제 다시 &lt;em&gt;master method&lt;/em&gt; 로 다시 돌아오자.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;c* n^d * sigma(j) (a / b^d)^j&lt;/code&gt; (&lt;code&gt;j = 0 to logb_n&lt;/code&gt;) 에서 &lt;code&gt;a / b^d&lt;/code&gt; 를 &lt;code&gt;r&lt;/code&gt; 이라 두자.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;RSP &amp;lt; RWS (case 2)&lt;/em&gt; 이면 &lt;code&gt;r &amp;lt; 1&lt;/code&gt; 이므로 시그마를 합해봐야 특정 상수다. &lt;code&gt;O(n^d)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;반대로 &lt;em&gt;RSP &amp;gt; RSW (case 3)&lt;/em&gt; 이면 &lt;code&gt;r &amp;gt; 1&lt;/code&gt; 이므로 시그마를 합해봐야 &lt;code&gt;r^k * 상수&lt;/code&gt; 보다 작거나 같으므로 가장 큰 항 &lt;code&gt;r^k&lt;/code&gt; 는 &lt;code&gt;(a / b^d)^logb_n&lt;/code&gt; 이다. 여기서 &lt;code&gt;b^(-dlogb_n)&lt;/code&gt; 이 &lt;code&gt;n^-d&lt;/code&gt; 라는 사실을 이용하면 &lt;code&gt;O(a^logb_n)&lt;/code&gt;만 남는다.&lt;/p&gt;

&lt;p&gt;그런데, 재미있는 사실은 &lt;code&gt;logb_n&lt;/code&gt; 이 마지막 단계이고, &lt;code&gt;a&lt;/code&gt; 는 각 단계에서 분할되는 노드의 갯수이므로 &lt;code&gt;a^(logb_n)&lt;/code&gt; 은 &lt;em&gt;recursion tree&lt;/em&gt; 에서 &lt;em&gt;leave&lt;/em&gt; 의 갯수다.&lt;/p&gt;

&lt;p&gt;다시 말해서 마지막 단계에서의 노드의 갯수에 연산이 비례한다. 근데 처음에 우리가 봤던건 &lt;code&gt;n^(logb_n)&lt;/code&gt; 아니었던가? 사실 로그를 배우면 위 두 식은 같다는걸 알 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;quick-sort&#34;&gt;Quick Sort&lt;/h3&gt;

&lt;p&gt;퀵소트는 평균적으로 &lt;code&gt;O(n logn)&lt;/code&gt; 성능을 보여주며 &lt;em&gt;in-place&lt;/em&gt; 로 작동하는 인기있는 정렬 알고리즘이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;key idea&lt;/em&gt; 는 &lt;em&gt;pivot&lt;/em&gt; 을 중심으로 문제를 좌우로 분할하는 것이다.   &lt;em&gt;less than pivot&lt;/em&gt; 들은 왼쪽에, &lt;em&gt;greater than pivot&lt;/em&gt; 들은 우측에 놓음으로써 최소한 한번의 분할당 하나의 원소 &lt;em&gt;(pivot)&lt;/em&gt; 은 자리를 잡는 다는 것을 보장한다.&lt;/p&gt;

&lt;p&gt;퀵소트의 매 호출당 일어나는 &lt;em&gt;partition (분할)&lt;/em&gt; 은 다음의 두 특징을 가진다.&lt;/p&gt;

&lt;p&gt;(1) linear time, &lt;code&gt;O(n)&lt;/code&gt;&lt;br /&gt;
(2) no extra memory&lt;/p&gt;

&lt;p&gt;대강의 로직은 이렇다. &lt;code&gt;Quicksort(array A, length n)&lt;/code&gt; 에 대해서&lt;/p&gt;

&lt;p&gt;(1) if &lt;code&gt;n = 1&lt;/code&gt; return &lt;code&gt;A&lt;/code&gt;&lt;br /&gt;
(2) &lt;code&gt;p&lt;/code&gt; = choose &lt;code&gt;Pivot(A, n)&lt;/code&gt;&lt;br /&gt;
(3) partition &lt;code&gt;A&lt;/code&gt; round &lt;code&gt;p&lt;/code&gt; =&amp;gt; &lt;code&gt;L, R&lt;/code&gt;&lt;br /&gt;
(4) recursively solve &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;보면 알겠지만 &lt;em&gt;combine&lt;/em&gt; 혹은 &lt;em&gt;merge&lt;/em&gt; 스텝이 전혀 없다.&lt;/p&gt;

&lt;h4 id=&#34;partition-in-place&#34;&gt;Partition: In-place&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;O(n)&lt;/code&gt; 의 추가 메모리를 사용하면 연산시간 &lt;code&gt;O(n)&lt;/code&gt; 을 구현하기 쉽다. 추가 메모리 없이 어떻게 &lt;code&gt;O(n)&lt;/code&gt; 으로 &lt;em&gt;partitioning&lt;/em&gt; 을 구현할 수 있을까?&lt;/p&gt;

&lt;p&gt;(1) 첫 번째 원소를 &lt;em&gt;pivot&lt;/em&gt; 이라 놓고&lt;br /&gt;
(2) &lt;em&gt;pivot&lt;/em&gt; 다음의 원소를 &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; 가 가리키게 한다.&lt;br /&gt;
(3) &lt;code&gt;j&lt;/code&gt; 보다 작은 원소들은 &lt;em&gt;partitioned&lt;/em&gt; , 큰 원소는 &lt;em&gt;unpartitioned&lt;/em&gt; 라 보고&lt;br /&gt;
(4) &lt;code&gt;i&lt;/code&gt; 보다 작은 원소들은 &lt;em&gt;pivot&lt;/em&gt; 보다 작은 값, 큰 원소들은 &lt;em&gt;pivot&lt;/em&gt; 보다 큰 값이다.&lt;br /&gt;
(5) &lt;code&gt;i &amp;lt;= j&lt;/code&gt; 이며, &lt;code&gt;i == j&lt;/code&gt; 일때는 &lt;code&gt;j&lt;/code&gt; 값을 증가시켜 원소를 비교 한뒤 &lt;code&gt;j&lt;/code&gt; 에 있는 원소가 &lt;code&gt;i&lt;/code&gt; 가 가리키는 원소보다 크면 &lt;em&gt;swap&lt;/em&gt; 하고 &lt;code&gt;i += 1, j +=1&lt;/code&gt; 아니면 &lt;code&gt;j += 1&lt;/code&gt; 한다.&lt;/p&gt;

&lt;p&gt;이해가 쉽게 그림을 첨부하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sadakurapati.files.wordpress.com/2013/10/qsort_1.png&#34; align=&#34;center&#34; /&gt;
&lt;img src=&#34;http://sadakurapati.files.wordpress.com/2013/10/qsort_2.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://sadakurapati.wordpress.com&#34;&gt;http://sadakurapati.wordpress.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이런 로직으로 &lt;code&gt;n&lt;/code&gt; 개의 원소를 순회하면, &lt;code&gt;n-1&lt;/code&gt; 번 만큼 &lt;code&gt;j&lt;/code&gt; 순회를 하고 최악의 경우 &lt;code&gt;n-1&lt;/code&gt; 번의 &lt;em&gt;swap&lt;/em&gt; 과 &lt;em&gt;i += 1&lt;/em&gt; 연산이 일어난다.  다시 말해 각 원소마다 &lt;code&gt;O(1)&lt;/code&gt; 연산이므로, &lt;em&gt;partition&lt;/em&gt; 연산은 &lt;code&gt;O(n)&lt;/code&gt; 이라 보장할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;quick-sort&lt;/em&gt; 는 귀납법으로 증명하기도 쉬운데, &lt;code&gt;P(n)&lt;/code&gt; 이 1부터 &lt;code&gt;n&lt;/code&gt; 까지의 정렬된 원소를 가지고 있는 배열이라고 하면,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;P(1)&lt;/code&gt; 임은 자명하고, 문제의 수 &lt;code&gt;k&lt;/code&gt; 에 대해 퀵소트가 &lt;code&gt;P(k)&lt;/code&gt; 일때  &lt;code&gt;P(k+1)&lt;/code&gt; 임을 보이면 &lt;code&gt;P(n)&lt;/code&gt; 에 대해서도 참임을 알 수 있다.&lt;/p&gt;

&lt;p&gt;그런데, &lt;code&gt;P(k+1)&lt;/code&gt; 에서 &lt;em&gt;pivot&lt;/em&gt; 을 제외한 좌측과 우측의 사이즈를 &lt;code&gt;k1&lt;/code&gt;, &lt;code&gt;k2&lt;/code&gt; 라 하면 &lt;code&gt;k1, k2 &amp;lt; k&lt;/code&gt; 이다. 좌측 또는 우측이 없을 때라야 &lt;code&gt;k1 or k2 = k&lt;/code&gt; 다. 이때 &lt;code&gt;P(k)&lt;/code&gt; 가 참이므로 이보다 작거나 같은 &lt;code&gt;k1, k2&lt;/code&gt; 의 문제 사이즈에 대해서도 참이다. 따라서 &lt;code&gt;P(k+1)&lt;/code&gt; 도 참이다.&lt;/p&gt;

&lt;h4 id=&#34;choosing-a-good-pivot&#34;&gt;Choosing a good pivot&lt;/h4&gt;

&lt;p&gt;그럼 &lt;em&gt;pivot&lt;/em&gt; 은 무엇을 기준으로 잡는게 좋을까? 어차피 비교에서 &lt;code&gt;i != p and j != p&lt;/code&gt; 라면 구현에는 어느 위치에 잡던 문제가 없을것 같은데..&lt;/p&gt;

&lt;p&gt;만약에 &lt;em&gt;pivot&lt;/em&gt; 이 첫 번째 원소이고, 입력이 이미 정렬이 된 배열이라면 성능이 어떻게 될까? 바로 &lt;code&gt;O(n^2)&lt;/code&gt; 이다. 왜냐하면 이미 정렬이 되어있으므로 문제가 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; 로 분할되지 않기 때문이다. 배열 사이즈만 1씩 줄어들면서 재귀호출이 반복된다.&lt;/p&gt;

&lt;p&gt;그럼 만약에, &lt;em&gt;pivot&lt;/em&gt; 을 원소들의 &lt;em&gt;median (중앙값)&lt;/em&gt; 으로 고른다면? 매 재귀마다 문제가 좌우로 분할되므로 &lt;code&gt;O(nlogn)&lt;/code&gt; 이라 볼 수 있다.&lt;/p&gt;

&lt;p&gt;근데 생각해 볼 거리가 있다. &lt;em&gt;pivot&lt;/em&gt; 을 구하는 함수의 비용은 어떻게 되는걸까? 이것 또한 &lt;code&gt;O(n)&lt;/code&gt; 이므로 전체 &lt;em&gt;partition&lt;/em&gt; 의 비용은 &lt;code&gt;O(n)&lt;/code&gt; 이라 보아도 된다.&lt;/p&gt;

&lt;h4 id=&#34;randomized-pivots&#34;&gt;Randomized pivots&lt;/h4&gt;

&lt;p&gt;그럼 만약에 &lt;em&gt;pivot&lt;/em&gt; 을 무작위로 고르면 어떻게 될까 생각해 보자. &lt;em&gt;pivot&lt;/em&gt; 을 무작위로 선택했을 때 한쪽이 &lt;code&gt;25-75%&lt;/code&gt; 로 분할될 확률은 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; 이다.&lt;/p&gt;

&lt;p&gt;그리고 무작위로 &lt;em&gt;pivot&lt;/em&gt; 을 선택했을때 첫번째 다음 재귀 호출에 넘겨질 배열의 길이의 기대값을 구하면, 다시 말해 &lt;code&gt;X&lt;/code&gt; 를 &lt;em&gt;subproblem size&lt;/em&gt; 라 했을때 &lt;code&gt;E(X)&lt;/code&gt; 를 구하면&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1/n * (0 + 1 + ... + (n - 1)) = (n - 1) / 2&lt;/code&gt; 다.&lt;/p&gt;

&lt;p&gt;여기서 잠깐 중요한 속성인 &lt;em&gt;linearity of expection&lt;/em&gt; 을 설명하면&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;모든 &lt;em&gt;random variable&lt;/em&gt; &lt;code&gt;X&lt;/code&gt; 의 합의 기대값은, 각 &lt;code&gt;X&lt;/code&gt;의 기대값의 합과 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://www.opendatastructures.org/ods-java/img333.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.opendatastructures.org&#34;&gt;http://www.opendatastructures.org&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Xj(i)P(i)&lt;/code&gt; 를 컬럼의 개수가 &lt;code&gt;j&lt;/code&gt;, 행의 개수가 &lt;code&gt;i&lt;/code&gt; 인 행렬의 원소로 보면 이 &lt;em&gt;linearity of expectation&lt;/em&gt; 은 쉽게 이해할 수 있다. 이 속성은 꽤나 유용하다.&lt;/p&gt;

&lt;p&gt;예를 들어 두개의 주사위를 독립적으로 굴린다고 할 때 나오는 값인 &lt;em&gt;random variable&lt;/em&gt; &lt;code&gt;X1, X2&lt;/code&gt; 에 대한 기대값을 직접 구하려면 36개의 &lt;em&gt;sample space&lt;/em&gt; 를 살펴봐야 하는데, 그러지 말고 하나를 굴렸을때의 값을 구해 이걸 2배 하면 된다. 하나를 굴렸을때는 6개의 &lt;em&gt;sample space&lt;/em&gt; 만 살피면 되니 금방 구한다.&lt;/p&gt;

&lt;p&gt;로드 밸런싱문제에 &lt;em&gt;linearity of expectation&lt;/em&gt; 을 적용해보자. &lt;code&gt;n&lt;/code&gt;개의 서버가 있고 여기에 &lt;code&gt;n&lt;/code&gt; 개의 프로세스를 랜덤하게 할당할때 한개의 서버에 할당될 프로세스의 기대값은 얼마일까? 다시 말해 평균적으로 몇개의 프로세스가 서버에 할당될까?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;sample space&lt;/em&gt; 는 &lt;code&gt;n&lt;/code&gt; 개의 항끼리의 곱에서 항의 개수를 구하는 문제와 같으므로 &lt;code&gt;n^n&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;이때 &lt;code&gt;Y&lt;/code&gt; 를 첫 번째 서버에 할당된 프로세스 수의 합이라 하면 이때 &lt;code&gt;Y&lt;/code&gt; 는 &lt;code&gt;sigma Xj (j = 1 to n, Xj = 1 or 0)&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;E[Y]&lt;/code&gt; 를 구하는 것이 본래의 문제인데 가능한 &lt;code&gt;Y&lt;/code&gt; 값을 모두 구한 뒤에 각각의 확률을 곱해서 더하느니, &lt;code&gt;Y&lt;/code&gt; 를 분해해 각각의 기대값을 구한 후 더하는게 훨씬 빠르다. (주사위 굴리기 문제처럼)&lt;/p&gt;

&lt;p&gt;다시 말해서, &lt;code&gt;Y&lt;/code&gt; 가 여러개의 항으로 구성될때는 각각의 기대값을 구하는게 더 계산이 빠르다는것이 &lt;em&gt;lineariry of expectation&lt;/em&gt; 의 본질이다.&lt;/p&gt;

&lt;p&gt;따라서 기대값을 시그마 뒤쪽으로 빼서 계산하면 &lt;code&gt;1&lt;/code&gt; 이 나온다. 다시 말해 서버 하나당 평균적으로 1개의 프로세스를 가진다는 이야기.&lt;/p&gt;

&lt;p&gt;다시 이 확률 테크닉을 &lt;em&gt;randomized pivot&lt;/em&gt; 을 선택하는 &lt;em&gt;merge sort&lt;/em&gt; 에 적용하러 가 보자.&lt;/p&gt;

&lt;h3 id=&#34;decomposition-principle&#34;&gt;Decomposition Principle&lt;/h3&gt;

&lt;p&gt;일단 랜덤 피벗을 가지는 퀵소트를 &lt;em&gt;master method&lt;/em&gt; 로는 &lt;em&gt;Big O&lt;/em&gt; 를 찾을 수가 없다는 사실을 알아 두자. 이는 입력한 배열이 일정하게 분할되지 않고 피벗때문에 랜덤하게 분할되지 때문이다.&lt;/p&gt;

&lt;p&gt;이제, 퀵 소트의 각 재귀에서 일어나는 연산 중 &lt;em&gt;comparison (비교)&lt;/em&gt; 가 다른 연산보다 &lt;em&gt;dominant&lt;/em&gt; 하다고 하면, 다시 말해서 비교하는 숫자에 의해 연산 수가 결정된다고 하자. 이건 생각해보면 사실인데, &lt;em&gt;partition&lt;/em&gt; 과정에서 일어나는 비교가 각 &lt;em&gt;sub-problem&lt;/em&gt; 에서의 연산 수를 결정한다.&lt;/p&gt;

&lt;p&gt;이렇게 하면 연산수의 기대값, 다시 말해서 &lt;em&gt;비교가 일어나는 회수의 평균으로&lt;/em&gt;, 퀵소트의 평균 성능을 찾아낼 수 있다.&lt;/p&gt;

&lt;p&gt;그런데 입력 배열에 대한 전체 비교 수를 &lt;code&gt;C&lt;/code&gt; 라 두면 &lt;code&gt;E(C)&lt;/code&gt; 는 사실 구하기가 굉장히 어렵다. 그런데, &lt;code&gt;E(C)&lt;/code&gt; 를 시그마 두번으로 분해할 수 있고, 심지어 가장 내부의 항은 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 을 가지는 원소이다. 따라서 &lt;em&gt;linearity of expectation&lt;/em&gt; 을 이용할 수 있다 &lt;del&gt;할렐루야&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;참고로 가장 내부의 항에 대해서 설명하자면, 전체 입력에서 두개의 원소를 골랐을 때 이 두개의 원소가 비교 되는 수다. 이 두개의 원소는 &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; 를 기준으로 구할 수 있으므로 &lt;code&gt;X_ij&lt;/code&gt; 라 두면 &lt;code&gt;i, j&lt;/code&gt; 에 각각에 대해 시그마를 씌울 수 있다. 이것이 &lt;code&gt;C&lt;/code&gt; 이므로 &lt;code&gt;E(C)&lt;/code&gt; 를 구하기는 상당히 복잡함을 알 수 있다. 그런데 &lt;code&gt;X_ij&lt;/code&gt; 자체는 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 만 가지는 값이니 이것에 대해 &lt;code&gt;E(X_ij)&lt;/code&gt; 를 구하면 심플해진다. (수식을 적기 힘드니 자세한 내용은 강의 &lt;em&gt;Analysis I: A Decomposition Principle&lt;/em&gt; 을 참조)&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;E(C)&lt;/code&gt; 는 &lt;code&gt;sigma i &amp;lt;- 1 to n-1, sigma j &amp;lt;- i+1 to n P(X_ij = 1)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;여기서 잠깐 이제 까지 나온 &lt;em&gt;decompositio principle&lt;/em&gt; 을 설명하자면&lt;/p&gt;

&lt;p&gt;(1) 구하고자 하는 랜덤 변수 &lt;code&gt;Y&lt;/code&gt; 를 정의하고&lt;br /&gt;
(2) &lt;code&gt;Y&lt;/code&gt; 를 더 간단한 랜덤 변수 &lt;code&gt;X&lt;/code&gt; 의 합으로 정의하자. &lt;code&gt;X&lt;/code&gt; 가 0 또는 1만 가지는 값이면 더 좋다.
(3) &lt;em&gt;linearity of expectation&lt;/em&gt; 을 적용&lt;/p&gt;

&lt;p&gt;다시 말해 알고리즘의 성능을 결정하는 &lt;em&gt;dominant operation&lt;/em&gt; 을 확률변수로 표현할 수 있고, 더 간단한 확률 변수의 합으로 표현할 수 있다면 해해 여기에 &lt;em&gt;기대값의 선형성&lt;/em&gt; 을 이용해 알고리즘의 평균적인 성능을 구할 수 있다는 뜻이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sigma i &amp;lt;- 1 to n-1, sigma j &amp;lt;- i+1 to n P(X_ij = 1)&lt;/code&gt; 다시 이 식으로 돌아오자. 여기에 적용할 수 있는 퀵소트의 특징이 있다. 여기서 &lt;code&gt;z_i&lt;/code&gt; 를 정렬된 배열의 &lt;code&gt;i&lt;/code&gt; 번쨰 원소라 했을때 &lt;em&gt;pivot&lt;/em&gt; 이 될 수 있는 것은 &lt;code&gt;z_i, z_i+1, ... z_j-1, z_j&lt;/code&gt; 다. 이때&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;z_i&lt;/code&gt; 또는 &lt;code&gt;z_j&lt;/code&gt; 가 &lt;em&gt;pivot&lt;/em&gt; 이 되면, 즉 가장 작은 수나 가장 큰 수가 &lt;em&gt;pivot&lt;/em&gt; 이 되면 &lt;code&gt;z_i&lt;/code&gt; 와 &lt;code&gt;z_j&lt;/code&gt; 는 한번만 비교된다. (이후에는 다른 재귀로 넘어가 둘 중 하나의 수만 남음)&lt;br /&gt;
(2) &lt;code&gt;z_i+1&lt;/code&gt;, &amp;hellip;, &lt;code&gt;z_j-1&lt;/code&gt; 이 &lt;em&gt;pivot&lt;/em&gt; 이 되면 &lt;code&gt;z_i&lt;/code&gt; 와 &lt;code&gt;z_j&lt;/code&gt; 는 절대로 비교되지 않는다. &lt;em&gt;pivot&lt;/em&gt; 기준으로 큰 수와 작은수는 서로 비교되지 않으며 둘 다 피벗과만 비교된다. 이후에도 다른 파티션으로 나누어져 비교되지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 각 &lt;em&gt;sub-problem&lt;/em&gt; 에서 일어나는 비교가 일어날 확률은 &lt;code&gt;2 / (j - i + 1)&lt;/code&gt; 이다. 다시 말해서 전체 원소 중에서 &lt;code&gt;z_i&lt;/code&gt; 와 &lt;code&gt;z_j&lt;/code&gt; 를 피벗으로 삼는 경우에만 비교가 일어난다.&lt;/p&gt;

&lt;p&gt;따라서 평균 연산 수 &lt;code&gt;E(C)&lt;/code&gt; 는 &lt;code&gt;sigma i &amp;lt;- 1 to n-1, sigma j &amp;lt;- i+1 to n [2 / (j -i + 1)]&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;이때 &lt;code&gt;j = i +1&lt;/code&gt; 부터 시작하므로 내부 시그마는 &lt;code&gt;1/2 + 1/3 + ... 1/n&lt;/code&gt; 이다. 그리고 내부 시그마에서 &lt;code&gt;i&lt;/code&gt; 가 사라졌으므로 외부 시그마 &lt;code&gt;i &amp;lt;- 1 to n-1&lt;/code&gt; 을 &lt;code&gt;n-1&lt;/code&gt; 대신 대략 &lt;code&gt;n&lt;/code&gt; 이라고 놓으면,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;E(C) &amp;lt;= 2 * n * [sigma k &amp;lt;- 2 to n (1/k)]&lt;/code&gt; 다.&lt;/p&gt;

&lt;p&gt;이때 &lt;code&gt;sigma k &amp;lt;- 2 to n (1/k)&lt;/code&gt; &amp;lt;= &lt;code&gt;ln n&lt;/code&gt; 인데, 본래 식의 &lt;code&gt;k&lt;/code&gt; 1 부터의 시그마보다 작으므로 이걸 적분으로 넓이를 구하면 &lt;code&gt;ln n - ln 1 =  ln n&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;E(C) &amp;lt;= 2 * n * ln n&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;notes&#34;&gt;Notes&lt;/h3&gt;

&lt;p&gt;이하는 필기 노트입니다.&lt;/p&gt;

&lt;h4 id=&#34;matrix-multiplication&#34;&gt;matrix multiplication&lt;/h4&gt;

&lt;p&gt;단순히 brute force 로 3 for-loop 로 구현하면 당연히 o(n^3) -_-;&lt;/p&gt;

&lt;p&gt;스트라센 매트릭스 곱셈으로 구현하면 놀랍게도 n^2&lt;/p&gt;

&lt;h4 id=&#34;multiplication&#34;&gt;Multiplication&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;define Input, output&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;assess performance&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;can we do better strait forard?&lt;/p&gt;

&lt;p&gt;일반적인 곱셈(초등3학년)은 2n * n&lt;/p&gt;

&lt;h4 id=&#34;karatsuba-multiplication&#34;&gt;Karatsuba Multiplication&lt;/h4&gt;

&lt;p&gt;a * c
b * d = 2652
(a + b)(c + d) = 6164
(a+b)(c+d) - a*c - b * d = 2840&lt;/p&gt;

&lt;p&gt;ad bc&lt;/p&gt;

&lt;p&gt;6164 + * 10000
+ 2652
+ 2840 * 100&lt;/p&gt;

&lt;p&gt;x = 10^n/2 a + b
y = 10^n/2 c + d&lt;/p&gt;

&lt;p&gt;x * y =&amp;gt; 10^n ac + 10 n/2 (ad+bc) + bd
따라서 &lt;em&gt;Karatsuba multiplication&lt;/em&gt; 은 &lt;em&gt;product&lt;/em&gt; 문제를 ac, ad, bc, bd 의 곱으로 쪼갬.&lt;/p&gt;

&lt;p&gt;여기서도, ac, ad, bc, bd 를 모두 구하는 대신에&lt;/p&gt;

&lt;p&gt;(a+b)(c+d) - ac bd 를 빼면,  ac bd (a+b)(c+d) 3개만 구하면 된다.&lt;/p&gt;

&lt;p&gt;따라서 3개의 recursive multiplication 만 필요&lt;/p&gt;

&lt;h4 id=&#34;closest-pairs&#34;&gt;Closest Pairs&lt;/h4&gt;

&lt;p&gt;brute force 는 n^2 인데,&lt;/p&gt;

&lt;p&gt;1D 의 closest pair 에서 sorting 하면 n^2 가 아니라 nlogn 이다.&lt;/p&gt;

&lt;p&gt;로직은 다음과 같다.&lt;/p&gt;

&lt;p&gt;문제를 반으로 잘라가면서 왼쪽에서 거리가 가장 짧은것 좌표 쌍, 오른쪽에서 가장 짧은것을 찾고, 각 영역에 좌표가 하나씩 있는 쌍도 검사 한다.&lt;/p&gt;

&lt;p&gt;(1) 주어진 배열을 P 라 하고 반으로 각각 좌우 Q, R 자른다. O(n) Q를 x 정렬한것을 Qx, y 축 기준으로 Qy, R도 Rx, Ry. 이건 전체 인풋 n 에 대해서 n logn&lt;br /&gt;
(2) ClosestPair(Qx, Qy), Closest(Rx, Ry) 해서 각각 좌 우에서 가장 짧은 거리를 가진 pair 쌍을 찾는다.  이걸 (p1, q1), (p2, q2)  라 하면&lt;br /&gt;
(3) (p1, q1), (p2, q2) 의 거리를 구해 최소값인 d 를 찾는다&lt;br /&gt;
(4) Closest(Px, Py, d) 해서 (p3 , q3) 가 있으면 찾아낸다. 여기서 찾은건 하나는 Q 하나는 R 에 있는 d 보다 작은 거리를 가진 점의 쌍&lt;br /&gt;
(5) p1, p2, p3 쌍중 가장 작은 d 를 가진 것을 리턴&lt;/p&gt;

&lt;p&gt;ClosestSplitPair&lt;/p&gt;

&lt;p&gt;(1) Px 의 가운데 점을 xBar 라 하면 이것 기준으로 -d, +d 의 x 값을 가진 점들을 Py 에서 찾아낸다. 정의에 의해서 x1 - x2 &amp;lt;= d 이기 때문에 아무리 커봐야 xBar 기준으로 좌우 d 까지밖에 존재하지 못함. 이걸 Sy 라 부르자. 이건 Py 가 이미 정렬되어 있기 때문에 O(n) 시간.&lt;br /&gt;
(2) Sy 는 y 축 기준으로 이미 정렬되어 있는데, 여기서 Sy 의 원소를 루프로 돌면서 이것 기준으로 +7개 원소를 검사하면서 거리가 d 보다 작은것이 있는지 검사. 이것 또한 마찬가지로 d 의 정의와 두 점이 Q, R 에 있다는 점을 이용해서 증명이 가능함.&lt;/p&gt;

&lt;p&gt;y1 - y2 도 d 보다 작거나 같이 때문에 y 기준으로 정렬된 점을 기준으로 잡았을때,&lt;/p&gt;

&lt;p&gt;p 와 같은 왼편에 있는 것들은 p와의 거리가 d 보다 작을 수 없다. 왜냐하면 d 자체가 같은 사이드에 있는 것들의 최소 거리이기 때문.
이런점들을 아무리 많이 왼쪽에 구겨 넣어도 3개. p 포함하면 4개다. 마찬가지로 q 와 같은 편에 있는것들도 3개.&lt;/p&gt;

&lt;p&gt;따라서 운이 나쁠 경우 Sy 에서 p, q + 6개를 더 검사해야.&lt;/p&gt;

&lt;p&gt;직사각형을 그려보면 이해가 쉬움.&lt;/p&gt;

&lt;p&gt;Input 은 (x1, y1) &amp;hellip; (xn, yn) 의 pair n개 편의상 p1, p2, &amp;hellip; pn&lt;/p&gt;

&lt;p&gt;d(p_i, p_j) 는 두 point 사이 거리&lt;/p&gt;

&lt;p&gt;(1) 모든 점들을 x 기준으로 정렬했을때 가운데에 있는 점을 xBar 라 하면 S_y 는 xBard - d, xBar + d 사이에 있는 모든 점이다. 만약에 왼쪽에 있는 p, 오른쪽에 있는 q 가 존재한다면 이 둘은 S_y 사이에 있고 아래 증명에 에해서 x1, x2 사이 거리는 d 보다 작다.&lt;/p&gt;

&lt;p&gt;왜냐하면, p(x1, y1), q(x2, y2) 사이의 거리가 d 보다 작기 때문에 x1 - x2 &amp;lt;= d 이다.&lt;/p&gt;

&lt;p&gt;(2) S_y 에서 p, q 가 존재한다면 그건 y 기준으로 7 원소 이내에 인접해 있다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;https://acrocontext.wordpress.com&#34;&gt;https://acrocontext.wordpress.com&lt;/a&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://sadakurapati.wordpress.com/2013/10/25/quicksort-a-practical-and-efficient-sorting-algorithm/&#34;&gt;http://sadakurapati.wordpress.com&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://www.opendatastructures.org/ods-java/1_3_Mathematical_Background.html&#34;&gt;http://www.opendatastructures.org&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design and Analysis: Randomized Selection</title>
      <link>https://1ambda.github.io/91/algorithm/design-and-analysis-part1-2/</link>
      <pubDate>Sat, 25 Jun 2016 12:54:47 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/design-and-analysis-part1-2/</guid>
      <description>

&lt;h3 id=&#34;intuition&#34;&gt;Intuition&lt;/h3&gt;

&lt;p&gt;중복이 없는 &lt;code&gt;n&lt;/code&gt; 개의 원소를 가진 배열에서 &lt;code&gt;i&lt;/code&gt; 번째로 큰 원소를 얻고 싶다고 하자. 간단한 방법은 먼저 정렬을 한 뒤 거기서 &lt;code&gt;i&lt;/code&gt; 번째 원소를 고르면 된다. 이 방법을 &lt;em&gt;reduction&lt;/em&gt; 이라 부르는데 &lt;em&gt;selection&lt;/em&gt; 문제를 &lt;em&gt;sorting&lt;/em&gt; 문제로 바꾸어 푼 것이다. 이 경우 정렬에 머지소트를 사용한다면 &lt;code&gt;O(n logn)&lt;/code&gt; 만큼의 시간이 걸릴 것이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;selection&lt;/em&gt; 문제는 &lt;code&gt;O(n)&lt;/code&gt; 시간 안에 &lt;em&gt;deterministic&lt;/em&gt; 하게 해결할 수 있다. 지난시간에 잠깐 논의했던 &lt;em&gt;randomization&lt;/em&gt; 을 이용하면 된다. 어떻게 그럴 수 있을까? 저기서 정렬을 더 개선할 수 없다는건 모두가 알고 있는 사실인데&lt;/p&gt;

&lt;p&gt;&lt;em&gt;quick sort&lt;/em&gt; 를 수정해서 &lt;em&gt;pivot&lt;/em&gt; 을 &lt;em&gt;median of medians&lt;/em&gt; 로 고르면 된다. &lt;del&gt;아니 의사양반 이게 무슨 개소리요!&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;더 정확히 말해서 이 문제는 &lt;strong&gt;정렬 문제가 아니기 때문에&lt;/strong&gt; 더 개선할 여지가 있다. &lt;em&gt;pivot&lt;/em&gt; &lt;code&gt;P&lt;/code&gt; 를 기준으로 좌측이나 우측 한쪽만 선택하면 되는 &lt;em&gt;selection&lt;/em&gt; 문제다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;worst case&lt;/em&gt; 는 당연히 매 재귀호출마다 문제 수가 1씩 줄어드는 경우이므로 &lt;code&gt;O(n^2)&lt;/code&gt; 일테다. 만약에, &lt;em&gt;bast case&lt;/em&gt; 로 문제가 절반씩 줄어든다면? &lt;em&gt;master method&lt;/em&gt; 를 이용하면 &lt;code&gt;a = 1, b = 2, d = 1&lt;/code&gt; 에서 &lt;code&gt;T(n) = O(n^1)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://acrocontext.files.wordpress.com/2014/01/master-method.png?w=300&amp;amp;h=160&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그럼 이제 문제는 어떻게 사이즈를 &lt;code&gt;1/2&lt;/code&gt; 로, 더 정확히는 &lt;em&gt;median&lt;/em&gt; 을 &lt;em&gt;pivot&lt;/em&gt; 으로 삼느냐다.&lt;/p&gt;

&lt;h3 id=&#34;analysis&#34;&gt;Analysis&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;randomized selection&lt;/em&gt; 문제를 풀기 위해 구현한 함수를 &lt;code&gt;rSelect&lt;/code&gt; 라 하자. 매 재귀마다 문제 사이즈가 &lt;code&gt;n&lt;/code&gt; 이라고 하면, 각 재귀에서의 &lt;code&gt;rSelect&lt;/code&gt; 의 연산은 &lt;code&gt;c * n&lt;/code&gt; 보다 작거나 같다. (&lt;code&gt;c&lt;/code&gt; 는 상수)&lt;/p&gt;

&lt;p&gt;이제 본격적인 분석전에  잠깐 &lt;em&gt;notation&lt;/em&gt; 을 하나 만들고 가면 &lt;code&gt;phase j&lt;/code&gt; 는 문제의 사이즈가 &lt;code&gt;(3/4)^j+1 * n&lt;/code&gt; 과 &lt;code&gt;(3/4)^j * n&lt;/code&gt; 사이에 있는 &lt;code&gt;rSelect&lt;/code&gt; 다. 따라서 문제의 사이즈가 &lt;code&gt;n&lt;/code&gt; 부터 &lt;code&gt;3/4&lt;/code&gt; 가 되기 전까지의 모든 &lt;code&gt;rSelect&lt;/code&gt; 는 &lt;code&gt;phase 0&lt;/code&gt; 에 있다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code&gt;Xj&lt;/code&gt; 를 &lt;code&gt;phase j&lt;/code&gt; 에 있는 &lt;code&gt;rSelect&lt;/code&gt; 호출의 수라 정의하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20%5Csum_%7Bphase%20j%7D%20X_j%20*%20c%20*%20%28%7B3%20%5Cover%204%7D%29%5Ej%20*%20n&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 정의해 놓으면 재밌는 조건을 하나 쓸 수 있다. 바로 &lt;em&gt;pivot&lt;/em&gt; 이 &lt;code&gt;25%-75%&lt;/code&gt; 사이로 분할만 해주면, 다시 말해서 반으로 갈린 문제 중 작은 한쪽이 적어도 &lt;code&gt;25%&lt;/code&gt; 가 넘으면 현재 &lt;em&gt;phase&lt;/em&gt; 가 끝난다. 그럼 이제 전체 알고리즘의 기대값을 구하기 위해 &lt;em&gt;linearity of expectation&lt;/em&gt; 을 이용해서 &lt;code&gt;E(Xj)&lt;/code&gt; 를 구하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;25-75%&lt;/code&gt; 로 피벗이 걸릴 확률 &lt;code&gt;P(25-75%) = 1/2&lt;/code&gt; 이고 그럴때의 &lt;code&gt;Xj = 1&lt;/code&gt; 이다. 반면 두번째에 피벗이 제대로 걸릴 확률은 &lt;code&gt;1/4&lt;/code&gt; 이고, 세번째에 피벗이 제대로 걸릴 확률은 &lt;code&gt;1/2^3&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;기대값은 이 모든 각각 확률변수값과 그 확률의 곱이므로 계산하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%7B1%20%5Cover%202%7D%20&amp;amp;plus;%20%7B1%20%5Cover%202%5E2%7D%20&amp;amp;plus;%20%7B1%20%5Cover%202%5E3%7D%20&amp;amp;plus;%20%5Ccdots%20%5Cleq%202&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이것 말고 더 재밌는 계산법도 있다. 자세한 건 강의 내용을 참조&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?E%28X_j%29%20%3D%201%20&amp;amp;plus;%20%7B1%20%5Cover%202%7D%20*%20E%28X_j%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;em&gt;average running&lt;/em&gt; 타임을 구하기 위해 &lt;code&gt;T(n)&lt;/code&gt; 의 평균을 구하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20E%5Bc%20*%20n%20*%20%5Csum_%7Bphase%20j%7D%20%28%7B3%20%5Cover%204%7D%29%5Ej%20*%20X_j%5D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;em&gt;linearity of expectation (기대값의 선형성)&lt;/em&gt; 을 이용하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20c%20*%20n%20*%20%5Csum_%7Bphase%20j%7D%20%28%7B3%20%5Cover%204%7D%29%5Ej%20*%20E%28X_j%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20c%20*%20n%20*%20%5Csum_%7Bphase%20j%7D%202%20*%20%28%7B3%20%5Cover%204%7D%29%5Ej&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;무한급수 공식을 적용하면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20c%20*%20n%20*%204&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;얼마나 멋진가?&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&#34;deterministic-selection&#34;&gt;Deterministic Selection&lt;/h3&gt;

&lt;p&gt;만약에 &lt;em&gt;randomization&lt;/em&gt; 을 이용할 수 없다면? 그럼 이제 문제는 &lt;em&gt;good pivot&lt;/em&gt;, 즉 &lt;code&gt;50/50&lt;/code&gt; 에 최대한 가깝게 잘라내는 &lt;em&gt;pivot&lt;/em&gt; 을 찾아야 한다. &lt;em&gt;median of medians&lt;/em&gt; 를 이용하면 해낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;deterministic selection&lt;/em&gt; 알고리즘을 구현한 함수를 &lt;code&gt;dSelect&lt;/code&gt; 라 부르면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dSelect(array A, length n, order statistic i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1) Break &lt;code&gt;A&lt;/code&gt; into groups of 5, sort each group&lt;br /&gt;
(2) C = the &lt;code&gt;n/5&lt;/code&gt; &amp;ldquo;middle elements&amp;rdquo;&lt;br /&gt;
(3) p = &lt;code&gt;dSelect(C, n/5, n/10)&lt;/code&gt;, recursivly computes median of C&lt;br /&gt;
(4) Partition &lt;code&gt;A&lt;/code&gt; around &lt;code&gt;p&lt;/code&gt;&lt;br /&gt;
(5) if &lt;code&gt;j = i&lt;/code&gt; return &lt;code&gt;p&lt;/code&gt;&lt;br /&gt;
(6) if &lt;code&gt;j &amp;lt; i&lt;/code&gt; return &lt;code&gt;dSelect(1st part of A, j-1, i)&lt;/code&gt;&lt;br /&gt;
(7) if &lt;code&gt;j &amp;gt; i&lt;/code&gt; return &lt;code&gt;dSelect(2nd part of A, j-j, i-j)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;4-7&lt;/code&gt; 스텝은 &lt;em&gt;randomized selection&lt;/em&gt; 과 똑같다. 더 복잡해진 부분은 앞의 &lt;code&gt;1-3&lt;/code&gt; 스텝에서 피벗을 고르는 일이다.&lt;/p&gt;

&lt;p&gt;퍼포먼스를 다시 이야기 해 보자 &lt;em&gt;randomized selection&lt;/em&gt; 은 &lt;em&gt;pivot&lt;/em&gt; 이 정말 나쁘게 선택되면 &lt;code&gt;O(n^2)&lt;/code&gt; 이 될 수 있다.&lt;/p&gt;

&lt;p&gt;반면 &lt;em&gt;deterministic selection&lt;/em&gt; 은 모든 경우에 &lt;code&gt;O(n)&lt;/code&gt; 을 보장한다. 그러나 실제로는 &lt;em&gt;randomized&lt;/em&gt; 보다 성능이 나쁜데, 이유는 알고리즘에서 볼 수 있듯이 새로운 배열 &lt;code&gt;C&lt;/code&gt; 가 필요하고 (&lt;em&gt;not in-place&lt;/em&gt;), 표기법에는 상수가 생략되는데 &lt;em&gt;deterministic selection&lt;/em&gt; 은 이 상수가 꽤나 커질 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;analysis-1&#34;&gt;Analysis&lt;/h3&gt;

&lt;p&gt;이제 좀 더 자세히 살펴보자.&lt;/p&gt;

&lt;p&gt;(1) Break &lt;code&gt;A&lt;/code&gt; into groups of 5, sort each group&lt;/p&gt;

&lt;p&gt;이건 얼마의 시간이 걸릴까? 주어진 배열을 5개씩 짜르고, 각각의 그룹을 정렬하는데 걸리는 시간은? &lt;code&gt;O(n)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code&gt;n = 120&lt;/code&gt; 이라 하자. 정렬에 &lt;em&gt;merge sort&lt;/em&gt; 를 사용하면 &lt;em&gt;merge sort&lt;/em&gt; 연산 수 공식은&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?6n%20*%20log_2%28n&amp;amp;plus;1%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;따라서 잘려진 5개짜리를 정렬하는데 걸리는 시간은 &lt;code&gt;30 * log_2(6)&lt;/code&gt; 에서, 이 값은 적어도 120 보다는 작음을 알 수 있다. 따라서 전체 그룹의개수 &lt;code&gt;n/5&lt;/code&gt; 를 곱하면, &lt;code&gt;24n&lt;/code&gt; 으로 &lt;code&gt;O(n)&lt;/code&gt; 임을 알 수 있다. 비록 상수가 좀 크긴 하지만&lt;/p&gt;

&lt;p&gt;(2) C = the &lt;code&gt;n/5&lt;/code&gt; &amp;ldquo;middle elements&amp;rdquo;&lt;br /&gt;
(3) p = &lt;code&gt;dSelect(C, n/5, n/10)&lt;/code&gt;, recursivly computes median of C&lt;br /&gt;
(4) Partition &lt;code&gt;A&lt;/code&gt; around &lt;code&gt;p&lt;/code&gt;&lt;br /&gt;
(5) if &lt;code&gt;j = i&lt;/code&gt; return &lt;code&gt;p&lt;/code&gt;&lt;br /&gt;
(6) if &lt;code&gt;j &amp;lt; i&lt;/code&gt; return &lt;code&gt;dSelect(1st part of A, j-1, i)&lt;/code&gt;&lt;br /&gt;
(7) if &lt;code&gt;j &amp;gt; i&lt;/code&gt; return &lt;code&gt;dSelect(2nd part of A, j-j, i-j)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(2), (4) 는 &lt;code&gt;O(n)&lt;/code&gt; 임을 알 수 있고, (3) 은 &lt;code&gt;T(n/5)&lt;/code&gt; 다. 문제는 (6), (7) 이다. 둘 중에 하나만 호출되긴 하지만 선택되는 &lt;em&gt;pivot&lt;/em&gt; &lt;code&gt;p&lt;/code&gt; 에 따라서 문제의 사이즈가 달라진다. 모르니까 &lt;code&gt;T(?)&lt;/code&gt; 라 두자 그러면 &lt;em&gt;determinitic selection&lt;/em&gt; 의 &lt;em&gt;running time&lt;/em&gt; 은&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&amp;amp;plus;%20T%28n/5%29%20&amp;amp;plus;%20T%28%3F%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;간단한 가설을 세워보자.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;두번째 &lt;code&gt;dSelect&lt;/code&gt; 호출의 input size 는 &lt;code&gt;7/10 * n&lt;/code&gt; 보다 작거나 같다&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그러면 수식을 이렇게 바꿀 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&amp;amp;plus;%20T%28n/5%29%20&amp;amp;plus;%20T%287n/10%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;(2) 에서 &lt;em&gt;medians&lt;/em&gt; 를 찾고, 이걸 (3)에서 재귀에 한번 더 넘기면 &lt;em&gt;median of medians&lt;/em&gt; 을 찾게된다. 이게 어떤 효과가 있냐면, 모든 원소를 5개씩 짤라 아래에서 위로 정렬, &lt;em&gt;medians&lt;/em&gt; 는 좌에서 우로 정렬하면 다음과 같은 행렬이 나오는데&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/gaOxb1A.jpg?1&#34; alt=&#34;&#34; /&gt;&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://functionspace.org/articles/19&#34;&gt;http://functionspace.org/articles/19&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;모든 원소 중 좌측 하단에 있는 &lt;code&gt;30%&lt;/code&gt; 는 &lt;em&gt;median of medians&lt;/em&gt; 보다 분명히 작다. 그리고 우측 상단 &lt;code&gt;30%&lt;/code&gt; 는 &lt;em&gt;medians of medians&lt;/em&gt; 보다 분명히 크다. 따라서 나머지 40% 값이 어쨌던건 간에 적어도 &lt;code&gt;30-70%&lt;/code&gt; 분할은 해주므로 문제의 사이즈가 (6) 스텝에서 &lt;code&gt;7n/10&lt;/code&gt; 보다 작거나 같다는 것을 분명히 보장해준다. 따라서 아래 식은 참이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&amp;amp;plus;%20T%28n/5%29%20&amp;amp;plus;%20T%287n/10%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;쉽게 &lt;em&gt;master method&lt;/em&gt; 를 이용하고 싶은데 문제가 서로 다른 사이즈로 분할되니까 사용할 수 없다. &lt;em&gt;induction&lt;/em&gt; 을 이용하자. 아래가 참임을 보이면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20an&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;우선 &lt;em&gt;base case&lt;/em&gt; 는 &lt;code&gt;T(1) = 1&lt;/code&gt; 이므로 &lt;code&gt;T(1) &amp;lt;= a (where a &amp;gt;= 1)&lt;/code&gt; 에서 참이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&amp;amp;plus;%20T%28n/5%29%20&amp;amp;plus;%20T%287n/10%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이제 위 식에서 &lt;em&gt;induction hypothesis&lt;/em&gt; 를 이용하고, 정리하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&amp;amp;plus;%20a%28n/5%29%20&amp;amp;plus;%20a%287n/10%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20n%20*%20%289a/10%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 때 &lt;code&gt;c&lt;/code&gt; 는 상수이므로 &lt;code&gt;c = a / 10&lt;/code&gt; 이라 하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20an&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;deterministic selection&lt;/em&gt; 의 성능은 &lt;code&gt;O(n)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&#34;lower-bound-for-sorting&#34;&gt;lower bound for sorting&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;comparison-based sorting&lt;/em&gt; 의 &lt;em&gt;lower bound&lt;/em&gt; 는&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%0A%5COmega%20(n*log%20n)&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;여기 해당되는 정렬들은 &lt;em&gt;merge sort, quick sort, heap sort&lt;/em&gt; 등이 있다. 이런 정렬들은 데이터가 어떠할 것이라는 가정 없이 정렬을 해낸다.&lt;/p&gt;

&lt;p&gt;반면 데이터의 분포를 안다면 &lt;em&gt;bucket sort&lt;/em&gt; 같은 경우 &lt;em&gt;linear time&lt;/em&gt; 으로 해결할 수 있다. &lt;em&gt;counting sort&lt;/em&gt; 나 &lt;em&gt;radix sort&lt;/em&gt; 같은 정렬도 데이터에 대한 정보(정수)라는 것을 이미 알고 있는 경우이므로 &lt;code&gt;O(n)&lt;/code&gt; 으로 정렬 가능하다.&lt;/p&gt;

&lt;p&gt;데이터에 대한 정보를 모른다고 해 보자. &lt;code&gt;1, 2, ..., n&lt;/code&gt; 까지의 데이터를 가지고 있다면 이 데이터들이 배열 안에 담겨있을 수 있는 경우의 수는 &lt;code&gt;n!&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;n!&lt;/code&gt; 개의 모든 종류의 인풋에 대해서 &lt;code&gt;k&lt;/code&gt; 번만큼, 혹은 그보다 더 적게 비교가 일어난다고 하자. 그럼 모든 &lt;code&gt;n!&lt;/code&gt; 종류의 인풋에 대해서 &lt;code&gt;2^k&lt;/code&gt; 개의 서로 다른 &lt;em&gt;execution&lt;/em&gt; 이 생긴다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose algorithm always makes &amp;lt;= k comparisons to correctly sort these &lt;code&gt;n!&lt;/code&gt; inputs. Across all &lt;code&gt;n!&lt;/code&gt; possile inputs algorithms exhibits &amp;lt;= &lt;code&gt;2^k&lt;/code&gt; distinct executions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;쉽게 생각해서 &lt;code&gt;k-bit&lt;/code&gt; 문자열이 있을때 이걸로 얻을 수 있는 문자열은 &lt;code&gt;2^k&lt;/code&gt; 개수다. 즉 어떤 문자는 없을수도 있다.&lt;/p&gt;

&lt;p&gt;비둘기 집 원리를 생각해 보자. 우리는 &lt;code&gt;n!&lt;/code&gt; 비둘기가 있고, &lt;code&gt;2^k&lt;/code&gt; 개의 비둘기 집이 있다. 만약에 &lt;code&gt;k&lt;/code&gt; 가 작아 &lt;code&gt;2^k &amp;lt; n!&lt;/code&gt; 이면 서로 다른 두개의 인풋에 대해서 같은 종류의 &lt;em&gt;execution&lt;/em&gt; 을 공유 한다는 뜻이다. 따라서 둘 중 하나는 제대로 정렬되고, 나머지 하나는 제대로 정렬되지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;2^k &amp;gt;= n!&lt;/code&gt; 이다. 이때&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?n%21%20%5Cgeq%20n%20*%20%28n-1%29%20*%20%28n-2%29%20%5Ccdots%20%28n/2%29%20%5Cgeq%20%28n/2%29%5E%7B%28n/2%29%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이므로&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?2%5Ek%20%5Cgeq%20%28n/2%29%5E%7Bn/2%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?k%20%5Cgeq%20%28n/2%29*%20log_2%28n/2%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?k%20%5Cgeq%20%5COmega%28n*logn%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;k&lt;/code&gt; 가 연산 수 이므로 &lt;em&gt;comparison-based sorting&lt;/em&gt; 의 &lt;em&gt;lower bound&lt;/em&gt; 는 &lt;code&gt;Omega(n logn)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;em&gt;Algorithms: Design and Analysis, Part 1&lt;/em&gt; by &lt;strong&gt;Tim Roughgarden&lt;/strong&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://functionspace.org/articles/19&#34;&gt;http://functionspace.org/articles/19&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design and Analysis: Graph Contraction Algorithm</title>
      <link>https://1ambda.github.io/91/algorithm/design-and-analysis-part1-3/</link>
      <pubDate>Sat, 25 Jun 2016 12:54:48 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/design-and-analysis-part1-3/</guid>
      <description>

&lt;p&gt;이번엔 지난시간에 배운 &lt;em&gt;randomized algorithm&lt;/em&gt; 을 새로운 &lt;em&gt;domain&lt;/em&gt; 인 그래프에 적용해 보고, &lt;em&gt;contraction algorithm&lt;/em&gt; 이 무엇인지 알아본다.&lt;/p&gt;

&lt;h3 id=&#34;graphs&#34;&gt;Graphs&lt;/h3&gt;

&lt;p&gt;용어 정리부터 시작하자. &lt;em&gt;edge&lt;/em&gt; &lt;code&gt;(E)&lt;/code&gt; 는 &lt;em&gt;pair of vertices&lt;/em&gt; 와 같은 말이다. &lt;code&gt;(E)&lt;/code&gt; 는 &lt;em&gt;directed or undirected&lt;/em&gt; 일 수 있으므로 &lt;em&gt;unordered pair&lt;/em&gt; 또는 &lt;em&gt;ordered pair&lt;/em&gt; 일 수 있다. &lt;em&gt;directed edges&lt;/em&gt; 는 다른말로 &lt;em&gt;arcs&lt;/em&gt; 라 부르기도 한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;cut&lt;/em&gt; 은 그래프를 비어있지 않은 두개의 그룹으로 분리하는 것을 말한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A cut of a graph &lt;code&gt;(V, E)&lt;/code&gt; is a partition of &lt;code&gt;V&lt;/code&gt; into two non-empty sets &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 &lt;em&gt;vertice&lt;/em&gt; 가 &lt;code&gt;n&lt;/code&gt; 개라면 &lt;code&gt;2^n - 2&lt;/code&gt; 개의 &lt;em&gt;cut&lt;/em&gt; 을 만들 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;minimum-cut-problem&#34;&gt;Minimum Cut Problem&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;crossing edge&lt;/em&gt; 를 최소로 하는 &lt;em&gt;cut&lt;/em&gt; 을 찾는 문제다. 이걸 어디다 쓸 수 있을까?&lt;/p&gt;

&lt;p&gt;(1) identify network bottlenecks / weaknesses&lt;br /&gt;
(2) community detection in social network&lt;/p&gt;

&lt;p&gt;두 사람 혹은 집단간 강하게 결합되고 나머지와는 약하게 결합된 부분(&lt;em&gt;mimimum cut&lt;/em&gt;) 을 찾으면 두 개체간 관련성이 있다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;(3) image segmentation&lt;/p&gt;

&lt;p&gt;이미지를 &lt;em&gt;2D grid&lt;/em&gt; 라 &lt;em&gt;grid edge&lt;/em&gt; 를 만들어 &lt;em&gt;same object&lt;/em&gt; 에서 왔을 가능성을 나타내는 가중치를 부여해 &lt;em&gt;min cut&lt;/em&gt; 을 하면 쓸모 없는 부분이 잘려나간다.&lt;/p&gt;

&lt;h3 id=&#34;graph-representation&#34;&gt;Graph representation&lt;/h3&gt;

&lt;p&gt;그래프가 &lt;em&gt;sparse graphs&lt;/em&gt;, &lt;em&gt;dense graphs&lt;/em&gt; 냐에 따라 알고리즘이 성능이 잘 나올수도 있고 아닐수도 있기 때문에 이 두 가지를 구분해 보자.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 을 &lt;em&gt;the number of vetices&lt;/em&gt;, &lt;code&gt;m&lt;/code&gt; 을 &lt;em&gt;the number of edges&lt;/em&gt; 라 하자. 대부분의 경우에 &lt;code&gt;m&lt;/code&gt; 은 &lt;code&gt;Omega(n)&lt;/code&gt;, &lt;code&gt;O(n^2)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;sparse graph&lt;/em&gt; 는 &lt;code&gt;m&lt;/code&gt; 이 &lt;code&gt;O(n)&lt;/code&gt; 에 가깝고 &lt;em&gt;dense graphs&lt;/em&gt; 는 &lt;code&gt;m&lt;/code&gt; 이 &lt;code&gt;O(n^2)&lt;/code&gt; 에 가깝다.&lt;/p&gt;

&lt;h3 id=&#34;adjacency-matrix&#34;&gt;Adjacency Matrix&lt;/h3&gt;

&lt;p&gt;그래프를 자료구조로 표현하는 몇 가지 방법이 있는데 &lt;em&gt;Adjacency matrix (인접행렬)&lt;/em&gt; 의 경우에는 노드 수, &lt;code&gt;n&lt;/code&gt; 에 대해 &lt;code&gt;n x n&lt;/code&gt; 의 행렬 &lt;code&gt;A&lt;/code&gt; 를 만들어서 &lt;code&gt;A_ij&lt;/code&gt; 를 &lt;code&gt;i&lt;/code&gt; 노드와 &lt;code&gt;j&lt;/code&gt; 노드가 연결되었다면 값을 &lt;code&gt;1&lt;/code&gt; 채운다&lt;/p&gt;

&lt;p&gt;몇 가지 변형이 있을 수 있는데 &lt;em&gt;parallel edges&lt;/em&gt; 가 허용된다면 &lt;code&gt;A_ij&lt;/code&gt; 는 연결된 엣지 수 일 수 있고, &lt;code&gt;A_ij&lt;/code&gt; 에 가중치를 담는 경우도 있다. &lt;em&gt;directed graph&lt;/em&gt; 면 &lt;code&gt;i -&amp;gt; j&lt;/code&gt; 냐 &lt;code&gt;j -&amp;gt; i&lt;/code&gt; 냐에 따라 &lt;code&gt;-1 or +1&lt;/code&gt; 을 값으로 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;어떤 경우든 &lt;em&gt;adjacency matrix&lt;/em&gt; 방식 자체는 &lt;em&gt;edge&lt;/em&gt; 수와는 관계 없이 &lt;em&gt;vertice&lt;/em&gt; 수의 제곱에 비례하는 공간이 필요하다. 따라서 &lt;em&gt;sparse graphs&lt;/em&gt; 에서는 사용하지 않는 편이 낫다.&lt;/p&gt;

&lt;h3 id=&#34;adjacency-list&#34;&gt;Adjacency List&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Adjacency list (인접 리스트)&lt;/em&gt; 로 그래프를 표현할 경우엔&lt;/p&gt;

&lt;p&gt;(1) array (or list) of vertices (&lt;code&gt;theta(n)&lt;/code&gt;)&lt;br /&gt;
(2) array (or list) of edges (&lt;code&gt;theta(m)&lt;/code&gt;)&lt;br /&gt;
(3) each edge points to its endpoint (&lt;code&gt;theta(m)&lt;/code&gt;)&lt;br /&gt;
(4) each vertex points edges (&lt;code&gt;theta(m)&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;(4) 의 경우 &lt;em&gt;undirected graph&lt;/em&gt; 라면 명확한데, &lt;em&gt;directed graph&lt;/em&gt; 의 경우에는 &lt;em&gt;tail&lt;/em&gt; 만 저장 한다던지 몇가지 방법을 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;그럼 &lt;em&gt;adjacency list&lt;/em&gt; 는 얼마의 공간을 차지할까? (3) 의 경우는 위에 표시했듯이 (&lt;code&gt;theta(m)&lt;/code&gt;) 인데, 각각의 &lt;em&gt;edge&lt;/em&gt; 는 2 개의 &lt;em&gt;vertex&lt;/em&gt; 를 저장하지만 &lt;code&gt;2&lt;/code&gt; 는 상수 취급한다.&lt;/p&gt;

&lt;p&gt;(4) 가 노드마다 간선 수가 달라 계산이 어려울 수 있는데, (3) 과 1:1 대응이라 보면 된다. 노드가 가리키는 간선이나, 간선이 가리키는 노드나 수는 같다. 따라서 (&lt;code&gt;theta(m)&lt;/code&gt;) 이므로 전체 메모리 사용은 (&lt;code&gt;theta(m + n)&lt;/code&gt;) 이다.&lt;/p&gt;

&lt;p&gt;그러면 인접 행렬과 인접 행렬중 어떤게 더 나을까? 둘 다 장단이 있지만 &lt;em&gt;graph search&lt;/em&gt; 는 단연 인접 행렬이 더 낫고, 요즘엔 &lt;em&gt;node&lt;/em&gt; 는 정말 많은 반면 &lt;em&gt;edge&lt;/em&gt; 는 좀 적기 때문에 인접 리스트가 더 낫다.&lt;/p&gt;

&lt;p&gt;간단히 웹만 생각해봐도 노드 자체는 엄청나게 많은 반면 간선은 적다. 만약 인접 행렬로 그래프를 표현하면 노드 수의 제곱에 비례하는 메모리가 필요한데, 이건 리소스 문제를 겪을 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;random-contraction-algorithm&#34;&gt;Random Contraction Algorithm&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;min cut&lt;/em&gt; 을 해결하기 위해 &lt;em&gt;quick sort&lt;/em&gt;, &lt;em&gt;randomized selection&lt;/em&gt; 에서 보았던 랜덤 샘플링을 이용할건데, 이 문제는 랜덤 샘플링이 그래프 문제에도 얼마나 효과적인지 보여준다. 알고리즘은 이렇다.&lt;/p&gt;

&lt;p&gt;(1) while there are more than 2 vertices&lt;br /&gt;
(2) pick a remaining edge &lt;code&gt;(u, v)&lt;/code&gt; uniformly at random&lt;br /&gt;
(3) merge (or &amp;ldquo;contract&amp;rdquo;) &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; into a single vertex&lt;br /&gt;
(4) remove self-loops&lt;br /&gt;
(5) return cut represented by final 2 vertices&lt;/p&gt;

&lt;p&gt;해보면 알겠지만 이 알고리즘은 &lt;em&gt;min cut&lt;/em&gt; 을 답으로 제공할 수도, 아닐 수도 있다. 따라서 문제는, &lt;em&gt;What is prob of success?&lt;/em&gt; 를 계산하는 것으로 바뀐다.&lt;/p&gt;

&lt;h3 id=&#34;analysis-contraction-algorithm&#34;&gt;Analysis: Contraction Algorithm&lt;/h3&gt;

&lt;p&gt;분석 전에 몇 가지 용어를 정의하고 가자. &lt;em&gt;graph&lt;/em&gt; &lt;code&gt;G = (V, E)&lt;/code&gt; 에 대해 &lt;code&gt;n&lt;/code&gt; 개의 &lt;em&gt;vertices&lt;/em&gt;, &lt;code&gt;m&lt;/code&gt; 개의 &lt;em&gt;edges&lt;/em&gt; 가 있다. 그리고 &lt;em&gt;minimum cut&lt;/em&gt; &lt;code&gt;(A, B)&lt;/code&gt; 는 &lt;code&gt;G&lt;/code&gt; 를 두개의 비어있지 않은 그룹 &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; 로 나눈다. 그리고 &lt;code&gt;k&lt;/code&gt; 를 &lt;code&gt;(A, B)&lt;/code&gt; 의 &lt;em&gt;crossing edges&lt;/em&gt; 숫자라 하자. 그리고 이들 &lt;em&gt;crossing edges&lt;/em&gt; 를 &lt;code&gt;F&lt;/code&gt; 라 부르자.&lt;/p&gt;

&lt;p&gt;만약에 &lt;code&gt;F&lt;/code&gt; 중 하나의 &lt;em&gt;edge&lt;/em&gt; 가 &lt;em&gt;contraction&lt;/em&gt; 알고리즘 중에 선택 된다면 &lt;code&gt;(A, B)&lt;/code&gt; 는 섞여버린다.&lt;/p&gt;

&lt;p&gt;따라서 이터레이션 동안 &lt;code&gt;A&lt;/code&gt; 내부에 있는 &lt;em&gt;vertex&lt;/em&gt; 끼리만, 그리고 &lt;code&gt;B&lt;/code&gt; 내부에 있는 &lt;em&gt;vertex&lt;/em&gt; 끼리만 &lt;em&gt;contraction&lt;/em&gt; 이 일어나야 한다. 그래야만 &lt;em&gt;minimum cut&lt;/em&gt; 을 찾을 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 올바른 &lt;code&gt;(A, B)&lt;/code&gt; 를 아웃풋으로 얻을 확률은 &lt;code&gt;F&lt;/code&gt; 중 어느 *edge*도 선택되지 않을 확률과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?P_r%5Boutput%20%5C%20is%20%5C%20%28A%2C%20B%29%5D%20%3D%20P_r%5Bnever%5C%20contracts%5C%20an%5C%20edge%5C%20of%20F%5D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;Tex 에 맛들려서 이미지를 추가한건 아니요!&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;S_i&lt;/code&gt; 를 &lt;code&gt;F&lt;/code&gt; 에 있는 &lt;em&gt;edge&lt;/em&gt; 가 이터레이션 &lt;code&gt;i&lt;/code&gt; 에서 &lt;em&gt;contracted&lt;/em&gt; 되는 &lt;em&gt;event (사건)&lt;/em&gt; 이라 하자. 그럼 우리의 목표는 다음의 확률을 계산하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20S_1%20%5Ccap%20%5Cneg%20S_2%20%5Ccap%20%5Ccdots%20%5Ccap%20%5Cneg%20S_%7Bn-2%7D%5D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;증명에 사용할 재미난 그래프의 특징이 하나 있다. 모든 &lt;em&gt;vertex&lt;/em&gt; 의 &lt;em&gt;incident edges, degree&lt;/em&gt; 의 값은 &lt;code&gt;k&lt;/code&gt; 보다 크거나 같다. 왜냐하면 모든 &lt;em&gt;vertex&lt;/em&gt; 는 그 자신과 나머지를 분리하는 &lt;em&gt;cut&lt;/em&gt; 을 가지는데, 이게 &lt;code&gt;k&lt;/code&gt; 라면 &lt;em&gt;min cut&lt;/em&gt; 이고 아니라면 &lt;code&gt;k&lt;/code&gt; 보다 크기 때문이다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;degree of each vertex is at least &lt;code&gt;k&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그리고 모든 &lt;em&gt;vertex&lt;/em&gt; 의 &lt;em&gt;degree&lt;/em&gt; 는 &lt;code&gt;2m&lt;/code&gt;, 즉 모든 &lt;em&gt;edge&lt;/em&gt; 수의 2배이기 때문에 아래 식은 참이고,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%5Csum_%7Bv%7Ddegree%28v%29%20%3D%202m&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;위 식과 각 &lt;em&gt;degree&lt;/em&gt; 합은 &lt;code&gt;kn&lt;/code&gt; 보다 크거나 같으므로 &lt;code&gt;2m&lt;/code&gt; 도 &lt;code&gt;kn&lt;/code&gt; 보다 크거나 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?2m%20%5Cgeq%20kn&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?m%20%5Cgeq%20%28kn/2%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 처음 이터레이션에서 &lt;code&gt;F&lt;/code&gt; 내에 있는 &lt;em&gt;edge&lt;/em&gt; 가 선택될 확률인 &lt;code&gt;P(S_1) = k / m&lt;/code&gt; 이기 때문에&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%7B2%20%5Cover%20n%7D%20%5Cgeq%20%7Bk%20%5Cover%20m%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?P_r%5BS_1%5D%20%5Cleq%20%7B2%20%5Cover%20n%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;P(S_1)&lt;/code&gt; 을 구했으니, 두번째 이터레이션에서 &lt;code&gt;F&lt;/code&gt; 내에 있는 &lt;em&gt;edge&lt;/em&gt; 가 선택되지 않을 확률을 구해보자. 조건부 확률 공식을 이용하면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20S_1%20%5Ccap%20%5Cneg%20S_2%5D%20%3D%20P_r%5B%5Cneg%20S_2%20%7C%20%5Cneg%20S_1%5D%20*%20P_r%5B%5Cneg%20S_1%5D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이때 &lt;code&gt;P(~S_1)&lt;/code&gt; 이 &lt;code&gt;n/2&lt;/code&gt; 보다 작거나 같으므로&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20S_1%5D%20%5Cgeq%20%281%20-%20%7B2%20%5Cover%20n%7D%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;나머지 &lt;code&gt;P(~S_2 | ~S_1)&lt;/code&gt; 을 구하려다 보니 남아있는 &lt;em&gt;edge&lt;/em&gt; 가 얼만지 알 수가 없다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20S_2%20%7C%20%5Cneg%20S_1%5D%20%3D%201%20-%7Bk%20%5Cover%20number%20%5C%20of%5C%20remaining%20%5C%20edges%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그런데, 본래의 그래프가 모든 &lt;em&gt;vertex&lt;/em&gt; 에 대해 &lt;em&gt;at least&lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 개의 &lt;em&gt;edge&lt;/em&gt; 를 가졌으면 &lt;em&gt;contracted&lt;/em&gt; 된 그래프도 모든 &lt;em&gt;vertex&lt;/em&gt; 에 대해 &lt;em&gt;at least&lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 개의 &lt;em&gt;edge&lt;/em&gt; 를 가져야 한다. (우리는 &lt;code&gt;F&lt;/code&gt; 내의 &lt;em&gt;edge&lt;/em&gt; 를 선택하지 않았기 때문)&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;remaining edge&lt;/em&gt; 는 &lt;code&gt;1/2 * k * (n-1)&lt;/code&gt; 보다 크다. (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; 은 &lt;code&gt;n&lt;/code&gt; 으로 &lt;em&gt;edge&lt;/em&gt; 수를 세면 두번씩 카운팅하기 때문에 필요)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%7Bnumber%20%5C%20of%5C%20remaining%20%5C%20edges%7D%20%5Cgeq%201/2%20*%20k%20*%20%28n-1%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;denominator&lt;/em&gt; 의 &lt;em&gt;lower bound&lt;/em&gt; 를 구했기 때문에 &lt;em&gt;fraction&lt;/em&gt; 의 &lt;em&gt;upper bound&lt;/em&gt; 를 구한셈이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20S_2%20%7C%20%5Cneg%20S_1%5D%20%5Cgeq%201%20-%7B2%20%5Cover%20n%20-%201%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이제 규칙성이 보인다. 우리가 구하려는 값은&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20S_1%20%5Ccap%20%5Cneg%20S_2%20%5Ccap%20%5Ccdots%20%5Ccap%20%5Cneg%20S_%7Bn-2%7D%5D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%3D%20P_r%5B%5Cneg%20S_1%5D%20*%20P_r%5B%5Cneg%20S_2%20%7C%20S_1%5D%20*%20P_r%5B%5Cneg%20S_3%20%7C%20%5Cneg%20S_2%20%5Ccap%20%5Cneg%20S_1%5D%20*%20%5Ccdots%20*%20P_r%5B%5Cneg%20S_%7Bn-2%7D%20%7C%20%5Cneg%20S_1%20%5Ccap%20%5Ccdots%20%5Ccap%20%5Cneg%20S_%7Bn-3%7D%5D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%5Cgeq%20%281%20-%20%7B2%20%5Cover%20n%7D%29*%281%20-%20%7B2%20%5Cover%20%28n%20-%201%29%7D%29*%281%20-%20%7B2%20%5Cover%20%28n%20-%202%29%7D%29*%5Ccdots*%20%281%20-%20%7B2%20%5Cover%20%28n%20-%20%28n-4%29%29%7D%29%20*%20%281%20-%20%7B2%20%5Cover%20%28n%20-%20%28n-3%29%29%7D%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;정리하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%3D%20%7B2%20%5Cover%20n%20%5C%20%28n-1%29%7D%20%5Cgeq%20%7B1%20%5Cover%20n%5E2%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;contraction&lt;/em&gt; 알고리즘이 성공할 확률은 &lt;code&gt;n&lt;/code&gt; 이 크면 굉장히 낮다. 근데 이게 &lt;em&gt;brute-force&lt;/em&gt; 에 비하면 놀랍게도 굉장히 높은 성공률이다.&lt;/p&gt;

&lt;p&gt;본래 &lt;code&gt;n&lt;/code&gt; 개의 &lt;em&gt;vertex&lt;/em&gt; 가 있으면 모든 &lt;em&gt;cut&lt;/em&gt; 을 다 해 보려면 &lt;code&gt;2^n&lt;/code&gt; 의 시도가 필요하다. 따라서 &lt;em&gt;contraction&lt;/em&gt; 알고리즘은 꽤 높은 확률을 보장하는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;T_i&lt;/code&gt; 를 &lt;code&gt;i&lt;/code&gt; 번째 &lt;em&gt;trial&lt;/em&gt; 에서 &lt;em&gt;min cut&lt;/em&gt; 을 찾아낼 확률이라 하자. &lt;code&gt;N&lt;/code&gt; 번의 &lt;em&gt;trial&lt;/em&gt; 동안 &lt;em&gt;min cut&lt;/em&gt; 을 찾지 못할 확률은, 매 &lt;em&gt;trial&lt;/em&gt; 이 독립적이기 때문에&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20T_1%20%5Ccap%20%5Cneg%20T_2%20%5Ccap%20%5Ccdots%20%5Ccap%20%5Cneg%20T_N%20%5Ccap%20%5D%20%3D%20%5Cprod_%7Bi%20%3D%201%7D%5EN%20P_r%5B%5Cneg%20T_i%5D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%5Cprod_%7Bi%20%3D%201%7D%5EN%20P_r%5B%5Cneg%20T_i%5D%20%5Cleq%20%281%20-%20%7B1%20%5Cover%20n%5E2%20%7D%29%5EN&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 때 &lt;code&gt;1 + x &amp;lt;= e^x&lt;/code&gt; 란 사실을 이용하면 좀 더 간단한 &lt;em&gt;upper bound&lt;/em&gt; 를 찾으 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%281%20-%20%7B1%20%5Cover%20n%5E2%20%7D%29%5EN%20%5Cleq%20%28e%5E%7B-1%20%5Cover%20n%5E2%7D%29%5EN&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이때 &lt;code&gt;N = n^2&lt;/code&gt; 이라면 &lt;code&gt;N&lt;/code&gt; 번째까지 실패할 확률은 &lt;code&gt;1/e&lt;/code&gt; 보다 작거나 같다. 만약에 &lt;code&gt;N = n^2 lnn&lt;/code&gt; 이면 &lt;code&gt;1/n&lt;/code&gt; 까지 내려간다.&lt;/p&gt;

&lt;p&gt;따라서 단순히 계산을 반복하는 것만으로도 성공 확률을 &lt;code&gt;1/n^2&lt;/code&gt; 에서 &lt;code&gt;1 - 1/n&lt;/code&gt; 까지 올릴 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;running time&lt;/em&gt; 은 &lt;code&gt;Omega(n^2 * m)&lt;/code&gt; 쯤 된다. &lt;code&gt;n^2&lt;/code&gt; 정도의 &lt;em&gt;trial&lt;/em&gt; 이 필요하고 매 &lt;em&gt;trial&lt;/em&gt; 마다 &lt;code&gt;m&lt;/code&gt; 의 &lt;em&gt;edge&lt;/em&gt; 를 살펴봐야 한다.&lt;/p&gt;

&lt;p&gt;여전히 느리다. 이후에는 단순히 &lt;em&gt;trial&lt;/em&gt; 을 늘리는 것 뿐만 아니라 다양한 옵티마이제이션 기법을 활용하는법을 배워보자. 거의 &lt;code&gt;O(n^2)&lt;/code&gt; 까지 줄일 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;counting-minimum-cuts&#34;&gt;Counting Minimum Cuts&lt;/h3&gt;

&lt;p&gt;그래프를 그려보면 알겠지만 &lt;em&gt;min cut&lt;/em&gt; 은 한개가 아니라 여러개 일 수 있다. 그러면 &lt;code&gt;n&lt;/code&gt; 개의 &lt;em&gt;vertice&lt;/em&gt; 를 가진 그래프에서 최대로 가질 수 있는 &lt;em&gt;min cut&lt;/em&gt; 은 몇개 일까?&lt;/p&gt;

&lt;p&gt;그래프에서 각 노드마다 &lt;em&gt;edge&lt;/em&gt; 가 하나밖에 없을땐 &lt;code&gt;n-1&lt;/code&gt; 이고, 아무리 &lt;em&gt;cut&lt;/em&gt; 이 많아봐야 &lt;code&gt;2^n - 2&lt;/code&gt; 보다 적으니까 이 사이에 있는건 분명하다.&lt;/p&gt;

&lt;p&gt;답은 &lt;em&gt;n choose 2&lt;/em&gt;, &lt;code&gt;(n * (n - 1)) / 2&lt;/code&gt; 다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;em&gt;lower bound&lt;/em&gt; 부터 보자. &lt;em&gt;n-cycle&lt;/em&gt; 그래프를 보면 2개를 끊으면 되므로 &lt;code&gt;nC2&lt;/code&gt; 다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;n&lt;/code&gt; 개의 &lt;em&gt;vectice&lt;/em&gt; 를 가진 모든 그래프 중에서 가장 많은 &lt;em&gt;min-cut&lt;/em&gt; 을 가진 그래프들은 적어도 이것보다는 많은 &lt;em&gt;min-cut&lt;/em&gt; 을 가져야 한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;upper bound&lt;/em&gt; 를 보자. &lt;code&gt;(A1, B1), (A2, B2), ..., (At, Bt)&lt;/code&gt; 만큼의 &lt;em&gt;min cut&lt;/em&gt; 이 있다 하자. 이 때 특정 &lt;em&gt;min cut&lt;/em&gt; 인 &lt;code&gt;(Ai, Bi)&lt;/code&gt; 가 나올 확률은 위의 증명을 다시 보면 &lt;code&gt;1/n^2&lt;/code&gt; 보다 큰 &lt;code&gt;2/(n(n-1))&lt;/code&gt; 이다. 이건 &lt;code&gt;nC2&lt;/code&gt; 를 뒤집은 수다.&lt;/p&gt;

&lt;p&gt;다시 말해서 &lt;em&gt;min cut&lt;/em&gt; 을 뽑아낼 확률이&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?P%5Boutput%5C%20%3D%5C%20%28A_i%2C%20B_i%29%5D%20%5Cgeq%20%7B2%20%5Cover%20n%28n-1%29%7D%20%3D%20%7B1%20%5Cover%20%5Cbinom%7Bn%7D%7B2%7D%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 때 &lt;code&gt;S_i&lt;/code&gt; 를 &lt;code&gt;(A_i, B_i)&lt;/code&gt; 가 나오는 사건이라 하면 &lt;code&gt;S_i&lt;/code&gt; 각각은 &lt;em&gt;disjoint&lt;/em&gt; 다.&lt;/p&gt;

&lt;p&gt;중요하니까 다시 한번 반복하면, &lt;code&gt;S_i&lt;/code&gt; 는 &lt;em&gt;disjoin&lt;/em&gt; 고 이로인해 모든 &lt;code&gt;S_i&lt;/code&gt; 를 합하면 &lt;code&gt;1&lt;/code&gt; 이다. 따라서&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%7Bt%20%5Cover%20%5Cbinom%7Bn%7D%7B2%7D%7D%20%5Cleq%201&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%7Bt%7D%20%5Cleq%20%5Cbinom%7Bn%7D%7B2%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이건 &lt;em&gt;upper bound&lt;/em&gt; 다. &lt;em&gt;lower bound&lt;/em&gt; 와 같으므로 모든 &lt;code&gt;n&lt;/code&gt; 개의 &lt;em&gt;vertice&lt;/em&gt; 를 가진 그래프는 최대 &lt;code&gt;nC2&lt;/code&gt; 의 &lt;em&gt;min cut&lt;/em&gt; 을 가진다.&lt;/p&gt;

&lt;h3 id=&#34;conditional-prob&#34;&gt;Conditional Prob&lt;/h3&gt;

&lt;p&gt;중간에 잠깐 조건 부 확률과 독립성, 그리고 기대값에 대해 나오는데 반-직관적인 예제를 교수님이 소개해 주셔서 적어볼까 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?X_1%2C%20X_2%20%5Cin%20%5C%7B%200%2C%201%20%5C%7D%20%5C%20and%20%5C%20X_3%20%3D%20X_1%20%5Coplus%20X_3&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;일때 &lt;code&gt;X_1&lt;/code&gt; 과 &lt;code&gt;X_3&lt;/code&gt; 는 독립이고, &lt;code&gt;X_1, X_3&lt;/code&gt; 와 &lt;code&gt;X_2&lt;/code&gt; 는 독립이 아니다. 기대값을 이용하면 쉽게 증명이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?E%5BX_1%2C%20X_2%2C%20X_3%5D%20%5Cneq%20E%5BX_1%2C%20X_2%5D%20*%20E%5BX_3%5D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;em&gt;Algorithms: Design and Analysis, Part 1&lt;/em&gt; by &lt;strong&gt;Tim Roughgarden&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design and Analysis: Graph Search and Connectivity</title>
      <link>https://1ambda.github.io/91/algorithm/design-and-analysis-part1-4/</link>
      <pubDate>Sat, 25 Jun 2016 12:54:50 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/design-and-analysis-part1-4/</guid>
      <description>

&lt;p&gt;기본적인 그래프 탐색 방법 &lt;em&gt;DFS&lt;/em&gt;, &lt;em&gt;BFS&lt;/em&gt; 에 대해 배우고 약간씩 응용하여 &lt;em&gt;shortest path&lt;/em&gt;, &lt;em&gt;conncected components&lt;/em&gt;, &lt;em&gt;topological order&lt;/em&gt;, &lt;em&gt;strongly connected components&lt;/em&gt; 등을 찾는 방법을 배운다.&lt;/p&gt;

&lt;p&gt;마지막 부분에선 웹이 어떻게 생겼을까 잠깐 고민해 본다.&lt;/p&gt;

&lt;h3 id=&#34;graph-search&#34;&gt;Graph Search&lt;/h3&gt;

&lt;p&gt;그래프 탐색은 다양하게 활용할 수 있다.&lt;/p&gt;

&lt;p&gt;(1) check if a network is connected&lt;br /&gt;
(2) driving directoin (shortest path)&lt;br /&gt;
(3) formulate a plan (e.g how to fill in a sudoku puzzle)&lt;br /&gt;
(4) compute the &lt;em&gt;&amp;ldquo;pieces&amp;rdquo;&lt;/em&gt; of a graph (e.g clustering)&lt;/p&gt;

&lt;p&gt;그래프를 탐색하는데는 &lt;em&gt;&amp;ldquo;재 방문하지 않는다&amp;rdquo;&lt;/em&gt; 등 여러 조건이 붙으면서 다양한 방법이 있을 수 있겠지만 여기서는 단순히 모든 &lt;em&gt;vertex&lt;/em&gt; 를 방문하는 일반적인 그래프 탐색 알고리즘 (&lt;em&gt;generic algorithm&lt;/em&gt;) 에 대해 먼저 이야기 해 보자.&lt;/p&gt;

&lt;p&gt;이렇게 먼저 일반적인 알고리즘을 정의해 보는 이유는, &lt;em&gt;BFS&lt;/em&gt; 와 &lt;em&gt;DFS&lt;/em&gt; 를 증명할때 먼저 정의한 일반적인 알고리즘의 특수한 경우임을 파악하여 이미 증명된 결과를 활용할 수 있기 때문이다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Goals: &lt;strong&gt;find everything findable from a given start vertex&lt;/strong&gt;, &lt;code&gt;O(m + n)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기서 &lt;em&gt;findable&lt;/em&gt; 이란 말은 두 점 &lt;code&gt;(s, e)&lt;/code&gt; 사이에 &lt;em&gt;path (경로)&lt;/em&gt; 가 있냐는 질문과 동일하다. 경로가 없으면 &lt;em&gt;findable&lt;/em&gt; 이 아니다.&lt;/p&gt;

&lt;p&gt;목표로 하는 복잡도가 &lt;code&gt;O(m + n)&lt;/code&gt; 인데, 이것은 정점의 수 &lt;code&gt;n&lt;/code&gt; 이나 엣지수 &lt;code&gt;m&lt;/code&gt; 중 더 큰 수를 따라간다고 이해하면 된다. 알고리즘은 이렇다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;initially `s` explored, all other vertices are unexplored  
while possible:  
  choose an edge `(u, v)` with `u` explored and `v` unexplored  
  mark `v` explored  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;generic graph search algorithm&lt;/em&gt; 이 끝났을때 &lt;code&gt;v&lt;/code&gt; 가 &lt;em&gt;explored&lt;/em&gt; 라면 그래프 &lt;code&gt;G&lt;/code&gt; 가 &lt;code&gt;s -&amp;gt; v&lt;/code&gt; 인 &lt;em&gt;path&lt;/em&gt; 가 존재한다. 이를 귀납법으로 증명해 보자.&lt;/p&gt;

&lt;p&gt;귀납법이므로 먼저 증명하려는 바를 부정하여 알고리즘이 종료 되었을 때 &lt;code&gt;G&lt;/code&gt; 에서 &lt;code&gt;(s -&amp;gt; v)&lt;/code&gt; 로 가는 경로가 없다고 하자.&lt;/p&gt;

&lt;p&gt;알고리즘 초기 단계에서 &lt;code&gt;s&lt;/code&gt; 만 &lt;em&gt;explored&lt;/em&gt; 고 나머지는 &lt;em&gt;unexplored&lt;/em&gt; 다. 매 탐색마다 &lt;code&gt;(u, w)&lt;/code&gt; 를 찾아내며 &lt;em&gt;unexplored&lt;/em&gt; &lt;code&gt;w&lt;/code&gt; 를 &lt;em&gt;explored&lt;/em&gt; 로 마킹한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(s, v)&lt;/code&gt; 사이 경로가 없다면, 어떤 &lt;code&gt;w&lt;/code&gt; 가 &lt;em&gt;unexplored&lt;/em&gt; 인 &lt;code&gt;(u, w)&lt;/code&gt; 가 알고리즘이 끝났을때 존재해야 한다. &lt;code&gt;w&lt;/code&gt; 가 &lt;code&gt;v&lt;/code&gt; 일수도, &lt;code&gt;u&lt;/code&gt; 가 &lt;code&gt;s&lt;/code&gt; 일수도 있다.&lt;/p&gt;

&lt;p&gt;그러나 이 경우 &lt;em&gt;unexplored&lt;/em&gt; &lt;code&gt;w&lt;/code&gt; 가 존재하면 알고리즘이 절대 종료될 수 없다. 결국 모순이므로 &lt;code&gt;s -&amp;gt; v&lt;/code&gt; &lt;em&gt;path&lt;/em&gt; 가 없다는 것이 잘못되었다.&lt;/p&gt;

&lt;h3 id=&#34;bfs-vs-dfs&#34;&gt;BFS vs DFS&lt;/h3&gt;

&lt;p&gt;사실 그래프 탐색 문제는 &lt;em&gt;crossing edge&lt;/em&gt; 문제와 같다. 한쪽을 &lt;em&gt;explored&lt;/em&gt;, 다른쪽을 &lt;em&gt;unexplored&lt;/em&gt; 라 놓고 각 &lt;em&gt;vertex&lt;/em&gt; 들을 잇는 &lt;em&gt;crossing edge&lt;/em&gt; 를 고르는 문제다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;BFS&lt;/em&gt; 는 기본적으로 &lt;em&gt;queue&lt;/em&gt; 를 사용하면 &lt;code&gt;O(m + n)&lt;/code&gt; 이다. 그리고&lt;/p&gt;

&lt;p&gt;(1) explore nodes in &lt;em&gt;&amp;ldquo;layers&amp;rdquo;&lt;/em&gt;&lt;br /&gt;
(2) can compute &lt;em&gt;&amp;ldquo;shortest path&amp;rdquo;&lt;/em&gt;&lt;br /&gt;
(3) can compute connected components of an undirected graph&lt;/p&gt;

&lt;p&gt;&lt;em&gt;DFS&lt;/em&gt; 는 &lt;em&gt;stack&lt;/em&gt; 을 이용하면 &lt;code&gt;O(m + n)&lt;/code&gt; 이다. 그리고&lt;/p&gt;

&lt;p&gt;(1) explore aggressively like a maze, backtrack only when necessary&lt;br /&gt;
(2) compute topological ordering of directed acyclic graph&lt;br /&gt;
(3) compute connected components in directed graphs&lt;/p&gt;

&lt;h3 id=&#34;breadth-first-search&#34;&gt;Breadth-First Search&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;BFS&lt;/em&gt; 는 &lt;em&gt;shortest path&lt;/em&gt; 를 계산할 수 있고 &lt;em&gt;undirected graph&lt;/em&gt; 의 &lt;em&gt;connected components&lt;/em&gt; 를 구할 수 있다. 그리고 복잡도는 &lt;code&gt;O(m + n)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;함수를 &lt;code&gt;BFS(graph G, start-vertex s)&lt;/code&gt; 라 하면 시작단계에서는 모든 그래프 노드가 &lt;em&gt;unexplored&lt;/em&gt; 다.&lt;/p&gt;

&lt;p&gt;(1) mark &lt;code&gt;s&lt;/code&gt; as explored&lt;br /&gt;
(2) Let &lt;code&gt;Q&lt;/code&gt; - queue data structure &lt;strong&gt;(FIFO)&lt;/strong&gt;, initialied with &lt;code&gt;s&lt;/code&gt;&lt;br /&gt;
(3) while &lt;code&gt;Q&lt;/code&gt; is not empty:&lt;br /&gt;
- remove the first node of &lt;code&gt;Q&lt;/code&gt;, call it &lt;code&gt;v&lt;/code&gt;&lt;br /&gt;
- for each edge &lt;code&gt;(v, w)&lt;/code&gt;, if &lt;code&gt;w&lt;/code&gt; unexplored mark &lt;code&gt;w&lt;/code&gt; as explored and add &lt;code&gt;w&lt;/code&gt; to Q&lt;/p&gt;

&lt;p&gt;시작 점 &lt;code&gt;s&lt;/code&gt; 를 &lt;em&gt;layer 0&lt;/em&gt; 이라 부르면 &lt;em&gt;layer 1&lt;/em&gt; 은 &lt;em&gt;layer 0&lt;/em&gt; 에서 갈 수 있는 지점이다. 모두 저장하고, 큐에서 하나 꺼내 &lt;em&gt;layer 2&lt;/em&gt; 를 계산해서 다시 집어넣고, 이 과정을 반복한다. 알고리즘 중에 이미 방문했는지를 검사하기 때문에 같은 노드를 두번 이상 방문하지 않는다.&lt;/p&gt;

&lt;p&gt;알고리즘이 종료되었을때 &lt;code&gt;v&lt;/code&gt; 가 &lt;em&gt;explored&lt;/em&gt; 라면 &lt;code&gt;s -&amp;gt; v&lt;/code&gt; 인 &lt;em&gt;path&lt;/em&gt; 가 존재한다. 증명은 간단한데 &lt;em&gt;BFS&lt;/em&gt; 가 &lt;em&gt;generic search algorithm&lt;/em&gt; 의 &lt;em&gt;spcial case&lt;/em&gt; 이기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;BFS&lt;/em&gt; 알고리즘을 잘 보면 &lt;em&gt;generic algorithm&lt;/em&gt; 처럼 &lt;code&gt;(u, w)&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; 는 &lt;em&gt;unexplored&lt;/em&gt; 인 &lt;em&gt;edge&lt;/em&gt; 를 찾는데, 이 때 &lt;em&gt;BFS&lt;/em&gt; 는 한 레이어에서 다음 레이어로 갈 수 있는 &lt;em&gt;edge&lt;/em&gt; 만 찾는다는 점이 다르다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;running time&lt;/em&gt; 은 &lt;code&gt;O(n_s + m_s)&lt;/code&gt; 다. 여기서 &lt;code&gt;n_s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 에서 갈 수 있는 &lt;em&gt;node&lt;/em&gt; 의 숫자고 &lt;code&gt;m_s&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 에서 갈 수 있는 &lt;em&gt;edge&lt;/em&gt; 수다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;while&lt;/code&gt; 루프 알고리즘을 다시 보면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while `Q` is not empty:  
  remove the first node of `Q`, call it `v`  
  for each edge `(v, w)`:
    if `w` is unexplored:
      mark `w` as explored
      add `w` to Q
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;한 &lt;em&gt;vertex&lt;/em&gt; 는 아무리 많아봐야 큐에 한번 들어가고,  이 때마다 이 &lt;em&gt;vertex&lt;/em&gt; 에서 갈 수 있는 &lt;em&gt;edge&lt;/em&gt; 를 검사하지만, 결국 아무리 많아봐야 한 &lt;em&gt;edge&lt;/em&gt; 당 두번씩만 검사되고, 검사하는 &lt;code&gt;for&lt;/code&gt; 구문은 &lt;code&gt;O(1)&lt;/code&gt; 이기 때문에 &lt;code&gt;O(m + n)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&#34;shortest-path&#34;&gt;Shortest Path&lt;/h3&gt;

&lt;p&gt;생각해보면 굉장히 쉽다. &lt;code&gt;s&lt;/code&gt; 부터 시작해서 &lt;code&gt;v&lt;/code&gt; 까지의 거리를 찾는 경우 &lt;code&gt;s = v&lt;/code&gt; 면 각 노드의 &lt;code&gt;dist&lt;/code&gt; 값을 &lt;code&gt;0&lt;/code&gt; 으로, 아니면 무한히 큰 값으로 한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;BFS&lt;/em&gt; 에서 레이어마다 하나씩 넘어갈때 마다 &lt;code&gt;dist&lt;/code&gt; 값을 1씩 증가시키는데, 이때 이미 &lt;code&gt;dist&lt;/code&gt; 값이 있는 경우 그 값보다 적으면 새로운 &lt;code&gt;dist&lt;/code&gt; 값을 기록하고, 아니면 기록하지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 알고리즘이 종료되었을때 &lt;code&gt;dist(v) = i&lt;/code&gt; 라면 &lt;code&gt;v&lt;/code&gt; 는 &lt;code&gt;i&lt;/code&gt; 번째 레이어에 있다. 바꿔말하면 &lt;em&gt;shortest path &lt;code&gt;(s, v)&lt;/code&gt;&lt;/em&gt; 는 &lt;code&gt;i&lt;/code&gt; 개의 &lt;em&gt;edge&lt;/em&gt; 를 가지고 있다는 뜻이다.&lt;/p&gt;

&lt;h3 id=&#34;undirected-connectivity&#34;&gt;Undirected Connectivity&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;undirected connectivity&lt;/em&gt; 는 그래프에서 서로 연결된 부분 집합을 찾는 문제다. 용어부터 정의하고 가자면&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;equivalence classes of the relation &lt;code&gt;u ~ v&lt;/code&gt; &amp;lt;=&amp;gt; &lt;code&gt;E(u, v)&lt;/code&gt; path in &lt;code&gt;G&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;equivalence class&lt;/em&gt; 는 처음봤는데 위키에 보니 다음의 3 가지 속성을 만족한다고 한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For every element &lt;code&gt;a&lt;/code&gt; in X, &lt;code&gt;a ~ a&lt;/code&gt; &lt;strong&gt;(reflexivity)&lt;/strong&gt;&lt;br /&gt;
For every two elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in X, if &lt;code&gt;a ~ b&lt;/code&gt;, then &lt;code&gt;b ~ a&lt;/code&gt; &lt;strong&gt;(symmetry)&lt;/strong&gt;&lt;br /&gt;
For every three elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; in X, if &lt;code&gt;a ~ b&lt;/code&gt; and &lt;code&gt;b ~ c&lt;/code&gt;, then &lt;code&gt;a ~ c&lt;/code&gt; &lt;strong&gt;(transitivity)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;connected component&lt;/em&gt; 를 어디다 쓸 수 있을까?&lt;/p&gt;

&lt;p&gt;네트워크에 대해 적용해 보면, 네트워크가 끊어졌는지를 &lt;em&gt;connected component&lt;/em&gt; 를 구해서 두개 이상이 나오는지로 판단할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;clustering&lt;/em&gt; 에도 쓸 수 있다. 만약 두 유전자나, 웹페이지가 비슷한지를 비교해서 &lt;em&gt;connected component&lt;/em&gt; 로 만들면 구별되는 특징을 가진 집단을 만들 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;clustering&lt;/em&gt; 하는 다른 알고리즘이 많음에도 &lt;em&gt;BFS&lt;/em&gt; 는 &lt;em&gt;linear time&lt;/em&gt; 이기 때문에 &lt;em&gt;clustering&lt;/em&gt; 에 충분히 쓸만하다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;undirected&lt;/em&gt; 그래프에서 &lt;em&gt;BFS&lt;/em&gt; 를 이용하면 &lt;em&gt;conncected component&lt;/em&gt; 를 구하는 알고리즘은 이렇다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;all node unexplored // assume labelled 1 to n

for i = 1 to n
  if i not yet explored
    BFS(G, i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;code&gt;BFS&lt;/code&gt; 를 수행할 때 마다 &lt;em&gt;connected component&lt;/em&gt; 가 하나씩 나온다고 말할 수 있다.&lt;/p&gt;

&lt;p&gt;성능은 마찬가지로 &lt;code&gt;O(m + n)&lt;/code&gt; 이다. 왜냐하면 부의 &lt;code&gt;if&lt;/code&gt; 나 &lt;code&gt;for&lt;/code&gt; 그리고 모든 노드를 &lt;em&gt;unexplored&lt;/em&gt; 로 초기화 하는 부분도 &lt;code&gt;O(n)&lt;/code&gt; 이고, 각 노드 하나씩에 대해서 방문하지 않았을 때만 &lt;em&gt;BFS&lt;/em&gt; 를 수행하는데 &lt;em&gt;BFS&lt;/em&gt; 는 &lt;em&gt;edge&lt;/em&gt; 에 대해서는 &lt;code&gt;O(1)&lt;/code&gt; 이고, 모든 &lt;em&gt;edge&lt;/em&gt; 를 검사하므로 &lt;em&gt;BFS&lt;/em&gt; 의 전체 성능은 &lt;code&gt;O(m)&lt;/code&gt; 이다. 따라서 &lt;code&gt;O(m + n)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;depth-first-search&#34;&gt;Depth-First Search&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;explore aggressively, and backtrack when necessary&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;BFS&lt;/em&gt; 로도 &lt;code&gt;O(m +n)&lt;/code&gt; 시간 내에 탐색하고 &lt;em&gt;shortest path&lt;/em&gt;, &lt;em&gt;connected component&lt;/em&gt; 를 찾는데 왜 &lt;em&gt;DFS&lt;/em&gt; 가 필요할까?&lt;/p&gt;

&lt;p&gt;(1) can computes a topological ordering of a directed acyclic graph&lt;br /&gt;
(2) strongly conncected components of directed graphs&lt;/p&gt;

&lt;p&gt;&lt;em&gt;BFS&lt;/em&gt; 는 못하는 이 두 가지 문제를 &lt;code&gt;O(m + n)&lt;/code&gt; 으로 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;코드는 비슷한데 &lt;em&gt;queue&lt;/em&gt; 대신 &lt;em&gt;stack&lt;/em&gt; 을 쓰도록 하고, 재귀버전으로 작성해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DFS(graph G, start-vertex s)

mark s as explored

for every edge (s, v):
  if v is unexplored
    DFS(G, v)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;DFS&lt;/em&gt; 가 종료 됐을때 &lt;code&gt;v&lt;/code&gt; 가 &lt;em&gt;explored&lt;/em&gt; 라면 &lt;code&gt;s -&amp;gt; v&lt;/code&gt; 인 &lt;em&gt;path&lt;/em&gt; 가 있다. 이는 &lt;em&gt;DFS&lt;/em&gt; 가 위에서 본 &lt;em&gt;generic search algorithm&lt;/em&gt; 의 특별한 케이스임을 생각하면 쉽게 알 수 있다.&lt;/p&gt;

&lt;p&gt;성능은 &lt;em&gt;BFS&lt;/em&gt; 와 같이 &lt;code&gt;O(n_s  m_s)&lt;/code&gt; 인데, 각 &lt;em&gt;vertex&lt;/em&gt; 는 아무리 많아봐야 한번, &lt;em&gt;edge&lt;/em&gt; 는 아무리 많아봐야 두번씩 체크하고 &lt;em&gt;edge&lt;/em&gt; 내부에서의 연산은 &lt;code&gt;O(1)&lt;/code&gt; 이기 때문이다.&lt;/p&gt;

&lt;h3 id=&#34;topological-sort&#34;&gt;Topological Sort&lt;/h3&gt;

&lt;p&gt;정의부터 보면&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;toplogical ordering&lt;/strong&gt; of a &lt;em&gt;directed graph&lt;/em&gt; &lt;code&gt;G&lt;/code&gt; is a labelling &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;G&lt;/code&gt;&amp;rsquo;s nodes such that&lt;br /&gt;
1. the &lt;code&gt;f(v)&lt;/code&gt;&amp;rsquo;s are the set &lt;code&gt;{1, 2, 3, ..., n}&lt;/code&gt;&lt;br /&gt;
2. &lt;code&gt;(u, v)&lt;/code&gt; in &lt;code&gt;G&lt;/code&gt; =&amp;gt; &lt;code&gt;f(u)&lt;/code&gt; &amp;lt; &lt;code&gt;f(v)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이미지로 보면 더 이해하기 쉽다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.stoimen.com/blog/wp-content/uploads/2012/12/3.-Topological-Sort-Order.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.stoimen.com&#34;&gt;http://www.stoimen.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;왜 &lt;em&gt;topological sort&lt;/em&gt; 가 필요할까? &lt;em&gt;precedence constraints&lt;/em&gt; 가 있는 &lt;em&gt;sequence&lt;/em&gt; 에서 나올 수 있는 모든 경우의 수를 파악하기에 좋다. 예를 들어 선수과목이 있을때 이수 가능한 스케쥴이라던가, 일정이라던가.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Sequence taks while respecting all precedence constraints&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;단, &lt;em&gt;topological sort&lt;/em&gt; 를 하기 위한 조건이 하나 있는데 &lt;em&gt;directed cycle&lt;/em&gt; 이 없어야 한다. 다시 말해 &lt;em&gt;acyclic&lt;/em&gt; 이어야 한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If &lt;code&gt;G&lt;/code&gt; has directed cycle, then no topological ordering&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;directed graph&lt;/em&gt; 에서 &lt;em&gt;outgoing edge&lt;/em&gt; 가 없는 것을 &lt;em&gt;sink vertex&lt;/em&gt; 라 하자. 그러면 &lt;em&gt;directed acyclic graph, DAG&lt;/em&gt; 는 최소한 하나의 &lt;em&gt;sink vertex&lt;/em&gt; 를 가지고 있다.&lt;/p&gt;

&lt;p&gt;증명은 &lt;em&gt;contradiction&lt;/em&gt; 을 이용하자. &lt;em&gt;sink vertex&lt;/em&gt; 가 없다고 하면, 쭈욱 방문하다 보면 하나의 &lt;em&gt;vertex&lt;/em&gt; 를 두번 이상 방문하게 되고, 그건 &lt;em&gt;cyclic&lt;/em&gt; 이므로 &lt;em&gt;acyclic&lt;/em&gt; 이란 조건에 위배되므로 모순이다. 따라서 &lt;em&gt;DAG&lt;/em&gt; 에서는 최소한 하나의 &lt;em&gt;sink vertex&lt;/em&gt; 가 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;topological sort&lt;/em&gt; 의 알고리즘은&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let v be a sink vertex of G
set f(v) = n
recurse on G - {v}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;G - {v}&lt;/code&gt; 도 &lt;em&gt;DAG&lt;/em&gt; 이다. 왜냐하면 &lt;em&gt;DAG&lt;/em&gt; 에서 &lt;em&gt;sink vertex&lt;/em&gt; 를 제거해도 &lt;em&gt;DAG&lt;/em&gt; 이기 때문에 매 재귀마다 &lt;code&gt;G&lt;/code&gt; 는 &lt;em&gt;DAG&lt;/em&gt; 가 된다. 이 때 제거하는 &lt;em&gt;sink vertex&lt;/em&gt; 에 전체 노드 수 &lt;code&gt;n&lt;/code&gt; 을 매기기 때문에 최종적으로는 &lt;code&gt;1, .., n&lt;/code&gt; 을 가진 &lt;em&gt;toplogical order&lt;/em&gt; 을 계산할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 &lt;em&gt;DFS&lt;/em&gt; 를 이용해 &lt;em&gt;toplogical sort (위상 정렬)&lt;/em&gt; 을 해보자.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DFS(graph G, start-vertex s)
- mark s explored  
- for every edge (s, v):
    if v not yet explored:
      DFS(G, v)
- set f(s) = current_label // sink vertex
- current_label--
    
DFS-Loop(graph G)
- mark all nodes unexplored
- current_label = n // to keep track of ordering
- for each vertex v in G:
    if v not yet explored:
      DFS(G, v)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;running time&lt;/em&gt; 은 &lt;code&gt;O(m + n)&lt;/code&gt; 이다. &lt;em&gt;node&lt;/em&gt; 마다 &lt;code&gt;O(1)&lt;/code&gt;, &lt;em&gt;edge&lt;/em&gt; 마다 &lt;code&gt;O(1)&lt;/code&gt; 이고 &lt;em&gt;node&lt;/em&gt; 나 &lt;em&gt;edge&lt;/em&gt; 는 두번 방문하지 않기 때문에 (&lt;em&gt;directed graph&lt;/em&gt;) &lt;code&gt;O(m + n)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;위상정렬을 하는지는 &lt;code&gt;(u, v)&lt;/code&gt; 가 &lt;em&gt;edge&lt;/em&gt; 라면 &lt;code&gt;f(u) &amp;lt; f(v)&lt;/code&gt; 임을 보이면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;u&lt;/code&gt; 먼저 방문되었을 경우에는 &lt;code&gt;v&lt;/code&gt; 가 먼저 끝나 &lt;code&gt;n&lt;/code&gt; 이 할당되기 때문에 &lt;code&gt;f(u) &amp;lt; f(v)&lt;/code&gt; 다.&lt;/p&gt;

&lt;p&gt;만약에 &lt;code&gt;v&lt;/code&gt; 가 &lt;code&gt;u&lt;/code&gt; 보다 먼저 방문되면 &lt;code&gt;u&lt;/code&gt; 가 방문되기도 전에 &lt;code&gt;v&lt;/code&gt; 에 대한 방문이 끝나므로 &lt;code&gt;f(u) &amp;lt; f(v)&lt;/code&gt; 다.&lt;/p&gt;

&lt;h3 id=&#34;strongly-connected-components&#34;&gt;Strongly Connected Components&lt;/h3&gt;

&lt;p&gt;먼저 정의부터 보면&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Strongly conncected components (SCCs)&lt;/strong&gt; of a directed graph &lt;code&gt;G&lt;/code&gt; are the equivalence classes of the relation. &lt;code&gt;u ~ v&lt;/code&gt; means path &lt;code&gt;u -&amp;gt; v&lt;/code&gt; and &lt;code&gt;v -&amp;gt; u&lt;/code&gt; in G&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;directed graph&lt;/em&gt; 는 방향성이 있기 때문에 단순히 &lt;em&gt;component&lt;/em&gt; 를 구한다고 해서 &lt;em&gt;equivalence classes&lt;/em&gt; 가 되지 않는다. 서로 순환이 될 수 있는, cyclic  인 &lt;em&gt;component&lt;/em&gt; 를 찾아야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/5/5c/Scc.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://commons.wikimedia.org&#34;&gt;http://commons.wikimedia.org&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;SCC&lt;/em&gt; 는 &lt;em&gt;cycle&lt;/em&gt; 이기 때문에 &lt;em&gt;DFS&lt;/em&gt; 만 돌려도 나올 &lt;strong&gt;수&lt;/strong&gt; 있다. 그런데, 만약 전체로 갈 수 있는 노드에서 &lt;em&gt;DFS&lt;/em&gt; 를 돌려버리면 모든 &lt;em&gt;SCC&lt;/em&gt; 가 합쳐진 형태가 나온다. 다시 말해서 단순 DFS 를 모든 노드에 대해 돌리는 것으로는 &lt;em&gt;SCC&lt;/em&gt; 를 얻을 수도, 못 얻을 수도 있다는 소리다. &lt;em&gt;Kosaraju&amp;rsquo;s Two-Pass Algorithm&lt;/em&gt; 으로 해결할 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;kosaraju-s-2-pass-algorithm&#34;&gt;Kosaraju&amp;rsquo;s 2-pass algorithm&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;O(m + n)&lt;/code&gt; 으로 &lt;em&gt;SCC&lt;/em&gt; 를 구하는 것을 보장한다. 어떻게 그럴까? &lt;em&gt;SCC&lt;/em&gt; 를 찾을 때 &lt;em&gt;DFS&lt;/em&gt; 를 돌릴려면 &lt;strong&gt;특정 노드의 순서&lt;/strong&gt;로 &lt;em&gt;DFS&lt;/em&gt; 를 돌려야 한다. 그렇지 않으면 &lt;em&gt;SCC&lt;/em&gt; 가 나오지 않는다. &lt;em&gt;Kosaraju algorithm&lt;/em&gt; 은 이 순서를 찾아준다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Let G_rev = G with all arcs reversed
run DFS-Loop on G_rev // compute &amp;quot;magical ordering&amp;quot;
run DFS-Loop on G // discover SCCs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;좀 더 자세히 보면 &lt;code&gt;f(v)&lt;/code&gt; 를 각 &lt;em&gt;vertex&lt;/em&gt; 에 대해 &lt;em&gt;finishing time&lt;/em&gt; 이라 보면, 두번째 &lt;code&gt;DFS-Loop&lt;/code&gt; 에서 &lt;code&gt;f(v)&lt;/code&gt; 의 &lt;em&gt;decreasing order&lt;/em&gt; 로 &lt;code&gt;DFS&lt;/code&gt; 를 여러번 돌리면 &lt;em&gt;SCC&lt;/em&gt; 를 찾아준다. 각 함수의 구현을 보면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DFS-Loop(graph G)

global variable t = 0 // # of nodes processed so far
global variable s = NULL // current source vertex

// assume nodes labelled 1 to n
for i = n to 1 by -1:
  if i not yet explored:
    s := i
    DFS(G, i)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;DFS(graph G, node i)

mark i as explored
set leader(i) := node s

for each arc (i, j) in G:
  if j not yet explored:
    DFS(G, j)

t++
set f(i) := t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;첫번째 &lt;code&gt;DFS-Loop&lt;/code&gt; 에서는 &lt;em&gt;edge&lt;/em&gt; 가 뒤집어져 있다. 함수가 끝나면 각 노드마다 &lt;code&gt;f(t)&lt;/code&gt; 를 계산 해 주는데, 이게 사실 &lt;em&gt;SCC&lt;/em&gt; 기준으로 보면 같은 &lt;em&gt;SCC&lt;/em&gt; 내에서는 외부와의 연결고리가 없는 내부 노드가 가장 낮은 &lt;code&gt;f(t)&lt;/code&gt; 를 가지게 된다.&lt;/p&gt;

&lt;p&gt;이제 두번째 &lt;code&gt;DFS-Loop&lt;/code&gt; 를 돌리기 위해 &lt;em&gt;edge&lt;/em&gt; 를 다시 뒤집어서 보면 가장 높은 &lt;code&gt;f(t)&lt;/code&gt; 값을 가지는 노드가 가장 먼저 &lt;em&gt;DFS&lt;/em&gt; 를 돌려야 할 노드가 된다. 그리고 &lt;em&gt;leader&lt;/em&gt; 는 각 &lt;em&gt;SCC&lt;/em&gt; 를 얻기 위해 &lt;em&gt;DFS&lt;/em&gt; 를 시작해야 할 지점이 된다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;running time&lt;/em&gt; 은 &lt;code&gt;2 x DFS&lt;/code&gt; 기 때문에 &lt;code&gt;O(m + n)&lt;/code&gt; 이다. 첫 번째 노드에서 얻은 &lt;em&gt;finisihing time&lt;/em&gt; &lt;code&gt;f(t)&lt;/code&gt; 를 정렬하면 &lt;code&gt;O(n logn)&lt;/code&gt; 이기 때문에 정렬 없이 &lt;em&gt;decreasing&lt;/em&gt; 순서로 &lt;em&gt;DFS&lt;/em&gt; 를 돌게 해줘야 한다.&lt;/p&gt;

&lt;h3 id=&#34;analysis&#34;&gt;Analysis&lt;/h3&gt;

&lt;p&gt;분석에 앞서서 간단한 성질을 먼저 이끌어 내자. 그래프를 변형해 &lt;em&gt;node&lt;/em&gt; 각각을 &lt;em&gt;SCC&lt;/em&gt; 로 만든 &lt;em&gt;meta-graph&lt;/em&gt; 를 생각 해 보자. 이 &lt;em&gt;meta graph&lt;/em&gt; 는 &lt;em&gt;DAG&lt;/em&gt; 다. 왜냐하면 모든 &lt;em&gt;cycle&lt;/em&gt; 있는 그래프는 &lt;em&gt;SCC&lt;/em&gt; 로 포함되었기 때문이다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;G&lt;/code&gt; 나, 여기서 &lt;em&gt;edge, arc&lt;/em&gt; 를 뒤집은 &lt;code&gt;G_rev&lt;/code&gt; 나 같은 &lt;em&gt;SCC&lt;/em&gt; 를 가지고 있다.&lt;/p&gt;

&lt;p&gt;이 때 &lt;code&gt;G&lt;/code&gt; 에서 서로 인접한 &lt;em&gt;SCC&lt;/em&gt; &lt;code&gt;C1 -&amp;gt; C2&lt;/code&gt; 에 대해서 &lt;em&gt;edge&lt;/em&gt; &lt;code&gt;(i, j)&lt;/code&gt; 가 있다고 해 보자. (&lt;code&gt;i -&amp;gt; j&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;그러면 &lt;code&gt;G_rev&lt;/code&gt; 로 계산한 &lt;code&gt;max f(C1) &amp;lt; max f(C2)&lt;/code&gt; 임을 알 수 있다. 다시 말해 &lt;code&gt;C2&lt;/code&gt; 가 먼저 &lt;em&gt;DFS&lt;/em&gt; 를 돌려야 하는 &lt;em&gt;SCC&lt;/em&gt; 인데, 먼저 돌려야 할 수록 더 높은 &lt;em&gt;finishing time&lt;/em&gt; &lt;code&gt;f(t)&lt;/code&gt; 를 가진다.&lt;/p&gt;

&lt;p&gt;이건 쉽게 보일 수 있는데, &lt;code&gt;G_rev&lt;/code&gt; 에서는 &lt;em&gt;arc&lt;/em&gt; 가 반대 방향이 되므로 더 큰 &lt;em&gt;SCC&lt;/em&gt; &lt;code&gt;C1&lt;/code&gt; 이, 다시 말해 더 나중에 계산해야 할 &lt;em&gt;SCC&lt;/em&gt; 가 더 작은 &lt;em&gt;SCC&lt;/em&gt; 가 되므로 먼저 계산이 끝나 더 작은 &lt;code&gt;max f(t)&lt;/code&gt; 를 가지게 된다.&lt;/p&gt;

&lt;p&gt;증명은 &lt;code&gt;C1 union C2&lt;/code&gt; 의 첫번째 노드가 &lt;code&gt;C1&lt;/code&gt; 에 있을 때 &lt;code&gt;C2&lt;/code&gt; 에 있을때로 각각 나눠서 참임을 보이면 쉽다.&lt;/p&gt;

&lt;p&gt;알고리즘을 다시 보면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DFS-Loop(graph G)

global variable t = 0 // # of nodes processed so far
global variable s = NULL // current source vertex

// assume nodes labelled 1 to n
for i = n to 1 by -1:
  if i not yet explored:
    s := i
    DFS(G, i)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;DFS(graph G, node i)

mark i as explored
set leader(i) := node s

for each arc (i, j) in G:
  if j not yet explored:
    DFS(G, j)

t++
set f(i) := t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;DFS&lt;/code&gt; 를 한번 돌릴 때 마다 &lt;em&gt;SCC&lt;/em&gt; 가 하나씩 발견된다. 우선 &lt;em&gt;sink SCC&lt;/em&gt; 가 가장 높은 &lt;code&gt;f(t)&lt;/code&gt; 값을 가지게 되므로 가장 먼저 &lt;em&gt;DFS&lt;/em&gt; 를 돌게 된다. 그리고 &lt;em&gt;SCC&lt;/em&gt; 는 &lt;em&gt;cyclic&lt;/em&gt; 이므로 하나의 &lt;em&gt;SCC&lt;/em&gt; 만 찾고 끝남을 보장한다. 다음으로 높은 &lt;code&gt;f(t)&lt;/code&gt; 값을 가지는 &lt;em&gt;SCC&lt;/em&gt; 를 찾고, 더이상 &lt;em&gt;SCC&lt;/em&gt; 를 찾지 못할 때 까지 반복하고 알고리즘이 끝나는걸 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;처음엔 잘 몰랐는데 &lt;em&gt;leader&lt;/em&gt; 가 해당 &lt;em&gt;SCC&lt;/em&gt; 에서 가장 높은 &lt;code&gt;f(t)&lt;/code&gt; 값을 가지는 &lt;em&gt;node&lt;/em&gt; 다.&lt;/p&gt;

&lt;h3 id=&#34;structure-of-the-web&#34;&gt;Structure of the Web&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;vertices&lt;/em&gt; 를 웹페이지라 보고 &lt;em&gt;edges&lt;/em&gt; 를 하이퍼링크라 보면 웹을 &lt;em&gt;directed graph&lt;/em&gt; 이해할 수 있다.&lt;/p&gt;

&lt;p&gt;그럼 웹은 어떻게 생겼을까? 사람들이 첫번째로 웹이 어떻게 생겼는지 확인하기 위해 시도한 방법은 &lt;em&gt;crawling&lt;/em&gt;, 즉 링크를 따라가며 모든 웹페이지를 긁는 방식이었다.&lt;/p&gt;

&lt;p&gt;그래서 실제로 해보니 2000 년도에는 &lt;em&gt;200 milions&lt;/em&gt; 의 &lt;em&gt;node&lt;/em&gt;, &lt;em&gt;1 bilion&lt;/em&gt; 의 &lt;em&gt;edge&lt;/em&gt; 가 있었다고 한다.&lt;/p&gt;

&lt;p&gt;그럼 이게 어떻게 생겼을까? &lt;em&gt;one big scc&lt;/em&gt; 일거라 보는 관점이 있다. 한쪽에선 오래된 웹페이지들이 있고, 더 뻗어나가지 않는다. 이쪽을 &lt;em&gt;out&lt;/em&gt; 이라 보면 반대편에서는 새로운 웹페이지들이 생겨 기존의 웹페이지에 &lt;em&gt;edge&lt;/em&gt; 를 붙여 나가는 &lt;em&gt;in&lt;/em&gt; 부분이 있다고 할 수 있다. 몇몇 부분에는 전혀 연결이 되지 않은 부분이 있을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://bparsia.files.wordpress.com/2009/11/bowtieweb.png?w=600&amp;amp;h=364&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://bparsia.wordpress.com&#34;&gt;http://bparsia.wordpress.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;웹의 &lt;em&gt;core&lt;/em&gt; 부분은 &lt;em&gt;well connected&lt;/em&gt; 되어 있는데 &lt;em&gt;small world property&lt;/em&gt; 를 가지고 있다. 무슨말이냐면 모든 노드가 각각 서로 연결되어 있진 않지만 연결을 많이 가지고 있는 특정 몇몇 노드에 의해 모든 노드가 연결된다는 뜻이다. 결국 서로 연결되는데 몇 &lt;em&gt;hop&lt;/em&gt; 안걸린다 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Small-world-network-example.png/330px-Small-world-network-example.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://en.wikipedia.org/wiki/Small-world_network&#34;&gt;http://en.wikipedia.org/wiki/Small-world_network&lt;/a&gt;)&lt;/p&gt;
&lt;img src=&#34;http://web.mit.edu/9.29/www/neville_jen/connectivity/MEA2_files/image002.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://web.mit.edu&#34;&gt;http://web.mit.edu&lt;/a&gt;
)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;요즘의 연구들은 웹 그래프가 어떤식으로 진화하는지, 정보들이 어떤식으로 전파되는지 등을 중점으로 하고 있다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;em&gt;Algorithms: Design and Analysis, Part 1&lt;/em&gt; by &lt;strong&gt;Tim Roughgarden&lt;/strong&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://en.wikipedia.org/wiki/Equivalence_class&#34;&gt;Equivalence class&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://www.stoimen.com/blog/2012/12/10/computer-algorithms-topological-sort-revisited/&#34;&gt;http://www.stoimen.com&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://commons.wikimedia.org/wiki/File:Scc.png&#34;&gt;http://commons.wikimedia.org/wiki/File:Scc.png&lt;/a&gt;&lt;br /&gt;
(5) &lt;a href=&#34;http://bparsia.wordpress.com/2009/11/24/does-rest-explain-the-bowtie-gross-structure-of-the-web/&#34;&gt;http://bparsia.wordpress.com&lt;/a&gt;&lt;br /&gt;
(6) &lt;a href=&#34;http://web.mit.edu/9.29/www/neville_jen/connectivity/MEA2.htm&#34;&gt;http://web.mit.edu&lt;/a&gt;&lt;br /&gt;
(7) &lt;a href=&#34;http://en.wikipedia.org/wiki/Small-world_network&#34;&gt;http://en.wikipedia.org/wiki/Small-world_network&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design and Analysis: Dijkstra, Heap, Red-Black Tree</title>
      <link>https://1ambda.github.io/91/algorithm/design-and-analysis-part1-5/</link>
      <pubDate>Sat, 25 Jun 2016 12:54:51 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/design-and-analysis-part1-5/</guid>
      <description>

&lt;h3 id=&#34;dijkstra-s-shortest-path-algorithm&#34;&gt;Dijkstra&amp;rsquo;s Shortest-Path Algorithm&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;BFS&lt;/em&gt; 는 &lt;em&gt;undirected graph&lt;/em&gt; 에서 최단 경로를 찾지만, 이건 모든 &lt;em&gt;edge&lt;/em&gt; 의 길이가 1일때만 그렇다.&lt;/p&gt;

&lt;p&gt;다익스트라(&lt;em&gt;dijkstra&lt;/em&gt;, &lt;em&gt;데이크스트라&lt;/em&gt;) 알고리즘은 &lt;em&gt;directed graph&lt;/em&gt; 에서 &lt;em&gt;non-negative length&lt;/em&gt; 에 대한 최단 경로를 찾아낼 수 있다.&lt;/p&gt;

&lt;p&gt;각 &lt;em&gt;edge&lt;/em&gt; 가 음수라면, 모든 수에 특정 수를 더해 양수로 만들어도, 아니면 음수 그 자체로 다익스트라 알고리즘을 돌려도 최단 경로를 찾지 못한다. 다음의 그래프가 한 예다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 -&amp;gt; 2 // length: 1
2 -&amp;gt; 3 // length: -6
1 -&amp;gt; 3 // length: -2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;금융거래를 보면 특정 거래를 &lt;em&gt;edge&lt;/em&gt; 라 보고 대해 여기에 대하 이득과 손실을 각각 양수, 음수의 가중치를 가지는 그래프라 생각할 수 있는데, 여기엔 음수 가중치가 있으므로 다익스트라 알고리즘을 쓸 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm&#34;&gt;벨만 포드&lt;/a&gt; 알고리즘을 써야한다.&lt;/p&gt;

&lt;p&gt;길이가 &lt;code&gt;n&lt;/code&gt; 인 &lt;em&gt;edge&lt;/em&gt; 를 길이가 &lt;code&gt;1&lt;/code&gt; 인 &lt;code&gt;n&lt;/code&gt; 개의 &lt;em&gt;edge&lt;/em&gt; 로 늘려 &lt;em&gt;BFS&lt;/em&gt; 를 쓸 수 없느냐 질문할 수도 있겠는데, 가중치가 상당히 크면 연산이 비효율적이 된다. (e.g 150000)&lt;/p&gt;

&lt;h4 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h4&gt;

&lt;p&gt;사실 다익스트라 알고리즘은 방문한 점 &lt;code&gt;v&lt;/code&gt; 와 방문하지 않은 점 &lt;code&gt;w&lt;/code&gt; 에 대해  &lt;em&gt;edge&lt;/em&gt; &lt;code&gt;(v -&amp;gt; w)&lt;/code&gt; 를 고르는 문제다. &lt;code&gt;l_vw&lt;/code&gt; 를 &lt;code&gt;v -&amp;gt; w&lt;/code&gt; 의 거리라 하고 &lt;code&gt;A[v]&lt;/code&gt; 를 시작점 부터 &lt;code&gt;v&lt;/code&gt; 까지의 최단거리라 하면 &lt;code&gt;A[v] + l_vw&lt;/code&gt; 를 최소로 하는 &lt;em&gt;edge&lt;/em&gt; 를 고르면 된다.&lt;/p&gt;

&lt;p&gt;알고리즘은 이렇다. 시작점을 &lt;code&gt;s&lt;/code&gt; 라 하면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X = {s} // vertices process so far
A = [s] // computed shortest path distances

// V is not visited vertices set  

while X != V
  // v in X, w not in X
  // select the edge minimizing [A]v + l_vw
  pick (v, w) 
  X + w
  A[w] = A[v] + l_vw
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;correctness&#34;&gt;Correctness&lt;/h4&gt;

&lt;p&gt;다익스트라 알고리즘이 &lt;em&gt;non-negative edge length&lt;/em&gt; 를 가진 &lt;em&gt;directed graph&lt;/em&gt; 에 대해 최단경로를 찾아낸다는 것을 증명하자.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A&lt;/code&gt; 를 다익스트라 알고리즘이 찾아 낸 경로, &lt;code&gt;L&lt;/code&gt; 을 실제 최단거리라 할 때 &lt;code&gt;A[w*] = L[w*]&lt;/code&gt; 임을 보이면 된다.&lt;/p&gt;

&lt;p&gt;귀납법을 이용해 먼저 가설을 세우면&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Inductive hypothesis: all previous iterations correct&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;base case&lt;/em&gt; 인 시작점 &lt;code&gt;s&lt;/code&gt; 에 대해 참임을 보이면 &lt;code&gt;A[s] = L[s] = 0&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;현재 &lt;em&gt;iteration&lt;/em&gt; 에서 찾아낸 &lt;em&gt;edge&lt;/em&gt; 를 &lt;code&gt;v* -&amp;gt; w*&lt;/code&gt; 라 하면, &lt;code&gt;A[w*] = L[v*] + l_v*w*&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;이 때 그래프 안에 있는 모든 &lt;code&gt;s -&amp;gt; w*&lt;/code&gt; 의 경로의 길이가 &lt;code&gt;L[v*] + l_v*w*&lt;/code&gt; 보다 큼을 보이면 된다.&lt;/p&gt;

&lt;p&gt;그래프 내에 있는 &lt;code&gt;s -&amp;gt; w*&lt;/code&gt; 의 모든 경로 &lt;code&gt;p&lt;/code&gt; 는 다음 형태를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;s -&amp;gt; y | -&amp;gt; z -&amp;gt; w*&lt;/code&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;s, y&lt;/code&gt; 는 방문한 점이고 &lt;code&gt;z, w*&lt;/code&gt; 는 방문하지 않은 점이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;s -&amp;gt; y | -&amp;gt; z -&amp;gt; w*&lt;/code&gt; 에 대해 &lt;code&gt;p&lt;/code&gt; 의 길이는 다음 3개를 더한 것이다.&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;l_sy &amp;gt;= A[y] = L[y]&lt;/code&gt; (&lt;em&gt;by induction hypothesis&lt;/em&gt;)&lt;br /&gt;
(2) &lt;code&gt;l_yz&lt;/code&gt;&lt;br /&gt;
(3) &lt;code&gt;l_zw &amp;gt;= 0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;즉, 모든 경로 &lt;code&gt;p&lt;/code&gt; 의 길이 &lt;code&gt;l_sy + l_yz + l_zw*&lt;/code&gt; 는 &lt;code&gt;L[y] + l_yz&lt;/code&gt; 보다 크다.&lt;/p&gt;

&lt;p&gt;그런데, 다익스트라 알고리즘으로 고른 경로 &lt;code&gt;A[v*] + l_v*w*&lt;/code&gt; 는 &lt;code&gt;L[y] + l_yz&lt;/code&gt; 보다 작거나 같다. 왜냐하면 &lt;code&gt;A[v*], L[y], l_v*w*&lt;/code&gt; 는 최단경로인데, &lt;code&gt;l_yz&lt;/code&gt; 는 최단경로일 수도, 아닐수도 있다.&lt;/p&gt;

&lt;p&gt;따라서 우리 알고리즘으로 구한 거리가, 모든 경로 &lt;code&gt;p&lt;/code&gt; 의 &lt;em&gt;lower bound&lt;/em&gt; 보다 작거나 같다.&lt;/p&gt;

&lt;h4 id=&#34;running-time&#34;&gt;Running time&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;naive implementation&lt;/em&gt; 의 성능은 &lt;code&gt;O(mn)&lt;/code&gt; 이다. &lt;code&gt;n - 1&lt;/code&gt; 의 모든 &lt;em&gt;vertex&lt;/em&gt; 를 살펴봐야 하고, 루프 내에서 러프하게 모든 &lt;em&gt;edge&lt;/em&gt; 를 검사한다고 보면 된다.&lt;/p&gt;

&lt;p&gt;다익스트라 알고리즘은 &lt;code&gt;O(n)&lt;/code&gt; 정도까지 개선할 수 있다. 알고리즘의 변경이 아니라, 자료구조를 &lt;em&gt;heap&lt;/em&gt; 으로 변경함으로써! &lt;em&gt;heap&lt;/em&gt; 은 &lt;em&gt;extract-min&lt;/em&gt; 연산에 대해 &lt;code&gt;O(log n)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;힙의 구조나 특성은 뒤에서 알아보기로 하고, 여기선 다익스트라 알고리즘에 어떻게 적용할지를 논의하자.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;heap&lt;/em&gt; 내부 원소들은 방문하지 않은 원소들의 집합 &lt;code&gt;V - X&lt;/code&gt; 라 하자. &lt;code&gt;X&lt;/code&gt; 는 방문한 원소들의 집합.&lt;br /&gt;
(2) &lt;code&gt;V - X&lt;/code&gt; 내의 원소 &lt;code&gt;v&lt;/code&gt; 에 대해서 &lt;code&gt;key[v]&lt;/code&gt; 는 &lt;em&gt;edge&lt;/em&gt; &lt;code&gt;(u, v)&lt;/code&gt; 에 대한 다익스트라 알고리즘의 스코어다. (&lt;code&gt;u&lt;/code&gt; 는 방문한 점)&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;v&lt;/code&gt; 의 키 값은 &lt;code&gt;X&lt;/code&gt; 와 &lt;code&gt;V - X&lt;/code&gt; 의 &lt;em&gt;crossing edge&lt;/em&gt; &lt;code&gt;u -&amp;gt; v&lt;/code&gt; 중에서 가장 작은 &lt;em&gt;edge&lt;/em&gt; 길이다.&lt;/p&gt;

&lt;p&gt;이때 &lt;code&gt;X&lt;/code&gt; 내에 있지 않은 점 &lt;code&gt;v&lt;/code&gt; 를 &lt;code&gt;X&lt;/code&gt; 로 옮기면서 &lt;code&gt;v -&amp;gt; w&lt;/code&gt; 로 새로운 &lt;em&gt;crossing edge&lt;/em&gt; 가 생기고, 이로인해 &lt;code&gt;w&lt;/code&gt; 의 &lt;em&gt;key&lt;/em&gt; 값이 변할 수 있다. 이를 해결하기 위한 &lt;em&gt;key&lt;/em&gt; 업데이트 로직은&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// v is extracted from heap and added to X
for each edge (v, w)
  if w in heap
    delete w from heap
    recompute key[w] = min(key[w], A[v] + l_vw)
    reinsert w into heap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;running time&lt;/em&gt; 은 &lt;em&gt;heap operation&lt;/em&gt; 의 수로 결정되는데 각 연산 &lt;code&gt;O(log n)&lt;/code&gt; 을&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;n - 1&lt;/code&gt; &lt;em&gt;extract min&lt;/em&gt; -&amp;gt; &lt;code&gt;n&lt;/code&gt;&lt;br /&gt;
(2) 그리고 &lt;em&gt;edge&lt;/em&gt; 중심으로 보면, &lt;code&gt;(v, w)&lt;/code&gt; 이 &lt;em&gt;edge&lt;/em&gt; 가 재 계산될때는 &lt;code&gt;v&lt;/code&gt; 가 &lt;code&gt;X&lt;/code&gt; 에 추가될때다. 그 이후에는 &lt;code&gt;(v, w)&lt;/code&gt; 는 &lt;em&gt;crossing edge&lt;/em&gt; 가 되므로 &lt;em&gt;delete, insertion&lt;/em&gt; 연산과 관련이 없어진다. 다시 말해 한 &lt;em&gt;edge&lt;/em&gt; 당 &lt;em&gt;at most one insertion and deletion&lt;/em&gt; 이 있다. -&amp;gt; &lt;code&gt;m&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;heap operation&lt;/em&gt; 수는 &lt;code&gt;O(n + m)&lt;/code&gt; 이다. 그런데, &lt;em&gt;path&lt;/em&gt; 자체는 &lt;em&gt;weakly connected undirected graph&lt;/em&gt; 이므로 &lt;code&gt;m ~= n&lt;/code&gt; 이고 &lt;code&gt;O(m + n) = O(m)&lt;/code&gt; 이라 볼 수 있다.&lt;/p&gt;

&lt;p&gt;결국 힙을 이용한 다익스트라 알고리즘은 &lt;code&gt;O(m log n)&lt;/code&gt; 이다. 이건 &lt;code&gt;O(m * n)&lt;/code&gt; 보다 어마어마하게 빠르다.&lt;/p&gt;

&lt;h3 id=&#34;what-data-structure-should-i-use&#34;&gt;What data structure should I use?&lt;/h3&gt;

&lt;p&gt;위 예제에서도 봤듯이, 적절한 데이터 구조의 사용은 알고리즘의 성능을 개선하는데 도움이 된다.&lt;/p&gt;

&lt;p&gt;익히 아는 리스트, 큐 부터 시작해서 &lt;em&gt;bloom filter&lt;/em&gt;, &lt;em&gt;union find&lt;/em&gt; 등이 있는데, 이렇게 다양한 자료구조가 있는 이유는 우리가 하려는 &lt;em&gt;task&lt;/em&gt; 가 다양하기 때문이다.&lt;/p&gt;

&lt;p&gt;많은 데이터 구조중 무엇을 선택해야 할까? &lt;em&gt;rule of thumb&lt;/em&gt; 는&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Choose the &amp;ldquo;minimal&amp;rdquo; data structure that supports all the operations that need.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;내게 필요한 것 이상의 과도한 연산을 제공하는 자료구조를 사용할 필욘 없다. 복잡한 연산이 있을수록, 자료구조는 더 복잡해지기 마련이다.&lt;/p&gt;

&lt;h3 id=&#34;heap&#34;&gt;Heap&lt;/h3&gt;

&lt;p&gt;자료구조에서 가장 먼저 생각해야 할 것은  &lt;em&gt;&amp;ldquo;어떤 operation 을 제공하는가?&amp;rdquo;&lt;/em&gt;, &lt;em&gt;&amp;ldquo;running time 은 얼마인가?&amp;rdquo;&lt;/em&gt; 다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Heap&lt;/em&gt; 은 &lt;em&gt;key&lt;/em&gt; 를 가진 *object*를 위한 &lt;em&gt;container&lt;/em&gt; 다. &lt;em&gt;employer records&lt;/em&gt;, &lt;em&gt;network edges&lt;/em&gt;, &lt;em&gt;event manager&lt;/em&gt; 등에 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;힙의 기본 연산은 &lt;em&gt;insert&lt;/em&gt; 와 &lt;em&gt;extract-min (or max)&lt;/em&gt; 연산이다. 이 연산의 러닝타임은 &lt;code&gt;O(log n)&lt;/code&gt; 이다. &lt;code&gt;n&lt;/code&gt; 은 힙 내에 있는 오브젝트의 수다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 개의 &lt;em&gt;batch insertion&lt;/em&gt; 에 대해 &lt;em&gt;heapify&lt;/em&gt; 는 &lt;code&gt;O(n)&lt;/code&gt;, 임의의 원소를 제거하는 &lt;em&gt;delete&lt;/em&gt; 는 &lt;code&gt;O(log n)&lt;/code&gt; 이다. 정리하면&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;insertion:&lt;/strong&gt; &lt;code&gt;O(log n)&lt;/code&gt;&lt;br /&gt;
(2) &lt;strong&gt;extract-min (or max):&lt;/strong&gt; &lt;code&gt;O(log n)&lt;/code&gt;&lt;br /&gt;
(3) &lt;strong&gt;heapify (batch):&lt;/strong&gt; &lt;code&gt;O(n)&lt;/code&gt;&lt;br /&gt;
(4) &lt;strong&gt;remove (arbitrary):&lt;/strong&gt; &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;application&#34;&gt;Application&lt;/h4&gt;

&lt;p&gt;힙을 어디에 쓸까? 먼저 생각해 볼 수 있는건 &lt;em&gt;min value&lt;/em&gt; 가 연속적으로 필요한 작업에 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;heap sort&lt;/em&gt; 는 힙에서 지속적으로 &lt;em&gt;min-value&lt;/em&gt; 를 뽑아내서 정렬하는 방법이다. &lt;code&gt;O(n logn)&lt;/code&gt; 의 성능을 보여준다. 이건 &lt;em&gt;merge sort&lt;/em&gt; 나 &lt;em&gt;randomized quick-sort&lt;/em&gt; 만큼 빠르다.&lt;/p&gt;

&lt;p&gt;잠깐 생각해 볼 거리가 있다. &lt;em&gt;quicksort&lt;/em&gt; 챕터에서 언급 했듯이 &lt;em&gt;comparison-based sorting&lt;/em&gt; 은 &lt;code&gt;O(n logn)&lt;/code&gt; 보다 더 빠를 수 없다. 힙 또한 비교를 이용해 정렬을 하므로 이보다 좋은 성능을 내기는 어렵다.&lt;/p&gt;

&lt;p&gt;(2) 아까 힙을 &lt;em&gt;event manager&lt;/em&gt; 에도 이용할 수 있고 했는데, &lt;em&gt;priority queue&lt;/em&gt; 가 바로 그것이다. 각 게임 이벤트가 큐에 들어있다고 하면 여기서 &lt;em&gt;key&lt;/em&gt; 는 각 &lt;em&gt;event&lt;/em&gt; 의 발생시간이다. 다시 말해 발생시간이 먼저인 이벤트가 먼저 발생되도록 큐를 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;(3) &lt;em&gt;median maintanence&lt;/em&gt; 에도 힙을 이용할 수 있다. &lt;code&gt;x1, x2, ..., xn&lt;/code&gt; 의 배열에 대해 &lt;code&gt;i&lt;/code&gt; 번째 스텝에서는 &lt;code&gt;x1, ..., xi&lt;/code&gt; 의 중앙값을 돌려주는 문제다. &lt;code&gt;O(i)&lt;/code&gt; 로 하면 정말 쉽지만, 조건이 하나 있다. 바로 &lt;code&gt;O(log i)&lt;/code&gt; 의 퍼포먼스를 내야하는것. 어떻게 할까?&lt;/p&gt;

&lt;p&gt;두개의 힙을 이용하면 쉽게 풀 수 있다. 데이터를 절반씩 나누어 &lt;em&gt;max heap&lt;/em&gt;, &lt;em&gt;min heap&lt;/em&gt; 각각에 나눠 담으면 된다. 그러면 각 힙의 루트가 중앙값이 될 수 있다.&lt;/p&gt;

&lt;p&gt;(4) 마지막으로 힙은 다익스트라 알고리즘의 성능을 개선하는데 사용할 수 있다. 위에서 보았듯이 &lt;code&gt;O(m logn)&lt;/code&gt; 의 퍼포먼스를 보여준다.&lt;/p&gt;

&lt;h4 id=&#34;implementation-details&#34;&gt;Implementation Details&lt;/h4&gt;

&lt;p&gt;힙을 배열 또는 트리로 보는 관점이 있는데, 여기선 쉬운 이해를 위해 트리로 설명한다. &lt;em&gt;rooted, binary, as complete as possible tree&lt;/em&gt; 로 보면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/6/69/Min-heap.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://en.wikipedia.org/wiki/Binary_heap&#34;&gt;http://en.wikipedia.org/wiki/Binary_heap&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;min heap&lt;/em&gt; 을 예로 들면, 부모는 항상 자식보다 작거나 같다. 따라서 루트는 모든 원소중 가장 작은 값을 가진다.&lt;/p&gt;

&lt;p&gt;힙을 배열로 구현한다고 하자. 인덱스가 1부터 시작할때 &lt;code&gt;parent(i)&lt;/code&gt; 는 &lt;code&gt;i&lt;/code&gt; 가 짝수면 &lt;code&gt;i/2&lt;/code&gt;, 홀수면 &lt;code&gt;[i/2]&lt;/code&gt; 가 될 것이다. 자식을 구하는건 더 쉽다. &lt;code&gt;i * 2&lt;/code&gt; 와 &lt;code&gt;i * 2 + 1&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;insert&lt;/em&gt; 의 구현을 생각해 보자. 힙은 가능한 &lt;em&gt;complete tree&lt;/em&gt; 기 때문에, 위 그림에서 새로운 숫자가 입력했을때 새로 생길 노드의 위치는 &lt;code&gt;19&lt;/code&gt; 의 왼쪽 자식이다.&lt;/p&gt;

&lt;p&gt;이렇게 완전 이진트리를 만드는 위치에 새로운 값을 삽입하고, 부모와 값을 비교해 가면서 값의 위치를 올려간다. 이 방법을 &lt;em&gt;bubble-up&lt;/em&gt; 이라 부른다.
정리하면,&lt;/p&gt;

&lt;p&gt;(1) stick &lt;code&gt;k&lt;/code&gt; at end of last level&lt;br /&gt;
(2) &lt;strong&gt;bubble-up&lt;/strong&gt; &lt;code&gt;k&lt;/code&gt; until heap property is restored&lt;/p&gt;

&lt;p&gt;&lt;em&gt;extract-min&lt;/em&gt; 연산은 루트에 있는 수를 뽑아낸다. 이 위치에 마지막 노드를 넣고, &lt;em&gt;bubble-down&lt;/em&gt; 함으로써 구현할 수 있다. 새롭게 루트가 된 노드를 내려가는 과정에서 왼쪽 자식, 오른쪽 자식과 모두 비교하여 가장 작은 수를 새로운 부모로 만들면 된다. 정리하면&lt;/p&gt;

&lt;p&gt;(1) delete &lt;code&gt;root&lt;/code&gt;&lt;br /&gt;
(2) move last leaf to be new root&lt;br /&gt;
(3) iterlatively &lt;strong&gt;bubble-down&lt;/strong&gt; until heap property has been restored&lt;/p&gt;

&lt;p&gt;이 두 연산은 이진트리의 &lt;code&gt;n&lt;/code&gt; 번째 깊이까지 내려갈 수 있으므로 퍼포먼스는 &lt;code&gt;O(log_2 n)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&#34;balanced-search-tree&#34;&gt;Balanced Search Tree&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;sorted array&lt;/strong&gt; 에 대한 연산을 먼저 생각해 보자. 이로부터 &lt;em&gt;balanced search tree&lt;/em&gt; 로 이끌어 낼 수 있는 연산들이 있을테다. 참고로 &lt;strong&gt;sorted array&lt;/strong&gt; 는 &lt;em&gt;static&lt;/em&gt; 이기 때문에 &lt;em&gt;insertion, deletion&lt;/em&gt; 이 없다.&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Search:&lt;/strong&gt; &lt;code&gt;O(logn)&lt;/code&gt;&lt;br /&gt;
(2) &lt;strong&gt;Select:&lt;/strong&gt; &lt;code&gt;O(1)&lt;/code&gt; (given order statistic &lt;code&gt;i&lt;/code&gt;)&lt;br /&gt;
(3) &lt;strong&gt;Min / Max:&lt;/strong&gt; &lt;code&gt;O(1)&lt;/code&gt;&lt;br /&gt;
(4) &lt;strong&gt;Predecessor / Successor:&lt;/strong&gt; &lt;code&gt;O(1)&lt;/code&gt;&lt;br /&gt;
(5) &lt;strong&gt;Rank:&lt;/strong&gt; &lt;code&gt;O(logn)&lt;/code&gt;&lt;br /&gt;
(6) &lt;strong&gt;Output in sorted order:&lt;/strong&gt; &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;여기서 주어진 데이터가 몇 번째 데이터인지를 찾는 &lt;em&gt;rank&lt;/em&gt; 는 &lt;em&gt;search&lt;/em&gt; 와 똑같은 문제다. &lt;em&gt;binary search&lt;/em&gt; 처럼 찾아가면서, 인덱스를 찾아내면 되기 때문이다.&lt;/p&gt;

&lt;p&gt;이제 &lt;strong&gt;balanced search tree&lt;/strong&gt; 를 생각해보자.&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Search:&lt;/strong&gt; &lt;code&gt;O(logn)&lt;/code&gt;&lt;br /&gt;
(2*) &lt;strong&gt;Select:&lt;/strong&gt; &lt;code&gt;O(logn)&lt;/code&gt;&lt;br /&gt;
(3*) &lt;strong&gt;Min / Max:&lt;/strong&gt; &lt;code&gt;O(logn)&lt;/code&gt;&lt;br /&gt;
(4*) &lt;strong&gt;Predecessor / Successor:&lt;/strong&gt; &lt;code&gt;O(logn)&lt;/code&gt;&lt;br /&gt;
(5) &lt;strong&gt;Rank:&lt;/strong&gt; &lt;code&gt;O(logn)&lt;/code&gt;&lt;br /&gt;
(6) &lt;strong&gt;Output in sorted order:&lt;/strong&gt; &lt;code&gt;O(n)&lt;/code&gt;&lt;br /&gt;
(7+) &lt;strong&gt;Insert:&lt;/strong&gt; &lt;code&gt;O(logn)&lt;/code&gt;&lt;br /&gt;
(8+) &lt;strong&gt;Delete:&lt;/strong&gt; &lt;code&gt;O(logn)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sorted array&lt;/strong&gt; 에 비해 &lt;em&gt;select, min or max, pred or succ&lt;/em&gt; 연산이 &lt;code&gt;O(logn)&lt;/code&gt; 이 되었고 &lt;em&gt;insert, delete&lt;/em&gt; 연산이 새롭게 추가됐다. 쉽게 기억하려면 &lt;em&gt;sorted array&lt;/em&gt; + &lt;em&gt;logarithmic insert, delete&lt;/em&gt; 라 생각하면 된다.&lt;/p&gt;

&lt;p&gt;힙과 비교해보면, 두 자료구조 모두 &lt;em&gt;insert, delete&lt;/em&gt; 를 &lt;code&gt;O(logn)&lt;/code&gt; 이란 빠른 시간에 제공한다. 차이점은, 힙은 &lt;em&gt;min or max&lt;/em&gt; 둘 중 하나만 매우 빠르게 제공한다는 것이다. 따라서 &lt;em&gt;priority queue, scheduler&lt;/em&gt; 같은 기능을 구현한다면 &lt;em&gt;balanced search tree&lt;/em&gt; 보단 힙이 더 좋은 선택이다.&lt;/p&gt;

&lt;h3 id=&#34;binary-search-tree&#34;&gt;Binary Search Tree&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;binary search tree&lt;/strong&gt; 를 쉽게 기억하는 방법은 &lt;em&gt;dynamic sorted array&lt;/em&gt; 라 기억하는 것이다. &lt;strong&gt;sorted array&lt;/strong&gt; 가 제공하는 풍부하고 빠른 연산에 &lt;em&gt;insert, delete&lt;/em&gt; 를 추가한 것이 바로 &lt;strong&gt;binary search tree, BST&lt;/strong&gt; 다.&lt;/p&gt;

&lt;p&gt;힙이 &lt;em&gt;vertically sorted&lt;/em&gt; 라면 BST 는 &lt;em&gt;horizontally sorted&lt;/em&gt; 다. 즉 왼쪽자식은 부모보다 항상 작고, 우측 자식은 부모보다 항상 크다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/300px-Binary_search_tree.svg.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://en.wikipedia.org/&#34;&gt;http://en.wikipedia.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이런 구조적 특성때문에 &lt;em&gt;search (탐색)&lt;/em&gt; 을 &lt;code&gt;O(logn)&lt;/code&gt; 으로 빠른 시간 내에 해낼 수 있다. 근데, 최악의 경우 노드가 일렬로 주-욱 이어져 있다면 &lt;code&gt;O(n)&lt;/code&gt; 의 퍼포먼스를 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://epaperpress.com/sortsearch/images/fig33.gif&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://epaperpress.com&#34;&gt;http://epaperpress.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;이제 연산의 구현을 좀 생각해 보자.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;insert, search&lt;/em&gt; 는 비슷하다. 자신의 자리를 찾아 내려가다가, 해당 원소가 있으면 돌려주고 아니면 &lt;code&gt;NULL&lt;/code&gt; 을 돌려주는 방법으로 &lt;em&gt;search&lt;/em&gt; 를 구현할 수 있다. &lt;em&gt;insert&lt;/em&gt; 도 값을 비교하면서 내려가다가 적절한 자리에 삽입하면 된다.&lt;/p&gt;

&lt;p&gt;(2) &lt;em&gt;max, min&lt;/em&gt; 연산은 가장 좌측 노드, 가장 우측 노드를 돌려줌으로써 쉽게 구할 수 있다.&lt;/p&gt;

&lt;p&gt;(3) &lt;em&gt;pred, succ&lt;/em&gt; 은 자신 다음으로 적거나, 자신 다음으로 큰 원소를 돌려주는 연산인데, 자신 기준으로 왼쪽 부트리에서 가장 우측에 있는 노드, 그리고 자신 기준으로 우측 부트리에서 가장 좌측에 있는 노드를 돌려주면 된다.&lt;/p&gt;

&lt;p&gt;(4) &lt;em&gt;in-order traversal&lt;/em&gt; 연산은 노드를 오름차순 순서로 방문하는 연산이다. 이것 역시 쉽게 구현할 수 있는데&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let r = root of search tree

recurse left sub-tree
print current node
recurse right sub-tree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;노드당 한번만 출력하므로, 퍼포먼스는 &lt;code&gt;O(n)&lt;/code&gt; 이다&lt;/p&gt;

&lt;p&gt;(5) &lt;em&gt;delete&lt;/em&gt; 는 조금 복잡한데 3가지 경우를 고려해야 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;자식이 없을 경우&lt;/li&gt;
&lt;li&gt;왼쪽 또는 오른쪽 자식만 있을 경우&lt;/li&gt;
&lt;li&gt;양쪽 자식이 다 있을 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;앞의 두 가지 경우는 어렵지 않은데, 양쪽 자식이 다 있을 경우는 조금 까다롭다. 이 경우는 지우려는 노드의 &lt;em&gt;successor&lt;/em&gt; 나 &lt;em&gt;predecessor&lt;/em&gt; 을 &lt;code&gt;l&lt;/code&gt; 이라 하자. 지우려는 노드와 &lt;code&gt;l&lt;/code&gt; 을 뒤 바꾸면, 이전 &lt;code&gt;l&lt;/code&gt; 자리에 있던 노드는 &lt;em&gt;left&lt;/em&gt; 또는 &lt;em&gt;right&lt;/em&gt; 자식이 없으므로 하나의 자식만 있는 알고리즘을 이용해 제거하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Binary_search_tree_delete_3.svg/620px-Binary_search_tree_delete_3.svg.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://commons.wikimedia.org/&#34;&gt;http://commons.wikimedia.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;(6) &lt;em&gt;select, rank&lt;/em&gt; 연산은 트리에 추가적인 정보를 기록함으로써 쉽게 구할 수 있다.  각 트리마다 자기를 포함한 자식들의 노드 수를 저장하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.tcs.auckland.ac.nz/~georgy/teaching/1998/98-231FC/231-hand/btr-rank.gif&#34; alt=&#34;http://www.tcs.auckland.ac.nz/~georgy/&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.tcs.auckland.ac.nz/~georgy/&#34;&gt;http://www.tcs.auckland.ac.nz/~georgy/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;매 삭제와 삽입 연산마다 각 트리의 사이즈를 변경해야 하는데 어렵지 않다. 삽입이나 삭제시 마지막 노드 혹은 &lt;em&gt;predecessor, successor&lt;/em&gt; 를 찾아가면서 매번 노드를 방문해야 하므로 이 때 마다 새롭게 값을 변경하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;select, rank&lt;/em&gt; 알고리즘은&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;start at root x
let y = left sub-tree
let z = right sub-tree
let a = size of y

if a = i - 1 return x
if a &amp;gt;= i, recurse y, i&#39;th statistic
if a &amp;lt; i, recurse z, (i - a - 1)&#39;th statistic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;러닝타임은 &lt;code&gt;O(height)&lt;/code&gt; 다.&lt;/p&gt;

&lt;h3 id=&#34;red-black-tree&#34;&gt;Red-Black Tree&lt;/h3&gt;

&lt;p&gt;이진트리는 운이 나쁠경우 &lt;code&gt;O(n)&lt;/code&gt; 의 연산 성능이 나오기 나온다. 따라서 트리의 높이를 최대 &lt;code&gt;O(logn)&lt;/code&gt; 으로 제한해 연산 성능을 개선할 수 있다.&lt;/p&gt;

&lt;p&gt;이렇게 구조적인 제한을 이용해 성능을 개선하는 트리는 &lt;em&gt;red-black tree&lt;/em&gt; 이외에도 &lt;em&gt;AVL tree&lt;/em&gt;, &lt;em&gt;splay tree&lt;/em&gt;, &lt;em&gt;B tree&lt;/em&gt; 등이 있다.&lt;/p&gt;

&lt;h4 id=&#34;invariants&#34;&gt;Invariants&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;red-black tree&lt;/em&gt; 는 다음의 제약 조건을 제외하면 이진트리와 동일하다.&lt;/p&gt;

&lt;p&gt;(1) each node is red or &lt;code&gt;black&lt;/code&gt;&lt;br /&gt;
(2) root is &lt;code&gt;black&lt;/code&gt;&lt;br /&gt;
(3) no 2 &lt;code&gt;reds&lt;/code&gt; in a row  -&amp;gt; &lt;code&gt;red&lt;/code&gt; node has only &lt;code&gt;black&lt;/code&gt; children&lt;br /&gt;
(4) every &lt;code&gt;root - NULL&lt;/code&gt; path  has same number of black nodes&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;(4)&lt;/code&gt; 는 &lt;em&gt;unsuccessful search&lt;/em&gt; 를 생각하면 쉽다. 검색이 제대로 되지 않았을 경우 &lt;code&gt;NULL&lt;/code&gt; 에서 중단하는데, 그때 까지의 모든 블랙 노드의 수가 다른 &lt;em&gt;unsuccessful search&lt;/em&gt; 가 방문한 블랙 노드 수와 동일하다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/750px-Red-black_tree_example.svg.png&#34; alt=&#34;http://en.wikipedia.org&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://en.wikipedia.org&#34;&gt;http://en.wikipedia.org&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;예제를 통해 좀 살펴보자. &lt;code&gt;1 -&amp;gt; 2 -&amp;gt; 3&lt;/code&gt; 의 이진트리가 있을 때, &lt;code&gt;2&lt;/code&gt; 가 레드 노드라 하자. 그러면 규칙 &lt;code&gt;(4)&lt;/code&gt; 를 위반한다. &lt;em&gt;unsuccessful search&lt;/em&gt; 의 경우인 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;4&lt;/code&gt; 를 찾을때 블랙 노드의 개수가 다르다.&lt;/p&gt;

&lt;h4 id=&#34;height-guarantee&#34;&gt;Height Guarantee&lt;/h4&gt;

&lt;p&gt;위에서 언급한 제약조건이 실제로는 트리의 높이를 &lt;code&gt;height &amp;lt;= 2 log_2(n + 1)&lt;/code&gt; 로 보장한다.&lt;/p&gt;

&lt;p&gt;우선 살펴봐야 할 것은, 모든 &lt;code&gt;root-null&lt;/code&gt; 경로가 &lt;code&gt;&amp;gt;= k&lt;/code&gt; 인 노드를 가지고 있다면, 그 트리는 &lt;code&gt;k&lt;/code&gt; 깊이 까지는 완전 이진트리다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If every &lt;code&gt;root-null&lt;/code&gt; path has &lt;code&gt;&amp;gt;= k&lt;/code&gt; nodes, then tree includes (at the top) a perfectly balanced search tree of depth &lt;code&gt;k - 1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 것은 레드블랙트리만이 아니라 모든 이진트리에 적용된다. 이제 전체 노드 &lt;code&gt;n&lt;/code&gt; 과 관계를 살펴 보자.&lt;/p&gt;

&lt;p&gt;이진트리이므로 노드의 수 &lt;code&gt;n &amp;gt;= 2^k - 1&lt;/code&gt; 과 &lt;code&gt;k&lt;/code&gt; 에 대해 &lt;code&gt;k &amp;lt;= log_2 (n+1)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;아까 &lt;code&gt;k&lt;/code&gt; 는 &lt;code&gt;root-null&lt;/code&gt; 경로의 노드의 수 라고 했었다. 그리고 레드블랙트리의 (3), (4) 조건을 다시 생각해보면&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(3) no 2 &lt;code&gt;reds&lt;/code&gt; in a row  -&amp;gt; &lt;code&gt;red&lt;/code&gt; node has only &lt;code&gt;black&lt;/code&gt; children&lt;br /&gt;
(4) every &lt;code&gt;root - NULL&lt;/code&gt; path  has same number of black nodes&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;레드 블랙트리에서 모든 노드가 블랙이면, (4) 에 의해서 &lt;code&gt;root-null&lt;/code&gt; 경로의 블랙 노드가 최대이므로 블랙 노드의 &lt;em&gt;upper bound&lt;/em&gt; 는 &lt;code&gt;&amp;lt;= log_2 (n+1)&lt;/code&gt; 이다. 그리고 레드 블랙 트리에서 &lt;code&gt;root-null&lt;/code&gt; 경로의 노드수가 깊이가 되므로 이때의 높이는 &lt;code&gt;log_2 (n+1)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;다른 경우를 생각해 보자. 레드블랙트리의 &lt;code&gt;root-null&lt;/code&gt; 경로에는 중간 중간 레드 노드가 낄 수 있는데, 레드 노드가 최대로 끼어있을때는 (3) 조건에 의해 블랙노드만큼이다. 이 때 블랙노드는 &lt;em&gt;upper bound&lt;/em&gt; 에 의해 &lt;code&gt;&amp;lt;= log_2 (n+1)&lt;/code&gt; 이므로, 레드노드도 최대 &lt;code&gt;&amp;lt;= log_2 (n+1)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;따라서 레드블랙트리의 깊이는 최대 &lt;code&gt;&amp;lt;= 2 * log_2 (n + )1&lt;/code&gt; 이므로, 연산에 대해 &lt;code&gt;O(log n)&lt;/code&gt; 을 보장한다.&lt;/p&gt;

&lt;h4 id=&#34;rotation&#34;&gt;Rotation&lt;/h4&gt;

&lt;p&gt;이진트리의 삽입, 삭제 연산은 레드블랙트리에서의 제약조건을 망가트릴 수 있다. 따라서 삭제와 삽입 연산에 부가적으로 구조를 유지하기 위한 작업이 필요하다.&lt;/p&gt;

&lt;p&gt;레드블랙트리 뿐만 아니라 &lt;em&gt;AVL tree&lt;/em&gt; 나 다른 &lt;em&gt;balanced search tree&lt;/em&gt; 도 구조를 유지해야 하는데, 여기에 공통적으로 사용하는 연산이 &lt;em&gt;rotation&lt;/em&gt; 이다. 한번 알아보자.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Idea: locally rebalance sub-trees at a node in &lt;code&gt;O(1)&lt;/code&gt; time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;먼저 &lt;em&gt;left roation&lt;/em&gt; 만 생각하자. 다음 그림에서 우측에 있는 트리를 좌측처럼 변경하는 것이다. &lt;code&gt;P&lt;/code&gt; 가 &lt;code&gt;Q&lt;/code&gt; 의 자식이 되도록 하는것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/2/23/Tree_rotation.png&#34; alt=&#34;http://en.wikipedia.org/wiki/Tree_rotation&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://en.wikipedia.org/wiki/Tree_rotation&#34;&gt;http://en.wikipedia.org/wiki/Tree_rotation&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;B&lt;/code&gt; 의 원소는 &lt;code&gt;P&lt;/code&gt; 보단 크고 &lt;code&gt;Q&lt;/code&gt; 보다 작다. 따라서 &lt;code&gt;Q&lt;/code&gt; 와 &lt;code&gt;P&lt;/code&gt; 의 위치를 변경하면 &lt;code&gt;B&lt;/code&gt; 는 &lt;code&gt;P&lt;/code&gt; 의 오른쪽에 와야 한다. 이것이 &lt;em&gt;left rotation&lt;/em&gt; 이다. 경로를 따라 왼쪽으로 한칸씩 밀려갔다고 생각하면 기억하기 쉽다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;right rotation&lt;/em&gt; 은 이것을 정확히 반대로 수행하면 된다. 좌측에 있는 트리에서 &lt;code&gt;P&lt;/code&gt;, &lt;code&gt;Q&lt;/code&gt; 를 경로를 따라 하나씩 우측으로 밀고, &lt;code&gt;B&lt;/code&gt; 는 &lt;code&gt;C&lt;/code&gt; 의 왼쪽으로 이동하면 된다.&lt;/p&gt;

&lt;p&gt;모든 연산은 포인터 변경으로 끝나므로 &lt;code&gt;O(1)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h4 id=&#34;insertion&#34;&gt;Insertion&lt;/h4&gt;

&lt;p&gt;이제 &lt;em&gt;rotation&lt;/em&gt; 을 이용해 &lt;em&gt;red-black tree&lt;/em&gt; 에서 삽입 연산을 구현해 보자. 삽입과 삭제의 기본적인 아이디어는&lt;/p&gt;

&lt;p&gt;(1) 이진트리에서의 &lt;em&gt;insert&lt;/em&gt; / &lt;em&gt;remove&lt;/em&gt; 연산을 수행 한다.&lt;br /&gt;
(2) 레드, 블랙을 다시 색칠한다.&lt;br /&gt;
(3) &lt;em&gt;rotation&lt;/em&gt; 을 수행한다.&lt;/p&gt;

&lt;p&gt;여기 (2) 단계에서 레드블랙트리의 구조가 망가질 수 있다. 새로운 노드를 레드로 만들면, 한 로우 내에 2개의 레드가 있을 수 없다는 규칙을 위반할 수 있고, 블랙으로 칠하면 &lt;code&gt;root-null&lt;/code&gt; 경로의 블랙 노드의 수가 같아야 한다는 제약조건에 위배될 수 있다.&lt;/p&gt;

&lt;p&gt;두 가지 경우중, 레드로 칠하는 경우가 더 가벼운 작업일 것 같으니&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;새로운 노드가 들어오면 먼저 레드로 칠해본다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;부모가 블랙이면 문제가 없다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;부모가 레드면?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;몇 가지 경우를 생각해봐야 한다. 우선 부모 &lt;code&gt;B&lt;/code&gt; 가 레드면, 부모의 부모 &lt;code&gt;C&lt;/code&gt; 는 블랙임이 확실하다. 이 때 만약,&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;C&lt;/code&gt; 가 &lt;code&gt;B&lt;/code&gt; 말고 다른 자식 &lt;code&gt;D&lt;/code&gt; 가 있다면 &lt;code&gt;B, C, D&lt;/code&gt; 의 색을 반전시키면 된다. 그리고 새롭게 색을 반전시켰을 때 &lt;code&gt;C&lt;/code&gt; 의 부모도 레드일 수 있다. 마찬가지로 &lt;em&gt;recoloring&lt;/em&gt; 을 반복하면 된다. 색을 반전시켜도 (3) 또는 (4) 의 규칙을 위반하지 않는다.&lt;/p&gt;

&lt;p&gt;아주 만약에, 루트까지 반복해서 루트가 레드가 되었다면 루트를 블랙으로 다시 칠하면 된다. 루트는 모든것의 부모이므로 블랙이 되어도 &lt;code&gt;root-null&lt;/code&gt; 경로 조건을 위반하지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 연산비용은 &lt;code&gt;O(log n)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://cs.lmu.edu/~ray/images/rbtrecoloring.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://cs.lmu.edu/~ray/notes/redblacktrees/&#34;&gt;http://cs.lmu.edu/~ray/notes/redblacktrees/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;그런데, 반복해서 이 방법을 사용하다가 &lt;code&gt;C&lt;/code&gt; 가 다른 자식 &lt;code&gt;D&lt;/code&gt; 를 가지고 있지 않거나, &lt;code&gt;D&lt;/code&gt; 가 블랙일 수 있다. 그럴땐 다음 경우로 넘어가야 한다.&lt;/p&gt;

&lt;p&gt;(2) &lt;code&gt;C&lt;/code&gt; 가 &lt;code&gt;B&lt;/code&gt; 말고 다른 자식이 없거나 블랙인 자식을 가지면 &lt;code&gt;A&lt;/code&gt; 가 좌측이냐 우측이냐에 따라 &lt;code&gt;right rotation&lt;/code&gt;, &lt;code&gt;left-right rotation&lt;/code&gt; 으로 해결할 수 있다. 마찬가지로 (3) 또는 (4) 를 위반하지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://cs.lmu.edu/~ray/images/rbrestructuring.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://cs.lmu.edu/~ray/notes/redblacktrees/&#34;&gt;http://cs.lmu.edu/~ray/notes/redblacktrees/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이 경우는 몇번의 로테이션으로 해결할 수 있으므로 &lt;code&gt;O(1)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;em&gt;Algorithms: Design and Analysis, Part 1&lt;/em&gt; by &lt;strong&gt;Tim Roughgarden&lt;/strong&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://en.wikipedia.org/wiki/Binary_heap&#34;&gt;Wiki - Binary heap&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://en.wikipedia.org/wiki/Binary_search_tree&#34;&gt;Wiki - Binary search tree&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://epaperpress.com/sortsearch/bin.html&#34;&gt;http://epaperpress.com&lt;/a&gt;&lt;br /&gt;
(5) &lt;a href=&#34;http://commons.wikimedia.org/wiki/File:Binary_search_tree_delete_3.svg&#34;&gt;http://commons.wikimedia.org/&lt;/a&gt;&lt;br /&gt;
(6) &lt;a href=&#34;http://www.tcs.auckland.ac.nz/~georgy/teaching/1998/98-231FC/231-hand/test231.html&#34;&gt;http://www.tcs.auckland.ac.nz/~georgy/&lt;/a&gt;&lt;br /&gt;
(7) &lt;a href=&#34;http://en.wikipedia.org/wiki/Red%E2%80%93black_tree&#34;&gt;Wiki - Red-black tree&lt;/a&gt;&lt;br /&gt;
(8) &lt;a href=&#34;http://upload.wikimedia.org/wikipedia/commons/2/23/Tree_rotation.png&#34;&gt;Wiki - Tree rotation&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design and Analysis: Hash Table, Universal Hashing, Bloom filters</title>
      <link>https://1ambda.github.io/91/algorithm/design-and-analysis-part1-6/</link>
      <pubDate>Sat, 25 Jun 2016 12:54:52 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/design-and-analysis-part1-6/</guid>
      <description>

&lt;h3 id=&#34;hash-table&#34;&gt;Hash Table&lt;/h3&gt;

&lt;p&gt;해시 테이블의 연산은 &lt;em&gt;key&lt;/em&gt; 를 이용해 이런 작업들을 한다.&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;insert:&lt;/strong&gt; add new record&lt;br /&gt;
(2) &lt;strong&gt;delete:&lt;/strong&gt; delete existing record&lt;br /&gt;
(2) &lt;strong&gt;lookup:&lt;/strong&gt; check for a particular record&lt;/p&gt;

&lt;p&gt;가끔 사람들이 &lt;em&gt;dictionary&lt;/em&gt; 라 부르기도 하는데, 해시테이블은 알파벳 순서같은 특정 &lt;em&gt;order&lt;/em&gt; 로 데이터를 저장하진 않는다.&lt;/p&gt;

&lt;p&gt;이 3가지 연산이 거의 &lt;code&gt;O(1)&lt;/code&gt; 라 보면 된다. 물론 이건 해시테이블을 잘 설계 했을때다. 슬프게도, 해시테이블은 &lt;em&gt;잘못&lt;/em&gt; 구현하기 쉽다. 해시테이블이 &lt;code&gt;O(1)&lt;/code&gt; 성능이 나오려면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;properly implemented&lt;/li&gt;
&lt;li&gt;non-pathological data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 &lt;em&gt;non-pathological&lt;/em&gt; 이란 &lt;em&gt;collision&lt;/em&gt; 을 만들지 않는 데이터를 말한다.&lt;/p&gt;

&lt;h4 id=&#34;application&#34;&gt;Application&lt;/h4&gt;

&lt;p&gt;(1) 주어진 &lt;em&gt;object stream&lt;/em&gt; 을 &lt;em&gt;de-duplication&lt;/em&gt; 하기 위해 해시테이블을 쓸 수 있다. 해시테이블에 들어오는 객체를 &lt;em&gt;lookup&lt;/em&gt; 해 보고 없으면 채워 넣고, 있으면 무시한다.&lt;/p&gt;

&lt;p&gt;(2) &lt;em&gt;2-Sum Problem&lt;/em&gt; 에도 해시테이블을 쓸 수 있다. &lt;em&gt;2-Sum&lt;/em&gt; 을 푸는 &lt;code&gt;O(n logn)&lt;/code&gt; 방법은, (&lt;code&gt;x + y = t&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;먼저 정렬 후 &lt;code&gt;A&lt;/code&gt; 의 원소 &lt;code&gt;x&lt;/code&gt; 에 대해 &lt;code&gt;t - x&lt;/code&gt; 를 이진탐색하는 방법이다. 이렇게 하면 &lt;code&gt;O(n logn)&lt;/code&gt; 으로 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;해시테이블을 이용하면 정렬 할 필요도 없고, 이진탐색 대신 &lt;em&gt;lookup&lt;/em&gt; 으로 &lt;code&gt;O(1)&lt;/code&gt; 시간에 원소를 검색할 수 있으므로 더 빨라진다.&lt;/p&gt;

&lt;p&gt;해시 테이블을 만드는데 &lt;code&gt;O(n)&lt;/code&gt;, 탐색에 &lt;code&gt;O(1 * n)&lt;/code&gt; 에서, &lt;code&gt;O(n)&lt;/code&gt; 만에 &lt;em&gt;2-Sum&lt;/em&gt; 을 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;(3) 이외에도&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;symbol tables in compilers&lt;/li&gt;
&lt;li&gt;blocking network traffic&lt;/li&gt;
&lt;li&gt;search algorithm (e.g &lt;strong&gt;game tree exploration&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;hash-table-implementation&#34;&gt;Hash Table Implementation&lt;/h3&gt;

&lt;p&gt;모든 집합을 의미하는 &lt;em&gt;universe &lt;code&gt;u&lt;/code&gt;&lt;/em&gt; 에 대해 a reasonable size* 의 &lt;em&gt;evolving set&lt;/em&gt; &lt;code&gt;s &amp;lt;= u&lt;/code&gt;* 을 유지하면 된다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;배열로 구현할 경우 &lt;em&gt;lookup&lt;/em&gt; 은 &lt;code&gt;O(1)&lt;/code&gt; 이지만 메모리가 &lt;code&gt;O(|u|)&lt;/code&gt; 다.&lt;/li&gt;
&lt;li&gt;리스트로 구현할 경우 &lt;code&gt;O(|s|)&lt;/code&gt; 의 메모리를 차지하지만, &lt;em&gt;lookup&lt;/em&gt; 이 &lt;code&gt;O(|s|)&lt;/code&gt; 다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;더 나은 방법은 없을까?&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;bucket size&lt;/em&gt; 인 &lt;code&gt;n ~ |s|&lt;/code&gt; 인 &lt;code&gt;n&lt;/code&gt; 을 고른다. 이 때 &lt;code&gt;|s|&lt;/code&gt; 는 그렇게 많이 안 변한다고 가정하자.&lt;br /&gt;
(2) 그 후 &lt;em&gt;hash function&lt;/em&gt; &lt;code&gt;h: u -&amp;gt; {0, 1, ..., n-1}&lt;/code&gt; 인 &lt;code&gt;h&lt;/code&gt; 를 고르면 된다.&lt;br /&gt;
(3) 길이 &lt;code&gt;n&lt;/code&gt; 의 배열 &lt;code&gt;A&lt;/code&gt; 에, &lt;code&gt;A[h(x)]&lt;/code&gt; 위치에 &lt;code&gt;x&lt;/code&gt; 를 저장하면 된다.&lt;/p&gt;

&lt;p&gt;이제 충돌 문제를 고민해 보자. 한 방에 &lt;code&gt;23&lt;/code&gt; 명만 있어도, 생일이 같은 2명이 존재할 확률이 &lt;code&gt;50%&lt;/code&gt; 가 넘으므로,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 에 비해 그리 크지 않은 &lt;em&gt;input size&lt;/em&gt; 에 대해서도 충돌이 발생할 확률이 꽤 높다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Collision:&lt;/strong&gt; dinstinct &lt;code&gt;x, y in u&lt;/code&gt; such that &lt;code&gt;h(x) = h(y)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;resolving-collisions&#34;&gt;Resolving Collisions&lt;/h3&gt;

&lt;p&gt;충돌을 해결하기 위한 첫 번째 방법은&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Chaining:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A[h(x)]&lt;/code&gt; 을 리스토로 만들어 충돌이 발생하는 원소를 리스트에 저장한다.&lt;/p&gt;

&lt;p&gt;(2) &lt;strong&gt;Open Addressing:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;충돌이 발생하면 새로운 &lt;em&gt;bucket&lt;/em&gt; 을 찾도록 해 하나의 &lt;em&gt;bucket&lt;/em&gt; 당 하나의 원소만 들어갈 수 있도록 한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;hash function now specifies probe sequence &lt;code&gt;h_1(x), h_2(x), ...&lt;/code&gt; keep trying til find open slot.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;open addressing&lt;/em&gt; 에서는 &lt;em&gt;probing, 탐사&lt;/em&gt; 방식을 통해 비어있는 &lt;em&gt;bucket&lt;/em&gt; 을 찾는다. 몇 가지 방법이 있는데&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;linear probing:&lt;/strong&gt; 순차적으로 탐색한다. 캐쉬 히트는 높으나, 클러스터링에 취약하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;double hashing probing:&lt;/strong&gt; 해쉬 함수 충돌이 발생하면 2차 해쉬 함수를 이용한다. 계산 비용이 비싸고, 캐쉬효율도 낮지만, 클러스터링에 영향을 받지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;quadratic probing:&lt;/strong&gt; 2차 함수를 이용해서 탐색을 위치를 찾는데, 캐싱과 클러스터링에서 두 방식의 중간정도의 성능을 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;clustering&#34;&gt;Clustering&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;key &lt;code&gt;k&lt;/code&gt;&lt;/em&gt; 에 대한 최초의 해쉬 함수 값 &lt;code&gt;h(k)&lt;/code&gt; &lt;em&gt;home position&lt;/em&gt; 이라 부르는데, 같은 &lt;em&gt;home position&lt;/em&gt; 를 갖는 &lt;em&gt;key&lt;/em&gt; 들을 모아 &lt;em&gt;cluster&lt;/em&gt; 라 부른다. &lt;em&gt;cluster&lt;/em&gt; 가 커지면 커질수록, 클러스터의 중간을 &lt;em&gt;home position&lt;/em&gt; 으로 하는 키가 들어올 확률도 높아지고, 인접한 클러스터와 합쳐지는 속도도 빨라진다.&lt;/p&gt;

&lt;p&gt;결국 &lt;em&gt;linear probing&lt;/em&gt; 의 경우 &lt;em&gt;load factor&lt;/em&gt; 가 높아질수록 해쉬 테이블의 성능이 &lt;code&gt;O(n)&lt;/code&gt; 으로 떨어진다.&lt;/p&gt;

&lt;h4 id=&#34;chaining-vs-open-addessing&#34;&gt;Chaining vs Open-addessing&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://sweeper.egloos.com/viewer/925740&#34;&gt;여기&lt;/a&gt;를 인용하면&lt;/p&gt;

&lt;p&gt;&lt;em&gt;chaining&lt;/em&gt; 은 &lt;em&gt;open addressing&lt;/em&gt; 에 비해 다음의 장점을 가진다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;삭제 작업이 간단하다. 삭제 작업이 빈번하다면 &lt;em&gt;open addressing&lt;/em&gt; 보다는 &lt;em&gt;chaining&lt;/em&gt; 이 낫다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;chaining&lt;/strong&gt; 은 클러스터링에 거의 영향을 받지 않아 충돌의 최소화만 고려하면 된다. 반면 &lt;strong&gt;open addressing&lt;/strong&gt; 은 클러스터링까지 피해야 하므로 해쉬함수를 구현하기가 쉽지 않다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;load factor&lt;/em&gt; 가 높아져도 성능 저하가 선형적이다. 아래 그림에서 볼 수 있듯이, &lt;em&gt;open-addressing&lt;/em&gt; 방법처럼 급격히 &lt;em&gt;lookup time&lt;/em&gt; 이 늘지 않는다. 따라서 테이블 확장을 상당히 늦출 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://pds5.egloos.com/pds/200702/14/32/d0014632_11023351.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;데이터의 크기가 &lt;em&gt;5 words and more&lt;/em&gt; 이면, &lt;em&gt;open addressing&lt;/em&gt; 보다 메모리 사용량이 적다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;반면 &lt;em&gt;open addressing&lt;/em&gt; 은&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;어떠한 포인터도 저장할 필요가 없고, 테이블 외부에 추가적인 공간이 필요 없으므로 메모리 효율이 높다.&lt;/p&gt;

&lt;p&gt;특히 &lt;em&gt;linear probing&lt;/em&gt; 에서 뛰어난 &lt;em&gt;locality&lt;/em&gt; 때문에 데이터가 캐쉬라인을 채울 정도로 크지 않다면 좋은 성능을 낼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정리하자면,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;open-addressing 방식은 테이블에 모두 저장될 수 있고 캐쉬 라인에 적합할 수 있을 정도로 데이터의 크기가 작을수록 성능이 더 좋아진다. 메모리 비용을 아끼려면, 이 방법이 적합하다.&lt;/p&gt;

&lt;p&gt;반면 테이블의 높은 load factor가 예상되거나, 데이터가 크거나, 데이터의 길이가 가변일 때 chained 해쉬 테이블은 open-addressing 방식보다 적어도 동등하거나 훨씬 더 뛰어난 성능을 보인다. 삭제가 중요하고, 빈번한 연산이라면 &lt;em&gt;chianing&lt;/em&gt; 이 더 낫다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;what-makes-a-good-hash-function&#34;&gt;What Makes a Good Hash Function?&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;chaining&lt;/em&gt; 을 생각해 보자.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;insert:&lt;/strong&gt; &lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lookup, delete:&lt;/strong&gt; &lt;code&gt;O(list length in the bucket)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이때 하나의 버켓에 들어있는 &lt;em&gt;list length&lt;/em&gt; 는 &lt;code&gt;m/n&lt;/code&gt; 부터 &lt;code&gt;m&lt;/code&gt; 까지 일 수 있기 때문에 (&lt;code&gt;m&lt;/code&gt; 개의 오브젝트에 대해), 해쉬 함수에 따라 성능이 정말 달라진다.&lt;/p&gt;

&lt;p&gt;이로부터 좋은 해쉬함수의 기준을 알 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Should lead to good performance =&amp;gt; &lt;em&gt;&amp;ldquo;spread data out&amp;rdquo;&lt;/em&gt;&lt;br /&gt;
(gold standard: completely random hashing)&lt;/li&gt;
&lt;li&gt;Should be easy to store / very fast to evaluate&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;quick-and-dirty-hash-function&#34;&gt;Quick and Dirty Hash Function&lt;/h3&gt;

&lt;p&gt;좋은 해쉬함수를 설계할 수 있다면 좋겠지만, 시간이 없을때 객체 &lt;code&gt;u&lt;/code&gt; 를 받아 정수 &lt;code&gt;n&lt;/code&gt; 으로 만들어 &lt;em&gt;bucket&lt;/em&gt; 을 찾는 해쉬함수를 이렇게 디자인할 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;u -&amp;gt; n&lt;/code&gt;: &lt;em&gt;hash code&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n -&amp;gt; bucket&lt;/code&gt;: &lt;em&gt;compression function&lt;/em&gt; using &lt;code&gt;mod&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 &lt;code&gt;n&lt;/code&gt; 은 어떻게 고를까?&lt;/p&gt;

&lt;p&gt;(1) 우리가 &lt;em&gt;compression function&lt;/em&gt; 으로 &lt;code&gt;mod&lt;/code&gt; 를 사용하기 때문에 소수여야 한다. 소수가 아니라면, &lt;code&gt;n&lt;/code&gt; 으로 나누어지는 모든 수는 &lt;code&gt;mod n == 0&lt;/code&gt; 이 되어, 같은 &lt;em&gt;bucket&lt;/em&gt; 에 할당될 것이다. 물론 이 수는 너무 커서는 안되고, 객체를 담을 수 있을만한 적당한 숫자여야 한다.&lt;/p&gt;

&lt;p&gt;(2) &lt;em&gt;input data&lt;/em&gt; 의 패턴을 고려해 &lt;code&gt;n&lt;/code&gt; 을 정해야 한다. 예를 들어 &lt;em&gt;memory location&lt;/em&gt; 이 4의 배수일 때, 테이블 사이즈 &lt;code&gt;n&lt;/code&gt; 을 &lt;code&gt;2^j&lt;/code&gt; 로 정해버리면, &lt;code&gt;mod n == 0&lt;/code&gt; 이 되는 경우가 많아 &lt;em&gt;empty bucket&lt;/em&gt; 이 많이 생길 것이다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code&gt;n&lt;/code&gt; 을 &lt;code&gt;2^k, 10^k&lt;/code&gt; 로 정해버리는 경우 &lt;code&gt;mod&lt;/code&gt; 연산이 시프팅으로 쉽게 구현되는데 이는 나머지 데이터를 고려하지 않고 일부의 데이터만으로 버킷을 찾아가므로 별로 좋은 선택이 아니다.&lt;/p&gt;

&lt;h3 id=&#34;load-factor&#34;&gt;Load Factor&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;evenly spread out&lt;/em&gt; 에 대해 고민해 보았으니, 이제 &lt;em&gt;non-pathological&lt;/em&gt; 을 생각해 보자.&lt;/p&gt;

&lt;p&gt;용어부터 정의하고 가면 &lt;em&gt;load factor&lt;/em&gt; 는 해시테이블에 들어있는 오브젝트 수를, 버킷 수로 나눈 것이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;open addressing&lt;/em&gt; 의 경우에는 &lt;em&gt;load factor&lt;/em&gt; 가 1보다 클 수 없지만 &lt;em&gt;chaining&lt;/em&gt; 은 가능하다.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;load factor&lt;/em&gt; &lt;code&gt;a = O(1)&lt;/code&gt; 이어야 연산이 &lt;em&gt;constant time&lt;/em&gt; 이다.&lt;br /&gt;
(2) &lt;em&gt;open addressing&lt;/em&gt; 이라면 &lt;code&gt;x &amp;lt;&amp;lt; 1&lt;/code&gt; 이어야 한다.&lt;/p&gt;

&lt;p&gt;따라서 해시 테이블의 성능을 위해서는 &lt;em&gt;load factor&lt;/em&gt; 를 조절해야 한다.&lt;/p&gt;

&lt;h3 id=&#34;pathological-data-sets&#34;&gt;Pathological Data Sets&lt;/h3&gt;

&lt;p&gt;모든 데이터에 대해 &lt;em&gt;evenly spread out&lt;/em&gt; 할 수 있는 해시함수가 있다면 좋겠지만, &lt;strong&gt;그런 해시 함수는 없다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;모든 해시 함수는 자신만의 &lt;em&gt;pathological data set&lt;/em&gt; 이 있다. 이는 쉽게 보일 수 있는데, &lt;em&gt;universe &lt;code&gt;u&lt;/code&gt;&lt;/em&gt; 와 대해 버켓 수 &lt;code&gt;n&lt;/code&gt; 에 대해 해시함수 &lt;code&gt;h: u -&amp;gt; {0, 1, ..., n-1}&lt;/code&gt; 이 있다고 하자.&lt;/p&gt;

&lt;p&gt;비둘기 집 원리에 의해 모든 &lt;em&gt;bucket&lt;/em&gt; 은 적어도 &lt;code&gt;|u|/n&lt;/code&gt; 개의 데이터를 담고 있다. 따라서 &lt;code&gt;u&lt;/code&gt; 중에서 어느 한 &lt;em&gt;bucket&lt;/em&gt; 에만 담을 수 있는 데이터 셋을 고르면, 그것이 바로 &lt;em&gt;pathological data set&lt;/em&gt; 이다.&lt;/p&gt;

&lt;p&gt;이런 &lt;em&gt;pathological data set&lt;/em&gt; 은 &lt;em&gt;service attack&lt;/em&gt; 에 쓰이기도 한다. 따라서 오픈소스라면 리버스엔지니어링 하기 쉽지 않게끔 해시함수를 설계하는 것도 필요하다.&lt;/p&gt;

&lt;p&gt;그럼 모든 해시 함수가 이런 데이터 셋을 가지고 있고, 심지어 공격에도 이용할 수 있다면 어떻게 해시함수를 설계해야 이런 문제를 조금이나마 피할 수 있을까?&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;use a cryptographic hash function&lt;/strong&gt; (e.g., &lt;strong&gt;SHA-2&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;infeasible to reverse engineer a pathological data set&lt;/p&gt;

&lt;p&gt;(2) &lt;strong&gt;use randomization&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;design a family &lt;code&gt;H&lt;/code&gt; of hash funcitons such that data sets &lt;code&gt;S&lt;/code&gt;, &amp;ldquo;almost all&amp;rdquo; functions &lt;code&gt;h in H&lt;/code&gt; spread &lt;code&gt;S&lt;/code&gt; out &amp;ldquo;pretty evenly&amp;rdquo; (compare to quicksort guarantee)&lt;/p&gt;

&lt;p&gt;이제 &lt;em&gt;universal hashing&lt;/em&gt; 이 무엇인지 알아보자&lt;/p&gt;

&lt;h3 id=&#34;universal-hashing-functions&#34;&gt;Universal Hashing Functions&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Let &lt;code&gt;H&lt;/code&gt; be a set of hash functions from &lt;code&gt;u&lt;/code&gt; to &lt;code&gt;{0, 1, ..., n-1}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;H&lt;/code&gt; is &lt;strong&gt;universal&lt;/strong&gt; if and only if,&lt;/p&gt;

&lt;p&gt;for all &lt;code&gt;x, y in u (x != y)&lt;/code&gt; &lt;code&gt;P[h(x) = h(y)] &amp;lt;= 1/n&lt;/code&gt; when &lt;code&gt;h&lt;/code&gt; is chosen unifomly at random from &lt;code&gt;H&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the number of buckets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;hashing-ip-addresses&#34;&gt;Hashing IP Addresses&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;IP Address&lt;/em&gt; 를 예로 들어 설명해보면 &lt;em&gt;IP&lt;/em&gt; 를 &lt;code&gt;(x1, x2, x3, x4)&lt;/code&gt; (&lt;code&gt;xi = 0 to 255&lt;/code&gt;), &lt;em&gt;bucket&lt;/em&gt; 수 &lt;code&gt;n&lt;/code&gt; 을 소수라 하자.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;tuple &lt;code&gt;a = (a1, a2, a3, a4), where ai in {0, ..., n-1}&lt;/code&gt;&lt;/em&gt; 에 대해서&lt;/p&gt;

&lt;p&gt;&lt;code&gt;h_a&lt;/code&gt; 를 이렇게 정의하자. 이러면 &lt;code&gt;h_a&lt;/code&gt; 는 &lt;code&gt;n^4&lt;/code&gt; 개 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;h_a(x1, x2, x3, x4) = (a1x2 + a2x2 + a3x3 + a4x4) mod n&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;h_a&lt;/code&gt; 의 집합 &lt;code&gt;H&lt;/code&gt; 는 &lt;em&gt;universal&lt;/em&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;H = { h_a | a1, a2, a3, a4 in {0, 1, ..., n-1} }&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;proof&#34;&gt;Proof&lt;/h4&gt;

&lt;p&gt;서로 다른 &lt;em&gt;IP&lt;/em&gt; &lt;code&gt;(x1, x2, x3, x4), (y1, y2, y3, y4)&lt;/code&gt; 를 생각해보자.&lt;/p&gt;

&lt;p&gt;만약 &lt;code&gt;x4 != y4&lt;/code&gt; 라면, 충돌이 일어날 확률은 얼마일까? 충돌에 대한 식을 좀 정리하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?collision%5C%20means%20%5C%5C%20%5C%5C%20%28a_1x_1%20&amp;amp;plus;%20a_2x_2%20&amp;amp;plus;%20a_3x_3%20&amp;amp;plus;%20a_4x_4%29%20%5Cmod%20n%20%3D%20%28a_1y_1%20&amp;amp;plus;%20a_2y_2%20&amp;amp;plus;%20a_3y_3%20&amp;amp;plus;%20a_4y_4%29%20%5Cmod%20n%20%5C%5C%20%5C%5C%20so%2C%20%5C%5C%20%5C%5C%20a_4%28x_4-y_4%29%20%5Cmod%20n%20%3D%20%5Csum_%7Bi%20%3D%201%7D%5E3%20a_i%28y_i%20-%20x_i%29%20%5Cmod%20n&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 때 &lt;code&gt;a1, a2, a3&lt;/code&gt; 를 고정하면 얼마나 많은 &lt;code&gt;a4&lt;/code&gt; 에 대해 아래 식이 성립할까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?a_4%28x_4-y_4%29%20%5Cmod%20n%20%3D%20%5Csum_%7Bi%20%3D%201%7D%5E3%20a_i%28y_i%20-%20x_i%29%20%5Cmod%20n&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xi, yi, a1, a2, a3&lt;/code&gt; 가 &lt;em&gt;fixed&lt;/em&gt; 기 때문에 우변은 &lt;code&gt;{0, ..., n-1}&lt;/code&gt; 사이의 숫자고 &lt;code&gt;a4&lt;/code&gt; 만 랜덤이다.&lt;/p&gt;

&lt;p&gt;이 때&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x4 != y4&lt;/code&gt; 이므로 &lt;code&gt;x4 - y4 != 0&lt;/code&gt; 이다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 이 &lt;code&gt;ai&lt;/code&gt; 의 최대값보다 큰수이면서 동시에 소수인데다가&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a4&lt;/code&gt; 가 &lt;em&gt;uniform at random&lt;/em&gt; 이기 때문에&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;left-hand side equally likely to be any of &lt;code&gt;{0, 1, ..., n-1}&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 좌변이 특정 숫자인 우변과 같을 확률은 &lt;code&gt;1/n&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?P%5Bh_a%28x%29%20%3D%20h_a%28y%29%5D%20%3D%20%7B1%20%5Cover%20n%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;analysis-of-chaining&#34;&gt;Analysis of Chaining&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;universal hash functions&lt;/em&gt; 의 정의를 한번 더 보고 넘어가면,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;H&lt;/code&gt; 가 해시함수 &lt;code&gt;u -&amp;gt; {0, ..., n-1}&lt;/code&gt; 의 집합일때 &lt;code&gt;H&lt;/code&gt; 가 다음을 만족하면 &lt;em&gt;universal&lt;/em&gt; 하다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x != y&lt;/code&gt; 인 &lt;code&gt;u&lt;/code&gt; 내의 &lt;code&gt;x, y&lt;/code&gt; 에 대해 충돌이 일어날 확률 &lt;code&gt;P &amp;lt;= 1/n&lt;/code&gt; 이고&lt;/li&gt;
&lt;li&gt;&lt;code&gt;H&lt;/code&gt; 내에서 &lt;code&gt;h&lt;/code&gt; 가 &lt;em&gt;uniformly at random&lt;/em&gt; 하게 선택될때&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만약 해시 테이블이 &lt;em&gt;chaining&lt;/em&gt; 을 이용해 구현되었을때, &lt;em&gt;universal family&lt;/em&gt; &lt;code&gt;H&lt;/code&gt; 로부터 해시함수 &lt;code&gt;h&lt;/code&gt; 가 &lt;em&gt;uniformly a random&lt;/em&gt; 하게 선택되면 모든 연산이 &lt;code&gt;O(1)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;그리고, &lt;code&gt;|S| = O(n)&lt;/code&gt; 다시 말해 &lt;em&gt;load factor&lt;/em&gt; &lt;code&gt;alpha = |S| / n = O(1)&lt;/code&gt; 임을, 해시 함수를 평가하는데 &lt;code&gt;O(1)&lt;/code&gt; 임을 가정한다.&lt;/p&gt;

&lt;h4 id=&#34;proof-1&#34;&gt;Proof&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;unsuccessful lookup&lt;/em&gt; 을 분석할건데, 다른 연산이 이보다는 항상 더 빠르므로 다른 연산의 &lt;em&gt;upper bound&lt;/em&gt; 라 보면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;S&lt;/code&gt; 를 &lt;code&gt;|S| = O(n)&lt;/code&gt; 인 데이터셋이라 하자. &lt;code&gt;x not in S&lt;/code&gt; 인 &lt;code&gt;x&lt;/code&gt; 를 &lt;em&gt;lookup&lt;/em&gt; 한다 하면 &lt;em&gt;running time&lt;/em&gt; 은&lt;/p&gt;

&lt;p&gt;&lt;code&gt;O(1) + O(list length in A[h(x)])&lt;/code&gt; 다. 즉 &lt;code&gt;h(x)&lt;/code&gt; 를 평가하는데 걸리는 시간과 해당 버킷 내의 리스트를 순회하는 시간의 합이다.&lt;/p&gt;

&lt;p&gt;그런데 여기서 &lt;code&gt;A[h(x)]&lt;/code&gt; 버킷의 리스트 길이를 &lt;code&gt;L&lt;/code&gt; 이라 하면 이 &lt;code&gt;L&lt;/code&gt; 은 &lt;code&gt;h&lt;/code&gt; 선택에 따라 달라지는 &lt;em&gt;random variable, 확률변수&lt;/em&gt; 다.&lt;/p&gt;

&lt;p&gt;그럼 &lt;em&gt;average list length&lt;/em&gt; 를 구해, &lt;code&gt;O(L)&lt;/code&gt; 을 구해보자. 기대값의 선형성을 이용할건데, &lt;code&gt;E(L)&lt;/code&gt; 을 위한 &lt;code&gt;1 or 0&lt;/code&gt; 의 확률변수를 도입하자.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;x != y&lt;/code&gt; 인 &lt;code&gt;y in S&lt;/code&gt; 에 대해 &lt;code&gt;z_y&lt;/code&gt; 를 충돌이 날경우 &lt;code&gt;1&lt;/code&gt; 로, 아닐 경우를 &lt;code&gt;0&lt;/code&gt; 으로 하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?z_y%3D%20%5Cbegin%7Bcases%7D%201%2C%20%26%20%5Cmbox%7Bif%20%7Dh%28x%29%20%3D%20h%28y%29%20%5C%5C%200%2C%20%26%20%5Cmbox%7Bif%20%7Dh%28x%29%20%5Cneq%20h%28y%29%20%5Cend%7Bcases%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 때 해시함수가 무엇이든, 충돌이 날 경우에만 같은 버킷으로 들어가므로 버킷의 길이는&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?L%20%3D%20%5Csum_%7By%5C%20%5Cin%5C%20S%7D%20z_y&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;따라서&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?E%28L%29%20%5C%5C%20%5C%5C%20%3D%20E%5B%5Csum_%7By%5C%20%5Cin%5C%20S%7D%20z_y%5D%20%5C%5C%20%5C%5C%20%3D%20%5Csum_%7By%5C%20%5Cin%5C%20S%7D%20E%28z_y%29%20%5C%20%5C%20%5Cmbox%7B%28apply%20linearity%20of%20expectation%29%7D%20%5C%5C%20%5C%5C%20%3D%20%5Csum_%7By%5C%20%5Cin%20%5C%20S%7D%20%7B1%20%5Cover%20n%7D%20%5C%5C%20%5C%5C%20%5Cleq%20%7CS%7C%20*%20%7B1%20%5Cover%20n%7D%20%5C%5C%20%5C%5C%20%3D%20O%281%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;중간에 &lt;code&gt;H&lt;/code&gt; 가 &lt;em&gt;universal&lt;/em&gt; 이므로 &lt;code&gt;P[h(y) = h(x)] &amp;lt;= 1/n&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&#34;open-addressing-performance&#34;&gt;Open Addressing Performance&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;open addressing&lt;/em&gt; 퍼포먼스를 계산할건데, &lt;em&gt;quick and dirty idealized analysis&lt;/em&gt; 를 위해 &lt;em&gt;heuristic assumtion&lt;/em&gt; 을 도입하면,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;All &lt;code&gt;n!&lt;/code&gt; probe sequences equally likely&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이상적인 경우를 가정하면 얻어지는 것은&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;expected insertion time ~= &lt;code&gt;1 / (1 - a)&lt;/code&gt; where &lt;code&gt;a = load factor&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다시 말해서, &lt;code&gt;a = 0.5&lt;/code&gt; 라면 새로운 데이터를 집어넣기 위해 &lt;code&gt;2&lt;/code&gt; 만큼 &lt;em&gt;probe&lt;/em&gt; 해야한다는 소리다. 반면 &lt;code&gt;a ~= 1&lt;/code&gt; 이면 (&lt;code&gt;1&lt;/code&gt;에 가까워지면) &lt;em&gt;insertion&lt;/em&gt; 타임은 어마어마하게 커진다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A random probe finds an empty slot with probability &lt;code&gt;1 - a&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 문제를 &amp;ldquo;&lt;em&gt;head&lt;/em&gt; 를 얻기 위해 동전을 몇번 뒤집어야 하는가&amp;rdquo; 로 치환할 수 있다. 여기서 &lt;code&gt;Pr[heads] = 1 - a&lt;/code&gt; 라 보면&lt;/p&gt;

&lt;p&gt;&lt;em&gt;head&lt;/em&gt; 를 얻기 위해 동전을 뒤집는 수 &lt;code&gt;N&lt;/code&gt; 에 대해 기대값 &lt;code&gt;E[N]&lt;/code&gt; 은&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?E%5BN%5D%20%3D%201%20&amp;amp;plus;%20%5Calpha%20%5C%20E%5BN%5D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;식을 풀면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?E%5BN%5D%20%3D%20%7B1%20%5Cover%201-%20%5Calpha%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;linear-probing&#34;&gt;Linear Probing&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;open addressing&lt;/em&gt; 방법으로 &lt;em&gt;linear probing&lt;/em&gt; 을 사용할 경우, 아까의 &lt;em&gt;heuristic assumption&lt;/em&gt; 자체가 성립하지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 다른 가정으로&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;initial probe uniformly random, independent for different keys.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그러면 가정아래,  &lt;em&gt;expected insertion time&lt;/em&gt; 은 &lt;code&gt;1 / (1 - a)^2&lt;/code&gt; 에 가까워진다. (&lt;em&gt;D.E Knuth&lt;/em&gt; 가 발견했다고 한다.)&lt;/p&gt;

&lt;h3 id=&#34;bloom-filter&#34;&gt;Bloom Filter&lt;/h3&gt;

&lt;p&gt;하던대로 &lt;em&gt;supported operation&lt;/em&gt; 부터 이야기 하자.&lt;/p&gt;

&lt;p&gt;블룸 필터는 해시테이블과 비슷하게 빠른 삽입, 탐색을 지원한다. 해시테이블과 비교했을때 메모리가 덜 든다. 반면 단점은&lt;/p&gt;

&lt;p&gt;(1) Can&amp;rsquo;t store an associated object&lt;br /&gt;
(2) No deletions&lt;br /&gt;
(3) small &lt;strong&gt;false positive&lt;/strong&gt; pobability (but no false negative)&lt;/p&gt;

&lt;p&gt;블룸 필터는 다양한 곳에 사용한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;early spell checkers (original)&lt;/li&gt;
&lt;li&gt;list of forbidden passwords (canonical)&lt;/li&gt;
&lt;li&gt;network routers (mordern)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만약 메모리가 아주 비싸고, &lt;em&gt;false positive&lt;/em&gt; 를 참을만 하다면 블룸필터는 좋은 선택이다. 연산도 아주 빠르다.&lt;/p&gt;

&lt;p&gt;블룸 필터의 구성요소를 보자.&lt;/p&gt;

&lt;p&gt;(1) 자료구조는 &lt;code&gt;n&lt;/code&gt; 비트의 배열이다.&lt;br /&gt;
(2) &lt;code&gt;k&lt;/code&gt; 개의 해시 함수가 필요하다. (&lt;code&gt;k&lt;/code&gt; 는 &lt;em&gt;small constant&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;insertion&lt;/em&gt; 은 &lt;code&gt;i = 1, ..., k&lt;/code&gt; 에 대해 &lt;code&gt;A[h_i(x)] = 1&lt;/code&gt; 로 세팅하면 된다. 이미 &lt;code&gt;1&lt;/code&gt; 이어도 덮어쓴다. 참고로 덮어쓰기때문에 &lt;em&gt;false positive&lt;/em&gt; 는 있어도 &lt;em&gt;false negative&lt;/em&gt; 는 없다. 자그마한 종양만 보여도 무조건 암이라 주장하는 소심한 의사라 보면 이해가 쉽다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;lookup&lt;/em&gt; 은 &lt;code&gt;i = 1, ..., k&lt;/code&gt; 에 대해 모든 &lt;code&gt;A[h_i(x)] = 1&lt;/code&gt; 이면 찾으려는 &lt;code&gt;x&lt;/code&gt; 가 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;false positive&lt;/em&gt; 는 &lt;code&gt;A[h_i(x)]&lt;/code&gt; 가 다른 &lt;em&gt;insertion&lt;/em&gt; 에 의해 &lt;code&gt;1&lt;/code&gt; 로 세팅 되었을때 발생한다.&lt;/p&gt;

&lt;p&gt;블룸필터를 이미지로 보면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/a/ac/Bloom_filter.svg/720px-Bloom_filter.svg.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://en.wikipedia.org&#34;&gt;http://en.wikipedia.org&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;블룸필터를 쓰는 것이 합리적인 선택이 되려면&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;n / |S|&lt;/code&gt; 즉, 오브젝트당 비트 수가 충분히 작아야 한다.&lt;br /&gt;
(2) &lt;em&gt;false positive&lt;/em&gt;, 즉 에러 확률이 작아야한다.&lt;/p&gt;

&lt;p&gt;동시에 두 조건을 작은 값으로, 모두 만족시키지 못한다면 그냥 해시 테이블을 쓰는 것이 더 낫다.&lt;/p&gt;

&lt;p&gt;근데, 자세히 살펴보면 &lt;em&gt;space&lt;/em&gt; 와 &lt;em&gt;error prob&lt;/em&gt;, 이 두 조건은 &lt;em&gt;trade-off&lt;/em&gt; 다.&lt;/p&gt;

&lt;h3 id=&#34;bloom-filter-heuristic-analysis&#34;&gt;Bloom Filter: Heuristic Analysis&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;heuristic assumption&lt;/em&gt; 은&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;all &lt;code&gt;h_i(x)&lt;/code&gt;&amp;rsquo; is uniformly random and independent (across different &lt;code&gt;i&lt;/code&gt;&amp;rsquo;s and &lt;code&gt;x&lt;/code&gt;&amp;rsquo;s&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;k&lt;/code&gt; 개의 해시함수를 가지는 &lt;code&gt;n&lt;/code&gt; 비트 블룸 필터에 데이터셋 &lt;code&gt;S&lt;/code&gt; 를 먼저 넣어놓자. 이제 블룸필터 &lt;code&gt;A&lt;/code&gt; 의 각 비트가 1일 확률은,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?1%20-%20%281%20-%7B1%20%5Cover%20n%7D%29%5E%7Bk%7CS%7C%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;인데 이것은 한 비트가 &lt;code&gt;0&lt;/code&gt; 일 확률을 &lt;code&gt;1&lt;/code&gt; 에서 뺀 것이다. &lt;code&gt;0&lt;/code&gt; 일 확률은 &lt;code&gt;k&lt;/code&gt; 개의 해쉬 함수를 &lt;code&gt;|S|&lt;/code&gt; 개의 모든 원소를 다 집어 넣은 후에도 &lt;code&gt;0&lt;/code&gt; 인 확률이므로&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%281%20-%20%7B1%20%5Cover%20n%7D%29%5E%7Bk%7CS%7C%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 때 &lt;code&gt;e^x&lt;/code&gt; 가 &lt;code&gt;1 + x&lt;/code&gt; 의 &lt;em&gt;upper bound&lt;/em&gt; 임을 이용하면, 각 비트가 1일 확률은&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?1%20-%20%281%20-%7B1%20%5Cover%20n%7D%29%5E%7Bk%7CS%7C%7D%20%5C%5C%20%5C%5C%20%5Cleq%201%20-%20e%5E%7B-k%7CS%7C%20%5Cover%20n%7D%20%5C%20%5Cmbox%7B%5C%20%5C%20%281/n%20%5Csim%200%29%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 때 &lt;code&gt;n / |S| = b&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; 는 오브젝트당 비트 수 이므로&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?1%20-%20%281%20-%7B1%20%5Cover%20n%7D%29%5E%7Bk%7CS%7C%7D%20%5C%5C%20%5C%5C%20%5Cleq%201%20-%20e%5E%7B-k%7CS%7C%20%5Cover%20n%7D%20%5C%5C%20%5C%5C%20%3D%201%20-%20e%5E%7B-k%20/%20b%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이제 블룸필터에 한번도 입력되지 않은 데이터에 대해 &lt;em&gt;false positive&lt;/em&gt; 확률 &lt;code&gt;P[FP]&lt;/code&gt; 를 계산하면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?P%5BFP%5D%20%5C%5C%20%5C%5C%20%5Cleq%20%281%20-%20e%5E%7B-k%20/%20b%7D%29%5Ek%20%5C%5C%20%5C%5C&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 때 고정된 수 &lt;code&gt;b&lt;/code&gt; 에 대해 에러일 확률 &lt;code&gt;P[FP]&lt;/code&gt; 를 최소화 하는 &lt;code&gt;k&lt;/code&gt; 를 찾으면&lt;/p&gt;

&lt;p&gt;&lt;code&gt;k ~ (ln2) * b&lt;/code&gt; 다. 로그를 계산하면, &lt;code&gt;k ~ 0.693 * b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;따라서&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?P%5BFP%5D%20%5Csim%20%28%7B1%20%5Cover%202%7D%29%5E%7B%28ln2%29b%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이므로 오브젝트당 비트수 &lt;code&gt;b&lt;/code&gt; 에 따라서 &lt;em&gt;false positive&lt;/em&gt;, 즉 에러 확률이 &lt;em&gt;exponentially&lt;/em&gt; 작아진다.&lt;/p&gt;

&lt;p&gt;식을 거꾸로 풀면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?b%20%5Csim%201.44%20*%20log_2%7B1%20%5Cover%20P%5BFP%5D%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 두 식은 오브젝트당 비트수 &lt;code&gt;b&lt;/code&gt; 와 &lt;em&gt;false positive&lt;/em&gt; 의 &lt;em&gt;trade off&lt;/em&gt; 를 보여준다.&lt;/p&gt;

&lt;p&gt;만약 &lt;code&gt;b = 8&lt;/code&gt; 이고 &lt;code&gt;k = 5, 6&lt;/code&gt; 이면 에러 확률은 &lt;code&gt;2%&lt;/code&gt; 정도다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;em&gt;Algorithms: Design and Analysis, Part 1&lt;/em&gt; by &lt;strong&gt;Tim Roughgarden&lt;/strong&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://sweeper.egloos.com/viewer/925740&#34;&gt;Hash Table&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://www.slideshare.net/tanmaytan21/application-of-hashing-in-better-alg-design-tanmay&#34;&gt;http://www.slideshare.net/tanmaytan21&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://en.wikipedia.org/wiki/Hash_table&#34;&gt;Wikipedia: Hash Table&lt;/a&gt;&lt;br /&gt;
(5) &lt;a href=&#34;http://www.slideshare.net/sajidmarwatt/advance-algorithm-hashing-lec-ii&#34;&gt;http://www.slideshare.net/sajidmarwatt&lt;/a&gt;&lt;br /&gt;
(6) &lt;a href=&#34;http://en.wikipedia.org/wiki/Primary_clustering&#34;&gt;Wikipedia: Primary Clustering&lt;/a&gt;&lt;br /&gt;
(7) &lt;a href=&#34;http://en.wikipedia.org/wiki/Bloom_filter&#34;&gt;Wikipedia: Bloom Filter&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Algorithm: Union Find</title>
      <link>https://1ambda.github.io/91/algorithm/algorithm-part1-1/</link>
      <pubDate>Sat, 25 Jun 2016 13:01:04 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/algorithm-part1-1/</guid>
      <description>

&lt;h3 id=&#34;union-find&#34;&gt;Union Find&lt;/h3&gt;

&lt;h4 id=&#34;dynamic-connectivity&#34;&gt;Dynamic Connectivity&lt;/h4&gt;

&lt;p&gt;N 개의 오브젝트가 있을때,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Union command:&lt;/strong&gt; connect two objects&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Find/connected query:&lt;/strong&gt; is there a path connecting the two objects?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 두 경로가 연결되어있는지 아닌지를 판별하는 알고리즘은 다양하게 활용될 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pixels in adigital photo&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Computers in a network&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Friends in a social network&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Transistors in a computer chip&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;modeling&#34;&gt;Modeling&lt;/h4&gt;

&lt;p&gt;connection 에서 몇개의 성질들을 뽑아낼 수 있는데,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Reflexive:&lt;/strong&gt; &lt;em&gt;p&lt;/em&gt; is connected to &lt;em&gt;p&lt;/em&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Symetric:&lt;/strong&gt; if &lt;em&gt;p&lt;/em&gt; is connected to &lt;em&gt;q&lt;/em&gt;, then &lt;em&gt;q&lt;/em&gt; is connected to &lt;em&gt;p&lt;/em&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transitive:&lt;/strong&gt; if &lt;em&gt;p&lt;/em&gt; is connected to &lt;em&gt;q&lt;/em&gt; and &lt;em&gt;q&lt;/em&gt; is connected to &lt;em&gt;r&lt;/em&gt;, then &lt;em&gt;p&lt;/em&gt; is also connected to &lt;em&gt;r&lt;/em&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Connected Components:&lt;/strong&gt; mamximum set of objects that are mutually connected&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 연산들을 정의해 보면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Find query:&lt;/strong&gt; Check if two objects are in the same component&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Union command:&lt;/strong&gt; Replace components containing two objects with their union&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;연산을 구현할때는 아래의 3가지 요소를 고려해야한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Number of objects N can be huge&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Number of operations M can be huse&lt;/li&gt;
&lt;li&gt;Find queries and union command may be intermixed&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;;; initialize union-find data structure with N objects (0 to N-1)
class UF(int N) 

;; add connection between p and q
void union(int p, int q)

;; are p and q in the same component?
boolean connected(int p, int q)

;; component identifier for p (0 to N-1)
int find(int p)

;; number of components
int count()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;quick-find&#34;&gt;Quick-find&lt;/h3&gt;

&lt;p&gt;Dynamic Connectivity 를 푸는 한 방법으로 &lt;strong&gt;eager approache&lt;/strong&gt; 를 사용하는 &lt;strong&gt;Quick-find&lt;/strong&gt; 가 있다.&lt;/p&gt;

&lt;p&gt;데이터 구조는 배열을 사용하며 &lt;code&gt;int id[]&lt;/code&gt;, 만약 &lt;em&gt;p&lt;/em&gt; 와 &lt;em&gt;q&lt;/em&gt; 가 연결되어있다면 똑같은 값을 가진다. 따라서&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;connected:&lt;/strong&gt; &lt;em&gt;p&lt;/em&gt; 와 &lt;em&gt;q&lt;/em&gt; 가 같은 값을 가지는지 살핀다.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;union:&lt;/strong&gt; &lt;code&gt;id[p]&lt;/code&gt; 와 같은 가지는 모든 인덱스의 값을 &lt;code&gt;id[q]&lt;/code&gt; 로 바꾼다&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구현은 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// UnionFind.java
public interface UnionFind {
	public void union(int p, int q);
	public boolean connected(int p, int q);
}

// QuickFind.java
public class QuickFind implements UnionFind {
	
	private int[] id;
	
	public QuickFind(int N) {
		this.id = new int[N];
		
		for(int i = 0; i &amp;lt; this.id.length; i++) {
			this.id[i] = i;
		}
	}

	public void union(int p, int q) {
		if (!connected(p, q)) {
			int pValue = id[p];
			
			// replace id values same as p&#39;s into the value of q
			for(int i = 0; i &amp;lt; this.id.length; i++) {
				if (id[i] == pValue) {
					id[i] = id[q];
				}
			}
		}
	}

	public boolean connected(int p, int q) {
		return id[p] == id[q];
	}

}

// QuickFindTest.java
import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;


public class QuickFindTest {
	
	private UnionFind uf;
	
	@Before
	public void setup() {
		uf = new QuickFind(10);
	}

	@Test
	public void testConnected() {
		assertThat(uf.connected(0, 1), is(false));
	}
	
	@Test
	public void testUnion() {
		assertThat(uf.connected(0, 1), is(not(true)));
		
		uf.union(0, 1);
		uf.union(0, 2);
		
		assertThat(uf.connected(0, 1), is(true));
		assertThat(uf.connected(1, 2), is(true));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;find(connected)&lt;/code&gt; 연산은 &lt;strong&gt;O(1)&lt;/strong&gt;, &lt;code&gt;union&lt;/code&gt; 연산은 &lt;strong&gt;O(n)&lt;/strong&gt; 의 복잡도를 가진다. 강좌에서는 각각 &lt;strong&gt;2 array accesses&lt;/strong&gt;, &lt;strong&gt;at most 2N+1 array accesses&lt;/strong&gt; 로 표현했다. 따라서 &lt;strong&gt;Quick-find&lt;/strong&gt; 의 Cost Model 은 아래와 같다. (Order of growth of number of array accesses)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;initialize:&lt;/strong&gt; N&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;union:&lt;/strong&gt; N&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;conncected:&lt;/strong&gt; 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 &lt;strong&gt;Quick-find&lt;/strong&gt; 방법 문제점은 &lt;code&gt;union&lt;/code&gt; 연산이 너무 비싸다는 것이다. N개의 오브젝트에 대해 N번의 Union 연산을 수행하면 &lt;strong&gt;N^2&lt;/strong&gt;, 즉 Quadratic(제곱)의 비용이 드는데, 이건 큰 문제다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Quadratic algorithms don&amp;rsquo;t scale with technology.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;컴퓨터가 10배 빨라지고, 메모리도 10 배만큼 늘었다고 하자. &lt;strong&gt;quadratic algorithm&lt;/strong&gt; 으로는 문제의 사이즈가 10배가 되면, 걸리는 시간은 100배가 된다. 연산 시간이 10배 빨라졌으므로 문제를 해결하려면 여전히 10배의 시간이 걸린다. 즉 기술이 10배나 발전해도, 문제의 사이즈에 해당하는 시간이 여전히 걸리는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quick-find&lt;/strong&gt; 접근 법은, &lt;strong&gt;find&lt;/strong&gt; 연산만 빠르다.&lt;/p&gt;

&lt;h3 id=&#34;quick-union&#34;&gt;Quick-union&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Quick-union&lt;/strong&gt; 은 알고리즘 디자인적으로 &lt;strong&gt;lazy approach&lt;/strong&gt; 라 볼 수 있다. &lt;strong&gt;Quick-find&lt;/strong&gt; 와 같은 자료 구조(배열)을 사용하나 자료 구조에 대한 interpretation 이 다르다.&lt;/p&gt;

&lt;p align=&#34;&#34;&gt;&lt;br/&gt;&lt;img src=&#34;http://www.timgittos.com/images/pa1/quick-union-overview.png&#34; /&gt;(http://www.timgittos.com/learning/princeton-algorithms-part-1/week-1/)&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;이 경우 연산은 각각 아래와 같이 생각할 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;find:&lt;/strong&gt; Check if &lt;em&gt;p&lt;/em&gt; and &lt;em&gt;q&lt;/em&gt; have the same root&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;union:&lt;/strong&gt; To mege components containing &lt;em&gt;p&lt;/em&gt; and &lt;em&gt;q&lt;/em&gt;, set the id of &lt;em&gt;p&lt;/em&gt;&amp;rsquo;s root to the id of &lt;em&gt;q&lt;/em&gt;&amp;rsquo;s root&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구현은 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// UnionFind.java
// same as above

// QuickUnion.java
public class QuickUnion implements UnionFind {
	
	private int[] id;
	
	public QuickUnion(int N) {
		this.id = new int[N];
		
		for(int i = 0; i &amp;lt; N; i++) {
			this.id[i] = i;
		}
	}
	
	public int getRoot(int n) {
		int root = id[n];
		
		while(root != id[root]) {
			root = id[root];
		}
		
		return root;
	}

	public void union(int p, int q) {
		if (!connected(p, q)) {
			int pRoot = this.getRoot(p);
			int qRoot = this.getRoot(q);
			id[pRoot] = qRoot;
		}
	}

	public boolean connected(int p, int q) {
		return getRoot(p) == getRoot(q);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// QuickUnionTest.java
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.not;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.*;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

public class QuickUnionTest {
	
	UnionFind uf;

	@Before
	public void setup() {
		uf = new QuickFind(10);
	}
	
	@Test
	public void testGetRoot() {
		QuickUnion spy = Mockito.spy(new QuickUnion(5));
		
		assertThat(spy.getRoot(0), is(0));
		assertThat(spy.getRoot(1), is(1));
		assertThat(spy.getRoot(2), is(2));
		assertThat(spy.getRoot(3), is(3));
		assertThat(spy.getRoot(4), is(4));
		
		spy.union(0, 1);
		assertThat(spy.getRoot(0), is(1));
		assertThat(spy.getRoot(1), is(1));

		spy.union(2, 3);
		spy.union(4, 2);
		assertThat(spy.getRoot(2), is(3));
		assertThat(spy.getRoot(3), is(3));
		assertThat(spy.getRoot(4), is(3));
	}
	
	@Test
	public void testConnected() {
		// initial     : 0 1 2 3 4
		// union(0, 1) : 1 1 2 3 4
		// union(2, 3) : 1 1 3 3 4
		// union(3, 1) : 1 1 3 1 4
		
		//   1   4
		//  0 3
		//    2 
		
		QuickUnion spy = Mockito.spy(new QuickUnion(5)); 
		when(spy.getRoot(1)).thenReturn(1);
		when(spy.getRoot(0)).thenReturn(1);
		when(spy.getRoot(3)).thenReturn(1);
		when(spy.getRoot(2)).thenReturn(1);
		when(spy.getRoot(4)).thenReturn(4);
		
		assertThat(spy.connected(0, 4), is(not(true)));
		assertThat(spy.connected(1, 4), is(not(true)));
		assertThat(spy.connected(2, 4), is(not(true)));
		assertThat(spy.connected(3, 4), is(not(true)));
		
		assertThat(spy.connected(0, 1), is(true));
		assertThat(spy.connected(0, 2), is(true));
		assertThat(spy.connected(0, 3), is(true));
		assertThat(spy.connected(1, 2), is(true));
		assertThat(spy.connected(1, 3), is(true));
		assertThat(spy.connected(2, 3), is(true));
	}
	
	@Test
	public void testUnion() {
		QuickUnion spy = Mockito.spy(new QuickUnion(5));
		when(spy.getRoot(0)).thenReturn(0);
		when(spy.getRoot(1)).thenReturn(1);
		when(spy.getRoot(2)).thenReturn(2);
		when(spy.getRoot(3)).thenReturn(3);
		when(spy.getRoot(4)).thenReturn(4);
		
		spy.union(0, 1);
		when(spy.getRoot(0)).thenReturn(1);
		spy.union(2, 3);
		when(spy.getRoot(2)).thenReturn(3);
		spy.union(2, 0);
		when(spy.getRoot(2)).thenReturn(1);
		when(spy.getRoot(3)).thenReturn(1);
		
		verify(spy, times(1)).connected(0, 1);
		verify(spy, times(1)).connected(2, 3);
		Mockito.reset(spy);
		
		assertThat(spy.connected(0, 1), is(true));
		assertThat(spy.connected(2, 3), is(true));
		assertThat(spy.connected(2, 0), is(true));
		assertThat(spy.connected(1, 3), is(true));
		assertThat(spy.connected(0, 3), is(true));
	}	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 경우 &lt;strong&gt;Cost Model&lt;/strong&gt; 은 아래와 같다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getRoot&lt;/code&gt;: depth of &lt;code&gt;n&lt;/code&gt; array accesses. &lt;strong&gt;O(n)&lt;/strong&gt; in worst case&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connected&lt;/code&gt;: depth of &lt;code&gt;q&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; array accesses. &lt;strong&gt;O(n)&lt;/strong&gt; in worst case&lt;/li&gt;
&lt;li&gt;&lt;code&gt;union&lt;/code&gt;: depth of &lt;code&gt;q&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; array accesses. &lt;strong&gt;O(n)&lt;/strong&gt; in worse case&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Quick-find&lt;/strong&gt; 의 defect 는
- &lt;code&gt;union&lt;/code&gt; is too expensive&lt;br /&gt;
- Trees are flat but too expensive keep them flat.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quick-union&lt;/strong&gt; 의 defect 는
- Trees can get tall&lt;br /&gt;
- &lt;code&gt;find(connected)&lt;/code&gt; is too expensive (could be N array accesses)&lt;/p&gt;

&lt;h3 id=&#34;quick-union-improvement&#34;&gt;Quick-union Improvement&lt;/h3&gt;

&lt;h4 id=&#34;1-weighted-quick-union&#34;&gt;1. Weighted Quick-union&lt;/h4&gt;

&lt;p&gt;기본 아이디어는 간단하다. &lt;code&gt;union&lt;/code&gt; 연산을 수행할때 낮은 트리가 높은 트리에 속하게 함으로써 &lt;strong&gt;Worst case&lt;/strong&gt; 를 방지하는 것이다. (마치 Balanced Tree 처럼)&lt;/p&gt;

&lt;p align=&#34;&#34;&gt;&lt;br/&gt;&lt;img src=&#34;http://my.csdn.net/uploads/201206/12/1339479587_5986.png&#34; /&gt;(http://my.csdn.net/uploads/201206/12/1339479587_5986.png)&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;다른것은 모두 같지만, 트리의 크기를 비교해야 하기 때문에 트리의 크기를 저장할 배열이 필요하며, 이런 트리 크기를 비교하고 변경할 로직이 &lt;code&gt;union&lt;/code&gt; 메소드에 추가되어야 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// UnionFind.java is same as above
// QuickUnion.java is same as above
// WeightedQuickUnion.java

public class WeightedQuickUnion extends QuickUnion {
	
	int treeSize[];

	public WeightedQuickUnion(int N) {
		super(N);
		
		this.treeSize = new int[N];
		
		for(int i = 0; i &amp;lt; this.treeSize.length; i++)  {
			this.treeSize[i] = 1;
		}
	}
	
	// for debug
	public int getTreeSize(int index) {
		return treeSize[index];
	}
	
	@Override
	public void union(int p, int q) {
		if(!connected(p, q)) {
			int qRoot = getRoot(q);
			int pRoot = getRoot(p);
			
			if (treeSize[qRoot] &amp;gt;= treeSize[pRoot]) {
				id[pRoot] = qRoot;
				treeSize[qRoot] += treeSize[pRoot];
			} else {
				id[qRoot] = pRoot;
				treeSize[pRoot] += treeSize[qRoot];
			}
		
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;WeightedQuickUnionTest.java
import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import org.junit.Test;
import org.mockito.Mockito;

public class WeightedQuickUnionTest {
	
	WeightedQuickUnionTest spy;

	@Test
	public void testUnion() {
		WeightedQuickUnion spy = Mockito.spy(new WeightedQuickUnion(5));
	
		assertThat(spy.connected(0, 1), is(not(true)));
		// 0 1 -&amp;gt; 1 1
		spy.union(0, 1);
		assertThat(spy.connected(1, 0), is(true));
		assertThat(spy.getTreeSize(0), is(1));
		assertThat(spy.getTreeSize(1), is(2));
		
		// 1 1 2 -&amp;gt; 1 1 1 
		spy.union(0, 2);
		assertThat(spy.connected(0, 1), is(true));
		assertThat(spy.connected(1, 2), is(true));
		assertThat(spy.connected(0, 2), is(true));
		
		assertThat(spy.getRoot(0), is(1));
		assertThat(spy.getRoot(1), is(1));
		assertThat(spy.getRoot(2), is(1));
		
		// 1 1 1 4 4
		spy.union(3, 4);
		assertThat(spy.connected(1, 3), is(false));
		assertThat(spy.connected(4, 3), is(true));
		
		// 1 1 1 4 1
		spy.union(2,  4);
		assertThat(spy.connected(4, 3), is(true));
		assertThat(spy.getRoot(4), is(1));
		assertThat(spy.getRoot(3), is(1));
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 때 &lt;strong&gt;Cost Model&lt;/strong&gt; 은&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;find&lt;/code&gt;: taks time proportional to depth of &lt;em&gt;p&lt;/em&gt; and &lt;em&gt;q&lt;/em&gt; &lt;strong&gt;O(logN)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;union&lt;/code&gt;: take constant time, given roots (without roots &lt;strong&gt;O(logN)&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;같은 사이즈의 트리끼리 merged 도야 depth 가 1 깊어지므로 N개의 원소에 대해 &lt;strong&gt;Weighted Quick-union&lt;/strong&gt; 이 구성하는 트리는 아무리 깊어봐야(at most) &lt;strong&gt;lg *N&lt;/strong&gt;* 이다.&lt;/p&gt;

&lt;h4 id=&#34;2-path-compression&#34;&gt;2. Path Compression&lt;/h4&gt;

&lt;p&gt;또 다른 &lt;strong&gt;Quick-union&lt;/strong&gt; 개선 방안은, &lt;strong&gt;Path Compression&lt;/strong&gt; 으로 루트를 탐색할때마다, 루트값을 새로 고쳐 써 다음번에 탐색할때 탐색 시간을 줄이는 방법이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// WeightedQuickUnion.java

...
...
	public int getRoot(int n) {
		
		int root = id[n];
		
		while(root != id[root]) {
			id[root] = id[id[root]];
			root = id[root];
		}
		
		return root;
	}
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;WQUPC(Weighted Quick-union with path compression)&lt;/strong&gt; 은 &lt;a href=&#34;http://upload.wikimedia.org/math/6/b/3/6b3721001c02b39a0da7d57a129e7661.png&#34;&gt;iterated logarithm (&lt;strong&gt;lg**N&lt;/strong&gt;*)&lt;/a&gt; 의 복잡도를 가진 다는 것이 증명 되었다. &lt;strong&gt;WQUPC&lt;/strong&gt; 는 실제로 데이터를 읽어 들이는 비용도 있기 때문에 이론적으로는 linear 하지 않으나, 실제로는 linear 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;N&lt;/em&gt;&lt;/strong&gt; 개의 오브젝트를 초기화 하고 여기에 대해 &lt;strong&gt;&lt;em&gt;M&lt;/em&gt;&lt;/strong&gt; 번의 &lt;code&gt;union-find&lt;/code&gt; 연산을 수행한다면 &lt;strong&gt;Worst case&lt;/strong&gt; 에 대해 복잡도를 정리해 보면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Quick-find:&lt;/strong&gt; M * N&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Quick-union:&lt;/strong&gt; M * N&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Weighted Quick-union:&lt;/strong&gt; N + M &lt;em&gt;logN&lt;/em&gt; (array 를 balanced 하게 만든다.)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Quick-union with path compression:&lt;/strong&gt; N + M &lt;em&gt;logN&lt;/em&gt; (array 를 flat 하게 만든다.)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WQUPC:&lt;/strong&gt; N + M lg*&lt;em&gt;N&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 보면 알고리즘의 복잡도는 별거 없어보이는데, 사실 무지막지하게 큰 차이다. 10^9 개의 오브젝트에 대해서 10^9 연산을 할 경우 &lt;strong&gt;Quick-find&lt;/strong&gt; 를 사용할때 30년이 걸린다면 &lt;strong&gt;WQUPC&lt;/strong&gt; 는 6초만에 해결할 수 있다. 다시 말해, 알고리즘은 슈퍼컴퓨터도 별 도움이 되지 못하는 문제를 해결할 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;applications-of-union-find&#34;&gt;Applications of Union-find&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Percolation&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Dynmaic Connectivity&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Lear common ancestor&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Kruskal&amp;rsquo;s minimum spanning tree&lt;/li&gt;
&lt;li&gt;and so on&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;percolation&#34;&gt;Percolation&lt;/h4&gt;

&lt;p align=&#34;&#34;&gt;&lt;br/&gt;&lt;img src=&#34;http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolates.png&#34; /&gt;(http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation.html)&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Percolation&lt;/strong&gt; 이란, &lt;em&gt;N&lt;/em&gt;-by-&lt;em&gt;N&lt;/em&gt; 의 Grid 에서 각 opened-site 는 확률 &lt;em&gt;p&lt;/em&gt; blocked-site 는 &lt;em&gt;1-p&lt;/em&gt; 의 확률을 가진다. 이 모델은 주로 물리 시스템을 모델링하기위해 사용된다.&lt;/p&gt;

&lt;p&gt;이론상 &lt;em&gt;N&lt;/em&gt; 이 충분히 크면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;p&lt;/em&gt; &amp;gt; &lt;em&gt;p*&lt;/em&gt; 인 지점에서는 almost certainly percolates 하고&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;p&lt;/em&gt; &amp;lt; &lt;em&gt;p*&lt;/em&gt; 인 지점에서는 alomost certainly does not percolate 하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p align=&#34;&#34;&gt;&lt;br/&gt;&lt;img src=&#34;http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation-threshold20.png&#34; /&gt; (http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation.html)&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;문제는 그런 &lt;em&gt;p*&lt;/em&gt; 값이 무엇이냐 하는건데, 수학적으로는 찾을 길이 없고, 컴퓨터 시뮬레이션으로는 &lt;strong&gt;Union-find algorithm&lt;/strong&gt; 을 이용하면 구할 수 있다. 유명한 방법으로 &lt;strong&gt;Monte Carlo simulation&lt;/strong&gt; 이 있는데, &lt;em&gt;N&lt;/em&gt;-by-&lt;em&gt;N&lt;/em&gt; Grid 를 blocked site 로 채우고, 랜덤하게 open site 를 만들면서 top 과 bottom 이 percolate 되는지 매번 확인한다. 연결되면, vacancy percentage 가 &lt;em&gt;p*&lt;/em&gt; 에 대한 추정값이다.&lt;/p&gt;

&lt;p&gt;구현 방법은 각 site 를 노드로 생각하고, top 과 bottom 을 그룹으로 묶어(virtual site) top 이 bottom 과 연결되는지 매번 체크하면 된다. 자세한 내용은 &lt;a href=&#34;http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation.html&#34;&gt;여기&lt;/a&gt;를 참조&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Algorithm: Analysis</title>
      <link>https://1ambda.github.io/91/algorithm/algorithm-part1-2/</link>
      <pubDate>Sat, 25 Jun 2016 13:01:05 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/algorithm-part1-2/</guid>
      <description>

&lt;p&gt;알고리즘을 분석해야 하는 이유는&lt;/p&gt;

&lt;p&gt;(1) Predict performance&lt;br /&gt;
(2) Compare algorithms&lt;br /&gt;
(3) Provide guarantees&lt;br /&gt;
(4) Understand theoretical basis&lt;/p&gt;

&lt;p&gt;그 중에서도 &lt;em&gt;performance bug&lt;/em&gt; 를 피하는 것이 무엇보다 중요하다. 이를 통해 내 알고리즘이 &lt;em&gt;practical large input&lt;/em&gt; 에 적용할 수 있을까? 고민하는 것이, 알고리즘 분석의 주된 동기다.&lt;/p&gt;

&lt;h3 id=&#34;observations&#34;&gt;Observations&lt;/h3&gt;

&lt;p&gt;주어진 배열에서 3개를 골라 더했을때 0이 나오는 &lt;em&gt;3-Sum&lt;/em&gt; 문제를 고려해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for (int i = 0; i &amp;lt; N; i++)
  for(int j = i + 1; j &amp;lt; N; j++)
    for(int k = j + 1; k &amp;lt; N; k++) 
      if (array[i] + array[j] + array[k] == 0)
        count++;        
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;입력 대비 출력 시간을 &lt;em&gt;log-log plot&lt;/em&gt; 으로 만들어, &lt;code&gt;y = a * N^b&lt;/code&gt; 를 얻을 수 있다. 이것 보다 더 빠르게 찾는 방법은 &lt;em&gt;input&lt;/em&gt; 을 두배씩 늘려가면서 로그 비율을 찾는 방법인데, &lt;em&gt;Doubling hypothesis&lt;/em&gt; 라 부른다. 이 경우 &lt;code&gt;b&lt;/code&gt; 가 3이 나오는걸 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;샘플 데이터가 다음과 같다고 하자. (Matlab format)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-matlab&#34;&gt;x = [
1000;
2000;
4000;
8000;
16000;
32000;
64000]

y = [
0.0;
0.0;
0.1;
0.3;
1.3;
5.1;
20.5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 경우 수가 클때, 4배씩 증가하므로 &lt;em&gt;2-based log ratio&lt;/em&gt; 는 &lt;code&gt;2&lt;/code&gt; 다. 따라서 &lt;code&gt;a * N^b&lt;/code&gt; 에서 &lt;code&gt;b&lt;/code&gt; 를 2로 가정하면, &lt;code&gt;5.1 / 32000^2&lt;/code&gt; 하면, 대략 &lt;code&gt;5.0 * 10^-9&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;mathematical-models&#34;&gt;Mathematical Models&lt;/h3&gt;

&lt;p&gt;사실 &lt;em&gt;Running time&lt;/em&gt; 에 있어서 연산의 수행 시간은 컴퓨터마다, 또 연산마다 다르므로 이것을 제하고 &lt;em&gt;operation number&lt;/em&gt;, &lt;em&gt;frequency&lt;/em&gt; 의 곱을 &lt;em&gt;input number&lt;/em&gt; &lt;code&gt;N&lt;/code&gt; 을 이용하여 표현한 모델을 이용할 수 있다. 예를 들어 &lt;em&gt;1-Sum&lt;/em&gt; 코드의 경우&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int count = 0;
for (int i = 0; i &amp;lt; N; i++)
  if (array[i] == 0)
    count++;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;variable declaration = 2&lt;br /&gt;
assignment = 2&lt;br /&gt;
less then compare = N + 1&lt;br /&gt;
equal to compare = N&lt;br /&gt;
array access = N&lt;br /&gt;
increment = N to 2N&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;2-Sum&lt;/em&gt; 코드의 경우&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int count = 0;
for (int i = 0; i &amp;lt; N; i++)
  for(int j = i + 1; j &amp;lt; N; j++)
    if (array[i] + array[j] == 0)
      count++;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;variable declaration = 2 + N
assignment = 2 + N
less then compare = &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; * (N + 1) * (N + 2)&lt;br /&gt;
equal to compare = &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; * N * (N - 1)&lt;br /&gt;
array access = N * (N - 1)&lt;br /&gt;
increment = &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; * N * (N - 1) to N * (N - 1)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;세 보면 알겠지만 정말 귀찮다. 세야할 연산의 종류도 많고. 그렇기 때문에, &lt;em&gt;running-time&lt;/em&gt; 을 간단히 추정하기 위해&lt;/p&gt;

&lt;p&gt;(1) Use some basic operation as a proxy for running time&lt;br /&gt;
(2) tilde notation: ignore lower order terms&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;2-Sum&lt;/em&gt; 의 경우 유효한 연산을 배열 접근으로 잡으면, 연산 회수는 &lt;code&gt;~N^2&lt;/code&gt; 이고 &lt;em&gt;3-Sum&lt;/em&gt; 은 &lt;code&gt;~ 1/6 * N^3&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;discrete sum&lt;/em&gt; 을 편하게 계산하는 법이 있는데, 시그마를 적분으로 바꿔, 계산하면 된다. 따라서 &lt;code&gt;1 + 2 + ... + N&lt;/code&gt; 은 &lt;code&gt;1/2 * N&lt;/code&gt;, &lt;code&gt;1 + 1/2 + 1/3 + ... + 1/N&lt;/code&gt; 은 &lt;code&gt;ln N&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;&lt;em&gt;3-Sum&lt;/em&gt; 의 &lt;em&gt;triple loop&lt;/em&gt; 는 &lt;code&gt;N * 1/2 N* 1/3 N&lt;/code&gt; 이므로, &lt;code&gt;~1/6 N&lt;/code&gt; 이다. 여기에 3번의 Array Access 가 일어나므로 곱하면 &lt;em&gt;3-Sum&lt;/em&gt; 은 &lt;code&gt;~1/2 N&lt;/code&gt;이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int sum = 0;
for (int i = 0; i &amp;lt; N; i++)
  for (int j = i; j &amp;lt; N; j++)
    for (int k = 1; k &amp;lt; N; k = k * 2)
      if (a[i] + a[j] &amp;gt;= a[k]) sum++;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;모든 &lt;em&gt;triple loop&lt;/em&gt; 가 &lt;code&gt;~n^3&lt;/code&gt; 을 가지는건 아니다. 위의 코드의 경우 &lt;code&gt;~ 1/2 N^2 * 3 lg  N&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&#34;order-of-growth-classification&#34;&gt;Order of Growth Classification&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;1&lt;/code&gt; &amp;lt; &lt;code&gt;lg N&lt;/code&gt; &amp;lt; &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;N lg N&lt;/code&gt; &amp;lt; &lt;code&gt;N^2&lt;/code&gt; &amp;lt; &lt;code&gt;N^3&lt;/code&gt; &amp;lt; &lt;code&gt;2^N&lt;/code&gt; 우측으로 갈 수록 알고리즘의 성능이 나쁘다. 일반적으로는 &lt;code&gt;N lg N&lt;/code&gt; 이 쓸 수 있는 알고리즘이다. 좀 더 알아보자면,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;log N:&lt;/strong&gt; N 이 절반으로 나누어지는 &lt;em&gt;binary search&lt;/em&gt; 등&lt;br /&gt;
&lt;strong&gt;N log N:&lt;/strong&gt;, &lt;em&gt;divide and conquer: merge sort&lt;/em&gt; 등&lt;br /&gt;
&lt;strong&gt;2^N:&lt;/strong&gt; 서브트리를 모두 검사하는 &lt;em&gt;exhaustive search&lt;/em&gt; 등&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;알고리즘의 성능을 비교하기 위해 &lt;code&gt;T(2N) / T(N)&lt;/code&gt; 을 구할 수 있는데,&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;N&lt;/code&gt; 은 &lt;code&gt;2&lt;/code&gt; (따라서 lg 2 = 1 이므로, &lt;code&gt;N^1&lt;/code&gt; 이다.)&lt;br /&gt;
(2) &lt;code&gt;N^2&lt;/code&gt; 은 &lt;code&gt;4&lt;/code&gt;&lt;br /&gt;
(3) &lt;code&gt;N^3&lt;/code&gt; 같은 경우 &lt;code&gt;8&lt;/code&gt; 이다.
(4) &lt;code&gt;2^N&lt;/code&gt; 은 &lt;code&gt;T(N)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;잠깐 &lt;code&gt;~lg N&lt;/code&gt; 의 복잡도를 가지는 &lt;em&gt;Binary Search&lt;/em&gt; 에 대해 이야기 해 보자.&lt;/p&gt;

&lt;h4 id=&#34;binary-search&#34;&gt;Binary Search&lt;/h4&gt;

&lt;p&gt;이진트리에 대해 재밌는 사실이 하나 있다. 이진트리가 나온건 1946년인데, 놀랍게도 버그가 없는 버전은 1962년에 처음 나왔다. 그리고 자바의 &lt;code&gt;Arrays.binarySerach()&lt;/code&gt; 도 2006년에 버그가 발견되었다. 아래의 코드에서 만약 &lt;code&gt;arr&lt;/code&gt; 에 &lt;code&gt;[1]&lt;/code&gt; 을 넣고, &lt;code&gt;key&lt;/code&gt; 에 &lt;code&gt;1&lt;/code&gt; 을 주면 어떻게 될지 한번 생각 해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int binarySearch(int[] arr, int key) {
  int low = 0, high = arr.length - 1;
  
  while (low &amp;lt;= high) {
    int mid = low + (high - low) / 2;
    
    if (key &amp;lt; arr[mid]) high = mid - 1; // 3-way compares
    else if (key &amp;gt; arr[mid]) low = mid + 1;
    else return mid
  }
  
  return -1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;binary search&lt;/em&gt; 를 &lt;em&gt;2-way compare&lt;/em&gt; 로 구현하면, 다시 말해 &lt;code&gt;if-else&lt;/code&gt; 만 이용하면 &lt;code&gt;1 + lg N&lt;/code&gt; 의 복잡도를 가지게 된다. 이는 &lt;code&gt;T(N) &amp;lt;= 1 + T(N/2)&lt;/code&gt; , &lt;code&gt;T(N) &amp;lt;= 1 + 1 + T(N/4)&lt;/code&gt;, &amp;hellip; &lt;code&gt;T(N) = 1 + 1 + ... + T(N/N)&lt;/code&gt; 이기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;binary search&lt;/em&gt; 가 &lt;code&gt;1 + lg N&lt;/code&gt; 이라는 사실을 이용하면 &lt;em&gt;3-Sum&lt;/em&gt; 을 &lt;code&gt;N^2 lg N&lt;/code&gt; 으로 개선할 수 있다.&lt;/p&gt;

&lt;p&gt;(1) sorting: &lt;code&gt;N^2&lt;/code&gt;&lt;br /&gt;
(2) binary search for &lt;code&gt;-(arr[i] + arr[j])&lt;/code&gt;  : &lt;code&gt;N^2 log N&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;두번째 스탭에서 &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; 에 대해 이진탐색을 시도하므로 &lt;code&gt;N^2 * log N&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&#34;theory-of-algorithms&#34;&gt;Theory of Algorithms&lt;/h3&gt;

&lt;p&gt;이제 &lt;strong&gt;Best case(lower bound on cost)&lt;/strong&gt;, &lt;strong&gt;Worst case(upper bound on cost)&lt;/strong&gt;, &lt;strong&gt;Average case(expected cost)&lt;/strong&gt; 를 고려 해 보자&lt;/p&gt;

&lt;p&gt;이를 위해 새로운 &lt;em&gt;notation&lt;/em&gt; 을 도입할 수 있다. 교수님이 해주시는 설명을 솔직히 못 알아 듣겠다. 그냥 &lt;em&gt;big theta&lt;/em&gt;, &lt;em&gt;big omega&lt;/em&gt;, &lt;em&gt;big oh&lt;/em&gt; 에 대해 구글링 해서 나오는 &lt;a href=&#34;http://stackoverflow.com/questions/471199/what-is-the-difference-between-%CE%98n-and-on&#34;&gt;SO 답변&lt;/a&gt; 을 참조했다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;strong&gt;asymptotic&lt;/strong&gt; 이란 말을 이해해야 하는데 한국어로 표현하면 &lt;em&gt;점근적&lt;/em&gt; 정도가 된다. &lt;del&gt;m 은 묵음&lt;/del&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If an algorithm is of Θ(g(n)), it means that the running time of the algorithm as n (input size) gets larger is proportional to g(n).&lt;/p&gt;

&lt;p&gt;If an algorithm is of O(g(n)), it means that the running time of the algorithm as n gets larger is at most proportional to g(n).&lt;/p&gt;

&lt;p&gt;More technically, O(n) represents upper bound. Θ(n) means tight bound. Ω(n) represents lower bound.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;우리가 어떤 알고리즘이 &lt;code&gt;O(n)&lt;/code&gt; 이라고 할 때 &lt;code&gt;O(n^2)&lt;/code&gt;, 혹은 &lt;code&gt;O(n^3)&lt;/code&gt; 이라고 말할 수 있다. &lt;em&gt;upper bound&lt;/em&gt; 니까. 하지만 어떤 알고리즘(&lt;code&gt;f(n)&lt;/code&gt;) 이 &lt;code&gt;Θ(n)&lt;/code&gt; 일때, &lt;code&gt;Θ(n^2)&lt;/code&gt; 이라 말할 순 없다. 그리고 &lt;em&gt;Big-Oh&lt;/em&gt; 와 &lt;em&gt;Big-theta&lt;/em&gt; 가 존재 해야 &lt;em&gt;Big-omega&lt;/em&gt; 가 존재한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;f(x) = Θ(g(x)) iff f(x) = O(g(x)) and f(x) = Ω(g(x))&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이런 표기법을 이용하는 이유는, 다시 말해서 &lt;em&gt;Theory of algorithm&lt;/em&gt; 의 목적은 &lt;em&gt;optimal algorithm&lt;/em&gt; 을 찾는데 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;1-sum&lt;/em&gt; 을 예로 들어 보자. &lt;em&gt;upper bound&lt;/em&gt; 는, 모든 원소를 찾는 것이다. 따라서 &lt;code&gt;O(n)&lt;/code&gt;.  적어도 모든 원소를 한번씩은 다 뒤져봐야 하므로, &lt;em&gt;lower bound&lt;/em&gt; 는 &lt;code&gt;Ω(n)&lt;/code&gt; 이다. 따라서 두개가 &lt;em&gt;constant factor&lt;/em&gt; 내에서 같으므로 &lt;code&gt;Θ(n)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;3-sum&lt;/em&gt; 을 고려해 보자. &lt;em&gt;upper bound&lt;/em&gt; 는 &lt;code&gt;O(n^2 * lg n)&lt;/code&gt; 이다. &lt;em&gt;lower bound&lt;/em&gt; 는 확실힌 모르겠지만 적어도 모든 원소를 한번씩은 훑어야 하므로 &lt;code&gt;Ω(n)&lt;/code&gt; 다. &lt;a href=&#34;http://cstheory.stackexchange.com/questions/14585/lower-bounds-for-3sum-with-a-free-cache&#34;&gt;여기&lt;/a&gt; 보면 &lt;em&gt;3-sum&lt;/em&gt; 의 &lt;em&gt;lower bound&lt;/em&gt; 에 관한 논의가 있다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;3-sum&lt;/em&gt; 에 대한 확실한 &lt;em&gt;lower bound&lt;/em&gt; 를 모르므로, &lt;em&gt;upper bound&lt;/em&gt; 와의 갭이 있고, 아직까진 &lt;em&gt;optimal algorithm&lt;/em&gt; 이 무엇인지 알 수 없다.&lt;/p&gt;

&lt;p&gt;따라서 알고리즘을 디자인하는 접근 방법은,&lt;/p&gt;

&lt;p&gt;(1) Develop an algorithm&lt;br /&gt;
(2) Prove a lower bound&lt;/p&gt;

&lt;p&gt;그리하여, &lt;em&gt;lower bound&lt;/em&gt; 와 &lt;em&gt;upper bound&lt;/em&gt; 사이의 갭이 있다면 &lt;em&gt;lower bound&lt;/em&gt; 를 증가시키는 새로운 알고리즘이 여지가 있다. 그걸 찾아내면서 &lt;em&gt;lower bound&lt;/em&gt; 를 올려가면 &lt;em&gt;optimal algorithm&lt;/em&gt; 을 찾을 수 있다.&lt;/p&gt;

&lt;p&gt;1970년대에는 &lt;em&gt;upper bound&lt;/em&gt; 를 줄여왔지만,&lt;/p&gt;

&lt;p&gt;(1) 너무 &lt;em&gt;worst case&lt;/em&gt; 에만 집중헀고&lt;br /&gt;
(2) 이제 더 정확한 성능 측정을 위해서 &lt;em&gt;to within a constant factor&lt;/em&gt; 보다 더 좋은 무언가가 필요하다.&lt;/p&gt;

&lt;p&gt;그리고 많은 사람들이 &lt;em&gt;Big o&lt;/em&gt; 를 &lt;em&gt;approximate model of running time&lt;/em&gt; 으로 번역하는 실수를 저질렀는데, 이 수업에서는 &lt;em&gt;Big o&lt;/em&gt; 대신 &lt;em&gt;tilde(~)&lt;/em&gt; 를 사용하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://qlx.is.quoracdn.net/main-ce94d194dc6a85d3.png&#34; align=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;If&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://qlx.is.quoracdn.net/main-30ac99d6624fcf8c.png&#34; align=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;memory&#34;&gt;Memory&lt;/h3&gt;

&lt;p&gt;자바에서는 다음과 같은 오버헤드가 있다.&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;N&lt;/code&gt; 개의 1차원 배열을 만들때는 &lt;em&gt;Type * N + 24 Bytes&lt;/em&gt;&lt;br /&gt;
(2) &lt;em&gt;Object&lt;/em&gt; 는 &lt;em&gt;16 Bytes&lt;/em&gt;&lt;br /&gt;
(3) &lt;em&gt;Reference&lt;/em&gt; 는 &lt;em&gt;8 Bytes&lt;/em&gt;&lt;br /&gt;
(4) 각 오브젝트는 &lt;em&gt;8 Bytes&lt;/em&gt; 단위로 패딩된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;String&lt;/strong&gt; 은 조금 더 복잡한데,&lt;/p&gt;

&lt;p&gt;오브젝트 오버헤드, &lt;code&gt;char&lt;/code&gt; 배열 오버헤드(&lt;code&gt;2N + 24&lt;/code&gt;)와 함께 &lt;code&gt;offset&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt; 를 &lt;code&gt;int&lt;/code&gt; 타입으로 가지므로 &lt;em&gt;12 Bytes&lt;/em&gt; 와 패딩이 포함된다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;inner class&lt;/em&gt; 가 있다면 &lt;em&gt;Object&lt;/em&gt; 에 &lt;em&gt;8 bytes&lt;/em&gt; 의 메모리가 더 필요하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WeightedQuickUnionUF {
  private int[] id;
  private int[] sz;
  private int count;
  
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 클래스를 인스턴스로 가지고 있을 경우엔 &lt;code&gt;N&lt;/code&gt; 에 대해서&lt;/p&gt;

&lt;p&gt;(1) 16 bytes &lt;em&gt;object overhead&lt;/em&gt;&lt;br /&gt;
(2) 8 + (4N + 24) for each &lt;em&gt;int[] array&lt;/em&gt;&lt;br /&gt;
(3) 4 bytes for &lt;code&gt;count&lt;/code&gt;&lt;br /&gt;
(4) 4 bytes padding&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;8N + 88&lt;/code&gt; 이므로 &lt;code&gt;~8 N&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Empirical analysis&lt;/strong&gt; 은 실제로 프로그램을 돌려 성능을 얻은 다음 가설을 새워 예측하는 방법이다. 반면 &lt;strong&gt;Mathematical analysis&lt;/strong&gt; 는 알고리즘을 분석해 연산 횟수에 기반한 모델을 새우는 방법이다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Emplirical analysis model enables us to &lt;strong&gt;make predictions&lt;/strong&gt; and necessary to validate mathematical models&lt;/p&gt;

&lt;p&gt;Mathematical analysis model enables us to &lt;strong&gt;explain behavior&lt;/strong&gt; and is independent of a particular system.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Algorithm: Spanning Tree, Shortest Paths</title>
      <link>https://1ambda.github.io/91/algorithm/algorithm-part2-1/</link>
      <pubDate>Sat, 25 Jun 2016 13:01:15 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/algorithm-part2-1/</guid>
      <description>

&lt;h4 id=&#34;is-a-graph-bipartite&#34;&gt;Is a graph bipartite?&lt;/h4&gt;

&lt;p&gt;그래프가 &lt;em&gt;bipartite&lt;/em&gt; 인가 하는 문제는, 그래프의 노드를 이렇게 두 그룹으로 나눌 수 있느냐 하는 문제다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/e/e8/Simple-bipartite-graph.svg/330px-Simple-bipartite-graph.svg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Biclique_K_3_5.svg/330px-Biclique_K_3_5.svg.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://en.wikipedia.org&#34;&gt;http://en.wikipedia.org&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;알고리즘이 얼마나 어려운가는 이렇게 나눠볼 수 있겠는데&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Any programmer could do it&lt;/li&gt;
&lt;li&gt;Typical diligen algorithms student could do it&lt;/li&gt;
&lt;li&gt;Hire an expert&lt;/li&gt;
&lt;li&gt;Intractable&lt;/li&gt;
&lt;li&gt;No one knows&lt;/li&gt;
&lt;li&gt;Impossile&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;biparting&lt;/em&gt; 문제는 &lt;em&gt;DFS-based solution&lt;/em&gt; 을 이용할 수 있으므로, 난이도 2정도에 해당한다 볼 수 있겠다.&lt;/p&gt;

&lt;p&gt;생각해 볼 수 있는 응용은, 질병의 전파 경로를 그래프로 그리고 &lt;em&gt;biparting&lt;/em&gt; 이 가능한지 보는 것이다.&lt;/p&gt;

&lt;h4 id=&#34;find-a-cycle&#34;&gt;Find a cycle&lt;/h4&gt;

&lt;p&gt;이것도 난이도 (2) 정도. 마찬가지로 &lt;em&gt;simple DFS-based solution&lt;/em&gt; 을 이용하자.&lt;/p&gt;

&lt;p&gt;잘 알려진 응용으로, &lt;em&gt;euler tour&lt;/em&gt; 가 있다. 각 &lt;em&gt;edge&lt;/em&gt; 를 단 한번씩만 방문하는 &lt;em&gt;cycle&lt;/em&gt; 이 있는지를 검사하는 문제다. 여기서 시작점과 끝 점이 같으면 &lt;em&gt;euler circuit&lt;/em&gt; 이고, 다르면 &lt;em&gt;euler path&lt;/em&gt; 라 부른다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ko.wikipedia.org/wiki/%EC%98%A4%EC%9D%BC%EB%9F%AC_%EA%B2%BD%EB%A1%9C&#34;&gt;여기&lt;/a&gt;에 의하면 그래프에 오일러 회로가 존재하려면&lt;/p&gt;

&lt;p&gt;(1) 연결된 그래프여야 하고&lt;br /&gt;
(2) 모든 꼭지점의 차수가 짝수여야 한다.&lt;/p&gt;

&lt;p&gt;반면 오일러 경로라면, 연결그래프에서 정확히 두 개의 꼭지점만 홀수 차수여야 한다.&lt;/p&gt;

&lt;p&gt;각 &lt;em&gt;node&lt;/em&gt; 를 정확히 한번씩만 지나는 &lt;em&gt;cycle&lt;/em&gt; 을 &lt;em&gt;traveling salesman problem, TSP&lt;/em&gt; 혹은 &lt;em&gt;hamiltonian path problem&lt;/em&gt; 이라 부른다.&lt;/p&gt;

&lt;p&gt;오일러 순회와 경로처럼 시작점과 끝점이 같은지, 아닌지에 따라 구분할 수 있다. &lt;em&gt;hamiltonian cycle&lt;/em&gt; 은 전형적인 &lt;em&gt;NP-complete problem&lt;/em&gt; 으로 알려져있다. 난이도로 구분하자면 &lt;em&gt;(4) intractable&lt;/em&gt; 정도 되시겠다.&lt;/p&gt;

&lt;h4 id=&#34;graph-isomorphism-problem&#34;&gt;Graph Isomorphism Problem&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Are two graphs identical except for vertex names?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그래프의 형태가 같은지 묻는 문제다. 예를 들어 다음의 두 그래프는 같은 형태다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.biodatamining.org/content/figures/1756-0381-4-10-3-l.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.biodatamining.org/&#34;&gt;http://www.biodatamining.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;두 그래프의 노드를 &lt;code&gt;n!&lt;/code&gt; 으로 배열해 가면서 같은지 비교하는 단순한 방법은 그래프가 커지면 기하 급수적으로 성능이 느려진다. 더 나은 알고리즘이 있는지 연구자들이 노력하고 있지만, 아직 모른다. 난이도는 &lt;em&gt;(5) No one knows&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;graphs-planarity&#34;&gt;Graphs Planarity&lt;/h4&gt;

&lt;p&gt;그래프를 &lt;em&gt;crossing edge&lt;/em&gt; 가 없는 그래프로 그릴 수 있느냐 하는 문제다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;평면 그래프(planar graph)는 평면 상에 그래프를 그렸을 때, 두 변이 꼭지점 이외에 만나지 않도록 그릴 수 있는 그래프를 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이건 난이도 &lt;em&gt;(3) Hier an expert&lt;/em&gt; 문제다. &lt;em&gt;DFS&lt;/em&gt; 기반의 &lt;em&gt;linear time&lt;/em&gt; 알고리즘이 1970년대에 발표되었다.&lt;/p&gt;

&lt;h3 id=&#34;minimum-spanning-trees&#34;&gt;Minimum Spanning Trees&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;undirected, positive edge weights&lt;/em&gt; 그래프에서&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;connected, acyclic&lt;/em&gt; &lt;strong&gt;(tree)&lt;/strong&gt;&lt;br /&gt;
(2) &lt;em&gt;includes all of the vertices&lt;/em&gt; &lt;strong&gt;(spanning)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;인 서브 그래프를 &lt;strong&gt;&lt;em&gt;spanning tree&lt;/em&gt;&lt;/strong&gt; 라 부른다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;minimum spanning tree&lt;/em&gt;&lt;/strong&gt; 는 여기서 &lt;em&gt;min weight&lt;/em&gt; 를 갖는 &lt;em&gt;spanning tree&lt;/em&gt; 를 찾는 문제다.&lt;/p&gt;

&lt;h4 id=&#34;applications&#34;&gt;Applications&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;dithering&lt;/li&gt;
&lt;li&gt;cluster analysis&lt;/li&gt;
&lt;li&gt;max bottleneck paths&lt;/li&gt;
&lt;li&gt;network design&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등에 활용할 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;mst-greedy-algorithm&#34;&gt;MST: Greedy Algorithm&lt;/h3&gt;

&lt;p&gt;간단한 설명을 위해서 그래프가 연결되어있고 &lt;em&gt;weight&lt;/em&gt; 가 모두 다르다 하자. 그럼 &lt;em&gt;MST&lt;/em&gt; 는 하나만 존재할 것이다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;em&gt;cut, crossing edge&lt;/em&gt; 용어 정리를 하면&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Cut:&lt;/strong&gt; A cut is a graph is a partition of its vertices into two (nonempty) sets&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Crossing edge:&lt;/strong&gt; A crossing edge connects a vertex in one set with a vertex in the other&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그러면, 이런 &lt;em&gt;cut property&lt;/em&gt; 가 존재한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given any &lt;strong&gt;cut&lt;/strong&gt;, the crossing edge of min weight is in the MST&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;증명은 &lt;em&gt;min-weight crossing edge&lt;/em&gt; &lt;code&gt;e&lt;/code&gt; 가 &lt;em&gt;MST&lt;/em&gt; 내에 없다고 하자. &lt;em&gt;MST&lt;/em&gt; 는 연결되야 하므로 다른 &lt;em&gt;crossing edge&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; 가 대신 사용될 것이다.&lt;/p&gt;

&lt;p&gt;(1) 다른 &lt;em&gt;crossing edge&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; 가 없으면 &lt;em&gt;connected&lt;/em&gt; 가 아니므로 &lt;em&gt;MST&lt;/em&gt; 가 아니다.&lt;br /&gt;
(2) 만약 &lt;code&gt;f&lt;/code&gt; 가 있어서 &lt;code&gt;f&lt;/code&gt; 를 대신 사용하는 &lt;em&gt;MST&lt;/em&gt; 에 &lt;code&gt;e&lt;/code&gt; 를 추가하면 사이클이 생긴다. 이 때 &lt;code&gt;f&lt;/code&gt; 를 제거하면 &lt;em&gt;weight&lt;/em&gt; 가 더 짧다. 따라서 &lt;code&gt;f&lt;/code&gt; 가 포함되면 &lt;em&gt;MST&lt;/em&gt; 가 아니다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;min-weight crossing edge&lt;/em&gt; 가 &lt;em&gt;MST&lt;/em&gt; 내에 존재한다. 이 사실을 이용하면 &lt;em&gt;MST&lt;/em&gt; 를 찾는 &lt;em&gt;greedy algorithm&lt;/em&gt; 을 만들 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- Start with all edges colored gray
- Find cut with no black corssing edges; 
   color its min-weight edge black
- Repeat until V - 1 edges are colored black
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;즉 어떤 &lt;em&gt;cut&lt;/em&gt; 에 대해서 &lt;em&gt;min-weight crossing edge&lt;/em&gt; 가 &lt;em&gt;MST&lt;/em&gt; 에 포함되므로, 이미 찾은 &lt;em&gt;MST edge&lt;/em&gt; 를 포함하지 않는 &lt;em&gt;cut&lt;/em&gt; 을 찾아, &lt;em&gt;min-weight crossing edge&lt;/em&gt; 을 추가해 나가면 된다.&lt;/p&gt;

&lt;h4 id=&#34;correcteness&#34;&gt;Correcteness&lt;/h4&gt;

&lt;p&gt;(1) Any edge colored black is in the MST (vis cut property)&lt;br /&gt;
(2) Fewer than &lt;code&gt;V - 1&lt;/code&gt; black edges =&amp;gt; cut with no black crossing edges&lt;/p&gt;

&lt;p&gt;모든 &lt;em&gt;MST&lt;/em&gt; 는 &lt;code&gt;V - 1&lt;/code&gt; 개의 &lt;em&gt;edge&lt;/em&gt; 로 구성된다. 따라서 &lt;code&gt;V - 1&lt;/code&gt; 개의 &lt;em&gt;black edge&lt;/em&gt;, 즉 &lt;em&gt;MST&lt;/em&gt; 의 원소를 찾아내면 된다.&lt;/p&gt;

&lt;h3 id=&#34;edge-weighted-graph-api&#34;&gt;Edge-Weighted Graph API&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Edge implements Comparable&amp;lt;Edge&amp;gt; {
  Edge(int v, int w, double weight)
  int either()
  int other(int v)
  int compareTo(Edge that)
  ...
}

// allow self-loops and parallel edges
public class EdgeWeightedGraph {
  EdgeWeightedGraph(int V) // V vertices
  void addEdge(Edge e)
  Iterable&amp;lt;Edge&amp;gt; adj(int v) // edges incident to v
  Iterable&amp;lt;Edge&amp;gt; edges() // all edges
  Int V() // # of vertices
  int E() // # of edges
}

public class MST {
  MST(EdgeWeigtedGraph G)
  Iterable&amp;lt;Edge&amp;gt; edges()
  double totalWeight()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;removing-assumptions&#34;&gt;Removing assumptions&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;What if edge weights are not all distinct?&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Greedy MST algorithm still correct if equal weights are present. (our correctness proof fails, but that can be fixed)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;What if graph is not connected?&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute MS forest = MST of each components&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;kruskal-s-algorithm&#34;&gt;Kruskal&amp;rsquo;s Algorithm&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;- Sort edges in ascending order of weight. 
- Add next edge to tree T 
  unless doing so would create a cycle 
  (until V - 1 edges added) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;kruskal&amp;rsquo;s algorithm&lt;/em&gt; 은 &lt;em&gt;greedy MST&lt;/em&gt; 의 일종이라 볼 수 있다.&lt;/p&gt;

&lt;p&gt;선택된 &lt;em&gt;edge&lt;/em&gt; &lt;code&gt;e = v &amp;lt;-&amp;gt; w&lt;/code&gt; 라 하고 이것을 &lt;em&gt;crossing edge&lt;/em&gt; (&lt;em&gt;cut&lt;/em&gt; 이라 볼 수 있다), 하면&lt;/p&gt;

&lt;p&gt;&lt;em&gt;black edge&lt;/em&gt; 간 &lt;em&gt;no cycle&lt;/em&gt; 인 &lt;code&gt;e&lt;/code&gt; 를 선택한 것이므로 &lt;code&gt;v &amp;lt;-&amp;gt; w&lt;/code&gt; 사이엔 &lt;em&gt;black crossing edge&lt;/em&gt; 가 없다.&lt;/p&gt;

&lt;p&gt;게다가 선택하는 &lt;em&gt;crossing edge&lt;/em&gt; 는 가장 작은 &lt;em&gt;weight&lt;/em&gt; 를 가진다. 이 전에 이미 더 작은 &lt;em&gt;weight&lt;/em&gt; 의 &lt;em&gt;edge&lt;/em&gt; 를 모두 선택했기 때문이다.&lt;/p&gt;

&lt;p&gt;따라서 크루스칼 알고리즘은 &lt;em&gt;greedy MST&lt;/em&gt; 의 일종이다.&lt;/p&gt;

&lt;h4 id=&#34;cycle-check&#34;&gt;Cycle Check&lt;/h4&gt;

&lt;p&gt;어떻게 &lt;em&gt;Cycle check&lt;/em&gt; 를 할까? 한 가지 방법은 &lt;em&gt;edge &lt;code&gt;e = v - w&lt;/code&gt;&lt;/em&gt; 에 대해 &lt;code&gt;v - w&lt;/code&gt; 가 연결되어있는지 &lt;em&gt;DFS&lt;/em&gt; 를 돌리면 된다. 그러면 &lt;code&gt;O(V)&lt;/code&gt; 로 사이클을 검사할 수 있다.&lt;/p&gt;

&lt;p&gt;단순히 연결되어있는지만 검사하는 것이므로 &lt;em&gt;union find&lt;/em&gt; 를 쓰면 &lt;code&gt;O(log* V)&lt;/code&gt; 로도 가능하다. &lt;a href=&#34;http://1ambda.github.io/union-find-algorithms-week-1/&#34;&gt;Union-find&lt;/a&gt; 를 참고하자.&lt;/p&gt;

&lt;h4 id=&#34;kruskal-mst-implementation&#34;&gt;Kruskal MST Implementation&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;EdgeWeightedGraph G;
int V = G.V()
UF uf = new UF(V);

Queue&amp;lt;Edge&amp;gt; mst = new Queue&amp;lt;Edge&amp;gt;();
MinPQ&amp;lt;Edge&amp;gt; pq = new MinQP&amp;lt;Edge&amp;gt;();

for (Edge e : G.edges())
  pq.enqueue(e);
  
while (!pq.isEmpty() &amp;amp;&amp;amp; mst.size() &amp;lt; V - 1) {
  Edge e = pq.dequeue();
  int v = e.either();
  int w = e.other(v);
  
  if (!uf.connected(v, w)) {
    uf.union(v, w);
    mst.enqueue(e);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;running time&lt;/em&gt; 은 &lt;code&gt;E log E&lt;/code&gt; 다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;build &lt;code&gt;pq&lt;/code&gt;: &lt;code&gt;1 * E&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;dequeue: &lt;code&gt;E * log E&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;union: &lt;code&gt;V * log* V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;connected: &lt;code&gt;E * log* V&lt;/code&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;prim-s-algorithm&#34;&gt;Prim&amp;rsquo;s Algorithm&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;- start with vertex 0 and greedily grow tree T
- add to T the min weight edge with exactly one endpoint in T
- repate until V - 1 edge
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;correctness&#34;&gt;Correctness&lt;/h4&gt;

&lt;p&gt;마찬가지로 &lt;em&gt;prim&amp;rsquo;s algorithm&lt;/em&gt; 도 &lt;em&gt;greedy MST&lt;/em&gt; 의 일종이다.&lt;/p&gt;

&lt;p&gt;방문한 노드와 방문하지 않은 노드를 &lt;em&gt;cut&lt;/em&gt; 해 거기서 &lt;em&gt;min-weight edge&lt;/em&gt; 를 선택한다. 따라서 &lt;em&gt;cut&lt;/em&gt; 자체가 방문하지 않은 노드와 방문한 노드 두 집합을 만드므로 &lt;em&gt;crossing edge&lt;/em&gt; 중에는 &lt;em&gt;black edge&lt;/em&gt; 가 없다.&lt;/p&gt;

&lt;h4 id=&#34;prim-mst-implementation&#34;&gt;Prim MST Implementation&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;lazy implementation&lt;/em&gt; 으로 현재 선택할 수 있는 &lt;em&gt;edge&lt;/em&gt; 를 &lt;em&gt;weight&lt;/em&gt; 기준으로 &lt;em&gt;priority queue&lt;/em&gt; 에 유지하는 방법이 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;queue&lt;/em&gt; 에 있는 &lt;em&gt;edge&lt;/em&gt; &lt;code&gt;e = (v, w)&lt;/code&gt; 를 꺼낸 뒤&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;v, w&lt;/code&gt; 둘 다 이미 방문했으면 패스하고,&lt;br /&gt;
(2) &lt;code&gt;v&lt;/code&gt; 혹은 &lt;code&gt;w&lt;/code&gt; 둘 중 하나만 방문했을 경우에만 &lt;code&gt;w or v&lt;/code&gt; 의 &lt;em&gt;edge&lt;/em&gt; 를 추가하고, &lt;code&gt;w or w&lt;/code&gt; 를 방문 처리 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// lazy Prim MST

boolean[] marked // MST vertices
Queue&amp;lt;Edge&amp;gt; mst = new Queue&amp;lt;Edge&amp;gt;();
MinPQ&amp;lt;Edge&amp;gt; pq = new MinPQ&amp;lt;Edge&amp;gt;();
WeightedGraph G;

visit(G, 0);

while (!pq.isEmpty()) {
  Edge e = pq.dequeue();
  int v = e.either();
  int w = e.other(v);
  
  if (marked[v] &amp;amp;&amp;amp; marked[w]) continue;
  
  mst.enqueue(e);
  
  // add v or w
  if (!marked[v]) visit(G, v);
  if (!marked[w]) visit(G, w);
}

void visit(int v) {
  marked[v] = true;
  for (Edge g : G.adj(v)) {
    if (!marked[e.other(v)]) pq.insert(e);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;running time&lt;/em&gt; 은 &lt;code&gt;O(E log E)&lt;/code&gt; 다.&lt;/p&gt;

&lt;p&gt;좀 더 나은 알고리즘은 &lt;em&gt;MST&lt;/em&gt; 에 &lt;em&gt;edge&lt;/em&gt; &lt;code&gt;e = (v, w)&lt;/code&gt; 를 추가할때, 이미 방문한 &lt;code&gt;w&lt;/code&gt; 와 방문하지 않은 &lt;code&gt;v&lt;/code&gt; 에 대해&lt;/p&gt;

&lt;p&gt;&lt;code&gt;v&lt;/code&gt; 에서 갈 수 있는 모든 &lt;em&gt;edge&lt;/em&gt; &lt;code&gt;e = (v, x)&lt;/code&gt; 을 생각해 보면,&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;x&lt;/code&gt; 가 이미 방문한 &lt;em&gt;vertex&lt;/em&gt; 면 패스&lt;br /&gt;
(2) &lt;em&gt;queue&lt;/em&gt; 에 &lt;code&gt;(k, x)&lt;/code&gt; 가 없으면 추가 (&lt;code&gt;k&lt;/code&gt; 는 이미 방문한 &lt;em&gt;vertex&lt;/em&gt;)&lt;br /&gt;
(3) &lt;code&gt;x&lt;/code&gt; 까지의 거리가, &lt;code&gt;e = (v, x)&lt;/code&gt; 가 더 짧으면 업데이트 (&lt;em&gt;decreaseKey operation&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;decreaseKey&lt;/code&gt; 연산을 빠르게 구현하기 위해 &lt;em&gt;indexed priority queue&lt;/em&gt; 를 이용할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void decreaseKey(int i, Key key)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;전체 러닝타임은&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;V&lt;/code&gt; &lt;em&gt;insert&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V&lt;/code&gt; &lt;em&gt;delete min&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;E&lt;/code&gt; &lt;em&gt;decrease key&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인데, &lt;em&gt;Priority Queue&lt;/em&gt; 구현하는데 어떤 자료구조를 사용하느냐에 따라 각 연산의 시간이 달라진다.&lt;/p&gt;

&lt;p&gt;(1) Array implementation optimal for dnse graph&lt;/p&gt;

&lt;p&gt;O(&lt;code&gt;V^2&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;(2) Binary heap much faser for sparse graphs&lt;/p&gt;

&lt;p&gt;O(&lt;code&gt;E log V&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;(3) 4-way heap worth the trouble in performance-critical situations&lt;/p&gt;

&lt;p&gt;O(&lt;code&gt;E log_(1/V) V&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;(4) Fibonacchi heap best in theor, but not worth implementing&lt;/p&gt;

&lt;p&gt;O(&lt;code&gt;E + V log V&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&#34;mst-context&#34;&gt;MST Context&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;linear time MST&lt;/em&gt; 알고리즘이 있을까? 1995년에 &lt;em&gt;linear time randomized MST&lt;/em&gt; 가 발견 되었지만 &lt;em&gt;deterministic&lt;/em&gt; 알고리즘은 여전히 연구중이다.&lt;/p&gt;

&lt;h3 id=&#34;shortest-paths-api&#34;&gt;Shortest Paths API&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Directed Edge {
  
  DirectedEdge(int v, int w, deouble weight)
  int from()
  int to()
  double weight()
}

// allow self-loop, parallel
public class EdgeWeightedDigraph {

  EdgeWeightedDigraph(int V)
  void addEdge(DirectedEdge e)
  Iterable&amp;lt;DirectedEdge&amp;gt; adj(int v)
  int V() // # of vertices
}

// shortest path
public class SP {

  SP(EdgeWeightedDigraph G, int s)
  double distTo(int v)
  Iterable &amp;lt;DirectedEdge&amp;gt; pathTo(int v)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;shortest-path-properties&#34;&gt;Shortest Path Properties&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;directed, weighted graph&lt;/em&gt; 에서 &lt;em&gt;shortest path tree, SPT&lt;/em&gt; 가 존재하는데, 이는 &lt;em&gt;cycle&lt;/em&gt; 이면 &lt;em&gt;shortest&lt;/em&gt; 가 될 수 없기 때문이다.&lt;/p&gt;

&lt;p&gt;위에서 본 &lt;code&gt;pathTo&lt;/code&gt; 함수는 이렇게 구현할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// edgeTo[v] is last edge on shortest path from s to v
public Iterable&amp;lt;DirectedEdge&amp;gt; pathTo(int v) {
  Stack&amp;lt;DirectedEdge&amp;gt; path = new Stack&amp;lt;DirectedEdge&amp;gt;();
  for (DirectedEdge e = edgeTo(v); e != null; e = edgeTo(e.from())
    path.push(e);
    
  return path;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;edge-relaxation&#34;&gt;Edge relaxation&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;relax edge &lt;code&gt;e = v -&amp;gt; w&lt;/code&gt;&lt;/em&gt;,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;distTo[v]&lt;/code&gt; is length of shortest known path from &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;distTo[w]&lt;/code&gt; is length of shortest known path from &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edgeTo[w]&lt;/code&gt; is last edge on shortest known path from &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;w&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 만약 &lt;code&gt;e = v -&amp;gt; w&lt;/code&gt; 가 &lt;code&gt;w&lt;/code&gt; 로의 더 짧은 거리라면, &lt;code&gt;distTo[w]&lt;/code&gt; 와 &lt;code&gt;edgeTo[w]&lt;/code&gt; 를 업데이트하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.csupomona.edu/~ftang/courses/CS241/notes/images/graph/relax1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://faculty.ycp.edu/~dbabcock/PastCourses/cs360/lectures/images/lecture21/relaxation.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.csupomona.edu/~ftang&#34;&gt;http://www.csupomona.edu/~ftang&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void relax(DirectedEdge e) {
  int v = e.from();
  int w = e.to();
  
  if (distTo(w) &amp;gt; distTo(v) + e.weight()) {
    distTo[w] = distTo[v] + e.weight();
    edgeTo[w] = e;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;shortest-paths-optimality-conditions&#34;&gt;Shortest-paths optimality conditions&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Let &lt;code&gt;G&lt;/code&gt; be an edge-weighted digraph, then &lt;code&gt;distTo[]&lt;/code&gt; are the shortest path distance from s iff:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;distTo[s]&lt;/code&gt; = 0&lt;/li&gt;
&lt;li&gt;For each vertex &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;distTo[v]&lt;/code&gt; is the length of some path from &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For each edge &lt;code&gt;e = v -&amp;gt; w&lt;/code&gt;, &lt;code&gt;distTo[w] &amp;lt;= distTo[v] + e.weight()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;necessary condition&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약 어떤 &lt;code&gt;e = v -&amp;gt; w&lt;/code&gt;에 대해 &lt;code&gt;distTo[w] &amp;gt; distTo[v] + e.weight()&lt;/code&gt; 이면, &lt;code&gt;e&lt;/code&gt; 를 이용한 &lt;code&gt;w&lt;/code&gt; 까지의 거리가 &lt;code&gt;distTo[w]&lt;/code&gt; 보다 더 짧다. 그러면 &lt;code&gt;distTo[w]&lt;/code&gt; 는 &lt;em&gt;shortest path&lt;/em&gt; 가 아니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sufficient condition&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Suppose &lt;code&gt;s = v0 -&amp;gt; v1, ... -&amp;gt; vk = w&lt;/code&gt; is a shortest path from &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;distTo[v1] &amp;lt;= distTo[v0] + e1.weight();
...
distTo[vk] &amp;lt;= distTo[v_k-1] + ek.weight(); 

// e_i is, i th edge on shortest path from s to w
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;distTo[v] = 0&lt;/code&gt; 이라 하면&lt;/p&gt;

&lt;p&gt;&lt;code&gt;distTo[w] &amp;lt;= e1.weight + ..., + ek.weight()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이 때 우변이 &lt;em&gt;shortest path&lt;/em&gt; 위에 있는 &lt;em&gt;edge&lt;/em&gt; 의 &lt;em&gt;weight&lt;/em&gt; 값이므로, &lt;code&gt;distTo[w]&lt;/code&gt; 는 &lt;code&gt;w&lt;/code&gt; 까지의 &lt;em&gt;shortest path&lt;/em&gt; 다.&lt;/p&gt;

&lt;p&gt;(여기서는 필요충분조건 &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; 를 증명하기 위해 &lt;code&gt;p -&amp;gt; q&lt;/code&gt;, &lt;code&gt;q -&amp;gt; p&lt;/code&gt; 를 증명했다.)&lt;/p&gt;

&lt;h4 id=&#34;generic-shortest-paths-algorithm&#34;&gt;Generic Shortest-paths Algorithm&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;initialize distTo[s] = 0 and distTo[v] = infinity for all other vertices

Repeat until optimality conditions are satisfied,
  Relax any edge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떤 &lt;em&gt;edge&lt;/em&gt; 를 고를까 하는 문제로 발전할 수 있다.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;Dijkstra&amp;rsquo;s algorithm&lt;/em&gt;: &lt;strong&gt;non-negative weights&lt;/strong&gt;&lt;br /&gt;
(2) &lt;em&gt;Topological sort&lt;/em&gt;: &lt;strong&gt;no directed cycles&lt;/strong&gt;&lt;br /&gt;
(3) &lt;em&gt;Bllman-Ford algorithm&lt;/em&gt;: &lt;strong&gt;no negative cycles&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;dijkstra-s-algorithm&#34;&gt;Dijkstra&amp;rsquo;s Algorithm&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;- Consider vertices in increasing order of dinstance from s
  (non-tree vertex with the lowest distTo[] value)
  
- Add vertex to tree and relax all edges pointing from that vertex
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;correctness-1&#34;&gt;Correctness&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Dijkstra&amp;rsquo;s algorithm computes a SPT in any edge-weighted digraph with non-negative weights&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;모든 &lt;code&gt;e = v -&amp;gt; w&lt;/code&gt; 는 단 한번씩만 &lt;em&gt;relaxed&lt;/em&gt; 되기 때문에 알고리즘은 언젠간 종료된다. (&lt;code&gt;v&lt;/code&gt; 가 &lt;code&gt;T&lt;/code&gt; 에 추가되었을 때)&lt;/p&gt;

&lt;p&gt;그리고 이 과정에서 &lt;code&gt;distTo[w] &amp;lt;= distTo[v] + e.weight()&lt;/code&gt; 가 유지된다. 왜냐하면 &lt;code&gt;distTo[w]&lt;/code&gt; 는 줄어들기만 하고, &lt;em&gt;weight&lt;/em&gt; 가 음수인 &lt;em&gt;edge&lt;/em&gt; 가 없기 때문에 &lt;code&gt;distTo[v]&lt;/code&gt; 는 변함이 없기 때문이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;DirectedEdge[] edgeTo;
double[] distTo;
IndexMinPQ&amp;lt;Double&amp;gt; pq;

void DijkstraSP(EdgeWeightedDigraph G, int s) {
  int V = G.V();
  edgeTo = new DirectedEdge[V];
  distTo = new double[V];
  pq = new IndexMinPQ&amp;lt;Double&amp;gt;(V);
  
  for(int v = 0; v &amp;lt; V; v++) {
    distTo[v] = Double.POSITIVE_INFINITY;
  }
  
  distTo[s] = 0.0;
  pq.insert(s, 0.0);
  
  while (!ps.isEmpty()) {
    int v = pq.dequeue();
    for(DirectedEdge e: G.adj(v))
      relax(e);
  }
}

void relax(DirectedEdge e) {
  int v = e.from();
  int w = e.to();
  
  if (distTo[w] &amp;gt; distTo[v] + e.weight()) {
    distTo[w] = distTo[v] + e.weight();
    edgeTo[w] = e;
    
    if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
    else pq.insert(w, distTo[w]);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;프림 알고리즘과 마찬가지로&lt;/p&gt;

&lt;p&gt;&lt;code&gt;T(n) = V insert + V delete-min + E decrease key&lt;/code&gt; 인데, 이 연산들은 &lt;em&gt;Priority Queue&lt;/em&gt; 구현에 따라 다를 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;undordered array&lt;/em&gt; 라면 &lt;code&gt;V^2&lt;/code&gt;, &lt;em&gt;binary heap&lt;/em&gt; 이라면 &lt;code&gt;E log V&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;dense graph&lt;/em&gt; 에서는 &lt;em&gt;array&lt;/em&gt; 를, &lt;em&gt;sparse graph&lt;/em&gt; 라면 &lt;em&gt;binary heap&lt;/em&gt; 이 낫다.&lt;/p&gt;

&lt;h4 id=&#34;dijkstra-and-prim&#34;&gt;Dijkstra and Prim&lt;/h4&gt;

&lt;p&gt;둘 다 &lt;em&gt;spanning tree&lt;/em&gt; 를 만들어 낸다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;다익스트라는 &lt;em&gt;directed path&lt;/em&gt; 에서 &lt;em&gt;source&lt;/em&gt; 에서 가장 가까운 &lt;em&gt;vertex&lt;/em&gt; 를 선택한다면,&lt;/li&gt;
&lt;li&gt;프림 알고리즘은 &lt;em&gt;undirected edge&lt;/em&gt; 내 에서 &lt;em&gt;tree&lt;/em&gt; 에서 가장 가까운 &lt;em&gt;vertex&lt;/em&gt; 를 선택한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;edge-weighted-dags&#34;&gt;Edge-Weighted DAGs&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;cycle&lt;/em&gt; 이 없는 그래프는 &lt;em&gt;shortest path&lt;/em&gt; 를 찾기 더 쉽다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;toplogical order&lt;/em&gt; 순서로 &lt;em&gt;relaxing&lt;/em&gt; 해 가면 된다. 어차피 방문 자체는 &lt;em&gt;topological order&lt;/em&gt; 로 해야만 모든 &lt;em&gt;vertex&lt;/em&gt; 를 방문할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;이 알고리즘에서 재미난 점은 음수 &lt;em&gt;weight&lt;/em&gt; 가 있던 말던 상관이 없다는 것이다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Topological sort algorithm computes SPT in &lt;strong&gt;any&lt;/strong&gt; edge-weighted DAG in time proprotional to &lt;code&gt;E + V&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다익스트라와 마찬가지로 모든 &lt;em&gt;edge &lt;code&gt;e = v -&amp;gt; w&lt;/code&gt;&lt;/em&gt; 는 단 한번만 &lt;em&gt;relaxed&lt;/em&gt; 되고, 이 과정에서 &lt;code&gt;distTo[w] &amp;lt;= distTo[v] + e.weight()&lt;/code&gt; 다.&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;distTo[w]&lt;/code&gt; 는 줄어들기만 하고,&lt;br /&gt;
(2) &lt;em&gt;topological order&lt;/em&gt; 이기 때문에 한번 방문된 &lt;code&gt;v&lt;/code&gt; 에 대해 이후의 &lt;em&gt;vertex&lt;/em&gt; 에서 &lt;code&gt;v&lt;/code&gt; 로 갈 수 없다. 있다면 &lt;em&gt;cycle&lt;/em&gt; 이고 그럼 &lt;em&gt;toplogical order&lt;/em&gt; 가 안된다. 따라서 &lt;code&gt;distTo[v]&lt;/code&gt; 는 변하지 않는다. 따라서 &lt;em&gt;weight&lt;/em&gt; 가 음수든 양수든 상관이 없다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;DirectedEdge[] edgeTo;
double[] distTo;

public AcyclicSP(EdgeWeightedDigraph G, int s) {
  int V = G.V();
  edgeTo = new DirectedEdge[V];
  distTo = new double[V];
  
  for(int v = 0; v &amp;lt; V; v++) {
    distTo[v] = Double.POSITIVE_INFINITY;
  }
  
  distTo[s] = 0.0;
  
  Topological t = new Topological(G);
  
  for (int v : t.order()) {
    for (DirectedEdge e : G.adj(v)) {
      relax(e);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;응용으로 &lt;em&gt;seam carving&lt;/em&gt; 이 있다. 수직이나 수평으로 &lt;em&gt;shortest path&lt;/em&gt; 를 찾아서 제거하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rahuldotgarg.appspot.com/data/SeamCarvingWeb/evaluation_files/image002.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://rahuldotgarg.appspot.com&#34;&gt;http://rahuldotgarg.appspot.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;longest path&lt;/em&gt; 를 찾는법은 모든 &lt;em&gt;weight&lt;/em&gt; 를 &lt;em&gt;negate&lt;/em&gt; 하고, 찾고, 다시 결과의 &lt;em&gt;weight&lt;/em&gt; 에 마이너스를 붙이면 된다. 이게 가능한 이유는 &lt;em&gt;no cycle&lt;/em&gt; 이기 때문에 &lt;em&gt;weight&lt;/em&gt; 가 음수든, 양수든 상관이 없기 때문이다.&lt;/p&gt;

&lt;p&gt;응용해서 &lt;em&gt;Critical path method, CPM&lt;/em&gt; 에 활용할 수 있다.&lt;/p&gt;

&lt;p&gt;작업간 의존관계가 있으므로 이를 이용해서 &lt;em&gt;DAG&lt;/em&gt; 를 그리면 된다. 각 &lt;em&gt;job&lt;/em&gt; 당 &lt;em&gt;start vertex, finish vertex&lt;/em&gt; 가 되며, 그 &lt;em&gt;weight&lt;/em&gt; 는 &lt;em&gt;duration&lt;/em&gt; 으로 하고 한 작업과 다음 작업의 &lt;em&gt;weight&lt;/em&gt; 는 &lt;code&gt;0&lt;/code&gt; 으로 했을때의 &lt;em&gt;longest path&lt;/em&gt; 를 찾으면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://algs4.cs.princeton.edu/44sp/images/scheduling-critical-path.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://algs4.cs.princeton.edu/44sp/&#34;&gt;http://algs4.cs.princeton.edu/44sp/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;h3 id=&#34;negative-weights&#34;&gt;Negative Weights&lt;/h3&gt;

&lt;p&gt;다익스트라 알고리즘은 &lt;em&gt;negative weight&lt;/em&gt; 에 대해서 작동하지 않는다. 모든 &lt;em&gt;weight&lt;/em&gt; 에 일정 수 &lt;code&gt;n&lt;/code&gt; 을 더해 모두 양수로 만들어도 똑같다. 심지어 이 경우는  &lt;em&gt;shortest path&lt;/em&gt; 자체가 바뀐다. 따라서 다른 알고리즘이 필요하다.&lt;/p&gt;

&lt;p&gt;진도를 빼기 전에 용어를 좀 정의하고 가면&lt;/p&gt;

&lt;p&gt;&lt;em&gt;negative cycle&lt;/em&gt; 은, &lt;em&gt;directed cycle&lt;/em&gt; 내의 모든 &lt;em&gt;weight&lt;/em&gt; 를 더했을 때 음수인 경우를 말한다. 이 경우 &lt;em&gt;SPT&lt;/em&gt; 는 없다. 이는 쉽게 보일 수 있는데&lt;/p&gt;

&lt;p&gt;&lt;em&gt;negative cycle&lt;/em&gt; 이 존재하면 한번 이 사이클을 돌면, 전체 값이 음수이므로 어느 경로를 택해도 이전보다 더 짧아진다.&lt;/p&gt;

&lt;p&gt;따라서 이 사이클을 돌면 내부 &lt;em&gt;vertex&lt;/em&gt; 를 무한정 &lt;em&gt;relaxing&lt;/em&gt; 할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;bellman-ford-algorihm&#34;&gt;Bellman-Ford Algorihm&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Bellman-Ford Algorihm&lt;/em&gt; 은 &lt;em&gt;negative cycle&lt;/em&gt; 이 있는지 검사할 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Initialize &lt;code&gt;distTo[s] = 0&lt;/code&gt; and &lt;code&gt;distTo[v] = inf&lt;/code&gt;
for all other vertice&lt;/li&gt;
&lt;li&gt;Repeat V times, relax each Edge&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; G.V(); i++) 
  for(int v = 0; v &amp;lt; G.V(); v++)
    for(DirectedEdge e: G.adj(v)) // pass i
      relax(e);	 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;벨만 포드 알고리즘은 &lt;em&gt;negative cycle&lt;/em&gt; 이 없을때 &lt;code&gt;O(E * V)&lt;/code&gt; 로 &lt;em&gt;shortest path&lt;/em&gt; 를 찾아낸다.&lt;/p&gt;

&lt;p&gt;증명은 &lt;a href=&#34;http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm#Proof_of_correctness&#34;&gt;여기&lt;/a&gt;를 참조하도록 하자.&lt;/p&gt;

&lt;p&gt;알고리즘을 잘 보면, 한 &lt;em&gt;pass&lt;/em&gt; 에서 &lt;code&gt;distTo[v]&lt;/code&gt; 가 변하지 않으면 그 이후에도 안 변한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If &lt;code&gt;distTo[v]&lt;/code&gt; does not change during pass &lt;code&gt;i&lt;/code&gt;, no need to relax any edge pointing from &lt;code&gt;v&lt;/code&gt; in pass &lt;code&gt;i + 1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 &lt;code&gt;distTo[]&lt;/code&gt; 가 변화한 &lt;code&gt;v&lt;/code&gt; 의 리스트를 유지해서, 이것 대상으로 &lt;em&gt;relax&lt;/em&gt; 하면 성능을 더 개선할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;finding-a-negative-cycle&#34;&gt;Finding a negative cycle&lt;/h4&gt;

&lt;p&gt;벨만 포드 알고리즘은 &lt;em&gt;negative cycle&lt;/em&gt; 을 찾아내는데 사용할 수도 있다. &lt;em&gt;negative cycle&lt;/em&gt; 이 있을 경우 무한히 &lt;em&gt;relax&lt;/em&gt; 를 해 내기 때문이다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;V - 1&lt;/code&gt; 까지 진행 한 후 &lt;code&gt;V&lt;/code&gt; 번째에서 어느 &lt;em&gt;vertex&lt;/em&gt; &lt;code&gt;v&lt;/code&gt; 라도 업데이트 된다면, &lt;em&gt;negative&lt;/em&gt; 사이클이 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;negative cycle&lt;/em&gt; 은 &lt;em&gt;arbitrage detection&lt;/em&gt; 에 사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;shortest-path-cost-summary&#34;&gt;Shortest Path Cost Summary&lt;/h3&gt;

&lt;p&gt;(1) &lt;strong&gt;Topological Sort:&lt;/strong&gt; No directed cycles&lt;/p&gt;

&lt;p&gt;다익스트보다 더 빠르고, &lt;em&gt;negative weight&lt;/em&gt; 도 문제 없다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;typical: &lt;code&gt;E + V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;worst: &lt;code&gt;E + V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;extra space: &lt;code&gt;V&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) &lt;strong&gt;Dijkstra(binary heap):&lt;/strong&gt; No negative weights&lt;/p&gt;

&lt;p&gt;거의 &lt;em&gt;linear time&lt;/em&gt; 이다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;typical: &lt;code&gt;E logV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;worst: &lt;code&gt;E logV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;extra space: &lt;code&gt;V&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(3) &lt;strong&gt;Bellman Ford:&lt;/strong&gt; No negative cycles&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;typical: &lt;code&gt;E * V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;worst: &lt;code&gt;E * V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;extra space: &lt;code&gt;V&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(4) &lt;strong&gt;Bellman Ford(queue):&lt;/strong&gt; No directed Cycles&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;typical: &lt;code&gt;E + V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;worst: &lt;code&gt;E * V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;extra space: &lt;code&gt;V&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;SPT&lt;/em&gt; 를 정리하면&lt;/p&gt;

&lt;p&gt;&lt;em&gt;directed cycle&lt;/em&gt; 은 문제를 더 어렵게 만들고,
&lt;em&gt;negative weight&lt;/em&gt; 도 문제를 더 어렵게 만들고,
&lt;em&gt;negative cycles&lt;/em&gt; 는 문제를 풀 수 없게 만든다. (내가 배운 한도 내에서는)&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;em&gt;Algorithms: Part 2&lt;/em&gt; by &lt;strong&gt;Robert Sedgewick&lt;/strong&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://en.wikipedia.org/wiki/Bipartite_graph&#34;&gt;Wikipedia: Bipartite Graph&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://www.biodatamining.org/content/4/1/10/figure/F3?highres=y&#34;&gt;http://www.biodatamining.org/&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://ko.wikipedia.org/wiki/%ED%8F%89%EB%A9%B4_%EA%B7%B8%EB%9E%98%ED%94%84&#34;&gt;Wikipedia: 평면그래프&lt;/a&gt;&lt;br /&gt;
(5) &lt;a href=&#34;http://www.csupomona.edu/~ftang&#34;&gt;CS241 Lecture Notes: Graph Algorithms&lt;/a&gt;&lt;br /&gt;
(6) &lt;a href=&#34;http://rahuldotgarg.appspot.com/data/SeamCarvingWeb/evaluation.htm&#34;&gt;Seam Carving for Content-Aware Image Resizing&lt;/a&gt;&lt;br /&gt;
(7) &lt;a href=&#34;http://algs4.cs.princeton.edu/44sp/&#34;&gt;Algorithms: Shortest Path&lt;/a&gt;&lt;br /&gt;
(8) &lt;a href=&#34;http://stackoverflow.com/questions/19760077/what-does-bellman-ford-algorithm-detects-negative-weight-or-negative-cycle&#34;&gt;What does bellman ford algorithm&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Algorithm: Radix Sort, Suffix Sort</title>
      <link>https://1ambda.github.io/91/algorithm/algorithm-part2-2/</link>
      <pubDate>Sat, 25 Jun 2016 13:01:17 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/algorithm-part2-2/</guid>
      <description>

&lt;h3 id=&#34;strings-in-java&#34;&gt;Strings in Java&lt;/h3&gt;

&lt;p&gt;문자열은 &lt;em&gt;Character (문자)&lt;/em&gt; 의 나열이다. C 에서 하나의 캐릭터는 &lt;em&gt;8-bit&lt;/em&gt; 인데, 자바의 경우에는 &lt;em&gt;16-bit unsigned integer&lt;/em&gt; 로 표시한다.&lt;/p&gt;

&lt;p&gt;스트링의 길이를 얻기 위해 &lt;code&gt;length&lt;/code&gt;, 인덱싱 하기 위해 &lt;code&gt;charAt&lt;/code&gt;, 서브스트링을 얻기 위해 &lt;code&gt;substring&lt;/code&gt; 의 메소드를 지원한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class String implements Comparable&amp;lt;String&amp;gt; {

  private char values;
  private int offset; // index of first char in array
  private int length;
  private int hash; // cache of hashCode()
  
  ...
  
  public char charAt(int i) {
    return value[i + offset];
  }
  
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바에서 문자열은 &lt;em&gt;immutable&lt;/em&gt; 이다. 더 정확히는 &lt;em&gt;immutable&lt;/em&gt; &lt;code&gt;char []&lt;/code&gt; &lt;em&gt;array&lt;/em&gt; 라 보면 된다. 길이 정보를 가지고 있고 배열이기 때문에 &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;charAt&lt;/code&gt;, &lt;code&gt;substring&lt;/code&gt; 등의 연산은 &lt;code&gt;O(1)&lt;/code&gt; 임을 보장한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;concat&lt;/code&gt; 의 경우에는 새로운 문자열을 만들기 때문에 &lt;code&gt;O(N)&lt;/code&gt; 이다. 메모리는 길이 &lt;code&gt;N&lt;/code&gt; 의 문자열에 대해 &lt;code&gt;40 + 2N&lt;/code&gt; 을 필요로 한다. 메모리를 아껴야 한다면 &lt;em&gt;byte, char&lt;/em&gt; 을 이용할 수 있겠지만 여러 편리한 스트링의 메소드를 사용하지 못한다.&lt;/p&gt;

&lt;h3 id=&#34;stringbuilder-stringbuffer&#34;&gt;StringBuilder, StringBuffer&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;StringBuilder&lt;/code&gt; 는 &lt;em&gt;mutable&lt;/em&gt; 이다. &lt;code&gt;char []&lt;/code&gt; 배열을 &lt;em&gt;resizing&lt;/em&gt; 하기 때문에&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;substirng&lt;/code&gt; 의 경우 &lt;code&gt;O(N)&lt;/code&gt; 이며 (새 스트링을 만든다)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;concat&lt;/code&gt; 은 &lt;code&gt;O(1*)&lt;/code&gt; 이다. (&lt;code&gt;*&lt;/code&gt; 는 amortized)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;length, charAt&lt;/code&gt; 은 마찬가지로 &lt;code&gt;O(1)&lt;/code&gt; 이다. 참고로 &lt;code&gt;StringBuffer&lt;/code&gt; 는 &lt;code&gt;StringBuilder&lt;/code&gt; 와 비슷하지만 &lt;em&gt;thread safe&lt;/em&gt; 하고, 느리다.&lt;/p&gt;

&lt;p&gt;그러면 &lt;em&gt;reverse&lt;/em&gt; 를 구현 할 때 &lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;StringBuilder&lt;/code&gt; 중 어떤 것이 더 나을까?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 1. use String
public static String reverse(String s) {
  String rev = &amp;quot;&amp;quot;;
  for (int i = s.length() - 1; i &amp;gt;= 0; i--)
    rev += s.charAt(i);
    
  return rev;
}  

// 2. use StringBuilder
public static String reverse(String s) {
  StringBuilder rev = new StringBuilder();
  for (int i = s.length() - 1; i &amp;gt;= 0; i--)
    rev.append(s.charAt(i));
    
  return rev.toString();
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;String&lt;/code&gt; 을 이용한 버전은 &lt;code&gt;O(n^2)&lt;/code&gt; 이고, &lt;code&gt;StringBuilder&lt;/code&gt; 를 이용한 버전은 &lt;code&gt;O(n)&lt;/code&gt; 이다. 이는 &lt;code&gt;+=&lt;/code&gt; 와 &lt;code&gt;append&lt;/code&gt; 의 차이 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;suffixes&lt;/em&gt; 문제도 생각해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// input string
a a c a a g t t a c a a g c

// output
c     // suffixes 14
g c   // suffixes 13
a g c // suffixes 12
...
...
a a c a a g t t a c a a g c // suffixes 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;String&lt;/code&gt; 과 &lt;code&gt;StringBuilder&lt;/code&gt; 의 구현을 생각해 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 1. use String 
public static String[] suffixes(String s) {
  int N = s.length();
  String[] suffixes = new String[N];
  
  for (int i = 0; i &amp;lt; N; i ++)
    suffixes[i] = s.substring(i, N);
    
  return suffixes;
}

// 2. use StringBuilder 
public static String[] suffixes(String s) {
  int N = s.length;
  stringBuilder sb = new StringBuilder(s);
  String suffixes = new String
  
  for (int i = 0; i &amp;lt; N; i++)
    suffixes[i] = s.substring(i, N);
    
  return suffixes;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;당연히 &lt;code&gt;substring&lt;/code&gt; 은 &lt;code&gt;String&lt;/code&gt; 이 메모리 사용량이 훨씬 더 적을꺼라 생각했는데 Java7 Update6 부터 좀 달라졌다고 한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Java 7 Update 6&lt;/em&gt; 부터는 이전처럼 &lt;code&gt;String&lt;/code&gt; 의 &lt;code&gt;char []&lt;/code&gt; 가 공유되지 않는단다. 따라서 &lt;code&gt;String.substring&lt;/code&gt; 은 더이상 &lt;em&gt;constance space, time&lt;/em&gt; 이 아니라 &lt;em&gt;linear space, time&lt;/em&gt; 의 비용이 든다. 자세한 내용은 &lt;a href=&#34;http://java-performance.info/changes-to-string-java-1-7-0_06/&#34;&gt;Changes to String Java 1.7.0-06&lt;/a&gt;로&lt;/p&gt;

&lt;p&gt;따라서 알고리즘 &lt;code&gt;1&lt;/code&gt; 은 &lt;em&gt;linear time, space&lt;/em&gt; &lt;code&gt;2&lt;/code&gt; 는 &lt;em&gt;quadratic time, space&lt;/em&gt; 의 알고리즘이다.&lt;/p&gt;

&lt;h4 id=&#34;longest-common-prefix&#34;&gt;Longest common prefix&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int lcp(String s, String t) {
  int n = Math.min(s.length(), t.length());
  
  for (int i = 0; i &amp;lt; n; i++)
    if (s.charAt(i) != t.charAt(i))
      return i;
      
  return n;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;러닝타임은 &lt;code&gt;s, t&lt;/code&gt; 중 더 긴 문자열의 길이에 비례한다. 일반적으로는 &lt;em&gt;sublinear time&lt;/em&gt; 이다. 따라서 &lt;code&gt;compareTo&lt;/code&gt; 메소드를 &lt;em&gt;sublinear time&lt;/em&gt; 으로 구현할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;radix&#34;&gt;Radix&lt;/h4&gt;

&lt;p&gt;알파벳을 다양한 형태로 표현할 수 있는데, &lt;em&gt;binary&lt;/em&gt; 의 경우엔 &lt;code&gt;01&lt;/code&gt; 이 될 것이다. 이때의 &lt;em&gt;radix&lt;/em&gt; 는 2 다. &lt;em&gt;DNS&lt;/em&gt; 는 &lt;code&gt;ACTG&lt;/code&gt; 로 표현할 수 있으므로 &lt;code&gt;R = 4&lt;/code&gt; 다.&lt;/p&gt;

&lt;h3 id=&#34;key-indexed-counting&#34;&gt;Key-Indexed Counting&lt;/h3&gt;

&lt;p&gt;정렬 알고리즘의 성능을 정리해 보면,&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Insertion Sort&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;guarantee:&lt;/strong&gt; &lt;code&gt;O(N^2 / 2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;random:&lt;/strong&gt; &lt;code&gt;O(N^2 / 4)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;extra space:&lt;/strong&gt; &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stable:&lt;/strong&gt; &lt;code&gt;yes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) &lt;strong&gt;Merge Sort&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;guarantee:&lt;/strong&gt; &lt;code&gt;O(N log N)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;random:&lt;/strong&gt; &lt;code&gt;O(N log N)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;extra space:&lt;/strong&gt; &lt;code&gt;N&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stable:&lt;/strong&gt; &lt;code&gt;yes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(3) &lt;strong&gt;Quick Sort&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;guarantee:&lt;/strong&gt; &lt;code&gt;O(1.39 N log N)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;random:&lt;/strong&gt; &lt;code&gt;O(1.39 N log N)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;extra space:&lt;/strong&gt; &lt;code&gt;c log N&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stable:&lt;/strong&gt; &lt;code&gt;no&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(4) &lt;strong&gt;Heap Sort&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;guarantee:&lt;/strong&gt; &lt;code&gt;O(2 N log N)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;random:&lt;/strong&gt; &lt;code&gt;O(2 N log N)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;extra space:&lt;/strong&gt; &lt;code&gt;1 log N&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stable:&lt;/strong&gt; &lt;code&gt;no&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 &lt;em&gt;comparison based&lt;/em&gt; 알고리즘은 &lt;em&gt;lower bound&lt;/em&gt; 가 &lt;code&gt;N log N&lt;/code&gt; 이다. 따라서 &lt;em&gt;key compare&lt;/em&gt; 를 하지 않는다면 더 나은 성능을 낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;key-indexed counting&lt;/em&gt; 에서는 &lt;em&gt;key&lt;/em&gt; 가 &lt;code&gt;0&lt;/code&gt; 부터 &lt;code&gt;R - 1&lt;/code&gt; 사이의 정수라 가정한다. 따라서 키를 배열의 인덱스로 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 다음처럼 활용할 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sort String by first letter&lt;/li&gt;
&lt;li&gt;Sort class roster by section&lt;/li&gt;
&lt;li&gt;Sort phone number by area code&lt;/li&gt;
&lt;li&gt;Subroutine in a sorting algorithm&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;알고리즘을 보자.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Goal:&lt;/strong&gt; Sort an array &lt;code&gt;a[]&lt;/code&gt; of &lt;code&gt;N&lt;/code&gt; integers between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;R - 1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(1) Count frequencies of each letter using key as index&lt;br /&gt;
(2) Compute frequecy cumulates which specify destinations&lt;br /&gt;
(3) Access cumulates using key as index to move items&lt;br /&gt;
(4) Copy back into original array&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int N = a.length();
int[] count = new int[R + 1];

// step (1)
for (int i = 0; i &amp;lt; N; i++)
  count[a[i] + 1]++;
  
// step (2)
for (int r = 0; r &amp;lt; R; r++)
  count[r + 1] += count[r];

// step (3)
for (int i = 0; i &amp;lt; N; i++)
  aux[count[a[i]]++] = a[i];

// step (4)
for (int i = 0; i &amp;lt; N; i++)
  a[i] = aux[i];
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;~11N + 4R&lt;/code&gt; &lt;em&gt;array access&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N + R&lt;/code&gt; &lt;em&gt;extra space&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;key-indexed counting&lt;/em&gt; 은 &lt;em&gt;linear time, stable sorting&lt;/em&gt; 이다.&lt;/p&gt;

&lt;h4 id=&#34;stable&#34;&gt;Stable&lt;/h4&gt;

&lt;p&gt;알고리즘이 &lt;em&gt;stable&lt;/em&gt; 하다는 건 무슨 뜻일까?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A stable sort is one which preserves the original order of the input set while The unstable algorithm exhibits undefined behaviour when two elements are equal, it is perfectly possible that the order is sometimes preserved.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://i.stack.imgur.com/hn6Rg.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://programmers.stackexchange.com/&#34;&gt;http://programmers.stackexchange.com/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;h3 id=&#34;lsd-radix-sort&#34;&gt;LSD Radix Sort&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;least-significant-digit-first string(radix) sort&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;아이디어는 간단하다. 우측부터 좌측으로 한 문자씩 &lt;em&gt;key-indexed couting&lt;/em&gt; 을 하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTjVFR1ozVWpNaVJHTzVZV0x4QXpZNDBpWjNJMk10WW1ZeEVUTHlZak5pVkdOMWN6TDJnRE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(www.programering.com)&lt;/p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Which of the following is the most efficient algorithm to sort 1 million 32-bit integers?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;답은 &lt;em&gt;radix sort&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;correctness&#34;&gt;Correctness&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;LSD sorts fixe-length strins in ascending order&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가설에 의해 &lt;code&gt;i&lt;/code&gt; 번째 pass 후에는 뒤 부터 &lt;code&gt;i&lt;/code&gt; 개의 문자들이 정렬되어 있다.  이 때 비교하려는 &lt;code&gt;i+1&lt;/code&gt; 번째의 두 문자가 다르다면, &lt;em&gt;key-indexed sort&lt;/em&gt; 가 두 개의 문자열을 정렬한다. 이 때 &lt;em&gt;key-indexed sort&lt;/em&gt; 는 &lt;em&gt;stable&lt;/em&gt; 하므로 이전 까지의 정렬했던 순서를 보존한다.&lt;/p&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// W: fixed-length of strings
	public static void LSDsort(String[] a, int W) {
		int N = a.length;
		int R = 256;
		String[] aux = new String[N];
		
		// key indexed counting for each digit from right to left
		for (int d = W - 1; d &amp;gt;= 0; d--) {
			int[] count = new int[R + 1];
			
			// count frequencies
			for (int i = 0; i &amp;lt; N; i++) 
				count[a[i].charAt(d) + 1]++;
				
			for (int r = 0; r &amp;lt; R; r++) 	
				count[r + 1] += count[r];
			
			for (int i = 0; i &amp;lt; N; i++)
				aux[count[a[i].charAt(d)]++] = a[i];
		
			for (int i = 0; i &amp;lt; N; i++)
				a[i] = aux[i];
		}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;LSD sort&lt;/em&gt; 퍼포먼스는 &lt;code&gt;2WN&lt;/code&gt;, 랜덤하게 &lt;code&gt;2WN&lt;/code&gt;, 공간은 &lt;code&gt;N + R&lt;/code&gt;, &lt;em&gt;stable&lt;/em&gt; 하다. 참고로, &lt;code&gt;4byte Int&lt;/code&gt; 에 대해 &lt;code&gt;1Byte&lt;/code&gt; 씩 &lt;em&gt;LSD sort&lt;/em&gt; 를 적용하면 &lt;code&gt;Array.sort&lt;/code&gt; 보다 2~3배 더 빠르다고 한다. &lt;a href=&#34;http://algs4.cs.princeton.edu/51radix/LSD.java.html&#34;&gt;코드는 여기로&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;msd-radix-sort&#34;&gt;MSD Radix Sort&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;most significant-digit-first string sort&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Partition array into &lt;code&gt;R&lt;/code&gt; pieces according to first character&lt;/li&gt;
&lt;li&gt;Recursively sort all strings that start with each character&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;좌측 문자열 부터 시작하고, 현재 문자가 같은 문자열들 끼리 모아, 나머지 부분을 &lt;em&gt;sub-array&lt;/em&gt; 취급해서 재귀적으로 정렬한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWjNNV001VW1ZaWhETTRjVExoTldONDBpTTJVMk10RVdaeEFUTHpVRFptZHpNaEYyTDVFVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(www.programering.com)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;LSD&lt;/em&gt; 는 다루지 못하는 &lt;em&gt;variable-length string&lt;/em&gt; 을 정렬할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;implementation-1&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;참고로 자바에서는 &lt;code&gt;\0&lt;/code&gt; 이 없다. 그래서 문자열의 길이를 넘어서는 인덱스에 대해 &lt;code&gt;-1&lt;/code&gt; 을 돌려주는 &lt;code&gt;charAt&lt;/code&gt; 을 만들자. 추가적인 문자가 없다면, 정렬된 것으로 보고 끝내면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static int charAt(String s, int d) {
  if (d &amp;lt; s.length()) return s.charAt(d);
  else return -1;
}

	private static void msdSort(String[] a, String[] aux, int l, int h, int d) {
		
		if (h &amp;lt;= l) return;
		
		int R = 256;
		int[] count = new int[R + 2];
		
		// count frequencies
		for (int i = l; i &amp;lt;= h; i++) {
			int c = charAt(a[i], d);
			count[c + 2]++;
		}
		
		// accumulate
		for (int r = 0; r &amp;lt; R + 1; r++)
			count[r + 1] += count[r];
		
		// sort
		for (int i = l; i &amp;lt;= h; i++) {
			int c = charAt(a[i], d);
			aux[count[c + 1]++] = a[i];
		}
		
		// copy
		for (int i = l; i &amp;lt;= h; i++)
			a[i] = aux[i - l];
		
		// solve sub-arrays
		for (int r = 0; r &amp;lt; R; r++)
			msdSort(a, aux, l + count[r], l + count[r + 1] - 1, d + 1);
	}
	
	public static void MSDsort(String[] a) {
		String[] aux = new String[a.length];
		msdSort(a, aux, 0, a.length - 1, 0);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그런데 이 구현은 몇 가지 문제가 있다.&lt;/p&gt;

&lt;p&gt;(1) 매 재귀마다 &lt;code&gt;count&lt;/code&gt; 배열을 만들고, 그 크기는 &lt;code&gt;R&lt;/code&gt; 에 비례하기 때문에 &lt;code&gt;~11R + N&lt;/code&gt; 의 성능을 갖는 &lt;em&gt;key-indexed counting&lt;/em&gt; 연산이 &lt;em&gt;small subarray&lt;/em&gt; 가 많아지면서 급격히 느려진다.&lt;/p&gt;

&lt;p&gt;(2) 조그마한 &lt;em&gt;sub-array&lt;/em&gt; 에 대해 많은 수의 재귀가 호출된다.&lt;/p&gt;

&lt;p&gt;이 문제를 해결하기 위해 적은 수의 &lt;em&gt;small array&lt;/em&gt; 에 대해 &lt;em&gt;insertion sort&lt;/em&gt; 를 사용하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// substring comparison is much faster than charAt comparison
	private static boolean less(String v, String w, int d) {
		return v.substring(d).compareTo(w.substring(d)) &amp;lt; 0;
	}
	
	private static void isort(String[] a, String[] aux, int l, int h, int d) {
		// insertion sort
		for (int i = l; i &amp;lt;= h; i++)
			for (int j = i; j &amp;gt; l &amp;amp;&amp;amp; less(a[j], a[j - 1], d); j--) {
				// swap a[j - 1], a[j]
				String temp = a[j - 1];
				a[j - 1] = a[j];
				a[j] = temp;
			}
			
	}
	
	private static void msdSort(String[] a, String[] aux, int l, int h, int d) {
		
		int CUTOFF = 15;
		if (h &amp;lt;= l + CUTOFF) {
			isort(a, aux, l, h, d);
			return;
		}
    ...
    ...
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;performance&#34;&gt;Performance&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;MSD string sort&lt;/em&gt; 는 필요한만큼 &lt;em&gt;character&lt;/em&gt; 를 확인하기 때문에, 데이터에 따라 성능이 다르다. 그러나 대부분의 경우 &lt;em&gt;sublinear&lt;/em&gt; 하고, 운이 나쁜 경우 &lt;em&gt;linear&lt;/em&gt; 의 성능이 나온다. &lt;em&gt;duplicated key&lt;/em&gt; 가 있는 경우에는 &lt;em&gt;nearly linear&lt;/em&gt; 다.&lt;/p&gt;

&lt;p&gt;재밌는 사실은 &lt;code&gt;compareTo&lt;/code&gt; 를 이용하지만 &lt;em&gt;sublinear&lt;/em&gt; 하게 성능이 나올 수도 있다는 점이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTWhkVFk0VXpZa2RqTmtaV0x3Z2paNTBpTTNZek10VWpNMFVUTGxSMlkxY1Raamx6TDRJVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(www.programering.com)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;MSD string sort&lt;/em&gt; 는 매 재귀마다 새로운 &lt;code&gt;count&lt;/code&gt; 배열을 만들기 때문에 &lt;code&gt;N + DR&lt;/code&gt; 만큼의 메모리가 필요하다., (&lt;code&gt;D&lt;/code&gt; 는 재귀 호출의 수)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;LSD&lt;/em&gt; 에 비해서 가변길이 문자열을 정렬할 수 있고, &lt;em&gt;random&lt;/em&gt; 데이터에 대해 &lt;code&gt;N log_R N&lt;/code&gt; 의 성능을 보여준다. &lt;em&gt;LSD&lt;/em&gt; 와 마찬가지로 &lt;em&gt;stable&lt;/em&gt; 하다.&lt;/p&gt;

&lt;h4 id=&#34;msd-vs-quick&#34;&gt;MSD vs quick&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;MSD string sort&lt;/em&gt; 는 &lt;em&gt;random access&lt;/em&gt; 를 하기 때문에 &lt;em&gt;cache inefficient&lt;/em&gt; 할 수 있고, &lt;em&gt;quicksort&lt;/em&gt; 에 비해 &lt;em&gt;inner loop&lt;/em&gt; 에 많은 명령어가 있다. 게다가 &lt;code&gt;count, aux&lt;/code&gt; 등 추가적인 메모리가 필요하다.&lt;/p&gt;

&lt;p&gt;반면 &lt;em&gt;quicksort&lt;/em&gt; 는 &lt;em&gt;linear&lt;/em&gt; 하지 않다. 그리고, 많은 수의 문자들을 다시 비교해야한다. 이 두가지를 합친 방법은 없을까?&lt;/p&gt;

&lt;h3 id=&#34;3-way-radix-quicksort&#34;&gt;3-way Radix Quicksort&lt;/h3&gt;

&lt;p&gt;&lt;del&gt;무려 교수님이 만드신 알고리즘 1997년에 이 수업에서 만들었다고 함&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;기본적인 아이디어는&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Do 3-way partitioning on the &lt;code&gt;d&lt;/code&gt; th character&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Less overhead than &lt;code&gt;R&lt;/code&gt;-way partitioning in &lt;em&gt;MSD string sort&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Does not re-examine characters equal to the partitioning char (but does re-examine characters not equal to the partitioning char)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTWhKVFpoTkRPMk1qWTRRV0xsTm1ZaTFDTjVFek10SVdNaVZUTHdZVFlsVldPbVoyTDBNVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(www.programering.com)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;즉, 첫 문자열의 첫 번째 문자를 기준으로, 이것보다 큰 것, 작은 것, 같은 것 3개로 파티셔닝하면서 정렬하는 알고리즘이다.&lt;/p&gt;

&lt;h4 id=&#34;implementation-2&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;구현은 퀵소트랑 상당히 유사하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// 3-Way Quicksort
	public static void Quicksort3way(String[] a) {
		qsort3way(a, 0, a.length - 1, 0);
	}
	
	// helper method for 3 way quicksort
	private static void swap(String[] a, int i, int j) {
		String temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	
	private static void qsort3way(String[] a, int l, int h, int d) {
		if (h &amp;lt;= l) return;
	
		int lt = l, gt = h;
		int v = charAt(a[l], d);
		int i = l + 1;
		
		// partition
		while (i &amp;lt;= gt) {
			int t = charAt(a[i], d);
			
			if      (t &amp;lt; v) swap(a, lt++, i++);
			else if (t &amp;gt; v) swap(a, i, gt--);
			else            i++;
		}
		// a[lo..lt-1] &amp;lt; v = a[lt..gt] &amp;lt; a[gt+1..hi]
		qsort3way(a, l, lt - 1, d);
		if (v &amp;gt;= 0) qsort3way(a, lt, gt, d + 1);
		qsort3way(a, gt + 1, h, d);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;MSD string sort&lt;/em&gt; 와 마찬가지로 &lt;code&gt;CUTOFF&lt;/code&gt; 를 이용해서 작은 &lt;em&gt;sub-array&lt;/em&gt; 를 &lt;em&gt;insetion sort&lt;/em&gt; 로 정렬할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;3-way-quicksort-vs-standard-quicksor&#34;&gt;3-way quicksort vs standard quicksor&lt;/h4&gt;

&lt;p&gt;일반적으로 &lt;em&gt;quicksort&lt;/em&gt; 는 &lt;code&gt;compareTo&lt;/code&gt; 를 기준으로 &lt;code&gt;~ 2N lnN&lt;/code&gt; 의 성능을 보여주고, &lt;em&gt;long common prefixes&lt;/em&gt; 가 있는 경우에 상당히 계산 비용이 비싸다. 이는 비교했던 문자열을 또 비교할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;그러나 &lt;em&gt;3-way string quicksort&lt;/em&gt; 는 &lt;code&gt;charAt&lt;/code&gt; 을 기준으로 &lt;code&gt;~ 2N lnN&lt;/code&gt; 의 성능을 보인다. 그리고 같은 파티션에 대해 &lt;code&gt;d + 1&lt;/code&gt; 로 재귀호출하기 때문에 같은 파티션 내에서는 비교했던 문자를 다시 계산하지 않는다. &lt;del&gt;갓 교수님&lt;/del&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-way-quicksort-vs-msd-sort&#34;&gt;3-way quicksort vs MSD sort&lt;/h4&gt;

&lt;p&gt;(1) &lt;strong&gt;MSD string sort&lt;/strong&gt; 는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;같은 &lt;code&gt;count&lt;/code&gt; 값을 가진 문자열에 뜬금없이 접근하기 때문에 &lt;em&gt;cache-inefficient&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;재귀마다 &lt;code&gt;count[]&lt;/code&gt; 를 새로 만들어 너무 많은 메모리를 사용&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count[], aux[]&lt;/code&gt; 를 초기화하는데 너무 많은 오버헤드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) &lt;strong&gt;3-way string quicksort&lt;/strong&gt; 는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;더 짧은 &lt;em&gt;inner loop&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt; 을 이용해 순차적으로 접근하므로 &lt;em&gt;cache-friendly&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;in-place&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTTTJFV09tZFRPakoyTTVjVEwxWW1ZNDBDTWtoek10UVRZMUlXTDVVRE8wWUdNd1UyTHhRVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(www.programering.com)&lt;/p&gt;&lt;/p&gt;

&lt;h3 id=&#34;suffix-arrays&#34;&gt;Suffix Arrays&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;keyword-in-context search&lt;/em&gt; 란&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a text of &lt;code&gt;N&lt;/code&gt; chars, preprocess i to enable fast substring search (find all occurrences of query string ocntext)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;쉽게 말해서 구글 검색창에 &lt;em&gt;world&lt;/em&gt; 라고 치면 &lt;em&gt;hello world&lt;/em&gt; 등이 자동으로 검색목록에 나오는것.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWmtkVFozRW1ZbFZtTmlGVEx6RVRPNDBTWTFZek10UVRNeFFXTGlKVFpqbERNekkyTHpRVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(www.programering.com)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;suffixes&lt;/em&gt; 를 만든다음에 문자열 정렬을 해서 중복된 &lt;em&gt;suffix&lt;/em&gt; 가 있는지 보면 된다. &lt;code&gt;String&lt;/code&gt; 의 경우 &lt;code&gt;substring&lt;/code&gt; 을 얻는데 &lt;code&gt;O(1)&lt;/code&gt; 이이므로 &lt;em&gt;suffixes&lt;/em&gt; 를 만드는데 &lt;code&gt;O(n)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;그 후에 &lt;em&gt;binary search&lt;/em&gt; 를 하면, 일치하는 문자열을 검색할 수 있다.&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Preprocess:&lt;/strong&gt; &lt;em&gt;suffix sort&lt;/em&gt; the text.&lt;br /&gt;
(2) &lt;strong&gt;Query:&lt;/strong&gt; &lt;em&gt;binary search&lt;/em&gt; for query; scan until mismatch.&lt;/p&gt;

&lt;h3 id=&#34;longest-repeated-substring&#34;&gt;Longest repeated substring&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Gien a string of &lt;code&gt;N&lt;/code&gt; characters, find the longest repeated substring.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;유전자 지도 &lt;code&gt;a g t t a a t c g ~&lt;/code&gt; 에서 일치하는 가장 긴 유전자 문자열을 찾아내는데 활용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;data compression&lt;/em&gt; 에도 활용 가능하다. 자주 반복되는 긴 패턴을 발견해 짧게 줄이면 용량을 상당히 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;악보를 이용해서 음악을 &lt;em&gt;visualization&lt;/em&gt; 하는데도 활용할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;brute-force&#34;&gt;Brute Force&lt;/h4&gt;

&lt;p&gt;문자열의 길이가 &lt;code&gt;N&lt;/code&gt;, 가장 긴 패턴의 길이가 &lt;code&gt;D&lt;/code&gt; 라면 &lt;em&gt;worst case&lt;/em&gt; &lt;code&gt;DN^2&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h4 id=&#34;sorting-solution&#34;&gt;Sorting solution&lt;/h4&gt;

&lt;p&gt;(1) form suffixes (&lt;code&gt;O(n)&lt;/code&gt;)&lt;br /&gt;
(2) sort suffixes (&lt;code&gt;O(n log n)&lt;/code&gt;)&lt;br /&gt;
(3) compute longest prefix between adjacent suffixes (&lt;code&gt;O(kn)&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// longrest common prefix
	public static String lcp(String v, String w) {
		
		int n = Math.min(v.length(), w.length());
		
		for (int i = 0; i &amp;lt; n; i++) {
			if (v.charAt(i) != w.charAt(i)) return v.substring(0, i);
		}
		
		return v.substring(0, n);
	}
	
    // longest repeated substring
	public static String lrs(String s) {
	
		int N = s.length();
		String[] suffixes = new String[N];
	
		// form suffixes
		for(int i = 0; i &amp;lt; N; i++)
			suffixes[i] = s.substring(i, N);

		// sort
		Arrays.sort(suffixes);
		
		// find longest repeated substring using lcp
		String lrs = &amp;quot;&amp;quot;;
		
		for (int i = 0; i &amp;lt; N - 1; i++) {
			String x = lcp(suffixes[i], suffixes[i + 1]);
			
			if (x.length() &amp;gt; lrs.length()) lrs = x;
		}
		
		return lrs;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;suffix soring&lt;/em&gt; 에 &lt;em&gt;3-way string quicksort&lt;/em&gt; 를 이용하면 어마어마하게 빠르다.&lt;/p&gt;

&lt;p&gt;한 가지 문제는 &lt;em&gt;lrs&lt;/em&gt; 의 길이가 길어지면 &lt;em&gt;suffix sort&lt;/em&gt; 의 성능이 급격히 떨어진다. &lt;code&gt;D&lt;/code&gt; 를 &lt;em&gt;lrs&lt;/em&gt; 의 길이라 했을때 적어도 &lt;code&gt;1 + 2 + ... + D&lt;/code&gt; 의  문자열 비교가 필요하다. (자신과 자신의 서브스트링과의 비교)&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;D&lt;/code&gt; 가 길면 길수록 성능이 나빠진다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Quadratic (or worse) in &lt;code&gt;D&lt;/code&gt; for &lt;em&gt;LRS&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;성능이 떨어지는 입력 데이터로, 반복되는 인풋이 있다. &lt;code&gt;twinstwins&lt;/code&gt; 를 예로 들면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ins
instwins
ns
nstwins
s
stwins
twins
twinstwins
wins
winstwins
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러면 더 빠른 알고리즘이 없을까? &lt;em&gt;Manber-Myers algorithm&lt;/em&gt; 이란게 있는데, 요건 &lt;em&gt;linearithmic&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;suffix trees&lt;/em&gt; 란 것도 있다. 이건 &lt;em&gt;linear&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;manber-myers-msd-algorithm&#34;&gt;Manber-Myers MSD Algorithm&lt;/h4&gt;

&lt;p&gt;(1) sort on first character using key-indexed counting sort&lt;br /&gt;
(2) given array of suffixes sorted on first &lt;code&gt;2^(i-1)&lt;/code&gt; characters (phase &lt;code&gt;i&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;worse-case&lt;/em&gt; 퍼포먼스는 &lt;code&gt;N lgN&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWmtCVE9rZFRaMVFEWjVBVEwwY2paaTFTTjBjek10Z0RabU5XTGlSRE9qUkRNalIyTDNNak14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(www.programering.com)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;key-indexed counting&lt;/em&gt; 을 이용해 먼저 하나의 문자를 정렬하고, 그 이후에는 &lt;code&gt;2, 4, 6, 8, ...,&lt;/code&gt; 개씩 정렬해 나간다. 이 과정에서 &lt;code&gt;inverse[]&lt;/code&gt; 를 이용한 &lt;em&gt;index sort&lt;/em&gt; 란걸 하는데, 아이디어는 이렇다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;suffixes&lt;/em&gt; 에서 비교하려는 두 문자열의 뒷부분의 일부는 이미 이전 단계에 정렬 되었을 수 있다. (슬라이드의 빨간색 부분) 따라서 이미 정렬해 된 순서 &lt;code&gt;inverse[]&lt;/code&gt; 를 이용해서 현재 비교하려는 두 문자열의 순서를 정할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;summary&#34;&gt;Summary&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;linear-time&lt;/em&gt; 문자열 정렬을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;왜냐하면 &lt;em&gt;key comparison&lt;/em&gt; 이 아니라 &lt;em&gt;character comparison&lt;/em&gt; 으로 해낼 수 있기 때문&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;sublinear-time&lt;/em&gt; 정렬도 만들 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모든 문자열을 비교할 필요가 없기 때문 (Input size is amount of data in keys, not number of keys.)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;3-way string quicksort is asymptotically optimal&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;1.39 N lgN&lt;/code&gt; 의 문자열 비교, &lt;em&gt;random data&lt;/em&gt; 에 대해. 그러나 &lt;em&gt;suffix sort&lt;/em&gt; 에 대해 &lt;code&gt;N lgN&lt;/code&gt; 을 보장하려면(&lt;em&gt;worst case&lt;/em&gt;) &lt;em&gt;Manber-Myer&lt;/em&gt; 를 사용해야 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Long strings are rarely random in practice&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;em&gt;Algorithms: Part 2&lt;/em&gt; by &lt;strong&gt;Robert Sedgewick&lt;/strong&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://programmers.stackexchange.com/questions/247440/what-does-it-mean-for-a-sorting-algorithm-to-be-stable&#34;&gt;What is a stable sorting algorithm?&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://www.programering.com/a/MTOyYjNwATM.html&#34;&gt;www.programering.com&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Algorithm: R-way, Ternary Tries</title>
      <link>https://1ambda.github.io/91/algorithm/algorithm-part2-3/</link>
      <pubDate>Sat, 25 Jun 2016 13:01:19 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/algorithm-part2-3/</guid>
      <description>

&lt;h3 id=&#34;string-symbol-table&#34;&gt;String Symbol Table&lt;/h3&gt;

&lt;p&gt;지난 시간에 &lt;em&gt;symbol-table&lt;/em&gt; 의 구현으로 &lt;em&gt;red-black tree, hash table&lt;/em&gt; 의 성능을 살펴봤었다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;red black tree&lt;/em&gt; 는 &lt;em&gt;search, insertion, delete&lt;/em&gt; 에 &lt;code&gt;compareTo&lt;/code&gt; 를 이용해 &lt;code&gt;log N&lt;/code&gt;, &lt;em&gt;hash table&lt;/em&gt; 은 &lt;code&gt;equals, hashCode&lt;/code&gt; 를 이용해 &lt;code&gt;1&lt;/code&gt; (under uniform hashing assumption) 의 성능을 확인했다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;red black tree&lt;/em&gt; 의 경우에는 &lt;em&gt;rank&lt;/em&gt; 같은 다른 연산도 하는것도 봤다. 그런데, 이보다 더 빠르게 만들 순 없을까?&lt;/p&gt;

&lt;p&gt;가능하다. 스트링 정렬처럼, &lt;em&gt;entire key&lt;/em&gt; 를 모두 검사하지 않으면 더 빠르게 만들 수 있다. 먼저 시작 전에 &lt;em&gt;String symbol table API&lt;/em&gt; 를 좀 보고가면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class StringST&amp;lt;Value&amp;gt; {
  ...
  
  void put(String key, Value value)
  Value get(String key)
  void delete(String key)

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tries&#34;&gt;Tries&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;red black tree&lt;/em&gt; 나 &lt;em&gt;hash table&lt;/em&gt; 과는 다르게 한 노드에 &lt;em&gt;key&lt;/em&gt; 가 아니라 &lt;em&gt;character&lt;/em&gt; 를 저장한다. 아래 짤방을 보는게 이해가 더 빠를듯. 끝 초록색 노드에 붙어있는 숫자가 바로 &lt;em&gt;value&lt;/em&gt; 다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://t2.hhg.to/V12-d3.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://t2.hhg.to&#34;&gt;http://t2.hhg.to&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이름은 re&lt;strong&gt;trie&lt;/strong&gt;val 에서 왔다고 한다. &lt;em&gt;try&lt;/em&gt; 랑 똑같이 발음함. 허프만 코드랑 비슷하게도 보인다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For now, store &lt;em&gt;char&lt;/em&gt; in nodes (not keys)&lt;/li&gt;
&lt;li&gt;Each node has &lt;code&gt;R&lt;/code&gt; children, one or each possible chars&lt;/li&gt;
&lt;li&gt;Store values in nodes corresponding to last chars in keys&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;value&lt;/em&gt; 는 항상 끝에만 있을 수 있는건 아니고 &lt;code&gt;shell&lt;/code&gt;, &lt;code&gt;she&lt;/code&gt; 둘 다 저장했을때 &lt;code&gt;e&lt;/code&gt; 에도 &lt;code&gt;she&lt;/code&gt; 를 위한 &lt;em&gt;value&lt;/em&gt; 를   저장할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;trie-performance&#34;&gt;Trie Performance&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Search hit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;L&lt;/code&gt; 개의 문자를 모두 탐색해야 한다. 그리 긴 시간은 아님.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Search miss&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;첫 번째 문자부터 탐색에 실패할 확률도 있다. 전형적인 경우는 몇 개의 문자를 탐색하다 실패하는 경우이므로 &lt;em&gt;sublinear&lt;/em&gt; 한 퍼포먼스를 보여준다.&lt;/p&gt;

&lt;p&gt;각 &lt;code&gt;leaf&lt;/code&gt; 마다 &lt;code&gt;R&lt;/code&gt; 개의 널 링크가 필요한데, 그래도 &lt;em&gt;sublinear&lt;/em&gt; 라고 말할 수 있는 것이 짧은 문자열들은 &lt;em&gt;common prefix&lt;/em&gt; 를 공유한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Fast search hit and evn faster search miss, but waste spaces.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;search miss&lt;/em&gt; 의 성능이 &lt;code&gt;log_R N&lt;/code&gt; 으로 빨라져서 좋긴 한데, &lt;em&gt;space&lt;/em&gt; 가 &lt;code&gt;(R + 1) * N&lt;/code&gt; 이라 좀 부담이다. (&lt;em&gt;search hit, insert&lt;/em&gt; 는 해시 테이블처럼 &lt;code&gt;L&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;유니코드면 &lt;em&gt;65536-way trie&lt;/em&gt; 를 만들어야 한다.&lt;/p&gt;

&lt;p&gt;유명한 &lt;em&gt;job interview&lt;/em&gt; 로 &lt;em&gt;efficient spell checking&lt;/em&gt; 의 자료구조를 구현하는 것이 있는데. &lt;em&gt;26-way tries&lt;/em&gt; 를 만들면 된다. &lt;em&gt;value&lt;/em&gt; 는 &lt;em&gt;bit&lt;/em&gt; 로&lt;/p&gt;

&lt;h4 id=&#34;deletion-in-an-r-way-trie&#34;&gt;Deletion in an R-way Trie&lt;/h4&gt;

&lt;p&gt;만약 마지막 노드가 &lt;em&gt;all null links&lt;/em&gt; 를 가지고 있으면 제거하면 된다. 그리고 백트래킹 하면서 &lt;em&gt;value&lt;/em&gt; 를 만나기 전 까지 삭제되면 됨.&lt;/p&gt;

&lt;h4 id=&#34;r-way-tries-implementation&#34;&gt;R-way Tries Implementation&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TrieST&amp;lt;Value&amp;gt; {

	private static final int R = 256; // extended ASCII
	private Node root = new Node();
	private int N;

	private static class Node {
		private Object val;
		private Node[] next = new Node[R];
	}
	
	public TrieST() { N = 0; }
	
	public int size() { return N; }
	
	public boolean isEmpty() { return size() == 0; }

	public Value get(String key) {
		Node x = get(root, key, 0);
		
		if (x == null) return null;
		return (Value) x.val;
	}
	
	public void delete(String key) {
		root = delete(root, key, 0);
	}

	private Node delete(Node x, String key, int d) {
		if (x == null) return null;
		
		if (d == key.length()) {
			if (x.val != null) N--;
			x.val = null;
		} else {
			char c = key.charAt(d);
			x.next[c] = delete(x.next[c], key, d + 1);
		}
		
		// remove subtrie rooted at x if it is completely empty
		if (x.val != null) return x;
		for (int c = 0; c &amp;lt; R; c++)
			if (x.next[c] != null) return x;
		
		return null;
	}

	private Node get(Node x, String key, int d) {
		if (x == null) return null;
		if (d == key.length()) return x;
		char c = key.charAt(d);
		return get(x.next[c], key, d + 1);
	}
	
	public boolean contains(String key) {
		return get(key) != null;
	}

	public void put(String key, Value val) {
		if (val == null) delete(key);
		else root = put(root, key, val, 0);
	}

	private Node put(Node x, String key, Value val, int d) {
		if (x == null) x = new Node();
		if (d == key.length()) {
			if (x.val == null) N++;
			x.val = val;
			return x;
		}
		
		char c = key.charAt(d);
		x.next[c] = put(x.next[c], key, val, d + 1);
		return x;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ternary-search-tries&#34;&gt;Ternary Search Tries&lt;/h3&gt;

&lt;p&gt;이전의 &lt;em&gt;R-way&lt;/em&gt; 는 &lt;code&gt;R&lt;/code&gt; 개의 자식들을 가졌지만, &lt;em&gt;ternary&lt;/em&gt; 에서는 &lt;code&gt;3&lt;/code&gt; 개만 가진다. &lt;del&gt;이것도 교수님이 만듬&lt;/del&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Store chars and values in nodes (not keys)&lt;/li&gt;
&lt;li&gt;Each node has 3 children; smaller, equal, larger&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;binary search&lt;/em&gt; 와 거의 유사하다. 그냥 &lt;em&gt;key&lt;/em&gt; 를 &lt;em&gt;string&lt;/em&gt; 로 사용하고 효율적인 검색을 위해 노드에 &lt;em&gt;character&lt;/em&gt; 를 저장한다는 점만 다르고. 이 차이점을 그냥 교수님은 &lt;em&gt;tree&lt;/em&gt; 가 아니라 &lt;em&gt;trie&lt;/em&gt; 라 부르는 것 같다.&lt;/p&gt;

&lt;p&gt;어쨌든 &lt;em&gt;ternary&lt;/em&gt; 는 &lt;em&gt;r-way&lt;/em&gt; 보다 &lt;em&gt;null link&lt;/em&gt; 자체가 훨씬 적다. 따라서 메모리 사용량에 부담 없고, &lt;em&gt;hash table&lt;/em&gt; 보다 상당히 빠른 &lt;em&gt;search miss&lt;/em&gt; 를 보여준다. 구현은 &lt;a href=&#34;http://algs4.cs.princeton.edu/52trie/TST.java.html&#34;&gt;여기로&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;tst-impelementation&#34;&gt;TST Impelementation&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TernaryST&amp;lt;Value&amp;gt; {

	private int N;
	private Node root;
	
	private class Node {
		private char c;
		private Value val;
		private Node left, mid, right;
	}
	
	public TernaryST() { N = 0; }
	
	public int size() { return N; }
	public boolean isEmpty() { return size() == 0; }
	
	public boolean contains(String key) {
		return get(key) != null;
	}
	
	public Value get(String key) {
		if (key == null) throw new NullPointerException();
		if (key.length() == 0) throw new IllegalArgumentException(&amp;quot;key shouldn&#39;t be empty&amp;quot;);
		
		Node x = get(root, key, 0);
		if (x == null) return null;
		return x.val;
	}

	private Node get(Node x, String key, int d) {
		if (key == null) throw new NullPointerException();
		if (key.length() == 0) throw new IllegalArgumentException(&amp;quot;key shouldn&#39;t be empty&amp;quot;);
		if (x == null) return null;
		
		char c = key.charAt(d);
		if      (c &amp;lt; x.c) 				return get(x.left, key, d);
		else if (c &amp;gt; x.c) 				return get(x.right, key, d);
		else if (d &amp;lt; key.length() - 1)  return get(x.mid, key, d + 1);
		else 							return x;
	}
	
	public void put(String key, Value val) {
		if (!contains(key)) N++;
		root = put(root, key, val, 0);
	}

	private Node put(Node x, String key, Value val, int d) {
		char c = key.charAt(d);
		
		if (x == null) {
			x = new Node();
			x.c = c;
		}
		
		if 		(c &amp;lt; x.c) 				x.left = put(x.left, key, val, d);
		else if	(c &amp;gt; x.c) 				x.right = put(x.right, key, val, d);
		else if (d &amp;lt; key.length() - 1)	x.mid = put(x.mid, key, val, d + 1);
		else 							x.val = val;
				
		return x;
	}	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;항상 느끼는건데, &lt;em&gt;imperative&lt;/em&gt; 언어에서의 재귀가 더 어려운 것 같다.&lt;/p&gt;

&lt;h4 id=&#34;tst-performance&#34;&gt;TST Performance&lt;/h4&gt;

&lt;p&gt;(1) &lt;strong&gt;R-way trie&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;search hit:&lt;/strong&gt; &lt;code&gt;L&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;search miss:&lt;/strong&gt; &lt;code&gt;log_R N&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;insert:&lt;/strong&gt; &lt;code&gt;L&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;space:&lt;/strong&gt; &lt;code&gt;(R + 1) * N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) &lt;strong&gt;Ternary trie(TST)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;search hit:&lt;/strong&gt; &lt;code&gt;L + ln N&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;search miss:&lt;/strong&gt; &lt;code&gt;ln N&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;insert:&lt;/strong&gt; &lt;code&gt;L + ln N&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;space:&lt;/strong&gt; &lt;code&gt;4N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;메모리가 &lt;code&gt;4N&lt;/code&gt; 밖에 안든다! 해싱은 모든 연산이 &lt;code&gt;L&lt;/code&gt; 이겠지만, 대신 메모리가 &lt;code&gt;4N ~ 16N&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;ternary symbol table&lt;/em&gt; 은 &lt;em&gt;hash table&lt;/em&gt; 만큼 빠르고, 메모리도 덜 든다.&lt;/p&gt;

&lt;p&gt;참고로 &lt;em&gt;rotation&lt;/em&gt; 연산을 이용해서 &lt;em&gt;balanced TST&lt;/em&gt; 를 만들면 &lt;em&gt;worst case&lt;/em&gt; 에도 &lt;code&gt;L + logN&lt;/code&gt; 이 나온다.&lt;/p&gt;

&lt;h4 id=&#34;tst-with-r2-branching-at-root&#34;&gt;TST with R2 Branching at root&lt;/h4&gt;

&lt;p&gt;꼭대기엔 &lt;code&gt;R^2-way&lt;/code&gt; 로 짓고, 자식은 &lt;em&gt;TST&lt;/em&gt; 로 지을 수 있다. 분석 결과로는 일반 &lt;em&gt;TST&lt;/em&gt; 보다 더 빠르다고 한다.&lt;/p&gt;

&lt;h4 id=&#34;tst-vs-hashing&#34;&gt;TST vs Hashing&lt;/h4&gt;

&lt;p&gt;(1) Hashing&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Need to examine entier key&lt;/li&gt;
&lt;li&gt;Search hits and misses cost about the same&lt;/li&gt;
&lt;li&gt;Performance relies on hash function&lt;/li&gt;
&lt;li&gt;Does not support ordered symbol table operations.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) TST&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Works only for strings (or digital keys)&lt;/li&gt;
&lt;li&gt;Only examines just enough key characters&lt;/li&gt;
&lt;li&gt;Search miss may involve only a few characters&lt;/li&gt;
&lt;li&gt;Supports ordered symbol table operations (plus others!).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정리하면, &lt;em&gt;TST&lt;/em&gt; 는 해싱만큼 빠르고 &lt;em&gt;search miss&lt;/em&gt; 는 더 빠르다. 그리고 &lt;em&gt;red-black BST&lt;/em&gt; 보다 유연하다. 그러나 자료의 형태에 제한이 있다.&lt;/p&gt;

&lt;h3 id=&#34;character-based-operations&#34;&gt;Character-Based Operations&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;string symbol table&lt;/em&gt; 의 경우에는 유용한 &lt;em&gt;chars-based operation&lt;/em&gt; 을 제공한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;prefix match&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;wildcard match&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;longest prefix&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;API&lt;/em&gt; 를 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SymbolST&amp;lt;Value&amp;gt; {

  ...
  ...
  
  Iterable&amp;lt;String&amp;gt; keys()
  Iterable&amp;lt;String&amp;gt; keysWithPrefix  (String s)
  Iterable&amp;lt;String&amp;gt; keysThatMatch   (String s)
  String           longestPrefixOf (String s) 
  
  ...
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 외에도 &lt;em&gt;ordered ST&lt;/em&gt; 를 위한 &lt;em&gt;floor, rank&lt;/em&gt; 등의 연산도 추가할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;inorder-traverse-of-trie&#34;&gt;Inorder Traverse of Trie&lt;/h4&gt;

&lt;p&gt;탐색이 이진트리하고 좀 다른게, 매 문자열마다 시작점부터 시작해야 된다. &lt;em&gt;leaf&lt;/em&gt; 까지 방문하는건 같은데&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/250px-Trie_example.svg.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://en.wikipedia.org/wiki/Trie&#34;&gt;http://en.wikipedia.org/wiki/Trie&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Iterable&amp;lt;String&amp;gt; keys() {
  Queue&amp;lt;String&amp;gt; q = new Queue&amp;lt;String&amp;gt;();
  collect(root, &amp;quot;&amp;quot;, q);
  return q;
}

public void collect(Node x, String prefix, Queue&amp;lt;String&amp;gt; q) {
  if (x == null) return;
  if (x.val != null) q.enequeue(prefix);
  
  for (char c = 0; c &amp;lt; R; c++)
    collect(x.next[c], prefix + c, q);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;queue&lt;/em&gt; 는 단순히 &lt;code&gt;she&lt;/code&gt; 를 방문할때 &lt;code&gt;she&lt;/code&gt; 를 저장하기 위한 용도다. &lt;code&gt;val != null&lt;/code&gt; 일 때 저장하므로 &lt;code&gt;s, sh&lt;/code&gt; 등은 저장하지 않는 다는 점에 유의하자.&lt;/p&gt;

&lt;p&gt;그리고 여기서 큐는 &lt;em&gt;DFS, BFS&lt;/em&gt; 처럼 로직에 쓰이지 않는다. 모든 노드를 방문하긴 하는데 &lt;code&gt;c = 0&lt;/code&gt; 부터 시작하니 왼쪽부터 방문하는 재귀 순회라 보면 쉽다.&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;collect&lt;/code&gt; 함수는 인자로 받은 노드 &lt;code&gt;x&lt;/code&gt; 를 기준으로 하위에 있는 &lt;em&gt;substring&lt;/em&gt; 을 찾아낸다.&lt;/p&gt;

&lt;p&gt;실제 구현에서는 &lt;code&gt;StringBuilder&lt;/code&gt; 를 사용한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	private void collect(Node x, StringBuilder prefix, Queue&amp;lt;String&amp;gt; q) {
		// TODO Auto-generated method stub
	
		if (x == null) return;
		if (x.val != null) q.add(prefix.toString());
		
		for (char c = 0; c &amp;lt; R; c++) {
			prefix.append(c);
			collect(x.next[c], prefix, q);
			prefix.deleteCharAt(prefix.length() - 1);
		}
	}
	
	public Iterable&amp;lt;String&amp;gt; keys() { return keysWithPrefix(&amp;quot;&amp;quot;); }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;prefix-matchs&#34;&gt;Prefix Matchs&lt;/h4&gt;

&lt;p&gt;구글링 하면서 매일 사용하는 기능이다. 구현은 위의 &lt;code&gt;collect&lt;/code&gt; 함수를 사용하면 쉽다. &lt;code&gt;keyWithPrefix(&amp;quot;sh&amp;quot;)&lt;/code&gt; 라면, &lt;code&gt;sh&lt;/code&gt; 까지 내려간 뒤 &lt;code&gt;collect&lt;/code&gt; 를 호출하면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Iterable&amp;lt;String&amp;gt; keysWithPrefix(String prefix) {
  Queue&amp;lt;String&amp;gt; q = new Queue&amp;lt;String&amp;gt;();
  Node x = get(root, prefix, 0);
  collect(x, prefix, q);
  return q;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바의 &lt;code&gt;Queue&lt;/code&gt; 는 인터페이스이므로 실제 구현은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public Iterable&amp;lt;String&amp;gt; keysWithPrefix(String prefix) {
		Queue&amp;lt;String&amp;gt; q = new LinkedList&amp;lt;String&amp;gt;();
		Node x = get(root, prefix, 0);
		collect(x, new StringBuilder(prefix), q);
		return q;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;longest-prefix&#34;&gt;Longest Prefix&lt;/h4&gt;

&lt;p&gt;라우터에서 자주 사용한다. 아이피를 문자열로 표현하고, 자기가 알고 있는 인접한 라우터중 어디로 보낼지를 결정하기 위해 &lt;em&gt;longest prefix&lt;/em&gt; 를 알아내 보낸다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;longestPrefixOf(&amp;quot;128.112.136.11&amp;quot;) 
// 128.112.136
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아이디어는 간단하다. &lt;code&gt;null&lt;/code&gt; 이나 찾으려는 문자열의 마지막 문자를 만나기 전까지의 문자열을 모아 돌려주면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String longestPrefixOf(String query) {
  int length = search(root, query, 0, 0);
  return query.substring(0, length);
}

public int search(Node x, String query, int d, int length) {

  if (x == null) return length;
  if (x.val != null) length =  d;
  if (d == query.length) return length;
  
  char c = query.charAt(d);
  return search(x.next[c], query, d + 1, length);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;patricia-trie&#34;&gt;Patricia Trie&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;shells, shellfish&lt;/code&gt; 를 넣으면 브랜칭이 길게 이루어진다. 메모리 낭비가 있을 수 있는데, &lt;code&gt;shell&lt;/code&gt; 밑에 &lt;code&gt;s, fish&lt;/code&gt; 를 자식으로 만들면 괜찮다.&lt;/p&gt;

&lt;p&gt;그러나 이 강의의 범위를 넘어서는 것이라 안알려준다고 함 ㅠㅠ. 이미지를 구해서 첨부하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://2.bp.blogspot.com/-0B8D2LHyQVc/USMklcwZnMI/AAAAAAAAAKc/UBmZnHflOa0/s640/radix_tries.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://3.bp.blogspot.com/-nQ0ZUeIpDrQ/USMkvNUKHBI/AAAAAAAAAKk/rrvVaYU4Pwo/s640/fractal+tries.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;(http://aketa.blogspot.kr)&lt;/p&gt;

&lt;p&gt;아마도 통짜로 삽입 후 이후에 비슷한 &lt;em&gt;suffix&lt;/em&gt; 의 문자열이 들어오면 분리를 시키는 것 같다.&lt;/p&gt;

&lt;h4 id=&#34;suffix-tree&#34;&gt;Suffix Tree&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://marknelson.us/attachments/1996/suffix-trees/FIGURE2.gif&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://marknelson.us&#34;&gt;http://marknelson.us&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;문자열 &lt;em&gt;suffix&lt;/em&gt; 의 &lt;em&gt;patricia trie&lt;/em&gt; 인데 &lt;em&gt;linear time&lt;/em&gt; 으로 만들 수 있다고 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;longest repeated substring&lt;/li&gt;
&lt;li&gt;longest common substring&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등에 쓸 수 있단다.&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;(1) Red-Black BST&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Performance guarantee:&lt;/strong&gt; &lt;code&gt;lg N&lt;/code&gt; key compares&lt;/li&gt;
&lt;li&gt;Supports ordered symbol table API&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) Hash Table&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Performance guarantee:&lt;/strong&gt; &lt;em&gt;constant&lt;/em&gt; number of probes&lt;/li&gt;
&lt;li&gt;Requires good hash function for key type&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(3) R-way, TST&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Performance guarantee:&lt;/strong&gt; &lt;code&gt;lg N&lt;/code&gt; &lt;em&gt;character&lt;/em&gt; accessed&lt;/li&gt;
&lt;li&gt;Supports &lt;em&gt;character-based&lt;/em&gt; operations&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;You can get at anything by examining 50-100 bits!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;em&gt;Algorithms: Part 2&lt;/em&gt; by &lt;strong&gt;Robert Sedgewick&lt;/strong&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://t2.hhg.to/V12-lausn.html&#34;&gt;http://t2.hhg.to&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://en.wikipedia.org/wiki/Trie&#34;&gt;Wikipedia: Trie&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://aketa.blogspot.kr/2013/02/squeezed-tries-fractal-compression-for.html&#34;&gt;Squeezed Tries, Fractal Compression&lt;/a&gt;&lt;br /&gt;
(5) &lt;a href=&#34;http://marknelson.us/1996/08/01/suffix-trees/&#34;&gt;Mark Nelson&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Algorithm: KMP, Boyer-Moore, Rabin-Karp</title>
      <link>https://1ambda.github.io/91/algorithm/algorithm-part2-4/</link>
      <pubDate>Sat, 25 Jun 2016 13:01:20 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/algorithm-part2-4/</guid>
      <description>

&lt;h3 id=&#34;intro-to-substring-search&#34;&gt;Intro to Substring Search&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;N&lt;/code&gt; 길이의 텍스트에서 &lt;code&gt;M&lt;/code&gt; 길이의 패턴을 찾는 문제다. 일반적으로 &lt;code&gt;N &amp;gt;&amp;gt; M&lt;/code&gt; 이다. &lt;code&gt;N&lt;/code&gt; 이 좀 많이 (무한히) 길기 때문에 지난시간까지 배운 알고리즘을 적용하기가 좀 힘들다.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;suffix sort&lt;/em&gt; 를 쓰려고 보니 &lt;em&gt;suffixes&lt;/em&gt; 를 만드는 것 자체가 어렵다. 따라서 &lt;em&gt;manber-myers MSD&lt;/em&gt; 도 패스.&lt;/p&gt;

&lt;p&gt;(2) &lt;em&gt;R-way&lt;/em&gt; 든 &lt;em&gt;Ternary&lt;/em&gt; 든 &lt;em&gt;tries&lt;/em&gt; 자체를 만들기 어렵다. 탐색해야 할 문서는 어마어마하기 때문에 메모리의 양이 모자랄 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;뭔가 문서를 &lt;em&gt;streaming&lt;/em&gt; 취급하면서 처리할 수 있는 알고리즘이 필요하다.&lt;/p&gt;

&lt;p&gt;주된 &lt;em&gt;application&lt;/em&gt; 은&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;computer forensics:&lt;/strong&gt; search memory, disk for signatures&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CTRL + F&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;spam filtering:&lt;/strong&gt; 특정 패턴이 발견되면 스팸이라 볼 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;internet traffic monitoring:&lt;/strong&gt; 보안&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;screen scraping:&lt;/strong&gt; 관련있는 패턴을 추출할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자바에서는 &lt;code&gt;indexOf&lt;/code&gt; 메소드가 문자열에서 해당 패턴을 발견해 시작 인덱스를 돌려준다.&lt;/p&gt;

&lt;h3 id=&#34;brute-force&#34;&gt;Brute Force&lt;/h3&gt;

&lt;p&gt;&lt;del&gt;언젠가 양자 컴퓨터가 나오면 쓸모 있을까&lt;/del&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int bruteForce(String pattern, String docs) {	
	int M = pattern.length();
	int N = docs.length();
	
	for (int i = 0; i &amp;lt; N - M; i ++) {
		int j;
		
		for (j = 0; j &amp;lt; M; j++) 
			if (pattern.charAt(j) != docs.charAt(i + j)) break;
			
		if (j == M) return i;
	}
	
	return N;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;성능은 &lt;em&gt;worst case&lt;/em&gt; 에서 &lt;code&gt;~M N&lt;/code&gt; 번의 &lt;em&gt;char compares&lt;/em&gt; 가 필요하다. 예를 들어 문서가 &lt;code&gt;AAAAAAAAAAAB&lt;/code&gt; 고 패턴이 &lt;code&gt;AAAAAB&lt;/code&gt; 면 최악이다.&lt;/p&gt;

&lt;h4 id=&#34;backup&#34;&gt;Backup&lt;/h4&gt;

&lt;p&gt;대부분의 &lt;em&gt;application&lt;/em&gt; 에서 &lt;em&gt;backup&lt;/em&gt; 하길 원치 않는다. 서론에 언급했듯이 스트림처럼 취급하고싶은데, &lt;em&gt;brute force&lt;/em&gt; 에서는 &lt;em&gt;backup&lt;/em&gt; 이 필요하기 때문에 &lt;em&gt;last &lt;code&gt;M&lt;/code&gt; characters&lt;/em&gt; 의 버퍼를 유지한다거나의 방법을 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;아래의 구현은 똑같은 비교 회수를 가지는데, &lt;em&gt;backup&lt;/em&gt; 한다는걸 확실히 보여준다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; points to end of sequence of already-matched chars in docs&lt;/li&gt;
&lt;li&gt;&lt;code&gt;j&lt;/code&gt; stores # of already-matched chars (end of sequence in pattern)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int bruteForceBackup(String pattern, String docs) {
	int i, N = docs.length();
	int j, M = pattern.length();
	
	for (i = 0, j = 0; i &amp;lt; N &amp;amp;&amp;amp; j &amp;lt; M; i++) 
		if (docs.charAt(i) == pattern.charAt(j)) j++;
		else { i -= j; j = 0; }
	
	if (j == M) return i - M;
	else return N;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이게 &lt;code&gt;M&lt;/code&gt; 이 작으면 문제가 안되는데, &lt;code&gt;M&lt;/code&gt; 이 크면 문제가 될 수 있다.&lt;/p&gt;

&lt;p&gt;우리가 풀어야 할 문제는&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;linear-tme guarantee&lt;/em&gt; 가 필요&lt;br /&gt;
(2) &lt;em&gt;backup&lt;/em&gt; 하지 않기&lt;/p&gt;

&lt;h3 id=&#34;knuth-morris-pratt&#34;&gt;Knuth-Morris-Pratt&lt;/h3&gt;

&lt;p&gt;아이디어는 간단하다. 매칭에 실패했을 경우, 현재까지 처리한 문자들에 대한 &lt;em&gt;정보&lt;/em&gt; 를 가지고 있기 때문에, 이걸 이용해서 필요 없는 부분을 건너 뛴다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// pattern: BAAAAAAAAA

A B A A A A B A A A A A A A A A
  B A A A A ^ // fail
            B // ignore previous chars
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dfa&#34;&gt;DFA&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Knuth-Morris-Pratt&lt;/em&gt; 알고리즘은 &lt;em&gt;deterministic finite state automation, DFA&lt;/em&gt; 란 것에 이론적으로 기반한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;DFA&lt;/em&gt; 는 &lt;em&gt;abstract string-searching machine&lt;/em&gt; 이다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Finite number of states (including start and halt)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exactly one transition&lt;/strong&gt; for each char in alphabet&lt;/li&gt;
&lt;li&gt;Accept if sequence of transitions leads to half state&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://www-igm.univ-mlv.fr/~lecroq/string/images/rwadfa2.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www-igm.univ-mlv.fr&#34;&gt;http://www-igm.univ-mlv.fr&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;더 크게 보면 &lt;em&gt;DFA&lt;/em&gt; 는 &lt;em&gt;Finite State Machine, FSM&lt;/em&gt; 의 한 종류다. &lt;em&gt;DFA&lt;/em&gt; 말고도 &lt;em&gt;Nondeterministic Finite Automata, NFA&lt;/em&gt; 가 있는데,  차이점은 이렇다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;비결정적 유한 오토마타는 결정적 유한 오토마타와는 다르게 입력 기호에 대해서 &lt;code&gt;\epsilon&lt;/code&gt;-transition 에 의해 0개 이상의 이동이 가능하다. 만약 가능한 다음 상태의 경우가 없다면, 기계는 입력을 거부한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;결정적 유한 오토마타는 입력값에 대해 출력 값이 1개라는 소리 같은데, 좀 모호해서 더 찾아봤다. &lt;a href=&#34;http://math.stackexchange.com/questions/563829/difference-between-nfa-and-dfa&#34;&gt;여기&lt;/a&gt; 에 의하면&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each input to a &lt;strong&gt;DFA&lt;/strong&gt; or &lt;strong&gt;NFA&lt;/strong&gt; affects the state of the automaton: if it was in state q immediately before the input, either it will be in some state q′ after the input, or the input will cause it to choke. (Note that q′ may be the same as q.) Suppose that we have an automaton in a state q. The difference in behavior between a DFA and an NFA is this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If it’s a &lt;strong&gt;DFA&lt;/strong&gt;, each possible input determines the resulting state q′ uniquely. Every input causes a state change, and the new state is completely determined by the input. Moreover, the automaton can change state only after reading an input.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If it’s an &lt;strong&gt;NFA&lt;/strong&gt;, some inputs may allow a choice of resulting states, and some may cause the automaton to choke, because there is no new state corresponding to that input. Moreover, the automaton may be constructed so that it can change state to some new state q′ without reading any input at all.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As a consequence of this difference in behavior, DFA’s and NFA’s differ in another very important respect.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If you start a &lt;strong&gt;DFA&lt;/strong&gt; in its initial state and input some word w, the state q in which the DFA ends up is completely determined by w: inputting w to the DFA will always cause it to end up in state q. This is what is meant by calling it deterministic.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you start an &lt;strong&gt;NFA&lt;/strong&gt; in its initial state and input some word w, there may be several possible states in which it can end up, since some of the inputs along the way may have allowed a choice of state changes. Consequently, you can’t predict from w alone in exactly which state the automaton will finish; this is what is meant by calling it nondeterministic. (And it’s actually a little worse than I’ve indicated, since an NFA is also allowed to have more than one initial state.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, these differences affect how we determine what words are accepted (or recognized) by an automaton.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If it’s a &lt;strong&gt;DFA&lt;/strong&gt;, we know that each word completely determines the final state of the automaton, and we say that the word is accepted if that state is an acceptor state.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If it’s an &lt;strong&gt;NFA&lt;/strong&gt;, there might be several possible final states that could result from reading a given word; as long as at least one of them is an acceptor state, we say that the automaton accepts the word.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;del&gt;갓 아메리카&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;똑같은 입력에 대해 &lt;em&gt;NFA&lt;/em&gt; 는 다양한 최종상태를 만들 수 있다고 한다. 그래서 그 중 하나라도 &lt;em&gt;accept&lt;/em&gt; 되면, 처리 된 것으로 받아들인다고 함. 어디서 주워들은 &lt;em&gt;NP hardness&lt;/em&gt; 와 비스무리한 개념인것 같다. 그림을 다시 보면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www-igm.univ-mlv.fr/~lecroq/string/images/rwadfa2.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www-igm.univ-mlv.fr&#34;&gt;http://www-igm.univ-mlv.fr&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;검색하려는 패턴, 즉 &lt;em&gt;desired state&lt;/em&gt; 나열하고 &lt;em&gt;transition&lt;/em&gt; 를 그려가며 &lt;em&gt;DFA&lt;/em&gt; 를 만든다. 이를 이용해 텍스트를 파싱하면서 &lt;em&gt;final state&lt;/em&gt; 에 도달하는지 보면 된다.&lt;/p&gt;

&lt;p&gt;구현은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int kmpStringSearch(String docs, String pattern) {
  int i, j;
  int N = docs.length(), M = pattern.length();
  Int[][] dfa = createDFA(pattern);
  
  for (i = 0, j = 0; i &amp;lt; N &amp;amp;&amp;amp; j &amp;lt; M; i++) {
    j = dfa[txt.charAt(i)][j];
  }
  
  if (j == M) return i - M 
  else N
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;재밌는 사실은 &lt;em&gt;backup&lt;/em&gt; 이 더이상 필요 없기 때문에 입력을 &lt;em&gt;stream&lt;/em&gt; 으로 받을 수도 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public int kmpStringSearch(In in, String pattern) {
  int i, j;
  int M = pattern.length();
  Int[][] dfa = createDFA(pattern);
  
  for (i = 0, j = 0; !in.isEmpty() &amp;amp;&amp;amp; j &amp;lt; M; i++) {
    j = dfa[in.readChar()][j];
  }
  
  if (j == M) return i - M 
  else N
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;em&gt;running time&lt;/em&gt; 은 &lt;em&gt;DFA&lt;/em&gt; 만 있다면 확실히 &lt;code&gt;N&lt;/code&gt; 번의 &lt;em&gt;char access&lt;/em&gt; 다. 그럼 이제 문제는, &lt;em&gt;DFA&lt;/em&gt; 를 만드는데 얼마나 시간이 걸릴것 인가?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;DFA&lt;/em&gt; 를 만들면서 알아보자. &lt;code&gt;ABABAC&lt;/code&gt; 의 패턴이 있을때&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;match transition&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;현재 상태가 &lt;code&gt;j&lt;/code&gt; 이고 다음 문자인 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;c == pattern.charAt(j)&lt;/code&gt; 이면 &lt;em&gt;match transition&lt;/em&gt; 이므로 &lt;code&gt;j++&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;따라서 패턴 &lt;code&gt;ABABAC&lt;/code&gt; 의 &lt;em&gt;DFA&lt;/em&gt; 는&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               j     0 1 2 3 4 5 
pattern.charAt(j)    A B A B A C

dfa[][j]          A  1   3   5
                  B    2   4  
                  C            6                  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2) &lt;em&gt;mismatch transition&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;상태 &lt;code&gt;j&lt;/code&gt; 에서 &lt;code&gt;c != pattern.chatAt(j)&lt;/code&gt; 이면, &lt;em&gt;mismatch&lt;/em&gt; 다. 그러면  방금 전까지 만든 &lt;code&gt;j-1&lt;/code&gt; 까지의 &lt;em&gt;DFA&lt;/em&gt; 를 이용해서 &lt;code&gt;pattern[1 .. j-1]&lt;/code&gt; 까지를 인풋으로 넣어 돌리면 된다. 무슨말인고 하니&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ABABAC&lt;/code&gt; 에서 현재 &lt;em&gt;state&lt;/em&gt; 가 &lt;code&gt;5&lt;/code&gt; 면, 다음 인풋으로 &lt;code&gt;C&lt;/code&gt; 를 받아야한다. &lt;code&gt;ABABA^C&lt;/code&gt; 이렇게 표기하자. 그러면, &lt;code&gt;ABABA&lt;/code&gt; 까지의 &lt;em&gt;DFA&lt;/em&gt; 를 만들었으므로, 첫 문자 &lt;code&gt;A&lt;/code&gt; 를 버리고 다음 문자 &lt;code&gt;C&lt;/code&gt; 를 포함해서 &lt;code&gt;BABAC&lt;/code&gt; 를 인풋으로 해서 &lt;em&gt;DFA&lt;/em&gt; 를 돌리면 된다.&lt;/p&gt;

&lt;p&gt;예를 들어 &lt;code&gt;j = 5&lt;/code&gt;, &lt;code&gt;c = A, B&lt;/code&gt; 에 대해 &lt;code&gt;j = 4&lt;/code&gt; 까지의 &lt;em&gt;DFA&lt;/em&gt; 를 짓고&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               j     0 1 2 3 4 5 
pattern.charAt(j)    A B A B A C

dfa[][j]          A  1 1 3 1 5
                  B  0 2 0 4 0
                  C  0 0 0 0 0 6                  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;에 대해서 &lt;code&gt;BABA&lt;/code&gt; 를 반복하면, &lt;code&gt;j = 3&lt;/code&gt; 이다. 따라서&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dfa[&#39;A&#39;][5] = dfa[&#39;A&#39;][3] = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dfa[&#39;B&#39;][5] = dfa[&#39;B&#39;][3] = 4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이게 잘 보면 매번 &lt;code&gt;j - 1&lt;/code&gt; 의 스텝을 반복해야하는 걸로 보일 수 있는데, 그러지 말고 &lt;code&gt;pattern[1 .. j-1]&lt;/code&gt; 을 &lt;em&gt;state&lt;/em&gt; &lt;code&gt;X&lt;/code&gt; 라 부르고, 이걸 유지하면 &lt;em&gt;transition&lt;/em&gt; 을 &lt;em&gt;constant time&lt;/em&gt; 으로 지을 수 있다. 즉 &lt;code&gt;j&lt;/code&gt; 가 하나 증가할 때 마다&lt;/p&gt;

&lt;p&gt;&lt;code&gt;X = dfa[pattern.charAt(j)][X]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이렇게 &lt;code&gt;X&lt;/code&gt; 를 업데이트하면, &lt;code&gt;j - 1&lt;/code&gt; 까지의 상태가 &lt;code&gt;X&lt;/code&gt; 다. 따라서 &lt;em&gt;DFA&lt;/em&gt; 를 &lt;em&gt;linear time&lt;/em&gt; 으로 만들 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTT3lJR08zSUdOalZUTm1WV0x6UVRPaDFDTmhkek10RXpZeFFXTGpWR1p3a1RZekkyTDRnek0wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;performance&#34;&gt;Performance&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;DFA&lt;/em&gt; 를 만드는 속도는 &lt;code&gt;M&lt;/code&gt; &lt;em&gt;char access&lt;/em&gt; 이므로 전체 문서를 검색하는데 걸리는 시간은 &lt;code&gt;M + N&lt;/code&gt; &lt;em&gt;char access&lt;/em&gt; 다. (&lt;code&gt;M&lt;/code&gt; 은 패턴의 길이, &lt;code&gt;N&lt;/code&gt; 은 문서의 길이)&lt;/p&gt;

&lt;p&gt;그러나 &lt;em&gt;DFA&lt;/em&gt; 를 만드는데 필요한 메모리가 &lt;code&gt;R * M&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NFA&lt;/em&gt; 를 이용하면 &lt;em&gt;KMP&lt;/em&gt; 알고리즘을 더 개선할 수 있다. &lt;code&gt;M&lt;/code&gt; 에 비례하는 시간, 공간만으로도 패턴을 문서에서 탐색할 수 있다고 한다. &lt;a href=&#34;http://algs4.cs.princeton.edu/53substring/KMPplus.java.html&#34;&gt;KMPplus.java&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;kmp-implementation&#34;&gt;KMP Implementation&lt;/h4&gt;

&lt;p&gt;구현하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DFA {
	
	int[][] dfa;
	
	public DFA(String pattern, int R) {
		int M = pattern.length();
	
		// initialize
		dfa = new int[R][];
		for (int r = 0; r &amp;lt; R; r++)
			dfa[r] = new int[M];
		
		dfa[pattern.charAt(0)][0] = 1;
		
		// build DFA
		for (int X = 0, j = 1; j &amp;lt; M; j++) {
			// mismatch
			for (int c = 0; c &amp;lt; R; c++)
				dfa[c][j] = dfa[c][X];
			
			// match
			dfa[pattern.charAt(j)][j] = j + 1;
			
			// update X
			X = dfa[pattern.charAt(j)][X];
		}
	}

	public int search(String docs) {
		
		int i, j, M = pattern.length(), N = docs.length();
		
		for (i = 0, j = 0; i &amp;lt; N &amp;amp;&amp;amp; j &amp;lt; M; i++) {
			j = dfa[docs.charAt(i)][j];
		}
		
		if (j == M) return i - M;
		else return N;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;boyer-moore&#34;&gt;Boyer-Moore&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;KMP&lt;/em&gt; 알고리즘은 &lt;em&gt;linear time&lt;/em&gt; 인데, 이보다 더 빠르게 할 수 있을까?&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTmtkVE5qaHpZaWRUWWhSVEx5STJNaDFDWmlCek10SUdaeFlUTGlGVE0yRVdPakp6TDRJRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com&#34;&gt;http://www.programering.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;패턴의 우측부터 매칭해 가면, 꽤나 많은 &lt;code&gt;M&lt;/code&gt; 사이즈의 텍스트를 빠르게 제낄 수 있다. 문제는 패턴이 어디까지 매칭되었는지에 따라 스킵할 수 있는 문자가 다르다는 것이다. 경우를 좀 나눠서 살펴보자 &lt;code&gt;i&lt;/code&gt; 는 현재 문서의 탐색할 인덱스를, &lt;code&gt;^&lt;/code&gt; 는 &lt;em&gt;mismatch&lt;/em&gt; 를 나타낸다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// case 1

          i     ^
. . . . . . . . T L E . . . . 
          N E E D L E
          
                  i
. . . . . . . . T L E . . . . 
                  N E E D L E
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;case 1&lt;/em&gt; 은 운이 좋아서, 미스매치 &lt;code&gt;T&lt;/code&gt; 가 패턴에 없기 때문에 &lt;code&gt;T&lt;/code&gt; 다음으로 &lt;code&gt;i&lt;/code&gt; 를 옮길 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// case 2a

          i     ^
. . . . . . . . N L E . . . . 
          N E E D L E
          
                i 
. . . . . . . . N L E . . . . 
                N E E D L E

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기선 &lt;em&gt;mismatch&lt;/em&gt; 문자 &lt;code&gt;N&lt;/code&gt; 이 패턴에 있기 때문에 &lt;em&gt;rightmost&lt;/em&gt; &lt;code&gt;N&lt;/code&gt; 을 찾아 다시 비교를 시작한다. (우측부터 비교하기 때문)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// case 2b

          i     ^
. . . . . . . . E L E . . . . 
          N E E D L E
          
// rightmost &#39;E&#39;          

      i          
. . . . . . . . E L E . . . . 
      N E E D L E


// just increament `i` by 1

                i         
. . . . . . . . E L E . . . . 
            N E E D L E
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 경우엔 &lt;em&gt;rightmost&lt;/em&gt; &lt;code&gt;E&lt;/code&gt; 가 별로 도움이 안되므로, 그냥 &lt;code&gt;i&lt;/code&gt; 를 증가시킨다.&lt;/p&gt;

&lt;p&gt;다시 한번 정리하면,&lt;/p&gt;

&lt;p&gt;(1) 우측부터 시작해서 비교하다 &lt;em&gt;mismatch&lt;/em&gt; 문자가 있을 때 필요 없는 문자를 몇개나 제낄 수 있느냐 하는 문제는, 패턴 안에서 해당 &lt;em&gt;mismatch&lt;/em&gt; 문자가 있느냐 없느냐에 따라 다르다.&lt;/p&gt;

&lt;p&gt;(2) 없다면 모두 제껴버리면 되는거고,&lt;/p&gt;

&lt;p&gt;(3) 있다면 그 문자가 얼마나 우측에 오느냐에 따라 스킵할 수 있는 문자의 수가 달라진다. 우측에 오면 올 수록 거기서 부터 다시 비교해야 하기 때문에, &lt;em&gt;heuristic&lt;/em&gt; 이 별로 도움이 안될 수도 있다. &lt;em&gt;case 2b&lt;/em&gt; 가 바로 그 예다. 그럴때는 그냥 1 만큼 증가시키는것이 더 나을 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;skip table&lt;/em&gt; 을 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int M = pattern.length();
int[] right = new int[R];

for (i = 0; i &amp;lt; R; i++) right[i] = -1;
for (j = 0; j &amp;lt; M; j++) right[pattern.charAt(j)] = j;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 테이블을 이용해 탐색을 하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int N = docs.length();
int M = pattern.length();

for (int i = 0; i &amp;lt;= N - M; i++) {
  int skip = 0;
  
  for (int j = M - 1; j &amp;gt;=0; j--) {
    if (docs.charAt(i + j) != pattern.charAt(j)) {
      skip = Math.max(1, j - right[docs.charAt(i + j)]);
      break;
    }
  }
  
  if (skip == 0) return i;
}

return N;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 알고리즘에서 &lt;code&gt;skip&lt;/code&gt; 을 계산하는 부분을 잘 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;skip = Math.max(1, j - right[docs.charAt(i + j)]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;현재 비교가 진행된 &lt;code&gt;j&lt;/code&gt; 에서 &lt;em&gt;mismatch&lt;/em&gt; 문자의 인덱스를 뺄셈해서 1 보다 큰지를 비교한다. 만약 1 보다 작다면, 다시 말해 &lt;code&gt;0&lt;/code&gt; 이나 음수라면 &lt;code&gt;skip&lt;/code&gt; 이 마이너스로, 즉 왼쪽으로 되기 때문에 스킵할 필요가 없다. 그냥 우측으로 &lt;code&gt;+1&lt;/code&gt; 해서 다시 비교하면 된다.&lt;/p&gt;

&lt;p&gt;전체 코드는&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BoyerMoore {
	
	int[] right;
	String pattern;

	public BoyerMoore(String pattern, int R) {

		this.pattern = pattern;
		int M = pattern.length();
	
		// initialize skip table
		right = new int[R];
		for (int i = 0; i &amp;lt; R; i++) right[i] = -1;
		for (int j = 0; j &amp;lt; M; j++) right[pattern.charAt(j)] = j;
	}
	
	public int search(String docs) {

		int M = pattern.length();
		int N = docs.length();
		
		for (int i = 0; i &amp;lt;= N - M; i++) {
			int skip = 0;
			
			for (int j = M - 1; j &amp;gt;=0; j--) {
				if (pattern.charAt(j) != docs.charAt(i + j)) {
					// calculate skip value
					skip = Math.max(1, j - right[docs.charAt(i + j)]);
					break;
				}
			}
			
			if (skip == 0) return i;
		}
		
		return N;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이건 &lt;em&gt;bad character&lt;/em&gt; 라는 특성을 이용한 방법이고, &lt;em&gt;good suffix&lt;/em&gt; 등을 과 비교하여 얼마나 더 스킵할지를 결정할 수 있다.&lt;/p&gt;

&lt;p&gt;보이어 무어 알고리즘에 대한 설명은 &lt;a href=&#34;http://xenostudy.tistory.com/72&#34;&gt;여기&lt;/a&gt;가 제일 잘 되어있다.&lt;/p&gt;

&lt;h4 id=&#34;performance-1&#34;&gt;Performance&lt;/h4&gt;

&lt;p&gt;일반적으로는(휴리스틱) &lt;code&gt;~N/M&lt;/code&gt; 의 &lt;em&gt;char compare&lt;/em&gt; 비교를 한다고 알려져있다. &lt;em&gt;sublinear&lt;/em&gt; 한건데,&lt;/p&gt;

&lt;p&gt;&lt;em&gt;worst case&lt;/em&gt; 에서는 &lt;code&gt;~ MN&lt;/code&gt; 이다. 예를 들어 패턴이 &lt;code&gt;ABBBB&lt;/code&gt; 고 문서가 &lt;code&gt;BBBBBBBBBBBBBBBBB..&lt;/code&gt; 일때 최악이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;worst case&lt;/em&gt; 를 &lt;code&gt;~3N&lt;/code&gt; 까지 개선할 수 있다. &lt;em&gt;KMP-like rule&lt;/em&gt; 을 더해 반복적인 패턴을 비하면 된다.&lt;/p&gt;

&lt;p&gt;실제로 보이어 무어 알고리즘은 검색할 문자열이 길때 효과가 있다. 그래야 스킵할것이 많기 때문이다. 그러나 대부분의 경우 검색어가 그다지 길지 않다는 것.&lt;/p&gt;

&lt;h3 id=&#34;rabin-karp&#34;&gt;Rabin-Karp&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://terpconnect.umd.edu/~sthomas2/images/rabinkarp.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://terpconnect.umd.edu&#34;&gt;http://terpconnect.umd.edu&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;기본 아이디어는 &lt;em&gt;modular hashing&lt;/em&gt; 이다. 인덱스를 하나씩 증가시켜가면서 문자열의 해싱 값을 비교한다.&lt;/p&gt;

&lt;p&gt;먼저 해야할 일은 &lt;em&gt;hash function&lt;/em&gt; 을 만드는 건데, &lt;code&gt;t_i&lt;/code&gt; 를 문서(&lt;code&gt;txt&lt;/code&gt;) 의 &lt;code&gt;i&lt;/code&gt; 번째 캐릭터라 하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://chart.apis.google.com/chart?cht=tx&amp;amp;chl=x_t%20%3D%20t_i%20R%5E%7BM-1%7D%5C%20%20%2B%5C%20%20t_%7Bi%2B1%7D%20R%5E%7BM-2%7D%5C%20%20%2B%5C%20%20%5Ccdots%20%5C%20%5C%20%20%2B%5C%20%20%20t_%7Bi%2BM-1%7D%20R%5E%7B0%7D%5C%20%5C%20%20(mod)%5C%20%5C%20%20Q&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;M&lt;/code&gt;-&lt;em&gt;digit&lt;/em&gt;, &lt;code&gt;R&lt;/code&gt;-&lt;em&gt;base&lt;/em&gt;, &lt;code&gt;Q&lt;/code&gt; modulo 다. &lt;code&gt;M&lt;/code&gt;-&lt;em&gt;degree&lt;/em&gt; 다항식인데, &lt;em&gt;Horner&amp;rsquo;s method&lt;/em&gt; 를 쓰면 중복된 계산 없이 &lt;em&gt;linear time&lt;/em&gt; 으로 &lt;em&gt;evaluation&lt;/em&gt; 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWjBnak1rUkRPeUVqWWpSVEwwRW1NaDFpWjVVek10WVROME1UTDNjVFl4SUdaemt6TDNjRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com/&#34;&gt;http://www.programering.com/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;난 첨에 뭔소린가 했는데 다항식의 값을 구할 때 중복된 계산을 피하기 위해 이렇게 구현하는걸 말한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://web-ext.u-aizu.ac.jp/course/alg1/ex/uk/ex04/horner2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;R&lt;/code&gt; 에 대한 다항식이기 때문에, 해싱함수의 구현은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private long hash(String key, int M, int Q) {
  long h = 0;
  
  for(int j = 0; j &amp;lt; M; j++)
    h = (R * h + key.charAt(j)) % Q;
    
  return h;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;x_i&lt;/code&gt; 의 해싱값을 계산하고, 매칭이 안되면 다음으로 넘어가 &lt;code&gt;x_(i+1)&lt;/code&gt; 을 계산해야 한다. 그런데, 좀 더 효율적으로 할 수 있는 방법이 없을까? 당연히 가능하다. 두 해싱값 서로 다른 1개의 항 빼고는 모두 같은 항을 가지고 있기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://chart.apis.google.com/chart?cht=tx&amp;amp;chl=x_i%5C%20%20%3D%5C%20t_iR%5E%7BM-1%7D%5C%20%2B%5C%20t_%7Bi%2B1%7DR%5E%7BM-2%7D%5C%20%2B%5C%20%5Ccdots%5C%20%2B%5C%20t_%7Bi%20%2B%20M%20-%201%7DR%5E0%5C%5C%0A%5C%20%5C%5C%20%0A%5C%20%5C%5C%0A%5C%20%5C%5C%0A%5C%20%5C%5C%0A%5C%20%5C%5C%0Ax_i%5C%20%20%3D%5C%20t_%7Bi%20%2B%201%7DR%5E%7BM-1%7D%5C%20%2B%5C%20t_%7Bi%2B1%7DR%5E%7BM-2%7D%5C%20%2B%5C%20%5Ccdots%5C%20%2B%5C%20t_%7Bi%20%2B%20M%7DR%5E0&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;x_(i+1)&lt;/code&gt; 은&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://chart.apis.google.com/chart?cht=tx&amp;amp;chl=x_%7Bi%2B1%7D%5C%20%20%3D%5C%20%20(x_i%5C%20%20%5C%20-%20t_iR%5E%7BM-1%7D)%5C%20%20*%5C%20%20R%5C%20%2B%5C%20%20t_%7Bi%2BM%7D%20&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이므로, 상수 시간 내에 다음 문자열의 해시값을 구할 수 있다. 따라서 매 &lt;code&gt;i&lt;/code&gt; 마다 상수 시간이므로 &lt;code&gt;~N&lt;/code&gt; 으로 패턴을 찾을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTmhKR00yWVROaEpHT2psVEwzTW1ONTBpWndjek10Z1RNbGxUTHpNR054WVdPM1l6TDVjRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com/&#34;&gt;http://www.programering.com/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;전체 코드는 &lt;a href=&#34;http://algs4.cs.princeton.edu/53substring/RabinKarp.java.html&#34;&gt;RabinKarp.java&lt;/a&gt; 로&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RabinKarp {
	
	String pattern;
	long patternHash;
	int M;
	long Q;
	int R;
	long RM; // R^(M-1) % Q

	public RabinKarp(String pattern) {
		this.pattern = pattern;
		
		R = 25;
		M = pattern.length();
		Q = longRandomPrime();
		
		// pre-compute R^(M-1) % Q for use in removing leading digit
		RM = 1;
		for (int i = 1; i &amp;lt;= M-1; i++)
			RM = (RM * R) % Q;
		
		patternHash = hash(pattern, M);
	}
	
	private long hash(String key, int M) {
		long h = 0;
		
		for (int j = 0; j &amp;lt; M; j++)
			h = (R * h + key.charAt(j)) % Q; 
		return h;
	}
	
	private static long longRandomPrime() {
		BigInteger prime = BigInteger.probablePrime(31, new Random());
		return prime.longValue();
	}
	
	public int search(String docs) {
		int N = docs.length();
		long docsHash = hash(docs, M);
	
		if (docsHash == patternHash) return 0;
		
		for (int i = M; i &amp;lt; N; i++) {
			// remove leading digit
			docsHash = (docsHash + Q - RM * docs.charAt(i-M) % Q) % Q;
			// add trailing digit
			docsHash = (docsHash * R + docs.charAt(i)) % Q;
			
			// match
			if (patternHash == docsHash) return i - M + 1;
		}
		
		return N;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로, 해시값을 비교하는 것에는 두 가지 버전이 있다.&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Monte Carlo version:&lt;/strong&gt; return match if hash match&lt;br /&gt;
(2) &lt;strong&gt;Las Vegas version:&lt;/strong&gt; check for substring match if hash match and continue search if false collision.&lt;/p&gt;

&lt;p&gt;몬테 카를로는 확률적으로 여러번 구해서 맞는 값을 찾는거다. 근데 만약에 &lt;code&gt;Q&lt;/code&gt; 가 &lt;code&gt;MN^2&lt;/code&gt; 정도로 상당히 크다면, 충돌이 일어날 확률은 &lt;code&gt;1/N&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;실제 돌려보면 &lt;code&gt;Q&lt;/code&gt; 를 충분히 크게 고르되, 오버플로우가 안 일어나면 &lt;code&gt;1/Q&lt;/code&gt; 의 적은 확률로 충돌이 일어난다.&lt;/p&gt;

&lt;p&gt;따라서&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Monte Carlo version&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Always runs in linear time&lt;/li&gt;
&lt;li&gt;Extremely likely to return correct answer (but not always)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) &lt;strong&gt;Las Vegas version&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Always returns correct answer&lt;/li&gt;
&lt;li&gt;Extremely likely to run in linear time (but worst case is &lt;code&gt;M N&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;라스베가스 버전에서 &lt;em&gt;worst case&lt;/em&gt; 는, 충돌이 매번 나고 매번 검사하는건데. 그럴 일은 거의 없다.&lt;/p&gt;

&lt;h4 id=&#34;pros-and-cons&#34;&gt;Pros and cons&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;rabin-karp&lt;/em&gt; 알고리즘은 앞서 보았던 &lt;em&gt;KMP&lt;/em&gt; 나 &lt;em&gt;boyed moore&lt;/em&gt; 에 비해 장점이 있는데&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Extends to 2d patterns&lt;/li&gt;
&lt;li&gt;Extends to finding multiple patterns&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어서 다양한 패턴을 찾고싶다 하면, 그 패턴들의 심볼 테이블을 만들어 놓고 검색하면 된다.&lt;/p&gt;

&lt;p&gt;단점으로는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Arithmetic ops slower than char compares&lt;/li&gt;
&lt;li&gt;라스베가스 버전은 백업을 필요로 함&lt;/li&gt;
&lt;li&gt;poor worst case guarantee&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWTVNMlkxWVdOMUVXTXdJV0w0TWpZaDF5TjJrek10WTJZM0lXTDRjek5pSldabFIyTDBrRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;em&gt;Algorithms: Part 2&lt;/em&gt; by &lt;strong&gt;Ro$bert Sedgewick&lt;/strong&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://introcs.cs.princeton.edu/java/73dfa/&#34;&gt;http://introcs.cs.princeton.edu&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://math.stackexchange.com/questions/563829/difference-between-nfa-and-dfa&#34;&gt;Difference between NFA and DFA&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://www-igm.univ-mlv.fr/~lecroq/string/node4.html&#34;&gt;Automaton&lt;/a&gt;&lt;br /&gt;
(5) &lt;a href=&#34;http://somemoreacademic.blogspot.kr/2012/09/boyer-moore-string-matching-algorithm.html&#34;&gt;Boyer Moore string matching algorithm&lt;/a&gt;&lt;br /&gt;
(6) &lt;a href=&#34;http://xenostudy.tistory.com/72&#34;&gt;보이어 무어 알고리즘에 대한 고찰&lt;/a&gt;&lt;br /&gt;
(7) &lt;a href=&#34;http://terpconnect.umd.edu/~sthomas2/rabin-karp.html&#34;&gt;Rabin-Karp Algorithm&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Algorithm: Maximum Flow (Ford-Fulkerson)</title>
      <link>https://1ambda.github.io/91/algorithm/algorithm-part2-5/</link>
      <pubDate>Sat, 25 Jun 2016 13:01:21 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/algorithm-part2-5/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://graph-tool.skewed.de/static/doc/_images/example-edmonds-karp.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;min-cut&#34;&gt;Min Cut&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;edge weighted&lt;/em&gt; 그래프에서 &lt;code&gt;st&lt;/code&gt;-&lt;em&gt;cut&lt;/em&gt; 이란 &lt;em&gt;vertices&lt;/em&gt; 를 두개의 &lt;em&gt;disjont sets&lt;/em&gt; 으로 나누는 것이다. 이때 &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt; 는 각각 다른 집합 &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; 에 속해있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/0/02/Min-cut.svg/220px-Min-cut.svg.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://en.wikipedia.org&#34;&gt;http://en.wikipedia.org&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;capacity&lt;/strong&gt; 란 컷으로 나뉘어진 두 집합 &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; 를 기준으로 &lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;B&lt;/code&gt; 로 가기 위한 모든 &lt;em&gt;edge&lt;/em&gt; 의 &lt;em&gt;weight&lt;/em&gt; 를 모두 합친 것이다. &lt;code&gt;B&lt;/code&gt; 에서 &lt;code&gt;A&lt;/code&gt; 로의 &lt;em&gt;edge&lt;/em&gt; 는 세지 않는 다는 것에 주의하자.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;mincut problem&lt;/em&gt; 은 &lt;em&gt;min capacity&lt;/em&gt; 를 갖는 &lt;em&gt;cut&lt;/em&gt; 을 찾는 문제다. 응용으로는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;실제 전쟁에서 보급로를 끊거나&lt;/li&gt;
&lt;li&gt;독재 정부에서 커뮤니케이션을 제한하거나&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;max-flow&#34;&gt;Max Flow&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://kunuk.files.wordpress.com/2010/11/fordfulkerson1.gif?w=700&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://kunuk.wordpress.com&#34;&gt;http://kunuk.wordpress.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;edge&lt;/em&gt; 에 &lt;em&gt;weight&lt;/em&gt; 이외에도 &lt;em&gt;flow&lt;/em&gt; 를 할당할 수 있다. 이 플로우는 몇 가지 성질을 만족하는데&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;capacity constraint:&lt;/strong&gt; &lt;code&gt;0 &amp;lt;= edge&#39;s flow &amp;lt;= edge&#39;s capa&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;local equilibrium:&lt;/strong&gt; &lt;code&gt;inflow = outflow&lt;/code&gt; at every vertex except &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉 한 에지에서 캐퍼시티는 항상 플로우보다 크거나 같고, &lt;code&gt;s, t&lt;/code&gt; 를 제외한 모든 노드에서 &lt;em&gt;inflow = outflow&lt;/em&gt; 다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;flow&lt;/em&gt; 의 &lt;em&gt;value&lt;/em&gt; 는 &lt;code&gt;t&lt;/code&gt; 에서의 &lt;em&gt;inflow&lt;/em&gt; 다. 이때 &lt;code&gt;s&lt;/code&gt; 를 가리키는 노드가 없고, &lt;code&gt;t&lt;/code&gt; 가 가리키는 노드가 없다고 가정한다. 다시 말해 &lt;code&gt;s&lt;/code&gt; 는 시작점, &lt;code&gt;t&lt;/code&gt; 는 종료지점이다.&lt;/p&gt;

&lt;p&gt;따라서 플로우를 어떻게 할당하냐에 따라 &lt;em&gt;value&lt;/em&gt; 가 달라질 수 있다. 이 때 &lt;em&gt;maximum flow&lt;/em&gt; 문제는 최대 값을 갖는 &lt;em&gt;flow&lt;/em&gt; 를 찾는 문제다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;max flow&lt;/em&gt; 의 응용은&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;운송량을 최대로 하는 보급로를 찾기&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;summary&#34;&gt;Summary&lt;/h4&gt;

&lt;p&gt;정리하면 &lt;em&gt;weighted digraph&lt;/em&gt; 에서 &lt;em&gt;source vertex&lt;/em&gt; &lt;code&gt;s&lt;/code&gt;, &lt;em&gt;target vertex&lt;/em&gt; &lt;code&gt;t&lt;/code&gt; 에 대해&lt;/p&gt;

&lt;p&gt;두 가지 문제를 정의할 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;min cut:&lt;/strong&gt; Find a cut of minimum capacity&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max flow:&lt;/strong&gt; Find a flow of maximum value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사실 이 문제는 상당히 유사한데, &lt;em&gt;dual&lt;/em&gt; 관계다. 하나를 풀면 다른 하나도 풀 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;ford-fulkerson-algorithm&#34;&gt;Ford-Fulkerson Algorithm&lt;/h3&gt;

&lt;p&gt;기본적인 아이디어는 &lt;em&gt;augmenting path&lt;/em&gt; 를 찾으면서 &lt;em&gt;flow&lt;/em&gt; 값을 증가시키는 것이다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;forward edge&lt;/em&gt; (not full) 을 이용해서 &lt;em&gt;flow&lt;/em&gt; 값을 증가시키고&lt;/li&gt;
&lt;li&gt;&lt;em&gt;backward edge&lt;/em&gt; (not empty) 를 이용해서 감소시킬 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;backward edge&lt;/em&gt; 의 아이디어는 &lt;em&gt;local equilibrium&lt;/em&gt; 이다. 진행할 수 없는 상황에서 &lt;em&gt;backward edge&lt;/em&gt; 를 만들고, 거기서 &lt;em&gt;flow&lt;/em&gt; 의 평형을 맞추는 값만큼 뺀 후 다시 진행한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWXljek0wSTJNaWRqWTNZVEx6RWpaaDF5TTVZMk10TWpabVZUTDVNR1ppbHpZaUJ6TDNNek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;더이상 &lt;em&gt;augmenting path&lt;/em&gt; 를 찾을 수 없을 때 알고리즘이 종료된다. 이건 &lt;em&gt;full forward edge&lt;/em&gt; 가 존재하거나 &lt;em&gt;empty backword edge&lt;/em&gt; 가 만들어졌기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.cs.princeton.edu/courses/archive/spr13/cos226/lectures/summaries/maxFlowCheckpoint.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.cs.princeton.edu/&#34;&gt;http://www.cs.princeton.edu/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;알고리즘을 서술하면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Fold-Fulkerson algorithm

Start with 0 flow
While there exists an augmenting path
- find an augmenting path
- compute bottleneck capacity
- increase flow on that path by bottleneck capacity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그럼, 이제 문제는 &lt;em&gt;min cut&lt;/em&gt; 은 어떻게 계산하고 &lt;em&gt;augmenting path&lt;/em&gt; 는 어떻게 찾을지로 치환된다.&lt;/p&gt;

&lt;p&gt;그리고 추가적인 질문으로 &lt;em&gt;FF&lt;/em&gt; 알고리즘이 &lt;em&gt;max flow&lt;/em&gt; 를 찾는지, 그리고 항상 종료된다는 걸 보장하는지, 종료된다면 얼마만큼의 &lt;em&gt;augmentations&lt;/em&gt; 를 찾아내는지를 물어볼 수 있다.&lt;/p&gt;

&lt;p&gt;좀 더 자세한 알고리즘 설명은 이 &lt;a href=&#34;http://www.cs.princeton.edu/courses/archive/spring13/cos226/lectures/64MaxFlow.pdf&#34;&gt;슬라이드&lt;/a&gt; 를 참조할 것&lt;/p&gt;

&lt;h3 id=&#34;maxflow-mincut-theorem&#34;&gt;Maxflow-Mincut Theorem&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;cut&lt;/em&gt; 과 &lt;em&gt;flow&lt;/em&gt; 는 무슨 관계일까?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;net flow accros cut&lt;/em&gt; &lt;code&gt;(A, B)&lt;/code&gt; 는 &lt;code&gt;A-&amp;gt;B&lt;/code&gt; 로의 &lt;em&gt;flow&lt;/em&gt; 를 모두 합한 것에서 &lt;code&gt;B-&amp;gt;A&lt;/code&gt; 로의 &lt;em&gt;flow&lt;/em&gt; 를 모두 뺀 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5WWhKV1lsRkRaeVFtTTVZV0xtVkRPaTF5TTFjek10TXpZbGxUTGxCRE1pWkRaaFZ6TDVNek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;flow-value lemma:&lt;/em&gt; Let &lt;code&gt;f&lt;/code&gt; be any flow and let &lt;code&gt;(A, B)&lt;/code&gt; be any cut. Then the net flow accros &lt;code&gt;(A, B)&lt;/code&gt; equals the value of &lt;code&gt;f&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;B&lt;/code&gt; 의 사이즈에 대해 귀납법을 이용하면 증명은 어렵지 않다.&lt;/p&gt;

&lt;p&gt;(1) Base case &lt;code&gt;B = { t }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;base case&lt;/em&gt; 에선 당연히 &lt;em&gt;value&lt;/em&gt; 와 &lt;em&gt;net flow accros&lt;/em&gt; 가 동일하다.&lt;/p&gt;

&lt;p&gt;(2) Inductive case&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;B&lt;/code&gt; 로 &lt;em&gt;vertex&lt;/em&gt; 를 하나씩 옮겨도 &lt;em&gt;local equilibrium&lt;/em&gt; 이 참이므로 이 속성은 유지된다. 옮기려는 &lt;em&gt;vertex&lt;/em&gt; 를 &lt;code&gt;k&lt;/code&gt; 라 하면&lt;/p&gt;

&lt;p&gt;&lt;code&gt;k&lt;/code&gt; 를 기준으로 &lt;em&gt;inflow&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;A -&amp;gt; k&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B -&amp;gt; k&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;는 다음의 &lt;em&gt;outflow&lt;/em&gt; 와 동일하다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;k&lt;/code&gt; -&amp;gt; &lt;code&gt;A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k&lt;/code&gt; -&amp;gt; &lt;code&gt;B&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그런데 &lt;code&gt;k&lt;/code&gt; 를 &lt;code&gt;B&lt;/code&gt; 로 옮기게 되면 &lt;em&gt;net flow accros&lt;/em&gt; 에 미치는 영향이 &lt;em&gt;inflow&lt;/em&gt;, &lt;em&gt;outflow&lt;/em&gt; 간 반대가 되지만 어쨌든 &lt;em&gt;local equilibrium&lt;/em&gt; 에 의해 값은 같으므로 어차피 &lt;em&gt;value&lt;/em&gt; 와 같다.&lt;/p&gt;

&lt;p&gt;그리고 결국 &lt;code&gt;k&lt;/code&gt; 를 계속 옮기다 보면&lt;code&gt;s&lt;/code&gt; 의 &lt;em&gt;outflow&lt;/em&gt; 는 &lt;code&gt;t&lt;/code&gt; 의 &lt;em&gt;inflow&lt;/em&gt; 와 같고 이것인 &lt;em&gt;value of flow&lt;/em&gt; 와 같다.&lt;/p&gt;

&lt;h4 id=&#34;weak-duality&#34;&gt;Weak Duality&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;weak duality&lt;/em&gt; 란 &lt;code&gt;f&lt;/code&gt; 를 아무 플로우, &lt;code&gt;(A, B)&lt;/code&gt; 를 어느 컷이라 할 때&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;value of flow&lt;/em&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;em&gt;capacity of cut&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 성립함을 말한다. 따라서 &lt;em&gt;max flow&lt;/em&gt; 는 &lt;em&gt;min cut&lt;/em&gt; 이다. 증명과정을 좀 보자. 위에서 귀납법으로 참임을 보인 성질에 의해 다음이 성립한다. &lt;del&gt;뜬금없이 증명해버림&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;value of flow&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; = *net flow accros &lt;code&gt;(A, B)&lt;/code&gt; &amp;lt;= capacity of &lt;code&gt;(A, B)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Augmenting path theorem:&lt;/strong&gt; A flow &lt;code&gt;f&lt;/code&gt; is a maxflow iff no augmenting paths&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Maxflow-mincut theorem:&lt;/strong&gt; Value of the maxflow = capacity of mincut&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉 이 말은 &lt;del&gt;동어 반복의 향연&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;(1) 플로우 &lt;code&gt;f&lt;/code&gt; 의 &lt;em&gt;value&lt;/em&gt; 와 동일한 값의 &lt;em&gt;capacity&lt;/em&gt; 를 가지는 어떤 컷이 있다.&lt;br /&gt;
(2) &lt;code&gt;f&lt;/code&gt; 는 &lt;em&gt;max flow&lt;/em&gt; 다&lt;br /&gt;
(3) &lt;code&gt;f&lt;/code&gt; 에 대해 &lt;em&gt;augmenting path&lt;/em&gt; 가 없다.&lt;/p&gt;

&lt;p&gt;정리해 보면 &lt;em&gt;max flow&lt;/em&gt; 로 부터 &lt;em&gt;min cut&lt;/em&gt; 을 계산할 수 있다는 소리가 된다. 잘 보면 &lt;em&gt;max flow&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; 에서는 &lt;em&gt;augmenting path&lt;/em&gt; 가 없다.&lt;/p&gt;

&lt;p&gt;다시 말해&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;한 집합은 &lt;code&gt;s&lt;/code&gt; 에서 &lt;em&gt;non-full forward&lt;/em&gt; 로 출발하지만 &lt;em&gt;empty backward&lt;/em&gt; 에 의해 막히고&lt;/li&gt;
&lt;li&gt;다른 집단은 &lt;em&gt;full foraward&lt;/em&gt; 때문에 &lt;code&gt;t&lt;/code&gt; 로의 &lt;em&gt;non empty backword&lt;/em&gt; 가 막힌다.&lt;/li&gt;
&lt;li&gt;이 두집단의 자르는 &lt;em&gt;cut&lt;/em&gt; 은 &lt;em&gt;full forward&lt;/em&gt;, &lt;em&gt;empty backward&lt;/em&gt; 로만 구성된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 컷은 &lt;em&gt;net flow accros cut&lt;/em&gt; 고 첫번째 집단은 &lt;code&gt;A&lt;/code&gt;, 두번째 집단은 &lt;code&gt;B&lt;/code&gt; 가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWjVZR05sSlRPaE4yTm1KVEw1TVdZNTBDTzJnek10VW1ZaUZXTG1CRFpoRkRaaU56THpRek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;따라서 러닝타임은 &lt;em&gt;max flow&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; 가 주어진다면 모든 &lt;em&gt;vertex&lt;/em&gt;, &lt;em&gt;edge&lt;/em&gt; 를 한번씩 보며 &lt;code&gt;A&lt;/code&gt; 를 찾는 시간이므로 &lt;code&gt;V + E&lt;/code&gt; 다.&lt;/p&gt;

&lt;h3 id=&#34;running-time-analysis&#34;&gt;Running Time Analysis&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5WTBJRE40a3pNMklXWW1KVEx5SVRaNTB5WWpaek10QVROaGhUTGlSV1lqUkdPM1V6TDNRek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com&#34;&gt;http://www.programering.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;아까 했던 질문들에 답해보면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;mincut&lt;/em&gt; 을 계산하긴 쉽다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;BFS&lt;/em&gt; 로 &lt;em&gt;augmenting path&lt;/em&gt; 를 찾을 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Ford-Fulkerson&lt;/em&gt; 이 종료되면 &lt;em&gt;max flow&lt;/em&gt; 를 찾을 수 있다&lt;/li&gt;
&lt;li&gt;&lt;em&gt;capacity&lt;/em&gt; 가 정수거나, &lt;em&gt;argumenting path&lt;/em&gt; 를 신중히 고른다면 &lt;em&gt;FF&lt;/em&gt; 는 종료된다.&lt;/li&gt;
&lt;li&gt;얼마나 많은 &lt;em&gt;augmentations&lt;/em&gt; 가 있을진 생각좀 해봐야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;간단한 경우부터 좀 보자.&lt;/p&gt;

&lt;h4 id=&#34;integer-capacities&#34;&gt;Integer Capacities&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;edge capacities&lt;/em&gt; 가 &lt;code&gt;[1, U]&lt;/code&gt; 사이의 값이면 &lt;em&gt;FF&lt;/em&gt; 알고리즘에 걸쳐서 모든 &lt;em&gt;flow&lt;/em&gt; 값은 정수다. 쉽게 증명 가능한데&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bottleneck capacity is an integer&lt;/li&gt;
&lt;li&gt;Flow on an edge increases / decreases by bottleneck capa&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;# of augmentations &amp;lt;= max flow value&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다시 말해 &lt;em&gt;augmentations&lt;/em&gt; 의 수는 &lt;em&gt;max flow value&lt;/em&gt; 보다 작거나 같다. 왜냐하면 처음에 &lt;code&gt;0&lt;/code&gt; 부터 시작해서 매 &lt;em&gt;augmentation&lt;/em&gt; 마다 적어도 &lt;em&gt;value&lt;/em&gt; 를 1 씩 증가시키기 때문이다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Integrality theorem:&lt;/strong&gt; There exists an integer-values maxflow&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 때 &lt;em&gt;FF&lt;/em&gt; 알고리즘이 종료되면 &lt;em&gt;max flow&lt;/em&gt; 를 찾아내고, 이것은 위에서 보였듯이 &lt;em&gt;integer-value&lt;/em&gt; 를 가진다.&lt;/p&gt;

&lt;h4 id=&#34;bad-case-for-ff&#34;&gt;Bad case for FF&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTW1Oek15RW1Zd0FqTWlWVExpbHpZNTBDWmhSMk10VURad01UTDJZek1oTldNeEl6THhVek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com&#34;&gt;http://www.programering.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;integer value max flow&lt;/em&gt; 에선 운이 나쁠 경우 &lt;em&gt;max flow value&lt;/em&gt; 만큼 &lt;em&gt;augmentation&lt;/em&gt; 이 일어난다. 위 슬라이드에서 볼 수 있듯이 그래프 사이즈에 비해 어마어마한 &lt;em&gt;augmentation&lt;/em&gt; 이 일어날 수 있다.&lt;/p&gt;

&lt;p&gt;다행히도 &lt;em&gt;shortest, fattest path&lt;/em&gt; 를 이용해 이런 상황을 피할 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;shortest path:&lt;/em&gt; augmenting path with &lt;strong&gt;fuwest number of edges&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;fattest path:&lt;/em&gt; augmenting path with &lt;strong&gt;maximum bottleneck capacity&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5WWtWMk4yTUdNbFZUWmpWVEx6UVdZaTFDTWtOMk10UVdNaUJUTGlaR1owTVRNbVoyTDFVek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com&#34;&gt;http://www.programering.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;FF&lt;/em&gt; 알고리즘의 성능은 어떤 &lt;em&gt;augmenting path&lt;/em&gt; 를 선택하느냐에 따라 달라질 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Ford-Fulkerson&lt;/em&gt; 알고리즘을 구현함에 있어서 실제로 사용하게 될 값은 두 가지다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;forward edge residual capacity&lt;/em&gt; = &lt;code&gt;c - f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;backward edge residual capacity&lt;/em&gt; = &lt;code&gt;f&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 &lt;em&gt;flow&lt;/em&gt;, &lt;em&gt;capacity&lt;/em&gt; 보다는 &lt;em&gt;residual capacity&lt;/em&gt; 를 &lt;em&gt;edge&lt;/em&gt; 의 가중치로 표시하는 &lt;em&gt;residual network&lt;/em&gt; 를 이용하는편이 더 직관적이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTT2lSMk1rRkdNNGN6WTVVVExsRjJZNTB5WWlsek10RVRPeVFXTDRjak41TVRObVp6TDNVek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com&#34;&gt;http://www.programering.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;실제 클래스 구현은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FlowEdge {
  
  private final int v, w;
  private final double capacity;
  private double flow;
  
  public FlowEdge(int v, int w, double capacity) {
    this.v = v; 
    this.w = w;
    this.capacity = capacity;
  }
  
  public int from() { return v; }
  public int to() { return w; }
  public double capacity() { return capacity; }
  public double flow() { return flow; }
  
  // other endpoint
  int other(int vertex) {
    if (vertex == v) return w;
    else if (vertex == w) return v;
    else throw new RuntimeException(&amp;quot;Illegal endpoint&amp;quot;);
  }
  
  // residual capacity toward v
  double residualCapacityTo(int vertex) {
    if (vertex == v)      return flow;            // backward edge
    else if (vertex == w) return capacity - flow; // forward edge
    else throw new IllegalArgumentException();
  }
  
  // add delta flow toward v
  void addResidualFlowTo(int vertex, double delta) {
    if (vertex == v)      flow -= delta; // backward edge
    else if (vertex == w) flow += delta; // forward edge
    else throw new IllegalArgumentException();
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FlowNetwork&lt;/code&gt; 는&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FlowNetwork {
  private final int V;
  // Bag is a list without remove op
  private Bag&amp;lt;FlowEdge&amp;gt;[] adj;
  
  public FlowNetwork(int V) {
    this.V = V;
    adj = (Bag&amp;lt;FlowEdge&amp;gt;[]) new Bag[V];
    for (int v = 0; v &amp;lt; V; v++)
      adj[v] = new Bag&amp;lt;FlowEdge&amp;gt;();
  }
  
  public void addEdge(FlowEdge e) {
    int v = e.from();
    int w = e.to();
    adj[v].add(e); // add forward edge
    adj[w].add(e); // add backward edge
  }
  
  public Iterable&amp;lt;FlowEdge&amp;gt; adj(int v) { 
    return adj[v];
  }

  public int V() { return V; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;FF&lt;/em&gt; 알고리즘 구현은 아래와 같다. &lt;em&gt;shortest augmenting path&lt;/em&gt; 를 찾기 위해 &lt;em&gt;BFS&lt;/em&gt; 를 이용했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FordFulkerson {

  private boolean[] marked;  // ture if s-&amp;gt;v path in residual network
  private FlowEdge[] edgeTo; // last edge on s-&amp;gt;v path
  private double value;      // value of flow
  
  public FordFulkersen(FlowNetwork G, int s, int t) {
    value = 0.0;
    
    while (hasAugmentingPath(G, s, t)) {
      double bottle = Double.POSITIVE_INFINITY;
      
      // compute bottleneck capacity
      for (int v = t; v != s; v = edgeTo[v].other(v))
        bottle = Math.min(bottle, edgeTo[v].residualCapacityTo(v));
      
      // augment flow
      for (int v = t; v != s; v = edgeTo[v].other(v))
        edgeTo[v].addResidualFlowTo(v, bottle);
      
      value += bottle;
    }
  }

  // find a shortest augmenting path using BFS
  private boolean hasAugmentingPath(FlowNetwork G, int s, int t) {
    edgeTo = new FlowEdge[G.V()];
    marked = new boolean[G.V()];
    
    Queue&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;Integer&amp;gt;();
    q.add(s);
    marked[s] = true;
    
    while (!q.isEmpty()) {
      int v = q.remove();
      
      for (FlowEdge e : G.adj(v)) {
        int w = e.other(v);
        
        // path s-&amp;gt;w is in the residual network?
        if (e.residualCapacityTo(w) &amp;gt; 0 &amp;amp;&amp;amp; !marked[w]) {
          edgeTo[w] = e;
          marked[w] = true;
          q.add(w);
        }
      }
    }
    
    return marked[t];
  }
  
  public double value() { return value; }
  // is `v` reachable from s in residual network?
  public boolean inCut(int v) { return marked[v]; } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/en/thumb/0/0e/Max-flow_min-cut_example.svg/288px-Max-flow_min-cut_example.svg.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://en.wikipedia.org&#34;&gt;http://en.wikipedia.org&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;테스트 코드도 좀 돌려보자. 예제는 위와 같고, 코드는 아래에 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FordFulkensonTest {

  @Test
  public void test() {
    int E = 5;
    
    int s = 0;
    int t = 3;
   
    // http://en.wikipedia.org/wiki/Max-flow_min-cut_theorem#Example
    FlowEdge[] edges = new FlowEdge[E];
    edges[0] = new FlowEdge(s, 1, 4.0);
    edges[1] = new FlowEdge(s, 2, 3.0);
    edges[2] = new FlowEdge(1, 2, 3.0);
    edges[3] = new FlowEdge(1, t, 4.0);
    edges[4] = new FlowEdge(2, t, 5.0);
   
    int V = 4;
    FlowNetwork G = new FlowNetwork(V);
    
    for (FlowEdge e : edges)
      G.addEdge(e);
     
    FordFulkerson FF = new FordFulkerson(G, s, t);
    
    assert(FF.value() == 7);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;max-flow-application&#34;&gt;Max Flow Application&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;shortest path&lt;/em&gt; 처럼 &lt;em&gt;max flow&lt;/em&gt; 도 정말 많은 곳에 응용할 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bipartite maching&lt;/li&gt;
&lt;li&gt;Network reliability&lt;/li&gt;
&lt;li&gt;Baseball elimination&lt;/li&gt;
&lt;li&gt;Image segmentation&lt;/li&gt;
&lt;li&gt;Distributed computing&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;bipartite-maching-problem&#34;&gt;Bipartite maching problem&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTTRNalowTVdPNE1UTTBVV0x6TVRONDBDTzFVMk10WUROakZUTDJVMk0wVUROa056THhZek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com&#34;&gt;http://www.programering.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;N&lt;/code&gt; 명의 &lt;em&gt;student&lt;/em&gt; 가 &lt;code&gt;N&lt;/code&gt; 개의 &lt;em&gt;company&lt;/em&gt; 로부터 각각 몇개씩의 주문을 받았을 때, &lt;code&gt;1:1&lt;/code&gt; 로 대응하는 그래프를 그릴 수 있느냐의 문제다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;max flow&lt;/em&gt; 알고리즘을 이용해 &lt;em&gt;bipartite maching&lt;/em&gt; 문제를 풀 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, one vertex for each student, and one vertex for each company(job)&lt;/li&gt;
&lt;li&gt;Add edge from &lt;code&gt;s&lt;/code&gt; to each student (capacity 1)&lt;/li&gt;
&lt;li&gt;Add edge from each job to &lt;code&gt;t&lt;/code&gt; (capacity 1)&lt;/li&gt;
&lt;li&gt;Add edge from student to each job offered (infinite capacity)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게하면 &lt;em&gt;local equilibrium&lt;/em&gt; 에 의해 각 &lt;em&gt;student&lt;/em&gt; 마다 하나씩의 &lt;em&gt;out-flow&lt;/em&gt; 밖에 가지지 못하고, 마찬가지로 &lt;em&gt;job&lt;/em&gt; 도 하나씩의 &lt;em&gt;in-flow&lt;/em&gt; 밖에 가지지 못하므로 &lt;code&gt;1:1&lt;/code&gt; 대응을 만들 수 있다.&lt;/p&gt;

&lt;p&gt;완벽히 매칭이 이루어지는지, 아닌지를 &lt;em&gt;min cut&lt;/em&gt; 을 이용해 알 수 있다. 그림을 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTm1OV08xSUdOd1VtWTJNVExsQnpNaDFTWjJRek10WXpNaUZUTGlWMk4wZ1ROa0p6THpZek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com&#34;&gt;http://www.programering.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Let &lt;code&gt;S&lt;/code&gt; = students on &lt;code&gt;s&lt;/code&gt; side of cut.&lt;/li&gt;
&lt;li&gt;Let &lt;code&gt;T&lt;/code&gt; = companies on &lt;code&gt;s&lt;/code&gt; side of cut.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|S|&lt;/code&gt; &amp;gt; &lt;code&gt;|T|&lt;/code&gt;; students in &lt;code&gt;S&lt;/code&gt; can be matched only to companies in &lt;code&gt;T&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;baseball-elimination&#34;&gt;Baseball elimination&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5TWhWVE9oZERNeGNET2paVEx6a0RPaDFDTm1WMk10UXpNMllUTGhKVFppSlRZME16TDFZek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com&#34;&gt;http://www.programering.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Which teams have a chance of finishing the season with the most wins?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이건 게임이 얼마나 남았느냐 뿐만 아니라, 누구와 상대하냐도 문제가 되기 때문에 이렇게 그래프를 그려 풀 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTTm1SR08yVTJZMlFqTTRnVEwxTURNaTFTWmpoek10TVRZaVJXTDJFMk5sSkdPakp6TDNZek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com&#34;&gt;http://www.programering.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;여기서 디트로이트 (&lt;code&gt;4&lt;/code&gt;) 는 수학적으로 봤을때 우승이 불가능하므로 미리 제거했다. 그리고, &lt;code&gt;s&lt;/code&gt; 에서 출발하는 &lt;em&gt;edge&lt;/em&gt; 를 각 팀간 남은 경기로, 그리고 &lt;code&gt;t&lt;/code&gt; 로 들어가는 &lt;em&gt;edge&lt;/em&gt; 를 디트로이트의 남은경기, 이긴경기에서 해당 팀의 이긴경기를 빼서 &lt;em&gt;upper bound&lt;/em&gt; 를 설정한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Team 4 (디트로이트) not eliminated iff all edges pointing from &lt;code&gt;s&lt;/code&gt; are full in max flow&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;performance&#34;&gt;Performance&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;max flow&lt;/em&gt; 문제의 경우 &lt;em&gt;FF&lt;/em&gt; 알고리즘을 이용하면 &lt;em&gt;worst case&lt;/em&gt; 에서 &lt;code&gt;E^2U&lt;/code&gt; 성능이 나온다고 한다. 근데 이건 1955년도에 발견된 알고리즘이고, 가장 최근에는 &lt;em&gt;compact network&lt;/em&gt; 라는 기법이 2012년에 만들어졌다. 이건 &lt;code&gt;E^2 / log E&lt;/code&gt; 의 &lt;em&gt;worst case performance&lt;/em&gt; 라고 함.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;em&gt;Algorithms: Part 2&lt;/em&gt; by &lt;strong&gt;Ro$bert Sedgewick&lt;/strong&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://introcs.cs.princeton.edu/java/73dfa/&#34;&gt;http://introcs.cs.princeton.edu&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;https://graph-tool.skewed.de/static/doc/flow.html&#34;&gt;https://graph-tool.skewed.de/&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://en.wikipedia.org/wiki/Cut_(graph_theory)&#34;&gt;Wikipedia: Cut&lt;/a&gt;&lt;br /&gt;
(5) &lt;a href=&#34;http://kunuk.wordpress.com/2010/11/09/graph-flow-ford-fulkerson-algorithm-example-with-c/&#34;&gt;http://kunuk.wordpress.com - Flow&lt;/a&gt;&lt;br /&gt;
(6) &lt;a href=&#34;http://www.programering.com/a/MDN0gDNwATY.html&#34;&gt;http://www.programering.com&lt;/a&gt;&lt;br /&gt;
(7) &lt;a href=&#34;http://en.wikipedia.org/wiki/Max-flow_min-cut_theorem#Example&#34;&gt;Wikipeda - Max Flow&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Algorithm: Data Compression, Huffman, LZW</title>
      <link>https://1ambda.github.io/91/algorithm/algorithm-part2-6/</link>
      <pubDate>Sat, 25 Jun 2016 13:01:22 +0900</pubDate>
      
      <guid>https://1ambda.github.io/91/algorithm/algorithm-part2-6/</guid>
      <description>

&lt;h3 id=&#34;data-compression&#34;&gt;Data Compression&lt;/h3&gt;

&lt;p&gt;주된 이유는 전송 시간과 저장 공간을 절약하기 위해서다. 무어의 법칙이 말해주듯이 제품의 성능은 점점 좋아지는데, 그럼에도 불구하고 사람들이 만들어 내는 데이터의 양은 더 급격히 증가한다. 그래서 압축이 필요하다.&lt;/p&gt;

&lt;p&gt;이번시간에 배울 기법은 3 가지다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Run-length&lt;/li&gt;
&lt;li&gt;Huffman&lt;/li&gt;
&lt;li&gt;LZW&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;data compression&lt;/em&gt; 응용은&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;generic file compression&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GZIP 같은 파일 압축이나, PKZIP 같은 아키이빙. 그리고 파일시스템에서도 압축을 할 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;multimedia&lt;/em&gt;, &lt;em&gt;communication&lt;/em&gt;, &lt;em&gt;database&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;GIF&lt;/em&gt;, &lt;em&gt;MP3&lt;/em&gt;, &lt;em&gt;V.42 bis model&lt;/em&gt;(?) 등 다양한 곳에 압축을 활용한다고 한다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTT2paRE5qTnpZMEVXTjNNVEw0Z1RONDBDTjFFMk10RWpad0VUTGtWRE41SWpNMGt6THlnVE0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com&#34;&gt;http://www.programering.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;강의에서 사용하는 용어를 좀 정리하고 가자. 바이너리 &lt;code&gt;B&lt;/code&gt; 에 대해 &lt;em&gt;compression, 압축&lt;/em&gt; &lt;code&gt;C(B)&lt;/code&gt; 를 하고 &lt;em&gt;expansion, 복원(?)&lt;/em&gt; 를 해서 &lt;code&gt;B&lt;/code&gt; 를 얻는다. 중요한점은 &lt;em&gt;loseless&lt;/em&gt; 여야 한다는 것.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;compression ratio&lt;/em&gt; 는 &lt;code&gt;C(B) / B&lt;/code&gt; 로 정의한다. &lt;em&gt;natural language&lt;/em&gt; 의 경우 &lt;code&gt;50~75%&lt;/code&gt; 이상의 압축이 가능하다고 한다.&lt;/p&gt;

&lt;h4 id=&#34;binary-stream&#34;&gt;Binary Stream&lt;/h4&gt;

&lt;p&gt;구현에 사용할 바이너리 스트림 API 를 보자. 코드는 &lt;a href=&#34;http://introcs.cs.princeton.edu/java/stdlib/BinaryStdIn.java.html&#34;&gt;BinaryStdIn.java&lt;/a&gt; &lt;a href=&#34;http://introcs.cs.princeton.edu/java/stdlib/BinaryStdOut.java.html&#34;&gt;BinaryStdOut.java&lt;/a&gt; 에서 구할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BinaryStdIn {
    boolean readBoolean() {} //read 1 bit and return as a boolean
    char readChar() {} //read 8 bits and return as a char
    char readChar(int r) {} //read r bitsand return as a char
    [similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits)]
    boolean isEmpty() {} //is the bitstream empty?
    void close() {} //close the bitstream
}

public class BinaryStdOut {
    void write(boolean b) {} //write the specified bit
    void write(char c) {} //write the specified 8-bit char
    void write(char c, int r) {} //write the r least significant bits of the specified char
    [similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits)]
    void close() {} //close the bitstream
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;찾아보니까 자바에서 기본적으로 제공되는건 &lt;code&gt;ByteArrayStream&lt;/code&gt; 이 있더라.&lt;/p&gt;

&lt;h4 id=&#34;data-representation&#34;&gt;Data Representation&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;12/31/1999&lt;/code&gt; 를 표시하는 법을 생각해 보자.&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;char&lt;/code&gt; 면 &lt;em&gt;8 bit&lt;/em&gt;  10개니까 &lt;em&gt;80 bit&lt;/em&gt;&lt;br /&gt;
(2) &lt;code&gt;int&lt;/code&gt;  면 &lt;em&gt;32 bit&lt;/em&gt;  3개니까 &lt;em&gt;96 bit&lt;/em&gt;&lt;br /&gt;
(3) &lt;code&gt;bit&lt;/code&gt; 단위를 지정할 수 있다면 &lt;em&gt;4 + 5 + 12 + 3(align) = 24 bit&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;month = 12
day = 31
year = 199

BinaryStdOut.write(month, 4)
BinaryStdOut.write(day, 5)
BinaryStdOut.write(year, 12)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이는 데이터 표현만 잘 해도 알고리즘 없이 상당부분 압축할 수 있다는 소리다. 일레로 1990년도에 만들어졌던 유전자 데이터베이스는 아스키로 &lt;code&gt;AGCT&lt;/code&gt; 를 표현했다고 한다. 4종류의 문자밖에 없으니까 &lt;em&gt;2 bit&lt;/em&gt; 로 표현 가능함에도 불구하고&lt;/p&gt;

&lt;h3 id=&#34;universal-data-compression&#34;&gt;Universal Data Compression&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;No algorithm can compress every bitstring&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;contraction&lt;/em&gt; 을 이용해 증명하면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;모든 비트스트림을 압축할 수 있는 알고리즘 &lt;code&gt;U&lt;/code&gt; 가 있다 하자.&lt;/li&gt;
&lt;li&gt;주어진 비트스트링 &lt;code&gt;b0&lt;/code&gt; 을 압축해서 더 작은 사이즈의 &lt;code&gt;b1&lt;/code&gt; 을 얻고&lt;/li&gt;
&lt;li&gt;이 과정을 반복하면 사이즈가 &lt;code&gt;0&lt;/code&gt; 이 될때까지 압축이 가능하다. 이건 말이 안된다.&lt;/li&gt;
&lt;li&gt;따라서 모든 비트스트림을 압축할 수 있는 알고리즘 &lt;code&gt;U&lt;/code&gt; 는 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;run-length-encoding&#34;&gt;Run-Length Encoding&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;0000000000000001111111000000011111111111&lt;/code&gt; 의 비트가 있을때 &lt;em&gt;n-bit&lt;/em&gt; 로 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 의 &lt;em&gt;runs&lt;/em&gt; (긴 나열을 말하는 듯함) 을 표시한다.&lt;/p&gt;

&lt;p&gt;예를 들어 위의 데이터를 4비트 카운트를 이용해 표시하면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin  1111 0111 0111 1011
dec    15    7    7   11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약에 &lt;em&gt;run&lt;/em&gt; 의 길이가 지정된 &lt;em&gt;n-bit&lt;/em&gt; 로 표시할 수 있는 수보다 크면 &lt;code&gt;0&lt;/code&gt; 부터 다시 세면 된다. &lt;em&gt;JPEG&lt;/em&gt;, &lt;em&gt;ITU-T T4 Group 3&lt;/em&gt; 등에 응용한다고 함.&lt;/p&gt;

&lt;p&gt;구현은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// http://algs4.cs.princeton.edu/55compression/RunLength.java.html
public class RunLength {

  private final static int R = 256; // max run-length count
  private final static int lgR = 8; // # of bits per count
  
  public static void compress() {
    int run = 0;
    boolean old = false;
    
    while (!BinaryStdIn.isEmpty()) {
      boolean current = BinaryStdIn.readBoolean();
      
      // alternate bit
      if (current != old) {
        BinaryStdOut.write(run, lgR);
        run = 1;
        old = !old;
      }
      // same bit
      else {
        // max count
        if (run == R - 1) {
          BinaryStdOut.write(run, lgR);
          // print dummy alternate bit whose length is 0
          run = 0;
          BinaryStdOut.write(run, lgR); 
        }
        
        run++;
      }
    }
    
    BinaryStdOut.write(run, lgR);
    BinaryStdOut.close();
  }
  
  public static void expand() {
    boolean bit = false;
    
    while (!BinaryStdIn.isEmpty()) {
      int run = BinaryStdIn.readInt(lgR); // read lgR bit
      
      for (int i = 0; i &amp;lt; run; i ++)
        BinaryStdOut.write(bit);
      
      bit = !bit;
    }
    
    BinaryStdOut.close();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;del&gt;테스틀 어찌해야하는가&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://help.adobe.com/en_US/Director/11.0/images/vector_bitmap_image.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://help.adobe.com&#34;&gt;http://help.adobe.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;bitmap&lt;/em&gt; 을 압축하는데 &lt;em&gt;run-length&lt;/em&gt; 를 사용하면 효과적이다. 글자에서 대부분의 비트가 &lt;code&gt;0&lt;/code&gt; (흰색) 이기 때문이다.&lt;/p&gt;

&lt;p&gt;흑백 그림을 예로 들어보자. 인치당 &lt;code&gt;300&lt;/code&gt; 픽셀이고, 사이즈가 &lt;code&gt;8.5 x 11&lt;/code&gt; 인치라 했을때, 한 이미지를 표시하기 위해 필요한 비트는 &lt;code&gt;300 * 8.5 * 300 * 11&lt;/code&gt; = &lt;code&gt;8.415&lt;/code&gt; 백만 비트가 필요하다.&lt;/p&gt;

&lt;h3 id=&#34;huffman-encoding&#34;&gt;Huffman Encoding&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;fixed-length code&lt;/em&gt; 말고 모스코드같은 &lt;em&gt;variable-length code&lt;/em&gt; 를 생각해 보자.&lt;/p&gt;

&lt;p&gt;모스코드에서 &lt;code&gt;* * * - - - * * *&lt;/code&gt; 는 여러 방법으로 해석될 수 있다. &lt;code&gt;SOS&lt;/code&gt;, &lt;code&gt;V7&lt;/code&gt;, &lt;code&gt;IAMIE&lt;/code&gt;, &lt;code&gt;EEWNI&lt;/code&gt; 모두 가능하다. 모호한것이다. 모스부호에서는 이 문제를 해결하기 위해 글자마다 갭을 두어, 올바르게 해석될 수 있도록 한다.&lt;/p&gt;

&lt;p&gt;인코딩에서 &lt;em&gt;ambiguity&lt;/em&gt; 를 해결하려면 어떤 &lt;em&gt;codeword&lt;/em&gt; 도 다른 &lt;em&gt;code word&lt;/em&gt; 의 &lt;em&gt;prefix&lt;/em&gt; 가 되지 않도록 해야 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fixed-length code&lt;/li&gt;
&lt;li&gt;Append special stop char to each codeword (e.g 모스)&lt;/li&gt;
&lt;li&gt;Prefix-free code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 중에서 &lt;em&gt;prefix-free&lt;/em&gt; 인 코드를 만드는법을 살펴보자. &lt;em&gt;binary trie&lt;/em&gt; 를 만들어 &lt;em&gt;leaf&lt;/em&gt; 에 문자를 놓고, 그 문자까지 도달하는 경로가 인코딩 값이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTjJRVE9tTnpZemdETjVVVEw0UTJZaTF5WXdVek10WWpNNUlXTDJRek5oZFRPaWR6THlrVE0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com&#34;&gt;http://www.programering.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;compression&lt;/em&gt; 을 위해 심볼테이블을 만들거나, 아니면 &lt;em&gt;leaf&lt;/em&gt; 부터 따라 올라가고, 그 &lt;em&gt;path&lt;/em&gt; 를 뒤집어 출력할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;expansion&lt;/em&gt; 은 루트부터 시작해서 &lt;em&gt;path&lt;/em&gt; 를 따라 내려가다가 &lt;em&gt;leaf&lt;/em&gt; 에서 만나는 문자를 출력하면 된다.&lt;/p&gt;

&lt;p&gt;한가지 생각해 볼 것은, 빈도가 많은 문자를 짧은 인코딩 값(&lt;em&gt;path&lt;/em&gt;) 를 가지도록 해야 압축률이 높아진다는 것이다. 이를 위해 각 문자의 &lt;em&gt;frequency&lt;/em&gt; 를 이용해야 한다.&lt;/p&gt;

&lt;p&gt;허프만 코드 API를 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Huffman {

	// support extended ASCII
	private static final int R = 256;
	
	private static class Node implements Comparable&amp;lt;Node&amp;gt; {

		private char ch;
		private int  freq;
		private final Node left, right;
	
		public Node(char ch, int freq, Node left, Node right) {
			this.ch = ch;
			this.freq = freq;
			this.left = left;
			this.right = right;
		}
	
		public boolean isLeaf() {
			return left == null &amp;amp;&amp;amp; right == null;
		}

		@Override
		public int compareTo(Node that) {
			return this.freq - that.freq;
		}
	}
	
	public static void compress()
	public static void expand()
	private static Node buildTrie(int[] freq)
	private static void writeTrie(Node x)
	private static void buildCode(String[] st, Node x, String s)
	private static Node readTrie()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;em&gt;expansion&lt;/em&gt; 을 구현하자. 스트림의 가장 첫 부분에, 몇 개의 문자인지를 &lt;em&gt;int&lt;/em&gt; 로 표시하는 규약을 정하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void expand() {
  Node root = readTrie(); // read in encoding trie
  int N = BinaryStdIn.readInt(); // read in # of chars
  
  for (int i = 0; i &amp;lt; N; i++) {
    Node x = root;
    while (!x.isLeaf()) {
      if (!BinaryStdIn.readBoolean())
        x = x.left;  // 0
      else
        x = x.right; // 1
    }
    
    BinaryStdOut.write(x.ch, 8); // print char
  }
  
  BinaryStdOut.close();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;running time&lt;/em&gt; 은 &lt;code&gt;N&lt;/code&gt; 에 비례한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;expansion&lt;/em&gt; 하는 쪽에서도 &lt;em&gt;trie&lt;/em&gt; 를 가지고 있어야한다. &lt;em&gt;trie&lt;/em&gt; 를 전송하기 위해 &lt;code&gt;writeTrie&lt;/code&gt; 함수를 만들어 보자. &lt;em&gt;trie&lt;/em&gt; 를 &lt;em&gt;preorder&lt;/em&gt; 로 순회하면서 &lt;em&gt;leaf&lt;/em&gt; 의 경우 &lt;code&gt;1&lt;/code&gt; 과 문자 값을, &lt;em&gt;internal node&lt;/em&gt; 의 경우 &lt;code&gt;0&lt;/code&gt; 을 출력한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;private static void writeTrie(Node x) {
  if (x.isLeaf()) {
    BinaryStdOut.write(true); // leaf
    BinaryStdOut.write(x.ch, 8);
    return;
  }
  
  BinaryStdOut.write(false);
  writeTrie(x.left);
  writeTrie(x.right);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이러면 비트스트림으로 온 &lt;em&gt;trie&lt;/em&gt; 를 해석하는 함수 &lt;code&gt;readTrie&lt;/code&gt; 를 만들자. 마찬가지로 &lt;em&gt;pre-order&lt;/em&gt; 로 읽는다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static Node readTrie() {
  // leaf
  if (BinaryStdIn.readBoolean()) {
    char c = BinaryStdIn.readChar(8);
    return new Node(c, 0, null, null);
  }
  
  Node l = readTrie(); 
  Node r = readTrie();
  return new Node(&#39;\0&#39;, 0, l, r);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;shannon-fano-algorithm&#34;&gt;Shannon-Fano algorithm&lt;/h4&gt;

&lt;p&gt;어떻게 가장 최적(압축률이 높은) &lt;em&gt;prefix-free code&lt;/em&gt; 를 만들까? &lt;em&gt;Shannon-Fano&lt;/em&gt; 알고리즘을 이용하면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;symbol&lt;/em&gt; &lt;code&gt;S&lt;/code&gt; 를 &lt;code&gt;freq&lt;/code&gt; 으 합이 최대한 같은 두 집단으로 나눈다 &lt;code&gt;S0, S1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S0&lt;/code&gt; 은 &lt;code&gt;0&lt;/code&gt; 부터 시작하고, &lt;code&gt;S1&lt;/code&gt; 은 &lt;code&gt;1&lt;/code&gt; 부터 시작하도록 &lt;em&gt;codeword&lt;/em&gt; 를 만든다&lt;/li&gt;
&lt;li&gt;위 두 단계를 반복한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;근데 이 알고리즘은 보면 알겠지만, 최적이 아니다. 이는 &lt;code&gt;freq&lt;/code&gt; 값이 &lt;code&gt;{5, 1}&lt;/code&gt;, &lt;code&gt;{2, 1, 2, 1}&lt;/code&gt; 처럼 구성될 수 있기 때문이다.&lt;/p&gt;

&lt;h4 id=&#34;huffman-algorithm&#34;&gt;Huffman algorithm&lt;/h4&gt;

&lt;p&gt;허프만 알고리즘은 최적의 &lt;em&gt;prefix-free code&lt;/em&gt; 를 만들기 위해&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;각 문자를 이용해 &lt;em&gt;single node trie&lt;/em&gt; 를 만든다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;freq&lt;/code&gt; 값이 가장 작은 두개를 골라 합치고, &lt;em&gt;internal node&lt;/em&gt; 에 값을 누적&lt;/li&gt;
&lt;li&gt;반복한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://lcm.csa.iisc.ernet.in/dsa/img161.gif&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://lcm.csa.iisc.ernet.in/dsa&#34;&gt;http://lcm.csa.iisc.ernet.in/dsa&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이 과정에서 가장 낮은 &lt;em&gt;frequency&lt;/em&gt; 를 갖는 문자가 아래로 가는 것을 보장하기 때문에 최적의 &lt;em&gt;prefix-free code&lt;/em&gt; 를 찾는다 말할 수 있다. (좀 더 자세한 증명은 책을 보라고 함)&lt;/p&gt;

&lt;p&gt;구현은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// construct huffman encoding trie 
private static Node buildTree(int[] freq) {
	PriorityQueue&amp;lt;Node&amp;gt; pq = new PriorityQueue&amp;lt;Node&amp;gt;();
		
	for (char c = 0; c &amp;lt; R; c++) 
		if (freq[c] &amp;gt; 0)
			pq.add(new Node(c, freq[c], null, null));
		
	// if only one char
	if (pq.size() == 1) {
		if (freq[&#39;\0&#39;] == 0) pq.add(new Node(&#39;\0&#39;, 0, null, null));
		else                 pq.add(new Node(&#39;\1&#39;, 0, null, null));
	}
		
	// merge two tries
	while (pq.size() &amp;gt; 1) {
		Node l = pq.remove();
		Node r = pq.remove();
		Node p = new Node(&#39;\0&#39;, l.freq + r.freq, l, r); // parent
		pq.add(p);
	}
	
	return pq.remove();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;compression&#34;&gt;Compression&lt;/h4&gt;

&lt;p&gt;구현은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void compress() {
	String s = BinaryStdIn.readString(); // input
	char[] input = s.toCharArray();
	
	// tabulate freq counts
	int[] freq = new int[R];
	for (int i = 0; i &amp;lt; R; i++)
		freq[input[i]]++;
	
	// build huffman trie
	Node root = buildTrie(freq);
	
	// build syombol table
	String[] st = new String[R];
	buildCode(st, root, &amp;quot;&amp;quot;);
	
	// print trie for decoder
	writeTrie(root);
	
	// print N (# of input)
	BinaryStdOut.write(input.length);
	
	// encode
	for (int i = 0; i &amp;lt; input.length; i++) {
		String code = st[input[i]];
		
		// traverse huffman trie
		for (int j = 0; j &amp;lt; code.length(); i++) {
			if (code.charAt(j) == &#39;0&#39;)
				BinaryStdOut.write(false);
			else if (code.charAt(j) == &#39;1&#39;)
				BinaryStdOut.write(true);
			else throw new IllegalStateException(&amp;quot;Illegal State&amp;quot;);
		}
	}
	
	BinaryStdOut.close();
}

private static void buildCode(String[] st, Node x, String s) {
	if (!x.isLeaf()) {
		buildCode(st, x.left, s + &#39;0&#39;);
		buildCode(st, x.right, s + &#39;1&#39;);
	} else {
		st[x.ch] = s; 
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;전체 코드는 &lt;a href=&#34;ko.thetimenow.com/pst/pacific_standard_time&#34;&gt;Huffman.java&lt;/a&gt; 로&lt;/p&gt;

&lt;h4 id=&#34;huffman-summary&#34;&gt;Huffman Summary&lt;/h4&gt;

&lt;p&gt;정리하면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tabulate char frequencies and build trie&lt;/li&gt;
&lt;li&gt;encode file by traversing trie or lookup table&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;러닝타임은 바이너리 힙을 이용할 경우(우선순위 큐) &lt;code&gt;N + RlogR&lt;/code&gt; 이다. 여기서 &lt;code&gt;R&lt;/code&gt; 은 알파벳 사이즈. &lt;code&gt;N&lt;/code&gt; 은 입력 문자의 수다.&lt;/p&gt;

&lt;p&gt;즉 &lt;code&gt;N&lt;/code&gt; 은 입력 문자를 인코딩 하는데, &lt;code&gt;R logR&lt;/code&gt; 은 &lt;code&gt;R&lt;/code&gt; 개의 문자에 대해 &lt;code&gt;freq&lt;/code&gt; 값을 이용해 &lt;em&gt;trie&lt;/em&gt; 를 만드는데 걸리는 시간&lt;/p&gt;

&lt;h3 id=&#34;lzw-compression&#34;&gt;LZW Compression&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Lempel-Ziv-Welch&lt;/em&gt; 의 약자다. 세 분이 만드신듯&lt;/p&gt;

&lt;p&gt;알고리즘을 보기 전에 데이터 압축 모델에 대해 좀 생각해보자.&lt;/p&gt;

&lt;p&gt;(1) 빠르고, 범용적이지만 최적은 아닌 &lt;strong&gt;static model&lt;/strong&gt; (e.g ASCII)
(2) 모델을 매번 생성하고, 전송해야하지만 최적인 &lt;strong&gt;Dynamic model&lt;/strong&gt; (e.g Huffman)&lt;/p&gt;

&lt;p&gt;이 둘을 섞은 &lt;em&gt;adaptive model&lt;/em&gt; 도 있다. 즉 매 텍스트마다 모델을 업그레이드 해 나가는 것이다. &lt;del&gt;머신러닝?!&lt;/del&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Progressively learn and upate model as you read text&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;More accurate modeling produces better compression&lt;/li&gt;
&lt;li&gt;Decoding must start from beginning&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;LZW compression&lt;/em&gt; 이 그 예다. &lt;em&gt;LZW&lt;/em&gt; 압축 알고리즘은 모델을 읽으면서 만들기 때문에, 전송할 필요가 없다.&lt;/p&gt;

&lt;p&gt;텍스트를 읽다가 &lt;em&gt;codeword table&lt;/em&gt; 에 이미 존재하면, 문자를 더 읽어 테이블에 없을 경우에만 추가한다. 그림으로 보면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWmlSR00yUW1OeVF6WWpaVEw0UTJNNDBTTjFVMk10a3pZM01XTHlFV05obGpZNU0yTHhBak0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create ST associating &lt;code&gt;W&lt;/code&gt;-bit codewords with string keys&lt;/li&gt;
&lt;li&gt;Initialize ST with codewords for single-char keys&lt;/li&gt;
&lt;li&gt;Find longest string &lt;code&gt;s&lt;/code&gt; in ST that is a prefix of unscanned part of input&lt;/li&gt;
&lt;li&gt;Write the &lt;code&gt;W&lt;/code&gt;-bit codeword associated with &lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add &lt;code&gt;s + c&lt;/code&gt; to ST where &lt;code&gt;c&lt;/code&gt; is next char in the input&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;LZW compression&lt;/em&gt; 에선 &lt;em&gt;longest string matching&lt;/em&gt; 이 필요하므로 &lt;em&gt;trie&lt;/em&gt; 를 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWmtsek5pRldPbVJtTmpSVEw1RVRZNTBDT3pFek10UVRZMElXTG1GVFk1TVdPbVZ6THpBak0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.programering.com&#34;&gt;http://www.programering.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;h4 id=&#34;lzw-implementation&#34;&gt;LZW Implementation&lt;/h4&gt;

&lt;p&gt;자세한 코드는 &lt;a href=&#34;http://algs4.cs.princeton.edu/55compression/LZW.java.html&#34;&gt;LZW.java&lt;/a&gt; 여기로. 그리고 메모리 사용량을 줄이기 위해 &lt;em&gt;ternary search trie&lt;/em&gt; 를 이용한다. &lt;a href=&#34;http://algs4.cs.princeton.edu/55compression/TST.java.html&#34;&gt;TST.java&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// ref: http://algs4.cs.princeton.edu/55compression/LZW.java.html
private static final int R = 256;  // # of input chars
private static final int L = 4096; // # of codewords = 2^W
private static final int W = 12;   // codeword width

public static void compress() {
  String input = BinaryStdIn.readString();
  
  // codewords for single chars
  TST&amp;lt;Integer&amp;gt; tst = new TST&amp;lt;Integer&amp;gt;();
  for(int i = 0; i &amp;lt; R; i++)
    sts.put(&amp;quot;&amp;quot; + (char) i, i);
  
  int code = R + 1;
  
  while (input.length() &amp;gt; 0) {
    String s = tst.longestPrefixOf(input);
    BinaryStdOut.write(s, W);
    
    int t = s.length();
    if (t &amp;lt; input.length() &amp;amp;&amp;amp; code &amp;lt; L)
      st.put(input.substring(0, t + 1), code++)
    
    input = input.substring(t);
  }
  
  BinaryStdOut.write(R, W); // write &amp;quot;stop&amp;quot; codeword
  BinaryStdOut.close();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;expansion&lt;/em&gt; 은 테이블에서 &lt;em&gt;codeword&lt;/em&gt; 를 읽어가면서 테이블을 만들면 된다. 심볼이 아니라 값으로 검색하므로 &lt;code&gt;2^W&lt;/code&gt; 길이의 &lt;em&gt;array&lt;/em&gt; 만 있으면 된다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;tricky case&lt;/em&gt; 가 있는데&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTTBNbVp3WVdaaloyWTRJVEwxY1RZaDF5TnlJMk10VUROaGRUTHdVVE4zWTJZM2t6TDFBak0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;compression&lt;/em&gt; 은 같은데 &lt;em&gt;expansion&lt;/em&gt; 이 좀 복잡하다. &lt;code&gt;41 42 81 83 80&lt;/code&gt; 에서 &lt;code&gt;83&lt;/code&gt; 을 해석할때, 테이블에 있어야 해석을 하는데 없으므로 막혀버린다.&lt;/p&gt;

&lt;p&gt;이 경우를 잘 보면 &lt;code&gt;83&lt;/code&gt; 을 해석해야 하고, 현재 테이블에 &lt;code&gt;82&lt;/code&gt; 까지의 심볼만 존재한다. 그리고 방금 전 까지 읽은건 &lt;code&gt;81&lt;/code&gt; 이다. &lt;code&gt;83&lt;/code&gt; 은 &lt;code&gt;ABA&lt;/code&gt; 인데, 이건 &lt;code&gt;81&lt;/code&gt; 의 심볼을 &lt;code&gt;val&lt;/code&gt; 이라 하면 &lt;code&gt;val + val.charAt(0)&lt;/code&gt; 과 동일하다.&lt;/p&gt;

&lt;p&gt;구현은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void expand() {
	String[] st = new String[L];
	int i; // next available codeword value
	
	for (i = 0; i &amp;lt; R; i++) 
		st[i] = &amp;quot;&amp;quot; + (char) i;
	
	st[i++] = &amp;quot;&amp;quot;; // termination codeword
	
	int codeword = BinaryStdIn.readInt(W);
	if (codeword == R) return; // if empty message
	String val = st[codeword];
	
	while(true) {
		BinaryStdOut.write(val);
		
		codeword = BinaryStdIn.readInt(W);
		if (codeword == R) break;
		
		String s = st[codeword];
		
		// tricky case
		if (codeword == i) s = val + val.charAt(0);
		// add string into table
		if (i &amp;lt; L) st[i++] = val + s.charAt(0);
		
		val = s;
	}
	
	BinaryStdOut.close();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;해석할때 &lt;code&gt;val&lt;/code&gt; 은 지난단계의 해석, &lt;code&gt;s&lt;/code&gt; 는 현재 읽은 값의 해석이라 생각하면 쉽다.&lt;/p&gt;

&lt;h4 id=&#34;lossless-data-compression&#34;&gt;Lossless Data Compression&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;LZW&lt;/em&gt; 같은 경우 특허가 있었는데, 2003년에 만료되었다고 한다. 이 알고리즘의 많은 변형이 있는데, &lt;em&gt;LZ77&lt;/em&gt; 은 특허가 없어서 오픈소스에 많이 쓰인다고 함. &lt;em&gt;deflate  zlib&lt;/em&gt; 는 &lt;em&gt;LZ77&lt;/em&gt; 과 &lt;em&gt;Huffman&lt;/em&gt; 을 섞여 쓰는 대표적인 압축 알고리즘&lt;/p&gt;

&lt;p&gt;&lt;em&gt;bit / char&lt;/em&gt; 를 기준으로 보면 아스키는 &lt;code&gt;7&lt;/code&gt;, 허프만은 &lt;code&gt;4.7&lt;/code&gt; 정도의 성능을 보여준다. 1995년에는 &lt;em&gt;Burrows-Wheeler&lt;/em&gt; 알고리즘이 발명되었는데 &lt;code&gt;2.29&lt;/code&gt; 정도까지 압축한다. 1999년에는 &lt;em&gt;RK&lt;/em&gt; 알고리즘이 &lt;code&gt;1.89&lt;/code&gt; 까지 압축에 성공함.&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Huffman:&lt;/strong&gt; represent &lt;em&gt;fixed-length symbols&lt;/em&gt; with &lt;em&gt;variable-length codes&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LZW:&lt;/strong&gt; represent &lt;em&gt;variable-length symbols&lt;/em&gt; with &lt;em&gt;fixed-length codes&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;lossy compression&lt;/em&gt; 의 경우 &lt;em&gt;FFT&lt;/em&gt;, 프랙탈 등 수학적 도구를 이용해 만드 알고리즘들이 많다.&lt;/p&gt;

&lt;p&gt;그리고 압축의 이론적 한계는 &lt;em&gt;shanon entropy&lt;/em&gt; 에 의해&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://crackingthenutshell.com/wp-content/uploads/file/shannons-formula-small.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;p&gt;(1) &lt;em&gt;Algorithms: Part 2&lt;/em&gt; by &lt;strong&gt;Robert Sedgewick&lt;/strong&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://introcs.cs.princeton.edu/java/73dfa/&#34;&gt;http://introcs.cs.princeton.edu&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://www.lawfareblog.com/2013/09/the-nsa-and-encryption/&#34;&gt;The NSA and Encryption&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://www.programering.com/a/MTO4YzNwATE.html&#34;&gt;Data Compression Lecture Note&lt;/a&gt;&lt;br /&gt;
(5) &lt;a href=&#34;http://lcm.csa.iisc.ernet.in/dsa/node88.html&#34;&gt;Huffman Algorithm&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>