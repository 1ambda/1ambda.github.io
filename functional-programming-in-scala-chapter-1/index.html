<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/Blog">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

  <title>Functional Programming in Scala, Chapter 1</title>
  <meta name="description" content="" />

  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Functional Programming in Scala, Chapter 1">
  <meta name="twitter:description" content="2014-09-16, Functional Programming in Scala, Coursera 1.1 Programming Paradigms Imperative Programming modifying mutable variables   using assignment   and control str such as if-then-else, loop breakl continue, return   절차적인 프로그래밍은 폰 노이만 구조랑 비슷한데,  Mutable var = memory cells   variable deferences = load instructions   var assginment = store instsruction   control structure = jumps   그런데 이런">
  <meta name="twitter:creator" content="@yourTwitterUsername">
  <meta name="twitter:image" content="">
  <meta name="twitter:url" content="http://1ambda.github.io/functional-programming-in-scala-chapter-1/">
  <meta name="twitter:domain" content="http://1ambda.github.io">

  

  <link rel="author" href="https://plus.google.com/101105410053351451441?rel=author" />

  <link rel="shortcut icon" href="../favicon.ico">

  <link rel="stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Droid+Serif" />
  <link rel='stylesheet' type='text/css' href="http://fonts.googleapis.com/css?family=Open+Sans:600,300" />
  <link rel="stylesheet" type="text/css" href="../assets/stylesheets/xpressio.css" />
  <link rel="stylesheet" type="text/css" href="../assets/1ambda/1ambda.css" />
  <script type="text/javascript" src="../assets/1ambda/modernizr.js">
  </script>
  <script type="text/javascript" src="../assets/1ambda/detectizr.min.js">
  </script>

  <!--load css if windows -->
  <script type="text/javascript">
    if (Modernizr.windows) {
      file = location.pathname.split( "/" ).pop();
      link = document.createElement( "link" );
      link.href = "/assets/1ambda/1ambda_windows.css";
      link.type = "text/css";
      link.rel = "stylesheet";
      link.media = "screen,print";
      document.getElementsByTagName("head")[0].appendChild( link );
    }
  </script>


  
  <link rel="stylesheet" href="../assets/highlight/styles/github.css">
<script src="../assets/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


  <meta name="generator" content="Ghost 0.5" />
<link rel="alternate" type="application/rss+xml" title="Old Lisper" href="../rss">
<link rel="canonical" href="http://1ambda.github.io/functional-programming-in-scala-chapter-1/" />

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52181619-1', '1ambda.github.io');
  ga('send', 'pageview');
</script>

  
</head>
<body>

  
  <script src="../public/jquery.js?v=7a66dda120"></script>

  

<header class="site_width text center padding_top_big margin_bottom_big">
  
  <h1 class="blog_title margin_bottom_small"><a href="http://1ambda.github.io">Old Lisper</a></h1>
  <h4 class="text book">Functional Programming</h4>
  
  <div class="social border solid top_small bottom_small padding_medium">
  <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="/about-me"><i class="fa fa-user"></i> <span class="margin_left_small desktop">About me</span></a></h6>
  <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="http://kr.linkedin.com/in/1ambda" target="_blank"><i class="fa fa-linkedin-square"></i> <span class="margin_left_small desktop">Linkedin</span></a></h6>
  <h6 class="text book color c_black_medium without_margin"><a href="http://github.com/1ambda" target="_blank"><i class="fa fa-github"></i> <span class="margin_left_small desktop">GitHub</span></a></h6>
</div>

</header>

<main class="site_width" role="main">
  <article class="post tag-scala">

    

    <header class="text center margin_bottom_medium">
      <h5 class="text book small uppercase color c_black_light margin_bottom_small">Posted in <a href="../tag/scala">scala</a></h5>
      <h1 class="margin_bottom_medium">Functional Programming in Scala, Chapter 1</h1>
      <h5 class="text book small uppercase color c_black_light margin_bottom_small"><time datetime="2014-09-16">Tuesday, September 16, 2014</time>
      <br/><br/>
       <a href="http://1ambda.github.io/functional-programming-in-scala-chapter-1/#disqus_thread">Comment</a>
      </h5>
    </header>

    <section>
      <p>2014-09-16, <strong>Functional Programming in Scala</strong>, Coursera</p>

<h3 id="11programmingparadigms">1.1 Programming Paradigms</h3>

<h4 id="imperativeprogramming">Imperative Programming</h4>

<ul>
<li>modifying mutable variables  </li>
<li>using assignment  </li>
<li>and control str such as if-then-else, loop breakl continue, return  </li>
</ul>

<p>절차적인 프로그래밍은 폰 노이만 구조랑 비슷한데, </p>

<ul>
<li>Mutable var = memory cells  </li>
<li>variable deferences = load instructions  </li>
<li>var assginment = store instsruction  </li>
<li>control structure = jumps  </li>
</ul>

<p>그런데 이런 instruction 들이 <code>word</code> 로 구성되어있으므로, 문제는  </p>

<blockquote>
  <p>"Scaling up, How can we avoid conceptualizign programs word by word?"</p>
</blockquote>

<p>결국 pure Imperative Programming 은 폰노이만 구조처럼 제한을 받는다고 볼 수 있다.</p>

<blockquote>
  <p>"One tends to conceptualize data structures word-by-words"</p>
</blockquote>

<p>그렇기 때문에 컬렉션, 다항식, 문자열과 같은 high-level abstraction 을 정의할 방법이 필요한데, 이상적으로는 <strong>Theory</strong> 를 만들면 해결할 수 있다. Theory 는 다음을 포함하는데</p>

<ul>
<li>one or more data types  </li>
<li>operations on these types  </li>
<li>laws that describe the relationships between values and opertions</li>
</ul>

<p>그러나, 일반적으로 <strong>Theory</strong> 는 mutation 에 대해서는 describe 하지 않지만 Imperative Programming 에서는 mutation 때문에 theories 가 부서질(break) 수 있음. 따라서 다음과 같은 것들이 필요하다. </p>

<ul>
<li>Concentrate on defining theories for operators expressed as function  </li>
<li>avoid mutations  </li>
<li>have powerful way to abstract and compose functions  </li>
</ul>

<p>정리하자면, Imperative Programming 에서는 high-level abstraction 을 위해 theory 를 이용할 수 있는데, Imperative Programming 에서는 mutation variable 을 이용하므로 theory 의 law 를 break 할 수 있다. 따라서 이런 단점을 해결하기 위해 나온 것이 Functional Programming 이다.</p>

<p>Functional Programming 에서는 상태가 Immutable 이기 때문에 <strong>Theory</strong> 를 구성하는 operator 를 만드는 것에 집중할 수 있다.</p>

<h4 id="functionalprogramming">Functional Programming</h4>

<ul>
<li>without mutable variables, assignments, loops  </li>
<li>focuses on functions</li>
</ul>

<p>FP offers the folloing benefits</p>

<ul>
<li>simpler reasoning principles  </li>
<li>better modularity  </li>
<li>good for exploiting parallelism fo mlticore and clod compting  </li>
</ul>

<h3 id="12elementsofprogramming">1.2 Elements of Programming</h3>

<h4 id="expression">Expression</h4>

<p>대다수의 언어들은 <strong>expression</strong> 과 관련해서 다음의 기능들을 제공한다</p>

<ul>
<li>primitive expressions, representing the simplest elements  </li>
<li>ways to combine expressions  </li>
<li>ways to abstract expressions, which introduce a name for an expression by which it can then be referred to.</li>
</ul>

<h4 id="evaluation">Evaluation</h4>

<p><strong>Non-primitive</strong> expression 은 최종적으로 value 를 만들기 전까지 다음과 같은 방식으로 evaluated 된다</p>

<ol>
<li>Take the leftmost operator  </li>
<li>Evaluate its operands (left before right)  </li>
<li>Apply the operator to the operands</li>
</ol>

<p><strong>A name</strong> is evaluatd by replacing it with the right hand side of its definition.</p>

<p>그러나 모든 expression 이 finite value 를 가지는 것은 아니다. </p>

<pre><code class="scala">def loop: Int = loop  
</code></pre>

<h4 id="evaluationoffunctionapplications">Evaluation of Function Applications</h4>

<p>Applications of parameterized functions 은 다음과 같은 방식으로 evaluated 된다. operator 와 얼추 비슷하다</p>

<p>(1) Evaluate all function arguments, from left to right <br />
(2.1) Replace the function application by the function's right-hand side, and, at the same time <br />
(2.2) Replace the formal parameters of the function by the actual arguments</p>

<pre><code class="scala">def square(x: Int) = x * *  
def sumOfSquares(x: Int, : Int) = square(x) + square(x)

sumOfSquares(3, 2+2)

// sumOfSquares(3, 4) : step (1) 
// square(3) + square(4) : step (2) 
// 3 * 3 + square(4) : step (1), (2)
// 9 + square(4)
// 9 + 4 * 4
// 9 + 16
// 25
</code></pre>

<p>인자를 먼저 평가하지 않을 경우 <code>square(2+2)</code> 가 <code>(2*2) + (2*2)</code> 로 reduced 되어 더 많은 계산을 야기할 수 있다.</p>

<h4 id="thesubstitutionmodel">The substitution model</h4>

<p>이렇게 Evaluation 해 나가는 과정을 <strong>The substitution model</strong> 이라 부른다. 이 모델의 근간이 되는 아이디어는 <strong>reducing an expression to a value</strong> 이고, <strong>side-effect</strong> 가 없는 한 모든 expressions 에 적용할 수 있다. 참고로 이 모델은 Functional Programming 의 근간이 되는 <strong>lambda-calculus</strong> 사용한 것이다.</p>

<h4 id="callbyvaluecallbyname">Call-by-value, Call-by-name</h4>

<p><code>square(4)</code> 처럼 <code>sumOfSquares</code> 의 인자가 먼저 평가되는 방식을 <strong>Call-by-value</strong>, <code>square(2+2)</code> 처럼 나중에 인자가 평가되는 방식을 <strong>Call-by-name</strong> 이라 부른다. </p>

<p>두 가지 방식 아래 조건이 지켜지는 한 모두 expression 을 value 로 reduce 한다</p>

<ul>
<li>the reuced expression consists of pure functions, and  </li>
<li><p>both evaluations terminate</p></li>
<li><p><strong>Call-by-value</strong> has the advantage that it evaluates every function argument only once  </p></li>
<li><strong>Call-by-name</strong> has the advantage that a function argument is not evaluated if the corresponding parameter is unused in the evaluation of the function body  </li>
</ul>

<h4 id="examples">Examples</h4>

<pre><code class="scala">def test(x: Int, y: Int) = x *x  
</code></pre>

<p>위와 같은 함수가 있다고 할때, <code>test(3, 4)</code> 는 똑같은 속도지만 <code>test(2+2, 3)</code> 은  <strong>Call-by-value</strong> 가, <code>test(2, 3+2)</code> 는 <strong>Call-by-name</strong> 이 더 빠르다</p>

<h3 id="13evaluationstrategiesandtermination">1.3 Evaluation Strategies and Termination</h3>

<p>But what if termination is not guaranteed?</p>

<pre><code class="scala">def test (x: Int, y: Int) = x * x  
def loop () = loop  
</code></pre>

<p>위의 예제에서 <code>test(3, loop)</code> 라는 expressions 은 <strong>Call-by-name</strong> 방식으로 평가될 수 있지만, <strong>Call-by-value</strong> 방식으로는 아니다. </p>

<p>Scala 은 일반적으로 re-computation 을 피하기 위해 <strong>Call-by-value</strong> 을 사용한다. 그러나 <code>def constOne(x: Int, y: =&gt; Int) = 1</code> 처럼 function parameter 가 <code>=&gt;</code> 로 시작하면 해당 인자는 <strong>Call-by-name</strong> 을 이용한다.</p>

<pre><code class="scala">def constOne(x: Int, y: =&gt; Int) = 1  
def loop() = loop

constOne(1+2, loop) // will be evaluated  
constOne(loop, 1+2) // will not be evaluated  
</code></pre>

<h3 id="14conditionalsandvaluedefinitions">1.4 Conditionals and Value Definitions</h3>

<h4 id="conditionalexpression">Conditional Expression</h4>

<pre><code class="scala">def abs(x: Int) = if (x &gt;= 0) x else -x  
</code></pre>

<p>In the above example, <code>x &gt;= 0</code> is a predicate, of type Boolean. and <code>If-else</code> is an expression not a statement</p>

<h4 id="shortcircuitevaluation">short-circuit evaluation</h4>

<p>Boolean 을 위한 Rule 을 다시 만들수 있다.</p>

<pre><code>!true      --&gt; false
!false     --&gt; true
true &amp;&amp; e  --&gt; e  
false &amp;&amp; e --&gt; false  
true || e  --&gt; true  
false || e --&gt; e  
</code></pre>

<p><code>&amp;&amp;</code> 와 <code>||</code> 의 경우에는 언제나 오른쪽 operand 가 평가되야 하는건 아닌데, 이러한 expression 을 보고 <strong>short-circuit evaluation</strong> 을 사용한다고 말한다.</p>

<h4 id="valuedefinitions">Value Definitions</h4>

<pre><code class="scala">def x loop(): Booelan = loop  
</code></pre>

<p>위의 식이 평가되는걸 보면 <code>def</code> 는 <strong>Call-by-value</strong> 를 이용하는걸 알 수 있다. 반대로 <code>val</code> 은 <strong>Call-by-value</strong> 를 사용한다. <code>val x = loop</code> 식을 평가하면, 무한 루프가 도는것을 확인할 수 있다. </p>

<h4 id="exercise">Exercise</h4>

<p><code>&amp;&amp;</code> 와 <code>||</code> 없이 <code>and</code> 함수를 구현하려다 보면, 다음과 같이 구현하는 경우가 있는데, </p>

<pre><code class="scala">def and(x: Boolean, y: Boolean = if (x) y else false  
</code></pre>

<p>이 경우 <code>and(false, loop)</code> 를 평가하면 올바르게 동작하지 않고 무한루프에 걸린다 따라서 두번 째 인자가 <strong>Call-by-name</strong> 을 이용해 평가되도록, 아래와 같이 작성해야 한다.</p>

<pre><code class="scala">def and(x: Boolean, y: =&gt; Booelan) = if (x) y else false  
def or(x: Boolean, y: =&gt; Boolean) = if (x) true else y  
</code></pre>

<h3 id="15examplesquarerootswithnewtonsmethod">1.5 Example: square roots with Newton's method</h3>

<p>일단 시작 전에 먼저 말하자면, Scala 에서 recursive function 의 경우에는 explicit return type 이 필요하다.</p>

<p><a href="http://kevin0960.tistory.com/entry/%EA%B3%A0%EC%B0%A8-%EB%B0%A9%EC%A0%95%EC%8B%9D%EC%9D%98-%ED%95%B4-%EA%B5%AC%ED%95%98%EA%B8%B0-%EB%89%B4%ED%8A%BC-%EB%9E%A9%EC%8A%A8%EB%B2%95-Newton-Rahpson">뉴튼-랩슨 법</a>을 이용해서 제곱근을 구하는 Scala 코드를 작성하면</p>

<pre><code class="scala">  def abs(x: Double) = if (x &lt; 0) -x else x
  def sqrt(x: Int): Double = sqrtIter(1.0, x)
  def sqrtIter(guess: Double, x: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)

  def isGoodEnough(guess: Double, x: Double): Boolean =
    abs(guess * guess - x) / x &lt; 0.0001

  def improve(guess: Double, x: Double) =
    (guess + x / guess) / 2
</code></pre>

<p>실수에 대해 작업할때는 엄청나게 커다란 수와 작은 수에 대해 테스트를 해 보아야 한다. 만약 <code>isGoodEnough</code> 의 구현이 <code>abs(guess * guess -x ) &lt; 0.0001</code> 이라면 큰수에 대해서는 non-termination 이, 작은 수에 대해서는 invalid 한 값이 나올수 있다.</p>

<p>참고로, <strong>scalatest</strong> 에서는 <strong>floating point number</strong> 에 대한 테스틀 위해 다음과 같은 인터페이스를 지원한다.</p>

<pre><code class="scala">sevenDotOh should equal (6.9 +- 0.2)  
sevenDotOh should === (6.9 +- 0.2)  
sevenDotOh should be (6.9 +- 0.2)  
sevenDotOh shouldEqual 6.9 +- 0.2  
sevenDotOh shouldBe 6.9 +- 0.2  
</code></pre>

<h3 id="16blocksandlexicalscope">1.6 Blocks and Lexical Scope</h3>

<p>위에서 작성한 <code>sqrt</code> 를 block scope 를 이용하면 <code>x</code> 를 파라미터로 넘기는것을 제거해 간단히 만들 수 있다. </p>

<pre><code class="scala">  def abs(x: Double) = if (x &lt; 0) -x else x
  def sqrt(x: Int): Double = {

    def sqrtIter(guess: Double): Double =
      if (isGoodEnough(guess, x)) guess
      else sqrtIter(improve(guess))

    def isGoodEnough(guess: Double, x: Double): Boolean =
      abs(guess * guess - x) &lt; 0.0001

    def improve(guess: Double) =
      (guess +  x / guess) / 2

    sqrtIter(1.0)
  }
</code></pre>

<h4 id="semicolons">Semicolons</h4>

<p>Scala 에서 세미콜론은 옵션이지만 이와 관련된 이슈가 있다.</p>

<pre><code class="scala">someLongExp  
+ someOtherExp
</code></pre>

<p>이건 다음과 같이 interpreted 될 것이다.</p>

<pre><code class="scala">someLongExp;  
+ someOtherExp
</code></pre>

<p>Expression 이 분리 되는 것을 방지하기 위해 다음과 두 가지 방법을 이용할 수 있다.</p>

<pre><code class="scala">someLongExp +  
someOtherExp

// or

(someLongExp
+ someOtherExp)
</code></pre>

<h3 id="17tailrecursion">1.7 Tail Recursion</h3>

<pre><code class="scala">  def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)

  def factorial(n: Int): Int =
    if (n == 0) 1 else n * factorial(n - 1);
</code></pre>

<p>다음과 같은 재귀 함수가 있을때, 자세히 보면 <code>factorial(4)</code> 의 경우 Expression 이 점점 길어진다. <code>(4 * 3 * 2 * (1 * 1)</code></p>

<p>반대로 <code>gcd(3, 2)</code> 의 경우 계산과정을 살펴보면 <code>gcd(3, 2)</code>, <code>gcd(2, 1)</code> 로 진행된다. 식이 점점 길어지는게 아니라, 함수에서 변수만 바뀌는걸 알 수 있다. 이 경우 저장해야할 지역변수가 없기 때문에 stack frame 을 재활용 할 수 있으며, 이런 Recursive call 을 <strong>Tail Recursion</strong> 이라 부른다. 영문 설명을 보면,</p>

<p>If a function calls itself as its last action, the function's stack frame can e reused. This is called <strong>Tail Recursion</strong></p>

<blockquote>
  <p>Tail recursive functions are iterative processes</p>
</blockquote>

<p>In general, if the last action of a function consists of calling a function (which may be the same), one stack frame would be sufficient for both functions. Such calls are called <strong>tail-calls</strong></p>

<p><strong>tail-recursion</strong> 버전의 <code>factorial</code> 은 다음과 같다.</p>

<pre><code class="scala">  def tailFactorial(n: Int) = {
    def loop(acc: Int, n: Int): Int =
      if (n == 0) acc else loop(acc * n, n-1)
    loop(1, n);
  }
</code></pre>
    </section>

    <footer>
      
      <section class="author_info margin_top_big">
        <div class="alignleft border rad_circle" style="height: 87px; width: 87px; background-image: url(http://www.gravatar.com/avatar/aa2032ba2302419e3c2ede54f1fbf687?d=404&amp;s=250); background-size: cover;"></div>
        <p class="margin_left_medium text small">Author</p>
        <p class="margin_left_medium text bold"><a href="http://language.is">1ambda</a></p>
        <p class="margin_left_medium text small">Lisp, Emacs, FP</p>
      </section>
      
    </footer>

    

    
    <div id="disqus_thread" class="margin_top_big"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = '1ambda'; // required: replace example with your forum shortname
  var disqus_identifier = '25';
  var disqus_url = 'http://1ambda.github.io/functional-programming-in-scala-chapter-1/';

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    </article>
</main>


  
  <script src="../assets/fitvids/jquery.fitvids.js"></script>
<script>
$(document).ready(function(){
  // Target your .container, .wrapper, .post, etc.
  $("section").fitVids();
});
</script>


  <footer class="blog_info margin_top_big padding_medium text center">
    <h5 class="text book small">&copy; 2014 <a href="..">Old Lisper</a>. All rights reserved.</h5>
    <h5 class="text book small"><a href="https://github.com/dreyacosta/velox" target="_blank" class="text bold">Velox theme</a> by <a href="http://dreyacosta.com/">David Rey</a></h5>
    <h5 class="text book small">Proudly published with <a href="http://ghost.org"><span>Ghost</span></a></h5>

  </footer>

  
  <script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = '1ambda'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function () {
 var s = document.createElement('script'); s.async = true;
 s.type = 'text/javascript';
 s.src = '//' + disqus_shortname + '.disqus.com/count.js';
 (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
 }());
</script>



  </body>
  </html>
