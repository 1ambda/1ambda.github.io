
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>Easy Scalaz 5, Playing with Monoids</title>
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Easy Scalaz 5, Playing with Monoids">
  <meta name="twitter:description" content="이번 글에서는 모노이드를 가지고 놀면서, 아래 나열된 라이브러리 및 언어적 특성을 살펴보겠습니다. Boolean Monoid operations with Spire Algebraic Data Types using Value Class, Scalaz.Tag Creating Monoid for all subclasses using Shapeless Context Bound Path Dependent Type Monoid Easy Scalaz 4 - Yoneda and Free Monad: Monoid 부분에서 발췌하면, 어떤">
  <meta name="twitter:creator" content="@yourTwitterUsername">
  <meta name="twitter:image" content="">
  <meta name="twitter:url" content="http://1ambda.github.io/easy-scalaz-5-playing-with-monoids/">
  <meta name="twitter:domain" content="http://1ambda.github.io">


  <link rel="author" href="https://plus.google.com/101105410053351451441?rel=author">

  <link rel="shortcut icon" href="../favicon.ico">

  <link rel="stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Droid+Serif">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:600,300">
  <link rel="stylesheet" type="text/css" href="../assets/stylesheets/xpressio.css">
  <link rel="stylesheet" type="text/css" href="../assets/1ambda/1ambda.css">
  <script type="text/javascript" src="../assets/1ambda/modernizr.js">
  </script>
  <script type="text/javascript" src="../assets/1ambda/detectizr.min.js">
  </script>

  <!--load css if windows -->
  <script type="text/javascript">
    if (Modernizr.windows) {
      file = location.pathname.split( "/" ).pop();
      link = document.createElement( "link" );
      link.href = "/assets/1ambda/1ambda_windows.css";
      link.type = "text/css";
      link.rel = "stylesheet";
      link.media = "screen,print";
      document.getElementsByTagName("head")[0].appendChild( link );
    }
  </script>


  <link rel="stylesheet" href="../assets/highlight/styles/github.css">
<script src="../assets/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  <link rel="canonical" href="http://1ambda.github.io/easy-scalaz-5-playing-with-monoids/">
    <meta name="referrer" content="origin">
    
    <meta property="og:site_name" content="Old Lisper">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Easy Scalaz 5, Playing with Monoids">
    <meta property="og:description" content="이번 글에서는 모노이드를 가지고 놀면서, 아래 나열된 라이브러리 및 언어적 특성을 살펴보겠습니다. Boolean Monoid operations with Spire Algebraic Data Types using Value Class, Scalaz.Tag Creating Monoid for all subclasses using Shapeless Context Bound Path Dependent Type Monoid Easy Scalaz...">
    <meta property="og:url" content="http://1ambda.github.io/easy-scalaz-5-playing-with-monoids/">
    <meta property="article:published_time" content="2015-12-18T15:37:58.404Z">
    <meta property="article:modified_time" content="2015-12-18T15:44:42.048Z">
    <meta property="article:tag" content="scala">
    <meta property="article:tag" content="monoid">
    <meta property="article:tag" content="scalaz">
    <meta property="article:tag" content="shapeless">
    <meta property="article:tag" content="spire">
    <meta property="article:tag" content="Tag">
    <meta property="article:tag" content="path dependent type">
    <meta property="article:tag" content="context bound">
    <meta property="article:tag" content="algebraic data type">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Easy Scalaz 5, Playing with Monoids">
    <meta name="twitter:description" content="이번 글에서는 모노이드를 가지고 놀면서, 아래 나열된 라이브러리 및 언어적 특성을 살펴보겠습니다. Boolean Monoid operations with Spire Algebraic Data Types using Value Class, Scalaz.Tag Creating Monoid for all subclasses using Shapeless Context Bound Path Dependent Type Monoid Easy Scalaz...">
    <meta name="twitter:url" content="http://1ambda.github.io/easy-scalaz-5-playing-with-monoids/">
    
    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Article",
    "publisher": "Old Lisper",
    "author": {
        "@type": "Person",
        "name": "1ambda",
        "image": "//www.gravatar.com/avatar/aa2032ba2302419e3c2ede54f1fbf687?d=404&s=250",
        "url": "http://1ambda.github.io/author/1ambda",
        "sameAs": "http://1ambda.github.io",
        "description": "Functional, Scala, Akka, Rx and Haskell"
    },
    "headline": "Easy Scalaz 5, Playing with Monoids",
    "url": "http://1ambda.github.io/easy-scalaz-5-playing-with-monoids/",
    "datePublished": "2015-12-18T15:37:58.404Z",
    "dateModified": "2015-12-18T15:44:42.048Z",
    "keywords": "scala, monoid, scalaz, shapeless, spire, Tag, path dependent type, context bound, algebraic data type",
    "description": "이번 글에서는 모노이드를 가지고 놀면서, 아래 나열된 라이브러리 및 언어적 특성을 살펴보겠습니다. Boolean Monoid operations with Spire Algebraic Data Types using Value Class, Scalaz.Tag Creating Monoid for all subclasses using Shapeless Context Bound Path Dependent Type Monoid Easy Scalaz..."
}
    </script>

    <meta name="generator" content="Ghost 0.6">
    <link rel="alternate" type="application/rss+xml" title="Old Lisper" href="http://1ambda.github.io/rss/">

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52181619-1', '1ambda.github.io');
  ga('send', 'pageview');
</script>
  
</head>
<body>

  <script src="../public/jquery.js?v=2be0f9f02e"></script>

  
<header class="site_width text center padding_top_big margin_bottom_big">
  
  <h1 class="blog_title margin_bottom_small"><a href="http://1ambda.github.io">Old Lisper</a></h1>
  <h4 class="text book">Functional Programming World</h4>
  <div class="social border solid top_small bottom_small padding_medium">
  <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="http://1ambda.github.io/articles/"><i class="fa fa-columns"></i> <span class="margin_lefarticlest_small desktop">Article</span></a></h6>
  <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="http://kr.linkedin.com/in/1ambda" target="_blank"><i class="fa fa-linkedin-square"></i> <span class="margin_left_small desktop">Linkedin</span></a></h6>
  <h6 class="text book color c_black_medium without_margin"><a href="http://github.com/1ambda" target="_blank"><i class="fa fa-github"></i> <span class="margin_left_small desktop">GitHub</span></a></h6>
</div>
</header>

<main class="site_width" role="main">
  <article class="post tag-scala tag-monoid tag-scalaz tag-shapeless tag-spire tag-tag-tag tag-path-dependent-type tag-context-bound tag-algebraic-data-type">


    <header class="text center margin_bottom_medium">
      <h5 class="text book small uppercase color c_black_light margin_bottom_small">Posted in <a href="../tag/scala/">scala</a>, <a href="../tag/monoid/">monoid</a>, <a href="../tag/scalaz/">scalaz</a>, <a href="../tag/shapeless/">shapeless</a>, <a href="../tag/spire/">spire</a>, <a href="../tag/tag-tag/">Tag</a>, <a href="../tag/path-dependent-type/">path dependent type</a>, <a href="../tag/context-bound/">context bound</a>, <a href="../tag/algebraic-data-type/">algebraic data type</a></h5>
      <h1 class="margin_bottom_medium">Easy Scalaz 5, Playing with Monoids</h1>
      <h5 class="text book small uppercase color c_black_light margin_bottom_small"><time datetime="2015-12-19">Saturday, December 19, 2015</time>
      <br><br>
       <a href="http://1ambda.github.io/easy-scalaz-5-playing-with-monoids/#disqus_thread">Comment</a>
      </h5>
    </header>

    <section>
      <p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p>이번 글에서는 모노이드를 가지고 놀면서, 아래 나열된 라이브러리 및 언어적 특성을 살펴보겠습니다.</p>

<ul>
<li><strong>Boolean Monoid</strong> operations with <a href="https://github.com/non/spire">Spire</a></li>
<li><strong>Algebraic Data Types</strong> using <a href="http://docs.scala-lang.org/overviews/core/value-classes.html">Value Class</a>, <a href="https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Tag.scala">Scalaz.Tag</a></li>
<li>Creating <strong>Monoid</strong> for all subclasses using <a href="https://github.com/milessabin/shapeless">Shapeless</a></li>
<li><a href="http://docs.scala-lang.org/tutorials/FAQ/context-and-view-bounds.html">Context Bound</a></li>
<li><a href="http://danielwestheide.com/blog/2013/02/13/the-neophytes-guide-to-scala-part-13-path-dependent-types.html">Path Dependent Type</a></li>
</ul>

<h2 id="monoid">Monoid</h2>

<p><a href="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/#monoid">Easy Scalaz 4 - Yoneda and Free Monad: Monoid</a> 부분에서 발췌하면,</p>

<p>어떤 집합 <code>S</code> 에 대한 닫힌 연산 <code>*</code>, 집합 내의 어떤 원소 <code>e</code> 가 다음을 만족할 경우 모노이드라 부릅니다.</p>

<ul>
<li><code>e * a = a = a * e</code> (<em>identity</em>)</li>
<li><code>(a * b) * c = a * (b * c)</code> (<em>associativity</em>)</li>
</ul>

<p>일반적으로 <code>e</code> 를 항등원이라 부릅니다. <code>Option[A]</code> 도 <code>None</code> 을 항등원으로 사용하고, <em>associativity</em> 를 만족하는 <code>A</code> 의 연산을 사용하면 모노이드입니다. 따라서 <code>A</code> 가 모노이드면 <code>Option[A]</code> 도 모노이드입니다. </p>

<p><em>Scalaz</em> 에서는 모노이드 연산 <code>*</code> 를, <code>|+|</code> 로 표시합니다. 우리가 알고 있는 <em>primitives</em> 대부분이 모노이드입니다. </p>

<pre><code class="language-scala">&gt; load.ivy("org.scalaz" % "scalaz-core_2.11" % "7.2.0-M5")

&gt; import scalaz._, Scalaz._
import scalaz._, Scalaz._  
&gt; implicitly[Monoid[String]]
res4: Monoid[String] = scalaz.std.StringInstances$stringInstance$@5590d10f  
&gt; implicitly[Monoid[Int]]
res5: Monoid[Int] = scalaz.std.AnyValInstances$$anon$5@4b9f2522  
&gt; implicitly[Monoid[Set[Int]]]
res6: Monoid[Set[Int]] = scalaz.std.SetInstances$$anon$3@5b1965ea

&gt; "1" |+| "2"
res7: String = "12"  
&gt; 1.0 |+| 2.0
Compilation Failed  
Main.scala:1459: value |+| is not a member of Double  
1.0 |+| 2.0  
    ^
&gt; 1 |+| 2
res8: Int = 3

&gt; 1.some |+| 2.some
res11: Option[Int] = Some(3)  
&gt; 1.some |+| none
res12: Option[Int] = Some(1)  
&gt; none[Int] |+| 1.some
res13: Option[Int] = Some(1)  
</code></pre>

<p><code>Map[A, B]</code> 는 <code>A</code> 를 <em>Key</em> 로 잡고, <code>B</code> 의 모노이드 연산과 항등원을 이용하는 모노이드입니다.</p>

<pre><code class="language-scala">&gt; val m1 = Map("a" -&gt; 1, "b" -&gt; 2)
m1: Map[String, Int] = Map("a" -&gt; 1, "b" -&gt; 2)  
&gt; val m2 = Map("a" -&gt; 1, "c" -&gt; 2)
m2: Map[String, Int] = Map("a" -&gt; 1, "c" -&gt; 2)  
&gt; m1 |+| m2
res16: Map[String, Int] = Map("a" -&gt; 2, "c" -&gt; 2, "b" -&gt; 2)  
</code></pre>

<h2 id="booleanmonoid">Boolean Monoid</h2>

<p><code>Boolean</code> 의 경우에는, 두 가지 모노이드가 존재할 수 있습니다. </p>

<ul>
<li><code>&amp;&amp;</code> 를 연산으로 사용하고, <code>true</code> 를 항등원으로 사용하는 경우</li>
<li><code>||</code> 를 연산으로 사용하고, <code>false</code> 를 항등원으로 사용하는 경우</li>
</ul>

<p>첫 번째를 <em>Conjunction</em> 이라 부르고 두 번째를 <em>Disjunction</em> 이라 부릅니다. 즉, <code>Boolean</code> 은 두 개의 모노이드가 존재할 수 있기 때문에 아래처럼 <em>scalaz</em> 의 <code>|+|</code> 를 바로 이용할 수 없습니다. <em>Disjunction</em> 인지 <em>Conjunction</em> 인지 골라야 하기 때문입니다.</p>

<pre><code class="language-scala">&gt; false |+| false
Compilation Failed  
Main.scala:1468: value |+| is not a member of Boolean  
false |+| false  
      ^

// import 를 하지 않으면, scalaz.Tags.Disjunction 이 아니라 scalaz.Disjunction 을 사용하므로 주의
&gt; import scalaz.Tags._
import scalaz.Tags._  
&gt; import scalaz.syntax.tag._
import scalaz.syntax.tag._  
&gt; Disjunction(false)
res22: Boolean @@ Disjunction = false  
&gt; Conjunction(false)
res23: Boolean @@ Conjunction = false

&gt; implicitly[Monoid[Boolean @@ Disjunction]]
res27: Monoid[Boolean @@ Disjunction] = scalaz.std.AnyValInstances$$anon$7@79a6c868  
&gt; implicitly[Monoid[Boolean @@ Conjunction]]
res28: Monoid[Boolean @@ Conjunction] = scalaz.std.AnyValInstances$$anon$8@6e49df4a

&gt; Disjunction(false) |+| Disjunction(true)
res29: Boolean @@ Disjunction = true  
&gt; Disjunction(true) |+| Disjunction(false)
res30: Boolean @@ Disjunction = true  
&gt; Conjunction(true) |+| Conjunction(true)
res31: Boolean @@ Conjunction = true  
&gt; Conjunction(true) |+| Conjunction(false)
res32: Boolean @@ Conjunction = false

&gt; List(false, false, true, false)
res37: List[Boolean] = List(false, false, true, false)  
&gt; Disjunction.subst(res37).suml
res38: Boolean @@ Disjunction = true  
&gt; Conjunction.subst(res37).suml
res39: Boolean @@ Conjunction = false  
</code></pre>

<p>실제로 <code>scalaz.std.AnyVal</code> 을 확인해 보면,</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/std/AnyVal.scala#L52

object conjunction extends Monoid[Boolean] {  
  def append(f1: Boolean, f2: =&gt; Boolean) = f1 &amp;&amp; f2
  def zero: Boolean = true
}

object disjunction extends Monoid[Boolean] {  
  def append(f1: Boolean, f2: =&gt; Boolean) = f1 || f2
  def zero = false
}
</code></pre>

<p>그렇다면 <code>Int</code> 의 경우에도 <code>*</code> 등 다른 모노이드가 있는데 왜 <code>+</code> 연산과 <code>0</code> 항등원만 <code>|+|</code> 에서 사용하는걸까요? 이는 <code>+</code> 가 너무 보편적이기 때문이며, <code>*</code> (곱셈) 등은 위에서 본 <code>Tag</code> 를 이용해 모노이드 연산으로 지정할 수 있습니다.</p>

<h2 id="tag">Tag</h2>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Tags.scala

object Tags {

  ...

  /** Type tag to choose a [[scalaz.Monoid]] instance that selects the lesser of two operands, ignoring `zero`. */
  sealed trait Min

  val Min = Tag.of[Min]

  /** Type tag to choose a [[scalaz.Monoid]] instance that selects the greater of two operands, ignoring `zero`. */
  sealed trait Max

  val Max = Tag.of[Max]

  /** Type tag to choose a [[scalaz.Monoid]] instance for a numeric type that performs multiplication,
   *  rather than the default monoid for these types which by convention performs addition. */
  sealed trait Multiplication

  val Multiplication = Tag.of[Multiplication]

  ...
}
</code></pre>

<p><code>Multiplication</code> 을 이용하면,</p>

<pre><code class="language-scala">&gt; Multiplication(2) |+| Multiplication(6)
res3: Int @@ Multiplication = 12

&gt; implicitly[Monoid[Int @@ Multiplication]]
res4: Monoid[Int @@ Multiplication] = scalaz.std.AnyValInstances$$anon$12@5910ca72  
</code></pre>

<p><code>AnyValInstances</code> 를 찾아보면 <code>byteMultiplicationNewType</code>, <code>intMultiplicationNewType</code> 등 <code>A @@ Multiplication</code> 을 위한 인스턴스들이 구현되어 있습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/std/AnyVal.scala#L253

trait AnyValInstances {

  implicit val shortMultiplicationNewType: Monoid[Short @@ Multiplication] with Enum[Short @@ Multiplication] = new Monoid[Short @@ Multiplication] with Enum[Short @@ Multiplication] {
    ...
  } 

  implicit val intMultiplicationNewType: Monoid[Int @@ Multiplication] with Enum[Int @@ Multiplication] = new Monoid[Int @@ Multiplication] with Enum[Int @@ Multiplication] {
    ...
  }
}
</code></pre>

<p><code>Tag</code> 는 이렇게 생겼습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/package.scala#L99

package object scalaz {  
  ...

  private[scalaz] type Tagged[A, T] = {type Tag = T; type Self = A}

  /**
   * Tag a type `T` with `Tag`.
   *
   * The resulting type is used to discriminate between type class instances.
   *
   * @see [[scalaz.Tag]] and [[scalaz.Tags]]
   *
   * Credit to Miles Sabin for the idea.
   */
  type @@[T, Tag] = Tagged[T, Tag]

  ...
}
</code></pre>

<p><code>@@[A, T]</code> 를 생성하기 위해 <code>Tag.apply</code> 를 값을 추출하기 위해 <code>unwrap</code> 을 이용할 수 있습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Tag.scala
object Tag {  
  /** `subst` specialized to `Id`.
    *
    * @todo According to Miles, @specialized doesn't help here. Maybe manually specialize.
    */
  @inline def apply[@specialized A, T](a: A): A @@ T = a.asInstanceOf[A @@ T]

  /** `unsubst` specialized to `Id`. */
  @inline def unwrap[@specialized A, T](a: A @@ T): A = unsubst[A, Id, T](a)

  /** Add a tag `T` to `A`.
    *
    * NB: It is unsafe to `subst` or `unsubst` a tag in an `F` that is
    * sensitive to the `A` type within.  For example, if `F` is a
    * GADT, rather than a normal ADT, it is probably unsafe.  For
    * "normal" types like `List` and function types, it is safe.  More
    * broadly, if it is possible to write a ''legal''
    * [[scalaz.InvariantFunctor]] over the parameter, `subst` of that
    * parameter is safe.
    * 
    * We do not have a
    * &lt;a href="https://ghc.haskell.org/trac/ghc/wiki/Roles"&gt;type role&lt;/a&gt;
    * system in Scala with which to declare the exact situations under
    * which `subst` is safe.  If we did, we would declare that `subst`
    * is safe if and only if the parameter has "representational" or
    * "phantom" role.
    */
  def subst[A, F[_], T](fa: F[A]): F[A @@ T] = fa.asInstanceOf[F[A @@ T]]

  ...
}
</code></pre>

<p><code>Tag</code> 는 <a href="http://docs.scala-lang.org/overviews/core/value-classes.html"><em>Value Class</em></a> 처럼 활용할 수도 있는데요,</p>

<pre><code class="language-scala">// http://eed3si9n.com/learning-scalaz/Tagged+type.html

sealed trait USD  
sealed trait EUR  
def USD[A](amount: A): A @@ USD = Tag[A, USD](amount)  
def EUR[A](amount: A): A @@ EUR = Tag[A, EUR](amount)

val oneUSD = USD(1)  
</code></pre>

<p>태깅된 타입을 이용하면 <em>implicit</em> 를 선택할 수 있습니다. 예를 들어 </p>

<pre><code class="language-scala">implicit val anonymousUserWriter = Writer[User @@ Anonymous] { ... }  
implicit val loggedInUserWriter  = Writer[User @@ LoggedIn]  { ... }  
</code></pre>

<p>그러나 <code>type B = A @@ T</code> 에서 <code>B</code> 는 <code>A</code> 의 서브타입으로 취급되므로 주의하여 사용해야 합니다. 예를 들어, <em>scalatest</em> 의 <code>===</code>, <code>shouldBe</code> 는 런타임값만 체크하므로 아래는 항상 참입니다.</p>

<pre><code class="language-scala">def convertUSDtoEUR[A](usd: A @@ USD, rate: A)  
                      (implicit M: Monoid[A @@ Multiplication]): A @@ EUR =
  EUR((Multiplication(usd.unwrap) |+| Multiplication(rate)).unwrap)

convertUSDtoEUR(USD(1), 2) === EUR(2) // true  
convertUSDtoEUR(USD(1), 2) === USD(2) // true

convertUSDtoEUR(USD(1), 2) shouldBe EUR(2) // true  
convertUSDtoEUR(USD(1), 2) shouldBe USD(2) // true

2 shouldBe USD(2) // true  
2 shouldBe EUR(2) // true  
</code></pre>

<p>따라서 <code>=:=</code> 를 만들어 사용하면 <code>EUR</code> 과 <code>USD</code> 비교시 컴파일 예외를 발생시킬 수 있습니다. (더 정확히는 <em>scalaz</em> 의 <code>===</code> 또는 <code>org.scalactic.TypeCheckedTripleEquals</code> 를 사용하면 되는데, <code>org.scalactic.TripleEqualSupports</code> 를 <code>FunSuite</code>  내에서 하이딩 시킬 방법을 찾지 못해서 아래처럼 구현했습니다.)</p>

<pre><code class="language-scala">// impilcit class 로 만들고 import 해서 사용해도 상관없음
trait TestImplicits {  
  final case class StrictEqualOps[A](val a: A) {
    def =:=(aa: A) = assert(a == aa)
    def =/=(aa: A) = assert(!(a == aa))
  }

  implicit def toStrictEqualOps[A](a: A) = StrictEqualOps(a)
}

// spec
convertUSDtoEUR(USD(1), 2) =:= EUR(2)  
convertUSDtoEUR(USD(1), 2) =:= EUR(3) // will fail  
convertUSDtoEUR(USD(1), 2) =:= USD(3) // compile error  
</code></pre>

<p><code>Tag</code> 을 이용하면 같은 <em>primitive type</em> 이어도 별도의 <em>wrapper</em> 를 만들지 않으면서 다른 타입으로 만들 수 있습니다. 예를 들어 <code>Job</code> 을 <code>Agent</code> 가 수행한다고 하면, 다음과 같이 간단한 모델을 만들어 볼 수 있는데</p>

<pre><code class="language-scala">// ref - http://www.slideshare.net/IainHull/improving-correctness-with-types

case class Agent(id: String, /* agent id */  
                 status: String, /* agent status */
                 jobType: String)

case class Job(id: String, /* job id */  
               maybeAgentId: Option[String], /* agent id */
               status: String, /* job status */
               jobType: String)
</code></pre>

<p>여기서 <em>Sum</em> 을 먼저 추출하면, (<em>Algebraic Data Type</em> 관련해서는 <a href="https://gleichmann.wordpress.com/2011/02/05/functional-scala-algebraic-datatypes-sum-and-product-types/">Sum and Product</a> 참조)</p>

<pre><code class="language-scala">sealed abstract class AgentStatus(val value: String)  
case object Waiting    extends AgentStatus("WAITING")  
case object Processing extends AgentStatus("PROCESSING")

sealed abstract class JobStatus(val value: String)  
case object Created   extends JobStatus("CREATED")  
case object Allocated extends JobStatus("ALLOCATED")  
case object Completed extends JobStatus("COMPLETED")

sealed abstract class JobType(val value: String)  
case object Small extends JobType("SMALL")  
case object Large extends JobType("LARGE")  
case object Batch extends JobType("BATCH")

case class Agent(id: String, /* agent id */  
                 status: AgentStatus,
                 jobType: JobType)

case class Job(id: String, /* job id */  
               maybeAgentId: Option[String], /* agent id */
               status: JobStatus,
               jobType: JobType)
</code></pre>

<p>여기서 오류의 소지가 다분한 <code>id</code> 에 태깅을 하면 다음과 같습니다.</p>

<pre><code class="language-scala">import scalaz._

case class Agent(id: String @@ Agent,  
                 status: AgentStatus,
                 jobType: JobType)

case class Job(id: String @@ Job,  
               maybeAgentId: Option[String @@ Agent],
               status: JobStatus,
               jobType: JobType)

Agent(Tag[String, Agent]("03"), Waiting, Small)  
Job(Tag[String, Job]("03"), None, Created, Small)  
</code></pre>

<p>조금 더 개선할 여지는, <code>maybeAgentId</code> 에 <code>Option</code> 을 이용하는 대신, <em>agent</em> 에 할당된 <em>job</em> 과 아닌 <em>job</em> 을 서브타입으로 분리하면, <code>Job</code> 을 다루는 함수에서 <code>Option</code> 처리를 피할 수 있습니다.</p>

<p>물론 이는 디자인적 결정입니다. <code>Option</code> 을 허용하되 수퍼클래스를 인자로 받을것인가, 아니면 허용하지 않을것인가의 문제죠. 개인적으로는 프로그래밍 과정에서 타입을 점점 좁혀가면 오류의 여지를 줄일 수 있기 때문에 후자를 선호합니다. 그렇지 않으면 강력한 타입시스템을 갖춘 언어를 굳이 사용할 필요가 없겠지요.</p>

<p>타입을 이용한 오류방지 방법 관련해서 <a href="http://www.slideshare.net/IainHull/improving-correctness-with-types">Improving Correctness with Types</a> 를 읽어보시길 권합니다.</p>

<h2 id="monoidexamplefilter">Monoid Example: Filter</h2>

<p>간단한 <code>Monoid</code> 예제를 하나 만들어 보겠습니다. <code>User</code> 클래스가 있고, 필터링을 하고 싶을 때</p>

<pre><code class="language-scala">// http://www.slideshare.net/oxbow_lakes/practical-scalaz

case class User(name: String, city: String)  
type Filter[A] = A =&gt; Boolean // Function1, same as Reader[A, Boolean]

val london: Filter[User] = _.city endsWith(".LONDON")  
val ny: Filter[User]     = _.city endsWith(".NY")

val inLondon = users filter london  
val inNY = users filter ny  
</code></pre>

<p>이 때 만약 <code>Filter[A]</code> 가 <code>OR (||)</code> 연산에 대한 모노이드라면, 이렇게 쓸 수 있지 않을까요?</p>

<pre><code class="language-scala">users filter (london |+| ny)  
</code></pre>

<p>그런데 <code>Filter[A]</code> 는 모노이드가 아니기 때문에 그럴 수 없습니다. 우린 모노이드를 배운 사람들이니까 <del>지성인</del> 한 번 만들어 보겠습니다.</p>

<pre><code class="language-scala">implicit def booleanMonoid[A] = new Monoid[Filter[A]] = {  
  override def zero: Filter[A] = 
    false
  override def append(f1: Filter[A], f2: =&gt; Filter[A]): Filter[A] = 
    a =&gt; f1(a) || f2(a)
}
</code></pre>

<p><em>disjunction</em> 이죠? <em>Scalaz</em> 어딘가에 구현되어 있을것 같습니다.</p>

<pre><code class="language-scala">impilcit def booleanMonoid[A] =  
  function1Monoid[A, Boolean](booleanInstance.disjunction)
</code></pre>

<p><code>function1Monoid[A, R]</code> 은 결과값 <code>R</code> 에 대한 모노이드 <code>Monoid[R]</code> 를 필요로 하고 여기에 위에서 봤던 <code>Monoid[Boolean]</code> 인 <code>booleanInstance.disjunction</code> 을 넣으면, 우리가 원했던 <code>Monoid[Filter[A]</code> 가 완성됩니다.</p>

<pre><code class="language-scala">implicit def function1Monoid[A, R](implicit R0: Monoid[R]): Monoid[A =&gt; R] = new Function1Monoid[A, R] {  
  implicit def R = R0
}

private trait Function1Monoid[A, R] extends Monoid[A =&gt; R] with Function1Semigroup[A, R] {  
  implicit def R: Monoid[R]
  def zero = a =&gt; R.zero
}

object disjunction extends Monoid[Boolean] {  
    def append(f1: Boolean, f2: =&gt; Boolean) = f1 || f2
    def zero = false
}
</code></pre>

<p>그러면 이제 요구사항을 좀 더 까다롭게 해서, <strong>런던에 사는 켈리 또는 뉴욕에 사는 켈리</strong> 만 뽑아내려면 어떻게 해야할까요?</p>

<pre><code class="language-scala">// if we have `|*|` representing `Conjunction`

val kelly: Filter[User] = _.name.endsWith("Kelly")  
val myFriendKelly = (london |*| kelly) |+| (ny |*| kelly)  
users filter myFriendKelly  
</code></pre>

<p>그런데, <em>scalaz</em> 에서 할당한 모노이드 연산자는 <code>|+|</code> 하나뿐입니다. 따라서 <em>Implicit Class</em> 를 추가하면 </p>

<pre><code class="language-scala">implicit class FilterOps[A](fa: Function1[A, Boolean]) {  
  def |*|(other: Function1[A, Boolean]): Function1[A, Boolean] =
    function1Monoid[A, Boolean](booleanInstance.conjunction).append(fa, other)
}

val users = List(  
  User("Kelly", ".LONDON"),
  User("John", ".NY"),
  User("Cark", ".SEOUL"),
  User("Kelly", ".NY"),
  User("Kelly", ".SEOUL")
)

val ks1 = users filter ((london |*| isKelly) |+| (ny |*| isKelly))  
val ks1.size shouldBe 2

// 더 짧게 줄이면, 
val ks2 = users filter ((london |+| ny) |*| isKelly)  
</code></pre>

<p><code>scalaz.Monoid</code> 가 <code>|+|</code> 만을 지원하는 반면, 대수타입에 특화된 <em>Spire</em> 는 <code>Boolean</code> 에 대해 <code>*, +</code> 두 가지 연산을 모두 지원합니다. </p>

<pre><code class="language-scala">import spire.algebra.Rig

implicit def filterRig[A] = new Rig[Filter[A]] {  
  def plus(x: Filter[A], y: Filter[A]): Filter[A] = v =&gt; x(v) || y(v)
  def one: Filter[A] = Function.const(true)
  def times(x: Filter[A], y: Filter[A]): Filter[A] = v =&gt; x(v) &amp;&amp; y(v)
  def zero: Filter[A] = Function.const(false)
} 

import spire.syntax.rig._

users filter ((london + ny) * kelly)  
</code></pre>

<h2 id="monoidwithbooleanwoptionwandendo">Monoid with BooleanW, OptionW and Endo</h2>

<p><code>Boolean</code> 과 <code>Option</code> 은, 연산에 <code>if-else</code>, <code>getOrElse</code> 처럼  <strong>다른 경우</strong> 를 내포하기 때문에, <code>Monoid.zero</code> 와 엮으면 쏠쏠하게 써먹을 수 있습니다.</p>

<pre><code class="language-scala">&gt; load.ivy("org.scalaz" % "scalaz-core_2.11" % "7.2.0-M5")

&gt; import scalaz._, Scalaz._
import scalaz._, Scalaz._

&gt; ~ 1.some      // Some(1).getOrElse(Monoid[Int].zero)
res5: Int = 1  
&gt; ~ none[Int]   // None.getOrElse(Monoid[Int].zero)
res6: Int = 0  
&gt; none[Int] | 3 // None.getOrElse(3)
res7: Int = 3  
</code></pre>

<p><code>Boolean</code> 연산도 살펴보면,</p>

<pre><code class="language-scala">(true  ? 1 | 2) shouldBe 1
(false ? 1 | 2) shouldBe 2
(true  ?? 1) shouldBe 1
(false ?? 1) shouldBe 0 /* raise into zero */
(true  !? 1) shouldBe 0 /* reversed `??` */
(false !? 1) shouldBe 1
</code></pre>

<p><code>??</code> 는 조건이 참일경우, <code>A</code> 를 아닐 경우 <code>Monoid[A].zero</code> 를 돌려줍니다.</p>

<pre><code class="language-scala">final class BooleanOps(self: Boolean) {  
  ...
  final def ??[A](a: =&gt; A)(implicit z: Monoid[A]): A = b.valueOrZero(self)(a)
  final def !?[A](a: =&gt; A)(implicit z: Monoid[A]): A = b.zeroOrValue(self)(a)
  ...
}

trait BooleanFunctions {  
  ...
  final def valueOrZero[A](cond: Boolean)(value: =&gt; A)(implicit z: Monoid[A]): A = 
    if (cond) value else z.zero
  final def zeroOrValue[A](cond: Boolean)(value: =&gt; A)(implicit z: Monoid[A]): A = 
    if (!cond) value else z.zero
  ...
}
</code></pre>

<p><a href="http://www.slideshare.net/oxbow_lakes/practical-scalaz">Practical Scalaz</a> 에서는 <code>Endo</code> 와 엮어 다음처럼 사용하는걸 보여줍니다. (<code>new Filter</code> 부분을 추출하는것이 더 나은것 같습니다만, 그냥 이렇게도 사용할 수 있다 정도로 알고만 계시면 될 것 같습니다.)</p>

<pre><code class="language-xml">// http://www.slideshare.net/oxbow_lakes/practical-scalaz

&lt;instruments filter="incl"&gt;  
  &lt;symbol value="VOD.L" /&gt;
  &lt;symbol value="MSFT.O" /&gt; 
&lt;/instruments&gt;  
</code></pre>

<pre><code class="language-scala">// before
for {  
  e &lt;- xml \ "instrument"
  f &lt;- e.attribute("filter")
} yield
  (if f == "incl") new Filter(instr(e)) else new Filter(instr(e)).neg)

// after
val reverseFilter = Endo[Filter](_.neg)

for {  
  e &lt;- xml \ "instrument"
  f &lt;- e.attribute("filter")
} yield
  (f == "incl") !? reverseFilter apply new Filter(instr(e))
</code></pre>

<p>참고로 <code>Endo</code> 는 <code>Function1[A, A]</code> 입니다. 따라서 <code>Monoid[Endo[A]]</code> 는 <em>identity function</em> 입니다. </p>

<pre><code class="language-scala">final case class Endo[A](run: A =&gt; A) {  
  final def apply(a: A): A = run(a)

  /** Do `other`, than call myself with its result. */
  final def compose(other: Endo[A]): Endo[A] = Endo.endo(run compose other.run)

  /** Call `other` with my result. */
  final def andThen(other: Endo[A]): Endo[A] = other compose this
}

trait EndoFunctions {  
  /** Alias for `Endo.apply`. */
  final def endo[A](f: A =&gt; A): Endo[A] = Endo(f)

  /** Alias for `Monoid[Endo[A]].zero`. */
  final def idEndo[A]: Endo[A] = endo[A](a =&gt; a)

  ...
}
</code></pre>

<h2 id="examplecurrency">Example: Currency</h2>

<p>이제까지 배워왔던 바를 적용해서, 통화를 나타내는 <code>Currency</code> 모델을 만들어 보겠습니다. 위에선 <code>Tag</code> 를 이용했었으니, 이번엔 <em><a href="http://docs.scala-lang.org/overviews/core/value-classes.html">Value Class</a></em> 로 만들어 보겠습니다.</p>

<pre><code class="language-scala">object Currency {  
  sealed trait Currency extends Any
  final case class EUR[A](amount: A) extends AnyVal with Currency
  final case class USD[A](amount: A) extends AnyVal with Currency
}

// spec
USD(1) =:= USD(1)  
USD(3) =:= EUR(2) // compile error  
</code></pre>

<p>이제 <code>1.USD</code> 등 의 문법을 위해 <em>implicit class</em> 를 추가하면,</p>

<pre><code class="language-scala">Object Currency {  
  ...

  implicit class CurrencyOps[A](amount: A) {
    def EUR = Currency3.EUR(amount)
    def USD = Currency3.USD(amount)
  }
}

// spec
10.USD =:= 10.USD  
</code></pre>

<p>이제 같은 통화간 덧셈을 위해, <code>Monoid[USD[A]]</code> 등을 추가할 수 있습니다. <code>|+|</code> 는 기존의 <code>Monoid[A]</code> 를 이용하면 됩니다.</p>

<pre><code class="language-scala">object Currency {  
  import scalaz._, Scalaz._

  ...
  implicit def usdMonoid[A](implicit M: Monoid[A]) = new Monoid[USD[A]] {
    override def zero: USD[A] =
      USD(M.zero)

    override def append(u1: USD[A], u2: =&gt; USD[A]): USD[A] =
      USD(M.append(u1.amount, u2.amount))
  }
}

// spec
(10.USD |+| 10.USD) =:= 20.USD
</code></pre>

<p>이제 <code>EUR</code> 를 위한 모노이드를 만들어 보겠습니다. 재미삼아 <em><a href="http://docs.scala-lang.org/tutorials/FAQ/context-and-view-bounds.html">context bound</a></em> 를 이용해 보면,</p>

<pre><code class="language-scala">object Currency {  
  ...

  implicit def eurMonoid[A : Monoid] = new Monoid[EUR[A]] {
    override def zero: EUR[A] =
      EUR(implicitly[Monoid[A]].zero)

    override def append(e1: EUR[A], e2: =&gt; EUR[A]): EUR[A] =
      EUR(implicitly[Monoid[A]].append(e1.amount, e2.amount))
  }
}
</code></pre>

<p>통화가 추가될때 마다 매번 반복적으로 모노이드를 추가해야된다는 것이 귀찮으므로, <code>Currency</code> 용 모노이드를 만들겠습니다. <em><a href="https://github.com/milessabin/shapeless">Shapeless</a></em> 를 이용하면, (<em>Shapeless</em> 의 <code>Generic</code>, <code>Aux</code> 는 아래에서 설명하겠습니다)</p>

<pre><code class="language-scala">object Currency {  
  import scalaz._, Scalaz._
  import shapeless._

  ...
  implicit def currencyMonoid[A : Monoid, C[_] &lt;: Currency]
  (implicit G: Generic.Aux[C[A], A :: HNil]) = new Monoid[C[A]] {
    override def zero: C[A] =
      G.from(implicitly[Monoid[A]].zero :: HNil)

    override def append(c1: C[A], c2: =&gt; C[A]): C[A] = {
      val a1: A = G.to(c1).head
      val a2: A = G.to(c2).head

      G.from(implicitly[Monoid[A]].append(a1, a2) :: HNil)
    }
  }
}
</code></pre>

<p>이제 통화간 변환을 위한 함수를 추가해보도록 하겠습니다. 이런 문법은 어떨까요?</p>

<pre><code class="language-scala">12.USD to EUR  
</code></pre>

<p>그런데, 현재 우리가 가진 디자인에서 <code>EUR</code> 은 <em>case class</em> 이므로 <code>EUR</code> 생성없이 타입만 지정하려면 이정도 문법으로 타협할 수 있겠네요.</p>

<pre><code class="language-scala">24.USD to[EUR]  
</code></pre>

<p><code>Currency</code> 에서 <code>to</code> 구현을 하려면, <code>to[C[_] &lt;: Currency[_]]</code> 정도로 하위 클래스는 퉁친다 해도, 하위 클래스 인스턴스 생성시에 <code>A</code> 가 필요하므로 <code>Currency</code> 를 <code>Currency[A]</code> 로 변경해야 합니다.</p>

<pre><code class="language-scala">object Currency {  
  sealed trait Currency[A] extends Any {
    def amount: A
  }

  final case class EUR[A](amount: A) extends AnyVal with Currency[A]
  final case class USD[A](amount: A) extends AnyVal with Currency[A]

  implicit class CurrencyOps[A](amount: A) {
    def EUR = Currency3.EUR(amount)
    def USD = Currency3.USD(amount)
  }

  implicit def currencyMonoid[A : Monoid, C[A] &lt;: Currency[A]]
  (implicit G: Generic.Aux[C[A], A :: HNil]) = new Monoid[C[A]] {
    override def zero: C[A] =
      G.from(implicitly[Monoid[A]].zero :: HNil)

    override def append(c1: C[A], c2: =&gt; C[A]): C[A] = {
      val a1: A = G.to(c1).head
      val a2: A = G.to(c2).head

      G.from(implicitly[Monoid[A]].append(a1, a2) :: HNil)
    }
  }
}
</code></pre>

<p>이제 <code>Currency</code> 에 <code>to</code> 를 추가하면,</p>

<pre><code class="language-scala">object Currency {  
  ...

  sealed trait Currency[A] extends Any {
    def amount: A
    def to[C[A] &lt;: Currency[A]](implicit G: Generic.Aux[C[A], A :: HNil]): C[A] =
      G.from(amount :: HNil)
  }

  ...
}

// spec
(10.USD.to[EUR]) =:= 10.EUR
</code></pre>

<p><code>to</code> 에 <code>implicit</code> 로 통화간 환율을 담고있는 <code>R: Rate</code> 등을 추가하고 <code>Rate</code> 내에서 <code>Monoid[A @@ Multiplcation</code> 을 이용하면 컴파일타임에 </p>

<ul>
<li><code>USD -&gt; EUR</code> 변환이 정의되어 있는지 (<a href="https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#heterogenous-maps">Shapeless Heterogenous Maps</a>)</li>
<li><code>A</code> 에 대한 곱셈 연산 <code>Monoid[A @@ Multiplication]</code> 이 정의 되어있는지를 검사할 수 있습니다.</li>
</ul>

<p><del>구현은 숙제로.. 제가 귀찮아서가 절대 아닙니다</del></p>

<p>디자인적인 결정이겠으나, <code>USD</code>, <code>EUR</code> 등을 <code>object</code> 로 만들고 <code>case class Money[A](amount: A, currency: Currency)</code> 로 구현할수도 있겠습니다. 관심 있으신 분은 <a href="https://github.com/lambdista/money">github.com/lambdista/money</a> 를 참조하시면 됩니다.</p>

<h2 id="shapeless">Shapeless</h2>

<p><em>Shapeless</em> 는 많은 기능을 가지고 있기 때문에 여기서 모든걸 설명하긴 어렵고, 위에서 사용한 <code>Generic</code>, <code>Aux</code> 에 대해 간단히 소개만 하겠습니다. (관심 있으신 분은 <a href="https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0">Shapeless - Feature 2.0.0</a> 를 참조하시면 됩니다.)</p>

<pre><code class="language-scala">// https://github.com/milessabin/shapeless/blob/master/core/src/main/scala/shapeless/generic.scala

&gt; load.ivy("com.chuusai" %% "shapeless" % "2.2.5")

&gt; import shapeless._
import shapeless._

&gt; case class Cat(name: String, catAge: Double)
defined class Cat  
&gt; Generic[Cat]
res4: Generic[Cat] {  
  type Repr = 
    shapeless.::[String,shapeless.::[Double,shapeless.HNil]]
} = ...
</code></pre>

<p><code>Generic[A]</code> 는 <a href="http://danielwestheide.com/blog/2013/02/13/the-neophytes-guide-to-scala-part-13-path-dependent-types.html">Path-Dependent Type</a> 으로 <code>Repr</code> 을 가지고 있습니다. 이는 <code>A</code> 에 따라 달라지는 값인데, 보통 <code>R</code> 로 표기합니다.</p>

<pre><code class="language-scala">// https://github.com/milessabin/shapeless/blob/master/core/src/main/scala/shapeless/generic.scala#L103

trait Generic[T] extends Serializable {  
  /** The generic representation type for {T}, which will be composed of {Coproduct} and {HList} types  */
  type Repr

  /** Convert an instance of the concrete type to the generic value representation */
  def to(t : T) : Repr

  /** Convert an instance of the generic representation to an instance of the concrete type */
  def from(r : Repr) : T
}
</code></pre>

<p><code>Generic.Aux[A, R]</code> 는 <code>Generic[A]</code> 의 <code>Repr</code> 에 <code>R</code> 을 사용하는것으로, <code>Generic[A] { type Repr = R }</code> 과 동일합니다.</p>

<pre><code class="language-scala">// https://github.com/milessabin/shapeless/blob/master/core/src/main/scala/shapeless/generic.scala#L148

object Generic {  
  ...

  type Aux[T, Repr0] = Generic[T] { type Repr = Repr0 }

  ...
}
</code></pre>

<p><code>Generic.Aux[A, R]</code> 을 이용하면, 타입수준의 표현 <code>R</code> 과 실제 타입 <code>A</code> 간<em>isomorphic</em> 변환을 수행할 수 있습니다. 위에서 봤던 <code>to</code> 와 <code>from</code> 기억 하시죠? </p>

<p>만약 <code>R</code> 이 기본적인 타입이어서, <code>Generic.Aux[A, R]</code> 이 Shapeless 에서 자동 생성해 줄 경우 <code>Currency</code> 예제에서 보았듯이 <code>implicit</code> 로 가져오면, 바로 이용할 수 있습니다. </p>

<p><em>primitive</em> 는 물론 <em>case class</em> 도 <code>Generic[Cat]</code> 처럼 자동생성되어 바로 가져다 쓸 수 있습니다. 중첩된것두 가능하구요.</p>

<pre><code class="language-scala">&gt; case class EnhancedCat(catType: String, cat: Cat)
defined class EnhancedCat

&gt; Generic[EnhancedCat]
res6: Generic[EnhancedCat] {  
  type Repr = shapeless.::[String,shapeless.::[cmd3.Cat,shapeless.HNil]]
} = ...
</code></pre>

<p>여기서 <code>HList</code> 는 (<a href="https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#heterogenous-lists">Heterogenous List</a>) 여러 타입을 담을 수 있는 리스트입니다.</p>

<p>이제 <code>to</code> 와 <code>from</code> 예제를 보면</p>

<pre><code class="language-scala">&gt; val c1 = Cat("odie", 1.0)
c1: Cat = Cat("odie", 1.0)

&gt; Generic[Cat].to(c1)
res9: String :: Double :: HNil = ::("odie", ::(1.0, HNil))

&gt; val reconstructed = Generic[Cat].from(res9)
reconstructed: Cat = Cat("odie", 1.0)

&gt; case class Dog(name: String, dogAge: Double)
defined class Dog

&gt; val d1 = Dog("dog odie", 1.0)
d1: Dog = Dog("dog odie", 1.0)

&gt; Generic[Dog].to(d1)
res13: String :: Double :: HNil = ::("dog odie", ::(1.0, HNil))

&gt; val reconstructedFromDog = Generic[Cat].from(res13)
reconstructedFromDog: Cat = Cat("dog odie", 1.0)  
</code></pre>

<p><a href="https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/">metaplasm.us - Type Classes and Generic Derivation</a> 에서는 <em>Shapeless</em> 를 이용해서 문자열로부터 <em>case class</em> 를 자동생성하는 파서를 만드는 법을 보여줍니다.</p>

<p><code>CaseClassParser</code> 가 있을 때, 문자열 <code>"odie, 1.2"</code> 를 <code>Dog</code> 로 파싱하기 위해 <code>CaseClassParser[Dog]("odie, 1.2")</code> 처럼 쓰고싶다고 하면,</p>

<pre><code class="language-scala">// ref - https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/

object CaseClassParser {  
  import shapeless._

  trait Parser[A] {
    def apply(s: String): Option[A]
  }

  def apply[A](s: String)(implicit P: Parser[A]): Option[A] = P(s)
}
</code></pre>

<p>이 때 <code>shapeless.Generic[A]</code> 를 이용하면 위에서 보았듯이 <code>A</code> 를 <code>HList</code> 로 (<a href="https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#heterogenous-lists">Heterogenous List</a>) 로 변경할 수 있으므로 <code>Parser[HList]</code> 만 있으면 됩니다.</p>

<p><code>HList</code> 도 <code>List</code> 처럼 <code>cons</code> 와 <code>nil</code> 로 구성되어 있습니다. <code>HNil</code> 과 <code>HList</code> 파서를 만들면,</p>

<pre><code class="language-scala">// ref - https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/

object CaseClassParser {  
  ...

  implicit val hnilParser = new Parser[HNil] {
    override def apply(s: String): Option[HNil] =
      if (s.isEmpty) Some(HNil) else None
  }

  implicit def hlistParser[H : Parser, T &lt;: HList : Parser] = new Parser[H :: T] {
    override def apply(s: String): Option[H :: T] =
      s.split(",").toList match {
        case cell +: rest /* use `+:` instead of :: */ =&gt; for {
          head &lt;- implicitly[Parser[H]].apply(cell)
          tail &lt;- implicitly[Parser[T]].apply(rest.mkString(","))
        } yield head :: tail
      }
  }
}
</code></pre>

<p>그리고 <code>implicitly[Parser[H]]</code> 에서 사용할 개별 타입별 파서를 만들면</p>

<pre><code class="language-scala">// ref - https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/

object CaseClassParser {  
  ...

  implicit val intParser = new Parser[Int] {
    override def apply(s: String): Option[Int] = Try(s.toInt).toOption
  }

  implicit val stringParser = new Parser[String] {
    override def apply(s: String): Option[String] = Some(s)
  }

  implicit val doubleParser = new Parser[Double] {
    override def apply(s: String): Option[Double] = Try(s.toDouble).toOption
  }
}
</code></pre>

<p>마지막으로, <em>case class</em> 를 <code>HList</code> 로 만들어줄 <code>caseClassParser</code> 만 만들면 됩니다.</p>

<pre><code class="language-scala">// ref - https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/

object CaseClassParser {  
  ...

  implicit def caseClassParser[C, R &lt;: HList]
  (implicit G: Generic.Aux[C, R], reprParser: Parser[R]): Parser[C] = new Parser[C] {
    override def apply(s: String): Option[C] = reprParser.apply(s).map(G.from)
  } 
}
</code></pre>

<p><code>reprParser.apply(s)</code> 는 <code>Option[R]</code> 이므로 <code>G.from</code> 을 이용해 변환해주면 됩니다.</p>

<h2 id="previousposts">Previous Posts</h2>

<ul>
<li><a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1, State</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/">Easy Scalaz 2, Monad Transformer</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/">Easy Scalaz 3, ReaderWriterState with Kleisli</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/">Easy Scalaz 4, Yoneda and Free Monad</a> </li>
</ul>

<h2 id="references">References</h2>

<ul>
<li><a href="http://cs.lth.se/edan40">Haskell Image</a></li>
<li><a href="http://eed3si9n.com/learning-scalaz/Tagged+type.html">Learning Scalaz: Tagged Type</a></li>
<li><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Tag.scala">Scalaz 7.2: Tag.scala</a></li>
<li><a href="https://groups.google.com/forum/#!topic/scalaz/Py_IIfp9d2Q">Scalaz Google Groups: Value Class vs Tag</a></li>
<li><a href="http://docs.scala-lang.org/overviews/core/value-classes.html">Scala Docs: Value Classes</a></li>
<li><a href="http://docs.scala-lang.org/tutorials/FAQ/context-and-view-bounds.html">Scala Docs: Context Bound</a></li>
<li><a href="http://etorreborre.blogspot.kr/2011/11/practical-uses-for-unboxed-tagged-types.html">Practical uses for Unboxed Tagged Types</a></li>
<li><a href="http://www.slideshare.net/IainHull/improving-correctness-with-types">Improving Correctness with Types</a></li>
<li><a href="http://underscore.io/blog/posts/2014/01/29/unboxed-tagged-angst.html">Underscore: Unboxed Tagged Angst</a></li>
<li><a href="http://www.slideshare.net/oxbow_lakes/practical-scalaz">Slideshare: Practical Scalaz</a></li>
<li><a href="http://stackoverflow.com/questions/34266285/tagged-type-comparison-in-scalaz">Stackoverflow: Tagged Type Comprarison in Scalaz</a></li>
<li><a href="https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0">Shapeless: Feature 2.0.0</a></li>
<li><a href="http://danielwestheide.com/blog/2013/02/13/the-neophytes-guide-to-scala-part-13-path-dependent-types.html">The Neophyte's Guide to Scala Part 13: Path-Dependent Type</a></li>
<li><a href="https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/">metaplasm.us: Type classes and generic derivation</a></li>
<li><a href="http://stackoverflow.com/questions/33585441/constructing-simple-scala-case-classes-from-strings-strictly-without-boiler-pla/33586304#33586304">Stackoverflow: Constructing simple Scala case classes from Strings, strictly without boiler-plate</a></li>
</ul>
    </section>

    <footer>
      <section class="author_info margin_top_big">
        <div class="alignleft border rad_circle" style="height: 87px; width: 87px; background-image: url(http://www.gravatar.com/avatar/aa2032ba2302419e3c2ede54f1fbf687?d=404&amp;s=250); background-size: cover;"></div>
        <p class="margin_left_medium text small">Author</p>
        <p class="margin_left_medium text bold"><a href="http://1ambda.github.io">1ambda</a></p>
        <p class="margin_left_medium text small">Functional, Scala, Akka, Rx and Haskell</p>
      </section>
    </footer>


    <div id="disqus_thread" class="margin_top_big"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = '1ambda'; // required: replace example with your forum shortname
  var disqus_identifier = '136';
  var disqus_url = 'http://1ambda.github.io/easy-scalaz-5-playing-with-monoids/';

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
    </article>
</main>


  <script src="../assets/fitvids/jquery.fitvids.js"></script>
<script>
$(document).ready(function(){
  // Target your .container, .wrapper, .post, etc.
  $("section").fitVids();
});
</script>

  <footer class="blog_info margin_top_big padding_medium text center">
    <h5 class="text book small">© 2015 <a href="../">Old Lisper</a>. All rights reserved.</h5>
    <h5 class="text book small"><a href="https://github.com/dreyacosta/velox" target="_blank" class="text bold">Velox theme</a> by <a href="http://dreyacosta.com/">David Rey</a></h5>
    <h5 class="text book small">Proudly published with <a href="http://ghost.org"><span>Ghost</span></a></h5>

  </footer>

  <script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = '1ambda'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function () {
 var s = document.createElement('script'); s.async = true;
 s.type = 'text/javascript';
 s.src = '//' + disqus_shortname + '.disqus.com/count.js';
 (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
 }());
</script>


  </body>
  