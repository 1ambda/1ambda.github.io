<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/Blog">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

  <title>하스켈로 배우는 함수형 언어 7</title>
  <meta name="description" content="" />

  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="하스켈로 배우는 함수형 언어 7">
  <meta name="twitter:description" content="the countdown problem 은 프랑스 퀴즈 프로그램에서 유래한 문제입니다. 주어진 양수를 단 한번씩만 이용하여 특정 숫자를 만드는 문제입니다. 사용가능한 연산자는 +, *, -, / 입니다. 예를 들어 (25 - 10) * (50 + 1) = 765 입니다.  사람이 풀기엔 search space 가 좀 넓어서 답을 한번에 찾기 어렵지만, 컴퓨터는 무한한 인내심을 가지고 있기 때문에 풀기에 적합한">
  <meta name="twitter:creator" content="@yourTwitterUsername">
  <meta name="twitter:image" content="">
  <meta name="twitter:url" content="http://1ambda.github.io/haskell-intro7/">
  <meta name="twitter:domain" content="http://1ambda.github.io">


  <link rel="author" href="https://plus.google.com/101105410053351451441?rel=author" />

  <link rel="shortcut icon" href="../favicon.ico">

  <link rel="stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Droid+Serif" />
  <link rel='stylesheet' type='text/css' href="http://fonts.googleapis.com/css?family=Open+Sans:600,300" />
  <link rel="stylesheet" type="text/css" href="../assets/stylesheets/xpressio.css" />
  <link rel="stylesheet" type="text/css" href="../assets/1ambda/1ambda.css" />
  <script type="text/javascript" src="../assets/1ambda/modernizr.js">
  </script>
  <script type="text/javascript" src="../assets/1ambda/detectizr.min.js">
  </script>

  <!--load css if windows -->
  <script type="text/javascript">
    if (Modernizr.windows) {
      file = location.pathname.split( "/" ).pop();
      link = document.createElement( "link" );
      link.href = "/assets/1ambda/1ambda_windows.css";
      link.type = "text/css";
      link.rel = "stylesheet";
      link.media = "screen,print";
      document.getElementsByTagName("head")[0].appendChild( link );
    }
  </script>


  <link rel="stylesheet" href="../assets/highlight/styles/github.css">
  <script src="../assets/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <meta name="generator" content="Ghost 0.5" />
<link rel="alternate" type="application/rss+xml" title="Old Lisper" href="../rss">
<link rel="canonical" href="http://1ambda.github.io/haskell-intro7/" />

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
    ga('create', 'UA-52181619-1', '1ambda.github.io');
    ga('send', 'pageview');
  </script>
  
</head>
<body>

  <script src="../public/jquery.js?v=5e102a0e1b"></script>

  
<header class="site_width text center padding_top_big margin_bottom_big">
  
  <h1 class="blog_title margin_bottom_small"><a href="http://1ambda.github.io">Old Lisper</a></h1>
  <h4 class="text book">Functional Programming</h4>
  <div class="social border solid top_small bottom_small padding_medium">
    <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="../articles"><i class="fa fa-columns"></i> <span class="margin_left_small desktop">Article</span></a></h6>
    <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="http://kr.linkedin.com/in/1ambda" target="_blank"><i class="fa fa-linkedin-square"></i> <span class="margin_left_small desktop">Linkedin</span></a></h6>
    <h6 class="text book color c_black_medium without_margin"><a href="http://github.com/1ambda" target="_blank"><i class="fa fa-github"></i> <span class="margin_left_small desktop">GitHub</span></a></h6>
  </div>
</header>

<main class="site_width" role="main">
  <article class="post tag-edx tag-haskell">


    <header class="text center margin_bottom_medium">
      <h5 class="text book small uppercase color c_black_light margin_bottom_small">Posted in <a href="../tag/edx">edx</a>, <a href="../tag/haskell">haskell</a></h5>
      <h1 class="margin_bottom_medium">하스켈로 배우는 함수형 언어 7</h1>
      <h5 class="text book small uppercase color c_black_light margin_bottom_small"><time datetime="2014-11-27">Thursday, November 27, 2014</time>
      <br/><br/>
       <a href="http://1ambda.github.io/haskell-intro7/#disqus_thread">Comment</a>
      </h5>
    </header>

    <section>
      <p><em>the countdown problem</em> 은 프랑스 퀴즈 프로그램에서 유래한 문제입니다. 주어진 양수를 단 한번씩만 이용하여 특정 숫자를 만드는 문제입니다. 사용가능한 연산자는 <code>+, *, -, /</code> 입니다.</p>

<p>예를 들어 <code>(25 - 10) * (50 + 1) = 765</code> 입니다. </p>

<p>사람이 풀기엔 <em>search space</em> 가 좀 넓어서 답을 한번에 찾기 어렵지만, 컴퓨터는 무한한 인내심을 가지고 있기 때문에 풀기에 적합한 문제입니다.</p>

<h3 id="evaluatingexpressions">Evaluating Expressions</h3>

<p>이번시간엔 <em>bottom-up</em> 으로 접근해 볼까요? 먼저 연산자타입과 이를 적용하는 함수 <code>apply</code> 를 만들어보면</p>

<pre><code class="haskell">data Op = Add | Sub | Mul | Div

apply :: Op -&gt; Int -&gt; Int -&gt; Int  
apply Add x y = x + y  
apply Sub x y = x - y  
apply Mul x y = x * y  
apply Div x y = x `div` y  
</code></pre>

<p>그리고 우리가 가진건 양수이기 때문에, 연산의 결과가 양수인지 체크하기 위한 <code>valid</code> 함수를 만들어 보겠습니다. </p>

<pre><code class="haskell">valid :: Op -&gt; Int -&gt; Int -&gt; Bool  
valid Add _ _ = True  
valid Sub x y = x &gt; y  
valid Mul _ _ = True  
valid Div x y = x `mod` y == 0  
</code></pre>

<p>이제 수식을 나타내는 <code>Expr</code> 타입과 평가하기 위한 <code>eval</code> 함수를 만들면</p>

<pre><code class="haskell">data Expr = Val Int = App Op Expr Expr

eval :: Expr -&gt; [Int]  
eval (Val n) = [n | n &gt; 0]  
eval (App o l r) = [apply o x y | x &lt;- eval l,  
                                  y &lt;- eval r,
                                  valid o x y]
</code></pre>

<p>여기선 연산이 실패했음을 나타내기 위해 <code>[]</code> 를 사용했습니다. <code>Maybe</code> 타입 대신 리스트를 쓸 때의 장점은, <em>list comprehension</em> 을 이용할 수 있다는 점이지요!</p>

<h3 id="formalizingtheproblem">Formalizing The Problem</h3>

<p>우리가 풀어야할 문제는 가능한 모든 조합을 탐색해야하기 때문에 다양한 조합을 만들기 위한 <code>choices</code> 함수를 만들겠습니다.</p>

<pre><code class="haskell">-- subs [1, 2] -&gt; [[], [1], [2], [1, 2]]
subs :: [a] -&gt; [[a]]  
subs [] = [[]]  
subs (x:xs) = yss ++ map (x:) yss  
  where yss = subs xs

-- interleave 1 [2, 3] -&gt; [[1, 2, 3], [2, 1, 3], [2, 3, 1]]
interleave :: a -&gt; [a] -&gt; [[a]]  
interleave x [] = [[x]]  
interleave x (y:ys) = (x:y:ys) : map (y:) (interleave x ys)

-- perm [1, 2, 3] = [[1, 2, 3], [1, 3, 2], [2, 3, 1], ..]
perm :: [a] -&gt; [[a]]  
perm [] = [[]]  
perm (x:xs) = concat (map (interleave x) (perm xs))

-- choices [1, 2] -&gt; [[], [1], [2], [1, 2], [2, 1]]
choices :: [a] -&gt; [[a]]  
choices xs = concat (map (perm) (subs xs))  
</code></pre>

<p>여기서 <code>subs</code> 함수는 순서를 고려하지 않은 부분집합을, <code>perm</code> 는 순열을 돌려줍니다. <code>choices</code> 는 이 두 함수를 조합하여 부분집합의 순열리스트를 돌려줍니다.</p>

<p>이제 입력한 수식이 정답인지 알려주는 <code>solution</code> 함수를 볼까요? 입력한 수식의 결과가 주어진 수 <code>n</code> 과 같아야 하고, 수식에 있는 숫자가 주어진 숫자들의 나열 <code>ns</code> 와 같아야 합니다.</p>

<pre><code class="haskell">values :: Expr -&gt; [Int]  
values (Val n) = [n]  
values (App _ l r) = values l ++ values r

solution :: Expr -&gt; [Int] -&gt; Int -&gt; Bool  
solution e ns n = elem (values e) (choices ns) &amp;&amp; eval e == [n]  
</code></pre>

<h3 id="bruteforce">Brute Force</h3>

<p>브루트 포스 방법으로 풀려면, 사용가능한 수들을 받아, 가능한 모든 수식을 돌려주면 됩니다.</p>

<pre><code class="haskell">-- brute force
split :: [a] -&gt; [([a], [a])]  
split xs = [splitAt i xs | i &lt;- [1..(n-1)]]  
  where n = length xs

exprs :: [Int] -&gt; [Expr]  
exprs [] = []  
exprs [n] = [Val n]  
exprs ns = [e | (ls, rs) &lt;- split ns  
              , l &lt;- exprs ls
              , r &lt;- exprs rs
              , e &lt;- combine l r]

combine :: Expr -&gt; Expr -&gt; [Expr]  
combine l r = [App o l r | o &lt;- [Add, Sub, Mul, Div]]

-- brute force solutions
bSolutions :: [Int] -&gt; Int -&gt; [Expr]  
bSolutions ns n = [e | ns' &lt;- choices ns  
                     , e &lt;- exprs ns'
                     , eval e == [n]]
</code></pre>

<p>아주아주아주아주 느립니다. 제 컴퓨터에서는 2분이 지나도 답이 안나오네요.</p>

<pre><code class="haskell">&gt; length (Bolutions [1, 3, 7, 10, 25, 50] 765)
</code></pre>

<h3 id="fastversion">Fast version</h3>

<p>어느부분을 고쳐야 더 빨라질까요? 한가지 개선할 부분은, <code>valid</code> 가 너무 늦게 호출된다는 점입니다. 우리가 어마어마한 식을 만드는 반면, 답이 780개란 사실은 대부분의 식이 값보다는 형태에 의해 필터링 된다는 뜻입니다. 따라서 <code>valid</code> 를 좀 더 땡길 수 있다면 계산이 훨씬 빨라질겁니다.</p>

<pre><code class="haskell">eval :: Expr -&gt; [Int]  
eval (Val n) = [n | n &gt; 0]  
eval (App o l r) = [apply o x y | x &lt;- eval l,  
                                  y &lt;- eval r,
                                  valid o x y]

exprs :: [Int] -&gt; [Expr]  
exprs [] = []  
exprs [n] = [Val n]  
exprs ns = [e | (ls, rs) &lt;- split ns  
              , l &lt;- exprs ls
              , r &lt;- exprs rs
              , e &lt;- combine l r]

bSolutions :: [Int] -&gt; Int -&gt; [Expr]  
bSolutions ns n = [e | ns' &lt;- choices ns  
                     , e &lt;- exprs ns'
                     , eval e == [n]]
</code></pre>

<p>이 부분을 좀 고쳐보겠습니다. </p>

<pre><code class="haskell">results :: [Int] -&gt; [Result]  
results [] = []  
results [n] = [(Val n, n) | n &gt; 0]  
results ns = [res | (ls, rs) &lt;- split ns  
                  , lx &lt;- results ls
                  , ry &lt;- results rs
                  , res &lt;- combine' lx ry]

combine' :: Result -&gt; Result -&gt; [Result]  
combine' (l,x) (r, y) =  
  [(App o l r, apply o x y) | o &lt;- [Add, Sub, Mul, Div]
                            , valid o x y]

fastSolutions :: [Int] -&gt; Int -&gt; [Expr]  
fastSolutions ns n = [e | ns' &lt;- choices ns  
                       , (e, m) &lt;- results ns'
                       , m == n]
</code></pre>

<p>값을 평가하기 전에 먼저 <code>valid</code> 를 호출하고 계산된 값을 튜플에 저장해 놓았다가 나중에 비교합니다.</p>

<pre><code class="haskell">&gt; length (Bolutions [1, 3, 7, 10, 25, 50] 765)
-- 780
</code></pre>

<p>더 개선할 수 있을까요? 음.. 생각해보니 <code>x * y = y * x</code> 이기도 하고 <code>x * 1</code> 은 <code>x</code> 이기도 하네요. 이런것들을 좀 줄일수 있을겁니다. <code>valid</code> 함수를 고쳐보도록 하지요.</p>

<pre><code class="haskell">valid :: Op -&gt; Int -&gt; Int -&gt; Bool  
valid Add _ _ = True  
valid Sub x y = x &gt; y  
valid Mul _ _ = True  
valid Div x y = x `mod` y == 0

-- modified
valid :: Op -&gt; Int -&gt; Int -&gt; Bool  
valid Add x y = x &lt;= y  
valid Sub x y = x &gt; y  
valid Mul x y = x &lt;= y &amp;&amp; x /= 1 &amp;&amp; y /= 1  
valid Div x y = x `mod` y == 0 &amp;&amp; y /= 1  
</code></pre>

<p><code>x &lt;= y</code> 로 만들어 중복을 제거하고 <code>x /= 1</code> 을 이용해 1을 곱한 수식을 제거했습니다. 결과가 정말 빠르게 나옵니다. </p>

<p>책에서 말하기를 브루트 포스 방법은 44초, 그 다음버전은 4초, 마지막 버전은 0.44 초 만에 계산이 끝난다고 합니다. 연산 시간이 어마어마하게 줄어들었죠?</p>

<pre><code class="haskell">&gt; length (Bolutions [1, 3, 7, 10, 25, 50] 765)
-- 49
</code></pre>

<h3 id="references">References</h3>

<p>(1) <strong>DelftX FP 101x</strong> <br />
(2) <em>Programming in Haskell</em>  </p>
    </section>

    <footer>
      <section class="author_info margin_top_big">
        <div class="alignleft border rad_circle" style="height: 87px; width: 87px; background-image: url(http://www.gravatar.com/avatar/aa2032ba2302419e3c2ede54f1fbf687?d=404&amp;s=250); background-size: cover;"></div>
        <p class="margin_left_medium text small">Author</p>
        <p class="margin_left_medium text bold"><a href="http://language.is">1ambda</a></p>
        <p class="margin_left_medium text small">Lisp, Emacs, FP</p>
      </section>
    </footer>


    <div id="disqus_thread" class="margin_top_big"></div>
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = '1ambda'; // required: replace example with your forum shortname
      var disqus_identifier = '68';
      var disqus_url = 'http://1ambda.github.io/haskell-intro7/';
    
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    </article>
</main>


  <script src="../assets/fitvids/jquery.fitvids.js"></script>
  <script>
  $(document).ready(function(){
    // Target your .container, .wrapper, .post, etc.
    $("section").fitVids();
  });
  </script>

  <footer class="blog_info margin_top_big padding_medium text center">
    <h5 class="text book small">&copy; 2015 <a href="..">Old Lisper</a>. All rights reserved.</h5>
    <h5 class="text book small"><a href="https://github.com/dreyacosta/velox" target="_blank" class="text bold">Velox theme</a> by <a href="http://dreyacosta.com/">David Rey</a></h5>
    <h5 class="text book small">Proudly published with <a href="http://ghost.org"><span>Ghost</span></a></h5>

  </footer>

  <script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = '1ambda'; // required: replace example with your forum shortname
  
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function () {
   var s = document.createElement('script'); s.async = true;
   s.type = 'text/javascript';
   s.src = '//' + disqus_shortname + '.disqus.com/count.js';
   (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
   }());
  </script>


  </body>
  </html>
