<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Old Lisper</title><description>Functional Programming World</description><link>http://1ambda.github.io/</link><generator>Ghost 0.6</generator><lastBuildDate>Sun, 06 Dec 2015 09:24:51 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Easy Scalaz 4, Yoneda and Free Monad</title><description>&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Free[F, A]&lt;/code&gt; 를 이용하면 Functor &lt;code&gt;F&lt;/code&gt; 를 Monad 인스턴스로 만들 수 있습니다. 그런데, &lt;code&gt;Coyoneda[G, A]&lt;/code&gt; 를 이용하면 아무 타입 &lt;code&gt;G&lt;/code&gt; 나 Functor 인스턴스로 만들 수 있으므로 어떤 타입이든 (심지어 방금 만든 &lt;em&gt;case class&lt;/em&gt; 조차) 모나드 인스턴스로 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Free&lt;/code&gt; 를 이용하면 사용자는 자신만의 &lt;em&gt;Composable DSL&lt;/em&gt; 을 구성하고,&lt;/p&gt;</description><link>http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/</link><guid isPermaLink="false">4bdf7e2f-ba28-4630-80d2-b44b3953a5a8</guid><category>scala</category><category>monad</category><category>monoid</category><category>scalaz</category><category>free</category><category>trampoline</category><category>yoneda</category><category>coyoneda</category><category>free monoid</category><category>free monad</category><dc:creator>1ambda</dc:creator><pubDate>Sun, 06 Dec 2015 08:34:34 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Free[F, A]&lt;/code&gt; 를 이용하면 Functor &lt;code&gt;F&lt;/code&gt; 를 Monad 인스턴스로 만들 수 있습니다. 그런데, &lt;code&gt;Coyoneda[G, A]&lt;/code&gt; 를 이용하면 아무 타입 &lt;code&gt;G&lt;/code&gt; 나 Functor 인스턴스로 만들 수 있으므로 어떤 타입이든 (심지어 방금 만든 &lt;em&gt;case class&lt;/em&gt; 조차) 모나드 인스턴스로 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Free&lt;/code&gt; 를 이용하면 사용자는 자신만의 &lt;em&gt;Composable DSL&lt;/em&gt; 을 구성하고, 구성한 모나딕 연산을 실행하는 해석기를 작성하게 됩니다. 즉, &lt;strong&gt;연산의 생성&lt;/strong&gt; 과 &lt;strong&gt;연산의 실행&lt;/strong&gt; 을 분리하여 다루게 됩니다. 이는 &lt;em&gt;side-effect&lt;/em&gt; 를 실행 시점으로 미룰 수 있다는 뜻입니다. (실행용 해석기와 별도로 테스트용 해석기를 작성하는 것도 가능합니다)&lt;/p&gt;

&lt;p&gt;그러면, 제가 가장 좋아하는 &lt;a href="http://tpolecat.github.io/assets/sbtb-slides.pdf"&gt;Programs as Values: Fure Functional JDBC Programming&lt;/a&gt; 예제로 시작해보겠습니다.&lt;/p&gt;

&lt;h2 id="ifwehaveamonad"&gt;If We Have a Monad&lt;/h2&gt;

&lt;p&gt;JDBC 를 쌩으로 사용한다면, 다음과 같은 코드를 작성해야 할텐데&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// ref - http://tpolecat.github.io/

case class Person(name: String, age: Int)

def getPerson(rs: ResultSet): Person {  
  val name = rs.getString(1)
  val age  = rs.getInt(2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음과 같은 문제점이 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;managed resource&lt;/em&gt; 인 &lt;code&gt;ResultSet&lt;/code&gt; 을 프로그래머가 다룰 수 있습니다. 어디에 저장이라도 하고 나중에 사용한다면 문제가 될 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rs.get*&lt;/code&gt; 은 &lt;em&gt;side-effect&lt;/em&gt; 를 만들어 내므로 테스트하기 쉽지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;접근 방식을 바꿔보는건 어떨까요? 프로그램을 실행해서 &lt;em&gt;side-effect&lt;/em&gt; 를 즉시 만드는 대신&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;어떤 연산을 수행할지를 &lt;em&gt;case class&lt;/em&gt; 로 만들고 이것들을 조합해 어떤 연산을 수행할지 나타낸뒤에&lt;/li&gt;
&lt;li&gt;연산의 조합을 번역해 실행하는 해석기(&lt;em&gt;interpreter&lt;/em&gt;) 를 만들어 보겠습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저 연산부터 정의하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;sealed trait ResultSetOp[A]

final case class GetString(index: Int) extends ResultSetOp[String]  
final case class GetInt(index: Int)    extends ResultSetOp[Int]  
final case object Next                 extends ResultSetOp[Boolean]  
final case object Close                extends ResultSetOp[Unit]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 때 만약 &lt;code&gt;ResultSetOp[A]&lt;/code&gt; 가 모나드라면 다음과 같이 작성할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def getPerson: ResultSetOp[Person] = for {  
  name &amp;lt;- GetString(1)
  age  &amp;lt;- GetInt(2)
} yield Person(name, age)

// Application Operation `*&amp;gt;`  (e.g `1.some *&amp;gt; 2.some== 2.some)
// See, http://eed3si9n.com/learning-scalaz/Applicative.html
def getNextPerson: ResultSetOp[Person] =  
  Next *&amp;gt; getPerson

def getPeople(n: Int): ResultSet[List[Person]] =  
  getNextPerson.repicateM(n) // List.fill(n)(getNextPerson).sequence

def getAllPeople: ResultSetIO[Vector[Person]] =  
  getPerson.whileM[Vector](Next)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ResultSetIO&lt;/code&gt; 는 모나드가 아니므로 위와 같이 작성할 수 없습니다.&lt;/p&gt;

&lt;h3 id="writingyourowndsl"&gt;Writing Your own DSL&lt;/h3&gt;

&lt;p&gt;놀랍게도, &lt;code&gt;ResultSetIO&lt;/code&gt; 를 모나드로 만들 수 있습니다. &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;unit&lt;/code&gt; 구현 없이 얻을 수 있는 공짜 모나드입니다. 방법은 이렇습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Free[F[_], ?]&lt;/code&gt; 는 &lt;code&gt;Functor&lt;/code&gt; &lt;code&gt;F&lt;/code&gt; 에 대해 &lt;code&gt;Monad&lt;/code&gt; 입니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Coyoneda[S[_], ?]&lt;/code&gt; 는 아무 타입 &lt;code&gt;S&lt;/code&gt; 에 대해 &lt;code&gt;Functor&lt;/code&gt; 입니다. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 &lt;code&gt;Free[Coyoneda[S, A], A&lt;/code&gt; 는 아무 타입 &lt;code&gt;S&lt;/code&gt; 에 대해서 모나드입니다. &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;import scalaz.{Free, Coyoneda}, Free._

// ResultSetOpCoyo is the Functor
type ResultSetOpCoyo[A] = Coyoneda[ResultSetOp, A] 

// ResultSetIO is the Monad
type ResultSetIO[A] = Free[ResultSetOpCoyo, A]

// same as
// type ResultSetIO2[A] = Free[({ type λ[α] = Coyoneda[ResultSetOp, α]})#λ, A]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 다음처럼 작성할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;val next                 : ResultSetIO[Boolean] = Free.liftFC(Next)  
def getString(index: Int): ResultSetIO[String]  = Free.liftFC(GetString(index))  
def getInt(index: Int)   : ResultSetIO[Int]     = Free.liftFC(GetInt(index))  
def close                : ResultSetIO[Unit]    = Free.liftFC(Close)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;Free.listFC&lt;/code&gt; 는 타입 &lt;code&gt;ResultSetOp&lt;/code&gt; 를 바로 &lt;code&gt;ResultSetIO&lt;/code&gt; 로 리프팅 해주는 헬퍼 함수입니다. (&lt;code&gt;F&lt;/code&gt; = &lt;em&gt;Free&lt;/em&gt;, &lt;code&gt;C&lt;/code&gt; = &lt;em&gt;Coyoneda&lt;/em&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Free.scala#L30

/** A version of `liftF` that infers the nested type constructor. */
def liftFU[MA](value: =&amp;gt; MA)(implicit MA: Unapply[Functor, MA]): Free[MA.M, MA.A] =  
  liftF(MA(value))(MA.TC)

/** A free monad over a free functor of `S`. */
def liftFC[S[_], A](s: S[A]): FreeC[S, A] =  
    liftFU(Coyoneda lift s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;liftFU[MA]&lt;/code&gt; 에서, &lt;code&gt;MA = Coyoneda[ResultSetOp, A]&lt;/code&gt; 로 보면 &lt;code&gt;Free[MA.M, MA.A]&lt;/code&gt; 는 &lt;code&gt;Free[Coyoneda[ResultSetOp, A], A]&lt;/code&gt; 가 됩니다. (&lt;a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Unapply.scala#L51"&gt;Unapply.scala&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;이를 이용해서 &lt;code&gt;get*&lt;/code&gt; 를 작성해 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;import scalaz._, Scalaz._

def getPerson: ResultSetIO[Person] = for {  
  name &amp;lt;- getString(1)
  age  &amp;lt;- getInt(2)
} yield Person(name, age)

def getNextPerson: ResultSetIO[Person] =  
  next *&amp;gt; getPerson

def getPeople(n: Int): ResultSetIO[List[Person]] =  
  getNextPerson.replicateM(n) // List.fill(n)(getNextPerson).sequence

def getPersonOpt: ResultSetIO[Option[Person]] =  
  next &amp;gt;&amp;gt;= {
    case true  =&amp;gt; getPerson.map(_.some)
    case false =&amp;gt; none.point[ResultSetIO]
  }

def getAllPeople: ResultSetIO[Vector[Person]] =  
  getPerson.whileM[Vector](next)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="dslinterpreter"&gt;DSL Interpreter&lt;/h3&gt;

&lt;p&gt;이제 &lt;code&gt;RestSetOp&lt;/code&gt; 로 작성한 연산 (일종의 프로그램) 을 실행하려면, &lt;code&gt;ResetSetOp&lt;/code&gt; 명령(&lt;em&gt;case class&lt;/em&gt;) 을, 로직(&lt;em&gt;side-effect&lt;/em&gt; 를 유발할 수 있는) 으로 변경해야 합니다. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;NaturalTransformation&lt;/code&gt; 을 이용할건데, &lt;code&gt;F ~&amp;gt; G&lt;/code&gt; 는 &lt;code&gt;F&lt;/code&gt; 를 &lt;code&gt;G&lt;/code&gt; 로 변경하는 변환(&lt;em&gt;Transformation&lt;/em&gt;) 을 의미합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/package.scala#L113

/** A [[scalaz.NaturalTransformation]][F, G]. */
type ~&amp;gt;[-F[_], +G[_]] = NaturalTransformation[F, G]

// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/NaturalTransformation.scala#L14
/** A universally quantified function, usually written as `F ~&amp;gt; G`,
  * for symmetry with `A =&amp;gt; B`.
  *
  * Can be used to encode first-class functor transformations in the
  * same way functions encode first-class concrete value morphisms;
  * for example, `sequence` from [[scalaz.Traverse]] and `cosequence`
  * from [[scalaz.Distributive]] give rise to `([a]T[A[a]]) ~&amp;gt;
  * ([a]A[T[a]])`, for varying `A` and `T` constraints.
  */
trait NaturalTransformation[-F[_], +G[_]] {  
  self =&amp;gt;
  def apply[A](fa: F[A]): G[A]

  def compose[E[_]](f: E ~&amp;gt; F): E ~&amp;gt; G = new (E ~&amp;gt; G) {
    def apply[A](ea: E[A]) = self(f(ea))
  }

  def andThen[H[_]](f: G ~&amp;gt; H): F ~&amp;gt; H =
    f compose self
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제, &lt;code&gt;ResultSetOp&lt;/code&gt; 를 &lt;code&gt;IO&lt;/code&gt; 로 변경하는 해석기를 작성하면, (&lt;a href="http://eed3si9n.com/learning-scalaz/IO+Monad.html"&gt;Learning Scalaz - IO&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;import scalaz.effect._

private def interpret(rs: ResultSet) = new (ResultSetOp ~&amp;gt; IO) {  
    def apply[A](fa: ResultSetOp[A]): IO[A] = fa match {
      case Next         =&amp;gt; IO(rs.next)
      case GetString(i) =&amp;gt; IO(rs.getString(i))
      case GetInt(i)    =&amp;gt; IO(rs.getInt(i))
      case Close        =&amp;gt; IO(rs.close)
      // more... 
    }
}

def run[A](a: ResultSetIO[A], rs: ResultSet): IO[A] =  
  Free.runFC(a)(interpret(rs))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="whyfree"&gt;Why Free?&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Free&lt;/code&gt; 가 제공하는 가치는 다음과 같습니다. (Ref - &lt;a href="http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern"&gt;StackExchange&lt;/a&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It is a lightweight way of &lt;strong&gt;creating a domain-specific language that gives you an AST&lt;/strong&gt;, and then having &lt;strong&gt;one or more interpreters&lt;/strong&gt; to &lt;strong&gt;execute the AST&lt;/strong&gt; however you like&lt;/li&gt;
&lt;li&gt;The free monad part is just a handy way to get an AST that you can assemble using Haskell's standard monad facilities (like do-notation) without having to write lots of custom code. This also ensures that your DSL is composable&lt;/li&gt;
&lt;li&gt;You could then interpret this however you like: run it against a live database, run it against a mock, just log the commands for debugging or even try optimizing the queries&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, &lt;code&gt;Free&lt;/code&gt; 는 우리는 자신만의 Composable 한 DSL 을 구축하고, 필요에 따라 이 DSL 다른 방식으로 해석할 수 있도록 도와주는 도구입니다. &lt;/p&gt;

&lt;h2 id="free"&gt;Free&lt;/h2&gt;

&lt;p&gt;(&lt;code&gt;Free&lt;/code&gt; 와 &lt;code&gt;Yoneda&lt;/code&gt; 는 난해할 수 있으니, &lt;code&gt;Free&lt;/code&gt; 를 어떻게 사용하는지만 알고 싶다면 &lt;a href="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/#reasonablypricedmonad"&gt;Reasonably Priced Monad&lt;/a&gt; 로 넘어가시면 됩니다.)&lt;/p&gt;

&lt;p&gt;어떻게 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 이기만 하면 &lt;code&gt;Free[F[_], ?]&lt;/code&gt; 가 모나드가 되는걸까요? 이를 알기 위해선, 모나드가 어떤 구조로 이루어져 있는지 알 필요가 있습니다.&lt;/p&gt;

&lt;h3 id="monad"&gt;Monad&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;A monad is just a monoid in the category of endofunctors, what's the problem?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;del&gt;의사양반 이게 무슨소리요!&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;Monoid&lt;/code&gt; 와 &lt;code&gt;Functor&lt;/code&gt; 가 무엇인지 알아봅시다.&lt;/p&gt;

&lt;h2 id="monoid"&gt;Monoid&lt;/h2&gt;

&lt;p&gt;어떤 집합 &lt;code&gt;S&lt;/code&gt; 에 대한 닫힌 연산 &lt;code&gt;*&lt;/code&gt;, 집합 내의 어떤 원소 &lt;code&gt;e&lt;/code&gt; 가 다음을 만족할 경우 모노이드라 부릅니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;e * a = a = a * e&lt;/code&gt; (&lt;em&gt;identity&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(a * b) * c = a * (b * c)&lt;/code&gt; (&lt;em&gt;associativity&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 &lt;code&gt;e&lt;/code&gt; 를 항등원이라 부릅니다. &lt;code&gt;Option[A]&lt;/code&gt; 도 &lt;code&gt;None&lt;/code&gt; 을 항등원으로 사용하고, &lt;em&gt;associativity&lt;/em&gt; 를 만족하는 &lt;code&gt;A&lt;/code&gt; 의 연산을 사용하면 모노이드입니다. 따라서 &lt;code&gt;A&lt;/code&gt; 가 모노이드면 &lt;code&gt;Option[A]&lt;/code&gt; 도 모노이드입니다. (활용법은 &lt;a href="http://www.slideshare.net/oxbow_lakes/practical-scalaz"&gt;Practical Scalaz&lt;/a&gt; 참조)&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;&amp;gt; load.ivy("org.scalaz" % "scalaz-core_2.11" % "7.2.0-M5")
&amp;gt; import scalaz._, Scalaz._


&amp;gt; 1.some |+| 2.some
res11: Option[Int] = Some(3)  
&amp;gt; 1.some |+| none
res12: Option[Int] = Some(1)  
&amp;gt; none[Int] |+| 1.some
res13: Option[Int] = Some(1)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="functor"&gt;Functor&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Functor&lt;/code&gt; 는 일반적으로 다음처럼 정의되는데, 이는 &lt;code&gt;Functor F&lt;/code&gt; 가 &lt;code&gt;F&lt;/code&gt; 에서 값을 꺼내, 함수를 적용해 값을 변경할 수 있다는 것을 의미합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A functor may go from one category to a different one&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;trait Functor[F[_]] {  
  def map[A, B](fa: F[A])(f: A =&amp;gt; B): F[B]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;Functor&lt;/code&gt; 는 &lt;em&gt;identity function&lt;/em&gt; 을 항등원으로 사용하면, 모노이드입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;F.map(x =&amp;gt; x) == F&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;F map f map g == F map (f compose g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 때, 변환의 인풋과 아웃풋이 같은 카테고리라면 이 &lt;code&gt;Functor&lt;/code&gt; 를 &lt;em&gt;endo-functor&lt;/em&gt; 라 부릅니다. &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A functor may go from one category to a different one, an endofunctor is a functor for which start and target category are the same.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="monad"&gt;Monad&lt;/h2&gt;

&lt;p&gt;그럼 다시 처음 문장으로 다시 돌아가면, &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Monads are just monoids in the category of endofunctors&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 것의 의미를 이해하려면 모나드가 무엇인지 알아야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;trait Monad[F[_]] {  
  def point[A](a: A): F[A]
  def join[A](ffa: F[F[A]): F[A]
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;일반적으로는 &lt;code&gt;point&lt;/code&gt; (=&lt;code&gt;return&lt;/code&gt;) 와 &lt;code&gt;bind&lt;/code&gt; (= &lt;code&gt;flatMap&lt;/code&gt;) 으로 모나드를 정의하나, &lt;code&gt;join&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt; 으로도 &lt;code&gt;bind&lt;/code&gt; 를 정의할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

trait Monad[F[_]] {  
  def point[A](a: A): F[A]
  def bind[A, B](fa: F[A])(f: A =&amp;gt; F[B]): F[B]

  def map[A, B](fa: F[A])(f: A =&amp;gt; B): F[B] = 
    bind(fa)(a =&amp;gt; point(f(a))    
  def join[A](ffa: F[F[A]): F[A] = 
    bind(ffa)(fa =&amp;gt; fa)
}

trait Monad[F[_]] {  
  def map[A, B](fa: F[A])(f: A =&amp;gt; B): F[B]
  def point[A](a: A): F[A]
  def join[A](ffa: F[F[A]): F[A] /* flatten*/

  def bind[A, B](fa: F[A])(f: A =&amp;gt; F[B]): F[B] = 
    join(map(fa)(f))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt;, &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;join&lt;/code&gt; 관점에서 모나드를 바라보면,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;(endo)functor&lt;/strong&gt; &lt;code&gt;T : X → X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;natural transformation&lt;/strong&gt; &lt;code&gt;μ : T × T → T&lt;/code&gt; (where &lt;code&gt;×&lt;/code&gt; means functor composition (also known as &lt;code&gt;join&lt;/code&gt; in Haskell)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;natural transformation&lt;/strong&gt;  &lt;code&gt;η : I → T&lt;/code&gt; (where &lt;code&gt;I&lt;/code&gt; is the identity endofunctor on &lt;code&gt;X&lt;/code&gt; also known as &lt;code&gt;return&lt;/code&gt; in Haskell)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이때 위 연산들이 모노이드 법칙을 만족합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;e * a = a = a * e&lt;/code&gt; (&lt;em&gt;identity&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;(a * b) * c = a * (b * c)&lt;/code&gt; (&lt;em&gt;associativity&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;μ(η(T)) = T = μ(T(η))&lt;/code&gt; (&lt;em&gt;identity&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;μ(μ(T × T) × T)) = μ(T × μ(T × T))&lt;/code&gt; (&lt;em&gt;associativity&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스칼라 코드로 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;&amp;gt; import scalaz._, Scalaz._

&amp;gt; val A = List(1, 2)
List[Int] = List(1, 2)

// identity left-side: μ(η(T)) = T
&amp;gt; A.map(x =&amp;gt; Monad[List].point(x)).flatten
List[Int] = List(1, 2)

// identity right-side: μ(T(η)) = T
&amp;gt; Monad[List].point(A).flatten
List[Int] = List(1, 2)

// associativity
&amp;gt; val T = List(1, 2, 3, 4)
T: List[Int] = List(1, 2, 3, 4)  
&amp;gt; val TT = T.map(List(_))
TT: List[List[Int]] = List(List(1), List(2), List(3), List(4))

// associativity left-side: μ(μ(T × T) × T))
&amp;gt; TT.flatten.map(List(_))
res30: List[List[Int]] = List(List(1), List(2), List(3), List(4))  
&amp;gt; TT.flatten.map(List(_)).flatten
res31: List[Int] = List(1, 2, 3, 4)

// associativity right-side: μ(T × μ(T × T))
&amp;gt; List(TT.flatten)
res34: List[List[Int]] = List(List(1, 2, 3, 4))  
&amp;gt; List(TT.flatten).flatten
res35: List[Int] = List(1, 2, 3, 4)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;em&gt;Monad&lt;/em&gt;는 &lt;em&gt;(endo)Functor&lt;/em&gt; 카테고리에 대한 &lt;em&gt;Monoid&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;h2 id="freemonoid"&gt;Free Monoid&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Free Monad&lt;/em&gt; 가 &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;point&lt;/code&gt; 에 대한 구현 없이, 모나드가 되듯이 &lt;em&gt;Free Monoid&lt;/em&gt; 또한 연산과 항등원에 대한 구현 없이 &lt;em&gt;구조적&lt;/em&gt; 으로 모노이드입니다. &lt;/p&gt;

&lt;p&gt;항등원과 연산을 &lt;code&gt;Zero&lt;/code&gt;, &lt;code&gt;Append&lt;/code&gt; 라는 이름으로 &lt;em&gt;구조화&lt;/em&gt; 하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

sealed trait FreeMonoid[+A]  
final case object Zero extends FreeMonoid[Nothing]  
final case class Value[A](a: A) extends FreeMonoid[A]  
final case class Append[A](l: FreeMonoid[A], r: FreeMonoid[A]) extends FreeMonoid[A]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;모노이드는 &lt;em&gt;associativity&lt;/em&gt; 를 만족하므로, &lt;code&gt;Append&lt;/code&gt; 를 우측 결합으로 바꾸고, &lt;code&gt;Zero&lt;/code&gt; 로 끝나도록 하면&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

sealed trait FreeMonoid[+A]  
final case object Zero extends FreeMonoid[Nothing]  
final case class Append[A](l: A, r: FreeMonoid[A]) extends FreeMonoid[A]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;List&lt;/code&gt; 와 동일한 구조임을 알 수 있습니다. 실제로, 리스트는 &lt;em&gt;concatenation&lt;/em&gt; 연산, &lt;code&gt;Nil&lt;/code&gt; 항등원에 대해 모노이드입니다.&lt;/p&gt;

&lt;h2 id="freemonad"&gt;Free Monad&lt;/h2&gt;

&lt;p&gt;이제까지의 내용을 정리하면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Monad is a monoid of functors&lt;/li&gt;
&lt;li&gt;Then, &lt;strong&gt;Free Monad is a free Monoid of functors&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 &lt;em&gt;Free Monad&lt;/em&gt; 는 &lt;em&gt;Functor&lt;/em&gt; 의 &lt;em&gt;List&lt;/em&gt; 라 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;모나드의 &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;join&lt;/code&gt; 을 &lt;em&gt;구조화&lt;/em&gt; (&lt;em&gt;타입화&lt;/em&gt;) 하면, &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def point[A](a: A): F[A]  
def join[A, B](ffa: F[F[A]): F[A]

sealed trait Free[F[_], A]  
case class Point[F[_], A](a: A) extends Free[F, A]             // == Return  
case class Join[F[_], A](ffa: F[Free[F, A]]) extends Free[F, A] // == Suspend  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 을 타입화 하는 대신, &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 라면 다음처럼 &lt;code&gt;Free.point&lt;/code&gt;, &lt;code&gt;Free.flatMap&lt;/code&gt; 을 작성할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;sealed trait Free[F[_], A] {  
  def point[F[_]](a: A): Free[F, A] = Point(a)
  def flatMap[B](f: A =&amp;gt; Free[F, B])(implicit functor: Functor[F]): Free[F, B] =
    this match {
      case Point(a)  =&amp;gt; f(a)
      case Join(ffa) =&amp;gt; Join(ffa.map(fa =&amp;gt; fa.flatMap(f)))
    }
  def map[B](f: A =&amp;gt; B)(implicit functor: Functor[F]): Free[F, B] =
    flatMap(a =&amp;gt; Point(f(a)))
}

case class Point[F[_], A](a: A) extends Free[F, A]  
case class Join[F[_], A](ff: F[Free[F, A]]) extends Free[F, A]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fa.flatMap(f)&lt;/code&gt; 의 결과가 &lt;code&gt;Free[F, B]&lt;/code&gt; 고 &lt;code&gt;ffa.map&lt;/code&gt; 의 결과로 들어가므로, &lt;code&gt;ffa.map(_ flatMap f)&lt;/code&gt; 의 결과는 &lt;code&gt;F[Free[F, B]&lt;/code&gt; 입니다. 이걸 &lt;code&gt;Free[F, B]&lt;/code&gt; 로 바꾸려면 &lt;code&gt;Join&lt;/code&gt; 을 이용하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이런 이유에서, &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 면 &lt;code&gt;Free[F, A]&lt;/code&gt; 는 &lt;code&gt;Monad&lt;/code&gt; 입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 리프팅과 실행을 위한 헬퍼 함수를 만들면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

import scalaz.{Functor, Monad, ~&amp;gt;}

def liftF[F[_], A](a: =&amp;gt; F[A])(implicit F: Functor[F]): Free[F, A] =  
  Join(F.map(a)(Point[F, A]))

def foldMap[F[_], M[_], A](fm: Free[F, A])(f: F ~&amp;gt; M)  
                          (implicit FI: Functor[F], MI: Monad[M]): M[A] = 
  fm match {
    case Point(a) =&amp;gt; MI.pure(a)
    case Join(ffa) =&amp;gt; MI.bind(f(ffa))(fa =&amp;gt; foldMap(fa)(f))
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;F ~&amp;gt; M&lt;/code&gt; 는 &lt;code&gt;F&lt;/code&gt; 를 &lt;code&gt;M&lt;/code&gt; 으로 변환해주는, &lt;em&gt;NaturalTransformation&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

type ~&amp;gt;[-F[_], +G[_]] = NaturalTransformation[F, G] 

trait NaturalTransformation[-F[_], +G[_]] {  
  self =&amp;gt;
  def apply[A](fa: F[A]): G[A]

  def compose[E[_]](f: E ~&amp;gt; F): E ~&amp;gt; G = new (E ~&amp;gt; G) {
    def apply[A](ea: E[A]) = self(f(ea))
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MI.bind(f(ffa))&lt;/code&gt; 의 결과는 &lt;code&gt;M[Free[F, A]]&lt;/code&gt; 이므로 여기에서 &lt;code&gt;bind&lt;/code&gt; (= &lt;code&gt;flatMap&lt;/code&gt;) 로 &lt;code&gt;fa&lt;/code&gt; 를 얻어, 재귀적으로 &lt;code&gt;foldMap&lt;/code&gt; 을 호출합니다.&lt;/p&gt;

&lt;h3 id="scalazfreeimplementation"&gt;Scalaz Free Implementation&lt;/h3&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def flatMap[B](f: A =&amp;gt; Free[F, B])(implicit functor: Functor[F]): Free[F, B] =  
    this match {
      case Point(a)  =&amp;gt; f(a)
      case Join(ffa) =&amp;gt; Join(ffa.map(fa =&amp;gt; fa.flatMap(f)))
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Scalaz 에서는 &lt;code&gt;flatMap&lt;/code&gt; 호출시 Stack 비용이 생각보다 크므로, &lt;code&gt;flatMap&lt;/code&gt; 자체도 타입화하고 있습니다. 즉, Stack 대신에 Heap 을 사용합니다. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;Point&lt;/code&gt; 대신, &lt;code&gt;Return&lt;/code&gt;, &lt;code&gt;Join&lt;/code&gt; 대신 &lt;code&gt;Suspend&lt;/code&gt;, &lt;code&gt;FlatMap&lt;/code&gt; 대신 &lt;code&gt;GoSub&lt;/code&gt; 라는 타입 이름으로 구현되어 있습니다. (이해를 돕기 위해 7.x 대신, 6.0.4 버전을 차용)&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/release/6.0.4/core/src/main/scala/scalaz/Free.scala

final case class Return[S[+_], +A](a: A) extends Free[S, A]  
final case class Suspend[S[+_], +A](a: S[Free[S, A]]) extends Free[S, A]  
final case class Gosub[S[+_], A, +B](a: Free[S, A],  
                                     f: A =&amp;gt; Free[S, B]) extends Free[S, B]
sealed trait Free[S[+_], +A] {  
  final def map[B](f: A =&amp;gt; B): Free[S, B] =
    flatMap(a =&amp;gt; Return(f(a)))

  final def flatMap[B](f: A =&amp;gt; Free[S, B]): Free[S, B] = this match {
    case Gosub(a, g) =&amp;gt; Gosub(a, (x: Any) =&amp;gt; Gosub(g(x), f))
    case a           =&amp;gt; Gosub(a, f)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="trampoline"&gt;Trampoline&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Free&lt;/code&gt; 를 이용하면, Stackoverflow 를 피할 수 있습니다. 이는 &lt;code&gt;Free&lt;/code&gt; 가 &lt;code&gt;flatMap&lt;/code&gt; 체인에서 스택 대신 힙을 이용하는 것을 응용한 것인데요,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/release/6.0.4/core/src/main/scala/scalaz/Free.scala

/** A computation that can be stepped through, suspended, and paused */
type Trampoline[+A] = Free[Function0, A]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이때 &lt;code&gt;Function0&lt;/code&gt; 도 &lt;code&gt;Functor&lt;/code&gt; 이므로, &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;implicit Function0Functor: Functor[Function0] = new Functor[Function0] {  
  def fmap[A, B](f: A =&amp;gt; B)(fa: Function0[A]): Function0[B] = 
    () =&amp;gt; f(fa)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Free[Function0, A]&lt;/code&gt; 도 모나드입니다. &lt;/p&gt;

&lt;p&gt;이제 스칼라에서 스택오버플로우가 발생하는 &lt;em&gt;mutual recursion&lt;/em&gt; 코드를 만들어 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

def isOdd(n: Int): Boolean = {  
  if (0 == n) false
  else isEven(n -1)
}

def isEven(n: Int): Boolean = {  
  if (0 == n) true
  else isOdd(n -1)
}

isOdd(10000) // stackoverflow  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;Trampoline&lt;/code&gt; 을 이용하면&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

import scalaz._, Scalaz._, Free._

def isOddT(n: Int): Trampoline[Boolean] =  
  if (0 == n) return_(false)
  else suspend(isEvenT(n - 1))

def isEvenT(n: Int): Trampoline[Boolean] =  
  if (0 == n) return_(true)
  else suspend(isOddT(n - 1))

scala&amp;gt; isOddT(2000000).run  
res7: Boolean = false

scala&amp;gt; isOddT(2000001).run  
res8: Boolean = true  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;return_&lt;/code&gt; 과 &lt;code&gt;suspend&lt;/code&gt; 는 다음처럼 정의되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Free.scala#L15

trait FreeFunctions {

  ...
  def return_[S[_], A](value: =&amp;gt; A)(implicit S: Applicative[S]): Free[S, A] =
    Suspend[S, A](S.point(Return[S, A](value)))

  def suspend[S[_], A](value: =&amp;gt; Free[S, A])(implicit S: Applicative[S]): Free[S, A] =
    Suspend[S, A](S.point(value))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="yonedacoyoneda"&gt;Yoneda, Coyoneda&lt;/h2&gt;

&lt;p&gt;포스트의 시작 부분에서 &lt;code&gt;Coyoneda&lt;/code&gt; 에 대한 언급을 기억하시나요?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Free[F[_], ?]&lt;/code&gt; 는 &lt;code&gt;Functor&lt;/code&gt; &lt;code&gt;F&lt;/code&gt; 에 대해 &lt;code&gt;Monad&lt;/code&gt; 입니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Coyoneda[S[_], ?]&lt;/code&gt; 는 아무 타입에 대해 &lt;code&gt;Functor&lt;/code&gt; 입니다. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Coyoneda&lt;/code&gt; 가 어떻게 &lt;code&gt;Functor&lt;/code&gt; 를 만들어내는지 확인해 보겠습니다. 이 과정에서 &lt;em&gt;dual&lt;/em&gt; 인 &lt;code&gt;Yoneda&lt;/code&gt; 도 같이 살펴보겠습니다. (같은 &lt;em&gt;Category&lt;/em&gt; 내에서, &lt;em&gt;morphism&lt;/em&gt; 방향만 다른 경우)&lt;/p&gt;

&lt;p&gt;먼저, &lt;code&gt;Yoneda&lt;/code&gt;, &lt;code&gt;Coyoneda&lt;/code&gt; 의 기본적인 내용을 훑고 가면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Yoneda&lt;/code&gt;, &lt;code&gt;Coyoneda&lt;/code&gt; 는 &lt;code&gt;Functor&lt;/code&gt; 입니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Yoneda[F[_], A]&lt;/code&gt;, &lt;code&gt;Coyoneda[F[_], A]&lt;/code&gt; 는 &lt;code&gt;F[A]&lt;/code&gt; 와 &lt;em&gt;isomorphic&lt;/em&gt; 입니다 (&lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 일 경우)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Yoneda[F, A]&lt;/code&gt; 에서 &lt;code&gt;F[A]&lt;/code&gt; 로의 &lt;em&gt;homomorphism&lt;/em&gt; 은 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 가 아닐 경우에도 존재합니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F[A]&lt;/code&gt; 에서 &lt;code&gt;Coyoneda[F, A]&lt;/code&gt; 로의 &lt;em&gt;homomorphism&lt;/em&gt; 은 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 가 아닐 경우에도 존재합니다 (중요)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Yoneda&lt;/code&gt;, &lt;code&gt;Coyoneda&lt;/code&gt; 모두 &lt;code&gt;Functor&lt;/code&gt; 가 필요한 시점을 미루고, &lt;code&gt;Functor.map&lt;/code&gt; 의 체인을, 일반 함수의 체인으로 표현합니다. 결국엔 &lt;code&gt;Functor&lt;/code&gt; 가 필요합니다 (중요)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/4-yoneda-and-free/iso_vs_homo_morphism.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;(Image - &lt;a href="http://evolvingthoughts.net/2010/08/homology-and-analogy/"&gt;http://evolvingthoughts.net/2010/08/homology-and-analogy/&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;즉 &lt;code&gt;Coyoneda[F[_], A]&lt;/code&gt; 가  &lt;code&gt;F&lt;/code&gt; 와 상관없이 &lt;code&gt;Functor&lt;/code&gt; 인 이유는, &lt;code&gt;F[A] -&amp;gt; Coyoenda[F[_], A]&lt;/code&gt; 로의 변환이 &lt;code&gt;F&lt;/code&gt; &lt;code&gt;Functor&lt;/code&gt; 인 것과 상관이 없으며 &lt;code&gt;Coyoneda&lt;/code&gt; 자체가 &lt;code&gt;Functor&lt;/code&gt; 인스턴스이기 때문입니다.&lt;/p&gt;

&lt;p&gt;추상은 간단합니다. &lt;code&gt;Functor[F]&lt;/code&gt; 가 &lt;code&gt;F[A] -&amp;gt; F[B]&lt;/code&gt; 로의 변환을 &lt;code&gt;f: A =&amp;gt; B&lt;/code&gt; 만 가지고 해 낼 수 있다는 점을 역이용하면 됩니다. &lt;code&gt;F[A]&lt;/code&gt; 에 &lt;code&gt;Functor.map(f)&lt;/code&gt; 를 적용하는 것이 아니라, 값 &lt;code&gt;A&lt;/code&gt; 가 있을 때 &lt;code&gt;f(a)&lt;/code&gt; 를 적용한 뒤에, &lt;code&gt;F[B]&lt;/code&gt; 를 만들면 됩니다. 다시 말해&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Functor[F]&lt;/code&gt; 는 &lt;code&gt;F[A]&lt;/code&gt; 와 &lt;code&gt;f: A =&amp;gt; B&lt;/code&gt;, &lt;code&gt;g: B = &amp;gt; C&lt;/code&gt; 가 가 있을 때 &lt;code&gt;Functor[F].map(f compose g)&lt;/code&gt; 대신&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f compose g&lt;/code&gt; 를 먼저 하고, 이것의 결과값인 &lt;code&gt;C&lt;/code&gt; 를 이용해 &lt;code&gt;F[C]&lt;/code&gt; 를 만들면 됩니다. 그러면 &lt;code&gt;Functor[F].map&lt;/code&gt; 연산을 함수의 컴포지션으로 해결할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="yoneda"&gt;Yoneda&lt;/h3&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Yoneda.scala

abstract class Yoneda[F[_], A] { yo =&amp;gt;  
  def apply[B](f: A =&amp;gt; B): F[B]

  def run: F[A] = apply(a =&amp;gt; a)

  def map[B](f: A =&amp;gt; B): Yoneda[F, B] = new Yoneda[F, B] {
    override def apply[C](g: (B) =&amp;gt; C): F[C] = yo(f andThen g)
  }
}

/** `F[A]` converts to `Yoneda[F, A]` for any functor `F` */
def apply[F[_]: Functor, A](fa: F[A]): Yoneda[F, A] = new Yoneda[F, A] {  
  override def apply[B](f: A =&amp;gt; B): F[B] = Functor[F].map(fa)(f)
}

/** `Yoneda[F, A]` converts to `F[A` for any `F` */
def from[F[_], A](yo: Yoneda[F, A]): F[A] =  
  yo.run

/** `Yoneda[F, _]` is a functor for any `F` */
implicit def yonedaFunctor[F[_]]: Functor[({ type  λ[α] = Yoneda[F,α]})#λ] =  
  new Functor[({type λ[α] = Yoneda[F, α]})#λ] {
    override def map[A, B](ya: Yoneda[F, A])(f: A =&amp;gt; B): Yoneda[F, B] =
      ya map f
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Yoneda[F[_], ?]&lt;/code&gt; 는 그 자체로 &lt;code&gt;Functor&lt;/code&gt; 이나 이를 만들기 위해선 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 여야 합니다. 반면 &lt;code&gt;Yoneda[F, A] -&amp;gt; F[A]&lt;/code&gt; 로의 변환은 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 이던 아니던 상관 없습니다.&lt;/p&gt;

&lt;h3 id="coyoneda"&gt;Coyoneda&lt;/h3&gt;

&lt;p&gt;그렇다면, &lt;em&gt;dual&lt;/em&gt; 인 &lt;code&gt;Coyoneda&lt;/code&gt; 는 어떨까요? &lt;code&gt;Yoneda&lt;/code&gt; &lt;code&gt;F[A]&lt;/code&gt; 를 &lt;code&gt;Functor&lt;/code&gt; 로 부터 얻는것이 아니라, &lt;em&gt;Identity&lt;/em&gt; 를 이용해, 처음부터 &lt;code&gt;F[A]&lt;/code&gt; 를 가지고 있습니다. 이로 부터 얻어지는 결론은 놀랍습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;sealed abstract class Coyoneda[F[_], A] { coyo =&amp;gt;  
  type I
  val fi: F[I]
  val k: I =&amp;gt; A

  final def map[B](f: A =&amp;gt; B): Aux[F, I, B] =
    apply(fi)(f compose k)

  final def run(implicit F: Functor[F]): F[A] =
    F.map(fi)(k)
}

type Aux[F[_], A, B] = Coyoneda[F, B] { type I = A }

def apply[F[_], A, B](fa: F[A])(_k: A =&amp;gt; B): Aux[F, A, B] =  
  new Coyoneda[F, B] {
    type I = A
    val k = _k
    val fi = fa
  }

/** `F[A]` converts to `Coyoneda[F, A]` for any `F` */
def lift[F[_], A](fa: F[A]): Coyoneda[F, A] = apply(fa)(identity[A])

/** `Coyoneda[F, A]` converts to `F[A]` for any Functor `F` */
def from[F[_], A](coyo: Coyoneda[F, A])(implicit F: Functor[F]): F[A] =  
  F.map(coyo.fi)(coyo.k)

/** `CoyoYoneda[F, _]` is a functor for any `F` */
implicit def coyonedaFunctor[F[_]]: Functor[({ type  λ[α] = Coyoneda[F,α]})#λ] =  
  new Functor[({type λ[α] = Coyoneda[F, α]})#λ] {
    override def map[A, B](ca: Coyoneda[F, A])(f: A =&amp;gt; B): Coyoneda[F, B] =
      ca.map(f)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;code&gt;Coyoneda[F[_], ?]&lt;/code&gt; 를 만들기 위해서 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 일 필요가 없습니다. &lt;/p&gt;

&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/24000465/step-by-step-deep-explain-the-power-of-coyoneda-preferably-in-scala-throu"&gt;Stackoverflow - The Power of (Co)yoneda&lt;/a&gt; 에선 다음처럼 설명합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-haskell"&gt;newtype Yoneda f a = Yoneda { runYoneda :: forall b . (a -&amp;gt; b) -&amp;gt; f b }

instance Functor (Yoneda f) where  
  fmap f y = Yoneda (\ab -&amp;gt; runYoneda y (ab . f))

data CoYoneda f a = forall b . CoYoneda (b -&amp;gt; a) (f b)

instance Functor (CoYoneda f) where  
  fmap f (CoYoneda mp fb) = CoYoneda (f . mp) fb
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;So instead of appealing to the &lt;code&gt;Functor&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; during definition of the &lt;code&gt;Functor&lt;/code&gt; instance for &lt;code&gt;Yoneda&lt;/code&gt;, it gets &lt;strong&gt;"defered"&lt;/strong&gt; to the construction of the &lt;code&gt;Yoneda&lt;/code&gt; itself. Computationally, it also has the nice property of turning all &lt;code&gt;fmaps&lt;/code&gt; into compositions with the "continuation" function (&lt;code&gt;a -&amp;gt; b&lt;/code&gt;).&lt;/p&gt;
  
  &lt;p&gt;The opposite occurs in &lt;code&gt;CoYoneda&lt;/code&gt;. For instance, &lt;code&gt;CoYoneda f&lt;/code&gt; is still a &lt;code&gt;Functor&lt;/code&gt; whether or not &lt;code&gt;f&lt;/code&gt; is. Also we again notice the property that &lt;code&gt;fmap&lt;/code&gt; is nothing more than composition along the eventual continuation.&lt;/p&gt;
  
  &lt;p&gt;&lt;strong&gt;So both of these are a way of "ignoring" a &lt;code&gt;Functor&lt;/code&gt; requirement for a little while, especially while performing &lt;code&gt;fmap&lt;/code&gt;s.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="reasonablypricedmonad"&gt;Reasonably Priced Monad&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;for comprehension&lt;/em&gt; 내에서는 단 하나의 모나드 밖에 쓸 수 없습니다. &lt;del&gt;단칸방 세입자 모나드&lt;/del&gt; &lt;em&gt;Monad Transformer&lt;/em&gt; 등을 사용하긴 하는데 불편하기 짝이 없지요.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Rúnar Bjarnason&lt;/em&gt; 은 &lt;a href="https://www.parleys.com/tutorial/composable-application-architecture-reasonably-priced-monads"&gt;Composable application architecture with reasonably priced monads
&lt;/a&gt; 에서 &lt;code&gt;Coproduct&lt;/code&gt; 를 이용해 &lt;code&gt;Free&lt;/code&gt; 를 조합하는 법을 소개합니다. (&lt;strong&gt;이 비디오는 꼭 보셔야합니다!&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;요약하면 &lt;code&gt;Free&lt;/code&gt; 를 이용해 생성한 서로 다른 두개의 모나드는 같은 &lt;em&gt;for comprehension&lt;/em&gt; 내에서 사용할 수 없습니다. 이 때 &lt;code&gt;Coproduct&lt;/code&gt; 를 이용해서 하나의 타입으로 묶고, 타입 자동 주입을 위해 &lt;code&gt;Inject&lt;/code&gt; 를 이용하면 많은 코드 없이도, 편리하게 &lt;code&gt;Free&lt;/code&gt; 를 이용할 수 있다는 것입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 다음과 처럼 두개의 프리 모나드 &lt;code&gt;Interact&lt;/code&gt;, &lt;code&gt;Auth&lt;/code&gt; 가 있을 때&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// Interact
trait InteractOp[A]  
final case class Ask(prompt: String) extends InteractOp[String]  
final case class Tell(msg: String)   extends InteractOp[Unit]

type CoyonedaInteract[A] = Coyoneda[InteractOp, A]  
type Interact[A] = Free[CoyonedaInteract, A]

def ask(prompt: String) = liftFC(Ask(prompt))  
def tell(msg: String) = liftFC(Tell(msg))  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// Auth
case class User(userId: UserId, permissions: Set[Permission])

sealed trait AuthOp[A]  
final case class Login(userId: UserId, password: Password) extends AuthOp[Option[User]]  
final case class HasPermission(user: User, permission: Permission) extends AuthOp[Boolean]

type CoyonedaAuth[A] = Coyoneda[AuthOp, A]  
type Auth[A] = Free[CoyonedaAuth, A]

def login(userId: UserId, password: Password): FreeC[F, Option[User]] =  
  liftFC(Login(userId, password))

def hasPermission(user: User, permission: Permission): FreeC[F, Boolean] =  
  liftFC(HasPermission(user, permission))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// Log

sealed trait LogOp[A]  
final case class Warn(message: String)  extends LogOp[Unit]  
final case class Error(message: String) extends LogOp[Unit]  
final case class Info(message: String)  extends LogOp[Unit]

type CoyonedaLog[A] = Coyoneda[LogOp, A]  
type Log[A] = Free[CoyonedaLog, A]

object Log {  
  def warn(message: String)  = liftFC(Warn(message))
  def info(message: String)  = liftFC(Info(message))
  def error(message: String) = liftFC(Error(message))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음처럼 같은 &lt;em&gt;for comprehension&lt;/em&gt; 구문에서 사용할 수 없습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// doesn't compile

for {  
  userId &amp;lt;- ask("Insert User ID: ")
  password &amp;lt;- ask("Password: ")
  user &amp;lt;- login(userId, password)
  _ &amp;lt;- info(s"user $userId logged in")
  hasPermission &amp;lt;- user.cata(
    none = point(false),
    some = hasPermission(_, "scalaz repository")
  )
  _ &amp;lt;- warn(s"$userId has no permission for scalaz repository")
} yield hasPermission
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 때 &lt;code&gt;Coproduct&lt;/code&gt; 를 이용하면, 가능합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// combine free monads
type Language0[A] = Coproduct[InteractOp, AuthOp, A]  
type Language[A] = Coproduct[LogOp, Language0, A]  
type LanguageCoyo[A] = Coyoneda[Language, A]  
type LanguageMonad[A] = Free[LanguageCoyo, A]  
def point[A](a: =&amp;gt; A): FreeC[Language, A] = Monad[LanguageMonad].point(a)

// combine interpreters
val interpreter0: Language0 ~&amp;gt; Id = or(InteractInterpreter, AuthInterpreter)  
val interpreter: Language ~&amp;gt; Id = or(LogInterpreter, interpreter0)

// run a program
def main(args: Array[String]) {  
  def program(implicit I: Interact[Language], A: Auth[Language], L: Log[Language]) = {
    import I._, A._, L._

    for {
      userId &amp;lt;- ask("Insert User ID: ")
      password &amp;lt;- ask("Password: ")
      user &amp;lt;- login(userId, password)
      _ &amp;lt;- info(s"user $userId logged in")
      hasPermission &amp;lt;- user.cata(
        none = point(false),
        some = hasPermission(_, "scalaz repository")
      )
      _ &amp;lt;- warn(s"$userId has no permission for scalaz repository")
    } yield hasPermission
  }

  program.mapSuspension(Coyoneda.liftTF(interpreter))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;or&lt;/code&gt; 과 &lt;code&gt;lift&lt;/code&gt; 는 라이브러리 코드라 생각하시면 됩니다. 이제 변화된 프리 모나드 부분을 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;object Auth {  
  type UserId = String
  type Password = String
  type Permission = String

  implicit def instance[F[_]](implicit I: Inject[AuthOp, F]): Auth[F] =
    new Auth
}

class Auth[F[_]](implicit I: Inject[AuthOp, F]) {  
  import Common._
  def login(userId: UserId, password: Password): FreeC[F, Option[User]] =
    lift(Login(userId, password))

  def hasPermission(user: User, permission: Permission): FreeC[F, Boolean] =
    lift(HasPermission(user, permission))
}

class Interact[F[_]](implicit I: Inject[InteractOp, F]) {  
  import Common._

  def ask(prompt: String): FreeC[F, String] =
    lift(Ask(prompt))

  def tell(message: String): FreeC[F, Unit] =
    lift(Tell(message))
}

object Interact {  
  implicit def instance[F[_]](implicit I: Inject[InteractOp, F]): Interact[F] =
    new Interact
}

class Log[F[_]](implicit I: Inject[LogOp, F]) {  
  import Common._

  def warn(message: String)  = lift(Warn(message))
  def info(message: String)  = lift(Info(message))
  def error(message: String) = lift(Error(message))
}

object Log {  
  implicit def instant[F[_]](implicit I: Inject[LogOp ,F]) =
    new Log
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제, &lt;code&gt;Common&lt;/code&gt; 을 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;object Common {  
  import scalaz.Coproduct, scalaz.~&amp;gt;

  def or[F[_], G[_], H[_]](f: F ~&amp;gt; H, g: G ~&amp;gt; H): ({type cp[α] = Coproduct[F,G,α]})#cp ~&amp;gt; H =
    new NaturalTransformation[({type cp[α] = Coproduct[F,G,α]})#cp,H] {
      def apply[A](fa: Coproduct[F,G,A]): H[A] = fa.run match {
        case -\/(ff) ⇒ f(ff)
        case \/-(gg) ⇒ g(gg)
      }
    }

  def lift[F[_], G[_], A](fa: F[A])(implicit I: Inject[F, G]): FreeC[G, A] =
    Free.liftFC(I.inj(fa))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Coproduct[F, G, A]&lt;/code&gt; 는 &lt;strong&gt;둘 중 하나&lt;/strong&gt; 를 의미하는 추상입니다. 결과로 &lt;code&gt;F[A] \/ G[A]&lt;/code&gt; (&lt;em&gt;scalaz either&lt;/em&gt;) 을 돌려줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Coproduct.scala

final case class Coproduct[F[_], G[_], A](run: F[A] \/ G[A]) {  
  ...
}

trait CoproductFunctions {  
  def leftc[F[_], G[_], A](x: F[A]): Coproduct[F, G, A] =
    Coproduct(-\/(x))

  def rightc[F[_], G[_], A](x: G[A]): Coproduct[F, G, A] =
    Coproduct(\/-(x))

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Inject[F[_], G[_]]&lt;/code&gt; 는 &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt; 를 포함하는 더 큰 타입인 &lt;code&gt;Coproduct&lt;/code&gt; 를 만들때 쓰입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def lift[F[_], G[_], A](fa: F[A])(implicit I: Inject[F, G]): FreeC[G, A] =  
  Free.liftFC(I.inj(fa))

// F == Langauge
class Log[F[_]](implicit I: Inject[LogOp, F]) {  
  def warn(message: String)  = lift(Warn(message))
  def info(message: String)  = lift(Info(message))
  def error(message: String) = lift(Error(message))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Inject&lt;/code&gt; 는 이렇게 생겼습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Inject.scala

sealed abstract class Inject[F[_], G[_]] {  
  def inj[A](fa: F[A]): G[A]
  def prj[A](ga: G[A]): Option[F[A]]
}

sealed abstract class InjectInstances {  
  implicit def reflexiveInjectInstance[F[_]] =
    new Inject[F, F] {
      def inj[A](fa: F[A]) = fa
      def prj[A](ga: F[A]) = some(ga)
    }

  implicit def leftInjectInstance[F[_], G[_]] =
    new Inject[F, ({type λ[α] = Coproduct[F, G, α]})#λ] {
      def inj[A](fa: F[A]) = Coproduct.leftc(fa)
      def prj[A](ga: Coproduct[F, G, A]) = ga.run.fold(some(_), _ =&amp;gt; none)
    }

  implicit def rightInjectInstance[F[_], G[_], H[_]](implicit I: Inject[F, G]) =
      new Inject[F, ({type λ[α] = Coproduct[H, G, α]})#λ] {
        def inj[A](fa: F[A]) = Coproduct.rightc(I.inj(fa))
        def prj[A](ga: Coproduct[H, G, A]) = ga.run.fold(_ =&amp;gt; none, I.prj(_))
      }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt; 타입만 맞추어 주면 &lt;code&gt;Inject&lt;/code&gt; 인스턴스는 자동으로 생성됩니다.&lt;/p&gt;

&lt;p&gt;다음시간에는 &lt;em&gt;side-effect&lt;/em&gt; 의 세계로 넘어가 &lt;code&gt;ST&lt;/code&gt;, &lt;code&gt;IO&lt;/code&gt; 등을 살펴보겠습니다.&lt;/p&gt;

&lt;h2 id="previousposts"&gt;Previous Posts&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-1-state/"&gt;Easy Scalaz 1, State&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/"&gt;Easy Scalaz 2, Monad Transformer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/"&gt;Easy Scalaz 3, ReaderWriterState with Kleisli&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="references"&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://cs.lth.se/edan40"&gt;Haskell Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tpolecat.github.io/assets/sbtb-slides.pdf"&gt;Programs as Values: Fure Functional JDBC Programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.higher-order.com/blog/2013/11/01/free-and-yoneda/"&gt;Free Monads and the Yoneda Lemma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/24000465/step-by-step-deep-explain-the-power-of-coyoneda-preferably-in-scala-throu"&gt;Stackoverflow - The Power of (Co) Yoneda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern"&gt;Stack Exchange - What is the Free Monad + Interpreter Pattern?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf"&gt;Free Monad is Free Monoid + Functor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://underscore.io/blog/posts/2015/04/23/deriving-the-free-monad.html"&gt;Underscore - Deriving the Free Monad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html"&gt;Underscore - Free Monads Are Simple&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/10342876/differences-between-functors-and-endofunctors"&gt;Stackoverflow - Difference between functors and endofuctors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem/3870310#3870310"&gt;Stackoverflow - A monad is just monoid in the categy of endofuctors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://evolvingthoughts.net/2010/08/homology-and-analogy/"&gt;Isomorphism vs Homomorphism Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.parleys.com/tutorial/composable-application-architecture-reasonably-priced-monads"&gt;Composable application architecture with reasonably priced monads
&lt;/a&gt;(&lt;a href="https://gist.github.com/runarorama/a8fab38e473fafa0921d"&gt;Gist: Code&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title>Easy Scalaz 3, ReaderWriterState with Kleisli</title><description>&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Composition&lt;/em&gt; (합성) 은 함수형 언어에서 중요한 테마중 하나인데요, 이번 시간에는 &lt;em&gt;Kleisli&lt;/em&gt; 를 이용해 어떻게 함수를 타입으로 표현하고, 합성할 수 있는지 살펴보겠습니다. 그리고 나서, &lt;em&gt;Reader&lt;/em&gt;, &lt;em&gt;Writer&lt;/em&gt; 에 대해 알아보고, 이것들과 &lt;em&gt;State&lt;/em&gt; 를 같이 사용하는 &lt;em&gt;RWST&lt;/em&gt; 에 대해 알아보겠습니다.&lt;/p&gt;

&lt;h2 id="kleisli"&gt;Kleisli&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;State&lt;/em&gt; 가 &lt;code&gt;(S) =&amp;gt; (S, A)&lt;/code&gt; 를 타입클래스로 표현한 것이라면, &lt;code&gt;A =&amp;gt;&lt;/code&gt;&lt;/p&gt;</description><link>http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/</link><guid isPermaLink="false">1be76d77-2344-4db8-b924-f9015146e001</guid><category>scala</category><category>scalaz</category><category>readerwriterstate</category><category>kleisli</category><dc:creator>1ambda</dc:creator><pubDate>Tue, 17 Nov 2015 11:32:42 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Composition&lt;/em&gt; (합성) 은 함수형 언어에서 중요한 테마중 하나인데요, 이번 시간에는 &lt;em&gt;Kleisli&lt;/em&gt; 를 이용해 어떻게 함수를 타입으로 표현하고, 합성할 수 있는지 살펴보겠습니다. 그리고 나서, &lt;em&gt;Reader&lt;/em&gt;, &lt;em&gt;Writer&lt;/em&gt; 에 대해 알아보고, 이것들과 &lt;em&gt;State&lt;/em&gt; 를 같이 사용하는 &lt;em&gt;RWST&lt;/em&gt; 에 대해 알아보겠습니다.&lt;/p&gt;

&lt;h2 id="kleisli"&gt;Kleisli&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;State&lt;/em&gt; 가 &lt;code&gt;(S) =&amp;gt; (S, A)&lt;/code&gt; 를 타입클래스로 표현한 것이라면, &lt;code&gt;A =&amp;gt; B&lt;/code&gt; 를 타입클래스로 표현한 것도 있지 않을까요? 그렇게 되면, 스칼라에서 지원하는 &lt;code&gt;andThen&lt;/code&gt;, &lt;code&gt;compose&lt;/code&gt; 을 이용해서 함수를 조합하는 것처럼, 타입 클래스를 조합할 수 있을겁니다. &lt;code&gt;Kleisli&lt;/code&gt; 가 바로, 그런 역할을 하는 타입 클래스입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kleisli represents a function &lt;code&gt;A =&amp;gt; M[B]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;타입을 보면, 단순히 &lt;code&gt;A =&amp;gt; B&lt;/code&gt; 이 아니라 &lt;code&gt;A =&amp;gt; M[B]&lt;/code&gt; 를 나타냅니다. 이는 &lt;code&gt;Kleisli&lt;/code&gt; 가 &lt;code&gt;M&lt;/code&gt; 을 해석하고, 조합할 수 있는 방법을 제공한다는 것을 의미합니다. 실제 구현을 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Kleisli.scala#L8

final case class Kleisli[M[_], A, B](run: A =&amp;gt; M[B]) { self =&amp;gt;  
  ...

  def &amp;gt;=&amp;gt;[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] =  kleisli((a: A) =&amp;gt; b.bind(this(a))(k.run))

  def andThen[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &amp;gt;=&amp;gt; k

  def &amp;gt;==&amp;gt;[C](k: B =&amp;gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &amp;gt;=&amp;gt; kleisli(k)

  def andThenK[C](k: B =&amp;gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &amp;gt;==&amp;gt; k

  /** alias for `compose` */
  def &amp;lt;=&amp;lt;[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &amp;gt;=&amp;gt; this

  def compose[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &amp;gt;=&amp;gt; this

  def &amp;lt;==&amp;lt;[C](k: C =&amp;gt; M[A])(implicit b: Bind[M]): Kleisli[M, C, B] = kleisli(k) &amp;gt;=&amp;gt; this

  def composeK[C](k: C =&amp;gt; M[A])(implicit b: Bind[M]): Kleisli[M, C, B] = this &amp;lt;==&amp;lt; k
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/KleisliUsage.scala"&gt;Kleisli Example&lt;/a&gt; 에서 간단한 예제를 가져와서 사용법을 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/KleisliUsage.scala

case class Continent(name: String, countries: List[Country] = List.empty)  
case class Country(name: String, cities: List[City] = List.empty)  
case class City(name: String, isCapital: Boolean = false, inhabitants: Int = 20)

val data: List[Continent] = List(  
  Continent("Europe"),
  Continent("America",
    List(
      Country("Canada",
        List(
          City("Ottawa"), City("Vancouver"))),
      Country("USA",
        List(
          City("Washington"), City("New York"))))),
  Continent("Asia",
    List(
      Country("India",
        List(City("New Dehli"), City("Calcutta"))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기에 다음의 함수를 정의하면 &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def continents(name: String): List[Continent] =  
  data.filter(k =&amp;gt; k.name.contains(name))

def countries(continent: Continent): List[Country] = continent.countries

def cities(country: Country): List[City] = country.cities

def save(cities: List[City]): Try[Unit] =  
  Try {
    // do IO or some side-effectful operations
    cities.foreach(c =&amp;gt; println("Saving " + c.name))
  }

def inhabitants(c: City): Int = c.inhabitants  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;A =&amp;gt; M[B]&lt;/code&gt; 형태의 여러 함수들을 만들었으므로 이를 &lt;code&gt;Kleisli&lt;/code&gt; 를 이용해 조합할 수 있습니다. (이 예제에서 &lt;code&gt;M == List&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// Kleisli[List, String, City]
val allCities = kleisli(continents) &amp;gt;==&amp;gt; countries &amp;gt;==&amp;gt; cities

// Kleisli[List, String, Int]
val cityInhabitants = allCities map inhabitants  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;allCities&lt;/code&gt; 는 &lt;code&gt;String&lt;/code&gt; 을 인자로 받기도 하고, &lt;code&gt;M == List&lt;/code&gt; 의 &lt;code&gt;Kleisli&lt;/code&gt; 기 때문에 &lt;code&gt;List&lt;/code&gt; 를 인자로 받을 수도 있습니다. (&lt;code&gt;=&amp;lt;&amp;lt;&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;allCities("America") map(println)

// output
City(Ottawa,false,20)  
City(Vancouver,false,20)  
City(Washington,false,20)  
City(New York,false,20)

(allCities =&amp;lt;&amp;lt; List("America", "Asia")).map(println)

// output
City(Ottawa,false,20)  
City(Vancouver,false,20)  
City(Washington,false,20)  
City(New York,false,20)  
City(New Dehli,false,20)  
City(Calcutta,false,20)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Kleisli&lt;/code&gt; 가 제공하는 함수를 다시 살펴보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def =&amp;lt;&amp;lt;(a: M[A])(implicit m: Bind[M]): M[B] = m.bind(a)(run)

def map[C](f: B =&amp;gt; C)(implicit M: Functor[M]): Kleisli[M, A, C] =  
  kleisli(a =&amp;gt; M.map(run(a))(f))

def mapK[N[_], C](f: M[B] =&amp;gt; N[C]): Kleisli[N, A, C] =  
  kleisli(run andThen f)

def flatMapK[C](f: B =&amp;gt; M[C])(implicit M: Bind[M]): Kleisli[M, A, C] =  
  kleisli(a =&amp;gt; M.bind(run(a))(f))

def flatMap[C](f: B =&amp;gt; Kleisli[M, A, C])(implicit M: Bind[M]): Kleisli[M, A, C] =  
  kleisli((r: A) =&amp;gt; M.bind[B, C](run(r))(((b: B) =&amp;gt; f(b).run(r))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;mapK :: M[B] =&amp;gt; N[C]&lt;/code&gt; 를 이용하면 현재 &lt;code&gt;Kleisli[M, _, _]&lt;/code&gt; 를 &lt;code&gt;Kleisli[N, _, _]&lt;/code&gt; 로 변경할 수 있습니다.&lt;/p&gt;

&lt;p&gt;위에서 정의한 &lt;code&gt;save&lt;/code&gt; 함수는 &lt;code&gt;List[A]&lt;/code&gt; 를 받아 &lt;code&gt;Try[Unit]&lt;/code&gt; 를 여기에 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// Kleisli[Try, String, Unit]
val getAndSaveCities = allCities mapK save  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;local&lt;/code&gt; 을 이용하면 함수를 &lt;em&gt;prepend&lt;/em&gt; 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// def local[AA](f: AA =&amp;gt; A): Kleisli[M, AA, B] =
//   kleisli(f andThen run)

def index(i: Int): String = data(i).name

// Kleisli[List, Int, City]
val allCitiesWithIndex = allCities local index

allCitiesWithIndex(1) map(println)

// output
City(Ottawa,false,20)  
City(Vancouver,false,20)  
City(Washington,false,20)  
City(New York,false,20)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Kleisli&lt;/code&gt; 에 대한 더 읽을거리는 아래 링크를 참조해주세요. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://eed3si9n.com/learning-scalaz/Arrow.html"&gt;Scalaz Arrow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Kleisli.scala#L209"&gt;Scalaz - Kleisli.scala#KleisliArrow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="reader"&gt;Reader&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Kleisli&lt;/code&gt; 가 &lt;code&gt;A =&amp;gt; M[B]&lt;/code&gt; 를 나타낸다면, &lt;code&gt;Reader&lt;/code&gt; 는 &lt;code&gt;A =&amp;gt; B&lt;/code&gt; (&lt;code&gt;Function1&lt;/code&gt;) 를 의미하는 타입클래스입니다. 얼핏 생각하기에 &lt;code&gt;Kleisli[Id, A, B]&lt;/code&gt; 일것 같죠? 실제 구현을 보면 (&lt;em&gt;scalaz&lt;/em&gt; 에서 타입 얼라이어스는 &lt;code&gt;package.scala&lt;/code&gt; 에 정의되어 있습니다.)&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/package.scala

type ReaderT[F[_], E, A] = Kleisli[F, E, A]  
val ReaderT = Kleisli  
type Reader[E, A] = ReaderT[Id, E, A]

object Reader {  
    def apply[E, A](f: E =&amp;gt; A): Reader[E, A] = Kleisli[Id, E, A](f)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Reader&lt;/code&gt; 도 &lt;code&gt;Klelsli&lt;/code&gt; 이므로, &lt;code&gt;Reader[A, B] &amp;gt;==&amp;gt; Reader[B, C]&lt;/code&gt; 는 &lt;code&gt;Reader[A, C]&lt;/code&gt; 가 됩니다. 게다가 &lt;code&gt;Kleisli&lt;/code&gt; 는 &lt;code&gt;flatMap&lt;/code&gt; 을 정의하고 있으므로 &lt;em&gt;monadic composition&lt;/em&gt; 을 작성할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The point of a &lt;code&gt;Reader&lt;/code&gt; is to supply some configuration object without having to manually (or &lt;em&gt;implicitly&lt;/em&gt;) pass i around all the functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;요는, 함수 사이의 체인을 엮어 새로운 함수를 만들수 있고 이로인해 직접 파라미터를 넘겨줄 필요가 없습니다. 예를 들어&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;type URI = String  
type Key = String  
type Value = String

val uri: Reader[Get, URI]  
val queryString: Reader[URI, String]  
val body: Reader[String, Map[Key, Value]

// Get =&amp;gt; Map[Key, Value]
val queryStringToBody = uri &amp;gt;==&amp;gt; queryString &amp;gt;==&amp;gt; body  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;간단히 구현을 해보겠습니다. 예외 처리는 외부에서 &lt;code&gt;Try&lt;/code&gt; 혹은 &lt;code&gt;\/.fromTryCatchThrowable&lt;/code&gt; 등으로 한다 가정하고 로직에만 집중해보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// model
trait HttpRequest {  
  def url: String
}
case class GET(url: String) extends HttpRequest  
case class POST(url: String, body: Map[String, String]) extends HttpRequest

val uri: Reader[GET, String] = Reader { req: GET =&amp;gt; req.url }  
val queryString: Reader[String, String] = Reader { url: String =&amp;gt; url.split("\\?")(1) }  
val body: Reader[String, Map[String, String]] = Reader { queries: String =&amp;gt;  
  val qs = queries.split("&amp;amp;").toList
  qs.foldLeft(Map.empty[String, String]) { (acc: Map[String, String], q) =&amp;gt;
    val kv = q.split("=")
    acc.updated(kv(0), kv(1))
  }
}

val queryStringToBody: Reader[GET, Map[String, String]] = uri &amp;gt;==&amp;gt; queryString &amp;gt;==&amp;gt; body  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;queryStringToBody&lt;/code&gt; 를 사용해 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;val get1 = GET("http://www.google.com/search?query=scalaz&amp;amp;site=github")  
val post1 = POST("http://www.google.com/search", Map("query" -&amp;gt; "scalaz", "site" -&amp;gt; "github"))  
val post2 = POST("https://www.google.com/search", Map("query" -&amp;gt; "scalaz", "site" -&amp;gt; "github"))

queryStringToBody.run(get1) shouldBe Map("query" -&amp;gt; "scalaz", "site" -&amp;gt; "github")  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;함수를 몇개 더 작성해보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;val toHttpsRequest = Reader { url: String =&amp;gt; url.replaceAll("http://$", "https://") }  
val sslProxy: Reader[_ &amp;gt;: readerwriterstate.HttpRequest, readerwriterstate.HttpRequest] = Reader { req: readerwriterstate.HttpRequest =&amp;gt;  
  req match {
    case request if request.url.startsWith("https://") =&amp;gt; request
    case request: POST =&amp;gt; request.copy(url = toHttpsRequest(request.url))
    case request: GET  =&amp;gt; request.copy(url = toHttpsRequest(request.url))
  }
}

val convertGetToPost: Reader[_ &amp;gt;: readerwriterstate.HttpRequest, POST] = Reader { req : readerwriterstate.HttpRequest =&amp;gt;  
  req match {
    case get: GET =&amp;gt;
      val split = get.url.split("\\?")
      val (path, query) = (split(0), split(1))
      val postBody = body.run(query)

      POST(path, postBody)

    case post: POST =&amp;gt; post
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;HttpRequest&lt;/code&gt; 서브타입을 받아, 프록시를 적용하고, &lt;code&gt;GET&lt;/code&gt; 이면 &lt;code&gt;POST&lt;/code&gt; 로 변경하는 함수를 조합해보면 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;(&lt;code&gt;:&amp;gt;&lt;/code&gt; 등 &lt;em&gt;Type Bound&lt;/em&gt; 에 대해서는 &lt;a href="http://twitter.github.io/scala_school/type-basics.html"&gt;Scala School - Type &amp;amp; Polymorphism&lt;/a&gt; 과 &lt;a href="http://twitter.github.io/scala_school/advanced-types.html"&gt;Scala School - Advanced Types&lt;/a&gt; 를 참조해주세요.) &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;val proxiedPost: Reader[_ &amp;gt;: HttpRequest, POST] = sslProxy &amp;gt;==&amp;gt; convertGetToPost

// spec
proxiedPost.run(get1) shouldBe post2  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="flatmapforreader"&gt;flatMap for Reader&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Reader&lt;/code&gt; 는 &lt;code&gt;Kleisli&lt;/code&gt; 고, 이것간의 합성은 &lt;code&gt;&amp;gt;==&amp;gt;&lt;/code&gt; 을 이용한다는것을 확인했습니다. 그럼 &lt;code&gt;flatMap&lt;/code&gt; 은 어디에 쓰는걸까요? &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;type ReaderT[F[_], E, A] = Kleisli[F, E, A]  
type Reader[E, A] = ReaderT[Id, E, A]

final case class Kleisli[M[_], A, B](run: A =&amp;gt; M[B]) { self =&amp;gt;  
  ...

  // andThen
  def &amp;gt;=&amp;gt;[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] =  kleisli((a: A) =&amp;gt; b.bind(this(a))(k.run))

  def &amp;gt;==&amp;gt;[C](k: B =&amp;gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &amp;gt;=&amp;gt; kleisli(k)

  def flatMapK[C](f: B =&amp;gt; M[C])(implicit M: Bind[M]): Kleisli[M, A, C] =
    kleisli(a =&amp;gt; M.bind(run(a))(f))

  def flatMap[C](f: B =&amp;gt; Kleisli[M, A, C])(implicit M: Bind[M]): Kleisli[M, A, C] =
    kleisli((r: A) =&amp;gt; M.bind[B, C](run(r))(((b: B) =&amp;gt; f(b).run(r))))

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;flatMap&lt;/code&gt; 을 보면 재미난 점이 보입니다. &lt;code&gt;Kleisli[M, A, B]&lt;/code&gt; 와 &lt;code&gt;Kleisli[M, A, C]&lt;/code&gt; 를 &lt;code&gt;flatMap&lt;/code&gt; 으로 엮는데, &lt;code&gt;r: A&lt;/code&gt; 를 넣어서 &lt;code&gt;run(r)&lt;/code&gt; 을 실행하는걸 보실 수 있습니다. &lt;code&gt;Kleisli[M, A, C]&lt;/code&gt; 까지도요! &lt;/p&gt;

&lt;p&gt;즉 &lt;code&gt;A&lt;/code&gt; 자체가 일종의 설정(&lt;em&gt;Configuration&lt;/em&gt;) 값으로써 모든 &lt;code&gt;Kleisli&lt;/code&gt; 에서 사용됩니다. 그렇기에 &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Reader[A, B]&lt;/code&gt; 와 &lt;code&gt;Reader[B, C]&lt;/code&gt; 는 &lt;code&gt;&amp;gt;==&amp;gt;&lt;/code&gt; 으로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Reader[A, B]&lt;/code&gt; 와 &lt;code&gt;Reader[A, C]&lt;/code&gt; 는 &lt;code&gt;flatMap&lt;/code&gt; 으로 엮을 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="dependencyinjectionusingreader"&gt;Dependency Injection using Reader&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Reader&lt;/code&gt; 를 이용하면 스칼라에서 별도의 라이브러리 없이 &lt;em&gt;Dependency Injection&lt;/em&gt; (이하 &lt;em&gt;DI&lt;/em&gt;) 를 구현할 수 있습니다. 이는 위에서 보았던 &lt;code&gt;flatMap&lt;/code&gt; 의 특징을 이용하면 됩니다. 다음과 같은 모델이 있다고 할  때, &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;case class User(id: Long,  
                name: String,
                age: Int,
                email: String,
                supervisorId: Long)

trait UserRepository {  
  def get(id: Long): User
  def find(name: String): User
}

trait UserService {  
  def getUser(id: Long): Reader[UserRepository, User] =
    Reader(repo =&amp;gt; repo.get(id))

  def findUser(userName: String): Reader[UserRepository, User] =
    Reader(repo =&amp;gt; repo.find(userName))

  def getUserInfo(userName: String): Reader[UserRepository, Map[String, String]] = for {
    user &amp;lt;- findUser(userName)
    supervisor &amp;lt;- getUser(user.supervisorId)
  } yield Map(
    "email" -&amp;gt; s"${user.email}",
    "boss"  -&amp;gt; s"${supervisor.name}"
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음처럼 주입할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;object UserRepositoryDummyImpl extends UserRepository {  
  override def get(id: Long): User = ???
  override def find(name: String): User = ???
}

class UserApplication(userRepository: UserRepository) extends UserService  
object UserApplication extends UserApplication(UserRepositoryDummyImpl)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이외에도 스칼라에서 언어 자체의 기능만으로 DI 를 구현하는 방법으로 &lt;em&gt;Cake Pattern&lt;/em&gt; , &lt;em&gt;Implicit&lt;/em&gt; 등이 있습니다. (&lt;a href="http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/"&gt;Scala Dependency Injection using Reader&lt;/a&gt; 참조)&lt;/p&gt;

&lt;p&gt;위의 두 방법과 &lt;code&gt;Reader&lt;/code&gt; 를 사용한 방법을 비교하면, &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Cake Pattern&lt;/em&gt; 에 비해 코드가 짧고&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Implicit&lt;/em&gt; 를 이용하지 않으므로 함수 시그니쳐가 간단합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="writer"&gt;Writer&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Writer[W, A]&lt;/code&gt; 는 &lt;code&gt;run: (W, A)&lt;/code&gt; 을 값으로 가지는 &lt;em&gt;case class&lt;/em&gt; 입니다. 재미난 점은, &lt;code&gt;flatMap&lt;/code&gt; 을 이용해 두개의 &lt;code&gt;Writer&lt;/code&gt; 를 엮으면 각각의 값인 &lt;code&gt;(w1, a1)&lt;/code&gt;, &lt;code&gt;(w2, a2)&lt;/code&gt; 에 대해서 사용자가 다루는 값인 &lt;code&gt;a1, a2&lt;/code&gt; 를 제하고 &lt;code&gt;w1&lt;/code&gt; 과 &lt;code&gt;w2&lt;/code&gt; 가 일종의 &lt;a href="http://1ambda.github.io/easy-scalaz-1-state/"&gt;State&lt;/a&gt; 처럼 관리되어 자동으로 &lt;em&gt;append&lt;/em&gt; 된다는 점입니다. 따라서 많은 튜토리얼들이 &lt;em&gt;logging&lt;/em&gt; 을 예로 들어 &lt;code&gt;Writer&lt;/code&gt; 를 설명하곤 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;test("WriterOps") {  
  val w1: Writer[String, Int] = 10.set("w1 created")
  val w2: Writer[String, Int] = 20.set("w2 created")

  val result: Writer[String, Int] = for {
    n1 &amp;lt;- w1
    n2 &amp;lt;- w2
  } yield n1 + n2

  // What if we use `List[String]` instead of `String`?
  result.run shouldBe ("w1 createdw2 created", 30)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Scalaz&lt;/em&gt; 구현을 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;type Writer[W, A] = WriterT[Id, W, A]

final case class WriterT[F[_], W, A](run: F[(W, A)]) { self =&amp;gt;  
  ...

  def flatMap[B](f: A =&amp;gt; WriterT[F, W, B])(implicit F: Bind[F], s: Semigroup[W]): WriterT[F, W, B] =
    flatMapF(f.andThen(_.run))

  def flatMapF[B](f: A =&amp;gt; F[(W, B)])(implicit F: Bind[F], s: Semigroup[W]): WriterT[F, W, B] =
    writerT(F.bind(run){wa =&amp;gt;
      val z = f(wa._2)
      F.map(z)(wb =&amp;gt; (s.append(wa._1, wb._1), wb._2))
    })

  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;WriterT&lt;/code&gt; 에서 &lt;code&gt;F&lt;/code&gt; 를 &lt;code&gt;Id&lt;/code&gt; 라 하면 &lt;code&gt;Writer&lt;/code&gt; 가 되고 &lt;code&gt;flatMap&lt;/code&gt; 로직은 다음처럼 단순화 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;case class Writer[W, A](run: (W, A)) { self =&amp;gt;  
  def flatMap[B](f: A =&amp;gt; Writer[W, B])(implicit s: Semigroup[W]) {
    val (w1, a) = self.run
    val (w2, b) = f(a)
    (s.append(w1, w2), b)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Semigroup.scala"&gt;Semigroup.scala&lt;/a&gt; 은, &lt;em&gt;Associativity&lt;/em&gt; (결합법칙) 을 만족하는 &lt;em&gt;binary operator&lt;/em&gt; 를 정의하는 타입 클래스입니다. (위에서 &lt;code&gt;append&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Semigroup.scala#L55

 /**
   * A semigroup in type F must satisfy two laws:
    *
    *  - '''closure''': `∀ a, b in F, append(a, b)` is also in `F`. This is enforced by the type system.
    *  - '''associativity''': `∀ a, b, c` in `F`, the equation `append(append(a, b), c) = append(a, append(b , c))` holds.
   */
  trait SemigroupLaw {
    def associative(f1: F, f2: F, f3: F)(implicit F: Equal[F]): Boolean =
      F.equal(append(f1, append(f2, f3)), append(append(f1, f2), f3))
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Monoid.scala"&gt;Monoid&lt;/a&gt; 는 결합법칙을 만족하는 덧셈 연산과, 항등원 연산을 정의하는 타입 클래스인데, &lt;em&gt;Scalaz&lt;/em&gt; 에서는 &lt;code&gt;Monoid&lt;/code&gt; 가 &lt;code&gt;Semigroup&lt;/code&gt; 을 상속받습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;trait Monoid[F] extends Semigroup[F] { self =&amp;gt;  
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png" alt="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png"&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;Writer[W, A]&lt;/code&gt; 의 &lt;code&gt;flatMap&lt;/code&gt; 을 이용하기 위해서는 &lt;code&gt;W&lt;/code&gt; 가 &lt;code&gt;Semigroup&lt;/code&gt; 여야 하고 그래야만 &lt;code&gt;flatMap&lt;/code&gt; 내부에서 자동으로 &lt;code&gt;W&lt;/code&gt; 를 &lt;em&gt;append&lt;/em&gt; 할 수 있습니다. &lt;/p&gt;

&lt;p&gt;스칼라에서 제공하는 &lt;code&gt;List&lt;/code&gt; 등의 기본 타입은 &lt;em&gt;Scalaz&lt;/em&gt; 에서 &lt;code&gt;Monoid&lt;/code&gt; 를 제공합니다. (&lt;a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/std/List.scala#L109"&gt;scalaz.std.List&lt;/a&gt;, &lt;a href="https://github.com/scalaz/scalaz/tree/series/7.1.x/core/src/main/scala/scalaz/std"&gt;scalaz.std&lt;/a&gt; 참조)&lt;/p&gt;

&lt;p&gt;정리하면, &lt;code&gt;Writer[W, A]&lt;/code&gt; 를 이용하면 값인 &lt;code&gt;A&lt;/code&gt; 를 조작하면서 &lt;code&gt;W&lt;/code&gt; 를 신경쓰지 않고, 자동으로 &lt;code&gt;append&lt;/code&gt; 시킬 수 있습니다. (e.g &lt;em&gt;logging&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id="writerexample"&gt;Writer Example&lt;/h2&gt;

&lt;p&gt;간단한 모델을 만들면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;import scalaz._, Scalaz._

trait ThreadState  
case object Waiting    extends ThreadState  
case object Running    extends ThreadState  
case object Terminated extends ThreadState  
case class Thread(tid: String, name: String, state: ThreadState)  
case class Process(pid: String, threads: List[Thread])

object Process {  
  type Logger[A] = Writer[Vector[String], A]

  def genRandomID: String = java.util.UUID.randomUUID().toString.replace("-", "")

  def createThread(name: String): Logger[Thread] = {
    val tid = genRandomID
    Thread(tid, name, Waiting).set(Vector(s"Thread [$tid] was created"))
  }

  def createEmptyProcess: Logger[Process] = {
    val pid = genRandomID
    Process(pid, Nil).set(Vector(s"Empty Process [$pid] was created"))
  }

  def createNewProcess: Logger[Process] = for {
    mainThread &amp;lt;- createThread("main")
    process &amp;lt;- createEmptyProcess
    _ &amp;lt;- Vector(s"Main Thread [${mainThread.tid}] was added to Process [${process.pid}").tell
  } yield process.copy(threads = mainThread.copy(state = Running) :: process.threads)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;W&lt;/code&gt; 로 &lt;code&gt;List[String]&lt;/code&gt; 대신 &lt;code&gt;Vector[String]&lt;/code&gt; 을 사용하는 이유는, &lt;em&gt;append&lt;/em&gt; 가 더 빠르기 때문입니다. (&lt;a href="http://docs.scala-lang.org/overviews/collections/performance-characteristics.html"&gt;Scala Collection Performance Characteristics&lt;/a&gt; 참조)&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;test("Writer usage2") {  
  import readerwriterstate.Process._

  val (written, process) = createNewProcess.run

  process.threads.length shouldBe 1
  process.threads.head.name shouldBe "main"

  /* map lets you map over the value side */
  val ts: Logger[List[Thread]] = createNewProcess.map(p =&amp;gt; p.threads)
  ts.value.length shouldBe 1

  /* with mapWritten you can map over the written side */
  val edited: Vector[String] = createNewProcess.mapWritten(_.map { log =&amp;gt; "[LOG]" + log }).written
  println(edited.mkString("\n"))

  /** output
   * [LOG]Thread [557ad5bd0f3b4d49bac85b05ebedcd7b] was created
   * [LOG]Empty Process [710bd940ebdd4a82b949a32b585a12d9] was created
   * [LOG]Main Thread [557ad5bd0f3b4d49bac85b05ebedcd7b] was added to Process [710bd940ebdd4a82b949a32b585a12d9]
   */

  /* with mapValue, you can map over both sides */
  createNewProcess.mapValue { case (log, p) =&amp;gt;
    (log :+ "Add an IO thread",
     p.copy(threads = Thread(genRandomID, "IO-1", Waiting) :: p.threads))
  }

  // `:++&amp;gt;` `:++&amp;gt;&amp;gt;`, `&amp;lt;++:`, `&amp;lt;&amp;lt;++:`
  createNewProcess :++&amp;gt; Vector("add some log")
  val emptyWithLog = createEmptyProcess :++&amp;gt;&amp;gt; { process =&amp;gt;
    Vector(s"${process.pid} is an empty process")
  }

   println(emptyWithLog.written)

  // output: Vector(Empty Process [cf211fc366ab4d20a0c25a27d173accd] was created, cf211fc366ab4d20a0c25a27d173accd is an empty process)

  // Writer is an applicative
  val emptyProcesses: Logger[List[readerwriterstate.Process]] =
    (createEmptyProcess |@| createEmptyProcess) { List(_) |+| List(_) }

  val ps = emptyProcesses.value
  ps.length shouldBe 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://eed3si9n.com/learning-scalaz/Applicative+Builder.html"&gt;Applicative Builder&lt;/a&gt;, &lt;a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/WriterT.scala#L30"&gt;WriterT Functions&lt;/a&gt; 를 참고하시면 이해가 더 쉽습니다.&lt;/p&gt;

&lt;h2 id="rwst"&gt;RWST&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala"&gt;ReaderWriterState&lt;/a&gt; 는 다름이 아니라, 이제까지 보았던 &lt;code&gt;Reader&lt;/code&gt;, &lt;code&gt;Writer&lt;/code&gt;, &lt;code&gt;State&lt;/code&gt; 를 모두 이용하는 타입 클래스입니다. &lt;code&gt;Reader&lt;/code&gt; 로 설정값을 읽고, &lt;code&gt;Writer&lt;/code&gt; 로 중간 과정을 기록하고, &lt;code&gt;State&lt;/code&gt; 로 상태를 변경 또는 유지해 가며 연산을 수행할 수 있습니다. &lt;em&gt;Scalaz&lt;/em&gt; 에서는 예제로 &lt;a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/ReaderWriterStateTUsage.scala"&gt;ReaderWriterStateTUsage.scala&lt;/a&gt; 를 제공하고 있습니다.&lt;/p&gt;

&lt;p&gt;이제까지 늘 그래왔듯이, &lt;code&gt;ReaderWriterState[R, W, S, A]&lt;/code&gt; 또한 &lt;code&gt;ReaderWriterStateT[Id, R, W, S, A]&lt;/code&gt; 의 &lt;em&gt;type alias&lt;/em&gt; 입니다. &lt;code&gt;Reader&lt;/code&gt;, &lt;code&gt;Writer&lt;/code&gt;, &lt;code&gt;State&lt;/code&gt; 에서 사용했었던 함수들도 같이 제공됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;type ReaderWriterState[-R, W, S, A] = ReaderWriterStateT[Id, R, W, S, A]  
type ReaderWriterStateT[F[_], -R, W, S, A] = IndexedReaderWriterStateT[F, R, W, S, S, A]

object ReaderWriterState extends ReaderWriterStateTInstances with ReaderWriterStateTFunctions {  
  def apply[R, W, S, A](f: (R, S) =&amp;gt; (W, A, S)): ReaderWriterState[R, W, S, A] = IndexedReaderWriterStateT[Id, R, W, S, S, A] { (r: R, s: S) =&amp;gt; f(r, s) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;apply&lt;/code&gt; 를 보면, &lt;code&gt;ReaderWriterState&lt;/code&gt; 는 타입 &lt;code&gt;(R, S) =&amp;gt; (W, A, S)&lt;/code&gt; 함수를 넘겨주어 생성할 수 있습니다. &lt;code&gt;Reader&lt;/code&gt;, &lt;code&gt;State&lt;/code&gt; 를 받고, &lt;code&gt;Writer&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; (결과값), &lt;code&gt;State&lt;/code&gt; 를 돌려주는 것으로 해석할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ReadwrWriterState.flatMap&lt;/code&gt; 은 &lt;code&gt;State&lt;/code&gt;, &lt;code&gt;Writer&lt;/code&gt;, &lt;code&gt;Reader&lt;/code&gt; 의 &lt;code&gt;flatMap&lt;/code&gt; 을 모두 조합한것처럼 생겼습니다. 하는일도 그렇구요. &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;/** A monad transformer stack yielding `(R, S1) =&amp;gt; F[(W, A, S2)]`. */
sealed abstract class IndexedReaderWriterStateT[F[_], -R, W, -S1, S2, A] {

  ...

  def flatMap[B, RR &amp;lt;: R, S3](f: A =&amp;gt; IndexedReaderWriterStateT[F, RR, W, S2, S3, B])(implicit F: Bind[F], W: Semigroup[W]): IndexedReaderWriterStateT[F, RR, W, S1, S3, B] =
    new IndexedReaderWriterStateT[F, RR, W, S1, S3, B] {
      def run(r: RR, s1: S1): F[(W, B, S3)] = {
        F.bind(self.run(r, s1)) {
          case (w1, a, s2) =&amp;gt; {
            F.map(f(a).run(r, s2)) {
              case (w2, b, s3) =&amp;gt; (W.append(w1, w2), b, s3)
            }
          }
        }
      }
    }

  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala#L4"&gt;Scalaz - IndexedReaderWriterStateT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala#L179"&gt;Scalaz - ReaderWriterStateTMonad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="rwstexample"&gt;RWST Example&lt;/h2&gt;

&lt;p&gt;예제를 위해 간단한 모델을 만들어 보겠습니다. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Reader&lt;/code&gt; 로 &lt;code&gt;DatabaseConfig&lt;/code&gt; 를&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Writer&lt;/code&gt; 로 &lt;code&gt;Vector[String]&lt;/code&gt; 을&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State&lt;/code&gt; 로 &lt;code&gt;Connection&lt;/code&gt; 을 이용하고&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결과값으로 타입 &lt;code&gt;A&lt;/code&gt; 를 돌려주는 &lt;code&gt;Task[A]&lt;/code&gt; 를 만들면 아래와 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;object Database {  
  type Task[A] = ReaderWriterState[DatabaseConfig, Vector[String] /* log */, Connection, A]
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기에 몇 가지 제약조건을 걸어보겠습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DatabaseConfig.operationTimeoutMillis&lt;/code&gt; 에 의해서 타임아웃(&lt;code&gt;OperationTimeoutException&lt;/code&gt;) 발생&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OperationTimeoutException&lt;/code&gt; 발생시, 연산을 즉시 중단하고, 오류 없이 수행이 되었을 경우 &lt;em&gt;commit&lt;/em&gt; &lt;/li&gt;
&lt;li&gt;&lt;em&gt;Post Commit Action&lt;/em&gt; 등록을 할 수 있어야 하며, &lt;em&gt;commit&lt;/em&gt; 후 순차대로 자동 실행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 필요한 몇몇 클래스를 만들고&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;type Action = () =&amp;gt; Unit  
case class PostCommitAction(id: String, action: Action)  
case class DatabaseConfig(operationTimeoutMillis: Long)  
case class ResultSet() /* dummy */

case class Connection(id: String,  
                      actions: List[PostCommitAction] = Nil) {

  def commit = {}
  def executeAndReturn(query: String): ResultSet = ResultSet()
  def execute(query: String): Unit = {}
}

class OperationTimeoutException private(ex: RuntimeException) extends RuntimeException(ex) {  
  def this(message:String) = this(new RuntimeException(message))
  def this(message:String, throwable: Throwable) = this(new RuntimeException(message, throwable))
}

object OperationTimeoutException {  
  def apply(message:String) = new OperationTimeoutException(message)
  def apply(message:String, throwable: Throwable) = new OperationTimeoutException(message, throwable)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 사용자가 API 를 사용하는 것을 한번 상상해보겠습니다. &lt;em&gt;commit&lt;/em&gt; 이 어쨌건, 사용자가 하고싶은 일은 쿼리를 실행해서 결과값을 받아오거나, 필요한 &lt;em&gt;post commit action&lt;/em&gt; 을 등록하는 일일겁니다. 나머지는 다 알아서 해주겠거니 하고 기대하고 있겠지요. 아래와 같은 API 가 있다면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def createTask[A](f: Connection =&amp;gt; A): Task[A]  
def addPostCommitAction(action: Action): Task[Unit]  
def run[A](task: Task[A]): Option[A]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;사용자들이 이런 방식으로 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;case class Person(name: String, address: Address)  
case class Address(street: String)

def getPerson(name: String): Task[Person] = createTask { conn =&amp;gt;  
  val rs: ResultSet = conn.executeAndReturn(s"SELECT * FROM USER WHERE name == '$name'")

  /* get a person using the result set */
  ...
}

def updateAddress(person : Person): Task[Unit] = createTask { conn =&amp;gt;  
  /* do something */
  conn.execute(
    s"UPDATE ADDRESS SET street = '${person.address.street}' where person_name = '${person.name}'")
}

val getAndUpdatePersonTask: Task[Person] = for {  
  p &amp;lt;- getPerson("1ambda")
  updatedP = p.copy(address = Address("BACON STREET 234"))
  _ &amp;lt;- addPostCommitAction(() =&amp;gt; println("post commit action1"))
  _ &amp;lt;- updateAddress(updatedP)
  _ &amp;lt;- addPostCommitAction(() =&amp;gt; println("post commit action2"))
} yield updatedP

val person: Option[Person] = Database.run(getAndUpdatePersonTask)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 상상했던 함수를 구현해 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/1ambda/scala/blob/master/learning-scalaz/src/main/scala/readerwriterstate/Database.scala

import java.util.UUID  
import scalaz._, Scalaz._  
import Database._  
import com.github.nscala_time.time.Imports._

object Database {

  ...
  object Implicit {
    implicit def defaultConnection: Connection = Connection(genRandomUUID)
    implicit def defaultConfig = DatabaseConfig(500)
  }

  private def genRandomUUID: String = UUID.randomUUID().toString

  private def execute[A](f: =&amp;gt; A, conf: DatabaseConfig): A = {
    val start = DateTime.now

    val a = f

    val end = DateTime.now

    val time: Long = (start to end).millis

    if (time &amp;gt; conf.operationTimeoutMillis)
      throw OperationTimeoutException(s"Operation timeout: $time millis")

    a
  }

  def createTask[A](f: Connection =&amp;gt; A): Task[A] =
    ReaderWriterState { (conf, conn) =&amp;gt;
      val a = execute(f(conn), conf)
      (Vector(s"Task was created with connection[${conn.id}]"), a, conn)
    }

  def addPostCommitAction(action: Action): Task[Unit] =
    ReaderWriterState { (conf, conn: Connection) =&amp;gt;

      val postCommitAction = PostCommitAction(genRandomUUID, action)
      (Vector(s"Add PostCommitAction(${postCommitAction.id})"),
        Unit,
        conn.copy(actions = conn.actions :+ postCommitAction))
    }

  def run[A](task: Task[A])
            (implicit defaultConf: DatabaseConfig, defaultConn: Connection): Option[A] = {

    \/.fromTryCatchThrowable[(Vector[String], A, Connection), Throwable](
      task.run(defaultConf, defaultConn)
    ) match {
      case -\/(t) =&amp;gt;
        println(s"Operation failed due to ${t.getMessage}") /* logging */
        none[A]

      case \/-((log: Vector[String], a: A, conn: Connection)) =&amp;gt;
        conn.commit /* close connection */

        log.foreach { text =&amp;gt; println(s"[LOG] $text")} /* logging */

        /* run post commit actions */
        conn.actions foreach { _.action() }

        a.some
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 실제로 &lt;em&gt;500 ms&lt;/em&gt; 를 초과하는 연산을 실행하면, 예외가 발생하는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;  test("Database example") {

    val slowQuery: Task[Person] = createTask { conn =&amp;gt;
      sleep(600)
      Person("Sherlock", Address("BACON ST 221-B"))
    }

    val getPeopleTask: Task[List[Person]] = for {
      p1 &amp;lt;- getPerson("Mycroft")
      p2 &amp;lt;- getPerson("Watson")
      p3 &amp;lt;- slowQuery
      _ &amp;lt;- addPostCommitAction(() =&amp;gt; println("post commit1"))
    } yield p1 :: p2 :: p3 :: Nil

    import Database.Implicit._
    val people = Database.run(getPeopleTask)

    // log: Operation failed due to java.lang.RuntimeException: Operation timeout: 603 millis
    people shouldBe None
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="previousposts"&gt;Previous Posts&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-1-state/"&gt;Easy Scalaz 1, State&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/"&gt;Easy Scalaz 2, Monad Transformer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="references"&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://cs.lth.se/edan40"&gt;Haskell Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://coderwall.com/p/ye_s_w/tooling-the-reader-monad"&gt;Tooling The Reader Monad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/"&gt;Reader Monad For Dependency Injection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://slides.com/danielbedo/reader-monad"&gt;Slideshare: Reader Monad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.haskell.org/Typeclassopedia"&gt;Typeclassopedia Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.scala-lang.org/overviews/collections/performance-characteristics.html"&gt;Scala Collection Performance Characteristics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title>About Type Class</title><description>&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;프로그래머가 하는 행위를 극도로 단순화해서 표현하면 &lt;strong&gt;저수준&lt;/strong&gt; 의 데이터를 &lt;strong&gt;고수준&lt;/strong&gt; 데이터로 변환하는 일입니다.&lt;/p&gt;

&lt;p&gt;여기서 저수준이란, &lt;em&gt;Stream&lt;/em&gt;, &lt;em&gt;Byte&lt;/em&gt;, &lt;em&gt;JSON&lt;/em&gt;, &lt;em&gt;String&lt;/em&gt; 등 현실세계의 데이터를, 고수준이라 함은 비즈니스 로직, 제약조건 등이 추가된 도메인 객체, 모델 등 데이터를 말합니다. &lt;/p&gt;

&lt;p&gt;이로 인해&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;저수준을 고수준으로 변환하는건 조건이 충족되지 않은 데이터와 연산 과정에서 일어나는 시스템 오류를 처리해야하기&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</description><link>http://1ambda.github.io/about-type-class/</link><guid isPermaLink="false">40c5a8ff-eb1f-40a3-a8b6-38f5e97ced9f</guid><category>scala</category><category>scalaz</category><category>type class</category><dc:creator>1ambda</dc:creator><pubDate>Tue, 20 Oct 2015 16:43:43 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;프로그래머가 하는 행위를 극도로 단순화해서 표현하면 &lt;strong&gt;저수준&lt;/strong&gt; 의 데이터를 &lt;strong&gt;고수준&lt;/strong&gt; 데이터로 변환하는 일입니다.&lt;/p&gt;

&lt;p&gt;여기서 저수준이란, &lt;em&gt;Stream&lt;/em&gt;, &lt;em&gt;Byte&lt;/em&gt;, &lt;em&gt;JSON&lt;/em&gt;, &lt;em&gt;String&lt;/em&gt; 등 현실세계의 데이터를, 고수준이라 함은 비즈니스 로직, 제약조건 등이 추가된 도메인 객체, 모델 등 데이터를 말합니다. &lt;/p&gt;

&lt;p&gt;이로 인해&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;저수준을 고수준으로 변환하는건 조건이 충족되지 않은 데이터와 연산 과정에서 일어나는 시스템 오류를 처리해야하기 때문에 힘든일입니다&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;갖은 고생 끝에 데이터를 고수준으로 끌어올린 뒤에야, 그 데이터를 프로그래머 자신의 세상에서 마음껏 주무를 수 있습니다&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;프로그래머가 작업을 끝낼 시점이 되면, 데이터를 저수준으로 변환해서 저장 또는 전송해야 하는데, 이미 제약조건이 충족 되었기 때문에 이는 손쉬운 일입니다&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;따라서 핵심은 다음의 두가지 입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;쉽게 고수준으로 변환할 수 있는가 (&lt;strong&gt;연산&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;변환된 고수준 데이터가 얼마나 다루기 편한가 (&lt;strong&gt;추상&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로그래머가 &lt;em&gt;적절한 연산&lt;/em&gt; 을 선택하면 힘들이지 않고 변환을 해낼것이고, &lt;em&gt;적절한 추상 (혹은 모델링)&lt;/em&gt; 을 한다면 직관적인 코드로 데이터를 주무를 수 있게 되는데, 이 것을 도와주는 것이 바로 &lt;strong&gt;타입 클래스&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;타입 클래스를 이용하면, &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if null&lt;/code&gt;  을 Option 으로,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S =&amp;gt; (S, A)&lt;/code&gt; 을 State[S, A] 로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if if if&lt;/code&gt; 를 Applicative 로&lt;/li&gt;
&lt;li&gt;&lt;em&gt;fail-slow&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt; 로직은 ValidationNel 과 Either 로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F[G[A]]&lt;/code&gt; 을 &lt;code&gt;G[F[A]]&lt;/code&gt; 로의 변경은 Traversal 로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setC{applyB{getA}}&lt;/code&gt; 를 getA &gt; applyB &gt; setC 로(Kleisli)
표기할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 연산을 각각의 타입으로 표시하기 때문에 로직을 파악하고, 분할하기 쉽습니다. 그리고 연산을 작성하는 과정이 타입을 조합하는 과정과 동일하기 때문에 컴파일러의 도움을 받을수 있구요.&lt;/p&gt;

&lt;p&gt;타입클래스는 &lt;strong&gt;연산이 어떠해야 하는지&lt;/strong&gt; 를 다루기 때문에 연산을 조합할 수 있는 다양한 함수들이 포함되어 있습니다. 이것을 이용하면 직관적인 방식으로 데이터를 다룰 수 있는데, 예를 들어 다음은 코드 실행과정에서 예외 발생 시에만 롤백을 수행하고, 예외를 돌려주는 코드입니다. (간략화 하였습니다.) &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;\/.fromTryCatch { 
  val result = runQuery; 
  commit; 
  result 
} leftMap(err =&amp;gt; rollback; err};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 &lt;code&gt;if null&lt;/code&gt;  보다  &lt;code&gt;Option&lt;/code&gt; 을 쓰는것이 더 편하고 익숙하다면, &lt;code&gt;Applicative&lt;/code&gt; 부터 천천히 시작해보는건 어떨까요?&lt;/p&gt;

&lt;h3 id="reference"&gt;Reference&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://wiki.haskell.org/Typeclassopedia"&gt;Typeclassopedia Image - Haskell Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title>Easy Scalaz 2, Monad Transformer</title><description>&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;지난 시간엔 &lt;em&gt;State Monad&lt;/em&gt; 를 다루었습니다. 그러나 &lt;em&gt;State&lt;/em&gt; 만 이용해서는 유용한 프로그램을 작성할 수 없습니다. 우리가 다루는 연산은 &lt;em&gt;Option&lt;/em&gt;, &lt;em&gt;Future&lt;/em&gt; 등 다양한 &lt;em&gt;side-effect&lt;/em&gt; 가 필요하기 때문인데요, &lt;/p&gt;

&lt;p&gt;서로 다른 &lt;code&gt;Monad&lt;/code&gt; 를 조합할 수 있다면 좋겠지만, 아쉽게도  &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Applicative&lt;/code&gt; 와 달리 모나드는 &lt;em&gt;composing&lt;/em&gt; 이 불가능합니다. &lt;a href="http://tonymorris.github.io/blog/posts/monads-do-not-compose"&gt;Monad Do Not Compose&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;여러 모나드를 조합해서&lt;/p&gt;</description><link>http://1ambda.github.io/easy-scalaz-2-monad-transformer/</link><guid isPermaLink="false">20ace812-f624-48ad-bfe9-9d1b707ed231</guid><category>scala</category><category>scalaz</category><category>monad transformer</category><category>EitherT</category><category>OptionT</category><category>StateT</category><dc:creator>1ambda</dc:creator><pubDate>Fri, 16 Oct 2015 14:46:45 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;지난 시간엔 &lt;em&gt;State Monad&lt;/em&gt; 를 다루었습니다. 그러나 &lt;em&gt;State&lt;/em&gt; 만 이용해서는 유용한 프로그램을 작성할 수 없습니다. 우리가 다루는 연산은 &lt;em&gt;Option&lt;/em&gt;, &lt;em&gt;Future&lt;/em&gt; 등 다양한 &lt;em&gt;side-effect&lt;/em&gt; 가 필요하기 때문인데요, &lt;/p&gt;

&lt;p&gt;서로 다른 &lt;code&gt;Monad&lt;/code&gt; 를 조합할 수 있다면 좋겠지만, 아쉽게도  &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Applicative&lt;/code&gt; 와 달리 모나드는 &lt;em&gt;composing&lt;/em&gt; 이 불가능합니다. &lt;a href="http://tonymorris.github.io/blog/posts/monads-do-not-compose"&gt;Monad Do Not Compose&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;여러 모나드를 조합해서 사용하려면 &lt;em&gt;Monad Transformer&lt;/em&gt; 가 필요합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Monad transformers are useful for enabling interaction between different types of monads by "nesting" them into a higher-level monadic abstraction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Monad Transformer&lt;/em&gt; 란 여러 모나드의 &lt;em&gt;effect&lt;/em&gt; 를 엮어 새로운 모나드를 만들때 쓸 수 있습니다. 예를 들어&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;어떤 임의의 모나드 M 을 사용하면서 &lt;code&gt;State&lt;/code&gt; 효과를 주고 싶을 때 &lt;code&gt;StateT&lt;/code&gt; 를 이용할 수 있습니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State&lt;/code&gt; 를 다루면서, &lt;code&gt;for&lt;/code&gt; 내에서 &lt;code&gt;Option&lt;/code&gt; 처럼 로직을 다루고 싶다면, &lt;code&gt;OptionT[State, A]&lt;/code&gt; 를 이용할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대략 감이 오시죠? (&lt;code&gt;State&lt;/code&gt; 에 대한 자세한 설명은 &lt;a href="http://1ambda.github.io/easy-scalaz-1-state/"&gt;Easy Scalaz 1 - State&lt;/a&gt; 을 참조)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;scalaz&lt;/em&gt; 에는 기본적으로 여러 모나드 트랜스포머가 정의되어 있습니다. (&lt;a href="https://github.com/scalaz/scalaz/tree/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz"&gt;scalaz.core.*&lt;/a&gt;) &lt;code&gt;ListT&lt;/code&gt;, &lt;code&gt;MaybeT&lt;/code&gt; 등등. 이번 글에서는 아래 3개의 모나드 트랜스포머만 다룰 예정입니다. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/scalaz/scalaz/blob/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz/OptionT.scala"&gt;Scalaz - OptionT.scala&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/scalaz/scalaz/blob/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz/EitherT.scala"&gt;Scalaz - EitherT.scala&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/scalaz/scalaz/blob/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz/StateT.scala"&gt;Scalaz - StateT.scala&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="theproblem"&gt;The Problem&lt;/h2&gt;

&lt;p&gt;모나드 트랜스포머를 설명하기 위해, 사용자의 Github Repository 에 어느 언어가 쓰였는지를 알려주는 &lt;code&gt;findLanguage&lt;/code&gt; 함수를 작성해보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// ref - https://softwarecorner.wordpress.com/2013/12/06/scalaz-optiont-monad-transformer/

import scalaz._, Scalaz._

case class User(name: String, repositories: List[Repository])  
case class Repository(name: String, languages: List[Language])  
case class Language(name: String, line: Long)

object GithubService {  
  def findLanguage(users: List[User],
                    userName: String,
                    repoName: String, 
                    langName: String): Option[Language] =
    for {
      u &amp;lt;- users          find { _.name === userName }
      r &amp;lt;- u.repositories find { _.name === repoName }
      l &amp;lt;- r.languages    find { _.name === langName }
    } yield l
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;List[User]&lt;/code&gt; 를 받아 해당 유저의 레포지토리에서 특정 언어가 있는지, 없는지를 검사하는 간단한 함수입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;val u1 = User(  
  "1ambda", List(
    Repository("akka", List(
      Language("scala", 4990),
      Language("java",  12801)
    )),

    Repository("scalaz", List(
      Language("scala", 1451),
      Language("java",  291)
    ))
  )
)

val u2 = User(  
  "2ambda", List()
)

val users = List(u1, u2)

// spec
"findLanguage" in {
  val l1 = findLanguage(users, "1ambda", "akka", "scala")
  val l2 = findLanguage(users, "1ambda", "akka", "haskell")
  val l3 = findLanguage(users, "1ambda", "rx-scala", "scala")
  val l4 = findLanguage(users, "adbma1", "rx-scala", "scala")

  l1.isDefined shouldBe true
  l2.isDefined shouldBe false
  l3.isDefined shouldBe false
  l4.isDefined shouldBe false
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그런데, 요구사항이 갑자기 변경되어 많이 쓰이는 언어도 찾아내야 합니다. &lt;strong&gt;검사한 것 중 1000 줄이 넘는 언어리스트를 상태로 다루면&lt;/strong&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;type LangState = State[List[Language], Option[Language]]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;findLanguage&lt;/code&gt; 를 다시 작성하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def findLanguage2(users: List[User],  
                  userName: String,
                  repoName: String,
                  langName: String): LangState =
  for {
    u &amp;lt;- users.find(_.name === userName).point[LangState]
    r  &amp;lt;- u.repositories.find(_.name === repoName).point[LangState]
    l &amp;lt;- r.languages.find(_.name === langName).point[LangState]
    _ &amp;lt;- modify(langs: List[Language] =&amp;gt; if (l.line &amp;gt;= 1000) l :: langs else langs)
  } yield song
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;당연히 컴파일이 되지 않습니다. 이는 &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt; 이 각각 &lt;code&gt;User&lt;/code&gt;, &lt;code&gt;Repository&lt;/code&gt;, &lt;code&gt;Language&lt;/code&gt; 가 아니라 &lt;code&gt;Option[User]&lt;/code&gt;, &lt;code&gt;Option[Repository]&lt;/code&gt;, &lt;code&gt;Option[Language]&lt;/code&gt; 이기 때문입니다. 패턴 매칭을 적용하면 아래와 같은 코드가 만들어집니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def findLanguage(users: List[User],  
                  userName: String,
                  repoName: String,
                  langName: String): LangState[Option[Language]] =
  for {
    optUser &amp;lt;- (users.find { _.name === userName }).point[LangState]
    optRepository &amp;lt;- (
      optUser match {
        case Some(u) =&amp;gt; u.repositories.find(_.name === repoName)
        case None =&amp;gt; none[Repository] // same as Option.empty[Repository]
      }).point[LangState]
    optLanguage &amp;lt;- (optRepository match {
      case Some(r) =&amp;gt; r.languages.find(_.name === langName)
      case None    =&amp;gt; none[Language]
    }).point[LangState]
    _ &amp;lt;- modify { langs: List[Language] =&amp;gt; optLanguage match {
      case Some(l) if l.line =&amp;gt; 1000 =&amp;gt; l :: langs
      case _                         =&amp;gt; langs
    }}
  } yield optLanguage
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드에서 중복되는 부분을 발견할 수 있는데요, 바로 &lt;code&gt;State[S, Option[A]]&lt;/code&gt; 에 대해 매번 패턴 매칭을 수행하는 부분이 중복입니다. 이를 제거하기 위해 새로운 모나드 &lt;code&gt;LangStateOption&lt;/code&gt; 을 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-sacla"&gt;case class LangStateOption[A](run: LangState[Option[A]])  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 모나드를 구현하면&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;implicit val LangStateOptionMonad = new Monad[LangStateOption] {  
  override def point[A](a: =&amp;gt; A): LangStateOption[A] =
    LangStateOption(a.point[Option].point[LangState])

  override def bind[A, B](fa: LangStateOption[A])(f: (A) =&amp;gt; LangStateOption[B]): LangStateOption[B] =
    LangStateOption(fa.run.flatMap { (o: Option[A]) =&amp;gt; o match {
      case Some(a) =&amp;gt; f(a).run
      case None    =&amp;gt; (none[B]).point[LangState] /* same as `(None: Option[B]).point[LangState]` */
    }})
}

// findLanguage impl
def findLanguage3(users: List[User],  
                  userName: String,
                  repoName: String,
                  langName: String): LangStateOption[Language] =
  for {
    u &amp;lt;- LangStateOption((users.find { _.name === userName }).point[LangState])
    r &amp;lt;- LangStateOption((u.repositories.find { _.name === repoName }).point[LangState])
    l &amp;lt;- LangStateOption((r.languages.find { _.name === langName }).point[LangState])
    _ &amp;lt;- LangStateOption((modify { langs: List[Language] =&amp;gt;
      if (l.line &amp;gt;= 1000) l :: langs else langs
    }) map (_ =&amp;gt; none[Language]))
  } yield l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 잘 보셔야 할 두 가지 부분이 있습니다&lt;/p&gt;

&lt;p&gt;A. 우리가 임의의 모나드와 &lt;code&gt;Option&lt;/code&gt; 을 엮은 새로운 모나드를 생성한다면, &lt;code&gt;LangStateOption&lt;/code&gt; 타입만 다르고 모두 동일한 형태의 코드를 가지게 됩니다.&lt;/p&gt;

&lt;p&gt;그런고로 &lt;em&gt;scalaz&lt;/em&gt; 에서는 &lt;code&gt;Option&lt;/code&gt; 과 임의의 모나드 &lt;code&gt;M&lt;/code&gt; 을 조합한 타입을 &lt;code&gt;OptionT[M[_], A]&lt;/code&gt; 로 제공합니다. &lt;/p&gt;

&lt;p&gt;B. &lt;code&gt;State&lt;/code&gt; 와 &lt;code&gt;Option&lt;/code&gt; 을 엮어서 &lt;code&gt;State[S, Option[A]]&lt;/code&gt; 를 엮을 경우 &lt;code&gt;State&lt;/code&gt; 가 먼저 실행되고, 그 후에야 &lt;code&gt;Option&lt;/code&gt; 이 효과를 발휘합니다. (&lt;code&gt;fa.run.flatMap { o =&amp;gt; ...&lt;/code&gt;}&lt;/p&gt;

&lt;p&gt;따라서 어떤 모나드 트랜스포머와, 모나드를 엮냐에 따라서 의미가 달라집니다. 예를 들어 &lt;em&gt;scalaz&lt;/em&gt; 에서 제공해주는 모나드 트랜스포머 &lt;code&gt;OptionT&lt;/code&gt; 와 &lt;code&gt;StateT&lt;/code&gt; 에 대해 &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OptionT[LangState, A]&lt;/code&gt; 는 &lt;code&gt;run: LangState[Option[A]]&lt;/code&gt; 이기 때문에 &lt;em&gt;optional value&lt;/em&gt; 를 돌려주는 &lt;em&gt;state action&lt;/em&gt; 을 의미하고&lt;/li&gt;
&lt;li&gt;반면 &lt;code&gt;StateT[Option, List[Language], A]]&lt;/code&gt; 는 &lt;code&gt;run: Option[State[List[Language], A]]&lt;/code&gt; 기 때문에 존재하지 않을 수 있는 (&lt;code&gt;None&lt;/code&gt;) 일 수 있는 &lt;em&gt;state action&lt;/em&gt; 을 의미합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="monadtrans"&gt;MonadTrans&lt;/h2&gt;

&lt;p&gt;지금까지 우리가 했던 일을 살펴보면,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;M[A]&lt;/code&gt; -&gt; &lt;code&gt;M[N[A]]&lt;/code&gt; -&gt; &lt;code&gt;NT[M[N[_]], A]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉 하나의 모나드 &lt;code&gt;M&lt;/code&gt; 이 있을때 &lt;code&gt;A&lt;/code&gt; 를 &lt;code&gt;N[A]&lt;/code&gt; 로 &lt;em&gt;lifting&lt;/em&gt; 하는 &lt;code&gt;N&lt;/code&gt; 을 위한 모나드 트랜스포머를 &lt;code&gt;NT&lt;/code&gt; 를 정의했습니다. &lt;em&gt;scalaz&lt;/em&gt; 에서 사용된 모나드 트랜스포머 구현인 &lt;code&gt;MonadTrans&lt;/code&gt;, &lt;code&gt;OptionT&lt;/code&gt; 을 보면 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/MonadTrans.scala
trait MonadTrans[F[_[_], _]] {  
  def liftM[G[_]: Monad, A](g: G[A]): F[G, A]

  ...
}

// OptionT `liftM` implementation (F == Option)
// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/OptionT.scala#L213

def liftM[G[_], A](a: G[A])(implicit G: Monad[G]): OptionT[G, A]) =  
  OptionT[G, A](G.map[A, Option[A]](a) { (a: A) =&amp;gt; 
    a.point[Option]
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Monad Transformer&lt;/strong&gt; 또한 &lt;strong&gt;Monad&lt;/strong&gt; 기 때문에 또 다른 &lt;strong&gt;Monad Transformer&lt;/strong&gt; 와 중첩이 가능합니다. 예를 들어&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// ref - http://www.slideshare.net/StackMob/monad-transformers-in-the-wild
type VIO[A] = ValidationT[IO, Throwable, A]  
def doIO: VIO[Option[String]  
val r = OptionT[VIO, String] = optionT[VIO](doIO)

// OptionT[ValidationT[IO, Throwable, A]
// == IO[Validation[Throwable, Option[A]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="optiont"&gt;OptionT&lt;/h2&gt;

&lt;p&gt;이제 모나드 트랜스포머가 무엇인지 알았으니, &lt;code&gt;OptionT&lt;/code&gt; 를 사용해 볼까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/OptionT.scala

final case class OptionT[F[_], A](run: F[Option[A]]) {  
  self =&amp;gt;

  private def mapO[B](f: Option[A] =&amp;gt; B)(implicit F: Functor[F]) = F.map(run)(f)

  def map[B](f: A =&amp;gt; B)(implicit F: Functor[F]): OptionT[F, B] = new OptionT[F, B](mapO(_ map f))

  def flatMap[B](f: A =&amp;gt; OptionT[F, B])(implicit F: Monad[F]): OptionT[F, B] = new OptionT[F, B](
    F.bind(self.run) {
      case None    =&amp;gt; F.point(None: Option[B])
      case Some(z) =&amp;gt; f(z).run
    }
  )

  def flatMapF[B](f: A =&amp;gt; F[B])(implicit F: Monad[F]): OptionT[F, B] = new OptionT[F, B](
    F.bind(self.run) {
      case None    =&amp;gt; F.point(none[B])
      case Some(z) =&amp;gt; F.map(f(z))(b =&amp;gt; some(b))
    }
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OptionT&lt;/code&gt; 는 두 가지 방법으로 생성할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;val ma: M[A]&lt;/code&gt; 가 있을 때 &lt;code&gt;ma.liftM[OptionT]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;val oa: Option[A]&lt;/code&gt; 가 있을 때 &lt;code&gt;OptionT(oa.point[M])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// type LangState[A] = State[List[Language], A]
val l = Language("lisp", 309)  
val os1: OptionT[LangState, Language] = l.point[LangState].liftM[OptionT]  
val os2: OptionT[LangState, Language] = OptionT(l.some.point[LangState])

os1 === os2  
os1.run === os2.run  
os1.run.runZero[List[Language]] === os2.run.runZero[List[Language]]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;findLanguage&lt;/code&gt; 함수를 &lt;code&gt;OptionT&lt;/code&gt; 로 작성할 수 있습니다. &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def findLanguage(users: List[User],  
                  userName: String,
                  repoName: String,
                  langName: String): OptionT[LangState, Language] =
  for {
    u &amp;lt;- OptionT((users.find { _.name === userName }).point[LangState])
    r &amp;lt;- OptionT((u.repositories.find { _.name === repoName }).point[LangState])
    l &amp;lt;- OptionT((r.languages.find { _.name === langName }).point[LangState])
    _ &amp;lt;- modify { langs: List[Language] =&amp;gt;
      if (l.line &amp;gt;= 1000) l :: langs else langs
    }.liftM[OptionT]
  } yield l
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="sequencingoptiont"&gt;Sequencing OptionT&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;findLanguage&lt;/code&gt; 를 이용해서, findLanguage&lt;strong&gt;s&lt;/strong&gt; 를 작성하는 것이 가능할까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;case class LanguageLookup(userName: String, repoName: String, langName: String)

// Option[List[Language]] 를 돌려주는 All or Nothing 버전
def findLanguages(users: List[User],  
                     lookups: List[LanguageLookup]): OptionT[LangState, List[Language]] = ???

// List[Option[Language]] 를 돌려주는 덜 엄격한 버전
def findLanguages(users: List[User],  
                     lookups: List[LanguageLookup]): LangState[List[Option[Language]]] = ???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;일단 &lt;code&gt;OptionT[LangState, List[Language]]&lt;/code&gt; 를 돌려주는 것 부터 작성해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def findLanguages1(users: List[User],  
                   lookups: List[LanguageLookup]): OptionT[LangState, List[Language]] =
  lookups map { lookup =&amp;gt;
    findLanguage(users, lookup.userName, lookup.repoName, lookup.langName)
  }

// compile error
Error:(87, 13) type mismatch;

 found   : List[scalaz.OptionT[LangState, Language]]
 required: scalaz.OptionT[LangState,List[Language]]
    lookups map { lookup =&amp;gt;
            ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;우리는 &lt;code&gt;OptionT[LangState, List[Language]]&lt;/code&gt; 를 돌려줘야 하는데, 단순히 &lt;code&gt;map&lt;/code&gt; 만 적용해서는 &lt;code&gt;List[OptionT[LangState, Language]]&lt;/code&gt; 밖에 못 얻습니다. 따라서 &lt;code&gt;Traversable.traverseU&lt;/code&gt; 를 이용하면&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def findLanguages1(users: List[User],  
                   lookups: List[LanguageLookup]): OptionT[LangState, List[Language]] =
  lookups.traverseU { lookup =&amp;gt;
    findLanguage(users, lookup.userName, lookup.repoName, lookup.langName)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;traverseU(f)&lt;/code&gt; 가 하는 일은 &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;map(f)&lt;/code&gt;: 함수 &lt;code&gt;f&lt;/code&gt; 를 적용합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List[OptionT[LangState, Language]]&lt;/code&gt; 를 &lt;code&gt;OptionT[LangState, List[Language]]&lt;/code&gt; 를 변환합니다. &lt;strong&gt;Option 모나드의 효과를 적용하면서요&lt;/strong&gt; (&lt;strong&gt;sequence&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 &lt;code&gt;F[G[B]]&lt;/code&gt; 를 &lt;code&gt;G[F[B]]&lt;/code&gt; 로 변경하는 함수를 &lt;code&gt;sequence&lt;/code&gt; 라 부릅니다. (&lt;code&gt;F&lt;/code&gt; 는 &lt;em&gt;Monad&lt;/em&gt;, &lt;code&gt;G&lt;/code&gt; 는 &lt;em&gt;applicative&lt;/em&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;final def sequence[G[_], B](implicit ev: A === G[B], G: Applicative[G]): G[F[B]] = {  
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 후 &lt;code&gt;sequence&lt;/code&gt; 를 호출하는 함수가 바로 위에서 보았던 &lt;code&gt;traverse&lt;/code&gt; 입니다. 그런데, 더 높은 추상에서 보면 방금 말했던 것과는 반대로, &lt;code&gt;sequence&lt;/code&gt; 가 &lt;em&gt;identity&lt;/em&gt; 함수를 &lt;code&gt;map&lt;/code&gt; 한 &lt;code&gt;traverse&lt;/code&gt; 입니다. &lt;strong&gt;scalaz&lt;/strong&gt; 에도 실제로 이렇게 구현되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/syntax/TraverseSyntax.scala#L25

  final def traverse[G[_], B](f: A =&amp;gt; G[B])(implicit G: Applicative[G]): G[F[B]] =
    G.traverse(self)(f)

  /** Traverse with the identity function */
  final def sequence[G[_], B](implicit ev: A === G[B], G: Applicative[G]): G[F[B]] = {
    val fgb: F[G[B]] = ev.subst[F](self)
    F.sequence(fgb)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위에서 &lt;code&gt;traverse&lt;/code&gt; 가 아니라 &lt;code&gt;traverseU&lt;/code&gt; 를 호출한 이유는 &lt;code&gt;OptionT&lt;/code&gt; 에 대한 타입추론을 이용하기 위해서 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;이제 덜 엄격한 &lt;code&gt;findLanguages&lt;/code&gt; 함수를 작성해보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def findLanguages2(users: List[User],  
                   lookups: List[LanguageLookup]): LangState[List[Option[Language]]] =
  lookups.traverseS { lookup =&amp;gt;
    findLanguage(users, lookup.userName, lookup.repoName, lookup.langName).run
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;traverseS&lt;/code&gt; 는 &lt;em&gt;state&lt;/em&gt; 버전의 &lt;code&gt;traverse&lt;/code&gt; 입니다. &lt;code&gt;map&lt;/code&gt; 을 적용한 &lt;code&gt;List[OptionT[LangState, Language]]&lt;/code&gt; 에 대해 &lt;code&gt;LangState[List[Option[Language]]&lt;/code&gt; 를 돌려줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;/** A version of `traverse` specialized for `State` */
final def traverseS[S, B](f: A =&amp;gt; State[S, B]): State[S, F[B]] = F.traverseS[S, A, B](self)(f)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;State[S, A]&lt;/code&gt; 에 대해서 &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;State[S, Option[List[A]]&lt;/code&gt; 를 얻고 싶다면 (&lt;strong&gt;all or nothing&lt;/strong&gt;) &lt;code&gt;traverseU&lt;/code&gt; 를&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State[S, List[Option[A]]&lt;/code&gt; 를 얻고 싶다면 &lt;code&gt;B = Option[A]&lt;/code&gt; 를 &lt;code&gt;List&lt;/code&gt; 로 감싸야 하므로 &lt;code&gt;State[S, F[B]]&lt;/code&gt; 를 돌려주는 위해 &lt;code&gt;traverseS&lt;/code&gt; 를 사용하면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="eithert"&gt;EitherT&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;EitherT&lt;/code&gt; 는 &lt;em&gt;scalaz&lt;/em&gt; 의 &lt;code&gt;Either&lt;/code&gt; 에 대한 모나드 트랜스포머입니다. 참고로, &lt;code&gt;scalaz.Either&lt;/code&gt; 은 &lt;code&gt;scala.Either&lt;/code&gt; 과 달리 &lt;em&gt;right-biased&lt;/em&gt; 입니다. &lt;code&gt;Option&lt;/code&gt; 처럼요.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;A \/ B&lt;/code&gt; is isomorphic to &lt;code&gt;scala.Either[A, B]&lt;/code&gt;, but &lt;code&gt;\/&lt;/code&gt; is right-biased, so methods such as &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; apply only in the context of the "right" case.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;scalaz.Either&lt;/code&gt; 에 대한 기본적인 설명은 &lt;a href="http://eed3si9n.com/learning-scalaz/Either.html"&gt;Learning Scalaz - Either&lt;/a&gt; 에서 보실 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;EitherT&lt;/code&gt; 를 위한 간단한 모델을 만들어 보겠습니다. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;쿼리를 파싱하고, 실행하는 과정에서 &lt;em&gt;상태&lt;/em&gt; 인 &lt;code&gt;QueryState&lt;/code&gt; 를 이용하고&lt;/li&gt;
&lt;li&gt;쿼리 파싱에 실패하면 수행하지 않고 종료하기 위해 &lt;code&gt;scalaz.Either&lt;/code&gt; 를 사용합니다 &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// ref - https://speakerdeck.com/mpilquist/scalaz-state-monad

import scalaz._, Scalaz._

trait Model  
trait Query  
trait QueryResult

object QueryService {  
  def runQuery(s: String, model: Model): String \/ QueryResult = for {
    query &amp;lt;- parseQuery(s)
    result &amp;lt;- performQuery(query, model)
  } yield result

  def parseQuery(s: String): String \/ Query = "TODO".left
  def performQuery(q: Query, m: Model): String \/ QueryResult = "TODO".left
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드에 &lt;em&gt;State&lt;/em&gt; 와 &lt;code&gt;EitherT&lt;/code&gt; 를 추가하면 &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;trait Model  
trait Query  
trait QueryResult  
trait Transaction 

object QueryService {  
  type TransactionState[A] = State[Transaction, A]
  type Transactional[A] = EitherT[TransactionState, String, A]

  def runQuery(s: String, model: Model): Transactional[QueryResult] = for {
    query &amp;lt;- EitherT(parseQuery(s).point[TransactionState])
    result &amp;lt;- EitherT(performQuery(query, model).point[TransactionState])
  } yield result

  def parseQuery(s: String): String \/ Query = ???
  def performQuery(q: Query, m: Model): String \/ QueryResult = ???
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기에 약간의 헬퍼 함수를 더하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def runQuery(s: String, model: Model): Transactional[QueryResult] = for {  
  query &amp;lt;- Transactional(parseQuery(s))
  result &amp;lt;- Transactional(performQuery(query, model))
} yield result

object Transactional {  
  import QueryService._
  def apply[A](e: String \/ A): Transactional[A] = liftE(e)
  def liftE[A](e: String \/ A): Transactional[A] = 
    EitherT(e.point[TransactionState])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;Transactional&lt;/code&gt; 이 이름 그대로의 역할을 할 수 있게 간단한 커넥션도 모델링 해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;trait Transaction {  
  def closeConnection: Unit
  def commit: Unit = closeConnection
  def rollback: Unit = closeConnection
}

object QueryService {  
  type TransactionState[A] = State[Transaction, A]
  type EitherStringT[F[_], A] = EitherT[F, String, A]
  type Transactional[A] = EitherStringT[TransactionState, A]

  def parseQuery(s: String): String \/ Query =
    if (s.startsWith("SELECT")) s"Invalid Query: $s".left[Query]
    else (new Query {}).right[String]

  def performQuery(q: Query, m: Model): String \/ QueryResult =
    new QueryResult {}.right

  def runQuery(s: String, model: Model): Transactional[QueryResult] = for {
    query &amp;lt;- Transactional(parseQuery(s))
    result &amp;lt;- Transactional(performQuery(query, model))
    _ &amp;lt;- (modify { t: Transaction =&amp;gt; t.commit; t }).liftM[EitherStringT]
  } yield result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;EitherStringT&lt;/code&gt; 타입을 새로 만든건, &lt;code&gt;liftM&lt;/code&gt; 을 사용하기 위해서입니다. 만약 &lt;code&gt;liftM[EitherT]&lt;/code&gt; 를 이용해 리프팅을 하면, 다음과 같은 예외가 발생합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;Error:(37, 59) scalaz.EitherT takes three type parameters, expected: two  
    _ &amp;lt;- (modify { t: Transaction =&amp;gt; t.commit; t }).liftM[EitherT]
                                                          ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;parseQuery&lt;/code&gt; 와 &lt;code&gt;performQuery&lt;/code&gt; 실패시 &lt;code&gt;rollback&lt;/code&gt; 을 호출하는것을 구현하고, &lt;code&gt;commit&lt;/code&gt; 을 헬퍼 함수로 변경하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def runQuery(s: String, model: Model): Transactional[QueryResult] = for {  
  query &amp;lt;- Transactional(parseQuery(s))
  result &amp;lt;- Transactional(performQuery(query, model))
  _ &amp;lt;- commit
} yield result

def commit: Transactional[Unit] =  
  (modify { t: Transaction =&amp;gt; t.commit; t }).liftM[EitherStringT]

object Transactional {  
  import QueryService._
  def apply[A](e: String \/ A): Transactional[A] = e match {
    case -\/(error) =&amp;gt;
      /* logging error and... */
      liftTS(State[Transaction, String \/ A] { t =&amp;gt; t.rollback; (t, e) })
    case \/-(a) =&amp;gt; liftE(e)
  }

  def liftE[A](e: String \/ A): Transactional[A] =
    EitherT(e.point[TransactionState])

  def liftTS[A](tse: TransactionState[String \/ A]): Transactional[A] =
    EitherT(tse)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 다음처럼 실패시 롤백이 호출되고 &lt;code&gt;for&lt;/code&gt; 자동으로 스탑되는것을 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;val t = new Transaction {}  
val model = new Model {}  
val result1 = runQuery("qqq", model).run.eval(t)  
println(result)

// output
parseQuery  
rollback  
-\/(Invalid Query: qqq)

val result2 = runQuery("SELECT", model).run.eval(t)  
println(result2)

// output
parseQuery  
performQuery  
\/-(QueryService$$anon$2@36804139)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 &lt;code&gt;Transaction&lt;/code&gt; 에 &lt;code&gt;committed&lt;/code&gt;, &lt;code&gt;rollbacked&lt;/code&gt; 등의 값을 추가하면 &lt;code&gt;eval&lt;/code&gt; 대신 &lt;code&gt;exec&lt;/code&gt; (&lt;code&gt;run&lt;/code&gt; 도 가능) 으로 최종 상태인 &lt;code&gt;Transaction&lt;/code&gt; 을 얻어 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/StateT.scala#L17

  /** An alias for `apply` */
  def run(initial: S1): F[(S2, A)] = apply(initial)

  /** Calls `run` using `Monoid[S].zero` as the initial state */
  def runZero[S &amp;lt;: S1](implicit S: Monoid[S]): F[(S2, A)] =
    run(S.zero)

  /** Run, discard the final state, and return the final value in the context of `F` */
  def eval(initial: S1)(implicit F: Functor[F]): F[A] =
    F.map(apply(initial))(_._2)

  /** Calls `eval` using `Monoid[S].zero` as the initial state */
  def evalZero[S &amp;lt;: S1](implicit F: Functor[F], S: Monoid[S]): F[A] =
    eval(S.zero)

  /** Run, discard the final value, and return the final state in the context of `F` */
  def exec(initial: S1)(implicit F: Functor[F]): F[S2] =
    F.map(apply(initial))(_._1)

  /** Calls `exec` using `Monoid[S].zero` as the initial state */
  def execZero[S &amp;lt;: S1](implicit F: Functor[F], S: Monoid[S]): F[S2] =
    exec(S.zero)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="statet"&gt;StateT&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-1-state/"&gt;Easy Scalaz 1 - State&lt;/a&gt; 에서 언급했던 것 처럼&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;type State[S, A] = StateT[Id, S, A]  
type Id[+X] = X

// 더 엄밀히는,

type StateT[F[_], S, A] = IndexedStateT[F, S, S, A]  
type IndexedState[-S1, S2, A] = IndexedStateT[Id, S1, S2, A]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;StateT&lt;/code&gt; 에다가 혼합할 모나드 &lt;code&gt;F&lt;/code&gt; 에 &lt;code&gt;Id&lt;/code&gt; 를 준것이 &lt;code&gt;State&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;여기에 함수 &lt;code&gt;replicateM&lt;/code&gt; 을 적용하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// https://speakerdeck.com/mpilquist/scalaz-state-monad
  "replicateM(10)" in {

    // def replicateM(n: Int): F[List[A]]
    val getAndIncrement: State[Int, Int] = State { s =&amp;gt; (s + 1, s) }
    getAndIncrement.replicateM(10).run(0) shouldBe (10, (0 until 10).toList)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;code&gt;State&lt;/code&gt; 를 &lt;code&gt;F[_]&lt;/code&gt; 라 보면 이걸 &lt;code&gt;F[List[_]]&lt;/code&gt; 로 만들어 주므로 여러개의 &lt;code&gt;flatMap&lt;/code&gt; 이 중첩된 형태가 됩니다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;replicateM(100000)&lt;/code&gt; 등의 코드는 &lt;em&gt;Stackoverflow&lt;/em&gt; 가 발생합니다.&lt;/p&gt;

&lt;p&gt;이 문제를 해결하기 위해 &lt;code&gt;Trampoline&lt;/code&gt; 을 이용할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Scalaz provides the &lt;code&gt;Free&lt;/code&gt; data type, which when used with Function0, trade heap for stack&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이럴때 &lt;code&gt;Trampoline&lt;/code&gt; 을 사용하면, &lt;em&gt;stackoverflow&lt;/em&gt; 를 피할 수 있습니다. (그만큼의 힙을 사용해서)&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// type Trampoline[+A] = Free[Function0, A]

"replicateM(1000)" in {

  import scalaz.Free._

  val getAndIncrement: State[Int, Int] = State { s =&amp;gt; (s + 1, s) }
  getAndIncrement.lift[Trampoline].replicateM(1000).run(0).run shouldBe (1000, (0 until 1000).toList)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Trampoline&lt;/code&gt; 은 후에 &lt;code&gt;Free&lt;/code&gt; 를 살펴보면서 다시 보겠습니다.&lt;/p&gt;

&lt;h3 id="references"&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://tonymorris.github.io/blog/posts/monads-do-not-compose"&gt;Tony Morris - Monad Do Not Compose&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://softwarecorner.wordpress.com/2013/12/06/scalaz-optiont-monad-transformer/"&gt;Scalaz OptionT Monad Transformer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/mpilquist/scalaz-state-monad"&gt;State Monad in Scalaz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/earldouglas/scala-scratchpad/tree/master/category-theory/monad-transformers"&gt;scala-scratchpad: Monad Transformer in Scala&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tpolecat.github.io/assets/scalaz.svg"&gt;Scalaz Typeclass Hierarchy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/26602611/how-to-understand-traverse-traverseu-and-traversem"&gt;Stackoverflow - traverseU, traverseM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cs.lth.se/edan40"&gt;Haskell Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.haskell.org/All_About_Monads#The_IO_monad"&gt;Haskell Wiki - All About Monads&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title>Easy Scalaz 1, State</title><description>&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""&gt;&lt;/p&gt;

&lt;h3 id="state"&gt;State&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;State&lt;/code&gt; 를 설명하는 수많은 문구들이 있지만, 타입만큼 간단한건 없습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;State[S, A] :: S =&amp;gt; (S, A)  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;A state transition, representing a &lt;strong&gt;function&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉 &lt;code&gt;S&lt;/code&gt; 를 받아 &lt;code&gt;(S, A)&lt;/code&gt; 를 돌려주는 함수를, 타입클래스 &lt;code&gt;State[S, A]&lt;/code&gt; 로 표현합니다. &lt;/p&gt;

&lt;p&gt;더 엄밀히는, (&lt;em&gt;scalaz&lt;/em&gt;  구현에서는) &lt;code&gt;type State[S, A] = StateT[Id, S, A]&lt;/code&gt;&lt;/p&gt;</description><link>http://1ambda.github.io/easy-scalaz-1-state/</link><guid isPermaLink="false">f9bd7b24-522b-412b-8c4f-cd741c93bc28</guid><category>scala</category><category>state monad</category><category>scalaz</category><dc:creator>1ambda</dc:creator><pubDate>Mon, 12 Oct 2015 14:14:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""&gt;&lt;/p&gt;

&lt;h3 id="state"&gt;State&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;State&lt;/code&gt; 를 설명하는 수많은 문구들이 있지만, 타입만큼 간단한건 없습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;State[S, A] :: S =&amp;gt; (S, A)  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;A state transition, representing a &lt;strong&gt;function&lt;/strong&gt; &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉 &lt;code&gt;S&lt;/code&gt; 를 받아 &lt;code&gt;(S, A)&lt;/code&gt; 를 돌려주는 함수를, 타입클래스 &lt;code&gt;State[S, A]&lt;/code&gt; 로 표현합니다. &lt;/p&gt;

&lt;p&gt;더 엄밀히는, (&lt;em&gt;scalaz&lt;/em&gt;  구현에서는) &lt;code&gt;type State[S, A] = StateT[Id, S, A] where Id[+X] = X&lt;/code&gt; 인데 이것은 나중에 &lt;code&gt;StateT&lt;/code&gt; 에서 다시 보겠습니다.&lt;/p&gt;

&lt;p&gt;우선 기억해둘 것은 &lt;code&gt;State&lt;/code&gt; 가 &lt;strong&gt;함수&lt;/strong&gt; 를 나타낸다는 사실입니다. 상태 &lt;code&gt;S&lt;/code&gt; 를 변경하면서 &lt;code&gt;A&lt;/code&gt; 를 만들어내는 함수를 말이지요. 즉, &lt;code&gt;State&lt;/code&gt; 는 더도 말고 덜도 말고, 상태를 조작하는 &lt;strong&gt;함수&lt;/strong&gt; 입니다. 여기에 모나드라고 하니, &lt;code&gt;flatMap&lt;/code&gt; 같은 몇몇 함수가 추가된 것 뿐이지요.&lt;/p&gt;

&lt;h3 id="statebasics"&gt;State Basics&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;State&lt;/code&gt; 코드를 들춰보면, 아래와 같이 생겼습니다. &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;object State extends StateFunctions {  
  def apply[S, A](f: S =&amp;gt; (S, A)): State[S, A] = new StateT[Id, S, A] {
    def apply(s: S) = f(s)
  }
}

trait StateFunctions extends IndexedStateFunctions {  
  def constantState[S, A](a: A, s: =&amp;gt; S): State[S, A] = State((_: S) =&amp;gt; (s, a))
  def state[S, A](a: A): State[S, A] = State((_ : S, a))
  def init[S]: State[S, S] = State(s =&amp;gt; (s, s))
  def get[S]: State[S, S] = init
  def gets[S, T](f: S =&amp;gt; T): State[S, T] = State(s =&amp;gt; (s, f(s)))
  def put[S](s: S): State[S, Unit] = State(_ =&amp;gt; (s, ()))
  def modify[S](f: S =&amp;gt; S): State[S, Unit] = State(s =&amp;gt; {
    val r = f(s);
    (r, ())
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;State.apply&lt;/code&gt; 에 상태 &lt;code&gt;S&lt;/code&gt; 를 조작하는 함수 &lt;code&gt;f&lt;/code&gt; 를 먹이면 &lt;code&gt;StateT&lt;/code&gt; 가 나오고&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StateT.apply&lt;/code&gt; 에 초기 상태 &lt;code&gt;S&lt;/code&gt; 를 먹이면 최종 결과물인 &lt;code&gt;(S, A)&lt;/code&gt; 가 나옵니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 코드를 조금 만 더 따라가다 보면 &lt;code&gt;apply&lt;/code&gt; 의 &lt;em&gt;alias&lt;/em&gt; 로 &lt;code&gt;run&lt;/code&gt; 이라는 함수가 제공되는걸 알 수 있습니다. &lt;a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/StateT.scala#L10"&gt;(Scalaz StateT.scala #L10)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;flatMap&lt;/code&gt; 으로 상태 조작함수 &lt;code&gt;f&lt;/code&gt; 여러개를 엮다가 하다가 마지막에 &lt;code&gt;run&lt;/code&gt; 으로 실행시킬것 같다는 느낌이 들죠? &lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;StateFunctions&lt;/code&gt; &lt;em&gt;trait&lt;/em&gt; 로 제공되는 함수를 사용해 볼까요? 그냥 써보면 재미 없으니, Github 에서 각 Repository 마다 존재하는 &lt;em&gt;star&lt;/em&gt; 를 가져오는 것을 간단히 모델링 해보겠습니다. 매번 네트워크 요청을 통해 가져오면 느리니까, &lt;code&gt;Map[String, Int]&lt;/code&gt; 타입의 캐시도 포함시켜서요.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;import scalaz._, Scalaz._ /* import all */

type Cache = Map[String, Int]

"create, run State" in {
  val s: State[Cache, Int] = State { c =&amp;gt; (c, c.getOrElse("1ambda/scala", 0))}
  val c: Cache = Map("1ambda/scala" -&amp;gt; 1)

  // def run(s: S): (S, A)
  val (c1, star1) = s.run(c)
  val (c2, star2) = s.run(Map.empty)

  (c1, star1) shouldBe (Map("1ambda/scala" -&amp;gt; 1), 1)
  (c2, star2) shouldBe (Map(), 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 작은 코드에서 우리가 다루는 상태는 &lt;code&gt;Cache&lt;/code&gt; 입니다. 아직은 &lt;code&gt;State { c =&amp;gt; ... }&lt;/code&gt; 에서 받은 &lt;code&gt;c: Cache&lt;/code&gt; 를 수정하지 않기 때문에 &lt;code&gt;run&lt;/code&gt; 에서 돌려주는 상태 (&lt;em&gt;State&lt;/em&gt;) 는 &lt;code&gt;run&lt;/code&gt; 에 넘긴 것과 동일합니다. 그런고로 &lt;code&gt;c == c1 == c2&lt;/code&gt; 입니다. &lt;/p&gt;

&lt;p&gt;이번엔 상태를 변경하는 함수를 만들어 보겠습니다. 캐시에서 데이터를 가져오면, 캐시를 그대로 돌려주고 미스가 발생하면 캐시에 레포지토리 URL 을 추가하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def getStargazer(url: String): State[Cache, Int] = State { c =&amp;gt;  
  c.get(url) match {
    case Some(count) =&amp;gt; (c, count)
    case None        =&amp;gt; (c.updated(url, 0), 0)
  }
}

"getStargazer" in {
  val c: Cache = Map("1ambda/scala" -&amp;gt; 1)

  val s1 = getStargazer("1ambda/haskell")
  val (c1, star) = s1.run(c)

  (c1, star) shouldBe (c.updated("1ambda/haskell", 0), 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;State&lt;/code&gt; 는 모나드기 때문에, &lt;code&gt;for&lt;/code&gt; 내에서 이용할 수 있습니다. 아래에서 더 자세히 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id="statemonadapplicativeandfunctor"&gt;State Monad, Applicative and Functor&lt;/h3&gt;

&lt;p&gt;모나드는 &lt;code&gt;return&lt;/code&gt; 과 &lt;code&gt;bind&lt;/code&gt; 를 가지고 특정한 규칙을 만족하는 타입 클래스를 말하는데요, &lt;em&gt;scala&lt;/em&gt; 에서는 &lt;code&gt;bind&lt;/code&gt; 는 &lt;code&gt;flatMap&lt;/code&gt; 이란 이름으로 제공되는 것 아시죠? &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;trait Monad[A] {  
  // sometimes called `unit`
  def return(a: A): M[A]
  def flatMap[B](f: A =&amp;gt; M[B]): M[B]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;scalaz&lt;/em&gt; 에선 &lt;code&gt;Monad&lt;/code&gt; 는 아래의 두 타입클래스를 상속받아 구현됩니다. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Applicative.point&lt;/code&gt; (= &lt;code&gt;return&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bind.bind&lt;/code&gt; (= &lt;code&gt;bind&lt;/code&gt;) &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;trait Bind[F[_]] extends Apply[F] { self =&amp;gt;  
  ...
  def bind[A, B](fa: F[A])(f: A =&amp;gt; F[B]): F[B]
  ...
}

trait Applicative[F[_]] extends Apply[F] { self =&amp;gt;  
  ...
  def point[A](a: =&amp;gt; A): F[A]
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;게다가 &lt;code&gt;Apply&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 를 상속받으므로 &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;trait Apply[F[_]] extends Functor[F] { self =&amp;gt;  
  def ap[A,B](fa: =&amp;gt; F[A])(f: =&amp;gt; F[A =&amp;gt; B]): F[B]
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;scalaz&lt;/em&gt; 에서 &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;Functor&lt;/code&gt; 이면서, &lt;code&gt;Applicative&lt;/code&gt; 이고, &lt;code&gt;Monad&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;아래는 &lt;a href="https://github.com/tpolecat/doobie"&gt;doobie&lt;/a&gt; 를 만든 &lt;a href="https://github.com/tpolecat"&gt;@tpolecat&lt;/a&gt; 의 블로그에서 가져온 &lt;em&gt;scalaz&lt;/em&gt; 타입 클래스 계층인데, 이 그림을 보면 왜 그런지 알 수 있습니다. (&lt;a href="http://tpolecat.github.io/assets/scalaz.svg"&gt;http://tpolecat.github.io/assets/scalaz.svg&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/scalaz.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;State&lt;/code&gt; 가 모나드라는 사실을 알았으니, 위에서 작성했던 &lt;code&gt;getStargazer&lt;/code&gt; 함수를 다시 작성해보겠습니다. &lt;em&gt;for comprehension&lt;/em&gt; 을 사용할건데요, &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;먼저 &lt;code&gt;State[Cache, Int]&lt;/code&gt; 의 상태인 &lt;code&gt;Cache&lt;/code&gt; 를 얻어와야 하므로 &lt;code&gt;get&lt;/code&gt; 을 이용하고&lt;/li&gt;
&lt;li&gt;상태를 변경해야 하므로 &lt;code&gt;modify&lt;/code&gt; 를 호출하겠습니다. &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// State helper functions defined in `StateFunctions` trait
def state[S, A](a: A): State[S, A] = State((_ : S, a))  
def init[S]: State[S, S] = State(s =&amp;gt; (s, s)) /* 상태 S 를 아웃풋 A 위치로 꺼냄 */  
def get[S]: State[S, S] = init  
def gets[S, T](f: S =&amp;gt; T): State[S, T] = State(s =&amp;gt; (s, f(s)))  
def put[S](s: S): State[S, Unit] = State(_ =&amp;gt; (s, ()))  
def modify[S](f: S =&amp;gt; S): State[S, Unit] = State(s =&amp;gt; {  
  /* 상태 S 를 변경하는 함수를 받아, 적용하고 A 위치에 `()` 를 돌려줌 */
  val r = f(s);
  (r, ())
})

def getStargazer(url: String): State[Cache, Int] = State { c =&amp;gt;  
  c.get(url) match {
    case Some(count) =&amp;gt; (c, count)
    case None        =&amp;gt; (c.updated(url, 0), 0)
  }
}

def getStargazerWithFor(url: String): State[Cache, Int] =  
  for {
    c &amp;lt;- State.get[Cache]
    optCount = c.get(url)
    _ &amp;lt;- modify { c: Cache =&amp;gt;
      // same as `if (optCount.isDefined) c else c.updated(url, 0)`
      optCount match {
        case Some(count) =&amp;gt; c
        case None        =&amp;gt; c.updated(url, 0)
      }
    }
  } yield optCount.getOrElse(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="whentousestate"&gt;When to use State&lt;/h3&gt;

&lt;p&gt;그러면, 언제 &lt;code&gt;State&lt;/code&gt; 가 필요할까요? 하나의 &lt;strong&gt;상태&lt;/strong&gt; (&lt;em&gt;State&lt;/em&gt;) 를 지속적으로 변경, 공유하면서 연산을 실행할 때 사용할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Building computations from sequences of operations that require a shared state.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를 들어 HTTP 요청과 응답, 트랜잭션 등을 &lt;code&gt;State&lt;/code&gt; 로 다루면서 연산을 조합해서 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HttpRequest, HttpResponse, HttpSession&lt;/li&gt;
&lt;li&gt;Database Transaction&lt;/li&gt;
&lt;li&gt;Random Number Generator&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="githubserviceexample"&gt;Github Service Example&lt;/h3&gt;

&lt;p&gt;그러면 위에서 보았던 &lt;code&gt;Cache&lt;/code&gt; 에 약간의 기능을 추가해 볼까요? 캐시 히트, 미스도 저장하고 캐시 히트는 최대 5분까지만 인정하기로 하지요. 오래된 캐시를 삭제하는 기능을 빼고 만들어 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;type URL = String  
type StarCount = Int

case class Timestamped(count: StarCount, time: DateTime)

case class Cache(hits: Int, misses: Int, map: Map[URL, Timestamped]) {  
  def get(url: URL): Option[Timestamped] = map.get(url)
  def update(url: URL, timestamp: Timestamped): Cache = {
    val m = map + (url -&amp;gt; timestamp)
    this.copy(map = m)
  }
}

object Cache {  
  def empty = Cache(0, 0, Map())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 &lt;code&gt;State&lt;/code&gt; 가 없다면, 우리가 다루는 상태인 &lt;code&gt;Cache&lt;/code&gt; 를 명시적으로 넘겨주고, 리턴받기 위해 이렇게 코드를 작성해야 할테지요. 여기서 &lt;code&gt;c1&lt;/code&gt; 대신 &lt;code&gt;c&lt;/code&gt; 를 쓰는 오타라도 발생한다면..&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def stargazerCount(url: URL, c: Cache): (Cache, StarCount) = {  
  val (c1, optCount) = checkCache(url, c)

  optCount match {
    case Some(count) =&amp;gt; (c1, count)
    case None =&amp;gt; retrieve(url, c1)
  }
}

def checkCache(url: URL, c: Cache): (Cache, Option[StarCount]) =  
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&amp;gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&amp;gt;
      (c.copy(misses = c.misses + 1), None)
  }

def retrieve(url: URL, c: Cache): (Cache, StarCount) = {  
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def stale(then: DateTime): Boolean = DateTime.now &amp;gt; then + 5.minutes  
def getStarCountFromWebService(url: URL): StarCount = ...  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;여기에 &lt;code&gt;State&lt;/code&gt; 를 하나씩 적용해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def stargazerCount(url: URL, c: Cache): (Cache, StarCount) = {  
  val (c1, optCount) = checkCache(url, c)

  optCount match {
    case Some(count) =&amp;gt; (c1, count)
    case None =&amp;gt; retrieve(url, c1)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;먼저 &lt;code&gt;State&lt;/code&gt; 타입을 적용하고, 그 후에 &lt;code&gt;for&lt;/code&gt; 문을 적용한 뒤에, &lt;code&gt;State.state&lt;/code&gt; 를 이용해서 조금 더 깔끔하게 바꾸면&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;// applying State 
def stargazerCount(url: URL): State[Cache, StarCount] =  
  checkCache(url) flatMap { optCount =&amp;gt;
    optCount match {
      case Some(count) =&amp;gt; State { c =&amp;gt; (c, count) }
      case None        =&amp;gt; retrieve(url)
    }
  }

// use for-comprehension
def stargazerCount2(url: URL): State[Cache, StarCount] = for {  
  optCount &amp;lt;- checkCache(url)
  count &amp;lt;- optCount match {
    case Some(count) =&amp;gt; State[Cache, StarCount] { c =&amp;gt; (c, count) }
    case None        =&amp;gt; retrieve(url)
  }
} yield count

// State.state
def stargazerCount(url: URL): State[Cache, StarCount] = for {  
  optCount &amp;lt;- checkCache(url)
  count &amp;lt;- optCount
    .map(State.state[Cache, StarCount])
    .getOrElse(retrieve(url))
} yield count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;checkCache&lt;/code&gt; 함수에도 적용해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def checkCacheOrigin(url: URL, c: Cache): (Cache, Option[StarCount]) =  
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&amp;gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&amp;gt;
      (c.copy(misses = c.misses + 1), None)
  }

def checkCache1(url: URL): State[Cache, Option[StarCount]] = State { c =&amp;gt;  
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&amp;gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&amp;gt;
      (c.copy(misses = c.misses + 1), None)
  }
}

/**
 *  Has potential bug.
 *  Always use `State.gets` and `State.modify`.
 */
def checkCache2(url: URL): State[Cache, Option[StarCount]] = for {  
  c &amp;lt;- State.get[Cache]
  optCount &amp;lt;- State.state {
    c.get(url) collect { case Timestamped(count, time) if !stale(time) =&amp;gt; count }
  }
  _ &amp;lt;- State.put(optCount ? c.copy(hits = c.hits + 1) | c.copy(misses = c.misses + 1))
} yield optCount

def checkCache(url: URL): State[Cache, Option[StarCount]] = for {  
  optCount &amp;lt;- State.gets { c: Cache =&amp;gt;
    c.get(url) collect { case Timestamped(count, time) if !stale(time) =&amp;gt; count }
  }
  _ &amp;lt;- State.modify { c: Cache =&amp;gt;
    optCount ? c.copy(hits = c.hits + 1) | c.copy(misses = c.misses + 1)
  }
} yield optCount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;checkCache2&lt;/code&gt; 는 &lt;code&gt;State.get&lt;/code&gt; &lt;code&gt;State.put&lt;/code&gt; 때문에 버그가 발생할 수 있습니다. &lt;code&gt;get&lt;/code&gt; 으로 꺼낸 뒤에 &lt;code&gt;put&lt;/code&gt; 으로 넣으면, 이전에 어떤 상태가 있었든지, 덮어 씌우기 때문에 주의가 필요합니다. 일반적으로는 &lt;code&gt;put&lt;/code&gt; 대신 &lt;code&gt;modify&lt;/code&gt; 를 이용합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def init[S]: State[S, S] = State(s =&amp;gt; (s, s))  
def get[S]: State[S, S] = init  
def put[S](s: S): State[S, Unit] = State(_ =&amp;gt; (s, ()))

def gets[S, T](f: S =&amp;gt; T): State[S, T] = State(s =&amp;gt; (s, f(s)))  
def modify[S](f: S =&amp;gt; S): State[S, Unit] = State(s =&amp;gt; {  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;마지막으로 &lt;code&gt;retrieve&lt;/code&gt; 함수도 수정해볼까요&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-scala"&gt;def retrieveOrigin(url: URL, c: Cache): (Cache, StarCount) = {  
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def retrieve1(url: URL): State[Cache, StarCount] = State { c =&amp;gt;  
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def retrieve(url: URL): State[Cache, StarCount] = for {  
  count &amp;lt;- State.state { getStarCountFromWebService(url) }
  timestamp = Timestamped(count, DateTime.now)
  _ &amp;lt;- State.modify[Cache] { _.update(url, timestamp) }
} yield count
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="references"&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://speakerdeck.com/mpilquist/scalaz-state-monad"&gt;State Monad in Scalaz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tpolecat.github.io/assets/scalaz.svg"&gt;Scalaz Typeclass Hierarchy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cs.lth.se/edan40"&gt;Haskell Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/fpinscala/fpinscala/wiki/Chapter-11:-Monads"&gt;fpinscala - Monad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.haskell.org/All_About_Monads#The_IO_monad"&gt;Haskell Monad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title>Reactive Message Patterns w/ Actor Model, Chapter 1</title><description>&lt;p&gt;&lt;img src="http://berb.github.io/diploma-thesis/original/resources/actors.svg" alt=""&gt;&lt;/p&gt;

&lt;h2 id="whyenterprisesoftwaredevelopmentishard"&gt;Why Enterprise Software Development Is Hard&lt;/h2&gt;

&lt;p&gt;엔터프라이즈 소프트웨어를 구현할 때 마주치는 문제점은, 고려해야할 것이 너무나 많다는 점입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Physical Tiers&lt;/li&gt;
&lt;li&gt;Application Servers&lt;/li&gt;
&lt;li&gt;Software layers&lt;/li&gt;
&lt;li&gt;Frameworks and Patterns&lt;/li&gt;
&lt;li&gt;Toolkits&lt;/li&gt;
&lt;li&gt;Databases&lt;/li&gt;
&lt;li&gt;Messaging Systems&lt;/li&gt;
&lt;li&gt;Third-Party Applications&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/reactive-message-patterns/complexity_stack.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;이런 요소들로 구성된 &lt;strong&gt;complexity stack&lt;/strong&gt; 의 내부를 잘 살펴보면, 결국 관심사는 &lt;strong&gt;command&lt;/strong&gt; 에 의해 생성된 &lt;strong&gt;domain event&lt;/strong&gt; 를&lt;/p&gt;</description><link>http://1ambda.github.io/reactive-message-patterns-w-actor-model-chapter-1/</link><guid isPermaLink="false">5c6d3ec5-2b23-462a-94da-f5df4ae0bdda</guid><category>scala</category><category>actor</category><category>akka</category><dc:creator>1ambda</dc:creator><pubDate>Sun, 20 Sep 2015 16:33:22 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="http://berb.github.io/diploma-thesis/original/resources/actors.svg" alt=""&gt;&lt;/p&gt;

&lt;h2 id="whyenterprisesoftwaredevelopmentishard"&gt;Why Enterprise Software Development Is Hard&lt;/h2&gt;

&lt;p&gt;엔터프라이즈 소프트웨어를 구현할 때 마주치는 문제점은, 고려해야할 것이 너무나 많다는 점입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Physical Tiers&lt;/li&gt;
&lt;li&gt;Application Servers&lt;/li&gt;
&lt;li&gt;Software layers&lt;/li&gt;
&lt;li&gt;Frameworks and Patterns&lt;/li&gt;
&lt;li&gt;Toolkits&lt;/li&gt;
&lt;li&gt;Databases&lt;/li&gt;
&lt;li&gt;Messaging Systems&lt;/li&gt;
&lt;li&gt;Third-Party Applications&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/reactive-message-patterns/complexity_stack.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;이런 요소들로 구성된 &lt;strong&gt;complexity stack&lt;/strong&gt; 의 내부를 잘 살펴보면, 결국 관심사는 &lt;strong&gt;command&lt;/strong&gt; 에 의해 생성된 &lt;strong&gt;domain event&lt;/strong&gt; 를 저장하는 일임을 알 수 있습니다. &lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/reactive-message-patterns/simplicity_stack.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Actor Model&lt;/em&gt; 은 여기에서 출발합니다. 불필요한 컴포넌트를 제외하고, &lt;strong&gt;command&lt;/strong&gt; 와 &lt;strong&gt;event&lt;/strong&gt; 에만 집중할 수 있도록 추상화를 제공합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What incoming messages (commands and/or events) do I accept?&lt;/li&gt;
&lt;li&gt;What outgoing messages (commands and/or events) do I emit?&lt;/li&gt;
&lt;li&gt;How can my state be mutated in reaction to incoming messages?&lt;/li&gt;
&lt;li&gt;What is my supervision strategy for supervised actors?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id="originofactors"&gt;Origin Of Actors&lt;/h2&gt;

&lt;p&gt;Actor Model 은 최근에 새롭게 만들어진 개념이 아니라, 1973년(&lt;em&gt;Dr. Carl Hewitt&lt;/em&gt;) 부터 있었던 개념입니다. 다만 당시에는 컴퓨팅 파워가 부족했기 때문에 활용되지 않았을 뿐입니다. Actor Model 이 처음 만들어졌을 당시에는 CPU 클럭은 1MHz 남짓이었고 멀티코어 프로세서는 존재하지도 않았습니다. &lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id="understandingactors"&gt;Understanding Actors&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Actor&lt;/em&gt; 는 하나의 컴퓨팅 객체로서 메시지를 받아 다음의 일들을 수행할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Send a finite number of messages to other actors&lt;/li&gt;
&lt;li&gt;Create a finite number of new actors&lt;/li&gt;
&lt;li&gt;Designate the behavior to be used for the next messages it receives&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Actor System 에서는 모든것이 Actor 입니다. 따라서 &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt; 처럼 일종의 &lt;em&gt;primitive type&lt;/em&gt; 으로 생각하면 더 이해가 쉽습니다.&lt;/p&gt;

&lt;p&gt;Actor System 과 Actor 는 다음의 특성을 가지고 있습니다. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Communication via direct asynchronous message&lt;/li&gt;
&lt;li&gt;State machines (FSM)&lt;/li&gt;
&lt;li&gt;Share nothing&lt;/li&gt;
&lt;li&gt;Lock-Free Concurrency&lt;/li&gt;
&lt;li&gt;Parallelism&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Akka&lt;/strong&gt; 에서 추가적으로 제공하는 특성들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Location Transparency&lt;/li&gt;
&lt;li&gt;Supervision&lt;/li&gt;
&lt;li&gt;Future / Promises&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id="concurrencyandparallelism"&gt;Concurrency and Parallelism&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Concurrency describes multiple computation occurring simultaneously. Parallelism is concurrency but applied to achieving a single goal. Parallelism is achieved by dividing a single complex process into smaller tasks and executing them concurrently. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Amdahl%27s_law?oldformat=true"&gt;Amdahl’s law&lt;/a&gt; 에 의하면 &lt;strong&gt;병렬화해서 얻을 수 있는 최대 성능은, 병렬화 할 수 없는 부분에 의해서 제한됩니다.&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;따라서 시스템을 얼마나 병렬화 할 수 있도록 디자인하는가가 성능에 영향을 주게 됩니다. 이는 일반적으로 어려운 일이지만, Actor System 을 이용하면 atomic 연산 unit 인 Actor 를 기반으로 디자인할 수 있으므로 부가적인 계층(Tier) 보다는 로직(이 메시지를 받았을 때 어떤 일을 해야하는가)에 더 집중하게 되어 쉬운 일이 됩니다. &lt;/p&gt;

&lt;p&gt;Akka 프로젝트 설명에서도 볼 수 있듯이, 분산 병렬 시스템을 만드는 것은 어려운 일이지만 대부분의 경우는 잘못된 추상(Abstaction), 도구(Tool) 을 이용하기 때문입니다. Actor Model 은 프로그래머가 더 쉬운 방법으로 분산 병렬 시스템을 디자인할 수 있도록 돕습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;We believe that writing correct concurrent &amp;amp; distributed, resilient and elastic applications is too hard. Most of the time it's because we are using the wrong tools and the wrong level of abstraction.&lt;/p&gt;
  
  &lt;p&gt;Akka is here to change that.&lt;/p&gt;
  
  &lt;p&gt;Using the Actor Model we raise the abstraction level and provide a better platform to build correct concurrent and scalable applications. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id="nondeterminism"&gt;Non-determinism&lt;/h2&gt;

&lt;p&gt;Actor Model 이 비결정적이라는 비판들이 있습니다. 그러나 실제로 내부를 잘 살펴보면 Actor 그 자체는 &lt;em&gt;deterministic atomic unit&lt;/em&gt; 입니다. 따라서 시스템을 Reactive 하게 구성하는 과정에서 프로그래머가 다루어야 하는 &lt;em&gt;non-determinism&lt;/em&gt; 을 Actor Model 을 이용하면 더 간단하게 다룰 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id="references"&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Title Image - &lt;a href="http://berb.github.io/"&gt;http://berb.github.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Book - &lt;a href="http://www.amazon.com/Reactive-Messaging-Patterns-Actor-Model/dp/0133846830/ref=sr_1_2?ie=UTF8&amp;amp;qid=1442747296&amp;amp;sr=8-2&amp;amp;keywords=akka+in+action"&gt;Reactive Message Patterns with the Actor Model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title>Angular, Providers</title><description>&lt;p&gt;&lt;img src="https://ga-core.s3.amazonaws.com/production/uploads/program/default_image/1444/Angularjs-Bootcamp-LONDON.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;자그마한 프로젝트를 엇그제 시작했습니다. 오늘 해야 할 일은 Linkedin, Github API 를 붙이는 일인데, 그 전에 Angular 를 좀 보고 넘어가겠습니다. 아래는 &lt;a href="https://github.com/DaftMonk/generator-angular-fullstack"&gt;angular-fullstack&lt;/a&gt; 으로 만들면 생성되는 템플릿 코드인데, 어디서 부터 시작해야할지 감이 안잡히네요!&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;angular.module('app', [  
  'ngCookies',
  'ngResource',
  'ngSanitize',
  'ui.router',
  'ui.bootstrap'
])
  .config(function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider) {
    $urlRouterProvider&lt;/code&gt;&lt;/pre&gt;</description><link>http://1ambda.github.io/angular-providers/</link><guid isPermaLink="false">fac918aa-4bc5-464c-ba73-2d2fad7e6a9d</guid><category>Angular</category><category>Trend Factory</category><category>factory</category><category>service</category><category>provider</category><category>injector</category><dc:creator>1ambda</dc:creator><pubDate>Sat, 14 Mar 2015 16:42:33 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="https://ga-core.s3.amazonaws.com/production/uploads/program/default_image/1444/Angularjs-Bootcamp-LONDON.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;자그마한 프로젝트를 엇그제 시작했습니다. 오늘 해야 할 일은 Linkedin, Github API 를 붙이는 일인데, 그 전에 Angular 를 좀 보고 넘어가겠습니다. 아래는 &lt;a href="https://github.com/DaftMonk/generator-angular-fullstack"&gt;angular-fullstack&lt;/a&gt; 으로 만들면 생성되는 템플릿 코드인데, 어디서 부터 시작해야할지 감이 안잡히네요!&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;angular.module('app', [  
  'ngCookies',
  'ngResource',
  'ngSanitize',
  'ui.router',
  'ui.bootstrap'
])
  .config(function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider) {
    $urlRouterProvider
      .otherwise('/');

    $locationProvider.html5Mode(true);
    $httpProvider.interceptors.push('authInterceptor');
  })

  .factory('authInterceptor', function ($rootScope, $q, $cookieStore, $location) {
    return {
      // Add authorization token to headers
      request: function (config) {
        config.headers = config.headers || {};
        if ($cookieStore.get('token')) {
          config.headers.Authorization = 'Bearer ' + $cookieStore.get('token');
        }
        return config;
      },

      // Intercept 401s and redirect you to login
      responseError: function(response) {
        if(response.status === 401) {
          $location.path('/login');
          // remove any stale tokens
          $cookieStore.remove('token');
          return $q.reject(response);
        }
        else {
          return $q.reject(response);
        }
      }
    };
  })

  .run(function ($rootScope, $location, Auth) {
    // Redirect to login if route requires auth and you're not logged in
    $rootScope.$on('$stateChangeStart', function (event, next) {
      Auth.isLoggedInAsync(function(loggedIn) {
        if (next.authenticate &amp;amp;&amp;amp; !loggedIn) {
          $location.path('/login');
        }
      });
    });
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="configrun"&gt;config, run&lt;/h3&gt;

&lt;p&gt;원문은 &lt;a href="https://docs.angularjs.org/guide/module#module-loading-dependencies"&gt;Angular Document: Module Loading &amp;amp; Dependencies&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;configuration&lt;/em&gt; 과 &lt;em&gt;run block&lt;/em&gt; 은 &lt;em&gt;bootstrap&lt;/em&gt; 과정에서 실행되는데&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;configuration block&lt;/em&gt; 에서는 &lt;strong&gt;provider&lt;/strong&gt;, &lt;strong&gt;constant&lt;/strong&gt; 만 &lt;em&gt;injected&lt;/em&gt; 될 수 있고&lt;/li&gt;
&lt;li&gt;&lt;em&gt;run block&lt;/em&gt; 은 &lt;em&gt;injector&lt;/em&gt; 가 생성되고, 어플리케이션을 구동하기 위해 사용된 후에 실행됩니다. &lt;strong&gt;instance&lt;/strong&gt; 와 &lt;strong&gt;constant&lt;/strong&gt; 만 &lt;em&gt;injected&lt;/em&gt; 될 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;angular.module('myModule', []).

  config(function(injectable) { // provider-injector
    // you can only inject Providers (not instances)
    // into config block
  }).

  run(function(injectable) {    // instance-injector
    // you can only inject instances (not Providers)
    // into run blocks
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래는 동일한 코드를 다른 메소드를 이용해 작성한 애플리케이션 초기화 코드입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;angular.module('myModule', []).  
  value('a', 123).
  factory('a', function() { return 123; }).
  directive('directiveName', ...).
  filter('filterName', ...);

// is same as

angular.module('myModule', []).  
  config(function($provide, $compileProvider, $filterProvider) {
    $provide.value('a', 123);
    $provide.factory('a', function() { retrun 123; });
    $compileProvider.directive('directiveName', ...);
    $filterProvider.register('filterName', ...);
  });  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;배운것보다 모르는게 더 많이 생겼습니다. &lt;code&gt;Provider&lt;/code&gt;, &lt;code&gt;$provide&lt;/code&gt;, &lt;em&gt;injectable&lt;/em&gt;  이 뭘까요?&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="providers"&gt;Providers&lt;/h3&gt;

&lt;p&gt;원문은 &lt;a href="https://docs.angularjs.org/guide/providers"&gt;Angular Document: Providers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;angular app&lt;/em&gt; 에서 쓰이는 오브젝트들은 &lt;a href="https://docs.angularjs.org/api/auto/service/$injector"&gt;&lt;em&gt;intector service&lt;/em&gt;&lt;/a&gt; 에 의해서 인스턴스화(&lt;em&gt;instantiated&lt;/em&gt;) 됩니다. &lt;em&gt;injector&lt;/em&gt; 는 두 타입의 오브젝트를 만드는데, &lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Services:&lt;/strong&gt; are objects whose API is defined by the developer writing the service &lt;br&gt;
(2) &lt;strong&gt;Specialized objects:&lt;/strong&gt; conform to a specific angular framework API. These objects are one of controllers, directives, filters or animations&lt;/p&gt;

&lt;p&gt;&lt;em&gt;injector&lt;/em&gt; 가 이러한 서비스를 만들기 위해서는 &lt;em&gt;recipe&lt;/em&gt; 를 알려줘야 하는데, 크게 5가지 &lt;em&gt;recipe&lt;/em&gt; 가 있습니다. &lt;/p&gt;

&lt;p&gt;가장 유명한건 &lt;strong&gt;Provider&lt;/strong&gt; 입니다. 그 외에 &lt;em&gt;Provider&lt;/em&gt; 를 이용해 만든 &lt;strong&gt;Value&lt;/strong&gt;, &lt;strong&gt;Factory&lt;/strong&gt;, &lt;strong&gt;Service&lt;/strong&gt;, &lt;strong&gt;Constant&lt;/strong&gt; 가 있습니다. &lt;/p&gt;

&lt;p&gt;&lt;em&gt;angular module&lt;/em&gt; 은 하나 이상의 &lt;em&gt;Provider&lt;/em&gt; 를 포함할 수 있습니다. 애플리케이션이 시작될때 &lt;em&gt;Angular&lt;/em&gt; 는 &lt;em&gt;injector&lt;/em&gt; 의 새로운 인스턴스를 만들고, &lt;code&gt;ng&lt;/code&gt; 모듈, 애플리케이션 모듈, 그리고 그 &lt;em&gt;dependencies&lt;/em&gt; 에 있는 모든 &lt;em&gt;recipe&lt;/em&gt; 를 하나의 레지스트리에 등록합니다. 그리고 이후에 필요할때마다 &lt;em&gt;injector&lt;/em&gt; 는 이 레지스트리에 새로운 인스턴스를 만들어야 할지, 아니면 존재하는 것을 사용할지 질의합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Value recipe&lt;/em&gt; 를 이용한 간단한 &lt;a href="https://docs.angularjs.org/guide/providers#value-recipe"&gt;예제&lt;/a&gt; 를 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;var myApp = angular.module('myApp', []).  
              value('clientId', 'a12345654321x');

myApp.controller('myController', ['clientId',  
                                  function(clientId) {
  this.clientId = clientId;
}]);                              
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;myApp&lt;/code&gt; 모듈에 정의되어 있는 &lt;code&gt;clientId&lt;/code&gt; &lt;em&gt;Value recipe&lt;/em&gt; 를 등록하고 컨트롤러에서 사용했습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="factory"&gt;Factory&lt;/h3&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;myApp.factory('apiToken', ['clientId', function apiTokenFactory(clientId) {

  var encrypt = function(data1, data2) {
  // encryption algorithm:
    return (data + ':' + data2).toUpperCase();
  };

  var secret = window.localStorage.getItem('myApp.secret');
  var apiToken = encrypt(clientId, secret);

  return apiToken;
}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Factory recipe&lt;/em&gt; 를 이용해서 &lt;code&gt;apiToken&lt;/code&gt; 서비스를 정의했습니다. 이 서비스는 &lt;em&gt;Value recipe&lt;/em&gt; 를 이용해 만든 &lt;code&gt;clientId&lt;/code&gt; 서비스에 의존합니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="service"&gt;Service&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;apiToken&lt;/code&gt; 서비스를 이용하는 다른 서비스를 &lt;em&gt;Service recipe&lt;/em&gt; 를 이용해서 만들어 볼텐데, 동시에 &lt;em&gt;Service recipe&lt;/em&gt; 가 어떤 역할을 하는지 비교하기 위해 &lt;em&gt;Factory recipe&lt;/em&gt; 로도 만들어 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;function UnicornLauncher(apiToken) {

  this.launchedCount = 0;
  this.launch = function() {
    // Make a request to the remote API and include the apiToken
    ...
    this.launchedCount++;
  }
}

myApp.factory('unicornLauncher', ["apiToken", function(apiToken) {  
  return new UnicornLauncher(apiToken);
}]);

// is same as
myApp.service('unicornLauncher', ["apiToken", UnicornLauncher]);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Factory recipe&lt;/em&gt; 로도 만들 수 있지만, 일반적으로 &lt;em&gt;Service recipe&lt;/em&gt; 는 &lt;code&gt;new&lt;/code&gt; 와 함께 호출되는 서비스를 정의하기 위해 사용합니다. &lt;a href="http://stackoverflow.com/questions/14324451/angular-service-vs-angular-factory"&gt;Stackoverflow: Factory vs Service&lt;/a&gt; 에서도 그 답변을 찾을 수 있습니다.&lt;/p&gt;

&lt;p&gt;예를 들어서 위에서 우리가 정의한 &lt;code&gt;unicornLauncher&lt;/code&gt; 서비스는, &lt;code&gt;UnicornLauncher&lt;/code&gt; 생성자를 &lt;code&gt;new&lt;/code&gt; 로 호출됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;아래는 대략적인 두 함수의 구성입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;function factory(name, factoryFn) {  
    return provider(name, { $get: factoryFn }); 
}

function service(name, constructor) {  
    return factory(name, ['$injector', function($injector) {
      return $injector.instantiate(constructor);
    }]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$injector&lt;/code&gt; 는 &lt;em&gt;provider&lt;/em&gt; 에 의해 정의된 인스턴스를 &lt;em&gt;angular app&lt;/em&gt; 내에서 조회하고, 생성할 수 있습니다. 이외에도 메소드를 호출하거나, 모듈을 로드할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="provider"&gt;Provider&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Provider recipe&lt;/em&gt; 는 &lt;em&gt;Service&lt;/em&gt; 나 &lt;em&gt;Factory&lt;/em&gt; 등 다른 &lt;em&gt;recipe&lt;/em&gt; 를 구성하는 코어 컴포넌트입니다. 문법적으로는 &lt;code&gt;$get&lt;/code&gt; 을 구현한 커스텀 타입입니다. 이 &lt;code&gt;$get&lt;/code&gt; 메소드는 &lt;em&gt;Factory recipe&lt;/em&gt; 에서 사용했던 것과 같은 &lt;em&gt;factory function&lt;/em&gt; 입니다. &lt;/p&gt;

&lt;p&gt;다시 말해서, &lt;em&gt;Factory recipe&lt;/em&gt; 만들때 하는 일은 &lt;em&gt;empty Provider&lt;/em&gt; 에 &lt;code&gt;$get&lt;/code&gt; 을 이용해 정의된 &lt;em&gt;factory function&lt;/em&gt; 을 가져오는 일입니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Provider recipe&lt;/em&gt;  는 반드시 애플리케이션이 시작 되기 전에 생성되야 하는 &lt;em&gt;application-wide configuration&lt;/em&gt; 을 위한 &lt;em&gt;API&lt;/em&gt; 를 정의할때만 사용해야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;myApp.provider('unicornLauncher', funtion UnicornLauncherProvider() {  
  var useTinfoilShielding = false;

  this.useTinfoilShielding = function(vaue) {
    useTinfoilShielding = !!value;
  };

  this.$get = ["apiToken", function unicornLauncherFactory(apiToken) {
    return new UnicornLauncher(apiToken, useTinfoilShielding);
  }];
});

myApp.config(["unicornLauncherProvider", function(unicornLauncherProvider) {  
  unicornLauncherProvider.useTinfoilShielding(true);
}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음에 &lt;em&gt;configuration block&lt;/em&gt; &lt;code&gt;config&lt;/code&gt; 를 언급하면서 &lt;strong&gt;provider&lt;/strong&gt;, &lt;strong&gt;constant&lt;/strong&gt; 만 &lt;em&gt;injected&lt;/em&gt; 될 수 있다고 말했었는데, 이런 이유에서입니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;regular instance injector&lt;/em&gt; 와는 달리 &lt;em&gt;provider injector&lt;/em&gt; 에 의해 실행되는 이런 &lt;em&gt;injection&lt;/em&gt; 을 통해 모든 &lt;em&gt;provider&lt;/em&gt; 가 인스턴스화 (&lt;em&gt;instantiated&lt;/em&gt;) 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;angular&lt;/em&gt; 애플리케이션이 부트스트랩되는 동안, &lt;em&gt;provider&lt;/em&gt; 가 구성되고, 생성되는 동안에는 &lt;em&gt;service&lt;/em&gt; 에 접근할 수 없습니다. 이는 &lt;em&gt;service&lt;/em&gt; 가 아직 생성되지 않았기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;configuration phase&lt;/em&gt; 가 지난 후에야 &lt;em&gt;services&lt;/em&gt; 가 생성되고, 이 단계를 &lt;em&gt;run phase&lt;/em&gt; 라 부릅니다. 이 때문에 &lt;em&gt;run block&lt;/em&gt; 에서 &lt;strong&gt;instance&lt;/strong&gt; 와 &lt;strong&gt;constant&lt;/strong&gt; 만 &lt;em&gt;injected&lt;/em&gt; 될 수 있다고 위에서 언급한 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="specialpurposeobjects"&gt;Special Purpose Objects&lt;/h3&gt;

&lt;p&gt;앞서 &lt;em&gt;Angular&lt;/em&gt; 에서 쓰이는 모든 오브젝트는 &lt;em&gt;intector service&lt;/em&gt; &lt;code&gt;$injector&lt;/code&gt;  에 의해서 초기화 된다고 했었습니다. 일반적인 서비스 오브젝트와, 특별한 목적을 가진 오브젝트들이 있다고 언급하기도 했지요.&lt;/p&gt;

&lt;p&gt;이런 특별한 오브젝트들은 프레임워크를 확장하는 플러그인으로서 &lt;em&gt;Angular&lt;/em&gt; 에서 정의한 &lt;em&gt;interface&lt;/em&gt; 를 구현해야 하는데, 이 인터페이스는 &lt;code&gt;Controller&lt;/code&gt;, &lt;code&gt;Directive&lt;/code&gt;, &lt;code&gt;Filter&lt;/code&gt;, &lt;code&gt;Animation&lt;/code&gt; 입니다. &lt;/p&gt;

&lt;p&gt;&lt;code&gt;Controller&lt;/code&gt; 오브젝트를 제외하고는 이러한 &lt;em&gt;special object&lt;/em&gt; 를 생성하기 위해 &lt;em&gt;injector&lt;/em&gt; 는 &lt;em&gt;Factory recipe&lt;/em&gt; 를 이용합니다. 따라서 인자로 넣어준 팩토리 함수가 디렉티브를 만들기 위해 호출됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;myApp.directive('myPlanet', ['planetName', function myPlanetDirectiveFactory(planetName) {  
  // directive definition object
  return {
    restrict: 'E',
    scope: {},
    link: function($scope, $element) { $element.text('Planet: ' + planetName); }
  }
}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="controller"&gt;Controller&lt;/h3&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;myApp.controller('DemoController', ['clientId', function DemoController(clientId) {  
  this.clientId = clientId;
}]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Controller&lt;/code&gt; 는 조금 다르게, &lt;em&gt;Factory recipe&lt;/em&gt; 를 이용하지 않습니다. 인자로 정의한 &lt;em&gt;constructor function&lt;/em&gt; 함수가 &lt;strong&gt;모듈과 함께 등록&lt;/strong&gt;됩니다. &lt;/p&gt;

&lt;p&gt;애플리케이션이 &lt;code&gt;DemoController&lt;/code&gt; 가 필요할때마다 매번 &lt;em&gt;constructor&lt;/em&gt; 를 통해서 인스턴스화(&lt;em&gt;instantiated&lt;/em&gt;) 합니다. 일반적인 &lt;em&gt;service&lt;/em&gt; 와는 다르게, &lt;strong&gt;컨트롤러는 싱글턴이 아닙니다&lt;/strong&gt;. &lt;/p&gt;

&lt;p&gt;지금까지 배운 내용을 정리하면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The injector uses recipes to create two type of objects: &lt;strong&gt;services&lt;/strong&gt; and &lt;strong&gt;special purpose objects&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;There are five recipe types that define how to create objects: &lt;strong&gt;Value&lt;/strong&gt;, &lt;strong&gt;Factory&lt;/strong&gt;, &lt;strong&gt;Service&lt;/strong&gt;, &lt;strong&gt;Provide&lt;/strong&gt;, and &lt;strong&gt;Constant&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Factory and Service are the most commonly used recipes. The only differences between them is that the &lt;em&gt;Service recipe&lt;/em&gt; works better &lt;strong&gt;for objects of a custom type&lt;/strong&gt;, while the &lt;em&gt;Factory&lt;/em&gt; can produce &lt;strong&gt;primitives and functions&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;Provider recipe&lt;/em&gt; is the core recipe type and all the other ones are just syntactic sugar on it&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Provider&lt;/em&gt; is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration&lt;/li&gt;
&lt;li&gt;All special purpose objects except for the &lt;strong&gt;Controller&lt;/strong&gt; are defined via &lt;em&gt;Factory recipes&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="dependencyinjection"&gt;Dependency Injection&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://docs.angularjs.org/img/guide/concepts-module-injector.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;service&lt;/em&gt; 는 &lt;code&gt;$injector&lt;/code&gt; 에 의해서 싱글턴 인스턴스가 만들어지고, &lt;code&gt;$injector.get()&lt;/code&gt; 을 통해 얻을 수 있습니다. 만약 캐시된 인스턴스가 있다면 가져오고 없으면 새로 만듭니다. 아래는 외부에서 &lt;code&gt;injector&lt;/code&gt; 를 통해 내부 서비스를 접근하는 방법입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;var injector = angular.injector(['myModule', 'ng']);  
var greeter = injector.get('greeter');  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="refs"&gt;Refs&lt;/h3&gt;

&lt;p&gt;(1) [http://galleryhip.com/angular-js-icon.html) &lt;br&gt;
(2) &lt;a href="https://docs.angularjs.org/guide/providers#value-recipe"&gt;Angular Document&lt;/a&gt; &lt;br&gt;
(3) &lt;a href="http://www.webdeveasy.com/javascript-promises-and-angularjs-q-service/"&gt;Webdeveasy: AngularJS Q&lt;/a&gt; &lt;br&gt;
(4) &lt;a href="http://www.webdeveasy.com/interceptors-in-angularjs-and-useful-examples/"&gt;Webdeveasy: AngularJS Interceptor&lt;/a&gt;  &lt;/p&gt;</content:encoded></item><item><title>Coding The Matrix 3</title><description>&lt;p&gt;&lt;img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/column_row_space.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_as_vector.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_impl.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/null_space_of_matrix.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Null space of a matrix is a vector space&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/vector_space.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions_proof.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/use_standard_generator.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;standard geneartor&lt;/em&gt; 를 이용해서 &lt;code&gt;f(x) = M * x&lt;/code&gt; 에서의 &lt;code&gt;M&lt;/code&gt; 의 컬럼을 알아낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_function_def.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_def_2.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;어떤 함수 &lt;code&gt;f&lt;/code&gt; 가 &lt;code&gt;M * x&lt;/code&gt; 형태로 정의되면, &lt;code&gt;f&lt;/code&gt; 는 &lt;em&gt;linear function&lt;/em&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/def_kernel.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;어떤 함수 &lt;code&gt;f&lt;/code&gt; 의 &lt;em&gt;kernel&lt;/em&gt; 은 &lt;em&gt;image&lt;/em&gt; 를 &lt;code&gt;0&lt;/code&gt; 으로 하는 집합이다. 다시&lt;/p&gt;</description><link>http://1ambda.github.io/coding-the-matrix-3/</link><guid isPermaLink="false">715b3e8b-1821-4204-98cf-48f2a029e11b</guid><category>coursera</category><category>linear algebra</category><category>matrix</category><dc:creator>1ambda</dc:creator><pubDate>Sat, 14 Mar 2015 16:41:34 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/column_row_space.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_as_vector.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_impl.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/null_space_of_matrix.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Null space of a matrix is a vector space&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/vector_space.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions_proof.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/use_standard_generator.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;standard geneartor&lt;/em&gt; 를 이용해서 &lt;code&gt;f(x) = M * x&lt;/code&gt; 에서의 &lt;code&gt;M&lt;/code&gt; 의 컬럼을 알아낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_function_def.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_def_2.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;어떤 함수 &lt;code&gt;f&lt;/code&gt; 가 &lt;code&gt;M * x&lt;/code&gt; 형태로 정의되면, &lt;code&gt;f&lt;/code&gt; 는 &lt;em&gt;linear function&lt;/em&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/def_kernel.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;어떤 함수 &lt;code&gt;f&lt;/code&gt; 의 &lt;em&gt;kernel&lt;/em&gt; 은 &lt;em&gt;image&lt;/em&gt; 를 &lt;code&gt;0&lt;/code&gt; 으로 하는 집합이다. 다시 말해서 &lt;code&gt;f(x) = M * x&lt;/code&gt; 에 대해 &lt;em&gt;null matrix&lt;/em&gt; &lt;code&gt;x&lt;/code&gt; 이 &lt;em&gt;kernel&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/kernel_one_to_one1.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;linear function&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; is &lt;strong&gt;one-to-one&lt;/strong&gt; iff its kernel is a &lt;em&gt;trivial vector space&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/kernel_one_to_one2.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;위에 나온 속성은 상당히 중요하다. 왜냐하면 &lt;em&gt;trivial kernel&lt;/em&gt; 이면, 다시 말해서 &lt;em&gt;null matrix&lt;/em&gt; 가 &lt;em&gt;trivial&lt;/em&gt; 이면, &lt;code&gt;f&lt;/code&gt; 의 &lt;em&gt;image&lt;/em&gt; &lt;code&gt;b&lt;/code&gt; 는 아무리 많아봐야 하나이기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/def_onto.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;image&lt;/em&gt; 가 &lt;em&gt;entire co-domain&lt;/em&gt; 과 같으면 &lt;strong&gt;onto&lt;/strong&gt; 다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/inner_product.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/outer_product.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/function_composition.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;두 &lt;em&gt;matrix-vector function&lt;/em&gt; 의 &lt;em&gt;composition&lt;/em&gt; 은 위처럼 쉽게 증명 가능하다. &lt;code&gt;AB * x&lt;/code&gt; 로&lt;/p&gt;

&lt;p&gt;이걸 이용하면 &lt;em&gt;matrix-matrix multiplication&lt;/em&gt; 의 &lt;em&gt;associativity&lt;/em&gt; 도 쉽게 증명 가능하다. &lt;code&gt;(AB)C = A(BC)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="invertible"&gt;Invertible&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible1.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible2.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;두 함수가 &lt;em&gt;inverse&lt;/em&gt; 관계면 두 매트릭스도 &lt;em&gt;inverse&lt;/em&gt; 관계다. 그리고 한 매트릭스의 &lt;em&gt;inverse matrix&lt;/em&gt; 가 존재하면 &lt;em&gt;invertible&lt;/em&gt; 또는 &lt;em&gt;singular&lt;/em&gt; 라 부르며, 아무리 많아봐야 하나의 &lt;em&gt;inverse&lt;/em&gt; 만 가진다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way1.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way2.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way3.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way4.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;invertible matrix&lt;/em&gt; 가 중요한 이유는, &lt;em&gt;invertible matrix&lt;/em&gt; 가 존재하면 &lt;code&gt;f&lt;/code&gt; 도 &lt;em&gt;invertible&lt;/em&gt; 이고, 그 말은 &lt;code&gt;f&lt;/code&gt; 가 &lt;strong&gt;one-to-one, onto&lt;/strong&gt; 라는 소리다. 따라서 &lt;code&gt;f(u) = b&lt;/code&gt; 에 대해 적어도 하나의 솔루션이 존재하고 (&lt;em&gt;onto&lt;/em&gt;), 아무리 많아봐야 하나의 솔루션이 존재한다는 뜻이다 (&lt;em&gt;one-to-one&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_product_matrix1.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_product_matrix2.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;함수처럼 매트릭스도 &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; 가 &lt;em&gt;invertible&lt;/em&gt; 일때만 &lt;code&gt;AB&lt;/code&gt; 도 그러하다. &lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/identity_invertible1.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AB&lt;/code&gt; 에 대해 &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; 가 서로의 &lt;em&gt;inverse&lt;/em&gt; 면 &lt;code&gt;AB&lt;/code&gt; 는 &lt;em&gt;identity matrix&lt;/em&gt; 지만 그 역은 성립하지 않는다.&lt;/p&gt;

&lt;p&gt;위 그림의 &lt;code&gt;A&lt;/code&gt; 에서 볼 수 있듯이 &lt;em&gt;null space&lt;/em&gt; 가 &lt;em&gt;trivial&lt;/em&gt; 하지 않기 때문에 &lt;em&gt;one to one&lt;/em&gt; 이 아니어서 &lt;code&gt;A&lt;/code&gt; 는 &lt;em&gt;invertible&lt;/em&gt; 이 아니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/identity_invertible2.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AB&lt;/code&gt;, &lt;code&gt;BA&lt;/code&gt; 가 모두 &lt;em&gt;identity matrix&lt;/em&gt; 여야 &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; 가 서로 &lt;em&gt;inverse&lt;/em&gt; 다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/identity_invertible3.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;매트릭스 &lt;code&gt;M&lt;/code&gt; 이 &lt;em&gt;one-to-one&lt;/em&gt; 인지는 &lt;em&gt;trivial kernel&lt;/em&gt; 인지를 판별하면 된다. &lt;code&gt;f(x) = M * x&lt;/code&gt; 는 &lt;em&gt;linear function&lt;/em&gt; 이기 때문에 &lt;em&gt;trivial kernel&lt;/em&gt; 이면 &lt;code&gt;M&lt;/code&gt; 도 &lt;em&gt;one-to-one&lt;/em&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;onto&lt;/em&gt; 인지는 어떻게 알 수 있을까?&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="summary"&gt;Summary&lt;/h3&gt;

&lt;p&gt;지금 까지의 내용을 정리하면&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;u1&lt;/code&gt; 이 &lt;code&gt;a * x = b&lt;/code&gt; 의 솔루션일때, &lt;code&gt;V&lt;/code&gt; 를 &lt;code&gt;a * x = 0&lt;/code&gt; 의 솔루션 셋이라 하면, &lt;code&gt;u1 + V&lt;/code&gt; 는 &lt;code&gt;a * x = b&lt;/code&gt; 의 솔루션 셋이다. 다시 말해서 &lt;code&gt;V&lt;/code&gt; 는 &lt;em&gt;null matrix&lt;/em&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;f(x)&lt;/code&gt; 가 &lt;code&gt;M * x&lt;/code&gt; 형태로 나타낼 수 있으면 &lt;em&gt;linear function&lt;/em&gt; 이다.  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;trivial kernel&lt;/em&gt; 이면 &lt;em&gt;linear function&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; 는 &lt;em&gt;one-to-one&lt;/em&gt; 이고, &lt;em&gt;linear function&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; 가 &lt;em&gt;one-to-one&lt;/em&gt; 이면 &lt;em&gt;trivial kernel&lt;/em&gt; 을 가진다.  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="refs"&gt;Refs&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href="http://colorsark.deviantart.com/art/3D-Cube-342632998"&gt;Title image&lt;/a&gt; &lt;br&gt;
(2) &lt;strong&gt;Coding the Matrix&lt;/strong&gt; by &lt;em&gt;Philip Klein&lt;/em&gt;  &lt;/p&gt;</content:encoded></item><item><title>Cloud Computing, Paxos</title><description>&lt;p&gt;&lt;img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;대부분의 분산 서버 벤더들은 &lt;code&gt;99.99999%&lt;/code&gt; 의 &lt;em&gt;reliability&lt;/em&gt; 를 보장하지만, &lt;code&gt;100%&lt;/code&gt;는 아닙니다. 왜그럴까요? 그들이 못해서가 아니라 &lt;em&gt;consensus&lt;/em&gt; 문제 때문입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The fault lies in the impossibility of consensus&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Consensus&lt;/em&gt; 문제가 중요한 이유는, 많은 분산 시스템이 &lt;em&gt;consensus&lt;/em&gt; 문제이기 때문입니다. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Perfect Failure Detection&lt;/li&gt;
&lt;li&gt;Leader Election&lt;/li&gt;
&lt;li&gt;Agreement (harder than consensus)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 서버가 많으면&lt;/p&gt;</description><link>http://1ambda.github.io/cloud-computing-paxos/</link><guid isPermaLink="false">fa427789-33eb-4728-913a-ab4b1cfbf14e</guid><category>coursera</category><category>cloud computing</category><category>paxos</category><category>consensus</category><dc:creator>1ambda</dc:creator><pubDate>Sat, 07 Mar 2015 19:44:32 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;대부분의 분산 서버 벤더들은 &lt;code&gt;99.99999%&lt;/code&gt; 의 &lt;em&gt;reliability&lt;/em&gt; 를 보장하지만, &lt;code&gt;100%&lt;/code&gt;는 아닙니다. 왜그럴까요? 그들이 못해서가 아니라 &lt;em&gt;consensus&lt;/em&gt; 문제 때문입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The fault lies in the impossibility of consensus&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Consensus&lt;/em&gt; 문제가 중요한 이유는, 많은 분산 시스템이 &lt;em&gt;consensus&lt;/em&gt; 문제이기 때문입니다. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Perfect Failure Detection&lt;/li&gt;
&lt;li&gt;Leader Election&lt;/li&gt;
&lt;li&gt;Agreement (harder than consensus)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 서버가 많으면 다음의 일들을 해야합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Reliable Multicast:&lt;/strong&gt; Make sure that all of them receive the same updates in the same order as each other&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Membership/Failure Detection:&lt;/strong&gt; To keep their own local lists where they know about each other, and when anyone leaves or fails, everyone is updated simultaneously&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Leader Election:&lt;/strong&gt; Elect a leader among them, and let everyone in the group know about it&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mutual Exclusion:&lt;/strong&gt; To ensure mutually exclusive access to a critical resource like a file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 문제들은 대부분 &lt;em&gt;consensus&lt;/em&gt; 와 연관되어 있습니다. 더 직접적으로 연관되어 있는 문제들은&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The ordering of messages&lt;/li&gt;
&lt;li&gt;The up/down status of a suspected failed process&lt;/li&gt;
&lt;li&gt;Who the leader is&lt;/li&gt;
&lt;li&gt;Who has access to the critical resource&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="consensusproblem"&gt;Consensus Problem&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_problem.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_problem2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;모든 프로세스(노드, 서버)가 같은 &lt;em&gt;value&lt;/em&gt; 를 만들도록 해야 하는데, 몇 가지 제약조건이 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;validity:&lt;/strong&gt; if everyone propose same value, then that's what's decided&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;integrity:&lt;/strong&gt; decided value must have been proposed by some process&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;non-triviality:&lt;/strong&gt; there is at least one initial system state that leads to each of the all-&lt;code&gt;0&lt;/code&gt;'s or all-&lt;code&gt;1&lt;/code&gt;'s outcomes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;non-triviality&lt;/em&gt; 는 쉽게 말해서, 모두 &lt;code&gt;0&lt;/code&gt; 이거나 모두 &lt;code&gt;1&lt;/code&gt; 일 수 있는 상태가 있어야 한다는 뜻입니다. 왜냐하면 항상 &lt;code&gt;0&lt;/code&gt; 이거나 &lt;code&gt;1&lt;/code&gt; 만 나오면 &lt;em&gt;trivial&lt;/em&gt; 하기 때문입니다. 별 의미가 없죠.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="models"&gt;Models&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;consensus&lt;/em&gt; 문제는 분산 시스템 모델에 따라 달라집니다. 모델은 크게 2가지로 나눌 수 있는데&lt;/p&gt;

&lt;p&gt;(1) Synchronous Distributed System Model&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Each message is received within bounded time&lt;/li&gt;
&lt;li&gt;Drift of each process' local clock has a known bound&lt;/li&gt;
&lt;li&gt;Each step in a process takes &lt;code&gt;lb &amp;lt; time &amp;lt; ub&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;동기 시스템 모델에서는 &lt;em&gt;consensus&lt;/em&gt; 문제를 풀 수 있습니다.&lt;/p&gt;

&lt;p&gt;(2) Asynchronous Distributed System Model&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Nobounds on process execution&lt;/li&gt;
&lt;li&gt;The drift rate of a clock is arbitrary&lt;/li&gt;
&lt;li&gt;No bounds on message transmission delay&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 비동기 분산 시스템 모델이 더 일반적입니다, 그리고 더 어렵죠. 비동기를 위한 프로토콜은 동기 모델 위에서 작동할 수도 있으나, 그 역은 잘 성립하지 않습니다.&lt;/p&gt;

&lt;p&gt;비동기 분산 시스템 모델에서는 &lt;em&gt;consensus&lt;/em&gt; 문제는 풀 수 &lt;strong&gt;없습니다&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Whatever protocol/algorithm you suggest, there is always a worst-case possible execution with failures and message delays that prevens the system from reaching consensus&lt;/li&gt;
&lt;li&gt;Powerful result(see the &lt;strong&gt;FLP&lt;/strong&gt; proof)&lt;/li&gt;
&lt;li&gt;Subsequently, safe and &lt;strong&gt;probabilistic&lt;/strong&gt; solution have become popular (e.g Paxos)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="paxosinsyncronoussystems"&gt;Paxos in Syncronous Systems&lt;/h3&gt;

&lt;p&gt;동기 시스템이라 가정합니다. 따라서&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bounds on message dealy&lt;/li&gt;
&lt;li&gt;bounds on upper bound on clock drift rates&lt;/li&gt;
&lt;li&gt;bounds on max time for each process step&lt;/li&gt;
&lt;li&gt;processes can fail by stopping&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_in_sync_system.png" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;아무리 많아야 &lt;code&gt;f&lt;/code&gt; 개의 프로세서에서 &lt;em&gt;crash&lt;/em&gt; 가 나고&lt;/li&gt;
&lt;li&gt;모든 프로세서는 &lt;em&gt;round&lt;/em&gt; 단위로 동기화 되고, 동작하며&lt;/li&gt;
&lt;li&gt;&lt;em&gt;reliable communication&lt;/em&gt; 을 통해 서로 통신합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;value_i^r&lt;/em&gt; 을 &lt;em&gt;round&lt;/em&gt; &lt;code&gt;r&lt;/code&gt; 의 시작에 &lt;code&gt;P_i&lt;/code&gt; 에게 알려진 &lt;em&gt;value&lt;/em&gt; 의 집합이라 라 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;f+1&lt;/code&gt; 라운드 후에 모든 &lt;em&gt;correct&lt;/em&gt; 프로세스는 같은 값의 집합을 가지게 되는데, 귀류법으로 쉽게 증명할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_in_async.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;비동기 환경에서는, 아주아주아주아주아주 느린 프로세서와 &lt;em&gt;failed&lt;/em&gt; 프로세서를 구분할 수 없기 때문에, 나머지 프로세서들이 이것을 결정하기 위해 영원히 기다려야 할지도 모릅니다. 이것이 기본적인 &lt;em&gt;FLP Proof&lt;/em&gt; 의 아이디어입니다. 그렇다면, &lt;em&gt;consensus&lt;/em&gt; 문제를 정말 풀기는 불가능한걸까요?&lt;/p&gt;

&lt;p&gt;풀 수 있습니다. 널리 알려진 &lt;em&gt;consensus-solving&lt;/em&gt; 알고리즘이 있습니다. 실제로는 불가능한 &lt;em&gt;consensus&lt;/em&gt; 문제를 풀려는 것이 아니라, &lt;em&gt;safety&lt;/em&gt; 와 &lt;em&gt;eventual liveness&lt;/em&gt; 를 제공합니다. 야후의 &lt;em&gt;zookeeper&lt;/em&gt; 나 구글의 &lt;em&gt;chubby&lt;/em&gt; 등이 이 알고리즘을 이용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/yes_we_can_with_paxos.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;safety&lt;/em&gt; 는 서로 다른 두개의 프로세서가 다른 값을 제출하지 않는것을 보장하고, (&lt;em&gt;No two non-faulty processes decide different values&lt;/em&gt;) &lt;em&gt;eventual liveness&lt;/em&gt; 는 운이 좋다면 언젠가는 합의에 도달한다는 것을 말합니다. 근데 실제로는 꽤 빨리 &lt;em&gt;consensus&lt;/em&gt; 문제를 풀 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos_simple.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;본래는 최적화때문에 더 복잡한데, 위 슬라이드에서는 간략화된 &lt;em&gt;paxos&lt;/em&gt; 가 나와있습니다. &lt;em&gt;paxos&lt;/em&gt; 의 &lt;em&gt;round&lt;/em&gt; 마다 고유한 &lt;em&gt;ballot id&lt;/em&gt; 가 할당되고, 각 &lt;em&gt;round&lt;/em&gt; 는 크게 3개의 비동기적인 &lt;em&gt;phase&lt;/em&gt; 로 분류할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;election:&lt;/strong&gt; a leader is elected&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bill:&lt;/strong&gt; leader proposes a value, processes ack&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;law:&lt;/strong&gt; leader multicasts final value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/election.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;먼저 &lt;em&gt;potential leader&lt;/em&gt; 가 &lt;em&gt;unique ballot id&lt;/em&gt; 를 고르고, 다른 프로세서들에게 보냅니다. 다른 프로세스들의 반응에 의해서 선출될 수도 있고, 선출되지 않으면 새로운 라운드를 시작합니다. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Because becoming a leader requires a majority of votes, and any two majorities intersect in at least one process, and each process can only vote once.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/bill.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;리더가 다른 프로세스들에게 &lt;code&gt;v&lt;/code&gt; 를 제안하고, 프로세스들은 지난 라운드에 &lt;code&gt;v'&lt;/code&gt; 를 결정했었으면 &lt;code&gt;v=v'&lt;/code&gt; 를 이용해 값을 결정합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/decision.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;만약 리더가 &lt;em&gt;majority&lt;/em&gt; 의 긍정적인 반응을 얻으면 모두에게 그 결정을 알리고 각 프로세서는 합의된 내용을 전달받고, 로그에 기록하게 됩니다. &lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos_no_return.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;사실 이 과정은 응답을 리더가 받는 단계에서 결정되는 것이 아니라, 프로세서들이 &lt;em&gt;proposed value&lt;/em&gt; 를 듣는순간 결정됩니다. 따라서 리더에서 &lt;em&gt;failure&lt;/em&gt; 가 일어나도, 이전에 결정되었던 &lt;code&gt;v'&lt;/code&gt; 을 이용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos_safety.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;이전에도 언급했듯이 &lt;em&gt;safety&lt;/em&gt; 는 두개의 서로 다른 프로세서의 의해서 다른 값이 선택되지 않음을 보장합니다. 이는 잠재적 리더가 있다 하더라도 현재 리더와, 잠재적 리더에게 응답하는 &lt;em&gt;majority&lt;/em&gt; (반수 이상) 을 교차하면 적어도 하나는 &lt;code&gt;v'&lt;/code&gt; 를 응답하기 때문에 &lt;em&gt;bill phase&lt;/em&gt; 에서 정의한대로 이전 결과인 &lt;code&gt;v'&lt;/code&gt; 가 사용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxsos_liveness.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;그림에서 볼 수 있듯이 영원히 끝나지 않을수도 있지만, 실제로는 꽤 빠른시간 내에 합의에 도달합니다. (eventualy-live in async systems)&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="refs"&gt;Refs&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href="http://ook.co/solutions/cloud-computing/"&gt;Title Image&lt;/a&gt; &lt;br&gt;
(2) &lt;strong&gt;Cloud Computing Concept 1&lt;/strong&gt; by &lt;em&gt;Indranil Gupta&lt;/em&gt;, Coursera  &lt;/p&gt;</content:encoded></item><item><title>Cloud Computing, Multicast</title><description>&lt;p&gt;&lt;img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;multicast&lt;/em&gt; 는 클라우드 시스템에서 많이 사용됩니다. &lt;em&gt;Cassandra&lt;/em&gt; 같은 분산 스토리지에서는 &lt;em&gt;write/read&lt;/em&gt; 메세지를 &lt;em&gt;replica gorup&lt;/em&gt; 으로 보내기도 하고, &lt;em&gt;membership&lt;/em&gt; 을 관리하기 위해서 사용하기도 합니다&lt;/p&gt;

&lt;p&gt;그런데, 이 &lt;em&gt;multicast&lt;/em&gt; 는 &lt;em&gt;ordering&lt;/em&gt; 에 따라서 &lt;em&gt;correctness&lt;/em&gt; 에 영향을 줄 수 있기 때문에 매우 중요합니다. 자주 쓰이는 기법으로 &lt;em&gt;FIFO&lt;/em&gt;, &lt;em&gt;Casual&lt;/em&gt;, &lt;em&gt;Total&lt;/em&gt; 이 있는데 하나씩 살펴보겠습니다.&lt;/p&gt;</description><link>http://1ambda.github.io/cloud-computing-multicast/</link><guid isPermaLink="false">1aa1fadb-da2f-4163-af61-a68ed5cef2ac</guid><category>coursera</category><category>cloud computing</category><category>multicast</category><category>virtual synchrony</category><dc:creator>1ambda</dc:creator><pubDate>Sat, 07 Mar 2015 17:20:18 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;multicast&lt;/em&gt; 는 클라우드 시스템에서 많이 사용됩니다. &lt;em&gt;Cassandra&lt;/em&gt; 같은 분산 스토리지에서는 &lt;em&gt;write/read&lt;/em&gt; 메세지를 &lt;em&gt;replica gorup&lt;/em&gt; 으로 보내기도 하고, &lt;em&gt;membership&lt;/em&gt; 을 관리하기 위해서 사용하기도 합니다&lt;/p&gt;

&lt;p&gt;그런데, 이 &lt;em&gt;multicast&lt;/em&gt; 는 &lt;em&gt;ordering&lt;/em&gt; 에 따라서 &lt;em&gt;correctness&lt;/em&gt; 에 영향을 줄 수 있기 때문에 매우 중요합니다. 자주 쓰이는 기법으로 &lt;em&gt;FIFO&lt;/em&gt;, &lt;em&gt;Casual&lt;/em&gt;, &lt;em&gt;Total&lt;/em&gt; 이 있는데 하나씩 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="ordering"&gt;Ordering&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_FIFO.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;FIFO&lt;/em&gt; 를 이용한다면, 보낸 순서대로 도착하게 됩니다. &lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_casual.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_casual_example.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;casual ordering&lt;/em&gt; 에서는 반드시 &lt;em&gt;casuality-obeying order&lt;/em&gt; 로 전달해야 합니다. 예를 들어 위 그림에서는 &lt;code&gt;M1:1 -&amp;gt; M3:1&lt;/code&gt; 이기 때문에 반드시 그 순서대로 받아야 합니다. &lt;em&gt;concurrent event&lt;/em&gt; 는 어떤 순서로 받아도 상관 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;casual ordering&lt;/em&gt; 이면 &lt;em&gt;FIFO ordering&lt;/em&gt; 입니다. 왜냐하면 같은 프로세스에서 보낸 &lt;em&gt;casuality&lt;/em&gt; 를 따르면 그게 바로 &lt;em&gt;FIFO&lt;/em&gt; 이기 때문입니다. 역은 성립하지 않습니다.&lt;/p&gt;

&lt;p&gt;일반적으로는 &lt;em&gt;casual ordering&lt;/em&gt; 을 사용합니다. 서로 다른 친구로부터 댓글이 달렸는데, 늦게 달린 친구의 댓글이 먼저 보인다면 당연히 말이 되지 않습니다. &lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_total.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_total_example.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;total ordering&lt;/em&gt; 은 &lt;em&gt;atomic broadcast&lt;/em&gt; 라 부르는데, 모든 프로세스가 같은 순서로 메시지를 받는것을 보장합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Since &lt;em&gt;FIFO/Casual&lt;/em&gt; are orthogonal to &lt;em&gt;Total&lt;/em&gt;, can have hybrid ordering protocol too (e.g &lt;em&gt;FIFO-total&lt;/em&gt;, &lt;em&gt;Casual-total&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="fifoorderingimpl"&gt;FIFO Ordering Impl&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl2.png" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;각 프로세스는 &lt;em&gt;seq number&lt;/em&gt; 로 구성된 벡터를 유지하고, &lt;/li&gt;
&lt;li&gt;프로세스에서 메시지를 보낼때 마다 자신의 &lt;em&gt;seq number&lt;/em&gt; 를 하나 증가 시켜서 보냅니다&lt;/li&gt;
&lt;li&gt;메시지를 받았을때, &lt;strong&gt;자신의 벡터 내에 있는 값 + 1&lt;/strong&gt; 일 경우에만 벡터 값을 +1 한뒤 전달하고, 아니면 +1 인 값이 올 때까지 버퍼에 넣고 기다립니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예제를 보면&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl_example.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl_example2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="totalorderingimpl"&gt;Total Ordering Impl&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/total_impl1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;sequencer-based approach&lt;/em&gt; 입니다. 먼저 하나의 프로세스가 &lt;em&gt;sequencer&lt;/em&gt; 로 선출된 뒤, 어떤 프로세스가 메세지를 보낼때마다 그룹 뿐만 아니라 &lt;em&gt;sequencer&lt;/em&gt; 에게 보내게 됩니다.&lt;/p&gt;

&lt;p&gt;이 &lt;em&gt;sequencer&lt;/em&gt; 는 글로벌 시퀀스 &lt;code&gt;S&lt;/code&gt; 를 유지하면서, 메시지 &lt;code&gt;M&lt;/code&gt; 을 받을때마다 &lt;code&gt;S++&lt;/code&gt; 해서 &lt;code&gt;&amp;lt;M, S&amp;gt;&lt;/code&gt; 로 멀티캐스트를 보냅니다.&lt;/p&gt;

&lt;p&gt;각 프로세스에서는 &lt;em&gt;local&lt;/em&gt; 에 글로벌 시퀀스 &lt;code&gt;Si&lt;/code&gt; 를 유지합니다. 만약 프로세스가 메세지를 받는다면 &lt;code&gt;Si + 1 = S(M)&lt;/code&gt; 값을 글로벌 시퀀서로부터 받을때까지 기다리고, 받은 후에야 &lt;code&gt;Si++&lt;/code&gt; 하고 전달합니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="casualorderingimpl"&gt;Casual Ordering Impl&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;자료구조 자체는 같으나, &lt;em&gt;casuality&lt;/em&gt; 를 검사하기 위해 &lt;em&gt;sender&lt;/em&gt; 가 &lt;em&gt;vector&lt;/em&gt; 전체를 보냅니다. &lt;em&gt;receiver&lt;/em&gt; 는 메세지를 받으면 다음 두 조건을 만족하기 전까지 버퍼에 넣습니다&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M[j]&lt;/code&gt; = &lt;code&gt;P_i[j] + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M[k]&lt;/code&gt; &amp;lt;= &lt;code&gt;P_i[k]&lt;/code&gt;, (&lt;code&gt;k != j&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두번째 조건을 해석하면, 자신의 벡터도 다음 프로세스에게 전달해야 하기 때문에 &lt;code&gt;M[k]&lt;/code&gt; 이후의 벡터만 가지고 있어야 전달할 수 있다는 뜻입니다. (&lt;code&gt;M[j]&lt;/code&gt; 는 제외)&lt;/p&gt;

&lt;p&gt;이 두 조건이 만족되야만 &lt;code&gt;P_i[j] = M[j]&lt;/code&gt; 로 세팅하고 &lt;code&gt;M&lt;/code&gt; 을 전달합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl_example1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl_example2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="reliablemulticast"&gt;Reliable Multicast&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;reliable&lt;/em&gt; 이란, 루즈하게 말하자면 모든 &lt;em&gt;receiver&lt;/em&gt; 가 메세지를 받는다는 뜻입니다. &lt;em&gt;ordering&lt;/em&gt; 과는 &lt;em&gt;orthogonal&lt;/em&gt; 하기 때문에 &lt;em&gt;Reliable-FIFO&lt;/em&gt;, 등등 구현이 가능합니다. 더 엄밀한 정의는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;need all &lt;strong&gt;correct&lt;/strong&gt; (&lt;em&gt;non-faulty&lt;/em&gt;) processes to receive the same set of multicasts as all other correct processes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/reliable_multicast_impl1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;단순히 &lt;em&gt;reliable unicast&lt;/em&gt; 를 여러개 보내는것 만으로는 부족합니다. 왜냐하면 &lt;em&gt;sender&lt;/em&gt; 에서 &lt;em&gt;failure&lt;/em&gt; 가 일어날 수 있기 때문입니다&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/reliable_multicast_impl2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/reliable_multicast_impl3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;비효율적이지만, &lt;em&gt;reliable&lt;/em&gt; 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="virtualsynchrony"&gt;Virtual Synchrony&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;virtual sinchrony&lt;/em&gt; 혹은 &lt;em&gt;view synchrony&lt;/em&gt; 라 불리는데, 이것은 &lt;em&gt;failure&lt;/em&gt; 에도 불구하고 &lt;em&gt;multicast ordering&lt;/em&gt; 과 &lt;em&gt;reliability&lt;/em&gt; 를 얻기 위해 &lt;em&gt;membership protocol&lt;/em&gt; 을 &lt;em&gt;multicast protocol&lt;/em&gt; 과 같이 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/view.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;각 프로세스가 관리하는 &lt;em&gt;membership list&lt;/em&gt; 를 &lt;em&gt;view&lt;/em&gt; 라 부릅니다. &lt;em&gt;virtual synchrony&lt;/em&gt; 프로토콜은 이런 &lt;em&gt;view change&lt;/em&gt; 가 &lt;em&gt;correct process&lt;/em&gt; 에 올바른 순서대로 전달됨을 보장합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/vsync_multicast.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Virtual Synchrony&lt;/em&gt; 프로토콜은 다음을 보장합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the set of multicasts delivered in a given view is the same set at all correct processes that were in that view&lt;/li&gt;
&lt;li&gt;the sender of the multicast message also belongs to that view&lt;/li&gt;
&lt;li&gt;if a process &lt;code&gt;P_i&lt;/code&gt; doesn't not deliver a multicast &lt;code&gt;M&lt;/code&gt; in view &lt;code&gt;V&lt;/code&gt; while other processes in the view &lt;code&gt;V&lt;/code&gt; delivered &lt;code&gt;M&lt;/code&gt; in &lt;code&gt;V&lt;/code&gt;, then &lt;code&gt;P_i&lt;/code&gt; will be &lt;strong&gt;forcibly removed&lt;/strong&gt; from the next view delivered after &lt;code&gt;V&lt;/code&gt; at the other processes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다시 말해서, &lt;em&gt;multicast&lt;/em&gt; 메세지는 같이 전달된 &lt;em&gt;view&lt;/em&gt; 내에 있던 다른 프로세스에서 모두 동일합니다. 그리고 &lt;em&gt;view&lt;/em&gt; &lt;code&gt;V&lt;/code&gt; 내에 있는 어떤 프로세스가 &lt;code&gt;M&lt;/code&gt; 을 전달하지 못할 경우, 다른 프로세스의 &lt;em&gt;next view&lt;/em&gt; 에서 제거됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example4.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example5.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example6.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example7.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example8.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Called &lt;strong&gt;"virtual synchrony"&lt;/strong&gt; since in spite of running on an asynchronous network, it gives the appearance of a synchronous network underneath that obeys the same ordering at all processes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 &lt;em&gt;consensus&lt;/em&gt; 를 구현하는데는 쓸 수 없습니다. &lt;em&gt;partitioning&lt;/em&gt; 에 취약하기 때문입니다.&lt;/p&gt;

&lt;p&gt;정리하자면 &lt;em&gt;multicast&lt;/em&gt; 는 클라우드 시스템에서 중요한 요소입니다. 필요에 따라서 &lt;em&gt;ordering&lt;/em&gt;, &lt;em&gt;reliability&lt;/em&gt;, &lt;em&gt;virtual synchorny&lt;/em&gt; 를 구현할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="refs"&gt;Refs&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href="http://ook.co/solutions/cloud-computing/"&gt;Title Image&lt;/a&gt; &lt;br&gt;
(2) &lt;strong&gt;Cloud Computing Concept 1&lt;/strong&gt; by &lt;em&gt;Indranil Gupta&lt;/em&gt;, Coursera  &lt;/p&gt;</content:encoded></item><item><title>Cloud Computing, Snapshots</title><description>&lt;p&gt;&lt;img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;이번시간에는 &lt;em&gt;Distributed Snapshot&lt;/em&gt; 에 대해서 배웁니다. 클라우드 환경에서 각 어플리케이션(혹은 서비스) 는 여러개의 서버 위에서 돌아갑니다. 각 서버는 &lt;em&gt;concurrent events&lt;/em&gt; 를 다루며, 서로 상호작용합니다. 이런 환경에서 &lt;em&gt;global snapshot&lt;/em&gt; 을 캡쳐할 수 있다면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;check pointing:&lt;/strong&gt; can restart distributed application on failure&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;garbage collection of objects:&lt;/strong&gt; object at servers that don't&lt;/li&gt;&lt;/ul&gt;</description><link>http://1ambda.github.io/cloud-computing-snapshot/</link><guid isPermaLink="false">7d51c274-e6e6-41dd-a37e-b548da6e711c</guid><category>coursera</category><category>cloud computing</category><category>snapshot</category><category>Chandy-Lamport</category><dc:creator>1ambda</dc:creator><pubDate>Sat, 07 Mar 2015 13:57:56 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;이번시간에는 &lt;em&gt;Distributed Snapshot&lt;/em&gt; 에 대해서 배웁니다. 클라우드 환경에서 각 어플리케이션(혹은 서비스) 는 여러개의 서버 위에서 돌아갑니다. 각 서버는 &lt;em&gt;concurrent events&lt;/em&gt; 를 다루며, 서로 상호작용합니다. 이런 환경에서 &lt;em&gt;global snapshot&lt;/em&gt; 을 캡쳐할 수 있다면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;check pointing:&lt;/strong&gt; can restart distributed application on failure&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;garbage collection of objects:&lt;/strong&gt; object at servers that don't have any other objects(ay any servers) with pointers to them&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deadlock detection:&lt;/strong&gt; useful in database transaction systems&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;termination of computation:&lt;/strong&gt; useful in batch computing systems like Folding@Homes, SETI@Home&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;global snapshot&lt;/em&gt; 은 두 가지를 포함합니다.&lt;/p&gt;

&lt;p&gt;(1) Individual state of each process 
(2) Individual state of each communication channel &lt;/p&gt;

&lt;p&gt;&lt;em&gt;global snapshot&lt;/em&gt; 을 만드는 한가지 방법은 모든 프로세스의 &lt;em&gt;clock&lt;/em&gt; 을 동기화 하는 것입니다. 그래서 모든 프로세스에게 &lt;em&gt;time&lt;/em&gt; &lt;code&gt;t&lt;/code&gt; 에서의 자신의 상태를 기록하도록 요구할 수 있습니다. 그러나&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Time synchorization always has error&lt;/li&gt;
&lt;li&gt;Doesn't not record the state of meesages in the channels&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지난 시간에 보았듯이, &lt;em&gt;synchronization&lt;/em&gt; 이 아니라 &lt;em&gt;casuality&lt;/em&gt; 로도 충분합니다. 프로세스가 &lt;strong&gt;명령을 실행하거나&lt;/strong&gt;, &lt;strong&gt;메시지를 받거나&lt;/strong&gt;, &lt;strong&gt;메시지를 보낼때마다&lt;/strong&gt; &lt;em&gt;global system&lt;/em&gt; 가 변합니다. 이를 저장하기 위해서 &lt;em&gt;casuality&lt;/em&gt; 를 기록하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="chandylamportalgorithm"&gt;Chandy-Lamport Algorithm&lt;/h3&gt;

&lt;p&gt;시작 전에 &lt;em&gt;system model&lt;/em&gt; 을 정의하면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N Processes in the system&lt;/li&gt;
&lt;li&gt;There are two uni-directional communication channels between each ordered process pair &lt;code&gt;P_j -&amp;gt; P_i&lt;/code&gt;, &lt;code&gt;P_i -&amp;gt; P_j&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;communication channels are &lt;strong&gt;FIFO&lt;/strong&gt; ordered&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No failure&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;All messages arribe intact, and are not duplicated&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;requirements&lt;/em&gt; 는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;snapshot&lt;/em&gt; 때문에 &lt;em&gt;application&lt;/em&gt; 의 작업에 방해가 일어나서는 안됩니다&lt;/li&gt;
&lt;li&gt;각 프로세스는 자신의 &lt;em&gt;state&lt;/em&gt; 를 저장할 수 있어야 합니다&lt;/li&gt;
&lt;li&gt;&lt;em&gt;global state&lt;/em&gt; 는 분산회되어 저장됩니다 (collected in a distributed manner)&lt;/li&gt;
&lt;li&gt;어떤 프로세스든지, &lt;em&gt;snapshot&lt;/em&gt; 작업을 시작할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport1.png" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;프로세스 &lt;code&gt;P_i&lt;/code&gt; 가 &lt;em&gt;market&lt;/em&gt; 메세지를 만들고, 자신을 제외한 다른 &lt;code&gt;N-1&lt;/code&gt; 개의 프로세스에게 보냅니다&lt;/li&gt;
&lt;li&gt;동시에 &lt;code&gt;P_i&lt;/code&gt; 는 &lt;em&gt;incoming channel&lt;/em&gt; 을 레코딩하기 시작합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;(1) 만약 &lt;code&gt;P_i&lt;/code&gt; 가 &lt;em&gt;marker&lt;/em&gt; 메시지를 처음 받는다면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;만약메시지를 받은 프로세스 &lt;code&gt;P_i&lt;/code&gt; 에서는 자신의 &lt;em&gt;state&lt;/em&gt; 를 기록하고&lt;/li&gt;
&lt;li&gt;자신을 제외한 프로세스들에게 &lt;em&gt;marker&lt;/em&gt; 보내고&lt;/li&gt;
&lt;li&gt;는 &lt;em&gt;incoming channel&lt;/em&gt; 을 레코딩하기 시작합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) &lt;code&gt;P_i&lt;/code&gt; 가 이미 &lt;em&gt;market&lt;/em&gt; 메세지를 받은적이 있다면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;이미 해당 채널의 모든 메세지를 기록중이었으므로, 레코딩을 끝냅니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;이 알고리즘은 모든 프로세스가 자신의 &lt;em&gt;state&lt;/em&gt; 와 모든 &lt;em&gt;channel&lt;/em&gt; 을 저장하면 종료됩니다. &lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example4.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example5.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example6.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="consistentcuts"&gt;Consistent Cuts&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Chandy-Lamport&lt;/em&gt; 알고리즘은 &lt;em&gt;casuality&lt;/em&gt; 를 보장합니다. 이에 대해 증명하기 전에 먼저, &lt;em&gt;consistent cut&lt;/em&gt; 이란 개념을 보고 가겠습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Cut:&lt;/strong&gt; time frontier at each process and at each channel. Events at the process/channel that happen before the cut are &lt;strong&gt;in the cut&lt;/strong&gt; and happening after the cut are &lt;strong&gt;out of the cut&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Consistent Cut:&lt;/strong&gt; a cut that obeys casuality. A cut &lt;code&gt;C&lt;/code&gt; is a consistent cut iff for each pair of event &lt;code&gt;e&lt;/code&gt; &lt;code&gt;f&lt;/code&gt; in the system, such that event &lt;code&gt;e&lt;/code&gt; is in the cur &lt;code&gt;C&lt;/code&gt; and if &lt;code&gt;f -&amp;gt; e&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다시 말해서 &lt;code&gt;e&lt;/code&gt; 가 &lt;code&gt;C&lt;/code&gt; 내에 있고, &lt;code&gt;f -&amp;gt; e&lt;/code&gt; 라면 &lt;code&gt;f&lt;/code&gt; 도 &lt;code&gt;C&lt;/code&gt; 에 있어야만 &lt;em&gt;consistent cut&lt;/em&gt; 이란 뜻입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consistent_cut1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;F&lt;/code&gt; 가 &lt;em&gt;cut&lt;/em&gt; 내에 있지만, 올바르게 캡쳐되어 메시지 큐 내에서 전송중임을 &lt;em&gt;snapshot&lt;/em&gt; 에서 보장합니다. 하지만 &lt;code&gt;G -&amp;gt; D&lt;/code&gt; 같은 경우는, &lt;code&gt;D&lt;/code&gt; 가 &lt;em&gt;cut&lt;/em&gt; 내에 있지만 &lt;code&gt;G&lt;/code&gt; 가 그렇지 않아 &lt;em&gt;inconsistent cut&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consistent_cut2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Chandy-Lamport Global Snapshot&lt;/em&gt; 알고리즘은 항상 &lt;em&gt;consistent cut&lt;/em&gt; 을 만듭니다. 왜 그런가 증명을 보면&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Proof1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ei -&amp;gt; ej&lt;/code&gt; 를 보장한다는 말은 스냅샷 안에 두 이벤트가 있다는 뜻입니다. 따라서 &lt;code&gt;ej -&amp;gt; &amp;lt;P_j records its state&amp;gt;&lt;/code&gt; 일때 당연히 &lt;code&gt;ei -&amp;gt; &amp;lt;P_i records its state&amp;gt;&lt;/code&gt; 와 같은 말입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Proof2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;code&gt;ej -&amp;gt; &amp;lt;P_j records its state&amp;gt;&lt;/code&gt; 일때 &lt;code&gt;&amp;lt;P_i records its state&amp;gt; -&amp;gt; ei&lt;/code&gt; 라 합시다.&lt;/p&gt;

&lt;p&gt;그러면 &lt;code&gt;ei -&amp;gt; ej&lt;/code&gt; 로 가는 &lt;em&gt;regular app message&lt;/em&gt; 경로를 생각해 봤을때, &lt;code&gt;P_i&lt;/code&gt; 가 먼저 자신의 상태를 기록하기 시작했으므로 &lt;em&gt;marker&lt;/em&gt; 메세지가 먼저 날라갈겁니다. (FIFO) 그러면 위에서 말한 &lt;code&gt;ei -&amp;gt; ej&lt;/code&gt; 경로를 타고 &lt;em&gt;marker&lt;/em&gt; 메세지가 먼저 가게되고 &lt;code&gt;P_j&lt;/code&gt; 는 자신의 상태를 먼저 기록하게 됩니다. 따라서 &lt;code&gt;P_j&lt;/code&gt; 에서 &lt;code&gt;ej&lt;/code&gt; 보다 자신의 상태를 기록하는 것이 먼저이므로 &lt;code&gt;ej&lt;/code&gt; 는 &lt;em&gt;out of cut&lt;/em&gt; 이고, 모순입니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="safetyandliveness"&gt;Safety and Liveness&lt;/h3&gt;

&lt;p&gt;분산시스템의 &lt;em&gt;correctness&lt;/em&gt; 와 관련해서 &lt;em&gt;safety&lt;/em&gt; 와 &lt;em&gt;liveness&lt;/em&gt; 란 개념이 있습니다. 이 둘은 주로 혼동되어 사용되는데, 둘을 구별하는 것은 매우 중요합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/liveness.png" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;distributed computation will terminate eventually &lt;/li&gt;
&lt;li&gt;every failure is eventually deteced by some non-faulty process&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/safety.png" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;there is no deadlock in a distributed transaction system&lt;/li&gt;
&lt;li&gt;no object is orphaned&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;accuracy&lt;/strong&gt; in failure detector&lt;/li&gt;
&lt;li&gt;no two processes decide on different values&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/liveness_and_safety.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;failure detector&lt;/em&gt; 나 &lt;em&gt;concensus&lt;/em&gt; 의 경우에서 볼 수 있듯이 &lt;em&gt;completeness&lt;/em&gt; 와 &lt;em&gt;accuracy&lt;/em&gt; 두 가지를 모두 충족하긴 힘듭니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/language_of_global_state.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;global snapshot&lt;/em&gt; 은 한 상태 &lt;code&gt;S&lt;/code&gt; 이고, 여기서 다른 스냅샷으로의 이동은 &lt;em&gt;casual step&lt;/em&gt; 을 따라 이동하는 것입니다. 따라서 &lt;em&gt;liveness&lt;/em&gt; 와, &lt;em&gt;safety&lt;/em&gt; 와 관련해 다음과 같은 특징이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/using_global_snapshot.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Chandy-Lamport&lt;/em&gt; 알고리즘은 &lt;em&gt;stable&lt;/em&gt; 한지를 검사하기 위해 사용할 수도 있습니다. 여기서 &lt;em&gt;stable&lt;/em&gt; 하다는 것은, 한번 참이면 그 이후에는 계속 참인 것을 말합니다. 이는 알고리즘이 &lt;em&gt;casual correctness&lt;/em&gt; 를 가지기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="refs"&gt;Refs&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href="http://ook.co/solutions/cloud-computing/"&gt;Title Image&lt;/a&gt; &lt;br&gt;
(2) &lt;strong&gt;Cloud Computing Concept 1&lt;/strong&gt; by &lt;em&gt;Indranil Gupta&lt;/em&gt;, Coursera  &lt;/p&gt;</content:encoded></item><item><title>Coding The Matrix 2, Vector Space</title><description>&lt;p&gt;&lt;img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""&gt;&lt;/p&gt;

&lt;h3 id="linearcombinations"&gt;Linear Combinations&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/linear_combinations.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;v1, ..., vn&lt;/code&gt; 이 주어졌을때 &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a1, ..., an&lt;/code&gt; 을 찾을 수 있을까요? &lt;/li&gt;
&lt;li&gt;있다면 &lt;em&gt;unique solution&lt;/em&gt; 인지 어떻게 알 수 있을까요?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="span"&gt;Span&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The set of all linear combinations of some vectors &lt;code&gt;v1, ..., vn&lt;/code&gt; is called &lt;strong&gt;span&lt;/strong&gt; of these vector&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/span.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;이브가 만약 위와 같은식을 만족한다는 사실을 알고 있다면, 패스워드의 모든&lt;/p&gt;</description><link>http://1ambda.github.io/coding-the-matrix-2/</link><guid isPermaLink="false">5f630834-a38f-4833-a4a3-8d465a1c0b31</guid><category>coursera</category><category>linear algebra</category><category>vector space</category><category>span</category><dc:creator>1ambda</dc:creator><pubDate>Wed, 04 Mar 2015 16:28:24 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""&gt;&lt;/p&gt;

&lt;h3 id="linearcombinations"&gt;Linear Combinations&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/linear_combinations.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;v1, ..., vn&lt;/code&gt; 이 주어졌을때 &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a1, ..., an&lt;/code&gt; 을 찾을 수 있을까요? &lt;/li&gt;
&lt;li&gt;있다면 &lt;em&gt;unique solution&lt;/em&gt; 인지 어떻게 알 수 있을까요?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="span"&gt;Span&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The set of all linear combinations of some vectors &lt;code&gt;v1, ..., vn&lt;/code&gt; is called &lt;strong&gt;span&lt;/strong&gt; of these vector&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/span.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;이브가 만약 위와 같은식을 만족한다는 사실을 알고 있다면, 패스워드의 모든 &lt;em&gt;span&lt;/em&gt; &lt;code&gt;{a1, ..., an}&lt;/code&gt; 에 대해서 적절한 &lt;em&gt;response&lt;/em&gt; 를 추출할 수 있습니다. 증명은 위처럼 간단합니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Let &lt;code&gt;V&lt;/code&gt; be a set of vectors if &lt;code&gt;v1, ..., vn&lt;/code&gt; are vectors such that &lt;code&gt;V&lt;/code&gt; = Span &lt;code&gt;{v1, ..., vn}&lt;/code&gt; then&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;we say &lt;code&gt;{v1, ..., vn}&lt;/code&gt; is a generating set for &lt;code&gt;V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;we refer to the vectors &lt;code&gt;v1, ..., vn&lt;/code&gt; as generators for &lt;code&gt;V&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;[x, y, z]&lt;/code&gt; = &lt;code&gt;x[1,0,0] + y[0,1,0] + z[0,0,1]&lt;/code&gt; 을 &lt;code&gt;R^3&lt;/code&gt; 의 &lt;em&gt;standard generator&lt;/em&gt; 라 부릅니다. &lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="geometryofsetsofvectors"&gt;Geometry of Sets of Vectors&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Span of the empty set:&lt;/em&gt; just the origin, &lt;strong&gt;Zero-dimensional&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Span&lt;/em&gt; &lt;code&gt;{[1,2], [3,4]}&lt;/code&gt;: all points in the plane, &lt;strong&gt;Two-dimensional&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Span&lt;/em&gt; &lt;code&gt;{[1,0,1.65], [0,1,1]}&lt;/code&gt; is a plain in three dimensions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;k&lt;/code&gt; 벡터의 &lt;em&gt;span&lt;/em&gt; 은 &lt;em&gt;k-dimensional&lt;/em&gt; 일까요? 아닙니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Span &lt;code&gt;{[0, 0]}&lt;/code&gt; 은 &lt;em&gt;zero-dimensional&lt;/em&gt; 입니다.&lt;/li&gt;
&lt;li&gt;Span &lt;code&gt;{[1,3], [2,6]}&lt;/code&gt; 은 &lt;em&gt;one-dimensional&lt;/em&gt; 입니다. &lt;/li&gt;
&lt;li&gt;Span &lt;code&gt;{[1,0,0], [0,1,0], [1,1,0]}&lt;/code&gt; 은 &lt;em&gt;two-dimensional&lt;/em&gt; 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러면 어떤 벡터 &lt;code&gt;v&lt;/code&gt; 가 있을때 &lt;em&gt;dimensionality&lt;/em&gt; 를 어떻게 알아낼 수 있을까요?&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/geometry_of_sets.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 볼 수 있듯이 &lt;em&gt;origin&lt;/em&gt; 을 포함하는 &lt;em&gt;geometry object&lt;/em&gt; 를 표현하는 방법은 두가지 입니다. 각각은 나름의 쓰임새가 있습니다.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;span&lt;/em&gt; of some vectors &lt;br&gt;
(2) 우변이 &lt;code&gt;0&lt;/code&gt; 인 &lt;em&gt;linear equation system&lt;/em&gt; 의 집합&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/two_representation1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/two_representation2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/common_representation1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;field&lt;/em&gt; 의 서브셋은 3가지 속성을 만족합니다. &lt;em&gt;field&lt;/em&gt; 를 &lt;code&gt;R&lt;/code&gt; 이라 하면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;subset contains the zero vector&lt;/li&gt;
&lt;li&gt;if subset contains &lt;code&gt;v&lt;/code&gt; then it contains &lt;code&gt;av&lt;/code&gt; for every scala &lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;if subset contains &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; then it contains &lt;code&gt;u+v&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/common_representation2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/common_representation3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;F^D&lt;/code&gt; 의 세가지 속성을 만족하는 &lt;em&gt;subset&lt;/em&gt; 을 &lt;strong&gt;vector space&lt;/strong&gt; 라 부릅니다. 그리고 &lt;code&gt;U&lt;/code&gt; 가 &lt;em&gt;vector space&lt;/em&gt; 고 &lt;em&gt;vector space&lt;/em&gt; &lt;code&gt;V&lt;/code&gt; 의 &lt;em&gt;subset&lt;/em&gt; 일때, &lt;code&gt;U&lt;/code&gt; 를 &lt;code&gt;V&lt;/code&gt; 의 &lt;em&gt;subspace&lt;/em&gt; 라 부릅니다.&lt;/p&gt;

&lt;p&gt;뒤에서 배울테지만 모든 &lt;code&gt;R^D&lt;/code&gt; 의 &lt;em&gt;subspace&lt;/em&gt; 는 &lt;em&gt;span&lt;/em&gt; &lt;code&gt;{v1, ..., vn}&lt;/code&gt; 과 &lt;code&gt;{x: a1 * x = 0, ..., an * x = 0}&lt;/code&gt; 의 형태로 쓸 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/abstract_vector_space.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;우리는 벡터에 대해 &lt;em&gt;sequence&lt;/em&gt; 나, &lt;em&gt;function&lt;/em&gt; 을 정의하지 않았습니다. 단순한 &lt;em&gt;operator&lt;/em&gt; 와 공리를 만족하는지, 그리고 &lt;em&gt;property&lt;/em&gt; &lt;code&gt;V1, V2, V3&lt;/code&gt; 정도만 따졌습니다. 벡터에 대한 이런 추상적 접근은 많은 장점이 있습니다. 그러나 이 수업에서는 사용하지 않겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/convex_hull.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="vectorspace"&gt;Vector Space&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/exclude_origin_line.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/exclude_origin_plain.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_space.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;벡터 &lt;code&gt;c&lt;/code&gt; 와 벡터 스페이스 &lt;code&gt;V&lt;/code&gt; 에 대해 &lt;code&gt;c + V&lt;/code&gt; 와 같은 형태를 &lt;em&gt;affine space&lt;/em&gt; 라 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;u1, u2, u3&lt;/code&gt; 를 담고있는 &lt;em&gt;plain&lt;/em&gt; 을 &lt;code&gt;u1 + V&lt;/code&gt; 형태로 표현하고 싶습니다. 어떻게 해야할까요?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;V&lt;/code&gt; 를 &lt;em&gt;span&lt;/em&gt; &lt;code&gt;{a, b}&lt;/code&gt; 라 하고 &lt;code&gt;a = u2 - u1&lt;/code&gt;, &lt;code&gt;b = u3 - u1&lt;/code&gt; 라 하면 &lt;code&gt;u1 + V&lt;/code&gt; 는 &lt;em&gt;plain&lt;/em&gt; 의 변환이지만, 그 자체로서 &lt;em&gt;plain&lt;/em&gt; 입니다&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;span&lt;/em&gt; &lt;code&gt;{a, b}&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 을 포함하므로 &lt;code&gt;u1&lt;/code&gt; + &lt;em&gt;span&lt;/em&gt; &lt;code&gt;{a, b}&lt;/code&gt; 는 &lt;code&gt;u1&lt;/code&gt; 를&lt;/li&gt;
&lt;li&gt;&lt;em&gt;span&lt;/em&gt; &lt;code&gt;{a, b}&lt;/code&gt; 는 &lt;code&gt;u2 - u1&lt;/code&gt; 도 을 포함하므로 &lt;code&gt;u1&lt;/code&gt; + &lt;em&gt;span&lt;/em&gt; &lt;code&gt;{a, b}&lt;/code&gt; 는 &lt;code&gt;u2&lt;/code&gt; 를&lt;/li&gt;
&lt;li&gt;&lt;em&gt;span&lt;/em&gt; &lt;code&gt;{a, b}&lt;/code&gt; 는 &lt;code&gt;u3 - u1&lt;/code&gt; 도 을 포함하므로 &lt;code&gt;u1&lt;/code&gt; + &lt;em&gt;span&lt;/em&gt; &lt;code&gt;{a, b}&lt;/code&gt; 는  &lt;code&gt;u3&lt;/code&gt; 를 포함합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 &lt;code&gt;u1&lt;/code&gt; + &lt;em&gt;span&lt;/em&gt; &lt;code&gt;{a, b}&lt;/code&gt; 는 &lt;code&gt;u1, u2, u3&lt;/code&gt; 를 모두 포함하는 평면입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;더 간단히 &lt;code&gt;ru1 + au2 + bu3&lt;/code&gt; (&lt;code&gt;r + a + b = 1&lt;/code&gt;) 로 &lt;em&gt;affine combination&lt;/em&gt; 을 표현할 수 있습니다. 그리고 더 &lt;em&gt;formal&lt;/em&gt; 하게 정의하면,&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_equation.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;affine space&lt;/em&gt; 를 &lt;em&gt;a solution set of a system of linear equations&lt;/em&gt; 으로 표현할 수 있습니다. 그런데, 역으로 이 솔루션이 &lt;em&gt;affine space&lt;/em&gt; 일까요?&lt;/p&gt;

&lt;p&gt;반례를 하나 들어보면 &lt;code&gt;1x = 1, 2x = 1&lt;/code&gt; 일때 솔루션은 없습니다. 그러나 벡터 스페이스 &lt;code&gt;V&lt;/code&gt; 는 &lt;em&gt;zero vector&lt;/em&gt; 를 가져야 하므로 &lt;em&gt;affine space&lt;/em&gt; &lt;code&gt;u + V&lt;/code&gt; 는 적어도 하나의 &lt;em&gt;vector&lt;/em&gt; 는 가져아합니다. 모순이 발생합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Theorem:&lt;/strong&gt; &lt;em&gt;solution set of a linear system&lt;/em&gt; 은 &lt;em&gt;empty&lt;/em&gt; 거나 &lt;em&gt;affine space&lt;/em&gt; 입니다. 증명은 아래와 같습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination_proof1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination_proof2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination_proof3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/number_of_solutions.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;지금까지 증명한 것은, &lt;code&gt;u1&lt;/code&gt; 이 &lt;em&gt;linear system&lt;/em&gt; 의 솔루션일때, &lt;code&gt;u1 + v&lt;/code&gt; (&lt;code&gt;v&lt;/code&gt; in &lt;code&gt;V&lt;/code&gt;) 도 솔루션이란 사실입니다. 여기서 &lt;code&gt;V&lt;/code&gt; 는 &lt;em&gt;homogeneous linear system&lt;/em&gt; 입니다. (우변이 &lt;code&gt;0&lt;/code&gt; 인)&lt;/p&gt;

&lt;p&gt;따라서 &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;unique solution&lt;/em&gt; 을 가질때는 &lt;code&gt;V&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 을 해로 가질 때이고&lt;/li&gt;
&lt;li&gt;&lt;em&gt;GF(2)&lt;/em&gt; 의 솔루션 수는 &lt;code&gt;0&lt;/code&gt; 이거나, &lt;code&gt;V&lt;/code&gt; 와 같습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="checksumfunction"&gt;Checksum function&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/checksum1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;corrupted&lt;/em&gt; 파일이 올바른 파일로 인식될 경우는 오리지널 바이너리 &lt;code&gt;p&lt;/code&gt; 에 대해 손상된 파일 &lt;code&gt;p+e&lt;/code&gt; 가 위 슬라이드의 방정식을 만족할 경우입니다. &lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/checksum2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;이 확률은 모든 가능한 &lt;code&gt;n&lt;/code&gt; 벡터에 대해 존재하는 솔루션의 수 이므로 굉장히 낮습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="refs"&gt;Refs&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href="http://colorsark.deviantart.com/art/3D-Cube-342632998"&gt;Title image&lt;/a&gt; &lt;br&gt;
(2) &lt;strong&gt;Coding the Matrix&lt;/strong&gt; by &lt;em&gt;Philip Klein&lt;/em&gt;  &lt;/p&gt;</content:encoded></item><item><title>Pattern Discovery 3</title><description>&lt;p&gt;&lt;img src="https://m1.behance.net/rendition/modules/7116731/disp/d18c13cd5b49bf40b41e6ef0610b26d3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;이번 시간에 배울 주제는 &lt;em&gt;Sequential Pattern Mining&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GSP (Generalized Sequential Patterns)&lt;/li&gt;
&lt;li&gt;Vertical Format-Based Mining: &lt;strong&gt;SPADE&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Pattern-Growth Methods: &lt;strong&gt;PrefixSpan&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Mining Closed Sequential Patterns: &lt;strong&gt;CloSpan&lt;/strong&gt;
Constrain-Based Sequential Pattern Mining&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;sequential pattern mining&lt;/em&gt; 은 다양한 곳에 사용됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;customer shopping sequences&lt;/li&gt;
&lt;li&gt;medial treatments&lt;/li&gt;
&lt;li&gt;web click streams, calling patterns&lt;/li&gt;
&lt;li&gt;program execution sequences (software engineering)&lt;/li&gt;&lt;/ul&gt;</description><link>http://1ambda.github.io/pattern-discovery-3/</link><guid isPermaLink="false">9d993973-15d9-4611-bb12-119343656a18</guid><category>coursera</category><category>pattern discovery</category><category>gSpan</category><category>closeGraph</category><dc:creator>1ambda</dc:creator><pubDate>Tue, 03 Mar 2015 16:02:54 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="https://m1.behance.net/rendition/modules/7116731/disp/d18c13cd5b49bf40b41e6ef0610b26d3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;이번 시간에 배울 주제는 &lt;em&gt;Sequential Pattern Mining&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GSP (Generalized Sequential Patterns)&lt;/li&gt;
&lt;li&gt;Vertical Format-Based Mining: &lt;strong&gt;SPADE&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Pattern-Growth Methods: &lt;strong&gt;PrefixSpan&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Mining Closed Sequential Patterns: &lt;strong&gt;CloSpan&lt;/strong&gt;
Constrain-Based Sequential Pattern Mining&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;sequential pattern mining&lt;/em&gt; 은 다양한 곳에 사용됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;customer shopping sequences&lt;/li&gt;
&lt;li&gt;medial treatments&lt;/li&gt;
&lt;li&gt;web click streams, calling patterns&lt;/li&gt;
&lt;li&gt;program execution sequences (software engineering)&lt;/li&gt;
&lt;li&gt;biological sequences (DNA)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;time-series DB&lt;/em&gt; 와는 다릅니다. 이건 일정 간격으로 로그가 저장된 것이고, &lt;em&gt;sequential pattern&lt;/em&gt; 은 &lt;em&gt;time stamp&lt;/em&gt; 가 붙은 것이라 보면 됩니다. 어찌 보면 [Process Mining][http://1ambda.github.io/process-mining-week1/] 이라 볼 수도 있겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;sequential pattern&lt;/em&gt; 은 크게 &lt;em&gt;gapped&lt;/em&gt; 와 &lt;em&gt;non-gapped&lt;/em&gt; 로 나누어집니다. 전자는 패턴 사이의 &lt;em&gt;gap&lt;/em&gt; 을 허용하고, 후자는 허용하지 않습니다. 모든 시퀀스가 중요하다는 뜻입니다. 예를 들어 웹사이트에서 &lt;em&gt;click stream&lt;/em&gt; 사이의 &lt;em&gt;gap&lt;/em&gt; 은 정말 중요할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/sequential_pattern_mining.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;sequential pattern mining&lt;/em&gt; 은 주어진 시퀀스에서 빈번한 서브시퀀스의 집합을 찾아냅니다. &lt;em&gt;element&lt;/em&gt; (&lt;code&gt;()&lt;/code&gt;) 또는 &lt;em&gt;event&lt;/em&gt; 라 부르는 단위가 &lt;em&gt;items&lt;/em&gt; 를 담고 있습니다. 그리고 &lt;code&gt;()&lt;/code&gt; 로 묶인 &lt;em&gt;item&lt;/em&gt; 의 순서는 중요하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="gsp"&gt;GSP&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;GSP&lt;/em&gt; 는 &lt;em&gt;apriori-based sequential pattern mining&lt;/em&gt; 기법입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/GSP.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;singleton&lt;/em&gt; 시퀀스를 기반으로 &lt;em&gt;length 1, 2&lt;/em&gt; 의 &lt;em&gt;candidates&lt;/em&gt; 를 만들고, &lt;em&gt;apriori pruning&lt;/em&gt; 을 적용합니다. 그러면, &lt;code&gt;36 + 15 = 51&lt;/code&gt; 의 &lt;em&gt;candidates&lt;/em&gt; 를 얻을 수 있습니다. &lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/GSP2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;데이터베이스를 지속적으로 스캔해가면서 &lt;em&gt;minimum support&lt;/em&gt; 를 통과하지 못하는 것들을 제거하고 위 과정을 반복하는 것이 &lt;em&gt;GSP Mining&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="spade"&gt;SPADE&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;SPADE (Sequential Pattern Mining in Vertical Data)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/SPADE.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;SID&lt;/em&gt; 뿐만 아니라 &lt;em&gt;element ID, EID&lt;/em&gt; 를 이용해서 테이블을 좌측처럼 하나 만듭니다. 그리고 이 테이블을 이용해서 우측 상단 테이블처럼 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; 등이 어느 &lt;em&gt;SID, EID&lt;/em&gt; 셋에서 나타나는지를 파악합니다. 패턴의 길이를 늘려가면서, 즉 테이블을 계속 조인해 나가면 패턴의 &lt;em&gt;support&lt;/em&gt; 를 구할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="prefixspan"&gt;PrefixSpan&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Pattern-Growth&lt;/em&gt; 기반의 알고리즘인 &lt;em&gt;PrefixSpan&lt;/em&gt; 을 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/prefix_span1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;먼저 &lt;em&gt;length-1&lt;/em&gt; 패턴을 찾고 이를 기반으로 &lt;em&gt;projected DB&lt;/em&gt; 를 만들어가며 마이닝을 진행합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/prefix_span2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;단계가 지나면 지날수록 &lt;em&gt;candidate&lt;/em&gt; 가 생겨나는 비율이 줄고, &lt;em&gt;projected DB&lt;/em&gt; 자체도 줄어든다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/prefix_span3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;다만 &lt;em&gt;projected DB&lt;/em&gt; 에서 많은 중복이 발생하기 때문에 이를 해결하기 위해 &lt;em&gt;pseudo projection&lt;/em&gt; 을 이용할 수 있습니다. &lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="clospan"&gt;CloSpan&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;CloSpan&lt;/em&gt; 은 &lt;em&gt;closed sequential pattern&lt;/em&gt; 을 마이닝하는 알고리즘입니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;closed pattern&lt;/em&gt; 을 다시 복습해 보면&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;closed pattern: A pattern(itemset) &lt;code&gt;X&lt;/code&gt; is closed if &lt;code&gt;X&lt;/code&gt; is frequent, and there exists no super pattern &lt;code&gt;Y&lt;/code&gt; ⊃ &lt;code&gt;X&lt;/code&gt;, with the same support as &lt;code&gt;X&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를 들어 &lt;code&gt;&amp;lt;abc&amp;gt;:20, &amp;lt;abcd&amp;gt;:20, &amp;lt;abcde&amp;gt;:15&lt;/code&gt; 라면 &lt;code&gt;&amp;lt;abcd&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;abcde&amp;gt;&lt;/code&gt; 는 &lt;em&gt;closed pattern&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/clo_span.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;closed pattern&lt;/em&gt; 을 마이닝하는 이유는 이전에도 말했듯이 중복된 패턴을 피하기 위함입니다. 위 그림처럼 &lt;em&gt;redundant search space&lt;/em&gt; 를 &lt;em&gt;pruning&lt;/em&gt; 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="constraintbased"&gt;Constraint-Based&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/constraint_based_mining.png" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Data anti monotonic:&lt;/strong&gt; &lt;code&gt;S&lt;/code&gt; 가 제약조건 &lt;code&gt;c&lt;/code&gt; 를 위반했을때, 나머지 부분인 &lt;code&gt;s&lt;/code&gt; 를 더해도 여전히 위반이라면 &lt;code&gt;s&lt;/code&gt; 를 제거할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sunccint:&lt;/strong&gt; 제약조건 &lt;code&gt;c&lt;/code&gt; 를 기준으로 데이터를 직접 조작합니다. 예를 들어 &lt;code&gt;S&lt;/code&gt; 가 &lt;code&gt;{i-phone, MacAir}&lt;/code&gt; 를 반드시 포함해야 한다고 할때, 그렇지 못하면 &lt;code&gt;S&lt;/code&gt; 를 제거할 수 있습니다&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Convertible:&lt;/strong&gt; 아이템을 정렬해서 제약조건을 &lt;em&gt;anti-monotonic&lt;/em&gt; 이나 &lt;em&gt;monotonic&lt;/em&gt; 등으로 바꿉니다. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/time_based_constraints.png" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;order constaint&lt;/em&gt; 는 &lt;em&gt;anti-monotonic&lt;/em&gt; 입니다&lt;/li&gt;
&lt;li&gt;&lt;em&gt;min, max gap&lt;/em&gt; 제약조건은 &lt;em&gt;succinct&lt;/em&gt; 입니다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;max span&lt;/em&gt; 제약조건은 처음과 마지막 &lt;em&gt;element&lt;/em&gt; 의 시간 간격입니다. 이것도 &lt;em&gt;succinct&lt;/em&gt; 입니다&lt;/li&gt;
&lt;li&gt;&lt;em&gt;window size&lt;/em&gt; 제약조건은 한 &lt;em&gt;element&lt;/em&gt; 내부에서 &lt;em&gt;event&lt;/em&gt; 발생 회수를 제한하는 조건입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/episode_pattern_mining.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;정규표현식과 &lt;em&gt;episode&lt;/em&gt; 는 &lt;em&gt;sequential pattern&lt;/em&gt; 의 다른 표현 방법입니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="graphpatternmining"&gt;Graph Pattern Mining&lt;/h3&gt;

&lt;p&gt;이번 시간에 배울 내용은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Apriori-Based Graph Pattern Mining&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gSpan:&lt;/strong&gt; A Pattern-Growth-Based Method&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CloseGraph:&lt;/strong&gt; Mining Closed Graph Pattern&lt;/li&gt;
&lt;li&gt;Graph Indexing&lt;/li&gt;
&lt;li&gt;Top-K Large Structural Patterns in a Massive Network&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/graph_support.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Graph&lt;/em&gt; 에서 &lt;em&gt;support&lt;/em&gt; 란 &lt;em&gt;subgraph&lt;/em&gt; 가 나타나는 수 입니다. &lt;/p&gt;

&lt;p&gt;그래프 패턴 마이닝을 위해서 다양한 방법을 이용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;(1) Generation of candidate subgraphs&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Apriori (&lt;strong&gt;FSG&lt;/strong&gt;) vs Pattern Growth(&lt;strong&gt;gSpan&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) Search Order&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Breadth vs Depth&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(3) Elimination of duplicate subgraphs&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Passive vs Active (e.g &lt;strong&gt;gSpan&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(4) Support calculation&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Store embeddings (e.g &lt;strong&gt;GASTON, FFSM, MoFA&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(5) Order of Pattern Discovery&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Path -&gt; Tree -&gt; Graph (&lt;strong&gt;GASTON&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="aprioribasedapproach"&gt;Apriori-Based Approach&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/apriori_based_approache.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Apriori Property&lt;/em&gt; 에 의해서, 어떤 그래프가 &lt;code&gt;G&lt;/code&gt; 가 빈번한 경우는, &lt;em&gt;*모든 *&lt;/em&gt;서브그래프들도 빈번할 경우뿐입니다. &lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;k&lt;/code&gt; 개의 &lt;em&gt;edge, vertex&lt;/em&gt; 를 가진 &lt;em&gt;frequent&lt;/em&gt; 서브그래프에서 공통된 엣지가 많은 그래프를 골라 &lt;code&gt;k+1&lt;/code&gt; 개의 &lt;em&gt;edge, vertex&lt;/em&gt; 그래프를 만듭니다. 그리고 여기서 이 그래프의 &lt;strong&gt;모든 서브 그래프가&lt;/strong&gt; &lt;em&gt;frequent&lt;/em&gt; 한지 검사하여 &lt;em&gt;pruning&lt;/em&gt; 을 진행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/vertex_edge_growing.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;vertex&lt;/em&gt; 기반으로 확장해 나가는 알고리즘으로 &lt;em&gt;AGM (Apriori-based Graph Mining)&lt;/em&gt; 이 있습니다. &lt;em&gt;edge&lt;/em&gt; 를 확장해 나가는 알고리즘으로는 &lt;em&gt;FSG (Frequent Sub Graphs)&lt;/em&gt; 가 있는데, 일반적으로 더 작은 컴포넌트인 &lt;em&gt;edge&lt;/em&gt; 를 확장시켜 나가는 방법이 더 효율적이라고 알려져 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="gspanapatterngrowthapproach"&gt;gSpan: A Pattern Growth Approach&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/pattern_growth_approach_gSpan.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;먼저 &lt;code&gt;k&lt;/code&gt;-&lt;em&gt;edge&lt;/em&gt; 그래프를 보고, 여기에 하나의 &lt;em&gt;edge&lt;/em&gt; 를 더해 &lt;code&gt;k+1&lt;/code&gt; &lt;em&gt;edge&lt;/em&gt; 그래프도 빈번하다면 이 과정을 계속 반복해 나아갑니다. 이 방법은 많은 수의 &lt;em&gt;subgraph&lt;/em&gt; 가 중복된다는 단점이 있습니다. &lt;/p&gt;

&lt;p&gt;이 문제를 해결하기 위해 &lt;em&gt;gSpan&lt;/em&gt; 에서는 생성할 &lt;em&gt;subgraph&lt;/em&gt; 의 순서를 미리 정의해 놓고 &lt;em&gt;depth-first search&lt;/em&gt; 를 이용해서 &lt;em&gt;graph&lt;/em&gt; 를 &lt;em&gt;sequence&lt;/em&gt; 처럼 펼칩니다. &lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/gspan_example.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서는 가장 작은 인덱스를 먼저 선택하는 &lt;em&gt;DFS&lt;/em&gt; 를 이용해서 우측처럼 시퀀스를 만들었습니다. &lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="closegraph"&gt;CloseGraph&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/closed_graph.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 개의 &lt;em&gt;edge&lt;/em&gt; 를 가진 그래프에는 &lt;code&gt;2^n&lt;/code&gt; 개의 서브그래프가 존재합니다. 정말 어마어마한 숫자입니다. 이런 &lt;em&gt;explosion&lt;/em&gt; 문제를 해결하기 위해 &lt;em&gt;closed frequent subgraph&lt;/em&gt; 를 이용합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A frequent graph &lt;code&gt;G&lt;/code&gt; is &lt;strong&gt;closed&lt;/strong&gt; if there exists no supergraph of &lt;code&gt;G&lt;/code&gt; that carries the same support as &lt;code&gt;G&lt;/code&gt;'&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;loseless compression&lt;/em&gt; 이기 때문에 결과는 &lt;em&gt;complete&lt;/em&gt; 합니다. 따라서 &lt;em&gt;closed graph pattern&lt;/em&gt; 을 마이닝 하면 좀 더 효율적입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/close_graph_algorithm.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;G&lt;/code&gt; 가 있을 때마다 &lt;code&gt;G1&lt;/code&gt; 이 존재한다면 다른 &lt;em&gt;supergraph&lt;/em&gt; 를 살펴볼 필요가 없습니다. 이는 &lt;code&gt;G1&lt;/code&gt; 이 &lt;code&gt;G&lt;/code&gt; 를 커버할 수 있기 때문입니다. 아래는 다른 알고리즘과의 성능 비교입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/close_graph_performance.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="graphindex"&gt;Graph Index&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/graph_indexing.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;그림에서 볼 수 있듯이 &lt;em&gt;path index&lt;/em&gt; 는 &lt;code&gt;(a)&lt;/code&gt; &lt;code&gt;(b)&lt;/code&gt; 를 쿼리 &lt;code&gt;Q&lt;/code&gt; 에 대해 필터링 하지 못할 수 있습니다. 따라서 그래프를 직접 인덱싱하는 것이 필요한데, 문제는 그래프를 인덱싱할때 서브그래프가 너무 많다는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/gIndex.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;frequent substructure&lt;/em&gt; 만 인덱스 하되, &lt;em&gt;size-increasing support threshold&lt;/em&gt; 를 이용하면 됩니다. 즉 사이즈가 증가할수록 &lt;em&gt;min support&lt;/em&gt; 도 올리는 것인데, 이는 큰 그래프일수록 작은 그래프에서 이미 &lt;em&gt;indexed&lt;/em&gt; 되었을 수 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;em&gt;discriminative substructure&lt;/em&gt; 를 인덱싱해야합니다. 이는 기존과 비슷한 그래프를 인덱싱 할 필요는 없기 때문이지요. &lt;em&gt;discriminative&lt;/em&gt; 그래프를 선택하기 위해서 슬라이드처럼 새로운 그래프 &lt;code&gt;x&lt;/code&gt; 가 기존의 인덱싱된 그래프 &lt;code&gt;f1, f2, ...,&lt;/code&gt; 을 얼마나 커버하는지를 계산하여 작으면 인덱싱합니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="spidermine"&gt;Spider Mine&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/spider_mine1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;pattern fusion&lt;/em&gt; 과 비슷하게, 작은 컴포넌트인 &lt;em&gt;spider&lt;/em&gt; 가 모여 결국에는 큰 컴포넌트를 만든다는 기본적인 아이디어로부터 시작합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;r-Spider&lt;/em&gt; 는 &lt;em&gt;vertex&lt;/em&gt; &lt;code&gt;u&lt;/code&gt; 로부터 &lt;code&gt;r&lt;/code&gt; 홉 안에 도달할 수 있는 &lt;em&gt;frequent&lt;/em&gt; 패턴입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/spider_mine2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;알고리즘이 수행되는 동안 &lt;em&gt;spider mine&lt;/em&gt; 알고리즘은 &lt;em&gt;large pattern&lt;/em&gt; 을 유지하고 &lt;em&gt;small pattern&lt;/em&gt; 을 &lt;em&gt;pruning&lt;/em&gt; 합니다. 그 이유는 작은 패턴일수록 &lt;em&gt;random draw&lt;/em&gt; 에서 &lt;em&gt;hit&lt;/em&gt; 할 확률이 낮고, 했다 하더라도 여러번 &lt;em&gt;hit&lt;/em&gt; 할 확률은 더 낮기 때문입니다. &lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="patternbasedclassification"&gt;Pattern-Based Classification&lt;/h3&gt;

&lt;p&gt;이번 챕터에서 배울 내용은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pattern-Based Classification&lt;/li&gt;
&lt;li&gt;Associative Classification&lt;/li&gt;
&lt;li&gt;Discriminative Pattern-Based Classification&lt;/li&gt;
&lt;li&gt;Direct Mining of Discriminative Patterns&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/pattern_based_why.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;frequent pattern mining&lt;/em&gt; 과 &lt;em&gt;classification&lt;/em&gt; 을 조합하면 더 심도있고, 다양한 데이터에 대한 분석이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/pattern_based_example.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="associativeclassificationcbacmar"&gt;Associative Classification: CBA, CMAR&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/classification_CBA.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/CMAR.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="discriminativeclassification"&gt;Discriminative Classification&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/discriminative1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/discriminative2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;당연한 이야기지만 &lt;em&gt;single item&lt;/em&gt; 보다는 &lt;code&gt;k&lt;/code&gt; 개의 아이템셋이 더 많은 &lt;em&gt;information gain&lt;/em&gt; 을 만듭니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/discriminative3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;그리고 위 슬라이드에서 볼 수 있듯이, &lt;em&gt;frequent, but not too frequent&lt;/em&gt;  한 패턴이 &lt;em&gt;discriminative&lt;/em&gt; 하게 적용됨을 알 수 있습니다. (&lt;em&gt;info gain&lt;/em&gt; 이 더 많다는 뜻)&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="ddpmine"&gt;DDP Mine&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/DDPMine1.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;frequent pattern mining&lt;/em&gt; 후에 &lt;em&gt;discriminative pattern&lt;/em&gt; 을 얻는 것은 계산적으로 비쌉니다. 따라서 바로 &lt;em&gt;discriminative pattern&lt;/em&gt; 을 얻을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/DDPMine2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;알고리즘은 이렇습니다. 매 이터레이션마다 가장 &lt;em&gt;discriminative power&lt;/em&gt; 가 큰 &lt;em&gt;feature&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; 를 고르고, &lt;code&gt;D&lt;/code&gt; 에서 &lt;code&gt;f&lt;/code&gt; 에 의해 커버 되는 인스턴스 &lt;code&gt;D&lt;/code&gt; 를 제거합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/DDPMine3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="refs"&gt;Refs&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href="https://www.behance.net/gallery/625042/Icon-and-pattern-with-a-marketing-theme"&gt;Title image&lt;/a&gt; &lt;br&gt;
(2) &lt;strong&gt;Pattern Discovery&lt;/strong&gt; by &lt;em&gt;Jiawei Han&lt;/em&gt; &lt;/p&gt;</content:encoded></item><item><title>Articles</title><description>&lt;h3 id="scala"&gt;Scala&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Scalaz&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-1-state/"&gt;Easy Scalaz 1, State&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/"&gt;Easy Scalaz 2, Monad Transformer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/"&gt;Easy Scalaz 3, ReaderWriterState with Kleisli&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/"&gt;Easy Scalaz 4, Yoneda, Coyonead, Free, Trampoline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[Easy Scalaz 5, ST, IO]&lt;/li&gt;
&lt;li&gt;[Easy Scalaz 6, Stream]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Monocle&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/scala-monocle-tutorial/"&gt;Scala Lens Library, Monocle&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Functional Programming in Scala&lt;/strong&gt; by &lt;em&gt;Martin Odersky&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/functional-programming-in-scala-chapter-1/"&gt;Chapter 1&lt;/a&gt; &lt;br&gt;
&lt;a href="http://1ambda.github.io/functional-programming-in-scala-chapter-2/"&gt;Chapter 2&lt;/a&gt; &lt;br&gt;
&lt;a href="http://1ambda.github.io/functional-programming-in-scala-chapter-3/"&gt;Chapter&lt;/a&gt;&lt;/p&gt;</description><link>http://1ambda.github.io/articles/</link><guid isPermaLink="false">9666f26e-e434-403f-95b1-8e667199693c</guid><category>1ambda</category><dc:creator>1ambda</dc:creator><pubDate>Sat, 28 Feb 2015 16:50:51 GMT</pubDate><content:encoded>&lt;h3 id="scala"&gt;Scala&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Scalaz&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-1-state/"&gt;Easy Scalaz 1, State&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/"&gt;Easy Scalaz 2, Monad Transformer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/"&gt;Easy Scalaz 3, ReaderWriterState with Kleisli&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/"&gt;Easy Scalaz 4, Yoneda, Coyonead, Free, Trampoline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[Easy Scalaz 5, ST, IO]&lt;/li&gt;
&lt;li&gt;[Easy Scalaz 6, Stream]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Monocle&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/scala-monocle-tutorial/"&gt;Scala Lens Library, Monocle&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Functional Programming in Scala&lt;/strong&gt; by &lt;em&gt;Martin Odersky&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/functional-programming-in-scala-chapter-1/"&gt;Chapter 1&lt;/a&gt; &lt;br&gt;
&lt;a href="http://1ambda.github.io/functional-programming-in-scala-chapter-2/"&gt;Chapter 2&lt;/a&gt; &lt;br&gt;
&lt;a href="http://1ambda.github.io/functional-programming-in-scala-chapter-3/"&gt;Chapter 3&lt;/a&gt; &lt;br&gt;
&lt;a href="http://1ambda.github.io/functional-programming-in-scala-chapter-4/"&gt;Chapter 4&lt;/a&gt; &lt;br&gt;
&lt;a href="http://1ambda.github.io/functional-programming-in-scala-chapter-5/"&gt;Chapter 5&lt;/a&gt; &lt;br&gt;
&lt;a href="http://1ambda.github.io/functional-programming-in-scala-chapter-6/"&gt;Chapter 6&lt;/a&gt; &lt;br&gt;
&lt;a href="http://1ambda.github.io/functional-programming-in-scala-chapter-7/"&gt;Chapter 7&lt;/a&gt;  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reactive Programming&lt;/strong&gt; by &lt;em&gt;Martin Odersky&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/reactive-programming-1/"&gt;Chapter 1&lt;/a&gt; - Monads, Random Generators &lt;br&gt;
&lt;a href="http://1ambda.github.io/reactive-programming-2/"&gt;Chapter 2&lt;/a&gt; - Stateful Object &lt;br&gt;
&lt;a href="http://1ambda.github.io/reactive-programming-3/"&gt;Chapter 3&lt;/a&gt; - Try, Future, Promise &lt;br&gt;
&lt;a href="http://1ambda.github.io/reactive-programming-4/"&gt;Chapter 4&lt;/a&gt; - Observable, Rx, Scheduler &lt;br&gt;
&lt;a href="http://1ambda.github.io/reactive-programming-5/"&gt;Chapter 5&lt;/a&gt; - Actor   &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Articles&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/new-to-play-framework-2/"&gt;new to Play Framework2&lt;/a&gt; &lt;br&gt;
&lt;a href="http://1ambda.github.io/partial-functions-scala/"&gt;Partial Functions, Scala&lt;/a&gt;  &lt;/p&gt;

&lt;h3 id="haskell"&gt;Haskell&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Introduction to Functional Programming using Haskell&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/haskell-intro1"&gt;Chapter 1&lt;/a&gt; - Basics &lt;br&gt;
&lt;a href="http://1ambda.github.io/haskell-intro2"&gt;Chapter 2&lt;/a&gt; - List Comprehension &lt;br&gt;
&lt;a href="http://1ambda.github.io/haskell-intro3"&gt;Chapter 3&lt;/a&gt; - Recursion, Higher Order Function &lt;br&gt;
&lt;a href="http://1ambda.github.io/haskell-intro4"&gt;Chapter 4&lt;/a&gt; - Monad &lt;br&gt;
&lt;a href="http://1ambda.github.io/haskell-intro5"&gt;Chapter 5&lt;/a&gt; - IO Monad &lt;br&gt;
&lt;a href="http://1ambda.github.io/haskell-intro6"&gt;Chapter 6&lt;/a&gt; - Type and Class &lt;br&gt;
&lt;a href="http://1ambda.github.io/haskell-intro7"&gt;Chapter 7&lt;/a&gt; - The Countdown Problem &lt;br&gt;
&lt;a href="http://1ambda.github.io/haskell-intro8"&gt;Chapter 8&lt;/a&gt; - Lazy Evaluation, Strict &lt;br&gt;
&lt;a href="http://1ambda.github.io/haskell-intro9"&gt;Chapter 9&lt;/a&gt; - Induction &lt;br&gt;
&lt;a href="http://1ambda.github.io/a-poor-mans-concurrency-monad"&gt;Poor Man's Concurrency Monad&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="machinelearning"&gt;Machine Learning&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Machine Learning&lt;/strong&gt; by &lt;em&gt;Andrew Ng&lt;/em&gt;, Coursera&lt;/p&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/machine-learning-week-1/"&gt;Chapter 1&lt;/a&gt; - Linear Regression &lt;br&gt;
&lt;a href="http://1ambda.github.io/machine-learning-week-2/"&gt;Chapter 2&lt;/a&gt; - Gradient Descent &lt;br&gt;
&lt;a href="http://1ambda.github.io/machine-learning-week-3/"&gt;Chapter 3&lt;/a&gt; - Logistic Regression &lt;br&gt;
&lt;a href="http://1ambda.github.io/machine-learning-week-4/"&gt;Chapter 4&lt;/a&gt; - Neural Network &lt;br&gt;
&lt;a href="http://1ambda.github.io/machine-learning-week-5/"&gt;Chapter 5&lt;/a&gt; - Back Propagation &lt;br&gt;
&lt;a href="http://1ambda.github.io/machine-learning-week-6/"&gt;Chapter 6&lt;/a&gt; - Practical Advices &lt;br&gt;
&lt;a href="http://1ambda.github.io/machine-learning-week-7/"&gt;Chapter 7&lt;/a&gt; - Support Vector Machine &lt;br&gt;
&lt;a href="http://1ambda.github.io/machine-learning-week-8/"&gt;Chapter 8&lt;/a&gt; - K-means, PCA Details &lt;br&gt;
&lt;a href="http://1ambda.github.io/machine-learning-week-9/"&gt;Chapter 9&lt;/a&gt; - Anomaly Detection, Recommender System &lt;br&gt;
&lt;a href="http://1ambda.github.io/machine-learning-week-10/"&gt;Chapter 10&lt;/a&gt; - Stochastic Gradient, Synthetic Data, Ceiling Analysis  &lt;/p&gt;

&lt;h3 id="algorithm"&gt;Algorithm&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Algorithm: Design and Analysis Part 1&lt;/strong&gt; by &lt;em&gt;Tim Roughgarden&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;(1) &lt;a href="http://1ambda.github.io/divide-and-conquer/"&gt;Divide and Conquer&lt;/a&gt; &lt;br&gt;
(2) &lt;a href="http://1ambda.github.io/randomized-selection/"&gt;Randomized Selection&lt;/a&gt; &lt;br&gt;
(3) &lt;a href="http://1ambda.github.io/graphs-the-contraction-algorithm/"&gt;Graphs, The Contraction Algorithm&lt;/a&gt; &lt;br&gt;
(4) &lt;a href="http://1ambda.github.io/graph-search-and-connectivity/"&gt;Graph Search and Connectivity&lt;/a&gt; &lt;br&gt;
(5) &lt;a href="http://1ambda.github.io/dijkstra-heap-balanced-tree/"&gt;Dijkstra, Heap, Red-Black Tree&lt;/a&gt; &lt;br&gt;
(6) &lt;a href="http://1ambda.github.io/hash-table-universal-hashing-bloom-filters/"&gt;Hash Table, Universal Hashing, Bloom filters&lt;/a&gt;  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algorithms, Part 1&lt;/strong&gt; by &lt;em&gt;Robert Sedgewick&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;(1) &lt;a href="http://1ambda.github.io/union-find-algorithms-week-1/"&gt;Union Find&lt;/a&gt; &lt;br&gt;
(2) &lt;a href="http://1ambda.github.io/analysis-of-algorithms/"&gt;Analysis of Algorithms&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algorithms, Part 2&lt;/strong&gt; by &lt;em&gt;Robert Sedgewick&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;(1) &lt;a href="http://1ambda.github.io/graph-challenges-minimum-spanning-trees"&gt;Spanning Tree, Shortest Paths&lt;/a&gt; &lt;br&gt;
(2) &lt;a href="http://1ambda.github.io/radix-sort-suffix-sort"&gt;Radix Sort, Suffix Sort&lt;/a&gt; &lt;br&gt;
(3) &lt;a href="http://1ambda.github.io/r-way-ternary-search-tries/"&gt;R-way, Ternary Tries&lt;/a&gt; &lt;br&gt;
(4) &lt;a href="http://1ambda.github.io/substring-search/"&gt;KMP, Boyer-Moore, Rabin-Karp&lt;/a&gt; &lt;br&gt;
(5) &lt;a href="http://1ambda.github.io/maximum-flow/"&gt;Maximum Flow (Ford-Fulkerson)&lt;/a&gt; &lt;br&gt;
(6) &lt;a href="http://1ambda.github.io/algorithm-data-compression/"&gt;Data Compression, Huffman, LZW&lt;/a&gt;   &lt;/p&gt;

&lt;h3 id="artificialintelligence"&gt;Artificial Intelligence&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Artificial Intelligence (CS188)&lt;/strong&gt; by &lt;em&gt;Dan Klein, Pieter Abbeel&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;(1) &lt;a href="http://1ambda.github.io/artificial-intelligence-1"&gt;Intro&lt;/a&gt; &lt;br&gt;
(2) &lt;a href="http://1ambda.github.io/artificial-intelligence-2"&gt;Search&lt;/a&gt;  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Artificial Intelligence Planning&lt;/strong&gt; by &lt;em&gt;Dr.Gerhard Wickler&lt;/em&gt;, &lt;em&gt;Prof. Austin Tate&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;(1) &lt;a href="http://1ambda.github.io/ai-planning-1"&gt;Intro&lt;/a&gt; &lt;br&gt;
(2) &lt;a href="http://1ambda.github.io/ai-planning-2"&gt;A*, STRIPS, forward and backward search&lt;/a&gt; &lt;br&gt;
(3) &lt;a href="http://1ambda.github.io/ai-planning-3"&gt;PSP, PoP&lt;/a&gt; &lt;br&gt;
(4) &lt;a href="http://1ambda.github.io/ai-planning-4"&gt;STN, HTN&lt;/a&gt;  &lt;/p&gt;

&lt;h3 id="cloudcomputing"&gt;Cloud Computing&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Cloud Computing Concept 1&lt;/strong&gt; by &lt;em&gt;Indranil Gupta&lt;/em&gt;, Coursera&lt;/p&gt;

&lt;p&gt;(1) &lt;a href="http://1ambda.github.io/cloud-computing-1-1/"&gt;MapReduce&lt;/a&gt; &lt;br&gt;
(2) &lt;a href="http://1ambda.github.io/cloud-computing-gossip-protocol/"&gt;Gossip Protocol&lt;/a&gt; &lt;br&gt;
(3) &lt;a href="http://1ambda.github.io/cloud-computing-membership-protocol/"&gt;Membership Protocol&lt;/a&gt; &lt;br&gt;
(4) &lt;a href="http://1ambda.github.io/cloud-computing-p2p-systems/"&gt;P2P Systems&lt;/a&gt; &lt;br&gt;
(4) &lt;a href="http://1ambda.github.io/cloud-computing-snapshot/"&gt;Global Snapshot&lt;/a&gt; &lt;br&gt;
(4) &lt;a href="http://1ambda.github.io/cloud-computing-multicast/"&gt;Multicast&lt;/a&gt; &lt;br&gt;
(4) &lt;a href="http://1ambda.github.io/cloud-computing-paxos/"&gt;Paxos&lt;/a&gt;  &lt;/p&gt;

&lt;h3 id="dataanalysis"&gt;Data Analysis&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Pattern Discovery&lt;/strong&gt; by &lt;em&gt;Jiawei Han&lt;/em&gt;, Coursera&lt;/p&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/pattern-discovery-1/"&gt;Chapter 1&lt;/a&gt; - Apriori, FP Growth &lt;br&gt;
&lt;a href="http://1ambda.github.io/pattern-discovery-2/"&gt;Chapter 2&lt;/a&gt; - Null-invariant, Pattern-Fusion, Constaint   &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Intro to Computational Thinking and Data Science&lt;/strong&gt;, edx&lt;/p&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/edx-600-2x-1/"&gt;Chapter 1&lt;/a&gt; - Modeling &lt;br&gt;
&lt;a href="http://1ambda.github.io/edx-600-2x-2/"&gt;Chapter 2&lt;/a&gt; - Monte Carlo Simulation &lt;br&gt;
&lt;a href="http://1ambda.github.io/edx-600-2x-3/"&gt;Chapter 3&lt;/a&gt; - Optimization Problem &lt;br&gt;
&lt;a href="http://1ambda.github.io/edx-600-2x-4/"&gt;Chapter 4&lt;/a&gt; - State Modeling, Hierarchical Clustering   &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Coding The Matrix&lt;/strong&gt; by &lt;em&gt;Philip Klein&lt;/em&gt;, Coursera&lt;/p&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/coding-the-matrix-1/"&gt;Chapter 1&lt;/a&gt; - Function, Field, Vector &lt;br&gt;
&lt;a href="http://1ambda.github.io/coding-the-matrix-w/"&gt;Chapter 2&lt;/a&gt; - Vector Space &lt;br&gt;
&lt;a href="http://1ambda.github.io/coding-the-matrix-e/"&gt;Chapter 3&lt;/a&gt; - Matrix  &lt;/p&gt;

&lt;h3 id="processmining"&gt;Process Mining&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Process Mining&lt;/strong&gt; by &lt;em&gt;Wil Van der Alast&lt;/em&gt;, Coursera&lt;/p&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/process-mining-week1/"&gt;Week 1&lt;/a&gt; - Process Mining Intro &lt;br&gt;
&lt;a href="http://1ambda.github.io/process-mining-week2/"&gt;Week 2&lt;/a&gt; - Alpha Algorithm &lt;br&gt;
&lt;a href="http://1ambda.github.io/process-mining-week3/"&gt;Week 3&lt;/a&gt; - Metric, C-nets &lt;br&gt;
&lt;a href="http://1ambda.github.io/process-mining-week4/"&gt;Week 4&lt;/a&gt; - Conformance Checking, Dotted Chart &lt;br&gt;
&lt;a href="http://1ambda.github.io/process-mining-week5/"&gt;Week 5&lt;/a&gt; - Decision, Social, Organization Mining  &lt;/p&gt;

&lt;h3 id="java"&gt;Java&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Articles&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/java-interview-questions-collection-framework/"&gt;Java Interview Questions - Collection Framework&lt;/a&gt;  &lt;/p&gt;

&lt;h3 id="javascript"&gt;Javascript&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://1ambda.github.io/javascript-object-inheritance/"&gt;Javascript Inheritance Details&lt;/a&gt; &lt;br&gt;
&lt;a href="http://1ambda.github.io/angular-providers/"&gt;Angular, Providers&lt;/a&gt;  &lt;/p&gt;</content:encoded></item><item><title>Cloud Computing, P2P Systems</title><description>&lt;p&gt;&lt;img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;P2P 시스템의 기술들은 &lt;em&gt;cloud computing&lt;/em&gt; 의 많은 분야에서 활용됩니다. 뒤에서 배울 &lt;em&gt;Chord P2P hashing&lt;/em&gt; 같은 경우는 &lt;em&gt;Cassandra&lt;/em&gt;, &lt;em&gt;Voldmort&lt;/em&gt; 등의 &lt;em&gt;key-value store&lt;/em&gt; 에서 쓰이고 있습니다. &lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="napster"&gt;Napster&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/napster.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;최초에 &lt;em&gt;peer&lt;/em&gt; 는 서버에게 메세지를 보내 P2P 시스템에 가입했다는 사실을 알립니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Napster&lt;/em&gt; 에서는 중앙에 서버를 두어, 파일이 저장된 &lt;em&gt;peer&lt;/em&gt; 를 기록합니다. 각 &lt;em&gt;peer&lt;/em&gt; 는 파일이&lt;/p&gt;</description><link>http://1ambda.github.io/cloud-computing-p2p-systems/</link><guid isPermaLink="false">6e527ab7-0598-4177-b199-dd4ef466f537</guid><category>coursera</category><category>cloud computing</category><category>P2P</category><category>Napster</category><category>Gnutella</category><category>BitTorrent</category><category>FastTrack</category><category>Chord</category><category>Pastry</category><category>Kelips</category><dc:creator>1ambda</dc:creator><pubDate>Sat, 28 Feb 2015 16:18:25 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;P2P 시스템의 기술들은 &lt;em&gt;cloud computing&lt;/em&gt; 의 많은 분야에서 활용됩니다. 뒤에서 배울 &lt;em&gt;Chord P2P hashing&lt;/em&gt; 같은 경우는 &lt;em&gt;Cassandra&lt;/em&gt;, &lt;em&gt;Voldmort&lt;/em&gt; 등의 &lt;em&gt;key-value store&lt;/em&gt; 에서 쓰이고 있습니다. &lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="napster"&gt;Napster&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/napster.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;최초에 &lt;em&gt;peer&lt;/em&gt; 는 서버에게 메세지를 보내 P2P 시스템에 가입했다는 사실을 알립니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Napster&lt;/em&gt; 에서는 중앙에 서버를 두어, 파일이 저장된 &lt;em&gt;peer&lt;/em&gt; 를 기록합니다. 각 &lt;em&gt;peer&lt;/em&gt; 는 파일이 어디있는지 검색하기 위해 중앙 서버에 질의해야 합니다. 그림에서 볼 수 있듯이, 각 파일은 서버가 아니라 &lt;strong&gt;클라이언트&lt;/strong&gt; 에 저장되어 있습니다. 파일이 어느 클라이언트(&lt;em&gt;peer&lt;/em&gt;) 에 저장되어있는지 알게되면, &lt;em&gt;ping&lt;/em&gt; 을 날려 살아있는지 확인 후 파일을 다운 받습니다. &lt;/p&gt;

&lt;p&gt;&lt;em&gt;Napster&lt;/em&gt; 의 문제점은&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;중앙 서버로의 요청이 너무나 많습니다.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;서버가 다운되면, 시스템이 멈춥니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="gnutella"&gt;Gnutella&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Gnutella&lt;/em&gt; 는 &lt;em&gt;Napster&lt;/em&gt; 시스템에서 &lt;strong&gt;서버&lt;/strong&gt;를 제거했습니다. 각 클라이언트 (&lt;em&gt;peer&lt;/em&gt;) 는 파일이 어디 저장되어있는지 파악하기 위해 서로 통신하지요. 이처럼 클라이언트가 서버처럼 행동하기때문에 &lt;em&gt;servent&lt;/em&gt; 라 부르기도 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;위 슬라이드에서 알 수 있듯이, 각 피어는 근처에 있는 피어로의 링크를 가지고 있습니다. 이 링크는 &lt;em&gt;overlay graph&lt;/em&gt; 라 부르기도 합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;gnutella&lt;/em&gt; 에서 피어간 통신에 사용되는 주요 메세지 타입은&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Query:&lt;/strong&gt; search&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;QueryHit:&lt;/strong&gt; reponse to query&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ping:&lt;/strong&gt; to probe network for other peers&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pong:&lt;/strong&gt; reply to ping, contains address of another peer&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Push:&lt;/strong&gt; used to initiate file transfer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella_header.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella_search_ttl.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 &lt;code&gt;TTL = 2&lt;/code&gt; 이기 때문에 &lt;em&gt;query&lt;/em&gt; 메세지는 &lt;em&gt;2-hop&lt;/em&gt; 까지만 전파됩니다. 그리고 &lt;em&gt;gnutella&lt;/em&gt; 에서는 각 피어가 최근에 퍼트린 &lt;em&gt;query&lt;/em&gt; 메세지 리스트를 유지하고 있기 때문에 같은 메세지를 다시 전파하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella_queryhit_msg.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella_queryhit_msg_ex.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;피어가 보낸 &lt;em&gt;query&lt;/em&gt; 에 대해 해당하는 파일을 가지고 있다는 응답은 &lt;em&gt;query hit&lt;/em&gt; 메세지를 통해 전달됩니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;gnutella&lt;/em&gt; 에서는 과도한 트래픽을 방지하기 위해 다음의 방법을 사용합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;to avoid duplicate transmissions, each peer maintains a list of recently received messages&lt;/li&gt;
&lt;li&gt;query forwarded to all neighbors except peer from which received&lt;/li&gt;
&lt;li&gt;each query (identified by &lt;code&gt;DescriptorID&lt;/code&gt;) forwarded only once&lt;/li&gt;
&lt;li&gt;&lt;em&gt;QueryHit&lt;/em&gt; routed back only to peer from which &lt;em&gt;Query&lt;/em&gt; received with same &lt;code&gt;DescriptorID&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;for flooded messages, duplicates with same &lt;code&gt;DescriptorID&lt;/code&gt; and &lt;em&gt;Payload descriptor&lt;/em&gt; are dropped&lt;/li&gt;
&lt;li&gt;&lt;em&gt;QueryHit&lt;/em&gt; with &lt;code&gt;DescriptorID&lt;/code&gt; for which &lt;em&gt;Query&lt;/em&gt; not seen is dropped&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/after_receiving_queryhit.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;QueryHit&lt;/em&gt; 메세지를 &lt;em&gt;requestor&lt;/em&gt; 가 받으면 최적의 &lt;em&gt;responder&lt;/em&gt; 를 고르고,  &lt;strong&gt;HTTP&lt;/strong&gt; 를 이용해서 몇번의 통신을 한 뒤 파일을 전송받습니다. 여기서 &lt;em&gt;gnutella&lt;/em&gt; 가 &lt;em&gt;HTTP&lt;/em&gt; 를 이용하는 이유는, HTTP 가 &lt;em&gt;standard&lt;/em&gt;, &lt;em&gt;well-debugged&lt;/em&gt;, &lt;em&gt;widely used&lt;/em&gt; 이기 때문입니다.&lt;/p&gt;

&lt;p&gt;그런데 만약, &lt;em&gt;responder&lt;/em&gt; 가 방화벽(&lt;em&gt;firewall&lt;/em&gt;) 뒤에 있으면 어떻게 될까요? 일반적으로 방화벽은 &lt;em&gt;incomming message&lt;/em&gt; 를 필터링 합니다. &lt;em&gt;gnutella&lt;/em&gt; 는 이럴 경우 대비해 &lt;em&gt;push&lt;/em&gt; 를 만들어 놓았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/dealing_with_firewalls.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;query hit&lt;/em&gt; 메세지를 받은 후에 &lt;em&gt;requestor&lt;/em&gt; 가 보내는 &lt;em&gt;HTTP&lt;/em&gt; 메세지에 &lt;em&gt;responder&lt;/em&gt; 가 응답하지 않으면 &lt;em&gt;overlay link&lt;/em&gt; (이미 연결되어있는) 을 통해서 &lt;em&gt;push&lt;/em&gt; 메세지를 &lt;em&gt;requestor&lt;/em&gt; 가 보냅니다. &lt;em&gt;responder&lt;/em&gt; 는 방화벽 뒤에 있어도, &lt;em&gt;overlay link&lt;/em&gt; 를 통해 받은 &lt;em&gt;push&lt;/em&gt; 메세지를 확인하고 파일 전송을 시작합니다.&lt;/p&gt;

&lt;p&gt;만약 &lt;em&gt;requestor&lt;/em&gt; 가 방화벽 뒤에 있다면, &lt;em&gt;gnutella&lt;/em&gt; 프로토콜로는 파일을 전송 받을 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;gnutella&lt;/em&gt; 에서 생기는 문제점은 &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;ping/pong&lt;/em&gt; constituted 50% traffic: use multiplex, cache and reduce freq of &lt;em&gt;ping/pong&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;modem-conncted hosts do not have enough bandwidth for passing gnutella traffic: use a central server to act as proxy for such peers. or use &lt;strong&gt;FastTrack System&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;large number of &lt;em&gt;free loaders&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;flooding causes excessive traffic: use &lt;strong&gt;Structured P2P system&lt;/strong&gt; e.g &lt;strong&gt;Chord System&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="fasttrac"&gt;FastTrac&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;FastTrac&lt;/em&gt; 은 &lt;em&gt;Kazza&lt;/em&gt;, &lt;em&gt;KazzaLite&lt;/em&gt;, &lt;em&gt;Grokster&lt;/em&gt; 라는 기술을 기반으로 한 &lt;em&gt;Napster&lt;/em&gt; &lt;em&gt;Gnutella&lt;/em&gt; 의 하이브리드입니다. &lt;/p&gt;

&lt;p&gt;&lt;em&gt;healthier participants&lt;/em&gt; 를 이용하겠다는 기본적인 아이디어로부터 출발했습니다. &lt;em&gt;gnutella&lt;/em&gt; 와 비슷하지만 노드중 일부가 &lt;em&gt;supernode&lt;/em&gt; 가 되어, 특별한 역할을 수행합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/fast_trac.jpg" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;supernode&lt;/em&gt;는 &lt;em&gt;Napster server&lt;/em&gt; 와 비슷하게 근처에 있는 노드의 &lt;code&gt;&amp;lt;file name, peer point&amp;gt;&lt;/code&gt; 리스트를 저장합니다&lt;/li&gt;
&lt;li&gt;&lt;em&gt;supernode&lt;/em&gt; 의 멤버십은 시간이 지나면서 변합니다&lt;/li&gt;
&lt;li&gt;어떤 노드도 &lt;em&gt;supernode&lt;/em&gt; 가 될 수 있습니다. 그러기 위해서는 &lt;em&gt;reputation&lt;/em&gt; 을 얻어야 합니다&lt;/li&gt;
&lt;li&gt;각 노드는 데이터를 탐색하기 위해 &lt;em&gt;supernode&lt;/em&gt; 에 질의합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 &lt;em&gt;reputation system&lt;/em&gt; 은 &lt;em&gt;Kazaalite&lt;/em&gt; 처럼 &lt;em&gt;upload&lt;/em&gt; 한 파일의 양으로 결정할 수도 있고, 경제학적인 원리를 적용한 방법도 있습니다&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="bittorrent"&gt;BitTorrent&lt;/h3&gt;

&lt;p&gt;이전에 언급했듯이 &lt;strong&gt;다운만 받는 peer&lt;/strong&gt; 도 존재할 수 있습니다. &lt;em&gt;BitTorrent&lt;/em&gt; 는 업로드 하는 &lt;em&gt;peer&lt;/em&gt; 에게 보상을 해 주어, &lt;em&gt;peer&lt;/em&gt; 들의 업로드를 더 이끌어 낼 수 있습니다. &lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/bit_torrent_network.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;BitTorrent&lt;/em&gt; 네트워크 구성은 위 슬라이드와 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Tracker:&lt;/strong&gt; 파일당 하나씩 존재하며 &lt;em&gt;heartbeat&lt;/em&gt; 를 받아 &lt;em&gt;peer&lt;/em&gt; 의 &lt;em&gt;join&lt;/em&gt;, &lt;em&gt;leave&lt;/em&gt; 를 관리합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Seed:&lt;/strong&gt; 전체 파일을 가지고 있는 &lt;em&gt;peer&lt;/em&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Leecher:&lt;/strong&gt; 파일의 일부분을 가지고 있는 &lt;em&gt;peer&lt;/em&gt; &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;BitTorrent&lt;/em&gt; 에서는 블럭단위로 파일을 전송하는데, 이 때 사용하는 몇 가지 규칙이 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Local Rarest First:&lt;/em&gt; 파일을 다운받을때, 귀한 블럭부터 먼저 받습니다&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Tit for tat:&lt;/em&gt; 업로드 하는 만큼, 다운로드 &lt;em&gt;bandwidth&lt;/em&gt; 를 할당받습니다. 다시 말해서 업로드를 많이해야 빠르게 받을 수 있습니다&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Choking:&lt;/em&gt; 동시에 업로드하는 &lt;em&gt;neighbor&lt;/em&gt; 수를 제한해서 &lt;em&gt;bandwidth&lt;/em&gt; 가 너무 많이 사용되지 않도록 합니다. &lt;em&gt;best neighbor&lt;/em&gt; 를 선택하여 &lt;em&gt;unchoked set&lt;/em&gt; 을 유지하고, 주기적으로 이 집합을 재평가합니다. 이외의 다른 &lt;em&gt;peer&lt;/em&gt; 는 &lt;em&gt;choked set&lt;/em&gt; 입니다. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;optimistic unchoke&lt;/em&gt; 기법은 주기적으로 랜덤한 &lt;em&gt;neighbor&lt;/em&gt; 를 &lt;em&gt;unchoke&lt;/em&gt; 해서, &lt;em&gt;unchoked set&lt;/em&gt; 을 &lt;em&gt;fresh&lt;/em&gt; 하게 유지합니다. 여기서 &lt;em&gt;random choice choking&lt;/em&gt; 을 쓰는 이유는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To avoid the sysem from getting stuck where only a few peers receive service&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="dht"&gt;DHT&lt;/h3&gt;

&lt;p&gt;지금까지 본 &lt;em&gt;Napster&lt;/em&gt;, &lt;em&gt;Gnutella&lt;/em&gt;, &lt;em&gt;FastTrac&lt;/em&gt; 은 일종의 &lt;em&gt;DHT, Distribute Hash Table&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;DHT&lt;/em&gt; 에서의 &lt;em&gt;performance concerns&lt;/em&gt; 는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;load balancing&lt;/li&gt;
&lt;li&gt;fault-tolerance&lt;/li&gt;
&lt;li&gt;efficiency of lookup and inserts&lt;/li&gt;
&lt;li&gt;locality&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우리가 배울 &lt;em&gt;Chord&lt;/em&gt; 는 이런 구조가 적용된 &lt;em&gt;structured peer to peer system&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/performance_comparison_nap_gnu.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Napster&lt;/em&gt; 는 &lt;em&gt;peer&lt;/em&gt; 의 경우 파일을 저장하지 않기 때문에 메모리가 많이 들지 않지만, &lt;em&gt;server&lt;/em&gt; 에서 많은 메모리를 요구합니다. 서버로 질의가 가기때문에 &lt;em&gt;lookup latency&lt;/em&gt; 나 &lt;em&gt;lookup&lt;/em&gt; 을 위한 메세지 수 자체는 많지 않지만, 서버의 부하가 상당히 심할 수 있습니다.&lt;/p&gt;

&lt;p&gt;반면 &lt;em&gt;Gnutella&lt;/em&gt; 에서는 서버가 없습니다. 그렇기 때문에 피어는 파일이 저장되어있는 주변 피어의 목록을 가지고 있어야 하는데, &lt;code&gt;N&lt;/code&gt; 만큼의 이웃이 주변에 있을 수 있습니다. 따라서 한 피어에서 필요한 메모리 양은 &lt;code&gt;O(N)&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;그리고 네트워크가 직선으로 구성되어 있다고 할때, &lt;em&gt;lookup latency&lt;/em&gt; 는 &lt;code&gt;O(N)&lt;/code&gt; (&lt;code&gt;N-1&lt;/code&gt;) 이고 룩업을 위한 메세지 수도 &lt;code&gt;O(N)&lt;/code&gt; (&lt;code&gt;2(N-1)&lt;/code&gt;) 입니다.&lt;/p&gt;

&lt;p&gt;반면 &lt;em&gt;Chord&lt;/em&gt; 는 모두 &lt;code&gt;O(log N)&lt;/code&gt; 입니다. 이론적으로 &lt;em&gt;constant&lt;/em&gt; 는 아니지만, &lt;em&gt;real world&lt;/em&gt; 에서는 상당히 낮은 수가 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="chord"&gt;Chord&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Chord&lt;/em&gt; 는 &lt;em&gt;Berkeley&lt;/em&gt; 와 &lt;em&gt;MIT&lt;/em&gt; 에서 개발된 &lt;em&gt;P2P&lt;/em&gt; 프로토콜입니다.&lt;em&gt;latency&lt;/em&gt; 와 &lt;em&gt;message cost of routing&lt;/em&gt; (&lt;em&gt;lookups&lt;/em&gt;/&lt;em&gt;inserts&lt;/em&gt;) 를 줄이기 위해 지능적으로 &lt;em&gt;neighbor&lt;/em&gt; 를 선택하고 &lt;em&gt;Consistent Hashing&lt;/em&gt; 기법을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Consistent Hasing&lt;/em&gt; 값은 &lt;em&gt;peer&lt;/em&gt; 에 부여되는 주소값으로&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IP 와 Port로 &lt;em&gt;SHA1&lt;/em&gt; 로 해싱해서 160 비트 스트링을 만들고 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; 비트로 절단해서 사용합니다&lt;/li&gt;
&lt;li&gt;&lt;em&gt;peer&lt;/em&gt; 의 &lt;em&gt;ID&lt;/em&gt; 라 불리기도 하는데, 이 값은 당연히 최대 &lt;code&gt;2^m - 1&lt;/code&gt; 입니다&lt;/li&gt;
&lt;li&gt;해싱값이므로 &lt;em&gt;unique&lt;/em&gt; 하진 않지만 충돌이 일어날 확률은 굉장히 적습니다&lt;/li&gt;
&lt;li&gt;그리고 이 값이 &lt;code&gt;2^m&lt;/code&gt; 개의 점이 되어 하나의 원을 구성합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/ring_of_peers.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_finger_table.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;각 노드는 (반) 시계방향으로의 &lt;em&gt;successor&lt;/em&gt; 를 가지고 있고, 다른 노드를 가리키기 위한 &lt;em&gt;finger table&lt;/em&gt; 을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_file_saving.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;파일도 마찬가지로 &lt;em&gt;SHA-1&lt;/em&gt; 으로 해싱해서, 160 비트로 짜른 뒤 &lt;code&gt;mod 2^m&lt;/code&gt; 연산해서, 같은 값이거나 그보다 큰 값을 가지는 &lt;em&gt;peer&lt;/em&gt; 에 저장합니다.&lt;/p&gt;

&lt;p&gt;만약 균일하게 해싱된다면 &lt;code&gt;K&lt;/code&gt; 개의 키, &lt;code&gt;N&lt;/code&gt; 개의 피어에서 파일은 각 피어당 &lt;code&gt;K/N&lt;/code&gt; 개씩 저장되므로 피어당 걸리는 부하는 &lt;code&gt;O(K/N)&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_search_process.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 &lt;code&gt;N80&lt;/code&gt; 피어가 &lt;code&gt;K42&lt;/code&gt; 파일을 찾을때, &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;finger table&lt;/em&gt; 에 &lt;code&gt;42&lt;/code&gt; 가 없으므로 최대한 먼 &lt;code&gt;N16&lt;/code&gt; 에 질의하고, &lt;/li&gt;
&lt;li&gt;&lt;code&gt;N16&lt;/code&gt; 은 &lt;code&gt;N32&lt;/code&gt; 와 &lt;code&gt;N80&lt;/code&gt; 밖에 모르므로 &lt;code&gt;N32&lt;/code&gt; 를 거쳐 &lt;code&gt;N45&lt;/code&gt; 로 질의합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_search_analysis.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;chrod search&lt;/em&gt; 는 &lt;code&gt;O(log N)&lt;/code&gt; 의 시간이 듭니다. 증명에 대한 &lt;em&gt;intuition&lt;/em&gt; 은 쉽습니다.&lt;/p&gt;

&lt;p&gt;만약 현재 &lt;code&gt;Here&lt;/code&gt; 에서 &lt;code&gt;Key&lt;/code&gt; 를 모른다고 합시다. 그러면 그 거리의 &lt;code&gt;1/2&lt;/code&gt; 만큼은 점프를 해야합니다. 그것보다 더 적게 점프하면 거리를 &lt;code&gt;d&lt;/code&gt; 라 합시다. &lt;em&gt;finger table entry&lt;/em&gt; 값은 2배씩 증가하기 때문에, &lt;code&gt;2d&lt;/code&gt; 만큼 점프할 수 있는 엔트리가 있어야 하고, 그럼 애초부터 &lt;code&gt;2d&lt;/code&gt; 만큼 점프했어야 했기 때문에 모순입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;log(N)&lt;/code&gt; 만큼의 점프 뒤에는 &lt;em&gt;key&lt;/em&gt; 까지의 거리는 아무리 멀어봐야 &lt;code&gt;2^m / N&lt;/code&gt; 입니다. 균일하게 분포되는 해싱을 쓴다 가정하면, 이 사이에는 적은 수의 노드만 있습니다. 따라서 &lt;code&gt;O(logN)&lt;/code&gt; 만큼만 더 점프한다면 높은 확률로 &lt;em&gt;key&lt;/em&gt; 를 찾을 수 있습니다. &lt;code&gt;O(logN) + O(logN) = O(logN)&lt;/code&gt; 이므로, &lt;em&gt;search&lt;/em&gt; 는 &lt;code&gt;O(logN)&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;insertion&lt;/em&gt; 도 &lt;em&gt;searching&lt;/em&gt; 과 마찬가지로 &lt;code&gt;O(logN)&lt;/code&gt; 입니다. 그러나 이 성능은 &lt;em&gt;finger table&lt;/em&gt; 과 &lt;em&gt;successor&lt;/em&gt; 가 잘못되지 않았을 경우에만 참입니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_multiple_successor.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;chrod&lt;/em&gt; 는 &lt;em&gt;successor&lt;/em&gt; 한개만 가질땐 &lt;em&gt;failure&lt;/em&gt; 에 취약하기 때문에, 위 그림처럼 다수개의 &lt;em&gt;successor&lt;/em&gt; 를 가질 수 있습니다. 이 경우 성능은 어떻게될까요?&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/multiple_successor_analysis.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;2log(N)&lt;/code&gt; 개의 &lt;em&gt;successor&lt;/em&gt; 를 유지할 경우를 한번 생각해 봅시다. &lt;code&gt;50%&lt;/code&gt; 씩 &lt;em&gt;failure&lt;/em&gt; 가 발생하면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;하나의 노드에서 유지하는 &lt;em&gt;successor&lt;/em&gt; 중, 적어도 하나의 &lt;em&gt;successor&lt;/em&gt; 가 살아있을 확률은&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://latex.codecogs.com/gif.latex?1%20-%20%28%7B1%20%5Cover%202%7D%29%5E%7B2logN%7D%20%3D%201%20-%20%7B1%20%5Cover%20N%5E2%7D" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;위 확률은 모든 살아있는 노드(&lt;code&gt;50%&lt;/code&gt;) 에서 참일때, 다시 말해서 모든 노드에서 적어도 하나의 &lt;em&gt;successor&lt;/em&gt; 가 존재할 확률은 &lt;code&gt;N&lt;/code&gt; 이 매우 클때&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://latex.codecogs.com/gif.latex?%281%20-%20%7B1%20%5Cover%20N%5E2%7D%29%5E%7BN/2%7D%20%3D%20e%5E%7B-%7B1%5Cover%202N%7D%7D%20%5Capprox%201" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_joining.png" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a new peer affects &lt;code&gt;O(logN)&lt;/code&gt; other finger entires in the system, on average&lt;/li&gt;
&lt;li&gt;number of messages per peer join &lt;code&gt;O(logN * logN)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_stabilization_protocol.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;join&lt;/em&gt;, &lt;em&gt;leave&lt;/em&gt;, &lt;em&gt;failure&lt;/em&gt; 등 &lt;em&gt;churn&lt;/em&gt; 이 자주 일어나므로 &lt;em&gt;loop&lt;/em&gt; 가 있는지 없는지 검사하기 위해 주기적으로 &lt;em&gt;stabilization protocol&lt;/em&gt; 를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="pastry"&gt;Pastry&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/pastry_routing.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/pastry_locality.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Pastry&lt;/em&gt; 는 &lt;em&gt;chord&lt;/em&gt; 처럼 &lt;em&gt;node&lt;/em&gt; 에 &lt;em&gt;id&lt;/em&gt; 를 부여합니다. &lt;em&gt;routing table&lt;/em&gt; 은 &lt;em&gt;prefix matching&lt;/em&gt; 에 기반하기 때문에 &lt;code&gt;log(N)&lt;/code&gt; 의 성능을 보여줍니다. 그리고 짧은 &lt;em&gt;prefix&lt;/em&gt; 일 수록 가까이에 있을 확률이 높습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="kelips"&gt;Kelips&lt;/h3&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/kelips.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/kelips2.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/kelips3.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Kelips&lt;/em&gt; 는 &lt;em&gt;1-hop lookup&lt;/em&gt; 을 보여줍니다. 이럴 수 있는 이유는 위 그림에서 보듯이 &lt;em&gt;affinity group&lt;/em&gt; 이란걸 사용하기 때문입니다. 루트 &lt;code&gt;N&lt;/code&gt; 에 가까운 숫자 &lt;code&gt;k&lt;/code&gt; 를 정하고, 이 수로 &lt;code&gt;mod&lt;/code&gt; 연산을 해, 그룹을 만듭니다. 각각의 그룹은 내에 있는 모든 노드는 서로 어떤 파일을 저장하는지 알고 있습니다. 그리고 각 노드는 다른 그룹으로의 링크를 하나씩 가지고 있습니다. 따라서 어딜가든 거의 1번 혹은 2번 내에 &lt;em&gt;lookup&lt;/em&gt; 이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;chord&lt;/em&gt; 에 비해 메모리를 더 잡아먹긴 합니다. &lt;code&gt;O(logN)&lt;/code&gt; 보단 많은 양이지만, 그렇게 많지도 않습니다. 메모리가 귀하다면 &lt;em&gt;chord&lt;/em&gt; 나 &lt;em&gt;pastry&lt;/em&gt; 를, 그렇지 않고 &lt;em&gt;lookup&lt;/em&gt; 속도가 중요하다면 &lt;em&gt;kelips&lt;/em&gt; 를 사용하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/kelips4.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;membership&lt;/em&gt; 은 &lt;em&gt;gossip-based&lt;/em&gt; 프로토콜로 관리할 수 있습니다. &lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id="refs"&gt;Refs&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href="http://ook.co/solutions/cloud-computing/"&gt;Title Image&lt;/a&gt; &lt;br&gt;
(2) &lt;strong&gt;Cloud Computing Concept 1&lt;/strong&gt; by &lt;em&gt;Indranil Gupta&lt;/em&gt;, Coursera  &lt;/p&gt;</content:encoded></item></channel></rss>