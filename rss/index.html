<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Old Lisper]]></title><description><![CDATA[Lisp, Emacs, FP]]></description><link>http://1ambda.github.io/</link><generator>Ghost 0.5</generator><lastBuildDate>Tue, 30 Sep 2014 03:36:14 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Functional Programmin in Scala, Chapter 2]]></title><description><![CDATA[<p>2014-09-27, <strong>Functional Programming in Scala</strong>, Coursera</p>

<h3 id="21higherorderfunctions">2.1 Higher-Order Functions</h3>

<h4 id="higherorderfunctions">Higher-Order Functions</h4>

<p>Functional PL 에서는 함수를 <em>first-class</em> 로 다루는데, 이는 함수를 파라미터로 넘기거나 결과로 리턴할 수 있다는 소리다. </p>

<p>이렇게 함수를 파라미터로 받거나, 혹은 함수를 리턴하는 함수를 <strong>Higher order functions</strong> 라 부른다.</p>

<h4 id="functiontypes">Function Types</h4>

<blockquote>
  <p>type A => B is the type of a function that thaks an arg of type A and return a result of type B.</p>
</blockquote>

<h4 id="anonymousfunctions">Anonymous Functions</h4>

<blockquote>
  <p>The type of the parameter can be omittered if it can be infferred by the compiler</p>
</blockquote>

<h3 id="22currying">2.2 Currying</h3>

<p>2.1 에서 우리는 <strong>Higher Order Functions</strong> 를 만들었다. 다음과 같은 Tail-Recursive 버전의 <code>sum</code> 이 있다고 하자.</p>

<pre><code class="scala">def TailRecursiveSum(f: Int =&gt; Int, a: Int, b: Int): Int = {  
  def loop(a: Int, acc: Int): Int = {
    if (a &gt; b) acc
    else loop(a + 1, f(a) + acc)
  }
  loop(a, 0);
}

def sumInts(a: Int, b: Int) =  sum(x =&gt; x, a, b)  
def sumCubes(a: Int, b: Int) =  sum(x =&gt; x * x * x, a, b)  
def sumFactorials(a: Int, b: Int) =  sum(fact, a, b)  
</code></pre>

<pre><code>
</code></pre>

<p><code>a</code> 와 <code>b</code>는 <code>sumInts</code> 와 <code>sumCubes</code> 로 부터 <code>sum</code> 으로 변하지 않고 넘어간다. 제거할 수 없을까? <br />
답은 간단하다. <code>sum</code> 이 <code>a, b</code> 를 받는 함수를 리턴하면 된다.</p>

<pre><code class="scala">def sum(f: Int =&gt; Int): (Int, Int) =&gt; Int = {  
  def sumF(a: Int, b: Int): Int = {
    def loop(a: Int, acc: Int): Int = {
      if (a &gt; b) acc
      else loop(a + 1, f(a) +  acc)
    }
    loop(a, 0)
  }
  sumF
}
</code></pre>

<p>그러면 이렇게 인자를 숨길 수 있다.</p>

<pre><code class="scala">def sumInts = Currying.sum(x =&gt; x)  
assert(sumInts(1, 10) == 55)  
</code></pre>

<p><code>sum</code> 이 인자로 받은 <code>f</code> 를 적용한 새로운 함수 <code>sumF</code> 를 돌려주므로 다음과 같이 호출도 가능하다.</p>

<pre><code class="scala">def cube = (x: Int) =&gt; x * x * x  
sum(cube)(1, 10)  
</code></pre>

<p>함수를 리턴하는 함수는 유용하기 때문에, 스칼라에서는 이를 위한 특별한 문법을 제공한다. 다음의 두 함수 <code>sum1</code>과 <code>sum2</code> 는 동일하다.</p>

<pre><code class="scala">def sum1(f: Int =&gt; Int): (Int, Int) =&gt; Int = {  
  def sumF(a: Int, b: Int): Int = {
    if (a &gt; b) 0
    else f(a) + sum(a + 1, b)
  }
}

def sum2(f: Int =&gt; Int)(a: Int, b: Int): Int = {  
  if (a &gt; b) 0
  else f(a) + sum2(f)(a + 1, b)
}
</code></pre>

<h4 id="expansionofmultipleparameterlists">Expansion of Multiple Parameter Lists</h4>

<p><code>def f(args1)...(argsn) = E</code> 가 있을때 이건 다음과 같이 함수로 감싸고 그 함수를 다시 돌려주면, 원 함수 <code>f</code> 에서 파라미터를 하나 줄일 수 있다.</p>

<p><code>def f(args1)...(argsn-1) = { def g(argn) = E; g }</code> 만약 익명함수로 표현한다면,</p>

<p><code>def f(args1)...(argsn-1) = (argsn =&gt; E)</code> 와 같이 표현할 수 있다. 따라서 이와 같이 함수로 감싸 원 함수 <code>f</code> 에서 파라미터를 반복적으로 줄이다 보면 </p>

<p><code>def f(args1)...(argsn) = E</code> 는 인자를 1개씩 받는 N개의 익명함수로 표현할 수 있다.</p>

<p><code>def f = (args1 =&gt; (args2 =&gt; ...(argn =&gt; E) ...))</code> 이러한 스타일을 <strong>currying</strong> 이라 부른다.</p>

<h4 id="morefunctiontypes">More Function Types</h4>

<p>그렇다면, 위에서 본 <code>sum</code> 함수의 타입은 무엇일까? <code>def sum(f: Int =&gt; Int)(a: Int, b: Int): Int</code></p>

<p><code>(Int =&gt; Int) =&gt; Int, Int =&gt; Int</code> 로 표현할 수 있다. 근데 스칼라에서 <strong>functional types associate to the right.</strong> 이므로,</p>

<p><code>(Int =&gt; Int) =&gt; (Int, Int =&gt; Int)</code> 와 동일하다.</p>

<h4 id="exercise">Exercise</h4>

<blockquote>
  <p>(1). Write a <code>product</code> function that calculates the product of the value of a function for the points on a given interval</p>
</blockquote>

<pre><code class="scala">def product(f: Int =&gt; Int)(a: Int, b: Int): Int = {  
  if (a &gt; b) 1
  else f(a) * product(f)(a + 1, b)
}
</code></pre>

<blockquote>
  <p>(2). Write <code>factorial</code> in terms of <code>product</code></p>
</blockquote>

<pre><code class="scala">def factorial(n: Int): Int = {  
  product(x =&gt; x)(1, n)
}
</code></pre>

<blockquote>
  <p>(3). Can you write a more general funtion, which generalizes both <code>sum</code> and <code>product</code> </p>
</blockquote>

<pre><code class="scala">def mapReduce(f: Int =&gt; Int, combine: (Int, Int) =&gt; Int, init: Int)(a: Int, b: Int): Int = {  
  if (a &gt; b) init
  else combine(f(a), mapReduce(f, combine, init)(a + 1, b))
}

def sumUsingMapReduce(f: Int =&gt; Int)(a: Int, b: Int) =  
  mapReduce(f, (x: Int, y: Int) =&gt; x + y, 0)(a, b)

def productUsingMapReduce(f: Int =&gt; Int)(a: Int, b: Int) =  
  mapReduce(f, (x: Int, y: Int) =&gt; x * y, 1)(a, b)
</code></pre>

<h3 id="23examplefindingfixedpoints">2.3 Example: Finding Fixed Points</h3>

<h4 id="findingafixedpointofafunction">Finding a fixed point of a function</h4>

<blockquote>
  <p>A number is called a <strong>fixed point</strong> of a function f  if <code>f(x) = x</code> </p>
</blockquote>

<p>어떤 <code>f</code> 들에 대해서는 <code>f(x)</code> 를 반복적으로 적용하면서 변하지 않거나 변화량이 충분히 작아질때를 찾아 <strong>fixed point</strong> 를 찾을 수 있다.</p>

<p>1장에서 만들었던 제곱근을 구하는 함수로 돌아가 보자. 사실 이 함수는 <strong>fixed point</strong> 와 관련이 있다. <code>sqrt(x) = y</code> 라고 했을때 <code>y * y = x</code> 이므로 <code>y = x / y</code> 다. 따라서 <code>sqrt(x)</code> 는 함수 <code>y = x / y</code> 를 꾸준히 적용해서 찾아낼 수 있으므로 <code>y = x / y</code> 의 <strong>fixed point</strong> 다.</p>

<p>다음과 같은 <code>fixedPoint</code> 함수가 있다고 하자.</p>

<pre><code class="scala">val tolerance = 0.0001 // = 1.0E-4  
def isCloseEnough(x: Double, y: Double) = {  
  abs((x - y) / x) / x &lt; tolerance
}

def fixedPoint(f: Double =&gt; Double)(firstGuess: Double): Double = {  
  def iterate(guess: Double): Double = {
    val next = f(guess)
    if (isCloseEnough(guess, next)) next
    else iterate(next)
  }
  iterate(firstGuess)
}
</code></pre>

<p>이 함수를 이용해서 </p>

<p><code>sqrt(x: Int) = fixedPoint(y =&gt; x / y)(1.0)</code> </p>

<p>와 같은 제곱근을 구하는 함수를 만들어 볼 수 있겠다. 그러나 <code>sqrt(2)</code>
 를 실행하면 <code>guess</code> 값이 <code>1.0</code>과 <code>2.0</code> 사이를 널뛰기 하면서 무한 루프를 돈다.</p>

<p>이건 <code>guess</code> 값이 너무나 많이 변하기 때문인데, <code>f</code> 를 적용하는 시퀀스에서 연속적인 두개의 <code>guess</code> 값의 평균을 구하는 <code>f</code> 를 만듦으로서 이 문제를 피할 수 있다. (잘못된 해석일 수 있으므로 원문을 첨부한다.)</p>

<pre><code class="scala">One way to control such oscillations is to prevent the estimation from varying too much. This is done by averaging successive values of the original sequence  
</code></pre>

<h4 id="functionsasreturnvalues">Functions as return values</h4>

<p>여태까지는 함수를 인자로 사용했을때 언어에서 어떤 이점을 얻을 수 있는가에 대한 설명이었고, 이제부터는 함수를 리턴값으로 사용할때의 장점을 알아 보자. </p>

<p>아까와 같이 averaging 함으로써 stabilizing 하는 기법을 <strong>Average Damping</strong> 이라 부르는데, 아래와 같은 함수를 만들어서 인자로 넘길 수 있다.</p>

<p><code>def avgDamp(f: Double =&gt; Double)(x: Doube) = (x + f(x)) / 2</code></p>

<p>따라서 <code>sqrt</code> 함수는 다음과 같이 새로 작성할 수 있다.</p>

<pre><code class="scala">def avgDamp(f: Double =&gt; Double)(x: Double) = (x + f(x)) / 2  
def sqrt(x: Double): Double = fixedPoint(avgDamp(y =&gt; x / y))(1)  
</code></pre>

<p><code>avgDamp</code> 는 <code>x</code> 를 다시 인자로 받는 함수를 돌려준다. 원래라면 <code>def</code> 를 이용해서 새로 함수를 만들고 리턴했어야 하나, 스칼라에서 지원해주는 문법을 이용해서 <code>(x: Double)</code> 을 추가하는 것 만으로 편하게 만들었다.</p>

<p>이번장에선 Higher order function 을 이용해서 함수를 combine 하면 더 강력한 <strong>abstraction(추상화)</strong> 를 얻을 수 있다는 법을 배웠다. 비록 이 방법이 항상 좋은건  아니지만 배우면 다 쓸데가 있기 마련이다.</p>

<p>덤으로 하나 더 정리하자면, <strong>Currying</strong> 은 함수의 인자를 반복적으로 쪼개어 익명 함수로 만든 뒤 재활용 할 수 있도록 만드는 기술이라 보면 된다. 왜냐면 N개의 인자가 있다고 가정할때, 이전에는 1개의 함수에 다양한 인자를 줘야했지만, 커링을 이용하면 N개의 함수로 쪼갤 수 있고, 각각의 리턴되는 함수를 저장할 수 있으므로 각각을 재활용 할 수 있다.</p>

<h3 id="25functionsanddata">2.5 Functions and Data</h3>

<p>이번 장에서는 클래스를 사용한다. 유리수 계산을 하기 위해 <code>def add(n1: Int, d1: Int, n2: Int, d2: Int): Int</code> 와 같은 함수를 만드는 것이 아니라, 데이터를 추상화 하기 위한 방법으로 다음과 같은 클래스를 만들 수 있다.</p>

<pre><code class="scala">class Rational(x: Int, y: Int) {  
  def numer = x
  def denom = y

  def add(that: Rational) = {
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }
}
</code></pre>

<p>참고로, 스칼라는 <strong>type</strong> 과 <strong>value</strong> 를 서로 다른네임스페이스에서 관리하기 때문에 충돌할 걱정을 할 필요가 없다.</p>

<h4 id="exercise">Exercise</h4>

<blockquote>
  <p>(1). In your worksheet, add a method <code>neg</code> to class Rational that is used like this <code>x.neg // -x</code></p>
  
  <p>(2). Add a method sub to subtract two rational numbers</p>
  
  <p>(3). With the values of x, y, z as given in the previous slide, what is the result of <code>x - y - z</code></p>
</blockquote>

<pre><code class="scala">class Rational(x: Int, y: Int) {  
  def numer = x
  def denom = y

  def add(that: Rational) = {
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }

  def sub(that: Rational) = {
    add(that.neg)
  }

  def neg = new Rational(-numer, denom)
}
</code></pre>

<h3 id="26morefunwithrationals">2.6 More Fun With Rationals</h3>

<p>이전에 만든 <code>Rational</code> 클래스는 약분된 형태로 표현되지 않기 때문에 이런 기능을 추가할 필요가 있다.</p>

<blockquote>
  <p>reduce them to their smallest numerator and denominator by dividing both with a divisor</p>
</blockquote>

<p>다양한 방법으로 구현할 수 있겠지만, 가장 쉬운 방법은 <code>Rational</code> 오브젝트가 생성될때 약분 하는 방법이다. </p>

<pre><code class="scala">  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
  private val g = abs(gcd(x, y))

  def numer = x / g
  def denom = y / g
</code></pre>

<h4 id="selfreference">Self-reference</h4>

<p>그리고, <code>less</code>, <code>max</code> 와 같은 함수도 만들어 볼 수 있다. <code>max</code> 가 <strong>self-referencing</strong> 을 위해 <code>this</code> 키워드를 사용한다는 점에 주목하자.</p>

<pre><code class="scala">  def less(that: Rational) = numer * that.denom &lt; that.numer * denom
  def max(that: Rational) = if (this.less(that)) that else this
</code></pre>

<h4 id="precondition">Pre-condition</h4>

<p><code>new Rational(1, 0)</code> 을 시도하면 <code>0</code> 으로 나눌수 없기 때문에 에러를 뿜는다. 검사하기 위해 <code>require</code> 함수를 사용할 수 있다.</p>

<p><code>require(y &gt; 0, "denum must be != 0</code></p>

<p><code>assert</code> 도 사용할 수 있는데, <code>require</code> 와는 차이가 있다. <code>AssertionError</code> 가 나오고, <code>require</code> 에서는 <code>IllegalArgumentException</code> 이 나온다. 그래서 서로 다른 의도로 쓰이게끔 만들어졌다는걸 알 수 있다. (오역이 있을 수 있기 때문에 원문을 첨부한다.)</p>

<blockquote>
  <p>The reflects a difference in intent </br><br/>
  - <code>require</code> is used to enforce a precondition on the caller of a function <br/>
  - <code>assert</code> is used as to check the code of the function itself</p>
</blockquote>

<p>만약 예외를 테스트한다면 <code>scalatest</code> 에서는 <code>intercept</code> 를 이용하면 된다.</p>

<pre><code class="scala">  "Rational(1, 0)" should "throw IllegalArgumentException" in {
    intercept[IllegalArgumentException] {
      new Rational(1, 0)
    }
  }
</code></pre>

<h4 id="constructor">Constructor</h4>

<p>스칼라에서는 암시적(implicitly) 인 생성자를 도입했는데, 다시 말해 코드상에 없어도 <strong>Primary Constructor</strong> 가 존재하는데, 이 <strong>Primary Constructor</strong> 는 클래스의 파라미터를 받아서 클래스 바디의 모든 문장을 실행한다. 만약 다른 생성자를 만들고 싶으면, 다음과 같이 작성하면 된다.</p>

<p><code>def this(x: Int) = this(x, 1)</code></p>

<p>우측에 나오는 <code>this</code> 는 <strong>implicit primary constructor</strong> 다.</p>

<h4 id="exercise">Exercise</h4>

<blockquote>
  <p>Modify the <code>Rational</code> class so that rational numbers are kept unsimplified internally, but the simplification is applied when numbers are converted to strings. Do clients observe the same behavior when interacting with rational class? </br></p>
</blockquote>

<p>primary constructor 에서 약분을 하지 않고, <code>toString</code> 에서 약분을 할때 과연 제대로 되겠느냐인데, 답은 <strong>아니오</strong> 다. integer overflow 를 생각하면 쉽다. 최대한 약분할 수 있을때 먼저 해버리는것이 낫다. 커다란 수 <code>a</code> ... <code>z</code> 에 대해서 연산 해버리면, 마지막 <code>toString</code> 에서만 약분이 될텐데. 제대로 되지 않을 가능성이 있다.</p>

<blockquote>
  <p>Yes for small sizes of denominators and nominators and small numbers of operations</p>
</blockquote>

<h3 id="27evaluationandoperators">2.7 Evaluation and Operators</h3>

<h4 id="classesandsubstitutions">Classes and Substitutions</h4>

<p>(단어 오역이 있을 수 있어서 용어를 그대로 씀)</p>

<p>함수에서 <strong>subtitution</strong> 에 기반한 <strong>compuation model</strong> 을 이용했는데, 사실 이건 클래스를 인스턴스 할때도 똑같이 적용된다. 즉 <code>new C(x1, ... ,xn)</code> 은 <code>new C(v1, ..., vn)</code> 과 같다.</p>

<p>그렇다면, 다음과 같이 클래스가 인자 n 개를 받는 함수를 정의했을때 <code>def f(y1, ... , yn) = b</code> 이런 식은 어떻게 평가될까?</p>

<p><code>new C(v1, ..., vm).f(w1, ... , wn)</code></p>

<p>(1). 클래스의 <strong>formal parameter</strong> <code>x1, ..., xn</code> 이 <strong>actual parameter</strong> <code>v1, ... , vm</code> 으로 <strong>substitution</strong> 된다.<br/></p>

<p>(2). 함수 <code>f</code> 의 <strong>formal parameter</strong> <code>y1, ... , yn</code> 이 <strong>actual parameter</strong> <code>w1, ... , wn</code> 으로 <strong>substitution</strong> 된다. <br/></p>

<p>(3) <code>new Class(v1, ... , vm)</code> 이 <code>this</code> 로 치환되고</p>

<p>(4) <code>f</code> 의 바디 <code>b</code> 가 평가된다.</p>

<p>따라서 이를 식으로 표현하면, 다음과 같이 쓸 수 있다.</p>

<p><code>[v1/x1, ... , vm/xm][w1/y1, ... , wn/yn][new C(v1, ..., vm)/this]b</code> </p>

<p>그러면, 예제를 통해서 살펴보자.</p>

<pre><code class="scala">new Rational(1, 2).less(new Rational(2, 3))  
</code></pre>

<p>이건 다음과 같이 평가된다.</p>

<pre><code class="scala">[1/2, 2/y][new Rational(2, 3)/that][new Rational(1, 2)/this] this.numer * that.denom &lt; that.numer * this denom
</code></pre>

<p>결국 이건 아래와 같다.</p>

<pre><code class="scala">new Rational(1, 2).numer * new Rational(2, 3).denom &lt; new Rational(2, 3).numer * new Rational(1, 2).denom

// 1 * 3 &lt; 2 * 2
// true
</code></pre>

<h4 id="operators">Operators</h4>

<p><code>Int</code> 의 경우에는 <code>+</code> 를 사용하면 <code>3 + 5</code> 와 같이 표현할 수 있지만 <code>Rational</code> 의 경우에는 <code>r.add(r2)</code> 와 같이 사용해야 했다. 뭔가 불편하다.</p>

<p>스칼라에는 이런 문제를 해결하기 위해 <strong>Infix Notation</strong> 이 있다. 함수의 인자가 하나라면, 괄호를 생략하는 것이다. 바이너리 오퍼레이터처럼 보일 수 있도록.</p>

<pre><code class="scala">r add s // r.add(s)  
r less s // r less s  
r max s // r max s  
</code></pre>

<h4 id="relaxedidentifiers">Relaxed Identifiers</h4>

<p>스칼라에서는 <strong>operator</strong> 또한 <strong>identifier</strong> 가 될 수 있다. 스칼라에서 <strong>identifier</strong> 룰은 아래와 같다</p>

<blockquote>
  <p>(1). <strong>Alphanumeric:</strong> starting with a letter, followed by a sequence of letters or numbers <br/></p>
  
  <p>(2). <strong>Symbolic:</strong> starting with an operator symbol, followed by other character operator symbols <br/></p>
  
  <p>(3). The underscore character <code>_</code> counts as a letter <br/></p>
  
  <p>(4). Alphanumeric identifiers can also end in an underscore, followed by some operator symbols</p>
</blockquote>

<p>따라서 <code>*</code>, <code>+?%&amp;</code>, <code>vector_++</code>, <code>counter_=</code> 모두 유효한 identifier 들이다. </p>

<p>이제 이런 symbolic identifier 들을 이용해서 <code>Rational</code> 클래스의 함수 이름들을 산술연산 처럼 보이도록 변경해 보자.</p>

<pre><code class="scala">class Rational(x: Int, y: Int) {  
  require(y &gt; 0, "denom != 0")

  // secondary constructor
  def this(x: Int) = this(x, 1)

  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
  private val g = abs(gcd(x, y))

  def numer = x / g
  def denom = y / g

  def &lt; (that: Rational) = numer * that.denom &lt; that.numer * denom
  def max(that: Rational) = if (this &lt; that) that else this

  def + (that: Rational) = {
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }

  def - (that: Rational) = {
    this + -that
  }

  def unary_- = new Rational(-numer, denom)
}
</code></pre>

<p>재밌는 점은 <code>neg</code> 를 <strong>unary operator</strong> <code>-</code> 로 만들기 위해 <code>unary_</code> 를 이용해서 <code>unary_-</code> 로 정의했다는 것이다. </p>

<p>참고로, return 값을 주기 위해서 <code>unary-_: Rational</code> 과 같이 정의하면 에러가 난다. <code>:</code> 가 포함된 identifier 로 인식하기 때문에 <code>unary-_ :</code> 로 스페이스를 꼭 주어야 한다.</p>

<h4 id="precedencerules">Precedence Rules</h4>

<p>그렇다면 <code>x * x + y</code> 와 같은 경우 <code>*</code> 가 먼저 계산되어야 하는데, 이런건 어떻게 해결할까? 우리가 만든건 정수 연산자가 아니라 함수인데.</p>

<p>이를 위해 스칼라는 다음과 같은 룰을 만들어 두었다.</p>

<blockquote>
  <p>The precedence of an operator is determined by its first character. The following table lists the characters in increasing order of priority precedence</p>
</blockquote>

<pre><code class="scala">(all letters) // Alphanumeric
|
^
&amp;
&lt; &gt;  
= !
:
+ -
* / %
(all other special characters)
</code></pre>

<p>identifier 의 첫글자가 미리 정의된 테이블에 있다면 우선순위가 정해지는 룰이다.</p>]]></description><link>http://1ambda.github.io/functional-programmin-in-scala-chapter-2/</link><guid isPermaLink="false">20cff111-9852-407f-9222-acac9d6733e0</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 29 Sep 2014 16:09:24 GMT</pubDate></item><item><title><![CDATA[Scala for the Impatient, Chapter 1, 2, 3]]></title><description><![CDATA[<h3 id="chapter1">Chapter 1</h3>

<p>(1). 스칼라의 REPL 은 엄밀히 말해서 인터프리터가 아니다. 입력받은 코드를 자바 바이트코드로 컴파일 한 후 자바 가상머신에서 실행시킨뒤 결과를 돌려준다.</p>

<p>(2). 스칼라는 문자열을 위한 추가적인 연산들을 제공하기 위해 <code>java.lang.String</code> 오브젝트를 <code>StringOps</code> 오브젝트로 변환한다. <code>"Hello".intersect("World")</code> 가 그 예다. 따라서 ScalaDoc 을 보려면 <code>SpringOps</code> 클래스를 살펴보는 편이 정신 건강에 좋다.</p>

<p>마찬가지로 <code>Int</code>, <code>Double</code> 등에도 편의 메소드를 추가한 <code>RichInt</code>, <code>RichDouble</code>, <code>RichChar</code> 등을 제공한다. <code>1.to(10)</code> 에서 <code>1</code> 은 <code>RichInt</code> 로 변환된 뒤에 <code>to</code> 메소드를 적용한다.</p>

<p>참고로 스칼라에서는 숫자간 타입 변환을 위해 캐스팅이 아니라 메소드를 사용한다. <code>99.44.toInt</code>, <code>99.toChar</code>, <code>"99.44".toDouble</code></p>

<p>(3). 스칼라에는 <code>++</code> 연산자가 없다.</p>

<p>(4). 스칼라에는 Static Method 대신 <strong>Singleton Object</strong> 와 <strong>Companion Object</strong> 가 있다.</p>

<p>(5). 오브젝트를 수정하지 않는, 인자가 없는 메소드는 괄호를 사용하지 않는다. </p>

<p><code>"Hello".distinct</code> </p>

<p>(6). ScalaDoc 에서 <strong>implicit</strong> 로 태그된 메소드는 자동변환이다. 예를들어 <code>BigInt</code> 오브젝트는 필요할때 자동으로 <code>int</code> 와 <code>long</code> 을 <code>BigInt</code> 로 바꾼다.</p>

<h3 id="chapter2">Chapter 2</h3>

<p>(1). 스칼라에서는 <strong>구문(Statement)</strong> 이 아니라 모든 것을 <strong>식(Expression)</strong> 으로 취급한다. 그런데, <code>else</code> 가 없는 <code>if</code> 문은 값이 없을 수 있는데, 스칼라에서는 <code>Unit</code> 클래스를 도입해서 해결한다. <code>Unit</code> 은 <strong>값 없음</strong> 을 뜻하는 <code>()</code> 을 값으로 가진다.</p>

<p>(2). 스칼라에서 <strong>할당(assignment)</strong> 은 <code>Unit</code> 타입의 값을 가진다. 따라서 할당을 묶어서 사용하지 않는다.</p>

<p><code>x = y = z = 1 // no</code></p>

<p>(3) <code>for</code> 루프에서 인덱스가 필요하면, <code>until</code> 을 사용하면 된다.</p>

<pre><code class="scala">val str = "lambda"  
var sum = 0  
for (index &lt; - 0until str.length)  
  sum += index
</code></pre>

<p>(4). <code>return</code> 이 없는 삶에 익숙해지자, 익명함수를 사용할 경우 리턴값이 쓸모가 없다. <code>break</code> 쯤으로 여기는 것이 마음 편하다.</p>

<p>(5). 재귀 함수는 타입을 반드시 명시해야 한다. <strong>ML</strong> 이나 <strong>하스켈</strong> 같은 일부 언어는 <strong><a href='http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system' >힌들리-밀너</a></strong> 알고리즘을 이용하여 재귀함수의 타입을 추론할 수 있지만, 이 알고리즘은 객체지향과는 잘 안맞는다.</p>

<p>(6). 가변인자가 필요하면, <code>*</code> 를 사용하자. 배열을 풀어헤치기 위해 사용하는 <code>_*</code> 는 <strong>Splat operator</strong> 다</p>

<pre><code class="scala">def sum(args: Int*) = {  
  var sum = 0;
  for(arg &lt;- args) sum += arg
  sum
}

sum(1 to 5: _*)

def recursiveSum(args: Int*): Int = {  
  if (args.length == 0) 0
  else args.head + recursiveSum(args.tail : _*)
}
</code></pre>

<p>참고로, <code>Object</code> 타입의 가변인자를 받으면 <code>42.asInstanceOf[AnyRef]</code> 처럼 직접 변환해야 한다.</p>

<p>(7). <strong>=</strong> 가 없는 함수는 <strong>Unit</strong> 리턴 타입을 가지며, <strong>프로시저</strong> 라 불린다. 값을 리턴하지 않기 때문에, 사이드 이펙트만를 위해 사용한다. 프로시저에서 <code>Unit</code> 을 직접 명시할수도 있다.</p>

<pre><code class="scala">def proc(str: String) {  
  ...
  ... // side effect
  ...
}
</code></pre>

<p>(8). <code>lazy val</code> 을 이용하면, <code>def</code> 처럼 해당 변수가 사용되기 전까지 평가되지 않는다.</p>

<pre><code class="scala">lazy val words = scala.io.Source.fromFile("words.txt").mkString  
</code></pre>

<p>그런데, <code>lazy</code> 로 선언되면 값을 접근할때 마다 스레드세이프하게 초기화가 되었는지 확인하는 검사가 필요하므로 비용이 든다.</p>

<p>(8). 스칼라에는 체크예외가 없다. 모두 런타임 예외다. 그리고, <code>throw</code> 는 <code>Nothing</code> 을 값으로 가지는데, <code>if</code> 문에서는 <code>Nothing</code> 대신 다른 분기의 타입으로 식의 값이 정해진다.</p>

<h3 id="chapter3">Chapter 3</h3>

<p>(1). 고정길이 배열이 필요하면 <code>Array</code> 로 사용하면 된다. 만약 초기값이 필요없으면 <code>new</code> 를 사용하고, 아니면 <code>new</code> 를 제외한다.</p>

<pre><code class="scala">val nums = new Array[Int](10)  
val strs = Array[String]("Hello", "World")  
</code></pre>

<p>고정 배열은 JVM 내부에서 자바의 일반 배열로 처리된다.</p>

<p>(2). 가변빌이 배열이 필요하면 <code>ArrayBuffer</code> 를 사용하면 된다. 자바의 <code>ArrayList</code> 라 보면 된다. </p>

<pre><code class="scala">val ab = ArrayBuffer[Int]()  
ab += 1  
ab += (2, 3)  
ab ++= Array(4, 5)  
</code></pre>

<p><code>ArrayBuffer</code> 끝에 원소를 삽입하고 삭제하는건 성능이 괜찮지만, 중간에 삽입하고 삭제하면 기존의 원소를 옮겨야 하므로 성능이 떨어진다는 점에 주의하자. </p>

<p>만약 <code>Array</code> 를 <code>ArrayBuffer</code> 로 만들려면 <code>toBuffer</code> 메소드를, <code>ArrayBuffer</code> 를 <code>Array</code> 로 만들려면 <code>toArray</code> 를 호출하면 된다.</p>

<p>(3). <code>until</code> 은 <code>RichInt</code> 클래스에 속한다. 만약 0부터 10까지 2씩 건너뛰고 싶으면</p>

<p><code>0 to (10, 2)</code> </p>

<p>거꾸로 순회하고 싶으면</p>

<p><code>(0 to 10).reverse</code></p>

<p>(4). 만약 <code>ArrayBuffer</code> 에 있는 음수 중, 처음 것만 제외하고 모두 삭제하고 싶을때 Flag 를 사용하면 다음과 같은 코드를 만들 수 있다.</p>

<pre><code class="scala">val first = true  
val n = arr.length  
var i = 0

while(i &lt; n) {  
  if (arr(i) &gt;= 0) i += 1
  else {
    if (first) { first = false; i += 1}
    else {
      arr.remove(i); n -= 1
    }
  }
}
</code></pre>

<p>그런데, 배열 버퍼 중간에 있는 원소를 삭제하는건 비효율적이기 때문에, 차라리 인덱스를 보존하고 한꺼번에 옮겨 자르는 편이 더 낫다.</p>

<pre><code class="scala">val indexes = for(i until arr.length if arr(i) &gt;= 0 || first) yield {  
  if (a &lt; 0) first = false;
  i
}

for(j until indexes.length) {  
  arr(j) == arr(indexes(j))
}

arr.trimEnd(arr.length - indexes.length)  
</code></pre>

<p>(4). <strong>for comprehension</strong> 의 <code>guard</code> 와 <code>yield</code> 를 사용하든, <strong>collection</strong> 의 <code>filter</code> 와 <code>map</code>을 사용하든 하는일은 같다.</p>

<p>(5). <code>ArrayBuffer</code> 나 <code>Array</code> 는 <code>max</code>, <code>min</code>, <code>sum</code> 과 같은 메소드 들을 가지고 있다. 그리고 <code>min</code>, <code>max</code> 혹은 <code>scala.util.Sorting.quickSort</code> 에 들어갈 컬렉션의 원소타입들은 반드시 비교 연산을 가지고 있어야 하는데, <strong>숫자</strong>, <strong>문자열</strong>, <strong>Ordered Trait</strong> 을 가지는 타입이 해당된다.</p>

<p>(6). 컬렉션의 원소를 이쁘게 출력하고 싶으면 <code>mkString</code> 을 이용하자.</p>

<pre><code class="scala">Array(1, 2, 3).mkString(" and ")  
// "1 and 2 and 3"
Array(1, 2, 3).mkString("&lt;", ", ", "&gt;")  
//  "&lt;1, 2, 3&gt;"
</code></pre>

<p>(7) <code>Array</code> 의 <code>toString</code> 은 <code>ArrayBuffer</code> 와는 달리 쓸모가 없다.</p>

<pre><code class="scala">scala&gt; Array(1, 2, 3).toString  
// res28: String = [I@412d54b3
</code></pre>

<p>(8). ScalaDoc 을 여행하다보면 기기묘묘한 것들을 만날 수 있다.</p>

<p><code>def appendAll(xs: TraversableOnce[A]): Unit</code> 같은 경우, <code>xs</code> 는 <code>TraversableOnce</code> 트레이트를 구현하는 콜렉션이라 보면 된다.. 스칼라의 모든 컬렉션은  <code>TraversableOnce</code> 또는 흔하게 볼 수 있는 컬렉션의 트레이트로 <code>TraversableIterable</code> 이 있다.</p>

<p><code>def += (elem: A): ArrayBuffer.this.type</code> 의 경우 체이닝이 가능하도록 자기 자신을 리턴하는 메소드다. 이를테면 <code>b += 4 += 5.</code> 처럼</p>

<p><code>def copyToArray[B &gt;: A] (xs: Array[B]): Unit</code> 의 경우 <code>ArrayBuffer[A]</code> 의 모든 원소를 <code>Array[B]</code> 로 복사하는데 <code>B</code>는 <code>A</code> 의 하위 타입이다. <code>ArrayBuffer[Int]</code>,   <code>Array[Any]</code> 처럼</p>

<p>(9). 자바처럼 당연히 컬럼이 고정되지 않은 다차원 배열도 만들 수 있다. </p>

<pre><code class="scala">val triangle = new Array[Array[Int]](10)  
for(i &lt;- 0 to triangle.length)  
  triangle(i) = new Array[Int](i + 1)
</code></pre>

<p>만약 컬럼이 고정된 다차원 배열을 만든다면 <code>ofDim</code> 메소드를 이용하면 된다. 접근하려면 괄호를 두번 사용한다.</p>

<pre><code class="scala">val matrix = Array.ofDim[Double](3, 4)

maxtric(0)(1)  
</code></pre>

<p>(10). 스칼라 배열은 자바 배열로 구현되므로, 당연히 주고 받을 수 있다. <code>java.util.List</code> 를 받거나 리턴하는 자바 메소드를 호출하면 스칼라 코드에서 <code>ArrayList</code> 를 사용할 수 있지만, 이것 대신 <code>scala.collection.JavaConversions</code> 에 속한 메소드들을 임포트하면, 스칼라 버퍼를 자동으로 자바 리스트로 변환할 수 있다. </p>

<p>아래 예제에서 자바의 <code>java.lang.ProcessBuilder</code> 는 <code>List&lt;String&gt;</code> 을 받는 생성자를 가지고 있는데, <code>JavaConversions.bufferAsJavaList</code> 를 임포트하면 스칼라 버퍼가 <code>java.util.List</code> 인터페이스를 구현한 자바 클래스 오브젝트로 감싸진다.</p>

<pre><code class="scala">iport scala.collection.JavaConversions.bufferAsJavaList  
import scala.collection.mutable.ArrayBuffer

val command = ArrayBuffer("ls", "-al" "/home/user")  
val processBuilder(command)  
</code></pre>

<p>반대로 자바 메소드가 <code>java.util.List</code> 리턴하면 <code>Buffer</code> 로 자동으로 변환할 수 있다. 아래 예제에서 <code>cmd == command</code> 다. 바로 <code>ArrayBuffer</code> 로 받지 않는다는 점에 주의하자. <code>Buffer</code> 만 보장한다.</p>

<pre><code class="scala">import scala.collection.JavaConversions.asScalaBuffer  
import scala.collection.mutable.ArrayBuffer  
sd  
val cmd: Buffer[String] = pb.command()  
</code></pre>

<p>참고로, 스칼라의 컬렉션은 <code>immutable</code> 이 기본이고, 자바의 컬렉션은 <code>mutable</code> 이 기본이다.</p>]]></description><link>http://1ambda.github.io/scala-for-the-impatient-chapter-1-2-3/</link><guid isPermaLink="false">d3535bd4-9f25-4ff0-bec0-74124cfc98fd</guid><category><![CDATA[scala]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 26 Sep 2014 10:31:09 GMT</pubDate></item><item><title><![CDATA[Algorithm I, Chapter 1]]></title><description><![CDATA[<p>Algorithm Part 1, Coursera</p>

<h3 id="unionfind">Union Find</h3>

<h4 id="dynamicconnectivity">Dynamic Connectivity</h4>

<p>N 개의 오브젝트가 있을때, </p>

<ul>
<li><strong>Union command:</strong> connect two objects  </li>
<li><strong>Find/connected query:</strong> is there a path connecting the two objects?</li>
</ul>

<p>이렇게 두 경로가 연결되어있는지 아닌지를 판별하는 알고리즘은 다양하게 활용될 수 있다.</p>

<ul>
<li>Pixels in adigital photo  </li>
<li>Computers in a network  </li>
<li>Friends in a social network  </li>
<li>Transistors in a computer chip  </li>
</ul>

<h4 id="modeling">Modeling</h4>

<p>connection 에서 몇개의 성질들을 뽑아낼 수 있는데,</p>

<ul>
<li><strong>Reflexive:</strong> <em>p</em> is connected to <em>p</em>  </li>
<li><strong>Symetric:</strong> if <em>p</em> is connected to <em>q</em>, then <em>q</em> is connected to <em>p</em>  </li>
<li><strong>Transitive:</strong> if <em>p</em> is connected to <em>q</em> and <em>q</em> is connected to <em>r</em>, then <em>p</em> is also connected to <em>r</em>  </li>
<li><strong>Connected Components:</strong> mamximum set of objects that are mutually connected</li>
</ul>

<p>이제 연산들을 정의해 보면</p>

<ul>
<li><strong>Find query:</strong> Check if two objects are in the same component  </li>
<li><strong>Union command:</strong> Replace components containing two objects with their union</li>
</ul>

<p>연산을 구현할때는 아래의 3가지 요소를 고려해야한다.</p>

<ol>
<li>Number of objects N can be huge  </li>
<li>Number of operations M can be huse  </li>
<li>Find queries and union command may be intermixed</li>
</ol>

<pre><code class="java">;; initialize union-find data structure with N objects (0 to N-1)
class UF(int N) 

;; add connection between p and q
void union(int p, int q)

;; are p and q in the same component?
boolean connected(int p, int q)

;; component identifier for p (0 to N-1)
int find(int p)

;; number of components
int count()  
</code></pre>

<h3 id="quickfind">Quick-find</h3>

<p>Dynamic Connectivity 를 푸는 한 방법으로 <strong>eager approache</strong> 를 사용하는 <strong>Quick-find</strong> 가 있다. </p>

<p>데이터 구조는 배열을 사용하며 <code>int id[]</code>, 만약 <em>p</em> 와 <em>q</em> 가 연결되어있다면 똑같은 값을 가진다. 따라서</p>

<ul>
<li><strong>connected:</strong> <em>p</em> 와 <em>q</em> 가 같은 값을 가지는지 살핀다.  </li>
<li><strong>union:</strong> <code>id[p]</code> 와 같은 가지는 모든 인덱스의 값을 <code>id[q]</code> 로 바꾼다  </li>
</ul>

<p>구현은 다음과 같다.</p>

<pre><code class="java">// UnionFind.java
public interface UnionFind {  
    public void union(int p, int q);
    public boolean connected(int p, int q);
}

// QuickFind.java
public class QuickFind implements UnionFind {

    private int[] id;

    public QuickFind(int N) {
        this.id = new int[N];

        for(int i = 0; i &lt; this.id.length; i++) {
            this.id[i] = i;
        }
    }

    public void union(int p, int q) {
        if (!connected(p, q)) {
            int pValue = id[p];

            // replace id values same as p's into the value of q
            for(int i = 0; i &lt; this.id.length; i++) {
                if (id[i] == pValue) {
                    id[i] = id[q];
                }
            }
        }
    }

    public boolean connected(int p, int q) {
        return id[p] == id[q];
    }

}

// QuickFindTest.java
import static org.hamcrest.CoreMatchers.*;  
import static org.junit.Assert.*;

import org.junit.Before;  
import org.junit.Test;


public class QuickFindTest {

    private UnionFind uf;

    @Before
    public void setup() {
        uf = new QuickFind(10);
    }

    @Test
    public void testConnected() {
        assertThat(uf.connected(0, 1), is(false));
    }

    @Test
    public void testUnion() {
        assertThat(uf.connected(0, 1), is(not(true)));

        uf.union(0, 1);
        uf.union(0, 2);

        assertThat(uf.connected(0, 1), is(true));
        assertThat(uf.connected(1, 2), is(true));
    }
}
</code></pre>

<p><code>find(connected)</code> 연산은 <strong>O(1)</strong>, <code>union</code> 연산은 <strong>O(n)</strong> 의 복잡도를 가진다. 강좌에서는 각각 <strong>2 array accesses</strong>, <strong>at most 2N+1 array accesses</strong> 로 표현했다. 따라서 <strong>Quick-find</strong> 의 Cost Model 은 아래와 같다. (Order of growth of number of array accesses)</p>

<ul>
<li><strong>initialize:</strong> N  </li>
<li><strong>union:</strong> N  </li>
<li><strong>conncected:</strong> 1</li>
</ul>

<p>이런 <strong>Quick-find</strong> 방법 문제점은 <code>union</code> 연산이 너무 비싸다는 것이다. N개의 오브젝트에 대해 N번의 Union 연산을 수행하면 <strong>N^2</strong>, 즉 Quadratic(제곱)의 비용이 드는데, 이건 큰 문제다.</p>

<blockquote>
  <p>Quadratic algorithms don't scale with technology.</p>
</blockquote>

<p>컴퓨터가 10배 빨라지고, 메모리도 10 배만큼 늘었다고 하자. <strong>quadratic algorithm</strong> 으로는 문제의 사이즈가 10배가 되면, 걸리는 시간은 100배가 된다. 연산 시간이 10배 빨라졌으므로 문제를 해결하려면 여전히 10배의 시간이 걸린다. 즉 기술이 10배나 발전해도, 문제의 사이즈에 해당하는 시간이 여전히 걸리는 것이다. </p>

<p><strong>Quick-find</strong> 접근 법은, <strong>find</strong> 연산만 빠르다.</p>

<h3 id="quickunion">Quick-union</h3>

<p><strong>Quick-union</strong> 은 알고리즘 디자인적으로 <strong>lazy approach</strong> 라 볼 수 있다. <strong>Quick-find</strong> 와 같은 자료 구조(배열)을 사용하나 자료 구조에 대한 interpretation 이 다르다. </p>

<p align=""><br/><img src='http://www.timgittos.com/images/pa1/quick-union-overview.png'  />(<a href='http://www.timgittos.com/learning/princeton-algorithms-part-1/week-1/' >http://www.timgittos.com/learning/princeton-algorithms-part-1/week-1/</a>)<br/></p>

<p>이 경우 연산은 각각 아래와 같이 생각할 수 있다.</p>

<ul>
<li><strong>find:</strong> Check if <em>p</em> and <em>q</em> have the same root  </li>
<li><strong>union:</strong> To mege components containing <em>p</em> and <em>q</em>, set the id of <em>p</em>'s root to the id of <em>q</em>'s root</li>
</ul>

<p>구현은 아래와 같다. </p>

<pre><code class="java">// UnionFind.java
// same as above

// QuickUnion.java
public class QuickUnion implements UnionFind {

    private int[] id;

    public QuickUnion(int N) {
        this.id = new int[N];

        for(int i = 0; i &lt; N; i++) {
            this.id[i] = i;
        }
    }

    public int getRoot(int n) {
        int root = id[n];

        while(root != id[root]) {
            root = id[root];
        }

        return root;
    }

    public void union(int p, int q) {
        if (!connected(p, q)) {
            int pRoot = this.getRoot(p);
            int qRoot = this.getRoot(q);
            id[pRoot] = qRoot;
        }
    }

    public boolean connected(int p, int q) {
        return getRoot(p) == getRoot(q);
    }
}
</code></pre>

<pre><code class="java">// QuickUnionTest.java
import static org.hamcrest.CoreMatchers.is;  
import static org.hamcrest.CoreMatchers.not;  
import static org.junit.Assert.assertThat;  
import static org.mockito.Mockito.*;

import org.junit.Before;  
import org.junit.Test;  
import org.mockito.Mockito;

public class QuickUnionTest {

    UnionFind uf;

    @Before
    public void setup() {
        uf = new QuickFind(10);
    }

    @Test
    public void testGetRoot() {
        QuickUnion spy = Mockito.spy(new QuickUnion(5));

        assertThat(spy.getRoot(0), is(0));
        assertThat(spy.getRoot(1), is(1));
        assertThat(spy.getRoot(2), is(2));
        assertThat(spy.getRoot(3), is(3));
        assertThat(spy.getRoot(4), is(4));

        spy.union(0, 1);
        assertThat(spy.getRoot(0), is(1));
        assertThat(spy.getRoot(1), is(1));

        spy.union(2, 3);
        spy.union(4, 2);
        assertThat(spy.getRoot(2), is(3));
        assertThat(spy.getRoot(3), is(3));
        assertThat(spy.getRoot(4), is(3));
    }

    @Test
    public void testConnected() {
        // initial     : 0 1 2 3 4
        // union(0, 1) : 1 1 2 3 4
        // union(2, 3) : 1 1 3 3 4
        // union(3, 1) : 1 1 3 1 4

        //   1   4
        //  0 3
        //    2 

        QuickUnion spy = Mockito.spy(new QuickUnion(5)); 
        when(spy.getRoot(1)).thenReturn(1);
        when(spy.getRoot(0)).thenReturn(1);
        when(spy.getRoot(3)).thenReturn(1);
        when(spy.getRoot(2)).thenReturn(1);
        when(spy.getRoot(4)).thenReturn(4);

        assertThat(spy.connected(0, 4), is(not(true)));
        assertThat(spy.connected(1, 4), is(not(true)));
        assertThat(spy.connected(2, 4), is(not(true)));
        assertThat(spy.connected(3, 4), is(not(true)));

        assertThat(spy.connected(0, 1), is(true));
        assertThat(spy.connected(0, 2), is(true));
        assertThat(spy.connected(0, 3), is(true));
        assertThat(spy.connected(1, 2), is(true));
        assertThat(spy.connected(1, 3), is(true));
        assertThat(spy.connected(2, 3), is(true));
    }

    @Test
    public void testUnion() {
        QuickUnion spy = Mockito.spy(new QuickUnion(5));
        when(spy.getRoot(0)).thenReturn(0);
        when(spy.getRoot(1)).thenReturn(1);
        when(spy.getRoot(2)).thenReturn(2);
        when(spy.getRoot(3)).thenReturn(3);
        when(spy.getRoot(4)).thenReturn(4);

        spy.union(0, 1);
        when(spy.getRoot(0)).thenReturn(1);
        spy.union(2, 3);
        when(spy.getRoot(2)).thenReturn(3);
        spy.union(2, 0);
        when(spy.getRoot(2)).thenReturn(1);
        when(spy.getRoot(3)).thenReturn(1);

        verify(spy, times(1)).connected(0, 1);
        verify(spy, times(1)).connected(2, 3);
        Mockito.reset(spy);

        assertThat(spy.connected(0, 1), is(true));
        assertThat(spy.connected(2, 3), is(true));
        assertThat(spy.connected(2, 0), is(true));
        assertThat(spy.connected(1, 3), is(true));
        assertThat(spy.connected(0, 3), is(true));
    }   
}
</code></pre>

<p>이 경우 <strong>Cost Model</strong> 은 아래와 같다.</p>

<ul>
<li><code>getRoot</code>: depth of <code>n</code> array accesses. <strong>O(n)</strong> in worst case   </li>
<li><code>connected</code>: depth of <code>q</code> and <code>p</code> array accesses. <strong>O(n)</strong> in worst case</li>
<li><code>union</code>: depth of <code>q</code> and <code>p</code> array accesses. <strong>O(n)</strong> in worse case</li>
</ul>

<p><strong>Quick-find</strong> 의 defect 는 
- <code>union</code> is too expensive <br />
- Trees are flat but too expensive keep them flat.</p>

<p><strong>Quick-union</strong> 의 defect 는 
- Trees can get tall <br />
- <code>find(connected)</code> is too expensive (could be N array accesses)</p>

<h3 id="quickunionimprovement">Quick-union Improvement</h3>

<h4 id="1weightedquickunion">1. Weighted Quick-union</h4>

<p>기본 아이디어는 간단하다. <code>union</code> 연산을 수행할때 낮은 트리가 높은 트리에 속하게 함으로써 <strong>Worst case</strong> 를 방지하는 것이다. (마치 Balanced Tree 처럼)</p>

<p align=""><br/><img src='http://my.csdn.net/uploads/201206/12/1339479587_5986.png'  />(<a href='http://my.csdn.net/uploads/201206/12/1339479587_5986.png' >http://my.csdn.net/uploads/201206/12/1339479587_5986.png</a>)<br/></p>

<p>다른것은 모두 같지만, 트리의 크기를 비교해야 하기 때문에 트리의 크기를 저장할 배열이 필요하며, 이런 트리 크기를 비교하고 변경할 로직이 <code>union</code> 메소드에 추가되어야 한다.</p>

<pre><code class="java">// UnionFind.java is same as above
// QuickUnion.java is same as above
// WeightedQuickUnion.java

public class WeightedQuickUnion extends QuickUnion {

    int treeSize[];

    public WeightedQuickUnion(int N) {
        super(N);

        this.treeSize = new int[N];

        for(int i = 0; i &lt; this.treeSize.length; i++)  {
            this.treeSize[i] = 1;
        }
    }

    // for debug
    public int getTreeSize(int index) {
        return treeSize[index];
    }

    @Override
    public void union(int p, int q) {
        if(!connected(p, q)) {
            int qRoot = getRoot(q);
            int pRoot = getRoot(p);

            if (treeSize[qRoot] &gt;= treeSize[pRoot]) {
                id[pRoot] = qRoot;
                treeSize[qRoot] += treeSize[pRoot];
            } else {
                id[qRoot] = pRoot;
                treeSize[pRoot] += treeSize[qRoot];
            }

        }
    }
}
</code></pre>

<pre><code class="java">WeightedQuickUnionTest.java  
import static org.hamcrest.CoreMatchers.*;  
import static org.junit.Assert.*;

import org.junit.Test;  
import org.mockito.Mockito;

public class WeightedQuickUnionTest {

    WeightedQuickUnionTest spy;

    @Test
    public void testUnion() {
        WeightedQuickUnion spy = Mockito.spy(new WeightedQuickUnion(5));

        assertThat(spy.connected(0, 1), is(not(true)));
        // 0 1 -&gt; 1 1
        spy.union(0, 1);
        assertThat(spy.connected(1, 0), is(true));
        assertThat(spy.getTreeSize(0), is(1));
        assertThat(spy.getTreeSize(1), is(2));

        // 1 1 2 -&gt; 1 1 1 
        spy.union(0, 2);
        assertThat(spy.connected(0, 1), is(true));
        assertThat(spy.connected(1, 2), is(true));
        assertThat(spy.connected(0, 2), is(true));

        assertThat(spy.getRoot(0), is(1));
        assertThat(spy.getRoot(1), is(1));
        assertThat(spy.getRoot(2), is(1));

        // 1 1 1 4 4
        spy.union(3, 4);
        assertThat(spy.connected(1, 3), is(false));
        assertThat(spy.connected(4, 3), is(true));

        // 1 1 1 4 1
        spy.union(2,  4);
        assertThat(spy.connected(4, 3), is(true));
        assertThat(spy.getRoot(4), is(1));
        assertThat(spy.getRoot(3), is(1));
    }
}
</code></pre>

<p>이 때 <strong>Cost Model</strong> 은</p>

<ul>
<li><code>find</code>: taks time proportional to depth of <em>p</em> and <em>q</em> <strong>O(logN)</strong></li>
<li><code>union</code>: take constant time, given roots (without roots <strong>O(logN)</strong>)</li>
</ul>

<p>같은 사이즈의 트리끼리 merged 도야 depth 가 1 깊어지므로 N개의 원소에 대해 <strong>Weighted Quick-union</strong> 이 구성하는 트리는 아무리 깊어봐야(at most) <strong>lg <em>N</em></strong> 이다. </p>

<h4 id="2pathcompression">2. Path Compression</h4>

<p>또 다른 <strong>Quick-union</strong> 개선 방안은, <strong>Path Compression</strong> 으로 루트를 탐색할때마다, 루트값을 새로 고쳐 써 다음번에 탐색할때 탐색 시간을 줄이는 방법이다.</p>

<pre><code class="java">// WeightedQuickUnion.java

...
...
    public int getRoot(int n) {

        int root = id[n];

        while(root != id[root]) {
            id[root] = id[id[root]];
            root = id[root];
        }

        return root;
    }
...
...
</code></pre>

<p><strong>WQUPC(Weighted Quick-union with path compression)</strong> 은 <a href='http://upload.wikimedia.org/math/6/b/3/6b3721001c02b39a0da7d57a129e7661.png' >iterated logarithm (<strong>lg*<em>N</em></strong>)</a> 의 복잡도를 가진 다는 것이 증명 되었다. <strong>WQUPC</strong> 는 실제로 데이터를 읽어 들이는 비용도 있기 때문에 이론적으로는 linear 하지 않으나, 실제로는 linear 할 수 있다. </p>

<p><strong><em>N</em></strong> 개의 오브젝트를 초기화 하고 여기에 대해 <strong><em>M</em></strong> 번의 <code>union-find</code> 연산을 수행한다면 <strong>Worst case</strong> 에 대해 복잡도를 정리해 보면</p>

<ul>
<li><strong>Quick-find:</strong> M * N  </li>
<li><strong>Quick-union:</strong> M * N  </li>
<li><strong>Weighted Quick-union:</strong> N + M <em>logN</em> (array 를 balanced 하게 만든다.)  </li>
<li><strong>Quick-union with path compression:</strong> N + M <em>logN</em> (array 를 flat 하게 만든다.)  </li>
<li><strong>WQUPC:</strong> N + M lg*<em>N</em></li>
</ul>

<p>이렇게 보면 알고리즘의 복잡도는 별거 없어보이는데, 사실 무지막지하게 큰 차이다. 10^9 개의 오브젝트에 대해서 10^9 연산을 할 경우 <strong>Quick-find</strong> 를 사용할때 30년이 걸린다면 <strong>WQUPC</strong> 는 6초만에 해결할 수 있다. 다시 말해, 알고리즘은 슈퍼컴퓨터도 별 도움이 되지 못하는 문제를 해결할 수 있다.</p>

<h3 id="applicationsofunionfind">Applications of Union-find</h3>

<ul>
<li>Percolation  </li>
<li>Dynmaic Connectivity  </li>
<li>Lear common ancestor  </li>
<li>Kruskal's minimum spanning tree</li>
<li>and so on  </li>
</ul>

<h4 id="percolation">Percolation</h4>

<p align=""><br/><img src='http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolates.png'  />(<a href='http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation.html' >http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation.html</a>)<br/></p>

<p><strong>Percolation</strong> 이란, <em>N</em>-by-<em>N</em> 의 Grid 에서 각 opened-site 는 확률 <em>p</em> blocked-site 는 <em>1-p</em> 의 확률을 가진다. 이 모델은 주로 물리 시스템을 모델링하기위해 사용된다.</p>

<p>이론상 <em>N</em> 이 충분히 크면 </p>

<ul>
<li><em>p</em> > <em>p*</em> 인 지점에서는 almost certainly percolates 하고  </li>
<li><em>p</em> &lt; <em>p*</em> 인 지점에서는 alomost certainly does not percolate 하다.</li>
</ul>

<p align=""><br/><img src='http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation-threshold20.png'  /> (<a href='http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation.html' >http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation.html</a>)<br/></p>

<p>문제는 그런 <em>p*</em> 값이 무엇이냐 하는건데, 수학적으로는 찾을 길이 없고, 컴퓨터 시뮬레이션으로는 <strong>Union-find algorithm</strong> 을 이용하면 구할 수 있다. 유명한 방법으로 <strong>Monte Carlo simulation</strong> 이 있는데, <em>N</em>-by-<em>N</em> Grid 를 blocked site 로 채우고, 랜덤하게 open site 를 만들면서 top 과 bottom 이 percolate 되는지 매번 확인한다. 연결되면, vacancy percentage 가 <em>p*</em> 에 대한 추정값이다.</p>

<p>구현 방법은 각 site 를 노드로 생각하고, top 과 bottom 을 그룹으로 묶어(virtual site) top 이 bottom 과 연결되는지 매번 체크하면 된다. 자세한 내용은 <a href='http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation.html' >여기</a>를 참조</p>]]></description><link>http://1ambda.github.io/union-find-algorithms-week-1/</link><guid isPermaLink="false">df59dca1-76f2-4e0c-be10-96e24881af0d</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 22 Sep 2014 05:49:05 GMT</pubDate></item><item><title><![CDATA[Deadlock]]></title><description><![CDATA[<p>데드락 그 자체보다는, 데드락을 어떻게 해결하는가가 더 중요한 것 같다.</p>

<h3 id="deadlocknecessaryconditions">Deadlock Necessary Conditions</h3>

<p><strong>Deadlock</strong> 은 <strong>Coffman conditions</strong> 으로 알려진 아래 4개의 조건들이 모두 동시에 일어날때 발생한다. 만약 조건 중 하나라도 막을 수 있다면, <strong>Deadlock</strong> 이 발생하지 않는다. </p>

<ol>
<li><p><strong>Mutual Exclusion:</strong> at least one resource must be held in a non-shareable mode. Only one process can use the resource at any given instant of time  </p></li>
<li><p><strong>Resource Holding:</strong> a process is currently holding at least one resource and requesting additional resources which are held by other processes</p></li>
<li><p><strong>No Preemption:</strong> a resource can be released only voluntarily by the process holding it, after that process has completed its task</p></li>
<li><p><strong>Circular Wait:</strong> a process must be waiting for a resource which is being held by another process, which in turn is waiting for the first process to release the resource.</p></li>
</ol>

<p><a href='http://en.wikipedia.org/wiki/Deadlock' >위키피디아</a> 에 의하면 최근의 운영체제 시스템도 데드락이 발생하는걸 예방할수는 없고, 발생한다 하더라도 서로 다른 해결 방식을 취한다고 한다. 대부분의 경우 데드락을 예방하기 위해서 <strong>Circular Wait</strong> 조건을 방지하려고 하는데, 대표적인 데드락 방지 방법은 다음의 4가지다.</p>

<ol>
<li><strong>Ignoring Deadlock</strong>  </li>
<li><strong>Detection</strong> and <strong>Recovery</strong>  </li>
<li><strong>Prevention</strong>  </li>
<li><strong>Avoidance</strong></li>
</ol>

<h3 id="deadlockhandling">Deadlock Handling</h3>

<h4 id="1ignoringdeadlock">1. Ignoring Deadlock</h4>

<p>가장 마음 편한 방법이다. <strong>Deadlock</strong> 이 발생하지 않으리라 생각하며, 발생해도 무시한다. <a href='http://en.wikipedia.org/wiki/Ostrich_algorithm' >Ostrich Algorithm</a> 이라고도 알려져 있는데, 쉽게 말해서 <strong>Convenience</strong> 와 <strong>Correctness</strong> 를 교환하는 방법이다. 데이터 손실이나, 데드락 발생 간격이 허용될만큼 충분히 작다면, 이를 해결하기 위해 궂이 성능을 낮출 필요가 없다는 것이다. poor worst-case performance 알고리즘의 대표적인 예로 <strong>Standard ML</strong> 의 type-checking 알고리즘이 있다고 한다.</p>

<h4 id="2detection">2. Detection</h4>

<p><strong>Deadlock</strong>이 발생할 수 있다고 보고, 감지한 뒤 해결하는 방법이다. <strong>Deadlock</strong>을 감지하기 위해서 recourse allocation 과 process states 를 추적 해야 한다. <strong>finite state-model</strong> 등을 이용해서 termination 조건을 결정하는 방법을 사용한다고 위키에 나와있다. (오토마타는 컴파일러뿐 아니라 여러 분야에서 중요한 것 같다.)</p>

<p>(1). <strong>Deadlock</strong> 을 발견한 뒤에는 <strong>Process Termiantion</strong> 을 통해 해결할 수 있다. 그러나 단순히 모든 프로세스를 종료 하게 되면, 진행중이던 computation 과 같은 리소스 들이 낭비되기 때문에 어떤 프로세스를 종료해야 가장 리소스 낭비가 적을지 결정해야 하는데, 이 부분이 쉽지 않다. 해당 프로세스를 종료 했을 때 <strong>Deadlock</strong> 이 풀릴지 아닐지를 계산하고, priority 와 process age 를 고려해야 하기 때문에 복잡하다.</p>

<p>(2). 다른 대안으로 <strong>Deadlock</strong>이 풀릴 때 까지 <strong>Resource Preemption</strong> 을 사용할 수 도 있다.</p>

<h4 id="3prevention">3. Prevention</h4>

<p><strong>Coffman conditions</strong> 중 하나를 방지하면 된다. (참 쉽죠?) </p>

<p>(1). <strong>Mutual exclusion</strong> 조건을 제거한다는건, 어느 프로세스도 resource 에 대해 배타적인 접근 권한을 가지지 못한다는 건데, 놀랍게도 <strong>spooled</strong> 될 수 없는 리소스에 대해서는 이러한 방법을 사용하지 못한다. 게다가 spooled resources 라 하더라도 <strong>Deadlock</strong> 은 여전히 발생할 수 있다. <strong><a href='http://en.wikipedia.org/wiki/Non-blocking_algorithm' >Non-blocking synchronization</a></strong> 알고리즘이 <strong>mutual exclusion</strong> 을 피할 수 있는 방법인데, 이 알고리즘은 스레드의 execution 이 indifinitely postponed 되는걸 막는다. <a href='http://www.slideshare.net/zzapuno/kgc2013-3' >여기</a> 에 의하면, 정해진 시간당 최소한 하나의 호출이 완료될 때 <strong>Lock-free</strong> 하다고 볼 수 있으며 충돌과는 관계 없이 모든 호출이 완료되면 <strong>Wait-free</strong> 하다고 한다. 아래는 위키를 인용</p>

<blockquote>
  <p>In computer science, a non-blocking algorithm ensures that threads competing for a shared resource do not have their execution indefinitely postponed by mutual exclusion. A non-blocking algorithm is lock-free if there is guaranteed system-wide progress regardless of scheduling; wait-free if there is also guaranteed per-thread progress.</p>
</blockquote>

<p>(2). <strong>Resource holding</strong> 조건의 경우에는 프로세스에게 <strong>시작 전에 필요한 모든 리소스를 요청</strong>하도록 함으로써 해결할 수 있는데, 말이 쉽지 시작 전에 사용할 모든 리소스를 파악하는 것도 어려우며, 모든 리소스를 사용할거라는 이유만으로 미리 할당하는 것은 비효율적이다. </p>

<p>다른 방법으로는 프로세스가 아무런 리소스를 가지고 있지 않을때만 리소스를 요청하도록 하는 방법이 있다. 따라서 프로세스들은 처음에 가지고 있는 모든 리소스를 release 해야만 이후에 필요한 리소스를 요청할 수 있다. 이 방법 또한 리소스가 덜 사용되므로 비효율적이다. 또한 자주 사용되는 리소스를 사용하는 프로세스는 무기한 대기할 수 있어 기아상태를 낳을 수 있다. <strong><a href='http://en.wikipedia.org/wiki/Serializing_tokens' >Serializing token</a></strong> 이 <strong>All-or-none</strong> 알고리즘으로 알려져 있다.</p>

<p><strong>Serializing token</strong> 와 <strong>Mutexex</strong> 는 shared resource 를 동시에 접근하는걸 막는다는 점에서 비슷하지만, <strong>Serializing tokens</strong> 은 해당 스레드가 blocked 혹은 asleep 상태일때는 다른 스레드의 shared resource 에 대한 접근을 막지 못한다. 따라서 <strong>Timeslicing</strong>, <strong>Preemption</strong>, <strong>Concurrent Execution</strong> 에 대해서는 <strong>Mutexes</strong> 처럼 동작하지만 <strong>Voluntary Blocking</strong> 에 대해서는 다른 스레드의 리소스 접근을 허용할 수 있다.</p>

<p>그럼에도 불구하고, <strong>Mutexes</strong> 가 <strong>Deadlock</strong> 이나 <strong>Priority Inversion</strong> 등 해결하기 어려운 문제를 발생시킬 수 있기 때문에, <strong>Deadlock</strong> 이 발생하지 않고, 코드를 간결하게 만드는 <strong>Serializing Tokens</strong> 을 이용하기도 한다. 아래는 위키 인용</p>

<blockquote>
  <p>Serializing tokens allow programmers to write multiprocessor-safe code without themselves or the lower level subsystems needing to be aware of every single entity that may also be holding the same token.</p>
  
  <p>In fact, the fact that tokens do not deadlock coupled with the fact that there is no expectation of atomicity for earlier acquired tokens when later operations block leads to a great deal of code simplification. If you look at FreeBSD-5, you will notice that FreeBSD-5 passes held mutexes down the subroutine stack quite often, in order to allow some very deep procedural level to temporarily release a mutex in order to switch or block or deal with a deadlock. There is a great deal of code pollution in FreeBSD-5 because of this (where some procedures must be given knowledge of the mutexes held by other unrelated procedures in order to function properly).</p>
</blockquote>

<p>(3). 어떤 프로세스든 최소 일정시간동안은 리소스를 보유해야 하기 때문에 <strong>No preempition</strong> 조건을 막기는 어렵거나 불가능할 수 있다. 게다가 리소스가 대해 <strong>Preemption System</strong> 의 경우에는 inconsistent processing outcome 이나, thrashing 이 발생할 수 있다.</p>

<p>일반적으로 잠긴(locked out) 리소스에 대한 preemption 은 <strong>rollback</strong> 을 의미하는데, 이건 오버헤드가 무지 크므로 주의해야 한다. preemption 을 허용하는 알고리즘에는 <strong><a href='http://en.wikipedia.org/wiki/Lock-free_and_wait-free_algorithms' >lock-free and wait-free algorithms</a></strong> 과 <strong><a href='http://en.wikipedia.org/wiki/Optimistic_concurrency_control' >optimistic concurrency control</a></strong> 이 있다.</p>

<p>(4). <strong>Circular Wait</strong> 을 방지하는 방법은, 크리티컬 섹션에서 인터럽트를 불가능하게 만들고 resource 에 대해 order 를 만들어 두어, 순서대로 얻어야만 상위 레벨의 resource 를 얻도록 하는 방법이 있다. <a href='http://en.wikipedia.org/wiki/Dining_philosophers_problem' #Resource_hierarchy_solution">식사하는 철학자</a> 문제에서 다익스트라가 제안한 방법이기도 하다.</p>

<p>그러나 이 방법은 하위 레벨의 리소스를 점유하기 위해서는, 상위 레벨의 리소스를 release 해야 하기 때문에 오버헤드가 생긴다. 특히 대용량 데이터베이스에 접근하는 어플리케이션의 경우, low-level 레코드를 얻기 위해 high-level 레코드를 방출하는 경우가 발생할 수 있는데, 극심한 비효율을 야기할 것이다.</p>

<h4 id="4aviodance">4. Aviodance</h4>

<p>리소스에 대해 특정 정보를 알 수 있는 경우, 리소스를 할땅 할 때마다 시스템이 <strong>Deadlock</strong> 을 야기할 수 있는 unsafe 한 상태로 넘어가는지 검사하여 <strong>Deadlock</strong> 을 피할 수 있다. 이를 위해서는 최소한 다음의 조건들을 알아야 한다.</p>

<ul>
<li>resources currently available</li>
<li>resources currently allocated to each process</li>
<li>resources that will be required and release by these processes in the future</li>
</ul>

<p>대표적인 알고리즘이 <strong><a href='http://en.wikipedia.org/wiki/Banker%27s_algorithm' >Banker's algorithm</a></strong> 이다. 새로운 프로세스가 시스템에 등록될때는, 어떤 리소스가 요구될지 미리 기록해야 하며 이 리소스들은 시스템이 가진 리소스를 초과하지 않아야 한다. 리소스가 할당 될때도, 시스템이 가진 총량을 넘을 수 없으며 사용 가능한 한도 내에 있어야 리소스가 프로세스에게 할당이 된다. 그러나 프로세스가 얼마만큼의 리소스가 필요할지 사전에 정확하게 예측하는건 어려운 일이다.</p>

<p><strong>Wait/Die</strong> 또는 <strong>Wound/Wait</strong> 이라 불리는 알고리즘도 있다. 타임스탬프를 이용해서 어느 프로세스가 오래되었는지 판별한 뒤에 다음과 같은 알고리즘을 적용할 수 있다. 알파벳 O 는 오래된 프로세스, Y 는 신규 프로세스다</p>

<ol>
<li><p><strong>Wait/Die</strong>  </p>

<ul><li>O needs a resource held by Y : O Waits</li>
<li>Y needs a resource held by O : Y dies</li></ul></li>
<li><p><strong>Wound/Die</strong>  </p>

<ul><li>O needs a resource held by Y : Y dies</li>
<li>Y needs a resource held by O : Y waits</li></ul></li>
</ol>]]></description><link>http://1ambda.github.io/deadlock/</link><guid isPermaLink="false">6e81bd41-1934-419f-b475-b148af68c7ab</guid><category><![CDATA[Operating System]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 22 Sep 2014 00:40:26 GMT</pubDate></item><item><title><![CDATA[Practical Common Lisp, Chapter 7]]></title><description><![CDATA[<h3 id="macrosstandardcontrolconstrucs">MACROS : STANDARD CONTROL CONSTRUCS</h3>

<blockquote>
  <p>All programmers should be used to the idea that the definition of a language can include a standard library of functionality that is implemented in terms of the "core" language functionality that could have benn implemented by any programmer on top of the language if it hand't been defined as part of the standard library.</p>
</blockquote>

<p>다른 언어에서 특정 기능이 부족할때 새로운 클래스나 메소드를 정의함으로서 standard library 를 확장할 수 있지만, Lisp 은 이 방법 외에도 <strong>Macro</strong> 라는 조금 다른 방식을 제공한다.</p>

<p>각 매크로는<code>s-exp</code> 가 어떻게 lisp forms 으로 확장될지를 결정하는 자신만의 <strong>Syntax</strong> 를 정의할 수 있다. 이런 <strong>Macro</strong> 의 기능으로 인해서 <strong>Language</strong> 자체의 <strong>Syntax</strong> 가 확장될 수 있다. 대표적인 예가 <code>WHEN</code>, <code>DOLIST</code>, <code>LOOP</code> 와 같은 control constructs 와 <code>DEFUN</code>, <code>DEFPARAMETER</code> 과 같은 definitinal forms 들이다.</p>

<h4 id="whenandunless">WHEN and UNLESS</h4>

<p><code>(if condition then-form [else-form])</code> 은 <code>then-form</code> 과 <code>else-form</code> 이 single lisp form 이어야 한다는 제한을 가지고 있다. </p>

<p>그렇기 때문에 스팸 메일을 받았을때, 폴더에 저장하고, 데이터베이스에 업데이트 하려고 할 때 <code>if</code> 구문을 다음과 같이 작성하면, 제대로 작동하지 않는다. </p>

<pre><code class="lisp">(if (spam-p current-message)
    (file-in-spam-folder current-message)
    (update-spam-database current-message))
</code></pre>

<p>이 코드의 경우 <code>update-spam-database</code> 함수는 <code>if-then</code> 이 아니라 <code>else-then</code> 에 붙어있는 form 으로 인식되어 의도했던 바 대로 실행되지 않는다.</p>

<p><code>progn</code> 을 이용하면, 여러 form 을 묶을 수 있기 때문에 다음과 같이 작성하면 제대로 동작한다.</p>

<pre><code class="lisp">(if (spam-p current-message)
    (progn
      (file-in-spam-folder current-message)
      (update-spam-database current-message)))
</code></pre>

<p>그러나 매번 <code>progn</code> 을 써야한다는 사실이 귀찮고, <code>if</code> 와 <code>progn</code> 의 조합으로 해당 역할을 해낼 수 있다는걸 깨달았으므로, 다음과 같은 인터페이스를 가지는 <code>when</code> 매크로를 작성해보자.</p>

<pre><code class="lisp">(when (spam-p current-message)
  (file-in-spam-folder current-message)
  (update-spam-database current-message))

(defmacro when (condition &amp;rest body)
  `(if ,condition (progn ,@body)))

(defmacro unless (condition &amp;rest body)
  `(if (not ,condition) (progn ,@body)))
</code></pre>

<h4 id="cond">COND</h4>

<p><code>if</code> 같은 경우도, 중첩되면 보기가 싫어질 수 있다.</p>

<pre><code class="lisp">(if a
    (do-x)
    (if b
        (do-y)
        (do-z)))
</code></pre>

<p>이를 위해서 <code>cond</code> 매크로를 만들어 보자.</p>

<pre><code class="lisp">(defmacro cond (&amp;rest body)
  (when body
    (let ((clause (first body)))
      `(if ,(first clause) (progn ,@(rest clause))
           (cond1 ,@(rest body))))))
</code></pre>

<h4 id="andorandnot">AND, OR, and NOT</h4>

<p><code>AND</code> 와 <code>OR</code> 같은 경우 <strong>short-circuit</strong> 을 구현하기 위해서는, 두번 째 인자를 평가하지 않아야 하는데, 일반 함수로는 인자의 평가 시기를 조절하기 불가능하고, 매크로를 이용하면 그럴 수 있다.</p>

<pre><code class="lisp">;; AND and OR macros
(defmacro and1 (x &amp;rest other)
  `(if ,(not other)
       ,x
       (if ,x (and1 ,@other) nil)))

(defmacro or1 (x &amp;rest other)
  `(if ,(not other)
       ,x
       (if ,x ,x (or1 ,@other))))
</code></pre>

<h4 id="looping">Looping</h4>

<p>Lisp 의 25가지 special operators 는 직접적으로 Looping 을 지원하지 <strong>않기</strong> 때문에 Lisp 의 모든 looping control constructs 는 이 specical operator 를 이용해 만든 Macro 다.</p>

<p><code>DO</code> 는 강력하지만, less expressie 하기 때문에 <code>DO</code> 위에 만들어진 <code>DOTIMES</code> 와 <code>DOLIST</code> 를 제공한다. <code>LOOP</code> 는 non-lispy, english-like 스타일의 문법을 제공한다.</p>

<h4 id="dolistanddotimes">DOLIST and DOTIMES</h4>

<p>아래는 <code>DOLIST</code> 와 <code>DOTIMES</code> 의 문법과 사용법이다.</p>

<pre><code class="lisp">;; syntax
(dolist (var list-form)
  body-form*)

(dotimes (var count-form)
  body-form*)

;; example
(dolist (x '(1 2 3)) (princ x) (princ x)) ;; 112233
(dotimes (x 4) (princ x) (princ x)) ;; 00112233
(dotimes (x 4) (print x) (if (= (/ x 2) 0) (return))) ;; 0 1 2
(dotimes (x 20)
       (dotimes (y 20)
         (format t "x: ~d, y: ~d~%" x y)))
</code></pre>

<h4 id="do">DO</h4>

<p><code>DO</code> 의 Syntax 와 사용법은 아래와 같다.</p>

<pre><code class="lisp">;; Syntax
(do (variable-definitions*)
    (end-test-form result-form*)
  statement*)

;; Usage : fibonacci
(do ((n 0 (+1 n))
     (cur 0 next
     (next 1 (+ cur next)))
    ((=10 n) cur))

;; Usage: omiited result-form
;; same as (dotimes (i 4) (print i))
(do ((i 0 (1+ i)))
    ((&gt;= i 4))
   (print i))
</code></pre>]]></description><link>http://1ambda.github.io/practical-common-lisp-chapter-7/</link><guid isPermaLink="false">24b1d760-68b1-4861-b657-28f45fccdcc8</guid><category><![CDATA[Lisp]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 17 Sep 2014 17:18:47 GMT</pubDate></item><item><title><![CDATA[Functional Programming in Scala, Chapter 1]]></title><description><![CDATA[<p>2014-09-16, <strong>Functional Programming in Scala</strong>, Coursera</p>

<h3 id="11programmingparadigms">1.1 Programming Paradigms</h3>

<h4 id="imperativeprogramming">Imperative Programming</h4>

<ul>
<li>modifying mutable variables  </li>
<li>using assignment  </li>
<li>and control str such as if-then-else, loop breakl continue, return  </li>
</ul>

<p>절차적인 프로그래밍은 폰 노이만 구조랑 비슷한데, </p>

<ul>
<li>Mutable var = memory cells  </li>
<li>variable deferences = load instructions  </li>
<li>var assginment = store instsruction  </li>
<li>control structure = jumps  </li>
</ul>

<p>그런데 이런 instruction 들이 <code>word</code> 로 구성되어있으므로, 문제는  </p>

<blockquote>
  <p>"Scaling up, How can we avoid conceptualizign programs word by word?"</p>
</blockquote>

<p>결국 pure Imperative Programming 은 폰노이만 구조처럼 제한을 받는다고 볼 수 있다.</p>

<blockquote>
  <p>"One tends to conceptualize data structures word-by-words"</p>
</blockquote>

<p>그렇기 때문에 컬렉션, 다항식, 문자열과 같은 high-level abstraction 을 정의할 방법이 필요한데, 이상적으로는 <strong>Theory</strong> 를 만들면 해결할 수 있다. Theory 는 다음을 포함하는데</p>

<ul>
<li>one or more data types  </li>
<li>operations on these types  </li>
<li>laws that describe the relationships between values and opertions</li>
</ul>

<p>그러나, 일반적으로 <strong>Theory</strong> 는 mutation 에 대해서는 describe 하지 않지만 Imperative Programming 에서는 mutation 때문에 theories 가 부서질(break) 수 있음. 따라서 다음과 같은 것들이 필요하다. </p>

<ul>
<li>Concentrate on defining theories for operators expressed as function  </li>
<li>avoid mutations  </li>
<li>have powerful way to abstract and compose functions  </li>
</ul>

<p>정리하자면, Imperative Programming 에서는 high-level abstraction 을 위해 theory 를 이용할 수 있는데, Imperative Programming 에서는 mutation variable 을 이용하므로 theory 의 law 를 break 할 수 있다. 따라서 이런 단점을 해결하기 위해 나온 것이 Functional Programming 이다.</p>

<p>Functional Programming 에서는 상태가 Immutable 이기 때문에 <strong>Theory</strong> 를 구성하는 operator 를 만드는 것에 집중할 수 있다.</p>

<h4 id="functionalprogramming">Functional Programming</h4>

<ul>
<li>without mutable variables, assignments, loops  </li>
<li>focuses on functions</li>
</ul>

<p>FP offers the folloing benefits</p>

<ul>
<li>simpler reasoning principles  </li>
<li>better modularity  </li>
<li>good for exploiting parallelism fo mlticore and clod compting  </li>
</ul>

<h3 id="12elementsofprogramming">1.2 Elements of Programming</h3>

<h4 id="expression">Expression</h4>

<p>대다수의 언어들은 <strong>expression</strong> 과 관련해서 다음의 기능들을 제공한다</p>

<ul>
<li>primitive expressions, representing the simplest elements  </li>
<li>ways to combine expressions  </li>
<li>ways to abstract expressions, which introduce a name for an expression by which it can then be referred to.</li>
</ul>

<h4 id="evaluation">Evaluation</h4>

<p><strong>Non-primitive</strong> expression 은 최종적으로 value 를 만들기 전까지 다음과 같은 방식으로 evaluated 된다</p>

<ol>
<li>Take the leftmost operator  </li>
<li>Evaluate its operands (left before right)  </li>
<li>Apply the operator to the operands</li>
</ol>

<p><strong>A name</strong> is evaluatd by replacing it with the right hand side of its definition.</p>

<p>그러나 모든 expression 이 finite value 를 가지는 것은 아니다. </p>

<pre><code class="scala">def loop: Int = loop  
</code></pre>

<h4 id="evaluationoffunctionapplications">Evaluation of Function Applications</h4>

<p>Applications of parameterized functions 은 다음과 같은 방식으로 evaluated 된다. operator 와 얼추 비슷하다</p>

<p>(1) Evaluate all function arguments, from left to right <br />
(2.1) Replace the function application by the function's right-hand side, and, at the same time <br />
(2.2) Replace the formal parameters of the function by the actual arguments</p>

<pre><code class="scala">def square(x: Int) = x * *  
def sumOfSquares(x: Int, : Int) = square(x) + square(x)

sumOfSquares(3, 2+2)

// sumOfSquares(3, 4) : step (1) 
// square(3) + square(4) : step (2) 
// 3 * 3 + square(4) : step (1), (2)
// 9 + square(4)
// 9 + 4 * 4
// 9 + 16
// 25
</code></pre>

<p>인자를 먼저 평가하지 않을 경우 <code>square(2+2)</code> 가 <code>(2*2) + (2*2)</code> 로 reduced 되어 더 많은 계산을 야기할 수 있다.</p>

<h4 id="thesubstitutionmodel">The substitution model</h4>

<p>이렇게 Evaluation 해 나가는 과정을 <strong>The substitution model</strong> 이라 부른다. 이 모델의 근간이 되는 아이디어는 <strong>reducing an expression to a value</strong> 이고, <strong>side-effect</strong> 가 없는 한 모든 expressions 에 적용할 수 있다. 참고로 이 모델은 Functional Programming 의 근간이 되는 <strong>lambda-calculus</strong> 사용한 것이다.</p>

<h4 id="callbyvaluecallbyname">Call-by-value, Call-by-name</h4>

<p><code>square(4)</code> 처럼 <code>sumOfSquares</code> 의 인자가 먼저 평가되는 방식을 <strong>Call-by-value</strong>, <code>square(2+2)</code> 처럼 나중에 인자가 평가되는 방식을 <strong>Call-by-name</strong> 이라 부른다. </p>

<p>두 가지 방식 아래 조건이 지켜지는 한 모두 expression 을 value 로 reduce 한다</p>

<ul>
<li>the reuced expression consists of pure functions, and  </li>
<li><p>both evaluations terminate</p></li>
<li><p><strong>Call-by-value</strong> has the advantage that it evaluates every function argument only once  </p></li>
<li><strong>Call-by-name</strong> has the advantage that a function argument is not evaluated if the corresponding parameter is unused in the evaluation of the function body  </li>
</ul>

<h4 id="examples">Examples</h4>

<pre><code class="scala">def test(x: Int, y: Int) = x *x  
</code></pre>

<p>위와 같은 함수가 있다고 할때, <code>test(3, 4)</code> 는 똑같은 속도지만 <code>test(2+2, 3)</code> 은  <strong>Call-by-value</strong> 가, <code>test(2, 3+2)</code> 는 <strong>Call-by-name</strong> 이 더 빠르다</p>

<h3 id="13evaluationstrategiesandtermination">1.3 Evaluation Strategies and Termination</h3>

<p>But what if termination is not guaranteed?</p>

<pre><code class="scala">def test (x: Int, y: Int) = x * x  
def loop () = loop  
</code></pre>

<p>위의 예제에서 <code>test(3, loop)</code> 라는 expressions 은 <strong>Call-by-name</strong> 방식으로 평가될 수 있지만, <strong>Call-by-value</strong> 방식으로는 아니다. </p>

<p>Scala 은 일반적으로 re-computation 을 피하기 위해 <strong>Call-by-value</strong> 을 사용한다. 그러나 <code>def constOne(x: Int, y: =&gt; Int) = 1</code> 처럼 function parameter 가 <code>=&gt;</code> 로 시작하면 해당 인자는 <strong>Call-by-name</strong> 을 이용한다.</p>

<pre><code class="scala">def constOne(x: Int, y: =&gt; Int) = 1  
def loop() = loop

constOne(1+2, loop) // will be evaluated  
constOne(loop, 1+2) // will not be evaluated  
</code></pre>

<h3 id="14conditionalsandvaluedefinitions">1.4 Conditionals and Value Definitions</h3>

<h4 id="conditionalexpression">Conditional Expression</h4>

<pre><code class="scala">def abs(x: Int) = if (x &gt;= 0) x else -x  
</code></pre>

<p>In the above example, <code>x &gt;= 0</code> is a predicate, of type Boolean. and <code>If-else</code> is an expression not a statement</p>

<h4 id="shortcircuitevaluation">short-circuit evaluation</h4>

<p>Boolean 을 위한 Rule 을 다시 만들수 있다.</p>

<pre><code>!true      --&gt; false
!false     --&gt; true
true &amp;&amp; e  --&gt; e  
false &amp;&amp; e --&gt; false  
true || e  --&gt; true  
false || e --&gt; e  
</code></pre>

<p><code>&amp;&amp;</code> 와 <code>||</code> 의 경우에는 언제나 오른쪽 operand 가 평가되야 하는건 아닌데, 이러한 expression 을 보고 <strong>short-circuit evaluation</strong> 을 사용한다고 말한다.</p>

<h4 id="valuedefinitions">Value Definitions</h4>

<pre><code class="scala">def x loop(): Booelan = loop  
</code></pre>

<p>위의 식이 평가되는걸 보면 <code>def</code> 는 <strong>Call-by-value</strong> 를 이용하는걸 알 수 있다. 반대로 <code>val</code> 은 <strong>Call-by-value</strong> 를 사용한다. <code>val x = loop</code> 식을 평가하면, 무한 루프가 도는것을 확인할 수 있다. </p>

<h4 id="exercise">Exercise</h4>

<p><code>&amp;&amp;</code> 와 <code>||</code> 없이 <code>and</code> 함수를 구현하려다 보면, 다음과 같이 구현하는 경우가 있는데, </p>

<pre><code class="scala">def and(x: Boolean, y: Boolean = if (x) y else false  
</code></pre>

<p>이 경우 <code>and(false, loop)</code> 를 평가하면 올바르게 동작하지 않고 무한루프에 걸린다 따라서 두번 째 인자가 <strong>Call-by-name</strong> 을 이용해 평가되도록, 아래와 같이 작성해야 한다.</p>

<pre><code class="scala">def and(x: Boolean, y: =&gt; Booelan) = if (x) y else false  
def or(x: Boolean, y: =&gt; Boolean) = if (x) true else y  
</code></pre>

<h3 id="15examplesquarerootswithnewtonsmethod">1.5 Example: square roots with Newton's method</h3>

<p>일단 시작 전에 먼저 말하자면, Scala 에서 recursive function 의 경우에는 explicit return type 이 필요하다.</p>

<p><a href='http://kevin0960.tistory.com/entry/%EA%B3%A0%EC%B0%A8-%EB%B0%A9%EC%A0%95%EC%8B%9D%EC%9D%98-%ED%95%B4-%EA%B5%AC%ED%95%98%EA%B8%B0-%EB%89%B4%ED%8A%BC-%EB%9E%A9%EC%8A%A8%EB%B2%95-Newton-Rahpson' >뉴튼-랩슨 법</a>을 이용해서 제곱근을 구하는 Scala 코드를 작성하면</p>

<pre><code class="scala">  def abs(x: Double) = if (x &lt; 0) -x else x
  def sqrt(x: Int): Double = sqrtIter(1.0, x)
  def sqrtIter(guess: Double, x: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)

  def isGoodEnough(guess: Double, x: Double): Boolean =
    abs(guess * guess - x) / x &lt; 0.0001

  def improve(guess: Double, x: Double) =
    (guess + x / guess) / 2
</code></pre>

<p>실수에 대해 작업할때는 엄청나게 커다란 수와 작은 수에 대해 테스트를 해 보아야 한다. 만약 <code>isGoodEnough</code> 의 구현이 <code>abs(guess * guess -x ) &lt; 0.0001</code> 이라면 큰수에 대해서는 non-termination 이, 작은 수에 대해서는 invalid 한 값이 나올수 있다.</p>

<p>참고로, <strong>scalatest</strong> 에서는 <strong>floating point number</strong> 에 대한 테스틀 위해 다음과 같은 인터페이스를 지원한다.</p>

<pre><code class="scala">sevenDotOh should equal (6.9 +- 0.2)  
sevenDotOh should === (6.9 +- 0.2)  
sevenDotOh should be (6.9 +- 0.2)  
sevenDotOh shouldEqual 6.9 +- 0.2  
sevenDotOh shouldBe 6.9 +- 0.2  
</code></pre>

<h3 id="16blocksandlexicalscope">1.6 Blocks and Lexical Scope</h3>

<p>위에서 작성한 <code>sqrt</code> 를 block scope 를 이용하면 <code>x</code> 를 파라미터로 넘기는것을 제거해 간단히 만들 수 있다. </p>

<pre><code class="scala">  def abs(x: Double) = if (x &lt; 0) -x else x
  def sqrt(x: Int): Double = {

    def sqrtIter(guess: Double): Double =
      if (isGoodEnough(guess, x)) guess
      else sqrtIter(improve(guess))

    def isGoodEnough(guess: Double, x: Double): Boolean =
      abs(guess * guess - x) &lt; 0.0001

    def improve(guess: Double) =
      (guess +  x / guess) / 2

    sqrtIter(1.0)
  }
</code></pre>

<h4 id="semicolons">Semicolons</h4>

<p>Scala 에서 세미콜론은 옵션이지만 이와 관련된 이슈가 있다.</p>

<pre><code class="scala">someLongExp  
+ someOtherExp
</code></pre>

<p>이건 다음과 같이 interpreted 될 것이다.</p>

<pre><code class="scala">someLongExp;  
+ someOtherExp
</code></pre>

<p>Expression 이 분리 되는 것을 방지하기 위해 다음과 두 가지 방법을 이용할 수 있다.</p>

<pre><code class="scala">someLongExp +  
someOtherExp

// or

(someLongExp
+ someOtherExp)
</code></pre>

<h3 id="17tailrecursion">1.7 Tail Recursion</h3>

<pre><code class="scala">  def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)

  def factorial(n: Int): Int =
    if (n == 0) 1 else n * factorial(n - 1);
</code></pre>

<p>다음과 같은 재귀 함수가 있을때, 자세히 보면 <code>factorial(4)</code> 의 경우 Expression 이 점점 길어진다. <code>(4 * 3 * 2 * (1 * 1)</code></p>

<p>반대로 <code>gcd(3, 2)</code> 의 경우 계산과정을 살펴보면 <code>gcd(3, 2)</code>, <code>gcd(2, 1)</code> 로 진행된다. 식이 점점 길어지는게 아니라, 함수에서 변수만 바뀌는걸 알 수 있다. 이 경우 저장해야할 지역변수가 없기 때문에 stack frame 을 재활용 할 수 있으며, 이런 Recursive call 을 <strong>Tail Recursion</strong> 이라 부른다. 영문 설명을 보면,</p>

<p>If a function calls itself as its last action, the function's stack frame can e reused. This is called <strong>Tail Recursion</strong></p>

<blockquote>
  <p>Tail recursive functions are iterative processes</p>
</blockquote>

<p>In general, if the last action of a function consists of calling a function (which may be the same), one stack frame would be sufficient for both functions. Such calls are called <strong>tail-calls</strong></p>

<p><strong>tail-recursion</strong> 버전의 <code>factorial</code> 은 다음과 같다.</p>

<pre><code class="scala">  def tailFactorial(n: Int) = {
    def loop(acc: Int, n: Int): Int =
      if (n == 0) acc else loop(acc * n, n-1)
    loop(1, n);
  }
</code></pre>]]></description><link>http://1ambda.github.io/scala-chapter-1/</link><guid isPermaLink="false">13422f6a-c277-4a2f-8db9-682eeaca0144</guid><category><![CDATA[scala]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 16 Sep 2014 12:00:01 GMT</pubDate></item><item><title><![CDATA[MySQL Derived Table, Correlated Query]]></title><description><![CDATA[<h3 id="correlatedvsnoncorrelated">Correlated vs Non-Correlated</h3>

<p>아래는 <strong>Non-Correlated</strong> 쿼리다. 즉 내부(Inner) 쿼리가 외부(Outer) 쿼리를 참조하지 않는다.</p>

<pre><code class="mysql">SELECT name  
FROM city  
WHERE population &gt; (SELECT population  
                    FROM city
                    WHERE name = 'new york');
</code></pre>

<p>반면 아래는 <strong>Correlated</strong> 쿼리다. 내부 쿼리가 <code>co.code</code> 로 외부 쿼리를 참조한다.</p>

<pre><code class="mysql">SELECT name  
FROM country as co  
WHERE EXISTS (SELECT *  
              FROM city
              WHERE population &gt; 900 AND co.code = country_code);
</code></pre>

<p><strong>Correlated Query</strong> 는 이렇게 외부 쿼리에 대한 참조를 가지고 있기 때문에 외부 쿼리의 각 <strong>Row</strong> 마다 서브쿼리가 실행되고, 결국 성능은 떨어진다. 다시 말해 일반적인 서브 쿼리<strong>(Non-Correlated)</strong> 라면 <code>N + M</code> 번 만큼 연산을 수행하지만, <strong>Correlated</strong> 서브쿼리라면 <code>N x M</code> 만큼의 연산을 수행한다.</p>

<p>이런 <strong>Correlated Query</strong> 는 <strong>Join</strong> 구문을 이용한 쿼리로 변경할 수 있다.</p>

<pre><code class="mysql">SELECT DISTINCT country.name  
FROM country  
JOIN city ON country.code = city.country_code  
WHERE city.population &gt; 900;  
</code></pre>

<h3 id="derivedtable">Derived Table</h3>

<p>이런 성능 저하 때문에 일반적으로는 Correlated Subquery 대신에 <strong>Derived Table</strong> 을 사용한다. <code>FROM</code> 혹은 <code>JOIN</code> 구문에서 사용하는 서브쿼리를 <strong>Derived Table</strong> 이라 부른다. 본질적으로 <strong>Derived Table</strong> 은 실제 존재하는 테이블이 아니라, 쿼리 내에서만 존재하는 <strong>Inline View</strong> 다.</p>

<pre><code class="mysql">SELECT LastName, FirstName  
FROM  
    (SELECT * FROM Employee
     WHERE State = "NY") AS EmployeeDerivedTable
WHERE LastName = "Smith"  
ORDER BY FirstName  
</code></pre>

<h3 id="references">References</h3>

<ol>
<li><p><a href='http://sarahdba.blogspot.kr/2009/08/examples-of-bad-queries.html' >Example of bad queries</a></p></li>
<li><p><a href='http://www.programmerinterview.com/index.php/database-sql/derived-table-vs-subquery/' >Derived Table vs Subquery</a></p></li>
<li><p><a href='http://stackoverflow.com/questions/17268848/difference-between-subquery-and-correlated-subquery' >Difference between subquery and correlated subquery</a></p></li>
</ol>]]></description><link>http://1ambda.github.io/mysql-derived-table/</link><guid isPermaLink="false">94d49870-33be-4d17-abd5-1d04f6ff0f22</guid><category><![CDATA[mysql]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 19 Aug 2014 12:59:57 GMT</pubDate></item><item><title><![CDATA[Javascript Inheritance]]></title><description><![CDATA[<h2 id="prototypeinheritance">Prototype Inheritance?</h2>

<p>자바스크립트는 프로토타입 방식의 상속을 사용한다고들 말합니다. 프로토타입이란 무엇이고, 클래스 기반 상속과는 어떻게 다른지, 그리고 주의해야 할 점은 무엇인지 알아보겠습니다. 이 글에서 다루는 키워드는 아래와 같습니다.</p>

<ul>
<li>.constructor</li>
<li>.__proto__</li>
<li>.prototype</li>
<li>Object.create</li>
<li>new</li>
<li>Object, Function</li>
</ul>

<p>먼저 예제부터 보시겠습니다.</p>

<pre><code class="javascript">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create

// Shape - superclass (1)
function Shape() {  
  this.x = 0;
  this.y = 0;
}

// superclass method (2)
Shape.prototype.move = function(x, y) {  
    this.x += x;
    this.y += y;
    console.info("Shape moved.");
};

// Rectangle - subclass (3)
function Rectangle() {  
  Shape.call(this); // call super constructor.
}

// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype); (4)  
Rectangle.prototype.constructor = Rectangle; (5)

var rect = new Rectangle();

rect instanceof Rectangle // true.  
rect instanceof Shape // true.

rect.move(1, 1); // Outputs, "Shape moved."  
</code></pre>

<p>(1). 먼저 <code>Shape</code> 이라는 함수를 만듭니다. 자바스크립트에서는 객체를 생성하기 위한 함수를 <code>Constructor(생성자)</code> 라고 부르며, 생성자임을 알아볼 수 있게 첫 글자를 <strong>대문자</strong>로 작성하는 것이 관례입니다. 이렇게 만들어진 생성자는 <code>new</code> 를 통해 호출할 수 있습니다. 물론 생성자는 그 자체로서 함수이기 때문에 <code>Shape()</code> 과 같이 호출도 가능합니다. 그러나 <code>new</code> 가 있는것과 없는것은 조금 차이가 있습니다. 아래에서 알아보겠습니다.</p>

<p>(2). 생성자에 존재하는 <code>prototype</code> 속성, 즉 <code>Shape.prototype</code> 에 <code>move</code> 란 메소드를 추가하고 있습니다. 생성자의 <code>prototype</code> 속성에 추가된 모든 것들은 이 생성자를 통해 생성된 모든 객체에서 사용 가능합니다. 그러나, 생성자의 <code>prototype</code> 이 아니라, 인스턴스에 추가된 속성들은 그 인스턴스만 사용할 수 있습니다.</p>

<pre><code class="javascript"> var s1 = new Shape();
s1.move(3, 3);

s1.isShape = true;

var s2 = new Shape();  
console.log (s2.isShape) // undefined  
console.log (typeof s2.isShape === "undefined") // true  
</code></pre>

<p>(3). <code>Rectangle</code> 이라는 새로운 생성자를 정의하고 있습니다. 그리고 이 생성자 내에서 <code>Shape.call(this)</code> 를 호출하여, <code>new Rectangle()</code> 을 통해 만들어지는 모든 인스턴스가 <code>Shape</code> 처럼 <code>this.x</code> 와 <code>this.y</code> 를 가지고, 0으로 초기화 하도록 합니다. 이 과정이 끝나면 다음과 같은 결과가 나옵니다.</p>

<pre><code class="javascript">function Rectangle() {  
    Shape.call(this);
}

var r1 = new Rectangle();  
console.log (r1.x); // 0  
console.log (r2.y); // 0  
</code></pre>

<p>그러나 이 시점에서 <code>r1</code> 은 <code>move</code> 란 메소드를 사용할 수 없습니다. <code>Shape.move</code> 는 있지만 이 <code>move</code> 메소드를 상속받은것은 아닙니다. <code>Rectangle</code> 은 단지 <code>this.x</code>, <code>this.y</code> 란 멤버변수를 상속받은 것 뿐입니다.</p>

<pre><code class="javascript">console.log (r1.move); // undefined  
</code></pre>

<p>(4). 드디어 <code>Rectangle.prototye</code> 에 <code>Shape.prototype</code> 을 연결해 주어 <code>r1</code> 에서도 <code>Shape.prototype</code> 에 정의된 메소드들을 사용할 수 있게끔 해줍니다. </p>

<pre><code class="javascript">r1.move(2, 2);  
console.log(r1.x); // 2  
console.log(r1.y); // 2  
</code></pre>

<p>여기서 Rectangle.prototype = Shape.prototype 을 하지않고 새롭게 Object.create 해주는 이유는, <code>Rectangle.prototype</code> 에 새로운 속성을 추가했을때, <code>Shape.prototype</code> 에 추가되도록 하지 않기 위함입니다. 다시 말해, <code>Rectangle</code> 에 추가한 것은, <code>Rectangle</code> 에만 추가되라는 것이지요.  </p>

<p><code>Rectangle.prototype = new Shape();</code> 처럼 <code>new</code> 를 사용하게 되면, 생성자를 호출하게 되어 <code>Rectangle.prototype</code> 에 인스턴스 변수인 <code>this.x</code> 와 <code>this.y</code> 가 추가됩니다.   이것은 우리가 원하지 않은 동작이기에, 일반적으로 <code>new</code> 를 이용해서 프로토타입을 생성하지 않습니다.</p>

<p>(5). <code>Object.create(Shape.prototype)</code> 으로 생성한 객체는 <code>constructor</code> 값으로 <code>Shape</code> 를 가지고 있습니다. 이 객체를 이제, <code>Rectangle.prototype</code> 에서 사용하므로 값을 변경해 줍니다. </p>

<h3 id="__proto__"><strong>proto</strong></h3>

<p><code>__proto__</code> 속성은 자바스크립트에서 상속의 핵심입니다. 모든 객체들은 자신의 속성을 찾다가 실패하면, <code>__proto__</code> 를 통해 더 검색을 시도합니다. 무슨말인고 하니, 다음과 같은 코드가 있을때</p>

<pre><code class="javascript">var r1 = new Rectangle();

r1.move(1, 1);  
</code></pre>

<p>실제로 <code>Rectangle</code> 은 <code>move</code> 라는 메소드를 인스턴스 멤버로도, 프로토타입 멤버로도 가지고 있지 않습니다. 다시 말해서, 아래와 같은 코드를 작성한 적이 없단 말이지요.</p>

<pre><code class="javascript">// Method per instance
function Rectangle() {  
    this.move = function(_x, _y) { this.x = _x; this.y = _y; };
}

// Method for specific instance
r1.move = function(_x, _y) { this.x = _x; this.y = _y; };

// Prototype method
Rectangle.prototype.move = function(_x, _y) { this.x = _x; this.y = _y; };  
</code></pre>

<p>이런 작업을 해 준 적이 없는데, 어떻게 <code>move</code> 메소드를 찾는걸까요? 우리는 <code>move</code> 를 <code>Shape.prototype</code> 에만 추가했는데요! 비결은 아래와 같습니다.</p>

<ol>
<li><p><code>r1</code> 인스턴스 자체에 <code>move</code> 메소드가 인스턴스에 없기 때문에 <code>r1.__proto__</code> 에서 탐색하게 됩니다.</p></li>
<li><p>인스턴스가 가지고 있는 <code>__proto__</code> 의 값은, 생성자의 프로토타입, 즉 <code>Rectangle.prototype</code> 입니다. 따라서 이곳을 검색합니다. 그러나 <code>Rectangle</code> 프로토타입에도 <code>move</code> 메소드는 없습니다.</p></li>
<li><p><code>Rectangle.prototype.__proto__</code> 를 검색합니다. <code>Rectangle.prototype</code> 은 <code>Object.create(Shape.prototype)</code> 을 통해 생성되었고, 이것은 인스턴스 멤버가 없는 <code>Shape</code> 인스턴스 이기 때문에, <code>Rectangle.prototype.__proto__</code> 의 값은 <code>Shape.prototype</code> 이 됩니다. </p></li>
<li><p><code>Shape.prototype</code> 에는 <code>move</code> 가 있기 때문에, 이를 실행합니다.</p></li>
<li><p>만약 <code>Shape.prototype</code> 에도 <code>move</code> 가 없다면, <code>Shape.prototype.__proto__</code> 를 탐색합니다. 모든 객체는 Default 값으로 <code>Object</code> 를 상속받으며, <code>Shape</code> 도 마찬가지입니다. <code>Shape</code> 은 <code>Object</code> 를 상속받았기 때문에 <code>Shape.prototype.__proto__</code> 는 <code>Object.prototype</code> 을 가리킵니다. 여기서 메소드를 검색합니다.</p></li>
<li><p>만약 <code>Object.prototype</code> 에도 없다면, <code>Object.prototype.__proto__</code> 를 검색하나, 이 값은 <code>null</code> 이기 때문에 멤버 검색에 실패하고 <code>undefined</code> 를 돌려줍니다.</p></li>
</ol>

<p>다른 예제지만, 이미지를 통해 보는것도 이해에 도움이 될 듯 하여 이미지를 같이 첨부합니다.</p>

<p><br/>  </p>

<p>  
<img src='http://mckoss.com/jscript/Prototype.gif'  />  
</p>  

<p align="center">  
(<a href='http://mckoss.com/jscript/object.htm' >http://mckoss.com/jscript/object.htm</a>)
</p>  

<p><br/></p>

<h3 id="objectfunction">Object, Function</h3>

<p>자바스크립트의 모든 함수는 <code>Function</code> 의 인스턴스입니다. 무슨 말인고 하니, 사용자가 정의한 함수들은 <code>__proto__</code> 값으로 <code>Function.prototype</code> 을 가진다는 뜻이지요.</p>

<pre><code class="javascript">function example() {};

example.__proto__ === Function.prototype; // true  
</code></pre>

<p>그리고 <code>Function</code> 은 <code>Object</code> 를 상속합니다. 다시 말해, </p>

<pre><code class="javascript">example.__proto__.__proto__ == Object.prototype  
</code></pre>

<p>그리고 이전에 언급했듯이, <code>Object.prototype.__proto__</code> 는 <code>null</code> 입니다.</p>

<pre><code class="javascript">Object.prototype.__proto__ === null // true  
</code></pre>

<p>그리고 <code>Object</code> 그 자체는, <code>Function</code> 을 상속합니다.</p>

<pre><code class="javascript">Object.__proto__ === Function.prototype // true  
</code></pre>

<p>그래서 <code>Function</code> 과 <code>Object</code> 를 설명할때, 아래와 같은 그림으로 설명할 수 있습니다. 아래 그림에서 빨간 선으로 이어진 <code>[[Prototype]]</code> 은 <code>__proto__</code> 입니다.</p>

<p><br/>  </p>

<p align="center">  
<img src='http://i.stack.imgur.com/rcGmc.png'  />  
</p>  

<p align="center">  
(<a href='http://iwiki.readthedocs.org/en/latest/javascript/js_core.html' #inheritance'>http://iwiki.readthedocs.org/en/latest/javascript/js_core.html#inheritance</a>)
</p>  

<p><br/></p>

<h3 id="prototypeinhertancevsclassicalinheritance">Prototype Inhertance vs Classical Inheritance</h3>

<p>"그래요. 프로토타입 기반 상속이란 이런거군요!. 근데 이거 왜 하는건가요?"</p>

<p>제 짧은 지식으로 어줍잖게 대답하는 것보다, 링크로 연결해드리는게 더 나을것 같아서 관련 링크를 적어놓습니다. 꼭 읽어보셨으면 좋겠습니다.</p>

<ol>
<li><p><a href='http://stackoverflow.com/questions/19633762/classical-inheritance-vs-protoypal-inheritance-in-javascript' >classical-inheritance-vs-protoypal-inheritance-in-javascript</a></p></li>
<li><p><a href='http://aaditmshah.github.io/why-prototypal-inheritance-matters/' #toc_6">why-prototypal-inheritance-matters</a></p></li>
<li><p><a href='http://stackoverflow.com/questions/2800964/benefits-of-prototypal-inheritance-over-classical' >benefits-of-prototypal-inheritance-over-classical</a></p></li>
<li><p><a href='http://stackoverflow.com/questions/1450582/classical-vs-prototypal-inheritance' >classical-vs-prototypal-inheritance</a></p></li>
</ol>

<h3 id="newvsobjectcreate">new vs Object.create</h3>

<p>위에서 잠깐 언급했듯이 일반적으로는 프로토타입 객체를 만들기 위해서 <code>Object.create()</code>를 사용한다고 했었습니다. <code>new</code> 대신에요. 왜 그런가 <code>Object.create</code> 의 동작을 한번 알아보겠습니다.</p>

<ol>
<li><code>Object.create</code> 는 첫 번째 인자로 프로토타입을 받습니다.  </li>
<li>빈 객체를 하나 만들고, 이 객체의 <code>__proto__</code> 에 인자로 받은 프로토타입 객체를 연결합니다.  </li>
<li>프로토타입이 연결된 객체를 리턴합니다.</li>
</ol>

<p>아마 코드는 아래와 비슷할 겁니다. 간단한 설명을 위해 두번째 인자는 생략하겠습니다.</p>

<pre><code class="javascript">Object.prototype.create == function(proto) {  
  var obj = {};
  obj.__proto__ = proto;
  return obj;
}
</code></pre>

<p>따라서 어떠한 경우에도 생성자를 호출하지 않으므로 다음과 같은 코드가 생성자에 있을 경우 호출되지 않을겁니다.</p>

<pre><code class="javascript">function Shape() {  
  this.x = 0;
  this.y = 0;

  console.log("This is constructor for Shape");
}

var created = Object.create(Shape.prototype);  
var newed  = new Shape(); // "This is constructor for Shape" 

console.log( created.x ); // undefined  
console.log( newed.x ); // 0;  
</code></pre>

<p><code>new</code> 를 이용해 생성한 객체만 생성자가 호출되어, <strong>"This is constructor for Shape"</strong> 가 출력되고 <code>this.x = 0</code> 이 실행됩니다. </p>

<p><code>new Shape()</code> 의 로직은 아마 다음과 비슷할 겁니다. (더 자세한 내용은 <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new' >MDN: new Operator</a> 를 보시면 되겠습니다.)</p>

<ol>
<li>새로운 오브젝트를 생성하고,  </li>
<li>이 오브젝트의 <code>__proto__</code> 에 생성자의 프로토타입 객체를 연결합니다.  </li>
<li>생성자를 호출하고, 리턴합니다.</li>
</ol>

<pre><code class="javascript">// new Shape();

{
  var obj = {};
  obj.__proto__ = Shape.prototype;
  return Shape.apply(obj, arguments) || obj; 
}
</code></pre>

<p>이렇게 <code>new</code> 연산자는 생성자를 호출하기 때문에, 새롭게 사용할 프로토타입 객체에 의도치 않은 속성이 추가될 수 있습니다. 위의 예에서 <code>Rectangle</code> 에서 새롭게 사용할 프로토타입 객체는, 다시 말해 <code>Rectangle.prototype</code> 에 들어갈 객체는 단순히 <code>__proto__</code> 값으로 <code>Shape.prototype</code> 만 가지고 있으면 됩니다. </p>

<p>만약 <code>Object.create</code> 대신 <code>new</code> 를 사용하게 되면 <code>Rectangle.prototype.x</code> 와 <code>Rectangle.prototype.y</code> 가 <code>0</code> 으로 초기화되게 됩니다. 이는 원치 않았던 부작용입니다. 이런 이유에서 일반적인 경우에는 <code>new</code> 대신 <code>Object.create</code> 를 프로토타입 객체 생성에 사용해야 합니다. 아래처럼요</p>

<pre><code class="javascript">// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype);  
</code></pre>

<h3 id="constructor">.constructor</h3>

<p>모든 프로토타입 객체들은, <code>constructor</code> 란 프로퍼티가 있습니다. 이 값은 생성자를 가리킵니다. 그러므로 아래 코드는 <code>true</code> 를 출력합니다.</p>

<pre><code class="javascript">Rectangle.prototype.constructor === Rectangle // true  
</code></pre>

<p>우리의 예제인 <code>Rectangle</code> 에서도 위에 있는 코드처럼 프로토타입의 <code>constructor</code> 값을 초기화 하고 있습니다. 왜 그래야 할까요?</p>

<p>사실 <code>.constructor</code> 값은 별로 의미있는 값은 아닙니다. 만약 우리가 <code>constructor</code> 값으로 어떤 종류의 객체인지 판별한다면, 의미는 있겠지요. 그러나 일반적으로는 <code>instanceof</code> 를 사용합니다.</p>

<pre><code class="javascript">function Shape() { this.x = 0; }

var s1 = new Shape();

console.log( s1.__proto__.constrctor === Shape) // true  
console.log( s1 instanceof Shape) // true  
</code></pre>

<p>그럼 이렇게 <code>constructor</code> 를 비교하는 작업을 <code>instanceof</code> 내부에서 사용하느냐, 그것도 아닙니다. <code>instanceof</code> 는 <code>s1.__proto__</code> 와 <code>Shape.prototype</code> 을 비교합니다.</p>

<p><code>.constructor</code> 는 사실 정말로 쓸모가 없을지도 모르겠습니다. 그러나 자바스크립트 표준이 프로토타입 객체의 <code>constructor</code> 프로퍼티는 생성자를 가르켜야 한다고 말하는 한, 적어도 세팅은 해주는게 나쁘지 않다는게 제 생각입니다. 아래는 관련된 논의입니다. </p>

<p>Link : <strong><a href='http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property' >What it the significance of the javascript constructor property</a></strong></p>

<p>다시 우리의 예제로 돌아와서, 코드를 살펴보겠습니다.</p>

<pre><code class="javascript">// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype); (1)  
Rectangle.prototype.constructor = Rectangle; (2)  
</code></pre>

<p><code>Rectangle.prototype.constuctor</code> 를 다시 세팅해 주는 이유는, 이 값이 <code>Shape</code> 이기 때문입니다. <code>Rectangle.protoype</code> 은 <code>__proto__</code> 를 <code>Shape.prototype</code> 으로 가지는 오브젝트고, 따라서 (1) 라인에서 코드를 실행시켰을 때는 다음과 같은 결과가 나옵니다.</p>

<p><code>console.log( Rectangle.prototype.constructor ); // Shape</code></p>

<p>왜냐 하면 <code>Rectangle.prototype</code> 에는 <code>constructor</code> 가 없기 때문에 <code>Rectangle.prototype.__proto__</code> 에서 <code>constructor</code> 를 찾는데, <code>Rectangle.prototype.__proto__</code> 는 <code>Shape.prototype</code> 이기 때문이지요. </p>

<p>기본적으로 우리가 생성자를 만들면, 자바스크립트는 다음과 같이 프로토타입 객체를 만들고 이 프로토타입 객체의 <code>constructor</code> 를 세팅해 줍니다.</p>

<pre><code class="javascript">function Shape() { this.x = 0; }

console.log( Shape.prototype.constructor ); // Shape;  
</code></pre>

<p><code>Rectangle.prototype.constructor</code> 는 본래 처음 <code>Rectangle</code> 생성자를 만들었을때는 <code>Rectangle</code> 이었겠지만, (1) 라인의 코드를 실행 시킨 순간 <code>Shape</code> 으로 변경되고, 더 정확히 이 값은 <code>Rectangle.prototype.__proto__.consturctor</code> 에서 옵니다. 결국 값이 바뀌었기 때문에 원래대로 돌려주어야 하므로 아래와 같은 코드를 작성해준 것입니다.</p>

<pre><code class="javascript">Rectangle.prototype.constructor = Rectangle;  
</code></pre>

<p>자 이제, 아래 그림이 완벽히 이해되실 겁니다. </p>

<p><br/>  </p>

<p align="center">  
<img src='http://i.stack.imgur.com/UfXRZ.png'  />  
</p>  

<p align="center">  
(<a href='http://dmitrysoshnikov.com/ecmascript/javascript-the-core/' >http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a>)
</p>  

<p><br/></p>]]></description><link>http://1ambda.github.io/javascript-object-inheritance/</link><guid isPermaLink="false">57da5ecb-1d40-4b48-a3bb-09654e4574ac</guid><category><![CDATA[javascript]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 10 Aug 2014 03:54:29 GMT</pubDate></item><item><title><![CDATA[CLOS, Common Lisp Object System]]></title><description><![CDATA[<p>CLOS Brief Guide based on</p>

<ol>
<li><a href='http://www.aiai.ed.ac.uk/' ~jeff/clos-guide.html'>http://www.aiai.ed.ac.uk/~jeff/clos-guide.html</a>  </li>
<li><a href='http://www.cs.northwestern.edu/academics/courses/325/readings/clos.php' >http://www.cs.northwestern.edu/academics/courses/325/readings/clos.php</a>  </li>
<li><a href='http://cl-cookbook.sourceforge.net/clos-tutorial/' >http://cl-cookbook.sourceforge.net/clos-tutorial/</a>  </li>
<li><a href='http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html' >http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html</a></li>
</ol>

<p>Full source code : <a href='https://github.com/1ambda/CLOS/blob/master/concept.lisp' >Here</a></p>

<h3 id="1classof">1. class-of</h3>

<p>Built-in Classes</p>

<ul>
<li>SYMBOL</li>
<li>STRING</li>
<li>INTEGER</li>
<li>CONS</li>
<li>VECTOR</li>
<li>and so on</li>
</ul>

<p><br/>  </p>

<h3 id="2defstruct">2. defstruct</h3>

<p><code>defstruct</code> automatically define access-function and constructor</p>

<pre><code class="lisp">(defstruct cat 
  (name)
  (age))

(setf c1 (make-cat :name 'blue :age 6))
(cat-age c1) ;; 6
(cat-name c1) ;; BLUE
</code></pre>

<p><br/></p>

<p>What defined by <code>defstruct</code> is <code>STRUCTURE-CLASS</code></p>

<pre><code class="lisp">(class-of c1)

;; #&lt;STRUCTURE-CLASS CAT)
</code></pre>

<p><br/></p>

<h3 id="3defclass">3. defclass</h3>

<p>defclass gives you more controll. You can specify <strong>initform</strong>, <strong>initarg</strong>, <strong>accessor</strong> and so on.</p>

<pre><code class="lisp">;; syntax
(DEFCLASS class-name (superclass-name*)
  (slot-description*)
  class-option*)

(defclass person ()
  ((name :initarg :name
         :initform 'bill
         :accessor person-name)
   (age :initarg :age
        :initform 26
        :accessor person-age)))

(setf p1 (make-instance 'person :name 'bob :age 26))
</code></pre>

<p><br/></p>

<p>What defined by <code>defclass</code> is <code>STANDARD-CLASS</code> which subclasses <code>STANDARD-OBJECT</code></p>

<pre><code class="lisp">(class-of p1)
(find-class 'person)

;; #&lt;STANDARD-CLASS PERSON&gt;
</code></pre>

<p><br/></p>

<h3 id="4slot">4. Slot</h3>

<p>Class defined by <code>defclass</code> can have slots. Slot is member-variable.</p>

<pre><code class="lisp">(setf p1 (make-instance 'person :name 'bob :age 26''))
(slot-value p1 'name)

;; BOB
</code></pre>

<p><br/></p>

<p><code>describe</code> function can be used to show instance or classes information</p>

<pre><code class="lisp">(describe p1) ;; instance information
;; #&lt;PERSON {1002E70513}&gt;
;;   [standard-object]
;; 
;; Slots with :INSTANCE allocation:
;;   NAME  = HOON
;;   AGE   = 26

(describe 'person) ;; class information
;; COMMON-LISP-USER::PERSON
;;   [symbol]
;; 
;; PERSON names the standard-class #&lt;STANDARD-CLASS PERSON&gt;:
;;   Class precedence-list: PERSON, STANDARD-OBJECT, SB-PCL::SLOT-OBJECT, T
;;   Direct superclasses: STANDARD-OBJECT
;;   No subclasses.
;;   Direct slots:
;;     NAME
;;       Initargs: :NAME
;;       Readers: PERSON-NAME
;;       Writers: (SETF PERSON-NAME)
;;     AGE
;;       Initargs: :AGE
;;       Readers: PERSON-AGE
;;       Writers: (SETF PERSON-AGE)
</code></pre>

<p><br/></p>

<h3 id="5slotoptioninheritance">5. Slot Option Inheritance</h3>

<p><code>initform</code> Slot options can be overrided. But <code>initarg</code> and <code>accessor</code> can't</p>

<pre><code class="lisp">(defclass teacher (person)
  ((subject :accessor teacher-subject
        :initarg :subject
        :initform "None")))

(defclass math-teacher (teacher)
  ((subject :initform "Mathmatics")))

(defvar t1 nil)
(defvar m1 nil)

(setf t1 (make-instance 'teacher :name 'bob :age 25))
(setf m1 (make-instance 'math-teacher :name 'john :age 25))

(describe t1)

;; #&lt;TEACHER {10040F9363}&gt;
;;   [standard-object]
;; 
;; Slots with :INSTANCE allocation:
;;   NAME     = BOB
;;   AGE      = 25
;;   SUBJECT  = "None"


(describe m1)

;; #&lt;MATH-TEACHER {10040FE653}&gt;
;;   [standard-object]
;; 
;; Slots with :INSTANCE allocation:
;;   NAME     = JOHN
;;   AGE      = 25
;;   SUBJECT  = "Mathmatics"
</code></pre>

<p><br/></p>

<h3 id="6multipleinheritance">6. Multiple Inheritance</h3>

<p>CLOS supports <strong>Multiple Inheritance</strong>. But I'm not going to discuss.</p>

<p>If you are interested in how CLOS solves diamond problem, see <a href='http://en.wikipedia.org/wiki/Multiple_inheritance' >Wiki</a></p>

<blockquote>
  <p>Common Lisp CLOS attempts to provide both reasonable default behavior and the ability to override it. By default, the method with the most specific argument classes is chosen; then in the order in which parent classes are named in the subclass definition. However, the programmer can override this, by giving a specific method resolution order or stating a rule for combining methods. This is called method combination, which may be fully controlled. The MOP (metaobject protocol) also provides means to modify the inheritance, dynamic dispatch, class instantiation, and other internal mechanisms without affecting the stability of the system.</p>
</blockquote>

<p>Basically, There are two rules about inheritance.</p>

<ol>
<li>Each class is more specific than its superclasses.  </li>
<li>For a given class, superclasses listed earlier are more specific than those listed later.</li>
</ol>

<p>The second rule is useful in case of</p>

<pre><code class="lisp">(defclass a (b c) ...)
</code></pre>

<p><br/> <br />
<code>initform</code> or <code>method</code> are can be from both class <code>b</code> and class <code>c</code>. But class 'b' precedes class 'c', class 'c''s <code>method' or</code>initform` will be selected.</p>

<p><br/>  </p>

<h3 id="7genericfunction">7. Generic function</h3>

<p>In common lisp, class have only <strong>data</strong>. That means <strong>code (method)</strong> is separeted from class and is <strong>not</strong> tired to any class contrary to popular object-oriented language like Java, C++. This is why we call it <strong>generic</strong> method or function.</p>

<pre><code class="lisp">;; inherit standard object
(defclass person ()
  ((name :accessor person-name
     :initarg :name)
   (age :accessor person-age
    :initarg :age)))

;; inherit person
(defclass teacher (person)
  ((subject :accessor teacher-subject
        :initarg :subject
        :initform "nothing")))

;; inherit teacher
(defclass math-teacher (teacher)
  ((subject :initform "math")))

;; create instance
(setf t1 (make-instance 'teacher :name 'bob :age 25))
(setf m1 (make-instance 'math-teacher :name 'john :age 25))

;; call method

(work t1)
;; BOB is teaching nothing

(work m1)
;; JOHN is teaching math
</code></pre>

<p><br/> <br />
Calling method like this is somewhat different from other languages. In Java, methods are binded in a class. So we can call methods <code>Class.method(args)</code>. This is <strong>Single dispatch</strong>. According to <a href='http://en.wikipedia.org/wiki/Dynamic_dispatch' #Single_and_multiple_dispatch">wikipedia</a></p>

<blockquote>
  <p>If the decision of which version of a method to call is based entirely on the class of the object x, then this is known as single dispatch because an implementation is chosen based on a single type — the type of the instance. Single dispatch is supported by many object-oriented languages, including statically typed languages such as C++ and Java, and dynamically typed languages such as Smalltalk and Objective-C.</p>
</blockquote>

<p>But in Common Lisp, Method is invoked like <code>(method classes args)</code>. CLOS select which method will be called based on <strong>classes</strong>. This is <strong>Multiple dispatch</strong>.</p>

<blockquote>
  <p>In some languages such as Common Lisp and Dylan, methods or functions can also be dynamically dispatched based on the run-time type of arguments. Expressed in pseudocode, the code manager.handle(y) could call different implementations depending on the types of both objects manager and y. This is known as multiple dispatch.</p>
</blockquote>

<p><br/>  </p>

<h3 id="8methodcombination">8. Method Combination</h3>

<p>More than one method are applicable to a given set of arguments, the applicable methods are called <strong>single effective method</strong>. Common Lisp comes with predefined <strong>standard method combination</strong>. Also, It is possible to define new kinds of method combination. Standard method combination consists of</p>

<ul>
<li>primary</li>
<li>:before</li>
<li>:after</li>
<li>:around</li>
</ul>

<pre><code class="lisp">(defgeneric work (teacher)
  (:documentation "do something based on their job"))

(defmethod work ((t1 teacher))
  (format t "~a is teaching ~a"
    (slot-value t1 'name)
    (slot-value t1 'subject)))

(defmethod work ((t1 math-teacher))
  (format t "~a's major is math~%"
    (slot-value t1 'name))
  (call-next-method))

(setf t1 (make-instance 'teacher :name 'bob :age 25))
(setf m1 (make-instance 'math-teacher :name 'john :age 25))

(work m1)
;; BOB is teaching nothing

(work t1)
;; JOHN's major is math
;; JOHN is teaching math
</code></pre>

<p><br/> <br />
If <code>around</code>, <code>before</code>, <code>after</code> keyword is not specified, the generic method is <strong>Primary</strong> method which is responsible for providing primary implementation. Above <code>work</code> methods are primary. <code>call-next-method</code> indicates that control should be passaed from this method to the method specialized on superclass as arguments.</p>

<pre><code class="lisp">(setf t1 (make-instance 'teacher :name 'bob :age 25))
(setf m1 (make-instance 'math-teacher :name 'john :age 25))

(defgeneric work (teacher)
  (:documentation "do something based on their job"))

(defmethod work ((t1 teacher))
  (format t "~a is teaching ~a~%"
    (slot-value t1 'name)
    (slot-value t1 'subject)))

(defmethod work :before ((t1 teacher))
  (format t "~a is preparing the class~%"
    (slot-value t1 'name)))

(defmethod work :after ((t1 teacher))
  (format t "~a has done his class~%"
    (slot-value t1 'name)))

(defmethod work :around ((t1 teacher))
  (format t "start around for teacher class~%")
  (let ((result (call-next-method)))
    (format t "end around for teacher class~%")
    result))

(defmethod work ((t1 math-teacher))
  (format t "~a's major is math~%"
    (slot-value t1 'name))
  (call-next-method))

(work t1)
;; start around for teacher class
;; BOB is preparing the class
;; BOB is teaching nothing
;; BOB has done his class
;; end around for teacher class
;; NIL

(work m1)
;; start around for teacher class
;; JOHN is preparing the class
;; JOHN's major is math
;; JOHN is teaching math
;; JOHN has done his class
;; end around for teacher class
;; NIL
</code></pre>

<p><br/> <br />
These <code>:before</code>, <code>:after</code>, <code>:around</code> are auxiliary methods. Superclass's auxiliary methods are automatically called when you invoke subclass's a primary method. Of course, we can define subclass's auxiliary methods.</p>

<pre><code class="lisp">(defmethod work :before ((t1 math-teacher))
  (format t "Math teacher ~a is preparing the math class~%"
    (slot-value t1 'name)))

(defmethod work :after ((t1 math-teacher))
  (format t "Math teacher ~a has done his math class~%"
    (slot-value t1 'name)))

(defmethod work :around ((t1 math-teacher))
  (format t "start around for math-teacher class~%")
  (let ((result (call-next-method)))
    (format t "end around for math-teacher class~%")
    result))

(work m1)
;; start around for math-teacher class
;; start around for teacher class
;; Math teacher JOHN is preparing the math class
;; JOHN is preparing the class
;; JOHN's major is math
;; JOHN is teaching math
;; JOHN has done his class
;; Math teacher JOHN has done his math class
;; end around for teacher class
;; end around for math-teacher class
;; NIL
</code></pre>]]></description><link>http://1ambda.github.io/clos-common-lisp-object-system/</link><guid isPermaLink="false">f45536c4-b80f-424f-9134-3a3cd7e46f1d</guid><category><![CDATA[Lisp]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 23 Jul 2014 01:27:33 GMT</pubDate></item></channel></rss>