<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Old Lisper]]></title><description><![CDATA[Lisp, Emacs, FP]]></description><link>http://1ambda.github.io/</link><generator>Ghost 0.5</generator><lastBuildDate>Tue, 19 Aug 2014 16:21:48 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[MySQL Derived Table, Correlated Query]]></title><description><![CDATA[<h3 id="correlatedvsnoncorrelated">Correlated vs Non-Correlated</h3>

<p>아래는 <strong>Non-Correlated</strong> 쿼리다. 즉 내부(Inner) 쿼리가 외부(Outer) 쿼리를 참조하지 않는다.</p>

<pre><code class="mysql">SELECT name  
FROM city  
WHERE population &gt; (SELECT population  
                    FROM city
                    WHERE name = 'new york');
</code></pre>

<p>반면 아래는 <strong>Correlated</strong> 쿼리다. 내부 쿼리가 <code>co.code</code> 로 외부 쿼리를 참조한다.</p>

<pre><code class="mysql">SELECT name  
FROM country as co  
WHERE EXISTS (SELECT *  
              FROM city
              WHERE population &gt; 900 AND co.code = country_code);
</code></pre>

<p><strong>Correlated Query</strong> 는 이렇게 외부 쿼리에 대한 참조를 가지고 있기 때문에 외부 쿼리의 각 <strong>Row</strong> 마다 서브쿼리가 실행되고, 결국 성능은 떨어진다. 다시 말해 일반적인 서브 쿼리<strong>(Non-Correlated)</strong> 라면 <code>N + M</code> 번 만큼 연산을 수행하지만, <strong>Correlated</strong> 서브쿼리라면 <code>N x M</code> 만큼의 연산을 수행한다.</p>

<p>이런 <strong>Correlated Query</strong> 는 <strong>Join</strong> 구문을 이용한 쿼리로 변경할 수 있다.</p>

<pre><code class="mysql">SELECT DISTINCT country.name  
FROM country  
JOIN city ON country.code = city.country_code  
WHERE city.population &gt; 900;  
</code></pre>

<h3 id="derivedtable">Derived Table</h3>

<p>이런 성능 저하 때문에 일반적으로는 Correlated Subquery 대신에 <strong>Derived Table</strong> 을 사용한다. <code>FROM</code> 혹은 <code>JOIN</code> 구문에서 사용하는 서브쿼리를 <strong>Derived Table</strong> 이라 부른다. 본질적으로 <strong>Derived Table</strong> 은 실제 존재하는 테이블이 아니라, 쿼리 내에서만 존재하는 <strong>Inline View</strong> 다.</p>

<pre><code class="mysql">SELECT LastName, FirstName  
FROM  
    (SELECT * FROM Employee
     WHERE State = "NY") AS EmployeeDerivedTable
WHERE LastName = "Smith"  
ORDER BY FirstName  
</code></pre>

<h3 id="references">References</h3>

<ol>
<li><p><a href='http://sarahdba.blogspot.kr/2009/08/examples-of-bad-queries.html' >Example of bad queries</a></p></li>
<li><p><a href='http://www.programmerinterview.com/index.php/database-sql/derived-table-vs-subquery/' >Derived Table vs Subquery</a></p></li>
<li><p><a href='http://stackoverflow.com/questions/17268848/difference-between-subquery-and-correlated-subquery' >Difference between subquery and correlated subquery</a></p></li>
</ol>]]></description><link>http://1ambda.github.io/mysql-derived-table/</link><guid isPermaLink="false">94d49870-33be-4d17-abd5-1d04f6ff0f22</guid><category><![CDATA[mysql]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 19 Aug 2014 12:59:57 GMT</pubDate></item><item><title><![CDATA[Javascript Inheritance]]></title><description><![CDATA[<h2 id="prototypeinheritance">Prototype Inheritance?</h2>

<p>자바스크립트는 프로토타입 방식의 상속을 사용한다고들 말합니다. 프로토타입이란 무엇이고, 클래스 기반 상속과는 어떻게 다른지, 그리고 주의해야 할 점은 무엇인지 알아보겠습니다. 이 글에서 다루는 키워드는 아래와 같습니다.</p>

<ul>
<li>.constructor</li>
<li>.__proto__</li>
<li>.prototype</li>
<li>Object.create</li>
<li>new</li>
<li>Object, Function</li>
</ul>

<p>먼저 예제부터 보시겠습니다.</p>

<pre><code class="javascript">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create

// Shape - superclass (1)
function Shape() {  
  this.x = 0;
  this.y = 0;
}

// superclass method (2)
Shape.prototype.move = function(x, y) {  
    this.x += x;
    this.y += y;
    console.info("Shape moved.");
};

// Rectangle - subclass (3)
function Rectangle() {  
  Shape.call(this); // call super constructor.
}

// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype); (4)  
Rectangle.prototype.constructor = Rectangle; (5)

var rect = new Rectangle();

rect instanceof Rectangle // true.  
rect instanceof Shape // true.

rect.move(1, 1); // Outputs, "Shape moved."  
</code></pre>

<p>(1). 먼저 <code>Shape</code> 이라는 함수를 만듭니다. 자바스크립트에서는 객체를 생성하기 위한 함수를 <code>Constructor(생성자)</code> 라고 부르며, 생성자임을 알아볼 수 있게 첫 글자를 <strong>대문자</strong>로 작성하는 것이 관례입니다. 이렇게 만들어진 생성자는 <code>new</code> 를 통해 호출할 수 있습니다. 물론 생성자는 그 자체로서 함수이기 때문에 <code>Shape()</code> 과 같이 호출도 가능합니다. 그러나 <code>new</code> 가 있는것과 없는것은 조금 차이가 있습니다. 아래에서 알아보겠습니다.</p>

<p>(2). 생성자에 존재하는 <code>prototype</code> 속성, 즉 <code>Shape.prototype</code> 에 <code>move</code> 란 메소드를 추가하고 있습니다. 생성자의 <code>prototype</code> 속성에 추가된 모든 것들은 이 생성자를 통해 생성된 모든 객체에서 사용 가능합니다. 그러나, 생성자의 <code>prototype</code> 이 아니라, 인스턴스에 추가된 속성들은 그 인스턴스만 사용할 수 있습니다.</p>

<pre><code class="javascript"> var s1 = new Shape();
s1.move(3, 3);

s1.isShape = true;

var s2 = new Shape();  
console.log (s2.isShape) // undefined  
console.log (typeof s2.isShape === "undefined") // true  
</code></pre>

<p>(3). <code>Rectangle</code> 이라는 새로운 생성자를 정의하고 있습니다. 그리고 이 생성자 내에서 <code>Shape.call(this)</code> 를 호출하여, <code>new Rectangle()</code> 을 통해 만들어지는 모든 인스턴스가 <code>Shape</code> 처럼 <code>this.x</code> 와 <code>this.y</code> 를 가지고, 0으로 초기화 하도록 합니다. 이 과정이 끝나면 다음과 같은 결과가 나옵니다.</p>

<pre><code class="javascript">function Rectangle() {  
    Shape.call(this);
}

var r1 = new Rectangle();  
console.log (r1.x); // 0  
console.log (r2.y); // 0  
</code></pre>

<p>그러나 이 시점에서 <code>r1</code> 은 <code>move</code> 란 메소드를 사용할 수 없습니다. <code>Shape.move</code> 는 있지만 이 <code>move</code> 메소드를 상속받은것은 아닙니다. <code>Rectangle</code> 은 단지 <code>this.x</code>, <code>this.y</code> 란 멤버변수를 상속받은 것 뿐입니다.</p>

<pre><code class="javascript">console.log (r1.move); // undefined  
</code></pre>

<p>(4). 드디어 <code>Rectangle.prototye</code> 에 <code>Shape.prototype</code> 을 연결해 주어 <code>r1</code> 에서도 <code>Shape.prototype</code> 에 정의된 메소드들을 사용할 수 있게끔 해줍니다. </p>

<pre><code class="javascript">r1.move(2, 2);  
console.log(r1.x); // 2  
console.log(r1.y); // 2  
</code></pre>

<p>여기서 Rectangle.prototype = Shape.prototype 을 하지않고 새롭게 Object.create 해주는 이유는, <code>Rectangle.prototype</code> 에 새로운 속성을 추가했을때, <code>Shape.prototype</code> 에 추가되도록 하지 않기 위함입니다. 다시 말해, <code>Rectangle</code> 에 추가한 것은, <code>Rectangle</code> 에만 추가되라는 것이지요.  </p>

<p><code>Rectangle.prototype = new Shape();</code> 처럼 <code>new</code> 를 사용하게 되면, 생성자를 호출하게 되어 <code>Rectangle.prototype</code> 에 인스턴스 변수인 <code>this.x</code> 와 <code>this.y</code> 가 추가됩니다.   이것은 우리가 원하지 않은 동작이기에, 일반적으로 <code>new</code> 를 이용해서 프로토타입을 생성하지 않습니다.</p>

<p>(5). <code>Object.create(Shape.prototype)</code> 으로 생성한 객체는 <code>constructor</code> 값으로 <code>Shape</code> 를 가지고 있습니다. 이 객체를 이제, <code>Rectangle.prototype</code> 에서 사용하므로 값을 변경해 줍니다. </p>

<h3 id="__proto__"><strong>proto</strong></h3>

<p><code>__proto__</code> 속성은 자바스크립트에서 상속의 핵심입니다. 모든 객체들은 자신의 속성을 찾다가 실패하면, <code>__proto__</code> 를 통해 더 검색을 시도합니다. 무슨말인고 하니, 다음과 같은 코드가 있을때</p>

<pre><code class="javascript">var r1 = new Rectangle();

r1.move(1, 1);  
</code></pre>

<p>실제로 <code>Rectangle</code> 은 <code>move</code> 라는 메소드를 인스턴스 멤버로도, 프로토타입 멤버로도 가지고 있지 않습니다. 다시 말해서, 아래와 같은 코드를 작성한 적이 없단 말이지요.</p>

<pre><code class="javascript">// Method per instance
function Rectangle() {  
    this.move = function(_x, _y) { this.x = _x; this.y = _y; };
}

// Method for specific instance
r1.move = function(_x, _y) { this.x = _x; this.y = _y; };

// Prototype method
Rectangle.prototype.move = function(_x, _y) { this.x = _x; this.y = _y; };  
</code></pre>

<p>이런 작업을 해 준 적이 없는데, 어떻게 <code>move</code> 메소드를 찾는걸까요? 우리는 <code>move</code> 를 <code>Shape.prototype</code> 에만 추가했는데요! 비결은 아래와 같습니다.</p>

<ol>
<li><p><code>r1</code> 인스턴스 자체에 <code>move</code> 메소드가 인스턴스에 없기 때문에 <code>r1.__proto__</code> 에서 탐색하게 됩니다.</p></li>
<li><p>인스턴스가 가지고 있는 <code>__proto__</code> 의 값은, 생성자의 프로토타입, 즉 <code>Rectangle.prototype</code> 입니다. 따라서 이곳을 검색합니다. 그러나 <code>Rectangle</code> 프로토타입에도 <code>move</code> 메소드는 없습니다.</p></li>
<li><p><code>Rectangle.prototype.__proto__</code> 를 검색합니다. <code>Rectangle.prototype</code> 은 <code>Object.create(Shape.prototype)</code> 을 통해 생성되었고, 이것은 인스턴스 멤버가 없는 <code>Shape</code> 인스턴스 이기 때문에, <code>Rectangle.prototype.__proto__</code> 의 값은 <code>Shape.prototype</code> 이 됩니다. </p></li>
<li><p><code>Shape.prototype</code> 에는 <code>move</code> 가 있기 때문에, 이를 실행합니다.</p></li>
<li><p>만약 <code>Shape.prototype</code> 에도 <code>move</code> 가 없다면, <code>Shape.prototype.__proto__</code> 를 탐색합니다. 모든 객체는 Default 값으로 <code>Object</code> 를 상속받으며, <code>Shape</code> 도 마찬가지입니다. <code>Shape</code> 은 <code>Object</code> 를 상속받았기 때문에 <code>Shape.prototype.__proto__</code> 는 <code>Object.prototype</code> 을 가리킵니다. 여기서 메소드를 검색합니다.</p></li>
<li><p>만약 <code>Object.prototype</code> 에도 없다면, <code>Object.prototype.__proto__</code> 를 검색하나, 이 값은 <code>null</code> 이기 때문에 멤버 검색에 실패하고 <code>undefined</code> 를 돌려줍니다.</p></li>
</ol>

<p>다른 예제지만, 이미지를 통해 보는것도 이해에 도움이 될 듯 하여 이미지를 같이 첨부합니다.</p>

<p><br/>  </p>

<p>  
<img src='http://mckoss.com/jscript/Prototype.gif'  />  
</p>  

<p align="center">  
(<a href='http://mckoss.com/jscript/object.htm' >http://mckoss.com/jscript/object.htm</a>)
</p>  

<p><br/></p>

<h3 id="objectfunction">Object, Function</h3>

<p>자바스크립트의 모든 함수는 <code>Function</code> 의 인스턴스입니다. 무슨 말인고 하니, 사용자가 정의한 함수들은 <code>__proto__</code> 값으로 <code>Function.prototype</code> 을 가진다는 뜻이지요.</p>

<pre><code class="javascript">function example() {};

example.__proto__ === Function.prototype; // true  
</code></pre>

<p>그리고 <code>Function</code> 은 <code>Object</code> 를 상속합니다. 다시 말해, </p>

<pre><code class="javascript">example.__proto__.__proto__ == Object.prototype  
</code></pre>

<p>그리고 이전에 언급했듯이, <code>Object.prototype.__proto__</code> 는 <code>null</code> 입니다.</p>

<pre><code class="javascript">Object.prototype.__proto__ === null // true  
</code></pre>

<p>그리고 <code>Object</code> 그 자체는, <code>Function</code> 을 상속합니다.</p>

<pre><code class="javascript">Object.__proto__ === Function.prototype // true  
</code></pre>

<p>그래서 <code>Function</code> 과 <code>Object</code> 를 설명할때, 아래와 같은 그림으로 설명할 수 있습니다. 아래 그림에서 빨간 선으로 이어진 <code>[[Prototype]]</code> 은 <code>__proto__</code> 입니다.</p>

<p><br/>  </p>

<p align="center">  
<img src='http://i.stack.imgur.com/rcGmc.png'  />  
</p>  

<p align="center">  
(<a href='http://iwiki.readthedocs.org/en/latest/javascript/js_core.html' #inheritance'>http://iwiki.readthedocs.org/en/latest/javascript/js_core.html#inheritance</a>)
</p>  

<p><br/></p>

<h3 id="prototypeinhertancevsclassicalinheritance">Prototype Inhertance vs Classical Inheritance</h3>

<p>"그래요. 프로토타입 기반 상속이란 이런거군요!. 근데 이거 왜 하는건가요?"</p>

<p>제 짧은 지식으로 어줍잖게 대답하는 것보다, 링크로 연결해드리는게 더 나을것 같아서 관련 링크를 적어놓습니다. 꼭 읽어보셨으면 좋겠습니다.</p>

<ol>
<li><p><a href='http://stackoverflow.com/questions/19633762/classical-inheritance-vs-protoypal-inheritance-in-javascript' >classical-inheritance-vs-protoypal-inheritance-in-javascript</a></p></li>
<li><p><a href='http://aaditmshah.github.io/why-prototypal-inheritance-matters/' #toc_6">why-prototypal-inheritance-matters</a></p></li>
<li><p><a href='http://stackoverflow.com/questions/2800964/benefits-of-prototypal-inheritance-over-classical' >benefits-of-prototypal-inheritance-over-classical</a></p></li>
<li><p><a href='http://stackoverflow.com/questions/1450582/classical-vs-prototypal-inheritance' >classical-vs-prototypal-inheritance</a></p></li>
</ol>

<h3 id="newvsobjectcreate">new vs Object.create</h3>

<p>위에서 잠깐 언급했듯이 일반적으로는 프로토타입 객체를 만들기 위해서 <code>Object.create()</code>를 사용한다고 했었습니다. <code>new</code> 대신에요. 왜 그런가 <code>Object.create</code> 의 동작을 한번 알아보겠습니다.</p>

<ol>
<li><code>Object.create</code> 는 첫 번째 인자로 프로토타입을 받습니다.  </li>
<li>빈 객체를 하나 만들고, 이 객체의 <code>__proto__</code> 에 인자로 받은 프로토타입 객체를 연결합니다.  </li>
<li>프로토타입이 연결된 객체를 리턴합니다.</li>
</ol>

<p>아마 코드는 아래와 비슷할 겁니다. 간단한 설명을 위해 두번째 인자는 생략하겠습니다.</p>

<pre><code class="javascript">Object.prototype.create == function(proto) {  
  var obj = {};
  obj.__proto__ = proto;
  return obj;
}
</code></pre>

<p>따라서 어떠한 경우에도 생성자를 호출하지 않으므로 다음과 같은 코드가 생성자에 있을 경우 호출되지 않을겁니다.</p>

<pre><code class="javascript">function Shape() {  
  this.x = 0;
  this.y = 0;

  console.log("This is constructor for Shape");
}

var created = Object.create(Shape.prototype);  
var newed  = new Shape(); // "This is constructor for Shape" 

console.log( created.x ); // undefined  
console.log( newed.x ); // 0;  
</code></pre>

<p><code>new</code> 를 이용해 생성한 객체만 생성자가 호출되어, <strong>"This is constructor for Shape"</strong> 가 출력되고 <code>this.x = 0</code> 이 실행됩니다. </p>

<p><code>new Shape()</code> 의 로직은 아마 다음과 비슷할 겁니다. (더 자세한 내용은 <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new' >MDN: new Operator</a> 를 보시면 되겠습니다.)</p>

<ol>
<li>새로운 오브젝트를 생성하고,  </li>
<li>이 오브젝트의 <code>__proto__</code> 에 생성자의 프로토타입 객체를 연결합니다.  </li>
<li>생성자를 호출하고, 리턴합니다.</li>
</ol>

<pre><code class="javascript">// new Shape();

{
  var obj = {};
  obj.__proto__ = Shape.prototype;
  return Shape.apply(obj, arguments) || obj; 
}
</code></pre>

<p>이렇게 <code>new</code> 연산자는 생성자를 호출하기 때문에, 새롭게 사용할 프로토타입 객체에 의도치 않은 속성이 추가될 수 있습니다. 위의 예에서 <code>Rectangle</code> 에서 새롭게 사용할 프로토타입 객체는, 다시 말해 <code>Rectangle.prototype</code> 에 들어갈 객체는 단순히 <code>__proto__</code> 값으로 <code>Shape.prototype</code> 만 가지고 있으면 됩니다. </p>

<p>만약 <code>Object.create</code> 대신 <code>new</code> 를 사용하게 되면 <code>Rectangle.prototype.x</code> 와 <code>Rectangle.prototype.y</code> 가 <code>0</code> 으로 초기화되게 됩니다. 이는 원치 않았던 부작용입니다. 이런 이유에서 일반적인 경우에는 <code>new</code> 대신 <code>Object.create</code> 를 프로토타입 객체 생성에 사용해야 합니다. 아래처럼요</p>

<pre><code class="javascript">// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype);  
</code></pre>

<h3 id="constructor">.constructor</h3>

<p>모든 프로토타입 객체들은, <code>constructor</code> 란 프로퍼티가 있습니다. 이 값은 생성자를 가리킵니다. 그러므로 아래 코드는 <code>true</code> 를 출력합니다.</p>

<pre><code class="javascript">Rectangle.prototype.constructor === Rectangle // true  
</code></pre>

<p>우리의 예제인 <code>Rectangle</code> 에서도 위에 있는 코드처럼 프로토타입의 <code>constructor</code> 값을 초기화 하고 있습니다. 왜 그래야 할까요?</p>

<p>사실 <code>.constructor</code> 값은 별로 의미있는 값은 아닙니다. 만약 우리가 <code>constructor</code> 값으로 어떤 종류의 객체인지 판별한다면, 의미는 있겠지요. 그러나 일반적으로는 <code>instanceof</code> 를 사용합니다.</p>

<pre><code class="javascript">function Shape() { this.x = 0; }

var s1 = new Shape();

console.log( s1.__proto__.constrctor === Shape) // true  
console.log( s1 instanceof Shape) // true  
</code></pre>

<p>그럼 이렇게 <code>constructor</code> 를 비교하는 작업을 <code>instanceof</code> 내부에서 사용하느냐, 그것도 아닙니다. <code>instanceof</code> 는 <code>s1.__proto__</code> 와 <code>Shape.prototype</code> 을 비교합니다.</p>

<p><code>.constructor</code> 는 사실 정말로 쓸모가 없을지도 모르겠습니다. 그러나 자바스크립트 표준이 프로토타입 객체의 <code>constructor</code> 프로퍼티는 생성자를 가르켜야 한다고 말하는 한, 적어도 세팅은 해주는게 나쁘지 않다는게 제 생각입니다. 아래는 관련된 논의입니다. </p>

<p>Link : <strong><a href='http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property' >What it the significance of the javascript constructor property</a></strong></p>

<p>다시 우리의 예제로 돌아와서, 코드를 살펴보겠습니다.</p>

<pre><code class="javascript">// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype); (1)  
Rectangle.prototype.constructor = Rectangle; (2)  
</code></pre>

<p><code>Rectangle.prototype.constuctor</code> 를 다시 세팅해 주는 이유는, 이 값이 <code>Shape</code> 이기 때문입니다. <code>Rectangle.protoype</code> 은 <code>__proto__</code> 를 <code>Shape.prototype</code> 으로 가지는 오브젝트고, 따라서 (1) 라인에서 코드를 실행시켰을 때는 다음과 같은 결과가 나옵니다.</p>

<p><code>console.log( Rectangle.prototype.constructor ); // Shape</code></p>

<p>왜냐 하면 <code>Rectangle.prototype</code> 에는 <code>constructor</code> 가 없기 때문에 <code>Rectangle.prototype.__proto__</code> 에서 <code>constructor</code> 를 찾는데, <code>Rectangle.prototype.__proto__</code> 는 <code>Shape.prototype</code> 이기 때문이지요. </p>

<p>기본적으로 우리가 생성자를 만들면, 자바스크립트는 다음과 같이 프로토타입 객체를 만들고 이 프로토타입 객체의 <code>constructor</code> 를 세팅해 줍니다.</p>

<pre><code class="javascript">function Shape() { this.x = 0; }

console.log( Shape.prototype.constructor ); // Shape;  
</code></pre>

<p><code>Rectangle.prototype.constructor</code> 는 본래 처음 <code>Rectangle</code> 생성자를 만들었을때는 <code>Rectangle</code> 이었겠지만, (1) 라인의 코드를 실행 시킨 순간 <code>Shape</code> 으로 변경되고, 더 정확히 이 값은 <code>Rectangle.prototype.__proto__.consturctor</code> 에서 옵니다. 결국 값이 바뀌었기 때문에 원래대로 돌려주어야 하므로 아래와 같은 코드를 작성해준 것입니다.</p>

<pre><code class="javascript">Rectangle.prototype.constructor = Rectangle;  
</code></pre>

<p>자 이제, 아래 그림이 완벽히 이해되실 겁니다. </p>

<p><br/>  </p>

<p align="center">  
<img src='http://i.stack.imgur.com/UfXRZ.png'  />  
</p>  

<p align="center">  
(<a href='http://dmitrysoshnikov.com/ecmascript/javascript-the-core/' >http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a>)
</p>  

<p><br/></p>]]></description><link>http://1ambda.github.io/javascript-object-inheritance/</link><guid isPermaLink="false">57da5ecb-1d40-4b48-a3bb-09654e4574ac</guid><category><![CDATA[javascript]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 10 Aug 2014 03:54:29 GMT</pubDate></item><item><title><![CDATA[CLOS, Common Lisp Object System]]></title><description><![CDATA[<p>CLOS Brief Guide based on</p>

<ol>
<li><a href='http://www.aiai.ed.ac.uk/' ~jeff/clos-guide.html'>http://www.aiai.ed.ac.uk/~jeff/clos-guide.html</a>  </li>
<li><a href='http://www.cs.northwestern.edu/academics/courses/325/readings/clos.php' >http://www.cs.northwestern.edu/academics/courses/325/readings/clos.php</a>  </li>
<li><a href='http://cl-cookbook.sourceforge.net/clos-tutorial/' >http://cl-cookbook.sourceforge.net/clos-tutorial/</a>  </li>
<li><a href='http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html' >http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html</a></li>
</ol>

<p>Full source code : <a href='https://github.com/1ambda/CLOS/blob/master/concept.lisp' >Here</a></p>

<h3 id="1classof">1. class-of</h3>

<p>Built-in Classes</p>

<ul>
<li>SYMBOL</li>
<li>STRING</li>
<li>INTEGER</li>
<li>CONS</li>
<li>VECTOR</li>
<li>and so on</li>
</ul>

<p><br/>  </p>

<h3 id="2defstruct">2. defstruct</h3>

<p><code>defstruct</code> automatically define access-function and constructor</p>

<pre><code class="lisp">(defstruct cat 
  (name)
  (age))

(setf c1 (make-cat :name 'blue :age 6))
(cat-age c1) ;; 6
(cat-name c1) ;; BLUE
</code></pre>

<p><br/></p>

<p>What defined by <code>defstruct</code> is <code>STRUCTURE-CLASS</code></p>

<pre><code class="lisp">(class-of c1)

;; #&lt;STRUCTURE-CLASS CAT)
</code></pre>

<p><br/></p>

<h3 id="3defclass">3. defclass</h3>

<p>defclass gives you more controll. You can specify <strong>initform</strong>, <strong>initarg</strong>, <strong>accessor</strong> and so on.</p>

<pre><code class="lisp">;; syntax
(DEFCLASS class-name (superclass-name*)
  (slot-description*)
  class-option*)

(defclass person ()
  ((name :initarg :name
         :initform 'bill
         :accessor person-name)
   (age :initarg :age
        :initform 26
        :accessor person-age)))

(setf p1 (make-instance 'person :name 'bob :age 26))
</code></pre>

<p><br/></p>

<p>What defined by <code>defclass</code> is <code>STANDARD-CLASS</code> which subclasses <code>STANDARD-OBJECT</code></p>

<pre><code class="lisp">(class-of p1)
(find-class 'person)

;; #&lt;STANDARD-CLASS PERSON&gt;
</code></pre>

<p><br/></p>

<h3 id="4slot">4. Slot</h3>

<p>Class defined by <code>defclass</code> can have slots. Slot is member-variable.</p>

<pre><code class="lisp">(setf p1 (make-instance 'person :name 'bob :age 26''))
(slot-value p1 'name)

;; BOB
</code></pre>

<p><br/></p>

<p><code>describe</code> function can be used to show instance or classes information</p>

<pre><code class="lisp">(describe p1) ;; instance information
;; #&lt;PERSON {1002E70513}&gt;
;;   [standard-object]
;; 
;; Slots with :INSTANCE allocation:
;;   NAME  = HOON
;;   AGE   = 26

(describe 'person) ;; class information
;; COMMON-LISP-USER::PERSON
;;   [symbol]
;; 
;; PERSON names the standard-class #&lt;STANDARD-CLASS PERSON&gt;:
;;   Class precedence-list: PERSON, STANDARD-OBJECT, SB-PCL::SLOT-OBJECT, T
;;   Direct superclasses: STANDARD-OBJECT
;;   No subclasses.
;;   Direct slots:
;;     NAME
;;       Initargs: :NAME
;;       Readers: PERSON-NAME
;;       Writers: (SETF PERSON-NAME)
;;     AGE
;;       Initargs: :AGE
;;       Readers: PERSON-AGE
;;       Writers: (SETF PERSON-AGE)
</code></pre>

<p><br/></p>

<h3 id="5slotoptioninheritance">5. Slot Option Inheritance</h3>

<p><code>initform</code> Slot options can be overrided. But <code>initarg</code> and <code>accessor</code> can't</p>

<pre><code class="lisp">(defclass teacher (person)
  ((subject :accessor teacher-subject
        :initarg :subject
        :initform "None")))

(defclass math-teacher (teacher)
  ((subject :initform "Mathmatics")))

(defvar t1 nil)
(defvar m1 nil)

(setf t1 (make-instance 'teacher :name 'bob :age 25))
(setf m1 (make-instance 'math-teacher :name 'john :age 25))

(describe t1)

;; #&lt;TEACHER {10040F9363}&gt;
;;   [standard-object]
;; 
;; Slots with :INSTANCE allocation:
;;   NAME     = BOB
;;   AGE      = 25
;;   SUBJECT  = "None"


(describe m1)

;; #&lt;MATH-TEACHER {10040FE653}&gt;
;;   [standard-object]
;; 
;; Slots with :INSTANCE allocation:
;;   NAME     = JOHN
;;   AGE      = 25
;;   SUBJECT  = "Mathmatics"
</code></pre>

<p><br/></p>

<h3 id="6multipleinheritance">6. Multiple Inheritance</h3>

<p>CLOS supports <strong>Multiple Inheritance</strong>. But I'm not going to discuss.</p>

<p>If you are interested in how CLOS solves diamond problem, see <a href='http://en.wikipedia.org/wiki/Multiple_inheritance' >Wiki</a></p>

<blockquote>
  <p>Common Lisp CLOS attempts to provide both reasonable default behavior and the ability to override it. By default, the method with the most specific argument classes is chosen; then in the order in which parent classes are named in the subclass definition. However, the programmer can override this, by giving a specific method resolution order or stating a rule for combining methods. This is called method combination, which may be fully controlled. The MOP (metaobject protocol) also provides means to modify the inheritance, dynamic dispatch, class instantiation, and other internal mechanisms without affecting the stability of the system.</p>
</blockquote>

<p>Basically, There are two rules about inheritance.</p>

<ol>
<li>Each class is more specific than its superclasses.  </li>
<li>For a given class, superclasses listed earlier are more specific than those listed later.</li>
</ol>

<p>The second rule is useful in case of</p>

<pre><code class="lisp">(defclass a (b c) ...)
</code></pre>

<p><br/> <br />
<code>initform</code> or <code>method</code> are can be from both class <code>b</code> and class <code>c</code>. But class 'b' precedes class 'c', class 'c''s <code>method' or</code>initform` will be selected.</p>

<p><br/>  </p>

<h3 id="7genericfunction">7. Generic function</h3>

<p>In common lisp, class have only <strong>data</strong>. That means <strong>code (method)</strong> is separeted from class and is <strong>not</strong> tired to any class contrary to popular object-oriented language like Java, C++. This is why we call it <strong>generic</strong> method or function.</p>

<pre><code class="lisp">;; inherit standard object
(defclass person ()
  ((name :accessor person-name
     :initarg :name)
   (age :accessor person-age
    :initarg :age)))

;; inherit person
(defclass teacher (person)
  ((subject :accessor teacher-subject
        :initarg :subject
        :initform "nothing")))

;; inherit teacher
(defclass math-teacher (teacher)
  ((subject :initform "math")))

;; create instance
(setf t1 (make-instance 'teacher :name 'bob :age 25))
(setf m1 (make-instance 'math-teacher :name 'john :age 25))

;; call method

(work t1)
;; BOB is teaching nothing

(work m1)
;; JOHN is teaching math
</code></pre>

<p><br/> <br />
Calling method like this is somewhat different from other languages. In Java, methods are binded in a class. So we can call methods <code>Class.method(args)</code>. This is <strong>Single dispatch</strong>. According to <a href='http://en.wikipedia.org/wiki/Dynamic_dispatch' #Single_and_multiple_dispatch">wikipedia</a></p>

<blockquote>
  <p>If the decision of which version of a method to call is based entirely on the class of the object x, then this is known as single dispatch because an implementation is chosen based on a single type — the type of the instance. Single dispatch is supported by many object-oriented languages, including statically typed languages such as C++ and Java, and dynamically typed languages such as Smalltalk and Objective-C.</p>
</blockquote>

<p>But in Common Lisp, Method is invoked like <code>(method classes args)</code>. CLOS select which method will be called based on <strong>classes</strong>. This is <strong>Multiple dispatch</strong>.</p>

<blockquote>
  <p>In some languages such as Common Lisp and Dylan, methods or functions can also be dynamically dispatched based on the run-time type of arguments. Expressed in pseudocode, the code manager.handle(y) could call different implementations depending on the types of both objects manager and y. This is known as multiple dispatch.</p>
</blockquote>

<p><br/>  </p>

<h3 id="8methodcombination">8. Method Combination</h3>

<p>More than one method are applicable to a given set of arguments, the applicable methods are called <strong>single effective method</strong>. Common Lisp comes with predefined <strong>standard method combination</strong>. Also, It is possible to define new kinds of method combination. Standard method combination consists of</p>

<ul>
<li>primary</li>
<li>:before</li>
<li>:after</li>
<li>:around</li>
</ul>

<pre><code class="lisp">(defgeneric work (teacher)
  (:documentation "do something based on their job"))

(defmethod work ((t1 teacher))
  (format t "~a is teaching ~a"
    (slot-value t1 'name)
    (slot-value t1 'subject)))

(defmethod work ((t1 math-teacher))
  (format t "~a's major is math~%"
    (slot-value t1 'name))
  (call-next-method))

(setf t1 (make-instance 'teacher :name 'bob :age 25))
(setf m1 (make-instance 'math-teacher :name 'john :age 25))

(work m1)
;; BOB is teaching nothing

(work t1)
;; JOHN's major is math
;; JOHN is teaching math
</code></pre>

<p><br/> <br />
If <code>around</code>, <code>before</code>, <code>after</code> keyword is not specified, the generic method is <strong>Primary</strong> method which is responsible for providing primary implementation. Above <code>work</code> methods are primary. <code>call-next-method</code> indicates that control should be passaed from this method to the method specialized on superclass as arguments.</p>

<pre><code class="lisp">(setf t1 (make-instance 'teacher :name 'bob :age 25))
(setf m1 (make-instance 'math-teacher :name 'john :age 25))

(defgeneric work (teacher)
  (:documentation "do something based on their job"))

(defmethod work ((t1 teacher))
  (format t "~a is teaching ~a~%"
    (slot-value t1 'name)
    (slot-value t1 'subject)))

(defmethod work :before ((t1 teacher))
  (format t "~a is preparing the class~%"
    (slot-value t1 'name)))

(defmethod work :after ((t1 teacher))
  (format t "~a has done his class~%"
    (slot-value t1 'name)))

(defmethod work :around ((t1 teacher))
  (format t "start around for teacher class~%")
  (let ((result (call-next-method)))
    (format t "end around for teacher class~%")
    result))

(defmethod work ((t1 math-teacher))
  (format t "~a's major is math~%"
    (slot-value t1 'name))
  (call-next-method))

(work t1)
;; start around for teacher class
;; BOB is preparing the class
;; BOB is teaching nothing
;; BOB has done his class
;; end around for teacher class
;; NIL

(work m1)
;; start around for teacher class
;; JOHN is preparing the class
;; JOHN's major is math
;; JOHN is teaching math
;; JOHN has done his class
;; end around for teacher class
;; NIL
</code></pre>

<p><br/> <br />
These <code>:before</code>, <code>:after</code>, <code>:around</code> are auxiliary methods. Superclass's auxiliary methods are automatically called when you invoke subclass's a primary method. Of course, we can define subclass's auxiliary methods.</p>

<pre><code class="lisp">(defmethod work :before ((t1 math-teacher))
  (format t "Math teacher ~a is preparing the math class~%"
    (slot-value t1 'name)))

(defmethod work :after ((t1 math-teacher))
  (format t "Math teacher ~a has done his math class~%"
    (slot-value t1 'name)))

(defmethod work :around ((t1 math-teacher))
  (format t "start around for math-teacher class~%")
  (let ((result (call-next-method)))
    (format t "end around for math-teacher class~%")
    result))

(work m1)
;; start around for math-teacher class
;; start around for teacher class
;; Math teacher JOHN is preparing the math class
;; JOHN is preparing the class
;; JOHN's major is math
;; JOHN is teaching math
;; JOHN has done his class
;; Math teacher JOHN has done his math class
;; end around for teacher class
;; end around for math-teacher class
;; NIL
</code></pre>]]></description><link>http://1ambda.github.io/clos-common-lisp-object-system/</link><guid isPermaLink="false">f45536c4-b80f-424f-9134-3a3cd7e46f1d</guid><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 23 Jul 2014 01:27:33 GMT</pubDate></item></channel></rss>