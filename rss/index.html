<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Old Lisper]]></title><description><![CDATA[Functional Programming World]]></description><link>http://1ambda.github.io/</link><generator>Ghost 0.6</generator><lastBuildDate>Sun, 06 Dec 2015 08:40:18 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Easy Scalaz 4, Yoneda and Free Monad]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p><code>Free[F, A]</code> 를 이용하면 Functor <code>F</code> 를 Monad 인스턴스로 만들 수 있습니다. 그런데, <code>Coyoneda[G, A]</code> 를 이용하면 아무 타입 <code>F</code> Functor 인스턴스로 만들 수 있으므로 아무 타입에 <code>G</code> 대해서나 (심지어 방금 만든 <em>case class</em> 조차) 모나드 인스턴스를 만들 수 있습니다.</p>

<p><code>Free</code> 를 이용하면 사용자는 자신만의 <em>Composable DSL</em> 을</p>]]></description><link>http://1ambda.github.io/easy-scalaz-4-yoneda-and-coyoneda/</link><guid isPermaLink="false">4bdf7e2f-ba28-4630-80d2-b44b3953a5a8</guid><category><![CDATA[scala]]></category><category><![CDATA[monad]]></category><category><![CDATA[monoid]]></category><category><![CDATA[scalaz]]></category><category><![CDATA[free]]></category><category><![CDATA[trampoline]]></category><category><![CDATA[yoneda]]></category><category><![CDATA[coyoneda]]></category><category><![CDATA[free monoid]]></category><category><![CDATA[free monad]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 06 Dec 2015 08:34:34 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p><code>Free[F, A]</code> 를 이용하면 Functor <code>F</code> 를 Monad 인스턴스로 만들 수 있습니다. 그런데, <code>Coyoneda[G, A]</code> 를 이용하면 아무 타입 <code>F</code> Functor 인스턴스로 만들 수 있으므로 아무 타입에 <code>G</code> 대해서나 (심지어 방금 만든 <em>case class</em> 조차) 모나드 인스턴스를 만들 수 있습니다.</p>

<p><code>Free</code> 를 이용하면 사용자는 자신만의 <em>Composable DSL</em> 을 구성하고, 구성한 모나딕 연산을 실행하는 해석기를 작성하게 됩니다. 즉, <strong>연산의 생성</strong> 과 <strong>연산의 실행</strong> 을 분리하여 다루게 됩니다. 이는 <em>side-effect</em> 를 실행 시점으로 미룰 수 있다는 뜻입니다. (실행용 해석기와 별도로 테스트용 해석기를 작성하는 것도 가능합니다)</p>

<p>그러면, 제가 가장 좋아하는 <a href="http://tpolecat.github.io/assets/sbtb-slides.pdf">Programs as Values: Fure Functional JDBC Programming</a> 예제로 시작해보겠습니다.</p>

<h2 id="ifwehaveamonad">If We Have a Monad</h2>

<p>JDBC 를 쌩으로 사용한다면, 다음과 같은 코드를 작성해야 할텐데</p>

<pre><code class="language-scala">// ref - http://tpolecat.github.io/

case class Person(name: String, age: Int)

def getPerson(rs: ResultSet): Person {  
  val name = rs.getString(1)
  val age  = rs.getInt(2)
}
</code></pre>

<p>다음과 같은 문제점이 있습니다.</p>

<ul>
<li><em>managed resource</em> 인 <code>ResultSet</code> 을 프로그래머가 다룰 수 있습니다. 어디에 저장이라도 하고 나중에 사용한다면 문제가 될 수 있습니다.</li>
<li><code>rs.get*</code> 은 <em>side-effect</em> 를 만들어 내므로 테스트하기 쉽지 않습니다.</li>
</ul>

<p>접근 방식을 바꿔보는건 어떨까요? 프로그램을 실행해서 <em>side-effect</em> 를 즉시 만드는 대신</p>

<ul>
<li>어떤 연산을 수행할지를 <em>case class</em> 로 만들고 이것들을 조합해 어떤 연산을 수행할지 나타낸뒤에</li>
<li>연산의 조합을 번역해 실행하는 해석기(<em>interpreter</em>) 를 만들어 보겠습니다.</li>
</ul>

<p>먼저 연산부터 정의하면,</p>

<pre><code class="language-scala">sealed trait ResultSetOp[A]

final case class GetString(index: Int) extends ResultSetOp[String]  
final case class GetInt(index: Int)    extends ResultSetOp[Int]  
final case object Next                 extends ResultSetOp[Boolean]  
final case object Close                extends ResultSetOp[Unit]  
</code></pre>

<p>이 때 만약 <code>ResultSetOp[A]</code> 가 모나드라면 다음과 같이 작성할 수 있습니다.</p>

<pre><code class="language-scala">def getPerson: ResultSetOp[Person] = for {  
  name &lt;- GetString(1)
  age  &lt;- GetInt(2)
} yield Person(name, age)

// Application Operation `*&gt;`  (e.g `1.some *&gt; 2.some== 2.some)
// See, http://eed3si9n.com/learning-scalaz/Applicative.html
def getNextPerson: ResultSetOp[Person] =  
  Next *&gt; getPerson

def getPeople(n: Int): ResultSet[List[Person]] =  
  getNextPerson.repicateM(n) // List.fill(n)(getNextPerson).sequence

def getAllPeople: ResultSetIO[Vector[Person]] =  
  getPerson.whileM[Vector](Next)
</code></pre>

<p><code>ResultSetIO</code> 는 모나드가 아니므로 위와 같이 작성할 수 없습니다.</p>

<h3 id="writingyourowndsl">Writing Your own DSL</h3>

<p>놀랍게도, <code>ResultSetIO</code> 를 모나드로 만들 수 있습니다. <code>flatMap</code>, <code>unit</code> 구현 없이 얻을 수 있는 공짜 모나드입니다. 방법은 이렇습니다.</p>

<ul>
<li><code>Free[F[_], ?]</code> 는 <code>Functor</code> <code>F</code> 에 대해 <code>Monad</code> 입니다</li>
<li><code>Coyoneda[S[_], ?]</code> 는 아무 타입 <code>G</code> 에 대해 <code>Functor</code> 입니다. </li>
</ul>

<p>따라서 <code>Free[Coyoneda[G, A], A</code> 는 아무 타입 <code>G</code> 에 대해서 모나드입니다. </p>

<pre><code class="language-scala">import scalaz.{Free, Coyoneda}, Free._

// ResultSetOpCoyo is the Functor
type ResultSetOpCoyo[A] = Coyoneda[ResultSetOp, A] 

// ResultSetIO is the Monad
type ResultSetIO[A] = Free[ResultSetOpCoyo, A]

// same as
// type ResultSetIO2[A] = Free[({ type λ[α] = Coyoneda[ResultSetOp, α]})#λ, A]
</code></pre>

<p>따라서 다음처럼 작성할 수 있습니다.</p>

<pre><code class="language-scala">val next                 : ResultSetIO[Boolean] = Free.liftFC(Next)  
def getString(index: Int): ResultSetIO[String]  = Free.liftFC(GetString(index))  
def getInt(index: Int)   : ResultSetIO[Int]     = Free.liftFC(GetInt(index))  
def close                : ResultSetIO[Unit]    = Free.liftFC(Close)  
</code></pre>

<p>여기서 <code>Free.listFC</code> 는 타입 <code>ResultSetOp</code> 를 바로 <code>ResultSetIO</code> 로 리프팅 해주는 헬퍼 함수입니다. (<code>F</code> = <em>Free</em>, <code>C</code> = <em>Coyoneda</em>)</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Free.scala#L30

/** A version of `liftF` that infers the nested type constructor. */
def liftFU[MA](value: =&gt; MA)(implicit MA: Unapply[Functor, MA]): Free[MA.M, MA.A] =  
  liftF(MA(value))(MA.TC)

/** A free monad over a free functor of `S`. */
def liftFC[S[_], A](s: S[A]): FreeC[S, A] =  
    liftFU(Coyoneda lift s)
</code></pre>

<p><code>liftFU[MA]</code> 에서, <code>MA = Coyoneda[ResultSetOp, A]</code> 로 보면 <code>Free[MA.M, MA.A]</code> 는 <code>Free[Coyoneda[ResultSetOp, A], A]</code> 가 됩니다. (<a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Unapply.scala#L51">Unapply.scala</a>)</p>

<p>이를 이용해서 <code>get*</code> 를 작성해 보면</p>

<pre><code class="language-scala">import scalaz._, Scalaz._

def getPerson: ResultSetIO[Person] = for {  
  name &lt;- getString(1)
  age  &lt;- getInt(2)
} yield Person(name, age)

def getNextPerson: ResultSetIO[Person] =  
  next *&gt; getPerson

def getPeople(n: Int): ResultSetIO[List[Person]] =  
  getNextPerson.replicateM(n) // List.fill(n)(getNextPerson).sequence

def getPersonOpt: ResultSetIO[Option[Person]] =  
  next &gt;&gt;= {
    case true  =&gt; getPerson.map(_.some)
    case false =&gt; none.point[ResultSetIO]
  }

def getAllPeople: ResultSetIO[Vector[Person]] =  
  getPerson.whileM[Vector](next)
</code></pre>

<h3 id="dslinterpreter">DSL Interpreter</h3>

<p>이제 <code>RestSetOp</code> 로 작성한 연산 (일종의 프로그램) 을 실행하려면, <code>ResetSetOp</code> 명령(<em>case class</em>) 을, 로직(<em>side-effect</em> 를 유발할 수 있는) 으로 변경해야 합니다. </p>

<p><code>NaturalTransformation</code> 을 이용할건데, <code>F ~&gt; G</code> 는 <code>F</code> 를 <code>G</code> 로 변경하는 변환(<em>Transformation</em>) 을 의미합니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/package.scala#L113

/** A [[scalaz.NaturalTransformation]][F, G]. */
type ~&gt;[-F[_], +G[_]] = NaturalTransformation[F, G]

// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/NaturalTransformation.scala#L14
/** A universally quantified function, usually written as `F ~&gt; G`,
  * for symmetry with `A =&gt; B`.
  *
  * Can be used to encode first-class functor transformations in the
  * same way functions encode first-class concrete value morphisms;
  * for example, `sequence` from [[scalaz.Traverse]] and `cosequence`
  * from [[scalaz.Distributive]] give rise to `([a]T[A[a]]) ~&gt;
  * ([a]A[T[a]])`, for varying `A` and `T` constraints.
  */
trait NaturalTransformation[-F[_], +G[_]] {  
  self =&gt;
  def apply[A](fa: F[A]): G[A]

  def compose[E[_]](f: E ~&gt; F): E ~&gt; G = new (E ~&gt; G) {
    def apply[A](ea: E[A]) = self(f(ea))
  }

  def andThen[H[_]](f: G ~&gt; H): F ~&gt; H =
    f compose self
}
</code></pre>

<p>이제, <code>ResultSetOp</code> 를 <code>IO</code> 로 변경하는 해석기를 작성하면, (<a href="http://eed3si9n.com/learning-scalaz/IO+Monad.html">Learning Scalaz - IO</a>)</p>

<pre><code class="language-scala">import scalaz.effect._

private def interpret(rs: ResultSet) = new (ResultSetOp ~&gt; IO) {  
    def apply[A](fa: ResultSetOp[A]): IO[A] = fa match {
      case Next         =&gt; IO(rs.next)
      case GetString(i) =&gt; IO(rs.getString(i))
      case GetInt(i)    =&gt; IO(rs.getInt(i))
      case Close        =&gt; IO(rs.close)
      // more... 
    }
}

def run[A](a: ResultSetIO[A], rs: ResultSet): IO[A] =  
  Free.runFC(a)(interpret(rs))
</code></pre>

<h2 id="whyfree">Why Free?</h2>

<p><code>Free</code> 가 제공하는 가치는 다음과 같습니다. (Ref - <a href="http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern">StackExchange</a>)</p>

<ul>
<li>It is a lightweight way of <strong>creating a domain-specific language that gives you an AST</strong>, and then having <strong>one or more interpreters</strong> to <strong>execute the AST</strong> however you like</li>
<li>The free monad part is just a handy way to get an AST that you can assemble using Haskell's standard monad facilities (like do-notation) without having to write lots of custom code. This also ensures that your DSL is composable</li>
<li>You could then interpret this however you like: run it against a live database, run it against a mock, just log the commands for debugging or even try optimizing the queries</li>
</ul>

<p>즉, <code>Free</code> 는 우리는 자신만의 Composable 한 DSL 을 구축하고, 필요에 따라 이 DSL 다른 방식으로 해석할 수 있도록 도와주는 도구입니다. </p>

<h2 id="free">Free</h2>

<p>(<code>Free</code> 와 <code>Yoneda</code> 는 난해할 수 있으니, <code>Free</code> 를 어떻게 사용하는지만 알고 싶다면 <a href="http://1ambda.github.io/easy-scalaz-4-yoneda-and-coyoneda/#reasonablypricedmonad">Reasonably Priced Monad</a> 로 넘어가시면 됩니다.)</p>

<p>어떻게 <code>F</code> 가 <code>Functor</code> 이기만 하면 <code>Free[F[_], ?]</code> 가 모나드가 되는걸까요? 이를 알기 위해선, 모나드가 어떤 구조로 이루어져 있는지 알 필요가 있습니다.</p>

<h3 id="monad">Monad</h3>

<blockquote>
  <p>A monad is just a monoid in the category of endofunctors, what's the problem?</p>
</blockquote>

<p><del>의사양반 이게 무슨소리요!</del></p>

<p>이제 <code>Monoid</code> 와 <code>Functor</code> 가 무엇인지 알아봅시다.</p>

<h2 id="monoid">Monoid</h2>

<p>어떤 집합 <code>S</code> 에 대한 닫힌 연산 <code>*</code>, 집합 내의 어떤 원소 <code>e</code> 가 다음을 만족할 경우 모노이드라 부릅니다.</p>

<ul>
<li><code>e * a = a = a * e</code> (<em>identity</em>)</li>
<li><code>(a * b) * c = a * (b * c)</code> (<em>associativity</em>)</li>
</ul>

<p>일반적으로 <code>e</code> 를 항등원이라 부릅니다. <code>Option[A]</code> 도 <code>None</code> 을 항등원으로 사용하고, <em>associativity</em> 를 만족하는 <code>A</code> 의 연산을 사용하면 모노이드입니다. 따라서 <code>A</code> 가 모노이드면 <code>Option[A]</code> 도 모노이드입니다. (활용법은 <a href="http://www.slideshare.net/oxbow_lakes/practical-scalaz">Practical Scalaz</a> 참조)</p>

<pre><code class="language-scala">&gt; load.ivy("org.scalaz" % "scalaz-core_2.11" % "7.2.0-M5")
&gt; import scalaz._, Scalaz._


&gt; 1.some |+| 2.some
res11: Option[Int] = Some(3)  
&gt; 1.some |+| none
res12: Option[Int] = Some(1)  
&gt; none[Int] |+| 1.some
res13: Option[Int] = Some(1)  
</code></pre>

<h2 id="functor">Functor</h2>

<p><code>Functor</code> 는 일반적으로 다음처럼 정의되는데, 이는 <code>Functor F</code> 가 <code>F</code> 에서 값을 꺼내, 함수를 적용해 값을 변경할 수 있다는 것을 의미합니다.</p>

<blockquote>
  <p>A functor may go from one category to a different one</p>
</blockquote>

<pre><code class="language-scala">trait Functor[F[_]] {  
  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]
}
</code></pre>

<p>그리고 <code>Functor</code> 는 <em>identity function</em> 을 항등원으로 사용하면, 모노이드입니다.</p>

<ul>
<li><code>F.map(x =&gt; x) == F</code> </li>
<li><code>F map f map g == F map (f compose g)</code></li>
</ul>

<p>이 때, 변환의 인풋과 아웃풋이 같은 카테고리라면 이 <code>Functor</code> 를 <em>endo-functor</em> 라 부릅니다. </p>

<blockquote>
  <p>A functor may go from one category to a different one, an endofunctor is a functor for which start and target category are the same.</p>
</blockquote>

<h2 id="monad">Monad</h2>

<p>그럼 다시 처음 문장으로 다시 돌아가면, </p>

<blockquote>
  <p>Monads are just monoids in the category of endofunctors</p>
</blockquote>

<p>이 것의 의미를 이해하려면 모나드가 무엇인지 알아야 합니다.</p>

<pre><code class="language-scala">trait Monad[F[_]] {  
  def point[A](a: A): F[A]
  def join[A](ffa: F[F[A]): F[A]
  ...
}
</code></pre>

<p>일반적으로는 <code>point</code> (=<code>return</code>) 와 <code>bind</code> (= <code>flatMap</code>) 으로 모나드를 정의하나, <code>join</code>, <code>map</code> 으로도 <code>bind</code> 를 정의할 수 있습니다.</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

trait Monad[F[_]] {  
  def point[A](a: A): F[A]
  def bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]

  def map[A, B](fa: F[A])(f: A =&gt; B): F[B] = 
    bind(fa)(a =&gt; point(f(a))    
  def join[A](ffa: F[F[A]): F[A] = 
    bind(ffa)(fa =&gt; fa)
}

trait Monad[F[_]] {  
  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]
  def point[A](a: A): F[A]
  def join[A](ffa: F[F[A]): F[A] /* flatten*/

  def bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B] = 
    join(map(fa)(f))
}
</code></pre>

<p><code>map</code>, <code>point</code>, <code>join</code> 관점에서 모나드를 바라보면,</p>

<ul>
<li><strong>(endo)functor</strong> <code>T : X → X</code></li>
<li><strong>natural transformation</strong> <code>μ : T × T → T</code> (where <code>×</code> means functor composition (also known as <code>join</code> in Haskell)</li>
<li><strong>natural transformation</strong>  <code>η : I → T</code> (where <code>I</code> is the identity endofunctor on <code>X</code> also known as <code>return</code> in Haskell)</li>
</ul>

<p>이때 위 연산들이 모노이드 법칙을 만족합니다.</p>

<ul>
<li><code>e * a = a = a * e</code> (<em>identity</em>)</li>
<li><p><code>(a * b) * c = a * (b * c)</code> (<em>associativity</em>)</p></li>
<li><p><code>μ(η(T)) = T = μ(T(η))</code> (<em>identity</em>)</p></li>
<li><code>μ(μ(T × T) × T)) = μ(T × μ(T × T))</code> (<em>associativity</em>)</li>
</ul>

<p>스칼라 코드로 보면,</p>

<pre><code class="language-scala">&gt; import scalaz._, Scalaz._

&gt; val A = List(1, 2)
List[Int] = List(1, 2)

// identity left-side: μ(η(T)) = T
&gt; A.map(x =&gt; Monad[List].point(x)).flatten
List[Int] = List(1, 2)

// identity right-side: μ(T(η)) = T
&gt; Monad[List].point(A).flatten
List[Int] = List(1, 2)

// associativity
&gt; val T = List(1, 2, 3, 4)
T: List[Int] = List(1, 2, 3, 4)  
&gt; val TT = T.map(List(_))
TT: List[List[Int]] = List(List(1), List(2), List(3), List(4))

// associativity left-side: μ(μ(T × T) × T))
&gt; TT.flatten.map(List(_))
res30: List[List[Int]] = List(List(1), List(2), List(3), List(4))  
&gt; TT.flatten.map(List(_)).flatten
res31: List[Int] = List(1, 2, 3, 4)

// associativity right-side: μ(T × μ(T × T))
&gt; List(TT.flatten)
res34: List[List[Int]] = List(List(1, 2, 3, 4))  
&gt; List(TT.flatten).flatten
res35: List[Int] = List(1, 2, 3, 4)  
</code></pre>

<p>따라서 <em>Monad</em>는 <em>(endo)Functor</em> 카테고리에 대한 <em>Monoid</em> 입니다.</p>

<h2 id="freemonoid">Free Monoid</h2>

<p><em>Free Monad</em> 가 <code>bind</code>, <code>point</code> 에 대한 구현 없이, 모나드가 되듯이 <em>Free Monoid</em> 또한 연산과 항등원에 대한 구현 없이 <em>구조적</em> 으로 모노이드입니다. </p>

<p>항등원과 연산을 <code>Zero</code>, <code>Append</code> 라는 이름으로 <em>구조화</em> 하면,</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

sealed trait FreeMonoid[+A]  
final case object Zero extends FreeMonoid[Nothing]  
final case class Value[A](a: A) extends FreeMonoid[A]  
final case class Append[A](l: FreeMonoid[A], r: FreeMonoid[A]) extends FreeMonoid[A]  
</code></pre>

<p>모노이드는 <em>associativity</em> 를 만족하므로, <code>Append</code> 를 우측 결합으로 바꾸고, <code>Zero</code> 로 끝나도록 하면</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

sealed trait FreeMonoid[+A]  
final case object Zero extends FreeMonoid[Nothing]  
final case class Append[A](l: A, r: FreeMonoid[A]) extends FreeMonoid[A]  
</code></pre>

<p><code>List</code> 와 동일한 구조임을 알 수 있습니다. 실제로, 리스트는 <em>concatenation</em> 연산, <code>Nil</code> 항등원에 대해 모노이드입니다.</p>

<h2 id="freemonad">Free Monad</h2>

<p>이제까지의 내용을 정리하면</p>

<ul>
<li>Monad is a monoid of functors</li>
<li>Then, <strong>Free Monad is a free Monoid of functors</strong> </li>
</ul>

<p>따라서 <em>Free Monad</em> 는 <em>Functor</em> 의 <em>List</em> 라 볼 수 있습니다.</p>

<p>모나드의 <code>point</code>, <code>join</code> 을 <em>구조화</em> (<em>타입화</em>) 하면, </p>

<pre><code class="language-scala">def point[A](a: A): F[A]  
def join[A, B](ffa: F[F[A]): F[A]

sealed trait Free[F[_], A]  
case class Point[F[_], A](a: A) extends Free[F, A]             // == Return  
case class Join[F[_], A](ffa: F[Free[F, A]]) extends Free[F, A] // == Suspend  
</code></pre>

<p><code>map</code> 을 타입화 하는 대신, <code>F</code> 가 <code>Functor</code> 라면 다음처럼 <code>Free.point</code>, <code>Free.flatMap</code> 을 작성할 수 있습니다.</p>

<pre><code class="language-scala">sealed trait Free[F[_], A] {  
  def point[F[_]](a: A): Free[F, A] = Point(a)
  def flatMap[B](f: A =&gt; Free[F, B])(implicit functor: Functor[F]): Free[F, B] =
    this match {
      case Point(a)  =&gt; f(a)
      case Join(ffa) =&gt; Join(ffa.map(fa =&gt; fa.flatMap(f)))
    }
  def map[B](f: A =&gt; B)(implicit functor: Functor[F]): Free[F, B] =
    flatMap(a =&gt; Point(f(a)))
}

case class Point[F[_], A](a: A) extends Free[F, A]  
case class Join[F[_], A](ff: F[Free[F, A]]) extends Free[F, A]  
</code></pre>

<p><code>fa.flatMap(f)</code> 의 결과가 <code>Free[F, B]</code> 고 <code>ffa.map</code> 의 결과로 들어가므로, <code>ffa.map(_ flatMap f)</code> 의 결과는 <code>F[Free[F, B]</code> 입니다. 이걸 <code>Free[F, B]</code> 로 바꾸려면 <code>Join</code> 을 이용하면 됩니다.</p>

<p><strong>이런 이유에서, <code>F</code> 가 <code>Functor</code> 면 <code>Free[F, A]</code> 는 <code>Monad</code> 입니다.</strong></p>

<p>이제 리프팅과 실행을 위한 헬퍼 함수를 만들면,</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

import scalaz.{Functor, Monad, ~&gt;}

def liftF[F[_], A](a: =&gt; F[A])(implicit F: Functor[F]): Free[F, A] =  
  Join(F.map(a)(Point[F, A]))

def foldMap[F[_], M[_], A](fm: Free[F, A])(f: F ~&gt; M)  
                          (implicit FI: Functor[F], MI: Monad[M]): M[A] = 
  fm match {
    case Point(a) =&gt; MI.pure(a)
    case Join(ffa) =&gt; MI.bind(f(ffa))(fa =&gt; foldMap(fa)(f))
  }
</code></pre>

<p>여기서 <code>F ~&gt; M</code> 는 <code>F</code> 를 <code>M</code> 으로 변환해주는, <em>NaturalTransformation</em> 입니다.</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

type ~&gt;[-F[_], +G[_]] = NaturalTransformation[F, G] 

trait NaturalTransformation[-F[_], +G[_]] {  
  self =&gt;
  def apply[A](fa: F[A]): G[A]

  def compose[E[_]](f: E ~&gt; F): E ~&gt; G = new (E ~&gt; G) {
    def apply[A](ea: E[A]) = self(f(ea))
  }
}
</code></pre>

<p><code>MI.bind(f(ffa))</code> 의 결과는 <code>M[Free[F, A]]</code> 이므로 여기에서 <code>bind</code> (= <code>flatMap</code>) 로 <code>fa</code> 를 얻어, 재귀적으로 <code>foldMap</code> 을 호출합니다.</p>

<h3 id="scalazfreeimplementation">Scalaz Free Implementation</h3>

<pre><code class="language-scala">def flatMap[B](f: A =&gt; Free[F, B])(implicit functor: Functor[F]): Free[F, B] =  
    this match {
      case Point(a)  =&gt; f(a)
      case Join(ffa) =&gt; Join(ffa.map(fa =&gt; fa.flatMap(f)))
    }
</code></pre>

<p>Scalaz 에서는 <code>flatMap</code> 호출시 Stack 비용이 생각보다 크므로, <code>flatMap</code> 자체도 타입화하고 있습니다. 즉, Stack 대신에 Heap 을 사용합니다. </p>

<p><code>Point</code> 대신, <code>Return</code>, <code>Join</code> 대신 <code>Suspend</code>, <code>FlatMap</code> 대신 <code>GoSub</code> 라는 타입 이름으로 구현되어 있습니다. (이해를 돕기 위해 7.x 대신, 6.0.4 버전을 차용)</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/release/6.0.4/core/src/main/scala/scalaz/Free.scala

final case class Return[S[+_], +A](a: A) extends Free[S, A]  
final case class Suspend[S[+_], +A](a: S[Free[S, A]]) extends Free[S, A]  
final case class Gosub[S[+_], A, +B](a: Free[S, A],  
                                     f: A =&gt; Free[S, B]) extends Free[S, B]
sealed trait Free[S[+_], +A] {  
  final def map[B](f: A =&gt; B): Free[S, B] =
    flatMap(a =&gt; Return(f(a)))

  final def flatMap[B](f: A =&gt; Free[S, B]): Free[S, B] = this match {
    case Gosub(a, g) =&gt; Gosub(a, (x: Any) =&gt; Gosub(g(x), f))
    case a           =&gt; Gosub(a, f)
  }
}
</code></pre>

<h3 id="trampoline">Trampoline</h3>

<p><code>Free</code> 를 이용하면, Stackoverflow 를 피할 수 있습니다. 이는 <code>Free</code> 가 <code>flatMap</code> 체인에서 스택 대신 힙을 이용하는 것을 응용한 것인데요,</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/release/6.0.4/core/src/main/scala/scalaz/Free.scala

/** A computation that can be stepped through, suspended, and paused */
type Trampoline[+A] = Free[Function0, A]  
</code></pre>

<p>이때 <code>Function0</code> 도 <code>Functor</code> 이므로, </p>

<pre><code class="language-scala">implicit Function0Functor: Functor[Function0] = new Functor[Function0] {  
  def fmap[A, B](f: A =&gt; B)(fa: Function0[A]): Function0[B] = 
    () =&gt; f(fa)
}
</code></pre>

<p><code>Free[Function0, A]</code> 도 모나드입니다. </p>

<p>이제 스칼라에서 스택오버플로우가 발생하는 <em>mutual recursion</em> 코드를 만들어 보면,</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

def isOdd(n: Int): Boolean = {  
  if (0 == n) false
  else isEven(n -1)
}

def isEven(n: Int): Boolean = {  
  if (0 == n) true
  else isOdd(n -1)
}

isOdd(10000) // stackoverflow  
</code></pre>

<p>이제 <code>Trampoline</code> 을 이용하면</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

import scalaz._, Scalaz._, Free._

def isOddT(n: Int): Trampoline[Boolean] =  
  if (0 == n) return_(false)
  else suspend(isEvenT(n - 1))

def isEvenT(n: Int): Trampoline[Boolean] =  
  if (0 == n) return_(true)
  else suspend(isOddT(n - 1))

scala&gt; isOddT(2000000).run  
res7: Boolean = false

scala&gt; isOddT(2000001).run  
res8: Boolean = true  
</code></pre>

<p><code>return_</code> 과 <code>suspend</code> 는 다음처럼 정의되어 있습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Free.scala#L15

trait FreeFunctions {

  ...
  def return_[S[_], A](value: =&gt; A)(implicit S: Applicative[S]): Free[S, A] =
    Suspend[S, A](S.point(Return[S, A](value)))

  def suspend[S[_], A](value: =&gt; Free[S, A])(implicit S: Applicative[S]): Free[S, A] =
    Suspend[S, A](S.point(value))
</code></pre>

<h2 id="yonedacoyoneda">Yoneda, Coyoneda</h2>

<p>포스트의 시작 부분에서 <code>Coyoneda</code> 에 대한 언급을 기억하시나요?</p>

<ul>
<li><code>Free[F[_], ?]</code> 는 <code>Functor</code> <code>F</code> 에 대해 <code>Monad</code> 입니다</li>
<li><code>Coyoneda[S[_], ?]</code> 는 아무 타입에 대해 <code>Functor</code> 입니다. </li>
</ul>

<p><code>Coyoneda</code> 가 어떻게 <code>Functor</code> 를 만들어내는지 확인해 보겠습니다. 이 과정에서 <em>dual</em> 인 <code>Yoneda</code> 도 같이 살펴보겠습니다. (같은 <em>Category</em> 내에서, <em>morphism</em> 방향만 다른 경우)</p>

<p>먼저, <code>Yoneda</code>, <code>Coyoneda</code> 의 기본적인 내용을 훑고 가면</p>

<ul>
<li><code>Yoneda</code>, <code>Coyoneda</code> 는 <code>Functor</code> 입니다</li>
<li><code>Yoneda[F[_], A]</code>, <code>Coyoneda[F[_], A]</code> 는 <code>F[A]</code> 와 <em>isomorphic</em> 입니다. (<code>F</code> 가 <code>Functor</code> 일 경우)</li>
<li><code>Yoneda[F, A]</code> 에서 <code>F[A]</code> 로의 <em>homomorphism</em> 은 <code>F</code> 가 <code>Functor</code> 가 아닐 경우에도 존재합니다.</li>
<li><code>F[A]</code> 에서 <code>Coyoneda[F, A]</code> 로의 <em>homomorphism</em> 은 <code>F</code> 가 <code>Functor</code> 가 아닐 경우에도 존재합니다. (<strong>중요</strong>)</li>
<li><code>Yoneda</code>, <code>Coyoneda</code> 모두 <code>Functor</code> 가 필요한 시점을 미루고, <code>Functor.map</code> 의 체인을, 일반 함수의 체인으로 표현합니다. 결국엔 <code>Functor</code> 가 필요합니다. (<strong>중요</strong>)</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/4-yoneda-and-free/iso_vs_homo_morphism.png" alt="">
(Image - <a href="http://evolvingthoughts.net/2010/08/homology-and-analogy/">http://evolvingthoughts.net/2010/08/homology-and-analogy/</a>)</p>

<p>즉 <code>Coyoneda[F[_], A]</code> 가  <code>F</code> 와 상관없이 <code>Functor</code> 인 이유는, <code>F[A] -&gt; Coyoenda[F[_], A]</code> 로의 변환이 <code>F</code> <code>Functor</code> 인 것과 상관이 없으며 <code>Coyoneda</code> 자체가 <code>Functor</code> 인스턴스이기 때문입니다.</p>

<p>추상은 간단합니다. <code>Functor[F]</code> 가 <code>F[A] -&gt; F[B]</code> 로의 변환을 <code>f: A =&gt; B</code> 만 가지고 해 낼 수 있다는 점을 역이용하면 됩니다. <code>F[A]</code> 에 <code>Functor.map(f)</code> 를 적용하는 것이 아니라, 값 <code>A</code> 가 있을 때 <code>f(a)</code> 를 적용한 뒤에, <code>F[B]</code> 를 만들면 됩니다. 다시 말해</p>

<ul>
<li><code>Functor[F]</code> 는 <code>F[A]</code> 와 <code>f: A =&gt; B</code>, <code>g: B = &gt; C</code> 가 가 있을 때 <code>Functor[F].map(f compose g)</code> 대신</li>
<li><code>f compose g</code> 를 먼저 하고, 이것의 결과값인 <code>C</code> 를 이용해 <code>F[C]</code> 를 만들면 됩니다. 그러면 <code>Functor[F].map</code> 연산을 함수의 컴포지션으로 해결할 수 있습니다.</li>
</ul>

<h3 id="yoneda">Yoneda</h3>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Yoneda.scala

abstract class Yoneda[F[_], A] { yo =&gt;  
  def apply[B](f: A =&gt; B): F[B]

  def run: F[A] = apply(a =&gt; a)

  def map[B](f: A =&gt; B): Yoneda[F, B] = new Yoneda[F, B] {
    override def apply[C](g: (B) =&gt; C): F[C] = yo(f andThen g)
  }
}

/** `F[A]` converts to `Yoneda[F, A]` for any functor `F` */
def apply[F[_]: Functor, A](fa: F[A]): Yoneda[F, A] = new Yoneda[F, A] {  
  override def apply[B](f: A =&gt; B): F[B] = Functor[F].map(fa)(f)
}

/** `Yoneda[F, A]` converts to `F[A` for any `F` */
def from[F[_], A](yo: Yoneda[F, A]): F[A] =  
  yo.run

/** `Yoneda[F, _]` is a functor for any `F` */
implicit def yonedaFunctor[F[_]]: Functor[({ type  λ[α] = Yoneda[F,α]})#λ] =  
  new Functor[({type λ[α] = Yoneda[F, α]})#λ] {
    override def map[A, B](ya: Yoneda[F, A])(f: A =&gt; B): Yoneda[F, B] =
      ya map f
  }
</code></pre>

<p><code>Yoneda[F[_], ?]</code> 는 그 자체로 <code>Functor</code> 이나 이를 만들기 위해선 <code>F</code> 가 <code>Functor</code> 여야 합니다. 반면 <code>Yoneda[F, A] -&gt; F[A]</code> 로의 변환은 <code>F</code> 가 <code>Functor</code> 이던 아니던 상관 없습니다.</p>

<h3 id="coyoneda">Coyoneda</h3>

<p>그렇다면, <em>dual</em> 인 <code>Coyoneda</code> 는 어떨까요? <code>Yoneda</code> <code>F[A]</code> 를 <code>Functor</code> 로 부터 얻는것이 아니라, <em>Identity</em> 를 이용해, 처음부터 <code>F[A]</code> 를 가지고 있습니다. 이로 부터 얻어지는 결론은 놀랍습니다.</p>

<pre><code class="language-scala">sealed abstract class Coyoneda[F[_], A] { coyo =&gt;  
  type I
  val fi: F[I]
  val k: I =&gt; A

  final def map[B](f: A =&gt; B): Aux[F, I, B] =
    apply(fi)(f compose k)

  final def run(implicit F: Functor[F]): F[A] =
    F.map(fi)(k)
}

type Aux[F[_], A, B] = Coyoneda[F, B] { type I = A }

def apply[F[_], A, B](fa: F[A])(_k: A =&gt; B): Aux[F, A, B] =  
  new Coyoneda[F, B] {
    type I = A
    val k = _k
    val fi = fa
  }

/** `F[A]` converts to `Coyoneda[F, A]` for any `F` */
def lift[F[_], A](fa: F[A]): Coyoneda[F, A] = apply(fa)(identity[A])

/** `Coyoneda[F, A]` converts to `F[A]` for any Functor `F` */
def from[F[_], A](coyo: Coyoneda[F, A])(implicit F: Functor[F]): F[A] =  
  F.map(coyo.fi)(coyo.k)

/** `CoyoYoneda[F, _]` is a functor for any `F` */
implicit def coyonedaFunctor[F[_]]: Functor[({ type  λ[α] = Coyoneda[F,α]})#λ] =  
  new Functor[({type λ[α] = Coyoneda[F, α]})#λ] {
    override def map[A, B](ca: Coyoneda[F, A])(f: A =&gt; B): Coyoneda[F, B] =
      ca.map(f)
  }
</code></pre>

<p>따라서 <code>Coyoneda[F[_], ?]</code> 를 만들기 위해서 <code>F</code> 가 <code>Functor</code> 일 필요가 없습니다. </p>

<p><a href="http://stackoverflow.com/questions/24000465/step-by-step-deep-explain-the-power-of-coyoneda-preferably-in-scala-throu">Stackoverflow - The Power of (Co)yoneda</a> 에선 다음처럼 설명합니다.</p>

<pre><code class="language-haskell">newtype Yoneda f a = Yoneda { runYoneda :: forall b . (a -&gt; b) -&gt; f b }

instance Functor (Yoneda f) where  
  fmap f y = Yoneda (\ab -&gt; runYoneda y (ab . f))

data CoYoneda f a = forall b . CoYoneda (b -&gt; a) (f b)

instance Functor (CoYoneda f) where  
  fmap f (CoYoneda mp fb) = CoYoneda (f . mp) fb
</code></pre>

<blockquote>
  <p>So instead of appealing to the <code>Functor</code> instance for <code>f</code> during definition of the <code>Functor</code> instance for <code>Yoneda</code>, it gets <strong>"defered"</strong> to the construction of the <code>Yoneda</code> itself. Computationally, it also has the nice property of turning all <code>fmaps</code> into compositions with the "continuation" function (<code>a -&gt; b</code>).</p>
  
  <p>The opposite occurs in <code>CoYoneda</code>. For instance, <code>CoYoneda f</code> is still a <code>Functor</code> whether or not <code>f</code> is. Also we again notice the property that <code>fmap</code> is nothing more than composition along the eventual continuation.</p>
  
  <p><strong>So both of these are a way of "ignoring" a <code>Functor</code> requirement for a little while, especially while performing <code>fmap</code>s.</strong></p>
</blockquote>

<h2 id="reasonablypricedmonad">Reasonably Priced Monad</h2>

<p><em>for comprehension</em> 내에서는 단 하나의 모나드 밖에 쓸 수 없습니다. <del>단칸방 세입자 모나드</del> <em>Monad Transformer</em> 등을 사용하긴 하는데 불편하기 짝이 없지요.</p>

<p><em>Rúnar Bjarnason</em> 은 <a href="https://www.parleys.com/tutorial/composable-application-architecture-reasonably-priced-monads">Composable application architecture with reasonably priced monads
</a> 에서 <code>Coproduct</code> 를 이용해 <code>Free</code> 를 조합하는 법을 소개합니다. (<strong>이 비디오는 꼭 보셔야합니다!</strong>)</p>

<p>요약하면 <code>Free</code> 를 이용해 생성한 서로 다른 두개의 모나드는 같은 <em>for comprehension</em> 내에서 사용할 수 없습니다. 이 때 <code>Coproduct</code> 를 이용해서 하나의 타입으로 묶고, 타입 자동 주입을 위해 <code>Inject</code> 를 이용하면 많은 코드 없이도, 편리하게 <code>Free</code> 를 이용할 수 있다는 것입니다.</p>

<p>예를 들어 다음과 처럼 두개의 프리 모나드 <code>Interact</code>, <code>Auth</code> 가 있을 때</p>

<pre><code class="language-scala">// Interact
trait InteractOp[A]  
final case class Ask(prompt: String) extends InteractOp[String]  
final case class Tell(msg: String)   extends InteractOp[Unit]

type CoyonedaInteract[A] = Coyoneda[InteractOp, A]  
type Interact[A] = Free[CoyonedaInteract, A]

def ask(prompt: String) = liftFC(Ask(prompt))  
def tell(msg: String) = liftFC(Tell(msg))  
</code></pre>

<pre><code class="language-scala">// Auth
case class User(userId: UserId, permissions: Set[Permission])

sealed trait AuthOp[A]  
final case class Login(userId: UserId, password: Password) extends AuthOp[Option[User]]  
final case class HasPermission(user: User, permission: Permission) extends AuthOp[Boolean]

type CoyonedaAuth[A] = Coyoneda[AuthOp, A]  
type Auth[A] = Free[CoyonedaAuth, A]

def login(userId: UserId, password: Password): FreeC[F, Option[User]] =  
  liftFC(Login(userId, password))

def hasPermission(user: User, permission: Permission): FreeC[F, Boolean] =  
  liftFC(HasPermission(user, permission))
</code></pre>

<pre><code class="language-scala">// Log

sealed trait LogOp[A]  
final case class Warn(message: String)  extends LogOp[Unit]  
final case class Error(message: String) extends LogOp[Unit]  
final case class Info(message: String)  extends LogOp[Unit]

type CoyonedaLog[A] = Coyoneda[LogOp, A]  
type Log[A] = Free[CoyonedaLog, A]

object Log {  
  def warn(message: String)  = liftFC(Warn(message))
  def info(message: String)  = liftFC(Info(message))
  def error(message: String) = liftFC(Error(message))
</code></pre>

<p>다음처럼 같은 <em>for comprehension</em> 구문에서 사용할 수 없습니다.</p>

<pre><code class="language-scala">// doesn't compile

for {  
  userId &lt;- ask("Insert User ID: ")
  password &lt;- ask("Password: ")
  user &lt;- login(userId, password)
  _ &lt;- info(s"user $userId logged in")
  hasPermission &lt;- user.cata(
    none = point(false),
    some = hasPermission(_, "scalaz repository")
  )
  _ &lt;- warn(s"$userId has no permission for scalaz repository")
} yield hasPermission
</code></pre>

<p>이 때 <code>Coproduct</code> 를 이용하면, 가능합니다.</p>

<pre><code class="language-scala">// combine free monads
type Language0[A] = Coproduct[InteractOp, AuthOp, A]  
type Language[A] = Coproduct[LogOp, Language0, A]  
type LanguageCoyo[A] = Coyoneda[Language, A]  
type LanguageMonad[A] = Free[LanguageCoyo, A]  
def point[A](a: =&gt; A): FreeC[Language, A] = Monad[LanguageMonad].point(a)

// combine interpreters
val interpreter0: Language0 ~&gt; Id = or(InteractInterpreter, AuthInterpreter)  
val interpreter: Language ~&gt; Id = or(LogInterpreter, interpreter0)

// run a program
def main(args: Array[String]) {  
  def program(implicit I: Interact[Language], A: Auth[Language], L: Log[Language]) = {
    import I._, A._, L._

    for {
      userId &lt;- ask("Insert User ID: ")
      password &lt;- ask("Password: ")
      user &lt;- login(userId, password)
      _ &lt;- info(s"user $userId logged in")
      hasPermission &lt;- user.cata(
        none = point(false),
        some = hasPermission(_, "scalaz repository")
      )
      _ &lt;- warn(s"$userId has no permission for scalaz repository")
    } yield hasPermission
  }

  program.mapSuspension(Coyoneda.liftTF(interpreter))
}
</code></pre>

<p>여기서 <code>or</code> 과 <code>lift</code> 는 라이브러리 코드라 생각하시면 됩니다. 이제 변화된 프리 모나드 부분을 보면,</p>

<pre><code class="language-scala">object Auth {  
  type UserId = String
  type Password = String
  type Permission = String

  implicit def instance[F[_]](implicit I: Inject[AuthOp, F]): Auth[F] =
    new Auth
}

class Auth[F[_]](implicit I: Inject[AuthOp, F]) {  
  import Common._
  def login(userId: UserId, password: Password): FreeC[F, Option[User]] =
    lift(Login(userId, password))

  def hasPermission(user: User, permission: Permission): FreeC[F, Boolean] =
    lift(HasPermission(user, permission))
}

class Interact[F[_]](implicit I: Inject[InteractOp, F]) {  
  import Common._

  def ask(prompt: String): FreeC[F, String] =
    lift(Ask(prompt))

  def tell(message: String): FreeC[F, Unit] =
    lift(Tell(message))
}

object Interact {  
  implicit def instance[F[_]](implicit I: Inject[InteractOp, F]): Interact[F] =
    new Interact
}

class Log[F[_]](implicit I: Inject[LogOp, F]) {  
  import Common._

  def warn(message: String)  = lift(Warn(message))
  def info(message: String)  = lift(Info(message))
  def error(message: String) = lift(Error(message))
}

object Log {  
  implicit def instant[F[_]](implicit I: Inject[LogOp ,F]) =
    new Log
}
</code></pre>

<p>이제, <code>Common</code> 을 보면</p>

<pre><code class="language-scala">object Common {  
  import scalaz.Coproduct, scalaz.~&gt;

  def or[F[_], G[_], H[_]](f: F ~&gt; H, g: G ~&gt; H): ({type cp[α] = Coproduct[F,G,α]})#cp ~&gt; H =
    new NaturalTransformation[({type cp[α] = Coproduct[F,G,α]})#cp,H] {
      def apply[A](fa: Coproduct[F,G,A]): H[A] = fa.run match {
        case -\/(ff) ⇒ f(ff)
        case \/-(gg) ⇒ g(gg)
      }
    }

  def lift[F[_], G[_], A](fa: F[A])(implicit I: Inject[F, G]): FreeC[G, A] =
    Free.liftFC(I.inj(fa))
}
</code></pre>

<p><code>Coproduct[F, G, A]</code> 는 <strong>둘 중 하나</strong> 를 의미하는 추상입니다. 결과로 <code>F[A] \/ G[A]</code> (<em>scalaz either</em>) 을 돌려줍니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Coproduct.scala

final case class Coproduct[F[_], G[_], A](run: F[A] \/ G[A]) {  
  ...
}

trait CoproductFunctions {  
  def leftc[F[_], G[_], A](x: F[A]): Coproduct[F, G, A] =
    Coproduct(-\/(x))

  def rightc[F[_], G[_], A](x: G[A]): Coproduct[F, G, A] =
    Coproduct(\/-(x))

  ...
}
</code></pre>

<p><code>Inject[F[_], G[_]]</code> 는 <code>F</code>, <code>G</code> 를 포함하는 더 큰 타입인 <code>Coproduct</code> 를 만들때 쓰입니다.</p>

<pre><code class="language-scala">def lift[F[_], G[_], A](fa: F[A])(implicit I: Inject[F, G]): FreeC[G, A] =  
  Free.liftFC(I.inj(fa))

// F == Langauge
class Log[F[_]](implicit I: Inject[LogOp, F]) {  
  def warn(message: String)  = lift(Warn(message))
  def info(message: String)  = lift(Info(message))
  def error(message: String) = lift(Error(message))
}
</code></pre>

<p><code>Inject</code> 는 이렇게 생겼습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Inject.scala

sealed abstract class Inject[F[_], G[_]] {  
  def inj[A](fa: F[A]): G[A]
  def prj[A](ga: G[A]): Option[F[A]]
}

sealed abstract class InjectInstances {  
  implicit def reflexiveInjectInstance[F[_]] =
    new Inject[F, F] {
      def inj[A](fa: F[A]) = fa
      def prj[A](ga: F[A]) = some(ga)
    }

  implicit def leftInjectInstance[F[_], G[_]] =
    new Inject[F, ({type λ[α] = Coproduct[F, G, α]})#λ] {
      def inj[A](fa: F[A]) = Coproduct.leftc(fa)
      def prj[A](ga: Coproduct[F, G, A]) = ga.run.fold(some(_), _ =&gt; none)
    }

  implicit def rightInjectInstance[F[_], G[_], H[_]](implicit I: Inject[F, G]) =
      new Inject[F, ({type λ[α] = Coproduct[H, G, α]})#λ] {
        def inj[A](fa: F[A]) = Coproduct.rightc(I.inj(fa))
        def prj[A](ga: Coproduct[H, G, A]) = ga.run.fold(_ =&gt; none, I.prj(_))
      }
}
</code></pre>

<p>따라서 <code>F</code>, <code>G</code> 타입만 맞추어 주면 <code>Inject</code> 인스턴스는 자동으로 생성됩니다.</p>

<p>다음시간에는 <em>side-effect</em> 의 세계로 넘어가 <code>ST</code>, <code>IO</code> 등을 살펴보겠습니다.</p>

<h2 id="previousposts">Previous Posts</h2>

<ul>
<li><a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1, State</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/">Easy Scalaz 2, Monad Transformer</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/">Easy Scalaz 3, ReaderWriterState with Kleisli</a></li>
</ul>

<h2 id="references">References</h2>

<ul>
<li><a href="http://cs.lth.se/edan40">Haskell Image</a></li>
<li><a href="http://tpolecat.github.io/assets/sbtb-slides.pdf">Programs as Values: Fure Functional JDBC Programming</a></li>
<li><a href="http://blog.higher-order.com/blog/2013/11/01/free-and-yoneda/">Free Monads and the Yoneda Lemma</a></li>
<li><a href="http://stackoverflow.com/questions/24000465/step-by-step-deep-explain-the-power-of-coyoneda-preferably-in-scala-throu">Stackoverflow - The Power of (Co) Yoneda</a></li>
<li><a href="http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern">Stack Exchange - What is the Free Monad + Interpreter Pattern?</a></li>
<li><a href="http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf">Free Monad is Free Monoid + Functor</a></li>
<li><a href="http://underscore.io/blog/posts/2015/04/23/deriving-the-free-monad.html">Underscore - Deriving the Free Monad</a></li>
<li><a href="http://underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html">Underscore - Free Monads Are Simple</a></li>
<li><a href="http://stackoverflow.com/questions/10342876/differences-between-functors-and-endofunctors">Stackoverflow - Difference between functors and endofuctors</a></li>
<li><a href="http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem/3870310#3870310">Stackoverflow - A monad is just monoid in the categy of endofuctors</a></li>
<li><a href="http://evolvingthoughts.net/2010/08/homology-and-analogy/">Isomorphism vs Homomorphism Image</a></li>
<li><a href="https://www.parleys.com/tutorial/composable-application-architecture-reasonably-priced-monads">Composable application architecture with reasonably priced monads
</a>(<a href="https://gist.github.com/runarorama/a8fab38e473fafa0921d">Gist: Code</a>)</li>
</ul>]]></content:encoded></item><item><title><![CDATA[Easy Scalaz 3, ReaderWriterState with Kleisli]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p><em>Composition</em> (합성) 은 함수형 언어에서 중요한 테마중 하나인데요, 이번 시간에는 <em>Kleisli</em> 를 이용해 어떻게 함수를 타입으로 표현하고, 합성할 수 있는지 살펴보겠습니다. 그리고 나서, <em>Reader</em>, <em>Writer</em> 에 대해 알아보고, 이것들과 <em>State</em> 를 같이 사용하는 <em>RWST</em> 에 대해 알아보겠습니다.</p>

<h2 id="kleisli">Kleisli</h2>

<p><em>State</em> 가 <code>(S) =&gt; (S, A)</code> 를 타입클래스로 표현한 것이라면, <code>A =&gt;</code></p>]]></description><link>http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/</link><guid isPermaLink="false">1be76d77-2344-4db8-b924-f9015146e001</guid><category><![CDATA[scala]]></category><category><![CDATA[scalaz]]></category><category><![CDATA[readerwriterstate]]></category><category><![CDATA[kleisli]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 17 Nov 2015 11:32:42 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p><em>Composition</em> (합성) 은 함수형 언어에서 중요한 테마중 하나인데요, 이번 시간에는 <em>Kleisli</em> 를 이용해 어떻게 함수를 타입으로 표현하고, 합성할 수 있는지 살펴보겠습니다. 그리고 나서, <em>Reader</em>, <em>Writer</em> 에 대해 알아보고, 이것들과 <em>State</em> 를 같이 사용하는 <em>RWST</em> 에 대해 알아보겠습니다.</p>

<h2 id="kleisli">Kleisli</h2>

<p><em>State</em> 가 <code>(S) =&gt; (S, A)</code> 를 타입클래스로 표현한 것이라면, <code>A =&gt; B</code> 를 타입클래스로 표현한 것도 있지 않을까요? 그렇게 되면, 스칼라에서 지원하는 <code>andThen</code>, <code>compose</code> 을 이용해서 함수를 조합하는 것처럼, 타입 클래스를 조합할 수 있을겁니다. <code>Kleisli</code> 가 바로, 그런 역할을 하는 타입 클래스입니다.</p>

<blockquote>
  <p>Kleisli represents a function <code>A =&gt; M[B]</code></p>
</blockquote>

<p>타입을 보면, 단순히 <code>A =&gt; B</code> 이 아니라 <code>A =&gt; M[B]</code> 를 나타냅니다. 이는 <code>Kleisli</code> 가 <code>M</code> 을 해석하고, 조합할 수 있는 방법을 제공한다는 것을 의미합니다. 실제 구현을 보면,</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Kleisli.scala#L8

final case class Kleisli[M[_], A, B](run: A =&gt; M[B]) { self =&gt;  
  ...

  def &gt;=&gt;[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] =  kleisli((a: A) =&gt; b.bind(this(a))(k.run))

  def andThen[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &gt;=&gt; k

  def &gt;==&gt;[C](k: B =&gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &gt;=&gt; kleisli(k)

  def andThenK[C](k: B =&gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &gt;==&gt; k

  /** alias for `compose` */
  def &lt;=&lt;[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &gt;=&gt; this

  def compose[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &gt;=&gt; this

  def &lt;==&lt;[C](k: C =&gt; M[A])(implicit b: Bind[M]): Kleisli[M, C, B] = kleisli(k) &gt;=&gt; this

  def composeK[C](k: C =&gt; M[A])(implicit b: Bind[M]): Kleisli[M, C, B] = this &lt;==&lt; k
  ...
}
</code></pre>

<p><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/KleisliUsage.scala">Kleisli Example</a> 에서 간단한 예제를 가져와서 사용법을 살펴보도록 하겠습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/KleisliUsage.scala

case class Continent(name: String, countries: List[Country] = List.empty)  
case class Country(name: String, cities: List[City] = List.empty)  
case class City(name: String, isCapital: Boolean = false, inhabitants: Int = 20)

val data: List[Continent] = List(  
  Continent("Europe"),
  Continent("America",
    List(
      Country("Canada",
        List(
          City("Ottawa"), City("Vancouver"))),
      Country("USA",
        List(
          City("Washington"), City("New York"))))),
  Continent("Asia",
    List(
      Country("India",
        List(City("New Dehli"), City("Calcutta"))))))
</code></pre>

<p>여기에 다음의 함수를 정의하면 </p>

<pre><code class="language-scala">def continents(name: String): List[Continent] =  
  data.filter(k =&gt; k.name.contains(name))

def countries(continent: Continent): List[Country] = continent.countries

def cities(country: Country): List[City] = country.cities

def save(cities: List[City]): Try[Unit] =  
  Try {
    // do IO or some side-effectful operations
    cities.foreach(c =&gt; println("Saving " + c.name))
  }

def inhabitants(c: City): Int = c.inhabitants  
</code></pre>

<p>이제 <code>A =&gt; M[B]</code> 형태의 여러 함수들을 만들었으므로 이를 <code>Kleisli</code> 를 이용해 조합할 수 있습니다. (이 예제에서 <code>M == List</code>)</p>

<pre><code class="language-scala">// Kleisli[List, String, City]
val allCities = kleisli(continents) &gt;==&gt; countries &gt;==&gt; cities

// Kleisli[List, String, Int]
val cityInhabitants = allCities map inhabitants  
</code></pre>

<p><code>allCities</code> 는 <code>String</code> 을 인자로 받기도 하고, <code>M == List</code> 의 <code>Kleisli</code> 기 때문에 <code>List</code> 를 인자로 받을 수도 있습니다. (<code>=&lt;&lt;</code>)</p>

<pre><code class="language-scala">allCities("America") map(println)

// output
City(Ottawa,false,20)  
City(Vancouver,false,20)  
City(Washington,false,20)  
City(New York,false,20)

(allCities =&lt;&lt; List("America", "Asia")).map(println)

// output
City(Ottawa,false,20)  
City(Vancouver,false,20)  
City(Washington,false,20)  
City(New York,false,20)  
City(New Dehli,false,20)  
City(Calcutta,false,20)  
</code></pre>

<p><code>Kleisli</code> 가 제공하는 함수를 다시 살펴보면,</p>

<pre><code class="language-scala">def =&lt;&lt;(a: M[A])(implicit m: Bind[M]): M[B] = m.bind(a)(run)

def map[C](f: B =&gt; C)(implicit M: Functor[M]): Kleisli[M, A, C] =  
  kleisli(a =&gt; M.map(run(a))(f))

def mapK[N[_], C](f: M[B] =&gt; N[C]): Kleisli[N, A, C] =  
  kleisli(run andThen f)

def flatMapK[C](f: B =&gt; M[C])(implicit M: Bind[M]): Kleisli[M, A, C] =  
  kleisli(a =&gt; M.bind(run(a))(f))

def flatMap[C](f: B =&gt; Kleisli[M, A, C])(implicit M: Bind[M]): Kleisli[M, A, C] =  
  kleisli((r: A) =&gt; M.bind[B, C](run(r))(((b: B) =&gt; f(b).run(r))))
</code></pre>

<p>여기서 <code>mapK :: M[B] =&gt; N[C]</code> 를 이용하면 현재 <code>Kleisli[M, _, _]</code> 를 <code>Kleisli[N, _, _]</code> 로 변경할 수 있습니다.</p>

<p>위에서 정의한 <code>save</code> 함수는 <code>List[A]</code> 를 받아 <code>Try[Unit]</code> 를 여기에 사용할 수 있습니다.</p>

<pre><code class="language-scala">// Kleisli[Try, String, Unit]
val getAndSaveCities = allCities mapK save  
</code></pre>

<p><code>local</code> 을 이용하면 함수를 <em>prepend</em> 할 수 있습니다.</p>

<pre><code class="language-scala">// def local[AA](f: AA =&gt; A): Kleisli[M, AA, B] =
//   kleisli(f andThen run)

def index(i: Int): String = data(i).name

// Kleisli[List, Int, City]
val allCitiesWithIndex = allCities local index

allCitiesWithIndex(1) map(println)

// output
City(Ottawa,false,20)  
City(Vancouver,false,20)  
City(Washington,false,20)  
City(New York,false,20)  
</code></pre>

<p><code>Kleisli</code> 에 대한 더 읽을거리는 아래 링크를 참조해주세요. </p>

<ul>
<li><a href="http://eed3si9n.com/learning-scalaz/Arrow.html">Scalaz Arrow</a></li>
<li><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Kleisli.scala#L209">Scalaz - Kleisli.scala#KleisliArrow</a></li>
</ul>

<h2 id="reader">Reader</h2>

<p><code>Kleisli</code> 가 <code>A =&gt; M[B]</code> 를 나타낸다면, <code>Reader</code> 는 <code>A =&gt; B</code> (<code>Function1</code>) 를 의미하는 타입클래스입니다. 얼핏 생각하기에 <code>Kleisli[Id, A, B]</code> 일것 같죠? 실제 구현을 보면 (<em>scalaz</em> 에서 타입 얼라이어스는 <code>package.scala</code> 에 정의되어 있습니다.)</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/package.scala

type ReaderT[F[_], E, A] = Kleisli[F, E, A]  
val ReaderT = Kleisli  
type Reader[E, A] = ReaderT[Id, E, A]

object Reader {  
    def apply[E, A](f: E =&gt; A): Reader[E, A] = Kleisli[Id, E, A](f)
  }
</code></pre>

<p><code>Reader</code> 도 <code>Klelsli</code> 이므로, <code>Reader[A, B] &gt;==&gt; Reader[B, C]</code> 는 <code>Reader[A, C]</code> 가 됩니다. 게다가 <code>Kleisli</code> 는 <code>flatMap</code> 을 정의하고 있으므로 <em>monadic composition</em> 을 작성할 수 있습니다.</p>

<blockquote>
  <p>The point of a <code>Reader</code> is to supply some configuration object without having to manually (or <em>implicitly</em>) pass i around all the functions.</p>
</blockquote>

<p>요는, 함수 사이의 체인을 엮어 새로운 함수를 만들수 있고 이로인해 직접 파라미터를 넘겨줄 필요가 없습니다. 예를 들어</p>

<pre><code class="language-scala">type URI = String  
type Key = String  
type Value = String

val uri: Reader[Get, URI]  
val queryString: Reader[URI, String]  
val body: Reader[String, Map[Key, Value]

// Get =&gt; Map[Key, Value]
val queryStringToBody = uri &gt;==&gt; queryString &gt;==&gt; body  
</code></pre>

<p>간단히 구현을 해보겠습니다. 예외 처리는 외부에서 <code>Try</code> 혹은 <code>\/.fromTryCatchThrowable</code> 등으로 한다 가정하고 로직에만 집중해보면,</p>

<pre><code class="language-scala">// model
trait HttpRequest {  
  def url: String
}
case class GET(url: String) extends HttpRequest  
case class POST(url: String, body: Map[String, String]) extends HttpRequest

val uri: Reader[GET, String] = Reader { req: GET =&gt; req.url }  
val queryString: Reader[String, String] = Reader { url: String =&gt; url.split("\\?")(1) }  
val body: Reader[String, Map[String, String]] = Reader { queries: String =&gt;  
  val qs = queries.split("&amp;").toList
  qs.foldLeft(Map.empty[String, String]) { (acc: Map[String, String], q) =&gt;
    val kv = q.split("=")
    acc.updated(kv(0), kv(1))
  }
}

val queryStringToBody: Reader[GET, Map[String, String]] = uri &gt;==&gt; queryString &gt;==&gt; body  
</code></pre>

<p><code>queryStringToBody</code> 를 사용해 보면,</p>

<pre><code class="language-scala">val get1 = GET("http://www.google.com/search?query=scalaz&amp;site=github")  
val post1 = POST("http://www.google.com/search", Map("query" -&gt; "scalaz", "site" -&gt; "github"))  
val post2 = POST("https://www.google.com/search", Map("query" -&gt; "scalaz", "site" -&gt; "github"))

queryStringToBody.run(get1) shouldBe Map("query" -&gt; "scalaz", "site" -&gt; "github")  
</code></pre>

<p>함수를 몇개 더 작성해보면,</p>

<pre><code class="language-scala">val toHttpsRequest = Reader { url: String =&gt; url.replaceAll("http://$", "https://") }  
val sslProxy: Reader[_ &gt;: readerwriterstate.HttpRequest, readerwriterstate.HttpRequest] = Reader { req: readerwriterstate.HttpRequest =&gt;  
  req match {
    case request if request.url.startsWith("https://") =&gt; request
    case request: POST =&gt; request.copy(url = toHttpsRequest(request.url))
    case request: GET  =&gt; request.copy(url = toHttpsRequest(request.url))
  }
}

val convertGetToPost: Reader[_ &gt;: readerwriterstate.HttpRequest, POST] = Reader { req : readerwriterstate.HttpRequest =&gt;  
  req match {
    case get: GET =&gt;
      val split = get.url.split("\\?")
      val (path, query) = (split(0), split(1))
      val postBody = body.run(query)

      POST(path, postBody)

    case post: POST =&gt; post
  }
}
</code></pre>

<p>이제 <code>HttpRequest</code> 서브타입을 받아, 프록시를 적용하고, <code>GET</code> 이면 <code>POST</code> 로 변경하는 함수를 조합해보면 아래와 같습니다.</p>

<p>(<code>:&gt;</code> 등 <em>Type Bound</em> 에 대해서는 <a href="http://twitter.github.io/scala_school/type-basics.html">Scala School - Type &amp; Polymorphism</a> 과 <a href="http://twitter.github.io/scala_school/advanced-types.html">Scala School - Advanced Types</a> 를 참조해주세요.) </p>

<pre><code class="language-scala">val proxiedPost: Reader[_ &gt;: HttpRequest, POST] = sslProxy &gt;==&gt; convertGetToPost

// spec
proxiedPost.run(get1) shouldBe post2  
</code></pre>

<h2 id="flatmapforreader">flatMap for Reader</h2>

<p><code>Reader</code> 는 <code>Kleisli</code> 고, 이것간의 합성은 <code>&gt;==&gt;</code> 을 이용한다는것을 확인했습니다. 그럼 <code>flatMap</code> 은 어디에 쓰는걸까요? </p>

<pre><code class="language-scala">type ReaderT[F[_], E, A] = Kleisli[F, E, A]  
type Reader[E, A] = ReaderT[Id, E, A]

final case class Kleisli[M[_], A, B](run: A =&gt; M[B]) { self =&gt;  
  ...

  // andThen
  def &gt;=&gt;[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] =  kleisli((a: A) =&gt; b.bind(this(a))(k.run))

  def &gt;==&gt;[C](k: B =&gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &gt;=&gt; kleisli(k)

  def flatMapK[C](f: B =&gt; M[C])(implicit M: Bind[M]): Kleisli[M, A, C] =
    kleisli(a =&gt; M.bind(run(a))(f))

  def flatMap[C](f: B =&gt; Kleisli[M, A, C])(implicit M: Bind[M]): Kleisli[M, A, C] =
    kleisli((r: A) =&gt; M.bind[B, C](run(r))(((b: B) =&gt; f(b).run(r))))

  ...
}
</code></pre>

<p><code>flatMap</code> 을 보면 재미난 점이 보입니다. <code>Kleisli[M, A, B]</code> 와 <code>Kleisli[M, A, C]</code> 를 <code>flatMap</code> 으로 엮는데, <code>r: A</code> 를 넣어서 <code>run(r)</code> 을 실행하는걸 보실 수 있습니다. <code>Kleisli[M, A, C]</code> 까지도요! </p>

<p>즉 <code>A</code> 자체가 일종의 설정(<em>Configuration</em>) 값으로써 모든 <code>Kleisli</code> 에서 사용됩니다. 그렇기에 </p>

<ul>
<li><code>Reader[A, B]</code> 와 <code>Reader[B, C]</code> 는 <code>&gt;==&gt;</code> 으로</li>
<li><code>Reader[A, B]</code> 와 <code>Reader[A, C]</code> 는 <code>flatMap</code> 으로 엮을 수 있습니다.</li>
</ul>

<h3 id="dependencyinjectionusingreader">Dependency Injection using Reader</h3>

<p><code>Reader</code> 를 이용하면 스칼라에서 별도의 라이브러리 없이 <em>Dependency Injection</em> (이하 <em>DI</em>) 를 구현할 수 있습니다. 이는 위에서 보았던 <code>flatMap</code> 의 특징을 이용하면 됩니다. 다음과 같은 모델이 있다고 할  때, </p>

<pre><code class="language-scala">case class User(id: Long,  
                name: String,
                age: Int,
                email: String,
                supervisorId: Long)

trait UserRepository {  
  def get(id: Long): User
  def find(name: String): User
}

trait UserService {  
  def getUser(id: Long): Reader[UserRepository, User] =
    Reader(repo =&gt; repo.get(id))

  def findUser(userName: String): Reader[UserRepository, User] =
    Reader(repo =&gt; repo.find(userName))

  def getUserInfo(userName: String): Reader[UserRepository, Map[String, String]] = for {
    user &lt;- findUser(userName)
    supervisor &lt;- getUser(user.supervisorId)
  } yield Map(
    "email" -&gt; s"${user.email}",
    "boss"  -&gt; s"${supervisor.name}"
  )
}
</code></pre>

<p>다음처럼 주입할 수 있습니다.</p>

<pre><code class="language-scala">object UserRepositoryDummyImpl extends UserRepository {  
  override def get(id: Long): User = ???
  override def find(name: String): User = ???
}

class UserApplication(userRepository: UserRepository) extends UserService  
object UserApplication extends UserApplication(UserRepositoryDummyImpl)  
</code></pre>

<p>이외에도 스칼라에서 언어 자체의 기능만으로 DI 를 구현하는 방법으로 <em>Cake Pattern</em> , <em>Implicit</em> 등이 있습니다. (<a href="http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/">Scala Dependency Injection using Reader</a> 참조)</p>

<p>위의 두 방법과 <code>Reader</code> 를 사용한 방법을 비교하면, </p>

<ul>
<li><em>Cake Pattern</em> 에 비해 코드가 짧고</li>
<li><em>Implicit</em> 를 이용하지 않으므로 함수 시그니쳐가 간단합니다.</li>
</ul>

<h2 id="writer">Writer</h2>

<p><code>Writer[W, A]</code> 는 <code>run: (W, A)</code> 을 값으로 가지는 <em>case class</em> 입니다. 재미난 점은, <code>flatMap</code> 을 이용해 두개의 <code>Writer</code> 를 엮으면 각각의 값인 <code>(w1, a1)</code>, <code>(w2, a2)</code> 에 대해서 사용자가 다루는 값인 <code>a1, a2</code> 를 제하고 <code>w1</code> 과 <code>w2</code> 가 일종의 <a href="http://1ambda.github.io/easy-scalaz-1-state/">State</a> 처럼 관리되어 자동으로 <em>append</em> 된다는 점입니다. 따라서 많은 튜토리얼들이 <em>logging</em> 을 예로 들어 <code>Writer</code> 를 설명하곤 합니다.</p>

<pre><code class="language-scala">test("WriterOps") {  
  val w1: Writer[String, Int] = 10.set("w1 created")
  val w2: Writer[String, Int] = 20.set("w2 created")

  val result: Writer[String, Int] = for {
    n1 &lt;- w1
    n2 &lt;- w2
  } yield n1 + n2

  // What if we use `List[String]` instead of `String`?
  result.run shouldBe ("w1 createdw2 created", 30)
}
</code></pre>

<p><em>Scalaz</em> 구현을 보면</p>

<pre><code class="language-scala">type Writer[W, A] = WriterT[Id, W, A]

final case class WriterT[F[_], W, A](run: F[(W, A)]) { self =&gt;  
  ...

  def flatMap[B](f: A =&gt; WriterT[F, W, B])(implicit F: Bind[F], s: Semigroup[W]): WriterT[F, W, B] =
    flatMapF(f.andThen(_.run))

  def flatMapF[B](f: A =&gt; F[(W, B)])(implicit F: Bind[F], s: Semigroup[W]): WriterT[F, W, B] =
    writerT(F.bind(run){wa =&gt;
      val z = f(wa._2)
      F.map(z)(wb =&gt; (s.append(wa._1, wb._1), wb._2))
    })

  ...
</code></pre>

<p><code>WriterT</code> 에서 <code>F</code> 를 <code>Id</code> 라 하면 <code>Writer</code> 가 되고 <code>flatMap</code> 로직은 다음처럼 단순화 할 수 있습니다.</p>

<pre><code class="language-scala">case class Writer[W, A](run: (W, A)) { self =&gt;  
  def flatMap[B](f: A =&gt; Writer[W, B])(implicit s: Semigroup[W]) {
    val (w1, a) = self.run
    val (w2, b) = f(a)
    (s.append(w1, w2), b)
  }
}
</code></pre>

<p>여기서 <a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Semigroup.scala">Semigroup.scala</a> 은, <em>Associativity</em> (결합법칙) 을 만족하는 <em>binary operator</em> 를 정의하는 타입 클래스입니다. (위에서 <code>append</code>)</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Semigroup.scala#L55

 /**
   * A semigroup in type F must satisfy two laws:
    *
    *  - '''closure''': `∀ a, b in F, append(a, b)` is also in `F`. This is enforced by the type system.
    *  - '''associativity''': `∀ a, b, c` in `F`, the equation `append(append(a, b), c) = append(a, append(b , c))` holds.
   */
  trait SemigroupLaw {
    def associative(f1: F, f2: F, f3: F)(implicit F: Equal[F]): Boolean =
      F.equal(append(f1, append(f2, f3)), append(append(f1, f2), f3))
  }
</code></pre>

<p><a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Monoid.scala">Monoid</a> 는 결합법칙을 만족하는 덧셈 연산과, 항등원 연산을 정의하는 타입 클래스인데, <em>Scalaz</em> 에서는 <code>Monoid</code> 가 <code>Semigroup</code> 을 상속받습니다.</p>

<pre><code class="language-scala">trait Monoid[F] extends Semigroup[F] { self =&gt;  
  ...
</code></pre>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png" alt="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png"></p>

<p><br></p>

<p>따라서 <code>Writer[W, A]</code> 의 <code>flatMap</code> 을 이용하기 위해서는 <code>W</code> 가 <code>Semigroup</code> 여야 하고 그래야만 <code>flatMap</code> 내부에서 자동으로 <code>W</code> 를 <em>append</em> 할 수 있습니다. </p>

<p>스칼라에서 제공하는 <code>List</code> 등의 기본 타입은 <em>Scalaz</em> 에서 <code>Monoid</code> 를 제공합니다. (<a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/std/List.scala#L109">scalaz.std.List</a>, <a href="https://github.com/scalaz/scalaz/tree/series/7.1.x/core/src/main/scala/scalaz/std">scalaz.std</a> 참조)</p>

<p>정리하면, <code>Writer[W, A]</code> 를 이용하면 값인 <code>A</code> 를 조작하면서 <code>W</code> 를 신경쓰지 않고, 자동으로 <code>append</code> 시킬 수 있습니다. (e.g <em>logging</em>)</p>

<h2 id="writerexample">Writer Example</h2>

<p>간단한 모델을 만들면,</p>

<pre><code class="language-scala">import scalaz._, Scalaz._

trait ThreadState  
case object Waiting    extends ThreadState  
case object Running    extends ThreadState  
case object Terminated extends ThreadState  
case class Thread(tid: String, name: String, state: ThreadState)  
case class Process(pid: String, threads: List[Thread])

object Process {  
  type Logger[A] = Writer[Vector[String], A]

  def genRandomID: String = java.util.UUID.randomUUID().toString.replace("-", "")

  def createThread(name: String): Logger[Thread] = {
    val tid = genRandomID
    Thread(tid, name, Waiting).set(Vector(s"Thread [$tid] was created"))
  }

  def createEmptyProcess: Logger[Process] = {
    val pid = genRandomID
    Process(pid, Nil).set(Vector(s"Empty Process [$pid] was created"))
  }

  def createNewProcess: Logger[Process] = for {
    mainThread &lt;- createThread("main")
    process &lt;- createEmptyProcess
    _ &lt;- Vector(s"Main Thread [${mainThread.tid}] was added to Process [${process.pid}").tell
  } yield process.copy(threads = mainThread.copy(state = Running) :: process.threads)
}
</code></pre>

<p>여기서 <code>W</code> 로 <code>List[String]</code> 대신 <code>Vector[String]</code> 을 사용하는 이유는, <em>append</em> 가 더 빠르기 때문입니다. (<a href="http://docs.scala-lang.org/overviews/collections/performance-characteristics.html">Scala Collection Performance Characteristics</a> 참조)</p>

<pre><code class="language-scala">test("Writer usage2") {  
  import readerwriterstate.Process._

  val (written, process) = createNewProcess.run

  process.threads.length shouldBe 1
  process.threads.head.name shouldBe "main"

  /* map lets you map over the value side */
  val ts: Logger[List[Thread]] = createNewProcess.map(p =&gt; p.threads)
  ts.value.length shouldBe 1

  /* with mapWritten you can map over the written side */
  val edited: Vector[String] = createNewProcess.mapWritten(_.map { log =&gt; "[LOG]" + log }).written
  println(edited.mkString("\n"))

  /** output
   * [LOG]Thread [557ad5bd0f3b4d49bac85b05ebedcd7b] was created
   * [LOG]Empty Process [710bd940ebdd4a82b949a32b585a12d9] was created
   * [LOG]Main Thread [557ad5bd0f3b4d49bac85b05ebedcd7b] was added to Process [710bd940ebdd4a82b949a32b585a12d9]
   */

  /* with mapValue, you can map over both sides */
  createNewProcess.mapValue { case (log, p) =&gt;
    (log :+ "Add an IO thread",
     p.copy(threads = Thread(genRandomID, "IO-1", Waiting) :: p.threads))
  }

  // `:++&gt;` `:++&gt;&gt;`, `&lt;++:`, `&lt;&lt;++:`
  createNewProcess :++&gt; Vector("add some log")
  val emptyWithLog = createEmptyProcess :++&gt;&gt; { process =&gt;
    Vector(s"${process.pid} is an empty process")
  }

   println(emptyWithLog.written)

  // output: Vector(Empty Process [cf211fc366ab4d20a0c25a27d173accd] was created, cf211fc366ab4d20a0c25a27d173accd is an empty process)

  // Writer is an applicative
  val emptyProcesses: Logger[List[readerwriterstate.Process]] =
    (createEmptyProcess |@| createEmptyProcess) { List(_) |+| List(_) }

  val ps = emptyProcesses.value
  ps.length shouldBe 2
}
</code></pre>

<p><a href="http://eed3si9n.com/learning-scalaz/Applicative+Builder.html">Applicative Builder</a>, <a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/WriterT.scala#L30">WriterT Functions</a> 를 참고하시면 이해가 더 쉽습니다.</p>

<h2 id="rwst">RWST</h2>

<p><a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala">ReaderWriterState</a> 는 다름이 아니라, 이제까지 보았던 <code>Reader</code>, <code>Writer</code>, <code>State</code> 를 모두 이용하는 타입 클래스입니다. <code>Reader</code> 로 설정값을 읽고, <code>Writer</code> 로 중간 과정을 기록하고, <code>State</code> 로 상태를 변경 또는 유지해 가며 연산을 수행할 수 있습니다. <em>Scalaz</em> 에서는 예제로 <a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/ReaderWriterStateTUsage.scala">ReaderWriterStateTUsage.scala</a> 를 제공하고 있습니다.</p>

<p>이제까지 늘 그래왔듯이, <code>ReaderWriterState[R, W, S, A]</code> 또한 <code>ReaderWriterStateT[Id, R, W, S, A]</code> 의 <em>type alias</em> 입니다. <code>Reader</code>, <code>Writer</code>, <code>State</code> 에서 사용했었던 함수들도 같이 제공됩니다.</p>

<pre><code class="language-scala">type ReaderWriterState[-R, W, S, A] = ReaderWriterStateT[Id, R, W, S, A]  
type ReaderWriterStateT[F[_], -R, W, S, A] = IndexedReaderWriterStateT[F, R, W, S, S, A]

object ReaderWriterState extends ReaderWriterStateTInstances with ReaderWriterStateTFunctions {  
  def apply[R, W, S, A](f: (R, S) =&gt; (W, A, S)): ReaderWriterState[R, W, S, A] = IndexedReaderWriterStateT[Id, R, W, S, S, A] { (r: R, s: S) =&gt; f(r, s) }
}
</code></pre>

<p><code>apply</code> 를 보면, <code>ReaderWriterState</code> 는 타입 <code>(R, S) =&gt; (W, A, S)</code> 함수를 넘겨주어 생성할 수 있습니다. <code>Reader</code>, <code>State</code> 를 받고, <code>Writer</code>, <code>A</code> (결과값), <code>State</code> 를 돌려주는 것으로 해석할 수 있습니다.</p>

<p><code>ReadwrWriterState.flatMap</code> 은 <code>State</code>, <code>Writer</code>, <code>Reader</code> 의 <code>flatMap</code> 을 모두 조합한것처럼 생겼습니다. 하는일도 그렇구요. </p>

<pre><code class="language-scala">/** A monad transformer stack yielding `(R, S1) =&gt; F[(W, A, S2)]`. */
sealed abstract class IndexedReaderWriterStateT[F[_], -R, W, -S1, S2, A] {

  ...

  def flatMap[B, RR &lt;: R, S3](f: A =&gt; IndexedReaderWriterStateT[F, RR, W, S2, S3, B])(implicit F: Bind[F], W: Semigroup[W]): IndexedReaderWriterStateT[F, RR, W, S1, S3, B] =
    new IndexedReaderWriterStateT[F, RR, W, S1, S3, B] {
      def run(r: RR, s1: S1): F[(W, B, S3)] = {
        F.bind(self.run(r, s1)) {
          case (w1, a, s2) =&gt; {
            F.map(f(a).run(r, s2)) {
              case (w2, b, s3) =&gt; (W.append(w1, w2), b, s3)
            }
          }
        }
      }
    }

  ...
</code></pre>

<ul>
<li><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala#L4">Scalaz - IndexedReaderWriterStateT</a></li>
<li><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala#L179">Scalaz - ReaderWriterStateTMonad</a></li>
</ul>

<h2 id="rwstexample">RWST Example</h2>

<p>예제를 위해 간단한 모델을 만들어 보겠습니다. </p>

<ul>
<li><code>Reader</code> 로 <code>DatabaseConfig</code> 를</li>
<li><code>Writer</code> 로 <code>Vector[String]</code> 을</li>
<li><code>State</code> 로 <code>Connection</code> 을 이용하고</li>
</ul>

<p>결과값으로 타입 <code>A</code> 를 돌려주는 <code>Task[A]</code> 를 만들면 아래와 같습니다.</p>

<pre><code class="language-scala">object Database {  
  type Task[A] = ReaderWriterState[DatabaseConfig, Vector[String] /* log */, Connection, A]
  ...
</code></pre>

<p>여기에 몇 가지 제약조건을 걸어보겠습니다.</p>

<ul>
<li><code>DatabaseConfig.operationTimeoutMillis</code> 에 의해서 타임아웃(<code>OperationTimeoutException</code>) 발생</li>
<li><code>OperationTimeoutException</code> 발생시, 연산을 즉시 중단하고, 오류 없이 수행이 되었을 경우 <em>commit</em> </li>
<li><em>Post Commit Action</em> 등록을 할 수 있어야 하며, <em>commit</em> 후 순차대로 자동 실행</li>
</ul>

<p>이제 필요한 몇몇 클래스를 만들고</p>

<pre><code class="language-scala">type Action = () =&gt; Unit  
case class PostCommitAction(id: String, action: Action)  
case class DatabaseConfig(operationTimeoutMillis: Long)  
case class ResultSet() /* dummy */

case class Connection(id: String,  
                      actions: List[PostCommitAction] = Nil) {

  def commit = {}
  def executeAndReturn(query: String): ResultSet = ResultSet()
  def execute(query: String): Unit = {}
}

class OperationTimeoutException private(ex: RuntimeException) extends RuntimeException(ex) {  
  def this(message:String) = this(new RuntimeException(message))
  def this(message:String, throwable: Throwable) = this(new RuntimeException(message, throwable))
}

object OperationTimeoutException {  
  def apply(message:String) = new OperationTimeoutException(message)
  def apply(message:String, throwable: Throwable) = new OperationTimeoutException(message, throwable)
}
</code></pre>

<p>이제 사용자가 API 를 사용하는 것을 한번 상상해보겠습니다. <em>commit</em> 이 어쨌건, 사용자가 하고싶은 일은 쿼리를 실행해서 결과값을 받아오거나, 필요한 <em>post commit action</em> 을 등록하는 일일겁니다. 나머지는 다 알아서 해주겠거니 하고 기대하고 있겠지요. 아래와 같은 API 가 있다면,</p>

<pre><code class="language-scala">def createTask[A](f: Connection =&gt; A): Task[A]  
def addPostCommitAction(action: Action): Task[Unit]  
def run[A](task: Task[A]): Option[A]  
</code></pre>

<p>사용자들이 이런 방식으로 사용할 수 있습니다.</p>

<pre><code class="language-scala">case class Person(name: String, address: Address)  
case class Address(street: String)

def getPerson(name: String): Task[Person] = createTask { conn =&gt;  
  val rs: ResultSet = conn.executeAndReturn(s"SELECT * FROM USER WHERE name == '$name'")

  /* get a person using the result set */
  ...
}

def updateAddress(person : Person): Task[Unit] = createTask { conn =&gt;  
  /* do something */
  conn.execute(
    s"UPDATE ADDRESS SET street = '${person.address.street}' where person_name = '${person.name}'")
}

val getAndUpdatePersonTask: Task[Person] = for {  
  p &lt;- getPerson("1ambda")
  updatedP = p.copy(address = Address("BACON STREET 234"))
  _ &lt;- addPostCommitAction(() =&gt; println("post commit action1"))
  _ &lt;- updateAddress(updatedP)
  _ &lt;- addPostCommitAction(() =&gt; println("post commit action2"))
} yield updatedP

val person: Option[Person] = Database.run(getAndUpdatePersonTask)  
</code></pre>

<p>이제 상상했던 함수를 구현해 보면,</p>

<pre><code class="language-scala">// https://github.com/1ambda/scala/blob/master/learning-scalaz/src/main/scala/readerwriterstate/Database.scala

import java.util.UUID  
import scalaz._, Scalaz._  
import Database._  
import com.github.nscala_time.time.Imports._

object Database {

  ...
  object Implicit {
    implicit def defaultConnection: Connection = Connection(genRandomUUID)
    implicit def defaultConfig = DatabaseConfig(500)
  }

  private def genRandomUUID: String = UUID.randomUUID().toString

  private def execute[A](f: =&gt; A, conf: DatabaseConfig): A = {
    val start = DateTime.now

    val a = f

    val end = DateTime.now

    val time: Long = (start to end).millis

    if (time &gt; conf.operationTimeoutMillis)
      throw OperationTimeoutException(s"Operation timeout: $time millis")

    a
  }

  def createTask[A](f: Connection =&gt; A): Task[A] =
    ReaderWriterState { (conf, conn) =&gt;
      val a = execute(f(conn), conf)
      (Vector(s"Task was created with connection[${conn.id}]"), a, conn)
    }

  def addPostCommitAction(action: Action): Task[Unit] =
    ReaderWriterState { (conf, conn: Connection) =&gt;

      val postCommitAction = PostCommitAction(genRandomUUID, action)
      (Vector(s"Add PostCommitAction(${postCommitAction.id})"),
        Unit,
        conn.copy(actions = conn.actions :+ postCommitAction))
    }

  def run[A](task: Task[A])
            (implicit defaultConf: DatabaseConfig, defaultConn: Connection): Option[A] = {

    \/.fromTryCatchThrowable[(Vector[String], A, Connection), Throwable](
      task.run(defaultConf, defaultConn)
    ) match {
      case -\/(t) =&gt;
        println(s"Operation failed due to ${t.getMessage}") /* logging */
        none[A]

      case \/-((log: Vector[String], a: A, conn: Connection)) =&gt;
        conn.commit /* close connection */

        log.foreach { text =&gt; println(s"[LOG] $text")} /* logging */

        /* run post commit actions */
        conn.actions foreach { _.action() }

        a.some
    }
  }
</code></pre>

<p>이제 실제로 <em>500 ms</em> 를 초과하는 연산을 실행하면, 예외가 발생하는 것을 확인할 수 있습니다.</p>

<pre><code class="language-scala">  test("Database example") {

    val slowQuery: Task[Person] = createTask { conn =&gt;
      sleep(600)
      Person("Sherlock", Address("BACON ST 221-B"))
    }

    val getPeopleTask: Task[List[Person]] = for {
      p1 &lt;- getPerson("Mycroft")
      p2 &lt;- getPerson("Watson")
      p3 &lt;- slowQuery
      _ &lt;- addPostCommitAction(() =&gt; println("post commit1"))
    } yield p1 :: p2 :: p3 :: Nil

    import Database.Implicit._
    val people = Database.run(getPeopleTask)

    // log: Operation failed due to java.lang.RuntimeException: Operation timeout: 603 millis
    people shouldBe None
}
</code></pre>

<h2 id="previousposts">Previous Posts</h2>

<ul>
<li><a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1, State</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/">Easy Scalaz 2, Monad Transformer</a></li>
</ul>

<h2 id="references">References</h2>

<ul>
<li><a href="http://cs.lth.se/edan40">Haskell Image</a></li>
<li><a href="https://coderwall.com/p/ye_s_w/tooling-the-reader-monad">Tooling The Reader Monad</a></li>
<li><a href="http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/">Reader Monad For Dependency Injection</a></li>
<li><a href="http://slides.com/danielbedo/reader-monad">Slideshare: Reader Monad</a></li>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia Image</a></li>
<li><a href="http://docs.scala-lang.org/overviews/collections/performance-characteristics.html">Scala Collection Performance Characteristics</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[About Type Class]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png" alt=""></p>

<p>프로그래머가 하는 행위를 극도로 단순화해서 표현하면 <strong>저수준</strong> 의 데이터를 <strong>고수준</strong> 데이터로 변환하는 일입니다.</p>

<p>여기서 저수준이란, <em>Stream</em>, <em>Byte</em>, <em>JSON</em>, <em>String</em> 등 현실세계의 데이터를, 고수준이라 함은 비즈니스 로직, 제약조건 등이 추가된 도메인 객체, 모델 등 데이터를 말합니다. </p>

<p>이로 인해</p>

<ol>
<li><p>저수준을 고수준으로 변환하는건 조건이 충족되지 않은 데이터와 연산 과정에서 일어나는 시스템 오류를 처리해야하기</p></li></ol>]]></description><link>http://1ambda.github.io/about-type-class/</link><guid isPermaLink="false">40c5a8ff-eb1f-40a3-a8b6-38f5e97ced9f</guid><category><![CDATA[scala]]></category><category><![CDATA[scalaz]]></category><category><![CDATA[type class]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 20 Oct 2015 16:43:43 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png" alt=""></p>

<p>프로그래머가 하는 행위를 극도로 단순화해서 표현하면 <strong>저수준</strong> 의 데이터를 <strong>고수준</strong> 데이터로 변환하는 일입니다.</p>

<p>여기서 저수준이란, <em>Stream</em>, <em>Byte</em>, <em>JSON</em>, <em>String</em> 등 현실세계의 데이터를, 고수준이라 함은 비즈니스 로직, 제약조건 등이 추가된 도메인 객체, 모델 등 데이터를 말합니다. </p>

<p>이로 인해</p>

<ol>
<li><p>저수준을 고수준으로 변환하는건 조건이 충족되지 않은 데이터와 연산 과정에서 일어나는 시스템 오류를 처리해야하기 때문에 힘든일입니다</p></li>
<li><p>갖은 고생 끝에 데이터를 고수준으로 끌어올린 뒤에야, 그 데이터를 프로그래머 자신의 세상에서 마음껏 주무를 수 있습니다</p></li>
<li><p>프로그래머가 작업을 끝낼 시점이 되면, 데이터를 저수준으로 변환해서 저장 또는 전송해야 하는데, 이미 제약조건이 충족 되었기 때문에 이는 손쉬운 일입니다</p></li>
</ol>

<p>따라서 핵심은 다음의 두가지 입니다.</p>

<ul>
<li>쉽게 고수준으로 변환할 수 있는가 (<strong>연산</strong>)</li>
<li>변환된 고수준 데이터가 얼마나 다루기 편한가 (<strong>추상</strong>)</li>
</ul>

<p>프로그래머가 <em>적절한 연산</em> 을 선택하면 힘들이지 않고 변환을 해낼것이고, <em>적절한 추상 (혹은 모델링)</em> 을 한다면 직관적인 코드로 데이터를 주무를 수 있게 되는데, 이 것을 도와주는 것이 바로 <strong>타입 클래스</strong> 입니다.</p>

<p>타입 클래스를 이용하면, </p>

<ul>
<li><code>if null</code>  을 Option 으로,</li>
<li><code>S =&gt; (S, A)</code> 을 State[S, A] 로</li>
<li><code>if if if</code> 를 Applicative 로</li>
<li><em>fail-slow</em>, <em>fail-fast</em> 로직은 ValidationNel 과 Either 로</li>
<li><code>F[G[A]]</code> 을 <code>G[F[A]]</code> 로의 변경은 Traversal 로</li>
<li><code>setC{applyB{getA}}</code> 를 getA > applyB > setC 로(Kleisli)
표기할 수 있습니다.</li>
</ul>

<p>이렇게 연산을 각각의 타입으로 표시하기 때문에 로직을 파악하고, 분할하기 쉽습니다. 그리고 연산을 작성하는 과정이 타입을 조합하는 과정과 동일하기 때문에 컴파일러의 도움을 받을수 있구요.</p>

<p>타입클래스는 <strong>연산이 어떠해야 하는지</strong> 를 다루기 때문에 연산을 조합할 수 있는 다양한 함수들이 포함되어 있습니다. 이것을 이용하면 직관적인 방식으로 데이터를 다룰 수 있는데, 예를 들어 다음은 코드 실행과정에서 예외 발생 시에만 롤백을 수행하고, 예외를 돌려주는 코드입니다. (간략화 하였습니다.) </p>

<pre><code class="language-scala">\/.fromTryCatch { 
  val result = runQuery; 
  commit; 
  result 
} leftMap(err =&gt; rollback; err};
</code></pre>

<p>만약 <code>if null</code>  보다  <code>Option</code> 을 쓰는것이 더 편하고 익숙하다면, <code>Applicative</code> 부터 천천히 시작해보는건 어떨까요?</p>

<h3 id="reference">Reference</h3>

<ul>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia Image - Haskell Wiki</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Easy Scalaz 2, Monad Transformer]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p>지난 시간엔 <em>State Monad</em> 를 다루었습니다. 그러나 <em>State</em> 만 이용해서는 유용한 프로그램을 작성할 수 없습니다. 우리가 다루는 연산은 <em>Option</em>, <em>Future</em> 등 다양한 <em>side-effect</em> 가 필요하기 때문인데요, </p>

<p>서로 다른 <code>Monad</code> 를 조합할 수 있다면 좋겠지만, 아쉽게도  <code>Functor</code>, <code>Applicative</code> 와 달리 모나드는 <em>composing</em> 이 불가능합니다. <a href="http://tonymorris.github.io/blog/posts/monads-do-not-compose">Monad Do Not Compose</a></p>

<p>여러 모나드를 조합해서</p>]]></description><link>http://1ambda.github.io/easy-scalaz-2-monad-transformer/</link><guid isPermaLink="false">20ace812-f624-48ad-bfe9-9d1b707ed231</guid><category><![CDATA[scala]]></category><category><![CDATA[scalaz]]></category><category><![CDATA[monad transformer]]></category><category><![CDATA[EitherT]]></category><category><![CDATA[OptionT]]></category><category><![CDATA[StateT]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 16 Oct 2015 14:46:45 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p>지난 시간엔 <em>State Monad</em> 를 다루었습니다. 그러나 <em>State</em> 만 이용해서는 유용한 프로그램을 작성할 수 없습니다. 우리가 다루는 연산은 <em>Option</em>, <em>Future</em> 등 다양한 <em>side-effect</em> 가 필요하기 때문인데요, </p>

<p>서로 다른 <code>Monad</code> 를 조합할 수 있다면 좋겠지만, 아쉽게도  <code>Functor</code>, <code>Applicative</code> 와 달리 모나드는 <em>composing</em> 이 불가능합니다. <a href="http://tonymorris.github.io/blog/posts/monads-do-not-compose">Monad Do Not Compose</a></p>

<p>여러 모나드를 조합해서 사용하려면 <em>Monad Transformer</em> 가 필요합니다.</p>

<blockquote>
  <p>Monad transformers are useful for enabling interaction between different types of monads by "nesting" them into a higher-level monadic abstraction.</p>
</blockquote>

<p><em>Monad Transformer</em> 란 여러 모나드의 <em>effect</em> 를 엮어 새로운 모나드를 만들때 쓸 수 있습니다. 예를 들어</p>

<ul>
<li>어떤 임의의 모나드 M 을 사용하면서 <code>State</code> 효과를 주고 싶을 때 <code>StateT</code> 를 이용할 수 있습니다</li>
<li><code>State</code> 를 다루면서, <code>for</code> 내에서 <code>Option</code> 처럼 로직을 다루고 싶다면, <code>OptionT[State, A]</code> 를 이용할 수 있습니다</li>
</ul>

<p>대략 감이 오시죠? (<code>State</code> 에 대한 자세한 설명은 <a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1 - State</a> 을 참조)</p>

<p><em>scalaz</em> 에는 기본적으로 여러 모나드 트랜스포머가 정의되어 있습니다. (<a href="https://github.com/scalaz/scalaz/tree/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz">scalaz.core.*</a>) <code>ListT</code>, <code>MaybeT</code> 등등. 이번 글에서는 아래 3개의 모나드 트랜스포머만 다룰 예정입니다. </p>

<ul>
<li><a href="https://github.com/scalaz/scalaz/blob/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz/OptionT.scala">Scalaz - OptionT.scala</a></li>
<li><a href="https://github.com/scalaz/scalaz/blob/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz/EitherT.scala">Scalaz - EitherT.scala</a></li>
<li><a href="https://github.com/scalaz/scalaz/blob/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz/StateT.scala">Scalaz - StateT.scala</a></li>
</ul>

<h2 id="theproblem">The Problem</h2>

<p>모나드 트랜스포머를 설명하기 위해, 사용자의 Github Repository 에 어느 언어가 쓰였는지를 알려주는 <code>findLanguage</code> 함수를 작성해보겠습니다.</p>

<pre><code class="language-scala">// ref - https://softwarecorner.wordpress.com/2013/12/06/scalaz-optiont-monad-transformer/

import scalaz._, Scalaz._

case class User(name: String, repositories: List[Repository])  
case class Repository(name: String, languages: List[Language])  
case class Language(name: String, line: Long)

object GithubService {  
  def findLanguage(users: List[User],
                    userName: String,
                    repoName: String, 
                    langName: String): Option[Language] =
    for {
      u &lt;- users          find { _.name === userName }
      r &lt;- u.repositories find { _.name === repoName }
      l &lt;- r.languages    find { _.name === langName }
    } yield l
}
</code></pre>

<p><code>List[User]</code> 를 받아 해당 유저의 레포지토리에서 특정 언어가 있는지, 없는지를 검사하는 간단한 함수입니다.</p>

<pre><code class="language-scala">val u1 = User(  
  "1ambda", List(
    Repository("akka", List(
      Language("scala", 4990),
      Language("java",  12801)
    )),

    Repository("scalaz", List(
      Language("scala", 1451),
      Language("java",  291)
    ))
  )
)

val u2 = User(  
  "2ambda", List()
)

val users = List(u1, u2)

// spec
"findLanguage" in {
  val l1 = findLanguage(users, "1ambda", "akka", "scala")
  val l2 = findLanguage(users, "1ambda", "akka", "haskell")
  val l3 = findLanguage(users, "1ambda", "rx-scala", "scala")
  val l4 = findLanguage(users, "adbma1", "rx-scala", "scala")

  l1.isDefined shouldBe true
  l2.isDefined shouldBe false
  l3.isDefined shouldBe false
  l4.isDefined shouldBe false
  }
</code></pre>

<p>그런데, 요구사항이 갑자기 변경되어 많이 쓰이는 언어도 찾아내야 합니다. <strong>검사한 것 중 1000 줄이 넘는 언어리스트를 상태로 다루면</strong>,</p>

<pre><code class="language-scala">type LangState = State[List[Language], Option[Language]]  
</code></pre>

<p>이제 <code>findLanguage</code> 를 다시 작성하면,</p>

<pre><code class="language-scala">def findLanguage2(users: List[User],  
                  userName: String,
                  repoName: String,
                  langName: String): LangState =
  for {
    u &lt;- users.find(_.name === userName).point[LangState]
    r  &lt;- u.repositories.find(_.name === repoName).point[LangState]
    l &lt;- r.languages.find(_.name === langName).point[LangState]
    _ &lt;- modify(langs: List[Language] =&gt; if (l.line &gt;= 1000) l :: langs else langs)
  } yield song
</code></pre>

<p>당연히 컴파일이 되지 않습니다. 이는 <code>u</code>, <code>r</code>, <code>l</code> 이 각각 <code>User</code>, <code>Repository</code>, <code>Language</code> 가 아니라 <code>Option[User]</code>, <code>Option[Repository]</code>, <code>Option[Language]</code> 이기 때문입니다. 패턴 매칭을 적용하면 아래와 같은 코드가 만들어집니다.</p>

<pre><code class="language-scala">def findLanguage(users: List[User],  
                  userName: String,
                  repoName: String,
                  langName: String): LangState[Option[Language]] =
  for {
    optUser &lt;- (users.find { _.name === userName }).point[LangState]
    optRepository &lt;- (
      optUser match {
        case Some(u) =&gt; u.repositories.find(_.name === repoName)
        case None =&gt; none[Repository] // same as Option.empty[Repository]
      }).point[LangState]
    optLanguage &lt;- (optRepository match {
      case Some(r) =&gt; r.languages.find(_.name === langName)
      case None    =&gt; none[Language]
    }).point[LangState]
    _ &lt;- modify { langs: List[Language] =&gt; optLanguage match {
      case Some(l) if l.line =&gt; 1000 =&gt; l :: langs
      case _                         =&gt; langs
    }}
  } yield optLanguage
</code></pre>

<p>위 코드에서 중복되는 부분을 발견할 수 있는데요, 바로 <code>State[S, Option[A]]</code> 에 대해 매번 패턴 매칭을 수행하는 부분이 중복입니다. 이를 제거하기 위해 새로운 모나드 <code>LangStateOption</code> 을 만들면</p>

<pre><code class="language-sacla">case class LangStateOption[A](run: LangState[Option[A]])  
</code></pre>

<p>이제 모나드를 구현하면</p>

<pre><code class="language-scala">implicit val LangStateOptionMonad = new Monad[LangStateOption] {  
  override def point[A](a: =&gt; A): LangStateOption[A] =
    LangStateOption(a.point[Option].point[LangState])

  override def bind[A, B](fa: LangStateOption[A])(f: (A) =&gt; LangStateOption[B]): LangStateOption[B] =
    LangStateOption(fa.run.flatMap { (o: Option[A]) =&gt; o match {
      case Some(a) =&gt; f(a).run
      case None    =&gt; (none[B]).point[LangState] /* same as `(None: Option[B]).point[LangState]` */
    }})
}

// findLanguage impl
def findLanguage3(users: List[User],  
                  userName: String,
                  repoName: String,
                  langName: String): LangStateOption[Language] =
  for {
    u &lt;- LangStateOption((users.find { _.name === userName }).point[LangState])
    r &lt;- LangStateOption((u.repositories.find { _.name === repoName }).point[LangState])
    l &lt;- LangStateOption((r.languages.find { _.name === langName }).point[LangState])
    _ &lt;- LangStateOption((modify { langs: List[Language] =&gt;
      if (l.line &gt;= 1000) l :: langs else langs
    }) map (_ =&gt; none[Language]))
  } yield l
</code></pre>

<p>여기서 잘 보셔야 할 두 가지 부분이 있습니다</p>

<p>A. 우리가 임의의 모나드와 <code>Option</code> 을 엮은 새로운 모나드를 생성한다면, <code>LangStateOption</code> 타입만 다르고 모두 동일한 형태의 코드를 가지게 됩니다.</p>

<p>그런고로 <em>scalaz</em> 에서는 <code>Option</code> 과 임의의 모나드 <code>M</code> 을 조합한 타입을 <code>OptionT[M[_], A]</code> 로 제공합니다. </p>

<p>B. <code>State</code> 와 <code>Option</code> 을 엮어서 <code>State[S, Option[A]]</code> 를 엮을 경우 <code>State</code> 가 먼저 실행되고, 그 후에야 <code>Option</code> 이 효과를 발휘합니다. (<code>fa.run.flatMap { o =&gt; ...</code>}</p>

<p>따라서 어떤 모나드 트랜스포머와, 모나드를 엮냐에 따라서 의미가 달라집니다. 예를 들어 <em>scalaz</em> 에서 제공해주는 모나드 트랜스포머 <code>OptionT</code> 와 <code>StateT</code> 에 대해 </p>

<ul>
<li><code>OptionT[LangState, A]</code> 는 <code>run: LangState[Option[A]]</code> 이기 때문에 <em>optional value</em> 를 돌려주는 <em>state action</em> 을 의미하고</li>
<li>반면 <code>StateT[Option, List[Language], A]]</code> 는 <code>run: Option[State[List[Language], A]]</code> 기 때문에 존재하지 않을 수 있는 (<code>None</code>) 일 수 있는 <em>state action</em> 을 의미합니다</li>
</ul>

<h2 id="monadtrans">MonadTrans</h2>

<p>지금까지 우리가 했던 일을 살펴보면,</p>

<blockquote>
  <p><code>M[A]</code> -> <code>M[N[A]]</code> -> <code>NT[M[N[_]], A]</code></p>
</blockquote>

<p>즉 하나의 모나드 <code>M</code> 이 있을때 <code>A</code> 를 <code>N[A]</code> 로 <em>lifting</em> 하는 <code>N</code> 을 위한 모나드 트랜스포머를 <code>NT</code> 를 정의했습니다. <em>scalaz</em> 에서 사용된 모나드 트랜스포머 구현인 <code>MonadTrans</code>, <code>OptionT</code> 을 보면 다음과 같습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/MonadTrans.scala
trait MonadTrans[F[_[_], _]] {  
  def liftM[G[_]: Monad, A](g: G[A]): F[G, A]

  ...
}

// OptionT `liftM` implementation (F == Option)
// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/OptionT.scala#L213

def liftM[G[_], A](a: G[A])(implicit G: Monad[G]): OptionT[G, A]) =  
  OptionT[G, A](G.map[A, Option[A]](a) { (a: A) =&gt; 
    a.point[Option]
  }
</code></pre>

<p><strong>Monad Transformer</strong> 또한 <strong>Monad</strong> 기 때문에 또 다른 <strong>Monad Transformer</strong> 와 중첩이 가능합니다. 예를 들어</p>

<pre><code class="language-scala">// ref - http://www.slideshare.net/StackMob/monad-transformers-in-the-wild
type VIO[A] = ValidationT[IO, Throwable, A]  
def doIO: VIO[Option[String]  
val r = OptionT[VIO, String] = optionT[VIO](doIO)

// OptionT[ValidationT[IO, Throwable, A]
// == IO[Validation[Throwable, Option[A]]
</code></pre>

<h2 id="optiont">OptionT</h2>

<p>이제 모나드 트랜스포머가 무엇인지 알았으니, <code>OptionT</code> 를 사용해 볼까요?</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/OptionT.scala

final case class OptionT[F[_], A](run: F[Option[A]]) {  
  self =&gt;

  private def mapO[B](f: Option[A] =&gt; B)(implicit F: Functor[F]) = F.map(run)(f)

  def map[B](f: A =&gt; B)(implicit F: Functor[F]): OptionT[F, B] = new OptionT[F, B](mapO(_ map f))

  def flatMap[B](f: A =&gt; OptionT[F, B])(implicit F: Monad[F]): OptionT[F, B] = new OptionT[F, B](
    F.bind(self.run) {
      case None    =&gt; F.point(None: Option[B])
      case Some(z) =&gt; f(z).run
    }
  )

  def flatMapF[B](f: A =&gt; F[B])(implicit F: Monad[F]): OptionT[F, B] = new OptionT[F, B](
    F.bind(self.run) {
      case None    =&gt; F.point(none[B])
      case Some(z) =&gt; F.map(f(z))(b =&gt; some(b))
    }
  )
</code></pre>

<p><code>OptionT</code> 는 두 가지 방법으로 생성할 수 있습니다.</p>

<ul>
<li><code>val ma: M[A]</code> 가 있을 때 <code>ma.liftM[OptionT]</code></li>
<li><code>val oa: Option[A]</code> 가 있을 때 <code>OptionT(oa.point[M])</code></li>
</ul>

<pre><code class="language-scala">// type LangState[A] = State[List[Language], A]
val l = Language("lisp", 309)  
val os1: OptionT[LangState, Language] = l.point[LangState].liftM[OptionT]  
val os2: OptionT[LangState, Language] = OptionT(l.some.point[LangState])

os1 === os2  
os1.run === os2.run  
os1.run.runZero[List[Language]] === os2.run.runZero[List[Language]]  
</code></pre>

<p>이제 <code>findLanguage</code> 함수를 <code>OptionT</code> 로 작성할 수 있습니다. </p>

<pre><code class="language-scala">def findLanguage(users: List[User],  
                  userName: String,
                  repoName: String,
                  langName: String): OptionT[LangState, Language] =
  for {
    u &lt;- OptionT((users.find { _.name === userName }).point[LangState])
    r &lt;- OptionT((u.repositories.find { _.name === repoName }).point[LangState])
    l &lt;- OptionT((r.languages.find { _.name === langName }).point[LangState])
    _ &lt;- modify { langs: List[Language] =&gt;
      if (l.line &gt;= 1000) l :: langs else langs
    }.liftM[OptionT]
  } yield l
</code></pre>

<h3 id="sequencingoptiont">Sequencing OptionT</h3>

<p><code>findLanguage</code> 를 이용해서, findLanguage<strong>s</strong> 를 작성하는 것이 가능할까요?</p>

<pre><code class="language-scala">case class LanguageLookup(userName: String, repoName: String, langName: String)

// Option[List[Language]] 를 돌려주는 All or Nothing 버전
def findLanguages(users: List[User],  
                     lookups: List[LanguageLookup]): OptionT[LangState, List[Language]] = ???

// List[Option[Language]] 를 돌려주는 덜 엄격한 버전
def findLanguages(users: List[User],  
                     lookups: List[LanguageLookup]): LangState[List[Option[Language]]] = ???
</code></pre>

<p>일단 <code>OptionT[LangState, List[Language]]</code> 를 돌려주는 것 부터 작성해 보겠습니다.</p>

<pre><code class="language-scala">def findLanguages1(users: List[User],  
                   lookups: List[LanguageLookup]): OptionT[LangState, List[Language]] =
  lookups map { lookup =&gt;
    findLanguage(users, lookup.userName, lookup.repoName, lookup.langName)
  }

// compile error
Error:(87, 13) type mismatch;

 found   : List[scalaz.OptionT[LangState, Language]]
 required: scalaz.OptionT[LangState,List[Language]]
    lookups map { lookup =&gt;
            ^
</code></pre>

<p>우리는 <code>OptionT[LangState, List[Language]]</code> 를 돌려줘야 하는데, 단순히 <code>map</code> 만 적용해서는 <code>List[OptionT[LangState, Language]]</code> 밖에 못 얻습니다. 따라서 <code>Traversable.traverseU</code> 를 이용하면</p>

<pre><code class="language-scala">def findLanguages1(users: List[User],  
                   lookups: List[LanguageLookup]): OptionT[LangState, List[Language]] =
  lookups.traverseU { lookup =&gt;
    findLanguage(users, lookup.userName, lookup.repoName, lookup.langName)
  }
</code></pre>

<p>여기서 <code>traverseU(f)</code> 가 하는 일은 </p>

<ul>
<li><code>map(f)</code>: 함수 <code>f</code> 를 적용합니다.</li>
<li><code>List[OptionT[LangState, Language]]</code> 를 <code>OptionT[LangState, List[Language]]</code> 를 변환합니다. <strong>Option 모나드의 효과를 적용하면서요</strong> (<strong>sequence</strong>)</li>
</ul>

<p>일반적으로 <code>F[G[B]]</code> 를 <code>G[F[B]]</code> 로 변경하는 함수를 <code>sequence</code> 라 부릅니다. (<code>F</code> 는 <em>Monad</em>, <code>G</code> 는 <em>applicative</em>)</p>

<pre><code class="language-scala">final def sequence[G[_], B](implicit ev: A === G[B], G: Applicative[G]): G[F[B]] = {  
  ...
}
</code></pre>

<p><code>map</code> 후 <code>sequence</code> 를 호출하는 함수가 바로 위에서 보았던 <code>traverse</code> 입니다. 그런데, 더 높은 추상에서 보면 방금 말했던 것과는 반대로, <code>sequence</code> 가 <em>identity</em> 함수를 <code>map</code> 한 <code>traverse</code> 입니다. <strong>scalaz</strong> 에도 실제로 이렇게 구현되어 있습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/syntax/TraverseSyntax.scala#L25

  final def traverse[G[_], B](f: A =&gt; G[B])(implicit G: Applicative[G]): G[F[B]] =
    G.traverse(self)(f)

  /** Traverse with the identity function */
  final def sequence[G[_], B](implicit ev: A === G[B], G: Applicative[G]): G[F[B]] = {
    val fgb: F[G[B]] = ev.subst[F](self)
    F.sequence(fgb)
  }
</code></pre>

<p>위에서 <code>traverse</code> 가 아니라 <code>traverseU</code> 를 호출한 이유는 <code>OptionT</code> 에 대한 타입추론을 이용하기 위해서 입니다.</p>

<p><br></p>

<p>이제 덜 엄격한 <code>findLanguages</code> 함수를 작성해보겠습니다.</p>

<pre><code class="language-scala">def findLanguages2(users: List[User],  
                   lookups: List[LanguageLookup]): LangState[List[Option[Language]]] =
  lookups.traverseS { lookup =&gt;
    findLanguage(users, lookup.userName, lookup.repoName, lookup.langName).run
  }
</code></pre>

<p><code>traverseS</code> 는 <em>state</em> 버전의 <code>traverse</code> 입니다. <code>map</code> 을 적용한 <code>List[OptionT[LangState, Language]]</code> 에 대해 <code>LangState[List[Option[Language]]</code> 를 돌려줍니다.</p>

<pre><code class="language-scala">/** A version of `traverse` specialized for `State` */
final def traverseS[S, B](f: A =&gt; State[S, B]): State[S, F[B]] = F.traverseS[S, A, B](self)(f)  
</code></pre>

<p><code>State[S, A]</code> 에 대해서 </p>

<ul>
<li><code>State[S, Option[List[A]]</code> 를 얻고 싶다면 (<strong>all or nothing</strong>) <code>traverseU</code> 를</li>
<li><code>State[S, List[Option[A]]</code> 를 얻고 싶다면 <code>B = Option[A]</code> 를 <code>List</code> 로 감싸야 하므로 <code>State[S, F[B]]</code> 를 돌려주는 위해 <code>traverseS</code> 를 사용하면 됩니다.</li>
</ul>

<h3 id="eithert">EitherT</h3>

<p><code>EitherT</code> 는 <em>scalaz</em> 의 <code>Either</code> 에 대한 모나드 트랜스포머입니다. 참고로, <code>scalaz.Either</code> 은 <code>scala.Either</code> 과 달리 <em>right-biased</em> 입니다. <code>Option</code> 처럼요.</p>

<blockquote>
  <p><code>A \/ B</code> is isomorphic to <code>scala.Either[A, B]</code>, but <code>\/</code> is right-biased, so methods such as <code>map</code> and <code>flatMap</code> apply only in the context of the "right" case.</p>
</blockquote>

<p><code>scalaz.Either</code> 에 대한 기본적인 설명은 <a href="http://eed3si9n.com/learning-scalaz/Either.html">Learning Scalaz - Either</a> 에서 보실 수 있습니다.</p>

<p><br></p>

<p><code>EitherT</code> 를 위한 간단한 모델을 만들어 보겠습니다. </p>

<ul>
<li>쿼리를 파싱하고, 실행하는 과정에서 <em>상태</em> 인 <code>QueryState</code> 를 이용하고</li>
<li>쿼리 파싱에 실패하면 수행하지 않고 종료하기 위해 <code>scalaz.Either</code> 를 사용합니다 </li>
</ul>

<pre><code class="language-scala">// ref - https://speakerdeck.com/mpilquist/scalaz-state-monad

import scalaz._, Scalaz._

trait Model  
trait Query  
trait QueryResult

object QueryService {  
  def runQuery(s: String, model: Model): String \/ QueryResult = for {
    query &lt;- parseQuery(s)
    result &lt;- performQuery(query, model)
  } yield result

  def parseQuery(s: String): String \/ Query = "TODO".left
  def performQuery(q: Query, m: Model): String \/ QueryResult = "TODO".left
}
</code></pre>

<p>위 코드에 <em>State</em> 와 <code>EitherT</code> 를 추가하면 </p>

<pre><code class="language-scala">trait Model  
trait Query  
trait QueryResult  
trait Transaction 

object QueryService {  
  type TransactionState[A] = State[Transaction, A]
  type Transactional[A] = EitherT[TransactionState, String, A]

  def runQuery(s: String, model: Model): Transactional[QueryResult] = for {
    query &lt;- EitherT(parseQuery(s).point[TransactionState])
    result &lt;- EitherT(performQuery(query, model).point[TransactionState])
  } yield result

  def parseQuery(s: String): String \/ Query = ???
  def performQuery(q: Query, m: Model): String \/ QueryResult = ???
}
</code></pre>

<p>여기에 약간의 헬퍼 함수를 더하면,</p>

<pre><code class="language-scala">def runQuery(s: String, model: Model): Transactional[QueryResult] = for {  
  query &lt;- Transactional(parseQuery(s))
  result &lt;- Transactional(performQuery(query, model))
} yield result

object Transactional {  
  import QueryService._
  def apply[A](e: String \/ A): Transactional[A] = liftE(e)
  def liftE[A](e: String \/ A): Transactional[A] = 
    EitherT(e.point[TransactionState])
}
</code></pre>

<p>이제 <code>Transactional</code> 이 이름 그대로의 역할을 할 수 있게 간단한 커넥션도 모델링 해 보겠습니다.</p>

<pre><code class="language-scala">trait Transaction {  
  def closeConnection: Unit
  def commit: Unit = closeConnection
  def rollback: Unit = closeConnection
}

object QueryService {  
  type TransactionState[A] = State[Transaction, A]
  type EitherStringT[F[_], A] = EitherT[F, String, A]
  type Transactional[A] = EitherStringT[TransactionState, A]

  def parseQuery(s: String): String \/ Query =
    if (s.startsWith("SELECT")) s"Invalid Query: $s".left[Query]
    else (new Query {}).right[String]

  def performQuery(q: Query, m: Model): String \/ QueryResult =
    new QueryResult {}.right

  def runQuery(s: String, model: Model): Transactional[QueryResult] = for {
    query &lt;- Transactional(parseQuery(s))
    result &lt;- Transactional(performQuery(query, model))
    _ &lt;- (modify { t: Transaction =&gt; t.commit; t }).liftM[EitherStringT]
  } yield result
}
</code></pre>

<p>여기서 <code>EitherStringT</code> 타입을 새로 만든건, <code>liftM</code> 을 사용하기 위해서입니다. 만약 <code>liftM[EitherT]</code> 를 이용해 리프팅을 하면, 다음과 같은 예외가 발생합니다.</p>

<pre><code class="language-scala">Error:(37, 59) scalaz.EitherT takes three type parameters, expected: two  
    _ &lt;- (modify { t: Transaction =&gt; t.commit; t }).liftM[EitherT]
                                                          ^
</code></pre>

<p>이제 <code>parseQuery</code> 와 <code>performQuery</code> 실패시 <code>rollback</code> 을 호출하는것을 구현하고, <code>commit</code> 을 헬퍼 함수로 변경하겠습니다.</p>

<pre><code class="language-scala">def runQuery(s: String, model: Model): Transactional[QueryResult] = for {  
  query &lt;- Transactional(parseQuery(s))
  result &lt;- Transactional(performQuery(query, model))
  _ &lt;- commit
} yield result

def commit: Transactional[Unit] =  
  (modify { t: Transaction =&gt; t.commit; t }).liftM[EitherStringT]

object Transactional {  
  import QueryService._
  def apply[A](e: String \/ A): Transactional[A] = e match {
    case -\/(error) =&gt;
      /* logging error and... */
      liftTS(State[Transaction, String \/ A] { t =&gt; t.rollback; (t, e) })
    case \/-(a) =&gt; liftE(e)
  }

  def liftE[A](e: String \/ A): Transactional[A] =
    EitherT(e.point[TransactionState])

  def liftTS[A](tse: TransactionState[String \/ A]): Transactional[A] =
    EitherT(tse)
}
</code></pre>

<p>이제 다음처럼 실패시 롤백이 호출되고 <code>for</code> 자동으로 스탑되는것을 확인할 수 있습니다.</p>

<pre><code class="language-scala">val t = new Transaction {}  
val model = new Model {}  
val result1 = runQuery("qqq", model).run.eval(t)  
println(result)

// output
parseQuery  
rollback  
-\/(Invalid Query: qqq)

val result2 = runQuery("SELECT", model).run.eval(t)  
println(result2)

// output
parseQuery  
performQuery  
\/-(QueryService$$anon$2@36804139)
</code></pre>

<p>만약 <code>Transaction</code> 에 <code>committed</code>, <code>rollbacked</code> 등의 값을 추가하면 <code>eval</code> 대신 <code>exec</code> (<code>run</code> 도 가능) 으로 최종 상태인 <code>Transaction</code> 을 얻어 확인할 수 있습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/StateT.scala#L17

  /** An alias for `apply` */
  def run(initial: S1): F[(S2, A)] = apply(initial)

  /** Calls `run` using `Monoid[S].zero` as the initial state */
  def runZero[S &lt;: S1](implicit S: Monoid[S]): F[(S2, A)] =
    run(S.zero)

  /** Run, discard the final state, and return the final value in the context of `F` */
  def eval(initial: S1)(implicit F: Functor[F]): F[A] =
    F.map(apply(initial))(_._2)

  /** Calls `eval` using `Monoid[S].zero` as the initial state */
  def evalZero[S &lt;: S1](implicit F: Functor[F], S: Monoid[S]): F[A] =
    eval(S.zero)

  /** Run, discard the final value, and return the final state in the context of `F` */
  def exec(initial: S1)(implicit F: Functor[F]): F[S2] =
    F.map(apply(initial))(_._1)

  /** Calls `exec` using `Monoid[S].zero` as the initial state */
  def execZero[S &lt;: S1](implicit F: Functor[F], S: Monoid[S]): F[S2] =
    exec(S.zero)
</code></pre>

<h3 id="statet">StateT</h3>

<p><a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1 - State</a> 에서 언급했던 것 처럼</p>

<pre><code class="language-scala">type State[S, A] = StateT[Id, S, A]  
type Id[+X] = X

// 더 엄밀히는,

type StateT[F[_], S, A] = IndexedStateT[F, S, S, A]  
type IndexedState[-S1, S2, A] = IndexedStateT[Id, S1, S2, A]  
</code></pre>

<p><code>StateT</code> 에다가 혼합할 모나드 <code>F</code> 에 <code>Id</code> 를 준것이 <code>State</code> 입니다.</p>

<p>여기에 함수 <code>replicateM</code> 을 적용하면,</p>

<pre><code class="language-scala">// https://speakerdeck.com/mpilquist/scalaz-state-monad
  "replicateM(10)" in {

    // def replicateM(n: Int): F[List[A]]
    val getAndIncrement: State[Int, Int] = State { s =&gt; (s + 1, s) }
    getAndIncrement.replicateM(10).run(0) shouldBe (10, (0 until 10).toList)
  }
</code></pre>

<p>따라서 <code>State</code> 를 <code>F[_]</code> 라 보면 이걸 <code>F[List[_]]</code> 로 만들어 주므로 여러개의 <code>flatMap</code> 이 중첩된 형태가 됩니다.</p>

<p>따라서 <code>replicateM(100000)</code> 등의 코드는 <em>Stackoverflow</em> 가 발생합니다.</p>

<p>이 문제를 해결하기 위해 <code>Trampoline</code> 을 이용할 수 있습니다.</p>

<blockquote>
  <p>Scalaz provides the <code>Free</code> data type, which when used with Function0, trade heap for stack</p>
</blockquote>

<p>이럴때 <code>Trampoline</code> 을 사용하면, <em>stackoverflow</em> 를 피할 수 있습니다. (그만큼의 힙을 사용해서)</p>

<pre><code class="language-scala">// type Trampoline[+A] = Free[Function0, A]

"replicateM(1000)" in {

  import scalaz.Free._

  val getAndIncrement: State[Int, Int] = State { s =&gt; (s + 1, s) }
  getAndIncrement.lift[Trampoline].replicateM(1000).run(0).run shouldBe (1000, (0 until 1000).toList)
}
</code></pre>

<p><code>Trampoline</code> 은 후에 <code>Free</code> 를 살펴보면서 다시 보겠습니다.</p>

<h3 id="references">References</h3>

<ul>
<li><a href="http://tonymorris.github.io/blog/posts/monads-do-not-compose">Tony Morris - Monad Do Not Compose</a></li>
<li><a href="https://softwarecorner.wordpress.com/2013/12/06/scalaz-optiont-monad-transformer/">Scalaz OptionT Monad Transformer</a></li>
<li><a href="https://speakerdeck.com/mpilquist/scalaz-state-monad">State Monad in Scalaz</a></li>
<li><a href="https://github.com/earldouglas/scala-scratchpad/tree/master/category-theory/monad-transformers">scala-scratchpad: Monad Transformer in Scala</a></li>
<li><a href="http://tpolecat.github.io/assets/scalaz.svg">Scalaz Typeclass Hierarchy</a></li>
<li><a href="http://stackoverflow.com/questions/26602611/how-to-understand-traverse-traverseu-and-traversem">Stackoverflow - traverseU, traverseM</a></li>
<li><a href="http://cs.lth.se/edan40">Haskell Image</a></li>
<li><a href="https://wiki.haskell.org/All_About_Monads#The_IO_monad">Haskell Wiki - All About Monads</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Easy Scalaz 1, State]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<h3 id="state">State</h3>

<p><code>State</code> 를 설명하는 수많은 문구들이 있지만, 타입만큼 간단한건 없습니다.</p>

<pre><code class="language-scala">State[S, A] :: S =&gt; (S, A)  
</code></pre>

<blockquote>
  <p>A state transition, representing a <strong>function</strong> </p>
</blockquote>

<p>즉 <code>S</code> 를 받아 <code>(S, A)</code> 를 돌려주는 함수를, 타입클래스 <code>State[S, A]</code> 로 표현합니다. </p>

<p>더 엄밀히는, (<em>scalaz</em>  구현에서는) <code>type State[S, A] = StateT[Id, S, A]</code></p>]]></description><link>http://1ambda.github.io/easy-scalaz-1-state/</link><guid isPermaLink="false">f9bd7b24-522b-412b-8c4f-cd741c93bc28</guid><category><![CDATA[scala]]></category><category><![CDATA[state monad]]></category><category><![CDATA[scalaz]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 12 Oct 2015 14:14:00 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<h3 id="state">State</h3>

<p><code>State</code> 를 설명하는 수많은 문구들이 있지만, 타입만큼 간단한건 없습니다.</p>

<pre><code class="language-scala">State[S, A] :: S =&gt; (S, A)  
</code></pre>

<blockquote>
  <p>A state transition, representing a <strong>function</strong> </p>
</blockquote>

<p>즉 <code>S</code> 를 받아 <code>(S, A)</code> 를 돌려주는 함수를, 타입클래스 <code>State[S, A]</code> 로 표현합니다. </p>

<p>더 엄밀히는, (<em>scalaz</em>  구현에서는) <code>type State[S, A] = StateT[Id, S, A] where Id[+X] = X</code> 인데 이것은 나중에 <code>StateT</code> 에서 다시 보겠습니다.</p>

<p>우선 기억해둘 것은 <code>State</code> 가 <strong>함수</strong> 를 나타낸다는 사실입니다. 상태 <code>S</code> 를 변경하면서 <code>A</code> 를 만들어내는 함수를 말이지요. 즉, <code>State</code> 는 더도 말고 덜도 말고, 상태를 조작하는 <strong>함수</strong> 입니다. 여기에 모나드라고 하니, <code>flatMap</code> 같은 몇몇 함수가 추가된 것 뿐이지요.</p>

<h3 id="statebasics">State Basics</h3>

<p><code>State</code> 코드를 들춰보면, 아래와 같이 생겼습니다. </p>

<pre><code class="language-scala">object State extends StateFunctions {  
  def apply[S, A](f: S =&gt; (S, A)): State[S, A] = new StateT[Id, S, A] {
    def apply(s: S) = f(s)
  }
}

trait StateFunctions extends IndexedStateFunctions {  
  def constantState[S, A](a: A, s: =&gt; S): State[S, A] = State((_: S) =&gt; (s, a))
  def state[S, A](a: A): State[S, A] = State((_ : S, a))
  def init[S]: State[S, S] = State(s =&gt; (s, s))
  def get[S]: State[S, S] = init
  def gets[S, T](f: S =&gt; T): State[S, T] = State(s =&gt; (s, f(s)))
  def put[S](s: S): State[S, Unit] = State(_ =&gt; (s, ()))
  def modify[S](f: S =&gt; S): State[S, Unit] = State(s =&gt; {
    val r = f(s);
    (r, ())
  })
}
</code></pre>

<ul>
<li><code>State.apply</code> 에 상태 <code>S</code> 를 조작하는 함수 <code>f</code> 를 먹이면 <code>StateT</code> 가 나오고</li>
<li><code>StateT.apply</code> 에 초기 상태 <code>S</code> 를 먹이면 최종 결과물인 <code>(S, A)</code> 가 나옵니다</li>
</ul>

<p>그리고 코드를 조금 만 더 따라가다 보면 <code>apply</code> 의 <em>alias</em> 로 <code>run</code> 이라는 함수가 제공되는걸 알 수 있습니다. <a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/StateT.scala#L10">(Scalaz StateT.scala #L10)</a></p>

<p><code>flatMap</code> 으로 상태 조작함수 <code>f</code> 여러개를 엮다가 하다가 마지막에 <code>run</code> 으로 실행시킬것 같다는 느낌이 들죠? </p>

<p><br></p>

<p>이제 <code>StateFunctions</code> <em>trait</em> 로 제공되는 함수를 사용해 볼까요? 그냥 써보면 재미 없으니, Github 에서 각 Repository 마다 존재하는 <em>star</em> 를 가져오는 것을 간단히 모델링 해보겠습니다. 매번 네트워크 요청을 통해 가져오면 느리니까, <code>Map[String, Int]</code> 타입의 캐시도 포함시켜서요.</p>

<pre><code class="language-scala">import scalaz._, Scalaz._ /* import all */

type Cache = Map[String, Int]

"create, run State" in {
  val s: State[Cache, Int] = State { c =&gt; (c, c.getOrElse("1ambda/scala", 0))}
  val c: Cache = Map("1ambda/scala" -&gt; 1)

  // def run(s: S): (S, A)
  val (c1, star1) = s.run(c)
  val (c2, star2) = s.run(Map.empty)

  (c1, star1) shouldBe (Map("1ambda/scala" -&gt; 1), 1)
  (c2, star2) shouldBe (Map(), 0)
}
</code></pre>

<p>이 작은 코드에서 우리가 다루는 상태는 <code>Cache</code> 입니다. 아직은 <code>State { c =&gt; ... }</code> 에서 받은 <code>c: Cache</code> 를 수정하지 않기 때문에 <code>run</code> 에서 돌려주는 상태 (<em>State</em>) 는 <code>run</code> 에 넘긴 것과 동일합니다. 그런고로 <code>c == c1 == c2</code> 입니다. </p>

<p>이번엔 상태를 변경하는 함수를 만들어 보겠습니다. 캐시에서 데이터를 가져오면, 캐시를 그대로 돌려주고 미스가 발생하면 캐시에 레포지토리 URL 을 추가하겠습니다.</p>

<pre><code class="language-scala">def getStargazer(url: String): State[Cache, Int] = State { c =&gt;  
  c.get(url) match {
    case Some(count) =&gt; (c, count)
    case None        =&gt; (c.updated(url, 0), 0)
  }
}

"getStargazer" in {
  val c: Cache = Map("1ambda/scala" -&gt; 1)

  val s1 = getStargazer("1ambda/haskell")
  val (c1, star) = s1.run(c)

  (c1, star) shouldBe (c.updated("1ambda/haskell", 0), 0)
}
</code></pre>

<p><code>State</code> 는 모나드기 때문에, <code>for</code> 내에서 이용할 수 있습니다. 아래에서 더 자세히 살펴보겠습니다.</p>

<h3 id="statemonadapplicativeandfunctor">State Monad, Applicative and Functor</h3>

<p>모나드는 <code>return</code> 과 <code>bind</code> 를 가지고 특정한 규칙을 만족하는 타입 클래스를 말하는데요, <em>scala</em> 에서는 <code>bind</code> 는 <code>flatMap</code> 이란 이름으로 제공되는 것 아시죠? </p>

<pre><code class="language-scala">trait Monad[A] {  
  // sometimes called `unit`
  def return(a: A): M[A]
  def flatMap[B](f: A =&gt; M[B]): M[B]
}
</code></pre>

<p><em>scalaz</em> 에선 <code>Monad</code> 는 아래의 두 타입클래스를 상속받아 구현됩니다. </p>

<ul>
<li><code>Applicative.point</code> (= <code>return</code>)</li>
<li><code>Bind.bind</code> (= <code>bind</code>) </li>
</ul>

<pre><code class="language-scala">trait Bind[F[_]] extends Apply[F] { self =&gt;  
  ...
  def bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]
  ...
}

trait Applicative[F[_]] extends Apply[F] { self =&gt;  
  ...
  def point[A](a: =&gt; A): F[A]
  ...
}
</code></pre>

<p>게다가 <code>Apply</code> 가 <code>Functor</code> 를 상속받으므로 </p>

<pre><code class="language-scala">trait Apply[F[_]] extends Functor[F] { self =&gt;  
  def ap[A,B](fa: =&gt; F[A])(f: =&gt; F[A =&gt; B]): F[B]
  ...
</code></pre>

<p><em>scalaz</em> 에서 <code>State</code> 는 <code>Functor</code> 이면서, <code>Applicative</code> 이고, <code>Monad</code> 입니다.</p>

<p>아래는 <a href="https://github.com/tpolecat/doobie">doobie</a> 를 만든 <a href="https://github.com/tpolecat">@tpolecat</a> 의 블로그에서 가져온 <em>scalaz</em> 타입 클래스 계층인데, 이 그림을 보면 왜 그런지 알 수 있습니다. (<a href="http://tpolecat.github.io/assets/scalaz.svg">http://tpolecat.github.io/assets/scalaz.svg</a>)</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/scalaz.png" alt=""></p>

<p>이제 <code>State</code> 가 모나드라는 사실을 알았으니, 위에서 작성했던 <code>getStargazer</code> 함수를 다시 작성해보겠습니다. <em>for comprehension</em> 을 사용할건데요, </p>

<ul>
<li>먼저 <code>State[Cache, Int]</code> 의 상태인 <code>Cache</code> 를 얻어와야 하므로 <code>get</code> 을 이용하고</li>
<li>상태를 변경해야 하므로 <code>modify</code> 를 호출하겠습니다. </li>
</ul>

<pre><code class="language-scala">// State helper functions defined in `StateFunctions` trait
def state[S, A](a: A): State[S, A] = State((_ : S, a))  
def init[S]: State[S, S] = State(s =&gt; (s, s)) /* 상태 S 를 아웃풋 A 위치로 꺼냄 */  
def get[S]: State[S, S] = init  
def gets[S, T](f: S =&gt; T): State[S, T] = State(s =&gt; (s, f(s)))  
def put[S](s: S): State[S, Unit] = State(_ =&gt; (s, ()))  
def modify[S](f: S =&gt; S): State[S, Unit] = State(s =&gt; {  
  /* 상태 S 를 변경하는 함수를 받아, 적용하고 A 위치에 `()` 를 돌려줌 */
  val r = f(s);
  (r, ())
})

def getStargazer(url: String): State[Cache, Int] = State { c =&gt;  
  c.get(url) match {
    case Some(count) =&gt; (c, count)
    case None        =&gt; (c.updated(url, 0), 0)
  }
}

def getStargazerWithFor(url: String): State[Cache, Int] =  
  for {
    c &lt;- State.get[Cache]
    optCount = c.get(url)
    _ &lt;- modify { c: Cache =&gt;
      // same as `if (optCount.isDefined) c else c.updated(url, 0)`
      optCount match {
        case Some(count) =&gt; c
        case None        =&gt; c.updated(url, 0)
      }
    }
  } yield optCount.getOrElse(0)
</code></pre>

<h3 id="whentousestate">When to use State</h3>

<p>그러면, 언제 <code>State</code> 가 필요할까요? 하나의 <strong>상태</strong> (<em>State</em>) 를 지속적으로 변경, 공유하면서 연산을 실행할 때 사용할 수 있습니다.</p>

<blockquote>
  <p>Building computations from sequences of operations that require a shared state.</p>
</blockquote>

<p>예를 들어 HTTP 요청과 응답, 트랜잭션 등을 <code>State</code> 로 다루면서 연산을 조합해서 사용할 수 있습니다.</p>

<ul>
<li>HttpRequest, HttpResponse, HttpSession</li>
<li>Database Transaction</li>
<li>Random Number Generator</li>
</ul>

<h3 id="githubserviceexample">Github Service Example</h3>

<p>그러면 위에서 보았던 <code>Cache</code> 에 약간의 기능을 추가해 볼까요? 캐시 히트, 미스도 저장하고 캐시 히트는 최대 5분까지만 인정하기로 하지요. 오래된 캐시를 삭제하는 기능을 빼고 만들어 보면,</p>

<pre><code class="language-scala">type URL = String  
type StarCount = Int

case class Timestamped(count: StarCount, time: DateTime)

case class Cache(hits: Int, misses: Int, map: Map[URL, Timestamped]) {  
  def get(url: URL): Option[Timestamped] = map.get(url)
  def update(url: URL, timestamp: Timestamped): Cache = {
    val m = map + (url -&gt; timestamp)
    this.copy(map = m)
  }
}

object Cache {  
  def empty = Cache(0, 0, Map())
}
</code></pre>

<p>만약 <code>State</code> 가 없다면, 우리가 다루는 상태인 <code>Cache</code> 를 명시적으로 넘겨주고, 리턴받기 위해 이렇게 코드를 작성해야 할테지요. 여기서 <code>c1</code> 대신 <code>c</code> 를 쓰는 오타라도 발생한다면..</p>

<pre><code class="language-scala">def stargazerCount(url: URL, c: Cache): (Cache, StarCount) = {  
  val (c1, optCount) = checkCache(url, c)

  optCount match {
    case Some(count) =&gt; (c1, count)
    case None =&gt; retrieve(url, c1)
  }
}

def checkCache(url: URL, c: Cache): (Cache, Option[StarCount]) =  
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&gt;
      (c.copy(misses = c.misses + 1), None)
  }

def retrieve(url: URL, c: Cache): (Cache, StarCount) = {  
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def stale(then: DateTime): Boolean = DateTime.now &gt; then + 5.minutes  
def getStarCountFromWebService(url: URL): StarCount = ...  
</code></pre>

<p><br></p>

<p>여기에 <code>State</code> 를 하나씩 적용해 보겠습니다.</p>

<pre><code class="language-scala">def stargazerCount(url: URL, c: Cache): (Cache, StarCount) = {  
  val (c1, optCount) = checkCache(url, c)

  optCount match {
    case Some(count) =&gt; (c1, count)
    case None =&gt; retrieve(url, c1)
  }
}
</code></pre>

<p>먼저 <code>State</code> 타입을 적용하고, 그 후에 <code>for</code> 문을 적용한 뒤에, <code>State.state</code> 를 이용해서 조금 더 깔끔하게 바꾸면</p>

<pre><code class="language-scala">// applying State 
def stargazerCount(url: URL): State[Cache, StarCount] =  
  checkCache(url) flatMap { optCount =&gt;
    optCount match {
      case Some(count) =&gt; State { c =&gt; (c, count) }
      case None        =&gt; retrieve(url)
    }
  }

// use for-comprehension
def stargazerCount2(url: URL): State[Cache, StarCount] = for {  
  optCount &lt;- checkCache(url)
  count &lt;- optCount match {
    case Some(count) =&gt; State[Cache, StarCount] { c =&gt; (c, count) }
    case None        =&gt; retrieve(url)
  }
} yield count

// State.state
def stargazerCount(url: URL): State[Cache, StarCount] = for {  
  optCount &lt;- checkCache(url)
  count &lt;- optCount
    .map(State.state[Cache, StarCount])
    .getOrElse(retrieve(url))
} yield count
</code></pre>

<p><code>checkCache</code> 함수에도 적용해 보겠습니다.</p>

<pre><code class="language-scala">def checkCacheOrigin(url: URL, c: Cache): (Cache, Option[StarCount]) =  
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&gt;
      (c.copy(misses = c.misses + 1), None)
  }

def checkCache1(url: URL): State[Cache, Option[StarCount]] = State { c =&gt;  
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&gt;
      (c.copy(misses = c.misses + 1), None)
  }
}

/**
 *  Has potential bug.
 *  Always use `State.gets` and `State.modify`.
 */
def checkCache2(url: URL): State[Cache, Option[StarCount]] = for {  
  c &lt;- State.get[Cache]
  optCount &lt;- State.state {
    c.get(url) collect { case Timestamped(count, time) if !stale(time) =&gt; count }
  }
  _ &lt;- State.put(optCount ? c.copy(hits = c.hits + 1) | c.copy(misses = c.misses + 1))
} yield optCount

def checkCache(url: URL): State[Cache, Option[StarCount]] = for {  
  optCount &lt;- State.gets { c: Cache =&gt;
    c.get(url) collect { case Timestamped(count, time) if !stale(time) =&gt; count }
  }
  _ &lt;- State.modify { c: Cache =&gt;
    optCount ? c.copy(hits = c.hits + 1) | c.copy(misses = c.misses + 1)
  }
} yield optCount
</code></pre>

<p><code>checkCache2</code> 는 <code>State.get</code> <code>State.put</code> 때문에 버그가 발생할 수 있습니다. <code>get</code> 으로 꺼낸 뒤에 <code>put</code> 으로 넣으면, 이전에 어떤 상태가 있었든지, 덮어 씌우기 때문에 주의가 필요합니다. 일반적으로는 <code>put</code> 대신 <code>modify</code> 를 이용합니다.</p>

<pre><code class="language-scala">def init[S]: State[S, S] = State(s =&gt; (s, s))  
def get[S]: State[S, S] = init  
def put[S](s: S): State[S, Unit] = State(_ =&gt; (s, ()))

def gets[S, T](f: S =&gt; T): State[S, T] = State(s =&gt; (s, f(s)))  
def modify[S](f: S =&gt; S): State[S, Unit] = State(s =&gt; {  
</code></pre>

<p>마지막으로 <code>retrieve</code> 함수도 수정해볼까요</p>

<pre><code class="language-scala">def retrieveOrigin(url: URL, c: Cache): (Cache, StarCount) = {  
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def retrieve1(url: URL): State[Cache, StarCount] = State { c =&gt;  
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def retrieve(url: URL): State[Cache, StarCount] = for {  
  count &lt;- State.state { getStarCountFromWebService(url) }
  timestamp = Timestamped(count, DateTime.now)
  _ &lt;- State.modify[Cache] { _.update(url, timestamp) }
} yield count
</code></pre>

<h3 id="references">References</h3>

<ul>
<li><a href="https://speakerdeck.com/mpilquist/scalaz-state-monad">State Monad in Scalaz</a></li>
<li><a href="http://tpolecat.github.io/assets/scalaz.svg">Scalaz Typeclass Hierarchy</a></li>
<li><a href="http://cs.lth.se/edan40">Haskell Image</a></li>
<li><a href="https://github.com/fpinscala/fpinscala/wiki/Chapter-11:-Monads">fpinscala - Monad</a></li>
<li><a href="https://wiki.haskell.org/All_About_Monads#The_IO_monad">Haskell Monad</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Reactive Message Patterns w/ Actor Model, Chapter 1]]></title><description><![CDATA[<p><img src="http://berb.github.io/diploma-thesis/original/resources/actors.svg" alt=""></p>

<h2 id="whyenterprisesoftwaredevelopmentishard">Why Enterprise Software Development Is Hard</h2>

<p>엔터프라이즈 소프트웨어를 구현할 때 마주치는 문제점은, 고려해야할 것이 너무나 많다는 점입니다.</p>

<ul>
<li>Physical Tiers</li>
<li>Application Servers</li>
<li>Software layers</li>
<li>Frameworks and Patterns</li>
<li>Toolkits</li>
<li>Databases</li>
<li>Messaging Systems</li>
<li>Third-Party Applications</li>
<li>...</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/reactive-message-patterns/complexity_stack.png" alt=""></p>

<p>이런 요소들로 구성된 <strong>complexity stack</strong> 의 내부를 잘 살펴보면, 결국 관심사는 <strong>command</strong> 에 의해 생성된 <strong>domain event</strong> 를</p>]]></description><link>http://1ambda.github.io/reactive-message-patterns-w-actor-model-chapter-1/</link><guid isPermaLink="false">5c6d3ec5-2b23-462a-94da-f5df4ae0bdda</guid><category><![CDATA[scala]]></category><category><![CDATA[actor]]></category><category><![CDATA[akka]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 20 Sep 2015 16:33:22 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://berb.github.io/diploma-thesis/original/resources/actors.svg" alt=""></p>

<h2 id="whyenterprisesoftwaredevelopmentishard">Why Enterprise Software Development Is Hard</h2>

<p>엔터프라이즈 소프트웨어를 구현할 때 마주치는 문제점은, 고려해야할 것이 너무나 많다는 점입니다.</p>

<ul>
<li>Physical Tiers</li>
<li>Application Servers</li>
<li>Software layers</li>
<li>Frameworks and Patterns</li>
<li>Toolkits</li>
<li>Databases</li>
<li>Messaging Systems</li>
<li>Third-Party Applications</li>
<li>...</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/reactive-message-patterns/complexity_stack.png" alt=""></p>

<p>이런 요소들로 구성된 <strong>complexity stack</strong> 의 내부를 잘 살펴보면, 결국 관심사는 <strong>command</strong> 에 의해 생성된 <strong>domain event</strong> 를 저장하는 일임을 알 수 있습니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/reactive-message-patterns/simplicity_stack.png" alt=""></p>

<p><em>Actor Model</em> 은 여기에서 출발합니다. 불필요한 컴포넌트를 제외하고, <strong>command</strong> 와 <strong>event</strong> 에만 집중할 수 있도록 추상화를 제공합니다.</p>

<ul>
<li>What incoming messages (commands and/or events) do I accept?</li>
<li>What outgoing messages (commands and/or events) do I emit?</li>
<li>How can my state be mutated in reaction to incoming messages?</li>
<li>What is my supervision strategy for supervised actors?</li>
</ul>

<p><br></p>

<h2 id="originofactors">Origin Of Actors</h2>

<p>Actor Model 은 최근에 새롭게 만들어진 개념이 아니라, 1973년(<em>Dr. Carl Hewitt</em>) 부터 있었던 개념입니다. 다만 당시에는 컴퓨팅 파워가 부족했기 때문에 활용되지 않았을 뿐입니다. Actor Model 이 처음 만들어졌을 당시에는 CPU 클럭은 1MHz 남짓이었고 멀티코어 프로세서는 존재하지도 않았습니다. </p>

<p><br></p>

<h2 id="understandingactors">Understanding Actors</h2>

<p><em>Actor</em> 는 하나의 컴퓨팅 객체로서 메시지를 받아 다음의 일들을 수행할 수 있습니다.</p>

<ul>
<li>Send a finite number of messages to other actors</li>
<li>Create a finite number of new actors</li>
<li>Designate the behavior to be used for the next messages it receives</li>
</ul>

<p>Actor System 에서는 모든것이 Actor 입니다. 따라서 <code>Int</code>, <code>String</code> 처럼 일종의 <em>primitive type</em> 으로 생각하면 더 이해가 쉽습니다.</p>

<p>Actor System 과 Actor 는 다음의 특성을 가지고 있습니다. </p>

<ul>
<li>Communication via direct asynchronous message</li>
<li>State machines (FSM)</li>
<li>Share nothing</li>
<li>Lock-Free Concurrency</li>
<li>Parallelism</li>
</ul>

<p><strong>Akka</strong> 에서 추가적으로 제공하는 특성들은 다음과 같습니다.</p>

<ul>
<li>Location Transparency</li>
<li>Supervision</li>
<li>Future / Promises</li>
</ul>

<p><br></p>

<h2 id="concurrencyandparallelism">Concurrency and Parallelism</h2>

<blockquote>
  <p>Concurrency describes multiple computation occurring simultaneously. Parallelism is concurrency but applied to achieving a single goal. Parallelism is achieved by dividing a single complex process into smaller tasks and executing them concurrently. </p>
</blockquote>

<p><a href="https://en.wikipedia.org/wiki/Amdahl%27s_law?oldformat=true">Amdahl’s law</a> 에 의하면 <strong>병렬화해서 얻을 수 있는 최대 성능은, 병렬화 할 수 없는 부분에 의해서 제한됩니다.</strong> </p>

<p>따라서 시스템을 얼마나 병렬화 할 수 있도록 디자인하는가가 성능에 영향을 주게 됩니다. 이는 일반적으로 어려운 일이지만, Actor System 을 이용하면 atomic 연산 unit 인 Actor 를 기반으로 디자인할 수 있으므로 부가적인 계층(Tier) 보다는 로직(이 메시지를 받았을 때 어떤 일을 해야하는가)에 더 집중하게 되어 쉬운 일이 됩니다. </p>

<p>Akka 프로젝트 설명에서도 볼 수 있듯이, 분산 병렬 시스템을 만드는 것은 어려운 일이지만 대부분의 경우는 잘못된 추상(Abstaction), 도구(Tool) 을 이용하기 때문입니다. Actor Model 은 프로그래머가 더 쉬운 방법으로 분산 병렬 시스템을 디자인할 수 있도록 돕습니다.</p>

<blockquote>
  <p>We believe that writing correct concurrent &amp; distributed, resilient and elastic applications is too hard. Most of the time it's because we are using the wrong tools and the wrong level of abstraction.</p>
  
  <p>Akka is here to change that.</p>
  
  <p>Using the Actor Model we raise the abstraction level and provide a better platform to build correct concurrent and scalable applications. </p>
</blockquote>

<p><br></p>

<h2 id="nondeterminism">Non-determinism</h2>

<p>Actor Model 이 비결정적이라는 비판들이 있습니다. 그러나 실제로 내부를 잘 살펴보면 Actor 그 자체는 <em>deterministic atomic unit</em> 입니다. 따라서 시스템을 Reactive 하게 구성하는 과정에서 프로그래머가 다루어야 하는 <em>non-determinism</em> 을 Actor Model 을 이용하면 더 간단하게 다룰 수 있습니다.</p>

<p><br></p>

<h2 id="references">References</h2>

<ul>
<li>Title Image - <a href="http://berb.github.io/">http://berb.github.io/</a></li>
<li>Book - <a href="http://www.amazon.com/Reactive-Messaging-Patterns-Actor-Model/dp/0133846830/ref=sr_1_2?ie=UTF8&amp;qid=1442747296&amp;sr=8-2&amp;keywords=akka+in+action">Reactive Message Patterns with the Actor Model</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Angular, Providers]]></title><description><![CDATA[<p><img src="https://ga-core.s3.amazonaws.com/production/uploads/program/default_image/1444/Angularjs-Bootcamp-LONDON.jpg" alt=""></p>

<p>자그마한 프로젝트를 엇그제 시작했습니다. 오늘 해야 할 일은 Linkedin, Github API 를 붙이는 일인데, 그 전에 Angular 를 좀 보고 넘어가겠습니다. 아래는 <a href="https://github.com/DaftMonk/generator-angular-fullstack">angular-fullstack</a> 으로 만들면 생성되는 템플릿 코드인데, 어디서 부터 시작해야할지 감이 안잡히네요!</p>

<pre><code class="javascript">angular.module('app', [  
  'ngCookies',
  'ngResource',
  'ngSanitize',
  'ui.router',
  'ui.bootstrap'
])
  .config(function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider) {
    $urlRouterProvider</code></pre>]]></description><link>http://1ambda.github.io/angular-providers/</link><guid isPermaLink="false">fac918aa-4bc5-464c-ba73-2d2fad7e6a9d</guid><category><![CDATA[Angular]]></category><category><![CDATA[Trend Factory]]></category><category><![CDATA[factory]]></category><category><![CDATA[service]]></category><category><![CDATA[provider]]></category><category><![CDATA[injector]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 14 Mar 2015 16:42:33 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://ga-core.s3.amazonaws.com/production/uploads/program/default_image/1444/Angularjs-Bootcamp-LONDON.jpg" alt=""></p>

<p>자그마한 프로젝트를 엇그제 시작했습니다. 오늘 해야 할 일은 Linkedin, Github API 를 붙이는 일인데, 그 전에 Angular 를 좀 보고 넘어가겠습니다. 아래는 <a href="https://github.com/DaftMonk/generator-angular-fullstack">angular-fullstack</a> 으로 만들면 생성되는 템플릿 코드인데, 어디서 부터 시작해야할지 감이 안잡히네요!</p>

<pre><code class="javascript">angular.module('app', [  
  'ngCookies',
  'ngResource',
  'ngSanitize',
  'ui.router',
  'ui.bootstrap'
])
  .config(function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider) {
    $urlRouterProvider
      .otherwise('/');

    $locationProvider.html5Mode(true);
    $httpProvider.interceptors.push('authInterceptor');
  })

  .factory('authInterceptor', function ($rootScope, $q, $cookieStore, $location) {
    return {
      // Add authorization token to headers
      request: function (config) {
        config.headers = config.headers || {};
        if ($cookieStore.get('token')) {
          config.headers.Authorization = 'Bearer ' + $cookieStore.get('token');
        }
        return config;
      },

      // Intercept 401s and redirect you to login
      responseError: function(response) {
        if(response.status === 401) {
          $location.path('/login');
          // remove any stale tokens
          $cookieStore.remove('token');
          return $q.reject(response);
        }
        else {
          return $q.reject(response);
        }
      }
    };
  })

  .run(function ($rootScope, $location, Auth) {
    // Redirect to login if route requires auth and you're not logged in
    $rootScope.$on('$stateChangeStart', function (event, next) {
      Auth.isLoggedInAsync(function(loggedIn) {
        if (next.authenticate &amp;&amp; !loggedIn) {
          $location.path('/login');
        }
      });
    });
  });
</code></pre>

<h3 id="configrun">config, run</h3>

<p>원문은 <a href="https://docs.angularjs.org/guide/module#module-loading-dependencies">Angular Document: Module Loading &amp; Dependencies</a></p>

<p><em>configuration</em> 과 <em>run block</em> 은 <em>bootstrap</em> 과정에서 실행되는데</p>

<ul>
<li><em>configuration block</em> 에서는 <strong>provider</strong>, <strong>constant</strong> 만 <em>injected</em> 될 수 있고</li>
<li><em>run block</em> 은 <em>injector</em> 가 생성되고, 어플리케이션을 구동하기 위해 사용된 후에 실행됩니다. <strong>instance</strong> 와 <strong>constant</strong> 만 <em>injected</em> 될 수 있습니다.</li>
</ul>

<pre><code class="javascript">angular.module('myModule', []).

  config(function(injectable) { // provider-injector
    // you can only inject Providers (not instances)
    // into config block
  }).

  run(function(injectable) {    // instance-injector
    // you can only inject instances (not Providers)
    // into run blocks
  });
</code></pre>

<p>아래는 동일한 코드를 다른 메소드를 이용해 작성한 애플리케이션 초기화 코드입니다.</p>

<pre><code class="javascript">angular.module('myModule', []).  
  value('a', 123).
  factory('a', function() { return 123; }).
  directive('directiveName', ...).
  filter('filterName', ...);

// is same as

angular.module('myModule', []).  
  config(function($provide, $compileProvider, $filterProvider) {
    $provide.value('a', 123);
    $provide.factory('a', function() { retrun 123; });
    $compileProvider.directive('directiveName', ...);
    $filterProvider.register('filterName', ...);
  });  
</code></pre>

<p>배운것보다 모르는게 더 많이 생겼습니다. <code>Provider</code>, <code>$provide</code>, <em>injectable</em>  이 뭘까요?</p>

<p><br></p>

<h3 id="providers">Providers</h3>

<p>원문은 <a href="https://docs.angularjs.org/guide/providers">Angular Document: Providers</a></p>

<p><em>angular app</em> 에서 쓰이는 오브젝트들은 <a href="https://docs.angularjs.org/api/auto/service/$injector"><em>intector service</em></a> 에 의해서 인스턴스화(<em>instantiated</em>) 됩니다. <em>injector</em> 는 두 타입의 오브젝트를 만드는데, </p>

<p>(1) <strong>Services:</strong> are objects whose API is defined by the developer writing the service <br>
(2) <strong>Specialized objects:</strong> conform to a specific angular framework API. These objects are one of controllers, directives, filters or animations</p>

<p><em>injector</em> 가 이러한 서비스를 만들기 위해서는 <em>recipe</em> 를 알려줘야 하는데, 크게 5가지 <em>recipe</em> 가 있습니다. </p>

<p>가장 유명한건 <strong>Provider</strong> 입니다. 그 외에 <em>Provider</em> 를 이용해 만든 <strong>Value</strong>, <strong>Factory</strong>, <strong>Service</strong>, <strong>Constant</strong> 가 있습니다. </p>

<p><em>angular module</em> 은 하나 이상의 <em>Provider</em> 를 포함할 수 있습니다. 애플리케이션이 시작될때 <em>Angular</em> 는 <em>injector</em> 의 새로운 인스턴스를 만들고, <code>ng</code> 모듈, 애플리케이션 모듈, 그리고 그 <em>dependencies</em> 에 있는 모든 <em>recipe</em> 를 하나의 레지스트리에 등록합니다. 그리고 이후에 필요할때마다 <em>injector</em> 는 이 레지스트리에 새로운 인스턴스를 만들어야 할지, 아니면 존재하는 것을 사용할지 질의합니다.</p>

<p><em>Value recipe</em> 를 이용한 간단한 <a href="https://docs.angularjs.org/guide/providers#value-recipe">예제</a> 를 보겠습니다.</p>

<pre><code class="javascript">var myApp = angular.module('myApp', []).  
              value('clientId', 'a12345654321x');

myApp.controller('myController', ['clientId',  
                                  function(clientId) {
  this.clientId = clientId;
}]);                              
</code></pre>

<p><code>myApp</code> 모듈에 정의되어 있는 <code>clientId</code> <em>Value recipe</em> 를 등록하고 컨트롤러에서 사용했습니다.</p>

<p><br></p>

<h3 id="factory">Factory</h3>

<pre><code class="javascript">myApp.factory('apiToken', ['clientId', function apiTokenFactory(clientId) {

  var encrypt = function(data1, data2) {
  // encryption algorithm:
    return (data + ':' + data2).toUpperCase();
  };

  var secret = window.localStorage.getItem('myApp.secret');
  var apiToken = encrypt(clientId, secret);

  return apiToken;
}]);
</code></pre>

<p><em>Factory recipe</em> 를 이용해서 <code>apiToken</code> 서비스를 정의했습니다. 이 서비스는 <em>Value recipe</em> 를 이용해 만든 <code>clientId</code> 서비스에 의존합니다.</p>

<p><br></p>

<h3 id="service">Service</h3>

<p><code>apiToken</code> 서비스를 이용하는 다른 서비스를 <em>Service recipe</em> 를 이용해서 만들어 볼텐데, 동시에 <em>Service recipe</em> 가 어떤 역할을 하는지 비교하기 위해 <em>Factory recipe</em> 로도 만들어 보겠습니다.</p>

<pre><code class="javascript">function UnicornLauncher(apiToken) {

  this.launchedCount = 0;
  this.launch = function() {
    // Make a request to the remote API and include the apiToken
    ...
    this.launchedCount++;
  }
}

myApp.factory('unicornLauncher', ["apiToken", function(apiToken) {  
  return new UnicornLauncher(apiToken);
}]);

// is same as
myApp.service('unicornLauncher', ["apiToken", UnicornLauncher]);  
</code></pre>

<p><em>Factory recipe</em> 로도 만들 수 있지만, 일반적으로 <em>Service recipe</em> 는 <code>new</code> 와 함께 호출되는 서비스를 정의하기 위해 사용합니다. <a href="http://stackoverflow.com/questions/14324451/angular-service-vs-angular-factory">Stackoverflow: Factory vs Service</a> 에서도 그 답변을 찾을 수 있습니다.</p>

<p>예를 들어서 위에서 우리가 정의한 <code>unicornLauncher</code> 서비스는, <code>UnicornLauncher</code> 생성자를 <code>new</code> 로 호출됩니다.</p>

<p><br></p>

<p>아래는 대략적인 두 함수의 구성입니다.</p>

<pre><code class="javascript">function factory(name, factoryFn) {  
    return provider(name, { $get: factoryFn }); 
}

function service(name, constructor) {  
    return factory(name, ['$injector', function($injector) {
      return $injector.instantiate(constructor);
    }]);
}
</code></pre>

<p><code>$injector</code> 는 <em>provider</em> 에 의해 정의된 인스턴스를 <em>angular app</em> 내에서 조회하고, 생성할 수 있습니다. 이외에도 메소드를 호출하거나, 모듈을 로드할 수 있습니다.</p>

<p><br></p>

<h3 id="provider">Provider</h3>

<p><em>Provider recipe</em> 는 <em>Service</em> 나 <em>Factory</em> 등 다른 <em>recipe</em> 를 구성하는 코어 컴포넌트입니다. 문법적으로는 <code>$get</code> 을 구현한 커스텀 타입입니다. 이 <code>$get</code> 메소드는 <em>Factory recipe</em> 에서 사용했던 것과 같은 <em>factory function</em> 입니다. </p>

<p>다시 말해서, <em>Factory recipe</em> 만들때 하는 일은 <em>empty Provider</em> 에 <code>$get</code> 을 이용해 정의된 <em>factory function</em> 을 가져오는 일입니다.</p>

<p><em>Provider recipe</em>  는 반드시 애플리케이션이 시작 되기 전에 생성되야 하는 <em>application-wide configuration</em> 을 위한 <em>API</em> 를 정의할때만 사용해야 합니다.</p>

<pre><code class="javascript">myApp.provider('unicornLauncher', funtion UnicornLauncherProvider() {  
  var useTinfoilShielding = false;

  this.useTinfoilShielding = function(vaue) {
    useTinfoilShielding = !!value;
  };

  this.$get = ["apiToken", function unicornLauncherFactory(apiToken) {
    return new UnicornLauncher(apiToken, useTinfoilShielding);
  }];
});

myApp.config(["unicornLauncherProvider", function(unicornLauncherProvider) {  
  unicornLauncherProvider.useTinfoilShielding(true);
}]);
</code></pre>

<p>처음에 <em>configuration block</em> <code>config</code> 를 언급하면서 <strong>provider</strong>, <strong>constant</strong> 만 <em>injected</em> 될 수 있다고 말했었는데, 이런 이유에서입니다.</p>

<p><em>regular instance injector</em> 와는 달리 <em>provider injector</em> 에 의해 실행되는 이런 <em>injection</em> 을 통해 모든 <em>provider</em> 가 인스턴스화 (<em>instantiated</em>) 됩니다.</p>

<p><em>angular</em> 애플리케이션이 부트스트랩되는 동안, <em>provider</em> 가 구성되고, 생성되는 동안에는 <em>service</em> 에 접근할 수 없습니다. 이는 <em>service</em> 가 아직 생성되지 않았기 때문입니다.</p>

<p><em>configuration phase</em> 가 지난 후에야 <em>services</em> 가 생성되고, 이 단계를 <em>run phase</em> 라 부릅니다. 이 때문에 <em>run block</em> 에서 <strong>instance</strong> 와 <strong>constant</strong> 만 <em>injected</em> 될 수 있다고 위에서 언급한 것입니다.</p>

<p><br></p>

<h3 id="specialpurposeobjects">Special Purpose Objects</h3>

<p>앞서 <em>Angular</em> 에서 쓰이는 모든 오브젝트는 <em>intector service</em> <code>$injector</code>  에 의해서 초기화 된다고 했었습니다. 일반적인 서비스 오브젝트와, 특별한 목적을 가진 오브젝트들이 있다고 언급하기도 했지요.</p>

<p>이런 특별한 오브젝트들은 프레임워크를 확장하는 플러그인으로서 <em>Angular</em> 에서 정의한 <em>interface</em> 를 구현해야 하는데, 이 인터페이스는 <code>Controller</code>, <code>Directive</code>, <code>Filter</code>, <code>Animation</code> 입니다. </p>

<p><code>Controller</code> 오브젝트를 제외하고는 이러한 <em>special object</em> 를 생성하기 위해 <em>injector</em> 는 <em>Factory recipe</em> 를 이용합니다. 따라서 인자로 넣어준 팩토리 함수가 디렉티브를 만들기 위해 호출됩니다.</p>

<pre><code class="javascript">myApp.directive('myPlanet', ['planetName', function myPlanetDirectiveFactory(planetName) {  
  // directive definition object
  return {
    restrict: 'E',
    scope: {},
    link: function($scope, $element) { $element.text('Planet: ' + planetName); }
  }
}]);
</code></pre>

<p><br></p>

<h3 id="controller">Controller</h3>

<pre><code class="javascript">myApp.controller('DemoController', ['clientId', function DemoController(clientId) {  
  this.clientId = clientId;
}]);
</code></pre>

<p><code>Controller</code> 는 조금 다르게, <em>Factory recipe</em> 를 이용하지 않습니다. 인자로 정의한 <em>constructor function</em> 함수가 <strong>모듈과 함께 등록</strong>됩니다. </p>

<p>애플리케이션이 <code>DemoController</code> 가 필요할때마다 매번 <em>constructor</em> 를 통해서 인스턴스화(<em>instantiated</em>) 합니다. 일반적인 <em>service</em> 와는 다르게, <strong>컨트롤러는 싱글턴이 아닙니다</strong>. </p>

<p>지금까지 배운 내용을 정리하면</p>

<ul>
<li>The injector uses recipes to create two type of objects: <strong>services</strong> and <strong>special purpose objects</strong></li>
<li>There are five recipe types that define how to create objects: <strong>Value</strong>, <strong>Factory</strong>, <strong>Service</strong>, <strong>Provide</strong>, and <strong>Constant</strong></li>
<li>Factory and Service are the most commonly used recipes. The only differences between them is that the <em>Service recipe</em> works better <strong>for objects of a custom type</strong>, while the <em>Factory</em> can produce <strong>primitives and functions</strong></li>
<li>The <em>Provider recipe</em> is the core recipe type and all the other ones are just syntactic sugar on it</li>
<li><em>Provider</em> is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration</li>
<li>All special purpose objects except for the <strong>Controller</strong> are defined via <em>Factory recipes</em></li>
</ul>

<p><br></p>

<h3 id="dependencyinjection">Dependency Injection</h3>

<p><img src="https://docs.angularjs.org/img/guide/concepts-module-injector.png" alt=""></p>

<p><em>service</em> 는 <code>$injector</code> 에 의해서 싱글턴 인스턴스가 만들어지고, <code>$injector.get()</code> 을 통해 얻을 수 있습니다. 만약 캐시된 인스턴스가 있다면 가져오고 없으면 새로 만듭니다. 아래는 외부에서 <code>injector</code> 를 통해 내부 서비스를 접근하는 방법입니다.</p>

<pre><code class="javascript">var injector = angular.injector(['myModule', 'ng']);  
var greeter = injector.get('greeter');  
</code></pre>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) [http://galleryhip.com/angular-js-icon.html) <br>
(2) <a href="https://docs.angularjs.org/guide/providers#value-recipe">Angular Document</a> <br>
(3) <a href="http://www.webdeveasy.com/javascript-promises-and-angularjs-q-service/">Webdeveasy: AngularJS Q</a> <br>
(4) <a href="http://www.webdeveasy.com/interceptors-in-angularjs-and-useful-examples/">Webdeveasy: AngularJS Interceptor</a>  </p>]]></content:encoded></item><item><title><![CDATA[Coding The Matrix 3]]></title><description><![CDATA[<p><img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/column_row_space.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_as_vector.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_impl.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/null_space_of_matrix.jpg" alt=""></p>

<p>Null space of a matrix is a vector space</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/vector_space.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions_proof.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/use_standard_generator.jpg" alt=""></p>

<p><em>standard geneartor</em> 를 이용해서 <code>f(x) = M * x</code> 에서의 <code>M</code> 의 컬럼을 알아낼 수 있다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_function_def.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_def_2.jpg" alt=""></p>

<p>어떤 함수 <code>f</code> 가 <code>M * x</code> 형태로 정의되면, <code>f</code> 는 <em>linear function</em> 이다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/def_kernel.jpg" alt=""></p>

<p>어떤 함수 <code>f</code> 의 <em>kernel</em> 은 <em>image</em> 를 <code>0</code> 으로 하는 집합이다. 다시</p>]]></description><link>http://1ambda.github.io/coding-the-matrix-3/</link><guid isPermaLink="false">715b3e8b-1821-4204-98cf-48f2a029e11b</guid><category><![CDATA[coursera]]></category><category><![CDATA[linear algebra]]></category><category><![CDATA[matrix]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 14 Mar 2015 16:41:34 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/column_row_space.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_as_vector.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_impl.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/null_space_of_matrix.jpg" alt=""></p>

<p>Null space of a matrix is a vector space</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/vector_space.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions_proof.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/use_standard_generator.jpg" alt=""></p>

<p><em>standard geneartor</em> 를 이용해서 <code>f(x) = M * x</code> 에서의 <code>M</code> 의 컬럼을 알아낼 수 있다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_function_def.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_def_2.jpg" alt=""></p>

<p>어떤 함수 <code>f</code> 가 <code>M * x</code> 형태로 정의되면, <code>f</code> 는 <em>linear function</em> 이다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/def_kernel.jpg" alt=""></p>

<p>어떤 함수 <code>f</code> 의 <em>kernel</em> 은 <em>image</em> 를 <code>0</code> 으로 하는 집합이다. 다시 말해서 <code>f(x) = M * x</code> 에 대해 <em>null matrix</em> <code>x</code> 이 <em>kernel</em></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/kernel_one_to_one1.jpg" alt=""></p>

<p><em>linear function</em> <code>f</code> is <strong>one-to-one</strong> iff its kernel is a <em>trivial vector space</em></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/kernel_one_to_one2.jpg" alt=""></p>

<p>위에 나온 속성은 상당히 중요하다. 왜냐하면 <em>trivial kernel</em> 이면, 다시 말해서 <em>null matrix</em> 가 <em>trivial</em> 이면, <code>f</code> 의 <em>image</em> <code>b</code> 는 아무리 많아봐야 하나이기 때문이다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/def_onto.jpg" alt=""></p>

<p><em>image</em> 가 <em>entire co-domain</em> 과 같으면 <strong>onto</strong> 다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/inner_product.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/outer_product.jpg" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/function_composition.jpg" alt=""></p>

<p>두 <em>matrix-vector function</em> 의 <em>composition</em> 은 위처럼 쉽게 증명 가능하다. <code>AB * x</code> 로</p>

<p>이걸 이용하면 <em>matrix-matrix multiplication</em> 의 <em>associativity</em> 도 쉽게 증명 가능하다. <code>(AB)C = A(BC)</code></p>

<p><br></p>

<h3 id="invertible">Invertible</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible2.jpg" alt=""></p>

<p>두 함수가 <em>inverse</em> 관계면 두 매트릭스도 <em>inverse</em> 관계다. 그리고 한 매트릭스의 <em>inverse matrix</em> 가 존재하면 <em>invertible</em> 또는 <em>singular</em> 라 부르며, 아무리 많아봐야 하나의 <em>inverse</em> 만 가진다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way2.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way3.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way4.jpg" alt=""></p>

<p><em>invertible matrix</em> 가 중요한 이유는, <em>invertible matrix</em> 가 존재하면 <code>f</code> 도 <em>invertible</em> 이고, 그 말은 <code>f</code> 가 <strong>one-to-one, onto</strong> 라는 소리다. 따라서 <code>f(u) = b</code> 에 대해 적어도 하나의 솔루션이 존재하고 (<em>onto</em>), 아무리 많아봐야 하나의 솔루션이 존재한다는 뜻이다 (<em>one-to-one</em>)</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_product_matrix1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_product_matrix2.jpg" alt=""></p>

<p>함수처럼 매트릭스도 <code>A</code>, <code>B</code> 가 <em>invertible</em> 일때만 <code>AB</code> 도 그러하다. </p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/identity_invertible1.jpg" alt=""></p>

<p><code>AB</code> 에 대해 <code>A</code>, <code>B</code> 가 서로의 <em>inverse</em> 면 <code>AB</code> 는 <em>identity matrix</em> 지만 그 역은 성립하지 않는다.</p>

<p>위 그림의 <code>A</code> 에서 볼 수 있듯이 <em>null space</em> 가 <em>trivial</em> 하지 않기 때문에 <em>one to one</em> 이 아니어서 <code>A</code> 는 <em>invertible</em> 이 아니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/identity_invertible2.jpg" alt=""></p>

<p><code>AB</code>, <code>BA</code> 가 모두 <em>identity matrix</em> 여야 <code>A</code>, <code>B</code> 가 서로 <em>inverse</em> 다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/identity_invertible3.jpg" alt=""></p>

<p>매트릭스 <code>M</code> 이 <em>one-to-one</em> 인지는 <em>trivial kernel</em> 인지를 판별하면 된다. <code>f(x) = M * x</code> 는 <em>linear function</em> 이기 때문에 <em>trivial kernel</em> 이면 <code>M</code> 도 <em>one-to-one</em> 이다.</p>

<p><em>onto</em> 인지는 어떻게 알 수 있을까?</p>

<p><br></p>

<h3 id="summary">Summary</h3>

<p>지금 까지의 내용을 정리하면</p>

<ol>
<li><code>u1</code> 이 <code>a * x = b</code> 의 솔루션일때, <code>V</code> 를 <code>a * x = 0</code> 의 솔루션 셋이라 하면, <code>u1 + V</code> 는 <code>a * x = b</code> 의 솔루션 셋이다. 다시 말해서 <code>V</code> 는 <em>null matrix</em>  </li>
<li><code>f(x)</code> 가 <code>M * x</code> 형태로 나타낼 수 있으면 <em>linear function</em> 이다.  </li>
<li><em>trivial kernel</em> 이면 <em>linear function</em> <code>f</code> 는 <em>one-to-one</em> 이고, <em>linear function</em> <code>f</code> 가 <em>one-to-one</em> 이면 <em>trivial kernel</em> 을 가진다.  </li>
</ol>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://colorsark.deviantart.com/art/3D-Cube-342632998">Title image</a> <br>
(2) <strong>Coding the Matrix</strong> by <em>Philip Klein</em>  </p>]]></content:encoded></item><item><title><![CDATA[Cloud Computing, Paxos]]></title><description><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>대부분의 분산 서버 벤더들은 <code>99.99999%</code> 의 <em>reliability</em> 를 보장하지만, <code>100%</code>는 아닙니다. 왜그럴까요? 그들이 못해서가 아니라 <em>consensus</em> 문제 때문입니다.</p>

<blockquote>
  <p>The fault lies in the impossibility of consensus</p>
</blockquote>

<p><em>Consensus</em> 문제가 중요한 이유는, 많은 분산 시스템이 <em>consensus</em> 문제이기 때문입니다. </p>

<ul>
<li>Perfect Failure Detection</li>
<li>Leader Election</li>
<li>Agreement (harder than consensus)</li>
</ul>

<p><br></p>

<p>일반적으로 서버가 많으면</p>]]></description><link>http://1ambda.github.io/cloud-computing-paxos/</link><guid isPermaLink="false">fa427789-33eb-4728-913a-ab4b1cfbf14e</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[paxos]]></category><category><![CDATA[consensus]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 07 Mar 2015 19:44:32 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>대부분의 분산 서버 벤더들은 <code>99.99999%</code> 의 <em>reliability</em> 를 보장하지만, <code>100%</code>는 아닙니다. 왜그럴까요? 그들이 못해서가 아니라 <em>consensus</em> 문제 때문입니다.</p>

<blockquote>
  <p>The fault lies in the impossibility of consensus</p>
</blockquote>

<p><em>Consensus</em> 문제가 중요한 이유는, 많은 분산 시스템이 <em>consensus</em> 문제이기 때문입니다. </p>

<ul>
<li>Perfect Failure Detection</li>
<li>Leader Election</li>
<li>Agreement (harder than consensus)</li>
</ul>

<p><br></p>

<p>일반적으로 서버가 많으면 다음의 일들을 해야합니다.</p>

<ul>
<li><strong>Reliable Multicast:</strong> Make sure that all of them receive the same updates in the same order as each other</li>
<li><strong>Membership/Failure Detection:</strong> To keep their own local lists where they know about each other, and when anyone leaves or fails, everyone is updated simultaneously</li>
<li><strong>Leader Election:</strong> Elect a leader among them, and let everyone in the group know about it</li>
<li><strong>Mutual Exclusion:</strong> To ensure mutually exclusive access to a critical resource like a file</li>
</ul>

<p>이 문제들은 대부분 <em>consensus</em> 와 연관되어 있습니다. 더 직접적으로 연관되어 있는 문제들은</p>

<ul>
<li>The ordering of messages</li>
<li>The up/down status of a suspected failed process</li>
<li>Who the leader is</li>
<li>Who has access to the critical resource</li>
</ul>

<p><br></p>

<h3 id="consensusproblem">Consensus Problem</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_problem.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_problem2.png" alt=""></p>

<p>모든 프로세스(노드, 서버)가 같은 <em>value</em> 를 만들도록 해야 하는데, 몇 가지 제약조건이 있습니다.</p>

<ul>
<li><strong>validity:</strong> if everyone propose same value, then that's what's decided</li>
<li><strong>integrity:</strong> decided value must have been proposed by some process</li>
<li><strong>non-triviality:</strong> there is at least one initial system state that leads to each of the all-<code>0</code>'s or all-<code>1</code>'s outcomes</li>
</ul>

<p><em>non-triviality</em> 는 쉽게 말해서, 모두 <code>0</code> 이거나 모두 <code>1</code> 일 수 있는 상태가 있어야 한다는 뜻입니다. 왜냐하면 항상 <code>0</code> 이거나 <code>1</code> 만 나오면 <em>trivial</em> 하기 때문입니다. 별 의미가 없죠.</p>

<p><br></p>

<h3 id="models">Models</h3>

<p><em>consensus</em> 문제는 분산 시스템 모델에 따라 달라집니다. 모델은 크게 2가지로 나눌 수 있는데</p>

<p>(1) Synchronous Distributed System Model</p>

<ul>
<li>Each message is received within bounded time</li>
<li>Drift of each process' local clock has a known bound</li>
<li>Each step in a process takes <code>lb &lt; time &lt; ub</code></li>
</ul>

<p>동기 시스템 모델에서는 <em>consensus</em> 문제를 풀 수 있습니다.</p>

<p>(2) Asynchronous Distributed System Model</p>

<ul>
<li>Nobounds on process execution</li>
<li>The drift rate of a clock is arbitrary</li>
<li>No bounds on message transmission delay</li>
</ul>

<p>일반적으로 비동기 분산 시스템 모델이 더 일반적입니다, 그리고 더 어렵죠. 비동기를 위한 프로토콜은 동기 모델 위에서 작동할 수도 있으나, 그 역은 잘 성립하지 않습니다.</p>

<p>비동기 분산 시스템 모델에서는 <em>consensus</em> 문제는 풀 수 <strong>없습니다</strong></p>

<ul>
<li>Whatever protocol/algorithm you suggest, there is always a worst-case possible execution with failures and message delays that prevens the system from reaching consensus</li>
<li>Powerful result(see the <strong>FLP</strong> proof)</li>
<li>Subsequently, safe and <strong>probabilistic</strong> solution have become popular (e.g Paxos)</li>
</ul>

<p><br></p>

<h3 id="paxosinsyncronoussystems">Paxos in Syncronous Systems</h3>

<p>동기 시스템이라 가정합니다. 따라서</p>

<ul>
<li>bounds on message dealy</li>
<li>bounds on upper bound on clock drift rates</li>
<li>bounds on max time for each process step</li>
<li>processes can fail by stopping</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_in_sync_system.png" alt=""></p>

<ul>
<li>아무리 많아야 <code>f</code> 개의 프로세서에서 <em>crash</em> 가 나고</li>
<li>모든 프로세서는 <em>round</em> 단위로 동기화 되고, 동작하며</li>
<li><em>reliable communication</em> 을 통해 서로 통신합니다</li>
</ul>

<p><em>value_i^r</em> 을 <em>round</em> <code>r</code> 의 시작에 <code>P_i</code> 에게 알려진 <em>value</em> 의 집합이라 라 하겠습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos2.png" alt=""></p>

<p><code>f+1</code> 라운드 후에 모든 <em>correct</em> 프로세스는 같은 값의 집합을 가지게 되는데, 귀류법으로 쉽게 증명할 수 있습니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_in_async.png" alt=""></p>

<p>비동기 환경에서는, 아주아주아주아주아주 느린 프로세서와 <em>failed</em> 프로세서를 구분할 수 없기 때문에, 나머지 프로세서들이 이것을 결정하기 위해 영원히 기다려야 할지도 모릅니다. 이것이 기본적인 <em>FLP Proof</em> 의 아이디어입니다. 그렇다면, <em>consensus</em> 문제를 정말 풀기는 불가능한걸까요?</p>

<p>풀 수 있습니다. 널리 알려진 <em>consensus-solving</em> 알고리즘이 있습니다. 실제로는 불가능한 <em>consensus</em> 문제를 풀려는 것이 아니라, <em>safety</em> 와 <em>eventual liveness</em> 를 제공합니다. 야후의 <em>zookeeper</em> 나 구글의 <em>chubby</em> 등이 이 알고리즘을 이용합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/yes_we_can_with_paxos.png" alt=""></p>

<p><em>safety</em> 는 서로 다른 두개의 프로세서가 다른 값을 제출하지 않는것을 보장하고, (<em>No two non-faulty processes decide different values</em>) <em>eventual liveness</em> 는 운이 좋다면 언젠가는 합의에 도달한다는 것을 말합니다. 근데 실제로는 꽤 빨리 <em>consensus</em> 문제를 풀 수 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos_simple.png" alt=""></p>

<p>본래는 최적화때문에 더 복잡한데, 위 슬라이드에서는 간략화된 <em>paxos</em> 가 나와있습니다. <em>paxos</em> 의 <em>round</em> 마다 고유한 <em>ballot id</em> 가 할당되고, 각 <em>round</em> 는 크게 3개의 비동기적인 <em>phase</em> 로 분류할 수 있습니다.</p>

<ul>
<li><strong>election:</strong> a leader is elected</li>
<li><strong>bill:</strong> leader proposes a value, processes ack</li>
<li><strong>law:</strong> leader multicasts final value</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/election.png" alt=""></p>

<p>먼저 <em>potential leader</em> 가 <em>unique ballot id</em> 를 고르고, 다른 프로세서들에게 보냅니다. 다른 프로세스들의 반응에 의해서 선출될 수도 있고, 선출되지 않으면 새로운 라운드를 시작합니다. </p>

<ul>
<li>Because becoming a leader requires a majority of votes, and any two majorities intersect in at least one process, and each process can only vote once.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/bill.png" alt=""></p>

<p>리더가 다른 프로세스들에게 <code>v</code> 를 제안하고, 프로세스들은 지난 라운드에 <code>v'</code> 를 결정했었으면 <code>v=v'</code> 를 이용해 값을 결정합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/decision.png" alt=""></p>

<p>만약 리더가 <em>majority</em> 의 긍정적인 반응을 얻으면 모두에게 그 결정을 알리고 각 프로세서는 합의된 내용을 전달받고, 로그에 기록하게 됩니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos_no_return.png" alt=""></p>

<p>사실 이 과정은 응답을 리더가 받는 단계에서 결정되는 것이 아니라, 프로세서들이 <em>proposed value</em> 를 듣는순간 결정됩니다. 따라서 리더에서 <em>failure</em> 가 일어나도, 이전에 결정되었던 <code>v'</code> 을 이용할 수 있습니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos_safety.png" alt=""></p>

<p>이전에도 언급했듯이 <em>safety</em> 는 두개의 서로 다른 프로세서의 의해서 다른 값이 선택되지 않음을 보장합니다. 이는 잠재적 리더가 있다 하더라도 현재 리더와, 잠재적 리더에게 응답하는 <em>majority</em> (반수 이상) 을 교차하면 적어도 하나는 <code>v'</code> 를 응답하기 때문에 <em>bill phase</em> 에서 정의한대로 이전 결과인 <code>v'</code> 가 사용됩니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxsos_liveness.png" alt=""></p>

<p>그림에서 볼 수 있듯이 영원히 끝나지 않을수도 있지만, 실제로는 꽤 빠른시간 내에 합의에 도달합니다. (eventualy-live in async systems)</p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://ook.co/solutions/cloud-computing/">Title Image</a> <br>
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></content:encoded></item><item><title><![CDATA[Cloud Computing, Multicast]]></title><description><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p><em>multicast</em> 는 클라우드 시스템에서 많이 사용됩니다. <em>Cassandra</em> 같은 분산 스토리지에서는 <em>write/read</em> 메세지를 <em>replica gorup</em> 으로 보내기도 하고, <em>membership</em> 을 관리하기 위해서 사용하기도 합니다</p>

<p>그런데, 이 <em>multicast</em> 는 <em>ordering</em> 에 따라서 <em>correctness</em> 에 영향을 줄 수 있기 때문에 매우 중요합니다. 자주 쓰이는 기법으로 <em>FIFO</em>, <em>Casual</em>, <em>Total</em> 이 있는데 하나씩 살펴보겠습니다.</p>]]></description><link>http://1ambda.github.io/cloud-computing-multicast/</link><guid isPermaLink="false">1aa1fadb-da2f-4163-af61-a68ed5cef2ac</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[multicast]]></category><category><![CDATA[virtual synchrony]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 07 Mar 2015 17:20:18 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p><em>multicast</em> 는 클라우드 시스템에서 많이 사용됩니다. <em>Cassandra</em> 같은 분산 스토리지에서는 <em>write/read</em> 메세지를 <em>replica gorup</em> 으로 보내기도 하고, <em>membership</em> 을 관리하기 위해서 사용하기도 합니다</p>

<p>그런데, 이 <em>multicast</em> 는 <em>ordering</em> 에 따라서 <em>correctness</em> 에 영향을 줄 수 있기 때문에 매우 중요합니다. 자주 쓰이는 기법으로 <em>FIFO</em>, <em>Casual</em>, <em>Total</em> 이 있는데 하나씩 살펴보겠습니다.</p>

<p><br></p>

<h3 id="ordering">Ordering</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_FIFO.png" alt=""></p>

<p><em>FIFO</em> 를 이용한다면, 보낸 순서대로 도착하게 됩니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_casual.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_casual_example.png" alt=""></p>

<p><em>casual ordering</em> 에서는 반드시 <em>casuality-obeying order</em> 로 전달해야 합니다. 예를 들어 위 그림에서는 <code>M1:1 -&gt; M3:1</code> 이기 때문에 반드시 그 순서대로 받아야 합니다. <em>concurrent event</em> 는 어떤 순서로 받아도 상관 없습니다.</p>

<p><br></p>

<p><em>casual ordering</em> 이면 <em>FIFO ordering</em> 입니다. 왜냐하면 같은 프로세스에서 보낸 <em>casuality</em> 를 따르면 그게 바로 <em>FIFO</em> 이기 때문입니다. 역은 성립하지 않습니다.</p>

<p>일반적으로는 <em>casual ordering</em> 을 사용합니다. 서로 다른 친구로부터 댓글이 달렸는데, 늦게 달린 친구의 댓글이 먼저 보인다면 당연히 말이 되지 않습니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_total.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_total_example.png" alt=""></p>

<p><em>total ordering</em> 은 <em>atomic broadcast</em> 라 부르는데, 모든 프로세스가 같은 순서로 메시지를 받는것을 보장합니다.</p>

<ul>
<li>Since <em>FIFO/Casual</em> are orthogonal to <em>Total</em>, can have hybrid ordering protocol too (e.g <em>FIFO-total</em>, <em>Casual-total</em></li>
</ul>

<p><br></p>

<h3 id="fifoorderingimpl">FIFO Ordering Impl</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl2.png" alt=""></p>

<ul>
<li>각 프로세스는 <em>seq number</em> 로 구성된 벡터를 유지하고, </li>
<li>프로세스에서 메시지를 보낼때 마다 자신의 <em>seq number</em> 를 하나 증가 시켜서 보냅니다</li>
<li>메시지를 받았을때, <strong>자신의 벡터 내에 있는 값 + 1</strong> 일 경우에만 벡터 값을 +1 한뒤 전달하고, 아니면 +1 인 값이 올 때까지 버퍼에 넣고 기다립니다</li>
</ul>

<p>예제를 보면</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl_example.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl_example2.png" alt=""></p>

<p><br></p>

<h3 id="totalorderingimpl">Total Ordering Impl</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/total_impl1.png" alt=""></p>

<p><em>sequencer-based approach</em> 입니다. 먼저 하나의 프로세스가 <em>sequencer</em> 로 선출된 뒤, 어떤 프로세스가 메세지를 보낼때마다 그룹 뿐만 아니라 <em>sequencer</em> 에게 보내게 됩니다.</p>

<p>이 <em>sequencer</em> 는 글로벌 시퀀스 <code>S</code> 를 유지하면서, 메시지 <code>M</code> 을 받을때마다 <code>S++</code> 해서 <code>&lt;M, S&gt;</code> 로 멀티캐스트를 보냅니다.</p>

<p>각 프로세스에서는 <em>local</em> 에 글로벌 시퀀스 <code>Si</code> 를 유지합니다. 만약 프로세스가 메세지를 받는다면 <code>Si + 1 = S(M)</code> 값을 글로벌 시퀀서로부터 받을때까지 기다리고, 받은 후에야 <code>Si++</code> 하고 전달합니다.</p>

<p><br></p>

<h3 id="casualorderingimpl">Casual Ordering Impl</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl2.png" alt=""></p>

<p>자료구조 자체는 같으나, <em>casuality</em> 를 검사하기 위해 <em>sender</em> 가 <em>vector</em> 전체를 보냅니다. <em>receiver</em> 는 메세지를 받으면 다음 두 조건을 만족하기 전까지 버퍼에 넣습니다</p>

<ul>
<li><code>M[j]</code> = <code>P_i[j] + 1</code></li>
<li><code>M[k]</code> &lt;= <code>P_i[k]</code>, (<code>k != j</code>)</li>
</ul>

<p>두번째 조건을 해석하면, 자신의 벡터도 다음 프로세스에게 전달해야 하기 때문에 <code>M[k]</code> 이후의 벡터만 가지고 있어야 전달할 수 있다는 뜻입니다. (<code>M[j]</code> 는 제외)</p>

<p>이 두 조건이 만족되야만 <code>P_i[j] = M[j]</code> 로 세팅하고 <code>M</code> 을 전달합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl_example1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl_example2.png" alt=""></p>

<p><br></p>

<h3 id="reliablemulticast">Reliable Multicast</h3>

<p><em>reliable</em> 이란, 루즈하게 말하자면 모든 <em>receiver</em> 가 메세지를 받는다는 뜻입니다. <em>ordering</em> 과는 <em>orthogonal</em> 하기 때문에 <em>Reliable-FIFO</em>, 등등 구현이 가능합니다. 더 엄밀한 정의는</p>

<ul>
<li>need all <strong>correct</strong> (<em>non-faulty</em>) processes to receive the same set of multicasts as all other correct processes</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/reliable_multicast_impl1.png" alt=""></p>

<p>단순히 <em>reliable unicast</em> 를 여러개 보내는것 만으로는 부족합니다. 왜냐하면 <em>sender</em> 에서 <em>failure</em> 가 일어날 수 있기 때문입니다</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/reliable_multicast_impl2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/reliable_multicast_impl3.png" alt=""></p>

<p>비효율적이지만, <em>reliable</em> 합니다.</p>

<p><br></p>

<h3 id="virtualsynchrony">Virtual Synchrony</h3>

<p><em>virtual sinchrony</em> 혹은 <em>view synchrony</em> 라 불리는데, 이것은 <em>failure</em> 에도 불구하고 <em>multicast ordering</em> 과 <em>reliability</em> 를 얻기 위해 <em>membership protocol</em> 을 <em>multicast protocol</em> 과 같이 사용합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/view.png" alt=""></p>

<p>각 프로세스가 관리하는 <em>membership list</em> 를 <em>view</em> 라 부릅니다. <em>virtual synchrony</em> 프로토콜은 이런 <em>view change</em> 가 <em>correct process</em> 에 올바른 순서대로 전달됨을 보장합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/vsync_multicast.png" alt=""></p>

<p><em>Virtual Synchrony</em> 프로토콜은 다음을 보장합니다.</p>

<ul>
<li>the set of multicasts delivered in a given view is the same set at all correct processes that were in that view</li>
<li>the sender of the multicast message also belongs to that view</li>
<li>if a process <code>P_i</code> doesn't not deliver a multicast <code>M</code> in view <code>V</code> while other processes in the view <code>V</code> delivered <code>M</code> in <code>V</code>, then <code>P_i</code> will be <strong>forcibly removed</strong> from the next view delivered after <code>V</code> at the other processes</li>
</ul>

<p>다시 말해서, <em>multicast</em> 메세지는 같이 전달된 <em>view</em> 내에 있던 다른 프로세스에서 모두 동일합니다. 그리고 <em>view</em> <code>V</code> 내에 있는 어떤 프로세스가 <code>M</code> 을 전달하지 못할 경우, 다른 프로세스의 <em>next view</em> 에서 제거됩니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example3.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example4.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example5.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example6.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example7.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example8.png" alt=""></p>

<p><br></p>

<ul>
<li>Called <strong>"virtual synchrony"</strong> since in spite of running on an asynchronous network, it gives the appearance of a synchronous network underneath that obeys the same ordering at all processes</li>
</ul>

<p>그러나 <em>consensus</em> 를 구현하는데는 쓸 수 없습니다. <em>partitioning</em> 에 취약하기 때문입니다.</p>

<p>정리하자면 <em>multicast</em> 는 클라우드 시스템에서 중요한 요소입니다. 필요에 따라서 <em>ordering</em>, <em>reliability</em>, <em>virtual synchorny</em> 를 구현할 수 있습니다.</p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://ook.co/solutions/cloud-computing/">Title Image</a> <br>
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></content:encoded></item><item><title><![CDATA[Cloud Computing, Snapshots]]></title><description><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>이번시간에는 <em>Distributed Snapshot</em> 에 대해서 배웁니다. 클라우드 환경에서 각 어플리케이션(혹은 서비스) 는 여러개의 서버 위에서 돌아갑니다. 각 서버는 <em>concurrent events</em> 를 다루며, 서로 상호작용합니다. 이런 환경에서 <em>global snapshot</em> 을 캡쳐할 수 있다면</p>

<ul>
<li><strong>check pointing:</strong> can restart distributed application on failure</li>
<li><strong>garbage collection of objects:</strong> object at servers that don't</li></ul>]]></description><link>http://1ambda.github.io/cloud-computing-snapshot/</link><guid isPermaLink="false">7d51c274-e6e6-41dd-a37e-b548da6e711c</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[snapshot]]></category><category><![CDATA[Chandy-Lamport]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 07 Mar 2015 13:57:56 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>이번시간에는 <em>Distributed Snapshot</em> 에 대해서 배웁니다. 클라우드 환경에서 각 어플리케이션(혹은 서비스) 는 여러개의 서버 위에서 돌아갑니다. 각 서버는 <em>concurrent events</em> 를 다루며, 서로 상호작용합니다. 이런 환경에서 <em>global snapshot</em> 을 캡쳐할 수 있다면</p>

<ul>
<li><strong>check pointing:</strong> can restart distributed application on failure</li>
<li><strong>garbage collection of objects:</strong> object at servers that don't have any other objects(ay any servers) with pointers to them</li>
<li><strong>deadlock detection:</strong> useful in database transaction systems</li>
<li><strong>termination of computation:</strong> useful in batch computing systems like Folding@Homes, SETI@Home</li>
</ul>

<p><em>global snapshot</em> 은 두 가지를 포함합니다.</p>

<p>(1) Individual state of each process 
(2) Individual state of each communication channel </p>

<p><em>global snapshot</em> 을 만드는 한가지 방법은 모든 프로세스의 <em>clock</em> 을 동기화 하는 것입니다. 그래서 모든 프로세스에게 <em>time</em> <code>t</code> 에서의 자신의 상태를 기록하도록 요구할 수 있습니다. 그러나</p>

<ul>
<li>Time synchorization always has error</li>
<li>Doesn't not record the state of meesages in the channels</li>
</ul>

<p>지난 시간에 보았듯이, <em>synchronization</em> 이 아니라 <em>casuality</em> 로도 충분합니다. 프로세스가 <strong>명령을 실행하거나</strong>, <strong>메시지를 받거나</strong>, <strong>메시지를 보낼때마다</strong> <em>global system</em> 가 변합니다. 이를 저장하기 위해서 <em>casuality</em> 를 기록하는 방법을 알아보겠습니다.</p>

<p><br></p>

<h3 id="chandylamportalgorithm">Chandy-Lamport Algorithm</h3>

<p>시작 전에 <em>system model</em> 을 정의하면</p>

<ul>
<li>N Processes in the system</li>
<li>There are two uni-directional communication channels between each ordered process pair <code>P_j -&gt; P_i</code>, <code>P_i -&gt; P_j</code></li>
<li>communication channels are <strong>FIFO</strong> ordered</li>
<li><strong>No failure</strong></li>
<li>All messages arribe intact, and are not duplicated</li>
</ul>

<p><em>requirements</em> 는</p>

<ul>
<li><em>snapshot</em> 때문에 <em>application</em> 의 작업에 방해가 일어나서는 안됩니다</li>
<li>각 프로세스는 자신의 <em>state</em> 를 저장할 수 있어야 합니다</li>
<li><em>global state</em> 는 분산회되어 저장됩니다 (collected in a distributed manner)</li>
<li>어떤 프로세스든지, <em>snapshot</em> 작업을 시작할 수 있습니다</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport1.png" alt=""></p>

<ul>
<li>프로세스 <code>P_i</code> 가 <em>market</em> 메세지를 만들고, 자신을 제외한 다른 <code>N-1</code> 개의 프로세스에게 보냅니다</li>
<li>동시에 <code>P_i</code> 는 <em>incoming channel</em> 을 레코딩하기 시작합니다</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport2.png" alt=""></p>

<p>(1) 만약 <code>P_i</code> 가 <em>marker</em> 메시지를 처음 받는다면</p>

<ul>
<li>만약메시지를 받은 프로세스 <code>P_i</code> 에서는 자신의 <em>state</em> 를 기록하고</li>
<li>자신을 제외한 프로세스들에게 <em>marker</em> 보내고</li>
<li>는 <em>incoming channel</em> 을 레코딩하기 시작합니다</li>
</ul>

<p>(2) <code>P_i</code> 가 이미 <em>market</em> 메세지를 받은적이 있다면</p>

<ul>
<li>이미 해당 채널의 모든 메세지를 기록중이었으므로, 레코딩을 끝냅니다</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport3.png" alt=""></p>

<p>이 알고리즘은 모든 프로세스가 자신의 <em>state</em> 와 모든 <em>channel</em> 을 저장하면 종료됩니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example3.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example4.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example5.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example6.png" alt=""></p>

<p><br></p>

<h3 id="consistentcuts">Consistent Cuts</h3>

<p><em>Chandy-Lamport</em> 알고리즘은 <em>casuality</em> 를 보장합니다. 이에 대해 증명하기 전에 먼저, <em>consistent cut</em> 이란 개념을 보고 가겠습니다.</p>

<ul>
<li><p><strong>Cut:</strong> time frontier at each process and at each channel. Events at the process/channel that happen before the cut are <strong>in the cut</strong> and happening after the cut are <strong>out of the cut</strong></p></li>
<li><p><strong>Consistent Cut:</strong> a cut that obeys casuality. A cut <code>C</code> is a consistent cut iff for each pair of event <code>e</code> <code>f</code> in the system, such that event <code>e</code> is in the cur <code>C</code> and if <code>f -&gt; e</code></p></li>
</ul>

<p>다시 말해서 <code>e</code> 가 <code>C</code> 내에 있고, <code>f -&gt; e</code> 라면 <code>f</code> 도 <code>C</code> 에 있어야만 <em>consistent cut</em> 이란 뜻입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consistent_cut1.png" alt=""></p>

<p><code>F</code> 가 <em>cut</em> 내에 있지만, 올바르게 캡쳐되어 메시지 큐 내에서 전송중임을 <em>snapshot</em> 에서 보장합니다. 하지만 <code>G -&gt; D</code> 같은 경우는, <code>D</code> 가 <em>cut</em> 내에 있지만 <code>G</code> 가 그렇지 않아 <em>inconsistent cut</em> 입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consistent_cut2.png" alt=""></p>

<p><em>Chandy-Lamport Global Snapshot</em> 알고리즘은 항상 <em>consistent cut</em> 을 만듭니다. 왜 그런가 증명을 보면</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Proof1.png" alt=""></p>

<p><code>ei -&gt; ej</code> 를 보장한다는 말은 스냅샷 안에 두 이벤트가 있다는 뜻입니다. 따라서 <code>ej -&gt; &lt;P_j records its state&gt;</code> 일때 당연히 <code>ei -&gt; &lt;P_i records its state&gt;</code> 와 같은 말입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Proof2.png" alt=""></p>

<p>만약 <code>ej -&gt; &lt;P_j records its state&gt;</code> 일때 <code>&lt;P_i records its state&gt; -&gt; ei</code> 라 합시다.</p>

<p>그러면 <code>ei -&gt; ej</code> 로 가는 <em>regular app message</em> 경로를 생각해 봤을때, <code>P_i</code> 가 먼저 자신의 상태를 기록하기 시작했으므로 <em>marker</em> 메세지가 먼저 날라갈겁니다. (FIFO) 그러면 위에서 말한 <code>ei -&gt; ej</code> 경로를 타고 <em>marker</em> 메세지가 먼저 가게되고 <code>P_j</code> 는 자신의 상태를 먼저 기록하게 됩니다. 따라서 <code>P_j</code> 에서 <code>ej</code> 보다 자신의 상태를 기록하는 것이 먼저이므로 <code>ej</code> 는 <em>out of cut</em> 이고, 모순입니다.</p>

<p><br></p>

<h3 id="safetyandliveness">Safety and Liveness</h3>

<p>분산시스템의 <em>correctness</em> 와 관련해서 <em>safety</em> 와 <em>liveness</em> 란 개념이 있습니다. 이 둘은 주로 혼동되어 사용되는데, 둘을 구별하는 것은 매우 중요합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/liveness.png" alt=""></p>

<ul>
<li>distributed computation will terminate eventually </li>
<li>every failure is eventually deteced by some non-faulty process</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/safety.png" alt=""></p>

<ul>
<li>there is no deadlock in a distributed transaction system</li>
<li>no object is orphaned</li>
<li><strong>accuracy</strong> in failure detector</li>
<li>no two processes decide on different values</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/liveness_and_safety.png" alt=""></p>

<p><em>failure detector</em> 나 <em>concensus</em> 의 경우에서 볼 수 있듯이 <em>completeness</em> 와 <em>accuracy</em> 두 가지를 모두 충족하긴 힘듭니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/language_of_global_state.png" alt=""></p>

<p><em>global snapshot</em> 은 한 상태 <code>S</code> 이고, 여기서 다른 스냅샷으로의 이동은 <em>casual step</em> 을 따라 이동하는 것입니다. 따라서 <em>liveness</em> 와, <em>safety</em> 와 관련해 다음과 같은 특징이 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/using_global_snapshot.png" alt=""></p>

<p><em>Chandy-Lamport</em> 알고리즘은 <em>stable</em> 한지를 검사하기 위해 사용할 수도 있습니다. 여기서 <em>stable</em> 하다는 것은, 한번 참이면 그 이후에는 계속 참인 것을 말합니다. 이는 알고리즘이 <em>casual correctness</em> 를 가지기 때문입니다.</p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://ook.co/solutions/cloud-computing/">Title Image</a> <br>
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></content:encoded></item><item><title><![CDATA[Coding The Matrix 2, Vector Space]]></title><description><![CDATA[<p><img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""></p>

<h3 id="linearcombinations">Linear Combinations</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/linear_combinations.png" alt=""></p>

<p><code>b</code> 와 <code>v1, ..., vn</code> 이 주어졌을때 </p>

<ul>
<li><code>a1, ..., an</code> 을 찾을 수 있을까요? </li>
<li>있다면 <em>unique solution</em> 인지 어떻게 알 수 있을까요?</li>
</ul>

<p><br></p>

<h3 id="span">Span</h3>

<ul>
<li>The set of all linear combinations of some vectors <code>v1, ..., vn</code> is called <strong>span</strong> of these vector</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/span.png" alt=""></p>

<p>이브가 만약 위와 같은식을 만족한다는 사실을 알고 있다면, 패스워드의 모든</p>]]></description><link>http://1ambda.github.io/coding-the-matrix-2/</link><guid isPermaLink="false">5f630834-a38f-4833-a4a3-8d465a1c0b31</guid><category><![CDATA[coursera]]></category><category><![CDATA[linear algebra]]></category><category><![CDATA[vector space]]></category><category><![CDATA[span]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 04 Mar 2015 16:28:24 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""></p>

<h3 id="linearcombinations">Linear Combinations</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/linear_combinations.png" alt=""></p>

<p><code>b</code> 와 <code>v1, ..., vn</code> 이 주어졌을때 </p>

<ul>
<li><code>a1, ..., an</code> 을 찾을 수 있을까요? </li>
<li>있다면 <em>unique solution</em> 인지 어떻게 알 수 있을까요?</li>
</ul>

<p><br></p>

<h3 id="span">Span</h3>

<ul>
<li>The set of all linear combinations of some vectors <code>v1, ..., vn</code> is called <strong>span</strong> of these vector</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/span.png" alt=""></p>

<p>이브가 만약 위와 같은식을 만족한다는 사실을 알고 있다면, 패스워드의 모든 <em>span</em> <code>{a1, ..., an}</code> 에 대해서 적절한 <em>response</em> 를 추출할 수 있습니다. 증명은 위처럼 간단합니다.</p>

<p><br></p>

<p>Let <code>V</code> be a set of vectors if <code>v1, ..., vn</code> are vectors such that <code>V</code> = Span <code>{v1, ..., vn}</code> then</p>

<ul>
<li>we say <code>{v1, ..., vn}</code> is a generating set for <code>V</code></li>
<li>we refer to the vectors <code>v1, ..., vn</code> as generators for <code>V</code></li>
</ul>

<p><code>[x, y, z]</code> = <code>x[1,0,0] + y[0,1,0] + z[0,0,1]</code> 을 <code>R^3</code> 의 <em>standard generator</em> 라 부릅니다. </p>

<p><br></p>

<h3 id="geometryofsetsofvectors">Geometry of Sets of Vectors</h3>

<ul>
<li><em>Span of the empty set:</em> just the origin, <strong>Zero-dimensional</strong></li>
<li><em>Span</em> <code>{[1,2], [3,4]}</code>: all points in the plane, <strong>Two-dimensional</strong></li>
<li><em>Span</em> <code>{[1,0,1.65], [0,1,1]}</code> is a plain in three dimensions</li>
</ul>

<p><code>k</code> 벡터의 <em>span</em> 은 <em>k-dimensional</em> 일까요? 아닙니다.</p>

<ul>
<li>Span <code>{[0, 0]}</code> 은 <em>zero-dimensional</em> 입니다.</li>
<li>Span <code>{[1,3], [2,6]}</code> 은 <em>one-dimensional</em> 입니다. </li>
<li>Span <code>{[1,0,0], [0,1,0], [1,1,0]}</code> 은 <em>two-dimensional</em> 입니다.</li>
</ul>

<p>그러면 어떤 벡터 <code>v</code> 가 있을때 <em>dimensionality</em> 를 어떻게 알아낼 수 있을까요?</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/geometry_of_sets.png" alt=""></p>

<p>위 그림에서 볼 수 있듯이 <em>origin</em> 을 포함하는 <em>geometry object</em> 를 표현하는 방법은 두가지 입니다. 각각은 나름의 쓰임새가 있습니다.</p>

<p>(1) <em>span</em> of some vectors <br>
(2) 우변이 <code>0</code> 인 <em>linear equation system</em> 의 집합</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/two_representation1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/two_representation2.png" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/common_representation1.png" alt=""></p>

<p><em>field</em> 의 서브셋은 3가지 속성을 만족합니다. <em>field</em> 를 <code>R</code> 이라 하면</p>

<ul>
<li>subset contains the zero vector</li>
<li>if subset contains <code>v</code> then it contains <code>av</code> for every scala <code>a</code></li>
<li>if subset contains <code>u</code> and <code>v</code> then it contains <code>u+v</code></li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/common_representation2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/common_representation3.png" alt=""></p>

<p><code>F^D</code> 의 세가지 속성을 만족하는 <em>subset</em> 을 <strong>vector space</strong> 라 부릅니다. 그리고 <code>U</code> 가 <em>vector space</em> 고 <em>vector space</em> <code>V</code> 의 <em>subset</em> 일때, <code>U</code> 를 <code>V</code> 의 <em>subspace</em> 라 부릅니다.</p>

<p>뒤에서 배울테지만 모든 <code>R^D</code> 의 <em>subspace</em> 는 <em>span</em> <code>{v1, ..., vn}</code> 과 <code>{x: a1 * x = 0, ..., an * x = 0}</code> 의 형태로 쓸 수 있습니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/abstract_vector_space.png" alt=""></p>

<p>우리는 벡터에 대해 <em>sequence</em> 나, <em>function</em> 을 정의하지 않았습니다. 단순한 <em>operator</em> 와 공리를 만족하는지, 그리고 <em>property</em> <code>V1, V2, V3</code> 정도만 따졌습니다. 벡터에 대한 이런 추상적 접근은 많은 장점이 있습니다. 그러나 이 수업에서는 사용하지 않겠습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/convex_hull.png" alt=""></p>

<p><br></p>

<h3 id="vectorspace">Vector Space</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/exclude_origin_line.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/exclude_origin_plain.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_space.png" alt=""></p>

<p>벡터 <code>c</code> 와 벡터 스페이스 <code>V</code> 에 대해 <code>c + V</code> 와 같은 형태를 <em>affine space</em> 라 부릅니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination.png" alt=""></p>

<p><code>u1, u2, u3</code> 를 담고있는 <em>plain</em> 을 <code>u1 + V</code> 형태로 표현하고 싶습니다. 어떻게 해야할까요?</p>

<p><code>V</code> 를 <em>span</em> <code>{a, b}</code> 라 하고 <code>a = u2 - u1</code>, <code>b = u3 - u1</code> 라 하면 <code>u1 + V</code> 는 <em>plain</em> 의 변환이지만, 그 자체로서 <em>plain</em> 입니다</p>

<ul>
<li><em>span</em> <code>{a, b}</code> 는 <code>0</code> 을 포함하므로 <code>u1</code> + <em>span</em> <code>{a, b}</code> 는 <code>u1</code> 를</li>
<li><em>span</em> <code>{a, b}</code> 는 <code>u2 - u1</code> 도 을 포함하므로 <code>u1</code> + <em>span</em> <code>{a, b}</code> 는 <code>u2</code> 를</li>
<li><em>span</em> <code>{a, b}</code> 는 <code>u3 - u1</code> 도 을 포함하므로 <code>u1</code> + <em>span</em> <code>{a, b}</code> 는  <code>u3</code> 를 포함합니다.</li>
</ul>

<p>따라서 <code>u1</code> + <em>span</em> <code>{a, b}</code> 는 <code>u1, u2, u3</code> 를 모두 포함하는 평면입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination2.png" alt=""></p>

<p>더 간단히 <code>ru1 + au2 + bu3</code> (<code>r + a + b = 1</code>) 로 <em>affine combination</em> 을 표현할 수 있습니다. 그리고 더 <em>formal</em> 하게 정의하면,</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination3.png" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_equation.png" alt=""></p>

<p><em>affine space</em> 를 <em>a solution set of a system of linear equations</em> 으로 표현할 수 있습니다. 그런데, 역으로 이 솔루션이 <em>affine space</em> 일까요?</p>

<p>반례를 하나 들어보면 <code>1x = 1, 2x = 1</code> 일때 솔루션은 없습니다. 그러나 벡터 스페이스 <code>V</code> 는 <em>zero vector</em> 를 가져야 하므로 <em>affine space</em> <code>u + V</code> 는 적어도 하나의 <em>vector</em> 는 가져아합니다. 모순이 발생합니다.</p>

<ul>
<li><strong>Theorem:</strong> <em>solution set of a linear system</em> 은 <em>empty</em> 거나 <em>affine space</em> 입니다. 증명은 아래와 같습니다.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination_proof1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination_proof2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination_proof3.png" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/number_of_solutions.png" alt=""></p>

<p>지금까지 증명한 것은, <code>u1</code> 이 <em>linear system</em> 의 솔루션일때, <code>u1 + v</code> (<code>v</code> in <code>V</code>) 도 솔루션이란 사실입니다. 여기서 <code>V</code> 는 <em>homogeneous linear system</em> 입니다. (우변이 <code>0</code> 인)</p>

<p>따라서 </p>

<ul>
<li><em>unique solution</em> 을 가질때는 <code>V</code> 가 <code>0</code> 을 해로 가질 때이고</li>
<li><em>GF(2)</em> 의 솔루션 수는 <code>0</code> 이거나, <code>V</code> 와 같습니다.</li>
</ul>

<p><br></p>

<h3 id="checksumfunction">Checksum function</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/checksum1.png" alt=""></p>

<p><em>corrupted</em> 파일이 올바른 파일로 인식될 경우는 오리지널 바이너리 <code>p</code> 에 대해 손상된 파일 <code>p+e</code> 가 위 슬라이드의 방정식을 만족할 경우입니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/checksum2.png" alt=""></p>

<p>이 확률은 모든 가능한 <code>n</code> 벡터에 대해 존재하는 솔루션의 수 이므로 굉장히 낮습니다.</p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://colorsark.deviantart.com/art/3D-Cube-342632998">Title image</a> <br>
(2) <strong>Coding the Matrix</strong> by <em>Philip Klein</em>  </p>]]></content:encoded></item><item><title><![CDATA[Pattern Discovery 3]]></title><description><![CDATA[<p><img src="https://m1.behance.net/rendition/modules/7116731/disp/d18c13cd5b49bf40b41e6ef0610b26d3.png" alt=""></p>

<p>이번 시간에 배울 주제는 <em>Sequential Pattern Mining</em> 입니다.</p>

<ul>
<li>GSP (Generalized Sequential Patterns)</li>
<li>Vertical Format-Based Mining: <strong>SPADE</strong></li>
<li>Pattern-Growth Methods: <strong>PrefixSpan</strong></li>
<li>Mining Closed Sequential Patterns: <strong>CloSpan</strong>
Constrain-Based Sequential Pattern Mining</li>
</ul>

<p><em>sequential pattern mining</em> 은 다양한 곳에 사용됩니다.</p>

<ul>
<li>customer shopping sequences</li>
<li>medial treatments</li>
<li>web click streams, calling patterns</li>
<li>program execution sequences (software engineering)</li></ul>]]></description><link>http://1ambda.github.io/pattern-discovery-3/</link><guid isPermaLink="false">9d993973-15d9-4611-bb12-119343656a18</guid><category><![CDATA[coursera]]></category><category><![CDATA[pattern discovery]]></category><category><![CDATA[gSpan]]></category><category><![CDATA[closeGraph]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 03 Mar 2015 16:02:54 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://m1.behance.net/rendition/modules/7116731/disp/d18c13cd5b49bf40b41e6ef0610b26d3.png" alt=""></p>

<p>이번 시간에 배울 주제는 <em>Sequential Pattern Mining</em> 입니다.</p>

<ul>
<li>GSP (Generalized Sequential Patterns)</li>
<li>Vertical Format-Based Mining: <strong>SPADE</strong></li>
<li>Pattern-Growth Methods: <strong>PrefixSpan</strong></li>
<li>Mining Closed Sequential Patterns: <strong>CloSpan</strong>
Constrain-Based Sequential Pattern Mining</li>
</ul>

<p><em>sequential pattern mining</em> 은 다양한 곳에 사용됩니다.</p>

<ul>
<li>customer shopping sequences</li>
<li>medial treatments</li>
<li>web click streams, calling patterns</li>
<li>program execution sequences (software engineering)</li>
<li>biological sequences (DNA)</li>
</ul>

<p><em>time-series DB</em> 와는 다릅니다. 이건 일정 간격으로 로그가 저장된 것이고, <em>sequential pattern</em> 은 <em>time stamp</em> 가 붙은 것이라 보면 됩니다. 어찌 보면 [Process Mining][http://1ambda.github.io/process-mining-week1/] 이라 볼 수도 있겠습니다.</p>

<p><em>sequential pattern</em> 은 크게 <em>gapped</em> 와 <em>non-gapped</em> 로 나누어집니다. 전자는 패턴 사이의 <em>gap</em> 을 허용하고, 후자는 허용하지 않습니다. 모든 시퀀스가 중요하다는 뜻입니다. 예를 들어 웹사이트에서 <em>click stream</em> 사이의 <em>gap</em> 은 정말 중요할 수 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/sequential_pattern_mining.png" alt=""></p>

<p><em>sequential pattern mining</em> 은 주어진 시퀀스에서 빈번한 서브시퀀스의 집합을 찾아냅니다. <em>element</em> (<code>()</code>) 또는 <em>event</em> 라 부르는 단위가 <em>items</em> 를 담고 있습니다. 그리고 <code>()</code> 로 묶인 <em>item</em> 의 순서는 중요하지 않습니다.</p>

<p><br></p>

<h3 id="gsp">GSP</h3>

<p><em>GSP</em> 는 <em>apriori-based sequential pattern mining</em> 기법입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/GSP.png" alt=""></p>

<p><em>singleton</em> 시퀀스를 기반으로 <em>length 1, 2</em> 의 <em>candidates</em> 를 만들고, <em>apriori pruning</em> 을 적용합니다. 그러면, <code>36 + 15 = 51</code> 의 <em>candidates</em> 를 얻을 수 있습니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/GSP2.png" alt=""></p>

<p>데이터베이스를 지속적으로 스캔해가면서 <em>minimum support</em> 를 통과하지 못하는 것들을 제거하고 위 과정을 반복하는 것이 <em>GSP Mining</em> 입니다.</p>

<p><br></p>

<h3 id="spade">SPADE</h3>

<p><em>SPADE (Sequential Pattern Mining in Vertical Data)</em></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/SPADE.png" alt=""></p>

<p><em>SID</em> 뿐만 아니라 <em>element ID, EID</em> 를 이용해서 테이블을 좌측처럼 하나 만듭니다. 그리고 이 테이블을 이용해서 우측 상단 테이블처럼 <code>a</code>, <code>b</code> 등이 어느 <em>SID, EID</em> 셋에서 나타나는지를 파악합니다. 패턴의 길이를 늘려가면서, 즉 테이블을 계속 조인해 나가면 패턴의 <em>support</em> 를 구할 수 있습니다.</p>

<p><br></p>

<h3 id="prefixspan">PrefixSpan</h3>

<p><em>Pattern-Growth</em> 기반의 알고리즘인 <em>PrefixSpan</em> 을 살펴보겠습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/prefix_span1.png" alt=""></p>

<p>먼저 <em>length-1</em> 패턴을 찾고 이를 기반으로 <em>projected DB</em> 를 만들어가며 마이닝을 진행합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/prefix_span2.png" alt=""></p>

<p>단계가 지나면 지날수록 <em>candidate</em> 가 생겨나는 비율이 줄고, <em>projected DB</em> 자체도 줄어든다는 장점이 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/prefix_span3.png" alt=""></p>

<p>다만 <em>projected DB</em> 에서 많은 중복이 발생하기 때문에 이를 해결하기 위해 <em>pseudo projection</em> 을 이용할 수 있습니다. </p>

<p><br></p>

<h3 id="clospan">CloSpan</h3>

<p><em>CloSpan</em> 은 <em>closed sequential pattern</em> 을 마이닝하는 알고리즘입니다.</p>

<p><em>closed pattern</em> 을 다시 복습해 보면</p>

<blockquote>
  <p>closed pattern: A pattern(itemset) <code>X</code> is closed if <code>X</code> is frequent, and there exists no super pattern <code>Y</code> ⊃ <code>X</code>, with the same support as <code>X</code></p>
</blockquote>

<p>예를 들어 <code>&lt;abc&gt;:20, &lt;abcd&gt;:20, &lt;abcde&gt;:15</code> 라면 <code>&lt;abcd&gt;</code> <code>&lt;abcde&gt;</code> 는 <em>closed pattern</em> 입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/clo_span.png" alt=""></p>

<p><em>closed pattern</em> 을 마이닝하는 이유는 이전에도 말했듯이 중복된 패턴을 피하기 위함입니다. 위 그림처럼 <em>redundant search space</em> 를 <em>pruning</em> 할 수 있습니다.</p>

<p><br></p>

<h3 id="constraintbased">Constraint-Based</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/constraint_based_mining.png" alt=""></p>

<ul>
<li><strong>Data anti monotonic:</strong> <code>S</code> 가 제약조건 <code>c</code> 를 위반했을때, 나머지 부분인 <code>s</code> 를 더해도 여전히 위반이라면 <code>s</code> 를 제거할 수 있습니다.</li>
<li><strong>Sunccint:</strong> 제약조건 <code>c</code> 를 기준으로 데이터를 직접 조작합니다. 예를 들어 <code>S</code> 가 <code>{i-phone, MacAir}</code> 를 반드시 포함해야 한다고 할때, 그렇지 못하면 <code>S</code> 를 제거할 수 있습니다</li>
<li><strong>Convertible:</strong> 아이템을 정렬해서 제약조건을 <em>anti-monotonic</em> 이나 <em>monotonic</em> 등으로 바꿉니다. </li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/time_based_constraints.png" alt=""></p>

<ul>
<li><em>order constaint</em> 는 <em>anti-monotonic</em> 입니다</li>
<li><em>min, max gap</em> 제약조건은 <em>succinct</em> 입니다.</li>
<li><em>max span</em> 제약조건은 처음과 마지막 <em>element</em> 의 시간 간격입니다. 이것도 <em>succinct</em> 입니다</li>
<li><em>window size</em> 제약조건은 한 <em>element</em> 내부에서 <em>event</em> 발생 회수를 제한하는 조건입니다.</li>
</ul>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/episode_pattern_mining.png" alt=""></p>

<p>정규표현식과 <em>episode</em> 는 <em>sequential pattern</em> 의 다른 표현 방법입니다.</p>

<p><br></p>

<h3 id="graphpatternmining">Graph Pattern Mining</h3>

<p>이번 시간에 배울 내용은 다음과 같습니다.</p>

<ul>
<li>Apriori-Based Graph Pattern Mining</li>
<li><strong>gSpan:</strong> A Pattern-Growth-Based Method</li>
<li><strong>CloseGraph:</strong> Mining Closed Graph Pattern</li>
<li>Graph Indexing</li>
<li>Top-K Large Structural Patterns in a Massive Network</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/graph_support.png" alt=""></p>

<p><em>Graph</em> 에서 <em>support</em> 란 <em>subgraph</em> 가 나타나는 수 입니다. </p>

<p>그래프 패턴 마이닝을 위해서 다양한 방법을 이용할 수 있습니다.</p>

<p>(1) Generation of candidate subgraphs</p>

<ul>
<li>Apriori (<strong>FSG</strong>) vs Pattern Growth(<strong>gSpan</strong>)</li>
</ul>

<p>(2) Search Order</p>

<ul>
<li>Breadth vs Depth</li>
</ul>

<p>(3) Elimination of duplicate subgraphs</p>

<ul>
<li>Passive vs Active (e.g <strong>gSpan</strong>)</li>
</ul>

<p>(4) Support calculation</p>

<ul>
<li>Store embeddings (e.g <strong>GASTON, FFSM, MoFA</strong>)</li>
</ul>

<p>(5) Order of Pattern Discovery</p>

<ul>
<li>Path -> Tree -> Graph (<strong>GASTON</strong>)</li>
</ul>

<p><br></p>

<h3 id="aprioribasedapproach">Apriori-Based Approach</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/apriori_based_approache.png" alt=""></p>

<p><em>Apriori Property</em> 에 의해서, 어떤 그래프가 <code>G</code> 가 빈번한 경우는, <em>*모든 *</em>서브그래프들도 빈번할 경우뿐입니다. </p>

<p>따라서 <code>k</code> 개의 <em>edge, vertex</em> 를 가진 <em>frequent</em> 서브그래프에서 공통된 엣지가 많은 그래프를 골라 <code>k+1</code> 개의 <em>edge, vertex</em> 그래프를 만듭니다. 그리고 여기서 이 그래프의 <strong>모든 서브 그래프가</strong> <em>frequent</em> 한지 검사하여 <em>pruning</em> 을 진행할 수 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/vertex_edge_growing.png" alt=""></p>

<p><em>vertex</em> 기반으로 확장해 나가는 알고리즘으로 <em>AGM (Apriori-based Graph Mining)</em> 이 있습니다. <em>edge</em> 를 확장해 나가는 알고리즘으로는 <em>FSG (Frequent Sub Graphs)</em> 가 있는데, 일반적으로 더 작은 컴포넌트인 <em>edge</em> 를 확장시켜 나가는 방법이 더 효율적이라고 알려져 있습니다.</p>

<p><br></p>

<h3 id="gspanapatterngrowthapproach">gSpan: A Pattern Growth Approach</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/pattern_growth_approach_gSpan.png" alt=""></p>

<p>먼저 <code>k</code>-<em>edge</em> 그래프를 보고, 여기에 하나의 <em>edge</em> 를 더해 <code>k+1</code> <em>edge</em> 그래프도 빈번하다면 이 과정을 계속 반복해 나아갑니다. 이 방법은 많은 수의 <em>subgraph</em> 가 중복된다는 단점이 있습니다. </p>

<p>이 문제를 해결하기 위해 <em>gSpan</em> 에서는 생성할 <em>subgraph</em> 의 순서를 미리 정의해 놓고 <em>depth-first search</em> 를 이용해서 <em>graph</em> 를 <em>sequence</em> 처럼 펼칩니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/gspan_example.png" alt=""></p>

<p>위 그림에서는 가장 작은 인덱스를 먼저 선택하는 <em>DFS</em> 를 이용해서 우측처럼 시퀀스를 만들었습니다. </p>

<p><br></p>

<h3 id="closegraph">CloseGraph</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/closed_graph.png" alt=""></p>

<p><code>n</code> 개의 <em>edge</em> 를 가진 그래프에는 <code>2^n</code> 개의 서브그래프가 존재합니다. 정말 어마어마한 숫자입니다. 이런 <em>explosion</em> 문제를 해결하기 위해 <em>closed frequent subgraph</em> 를 이용합니다.</p>

<ul>
<li>A frequent graph <code>G</code> is <strong>closed</strong> if there exists no supergraph of <code>G</code> that carries the same support as <code>G</code>'</li>
</ul>

<p><em>loseless compression</em> 이기 때문에 결과는 <em>complete</em> 합니다. 따라서 <em>closed graph pattern</em> 을 마이닝 하면 좀 더 효율적입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/close_graph_algorithm.png" alt=""></p>

<p><code>G</code> 가 있을 때마다 <code>G1</code> 이 존재한다면 다른 <em>supergraph</em> 를 살펴볼 필요가 없습니다. 이는 <code>G1</code> 이 <code>G</code> 를 커버할 수 있기 때문입니다. 아래는 다른 알고리즘과의 성능 비교입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/close_graph_performance.png" alt=""></p>

<p><br></p>

<h3 id="graphindex">Graph Index</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/graph_indexing.png" alt=""></p>

<p>그림에서 볼 수 있듯이 <em>path index</em> 는 <code>(a)</code> <code>(b)</code> 를 쿼리 <code>Q</code> 에 대해 필터링 하지 못할 수 있습니다. 따라서 그래프를 직접 인덱싱하는 것이 필요한데, 문제는 그래프를 인덱싱할때 서브그래프가 너무 많다는 것입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/gIndex.png" alt=""></p>

<p>따라서 <em>frequent substructure</em> 만 인덱스 하되, <em>size-increasing support threshold</em> 를 이용하면 됩니다. 즉 사이즈가 증가할수록 <em>min support</em> 도 올리는 것인데, 이는 큰 그래프일수록 작은 그래프에서 이미 <em>indexed</em> 되었을 수 있기 때문입니다.</p>

<p>그리고 <em>discriminative substructure</em> 를 인덱싱해야합니다. 이는 기존과 비슷한 그래프를 인덱싱 할 필요는 없기 때문이지요. <em>discriminative</em> 그래프를 선택하기 위해서 슬라이드처럼 새로운 그래프 <code>x</code> 가 기존의 인덱싱된 그래프 <code>f1, f2, ...,</code> 을 얼마나 커버하는지를 계산하여 작으면 인덱싱합니다.</p>

<p><br></p>

<h3 id="spidermine">Spider Mine</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/spider_mine1.png" alt=""></p>

<p><em>pattern fusion</em> 과 비슷하게, 작은 컴포넌트인 <em>spider</em> 가 모여 결국에는 큰 컴포넌트를 만든다는 기본적인 아이디어로부터 시작합니다.</p>

<p><em>r-Spider</em> 는 <em>vertex</em> <code>u</code> 로부터 <code>r</code> 홉 안에 도달할 수 있는 <em>frequent</em> 패턴입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/spider_mine2.png" alt=""></p>

<p>알고리즘이 수행되는 동안 <em>spider mine</em> 알고리즘은 <em>large pattern</em> 을 유지하고 <em>small pattern</em> 을 <em>pruning</em> 합니다. 그 이유는 작은 패턴일수록 <em>random draw</em> 에서 <em>hit</em> 할 확률이 낮고, 했다 하더라도 여러번 <em>hit</em> 할 확률은 더 낮기 때문입니다. </p>

<p><br></p>

<h3 id="patternbasedclassification">Pattern-Based Classification</h3>

<p>이번 챕터에서 배울 내용은 다음과 같습니다.</p>

<ul>
<li>Pattern-Based Classification</li>
<li>Associative Classification</li>
<li>Discriminative Pattern-Based Classification</li>
<li>Direct Mining of Discriminative Patterns</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/pattern_based_why.png" alt=""></p>

<p><em>frequent pattern mining</em> 과 <em>classification</em> 을 조합하면 더 심도있고, 다양한 데이터에 대한 분석이 가능합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/pattern_based_example.png" alt=""></p>

<p><br></p>

<h3 id="associativeclassificationcbacmar">Associative Classification: CBA, CMAR</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/classification_CBA.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/CMAR.png" alt=""></p>

<p><br></p>

<h3 id="discriminativeclassification">Discriminative Classification</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/discriminative1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/discriminative2.png" alt=""></p>

<p>당연한 이야기지만 <em>single item</em> 보다는 <code>k</code> 개의 아이템셋이 더 많은 <em>information gain</em> 을 만듭니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/discriminative3.png" alt=""></p>

<p>그리고 위 슬라이드에서 볼 수 있듯이, <em>frequent, but not too frequent</em>  한 패턴이 <em>discriminative</em> 하게 적용됨을 알 수 있습니다. (<em>info gain</em> 이 더 많다는 뜻)</p>

<p><br></p>

<h3 id="ddpmine">DDP Mine</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/DDPMine1.png" alt=""></p>

<p><em>frequent pattern mining</em> 후에 <em>discriminative pattern</em> 을 얻는 것은 계산적으로 비쌉니다. 따라서 바로 <em>discriminative pattern</em> 을 얻을 수 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/DDPMine2.png" alt=""></p>

<p>알고리즘은 이렇습니다. 매 이터레이션마다 가장 <em>discriminative power</em> 가 큰 <em>feature</em> <code>f</code> 를 고르고, <code>D</code> 에서 <code>f</code> 에 의해 커버 되는 인스턴스 <code>D</code> 를 제거합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/DDPMine3.png" alt=""></p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="https://www.behance.net/gallery/625042/Icon-and-pattern-with-a-marketing-theme">Title image</a> <br>
(2) <strong>Pattern Discovery</strong> by <em>Jiawei Han</em> </p>]]></content:encoded></item><item><title><![CDATA[Articles]]></title><description><![CDATA[<h3 id="scala">Scala</h3>

<p><strong>Scalaz</strong></p>

<ul>
<li><a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1, State</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/">Easy Scalaz 2, Monad Transformer</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/">Easy Scalaz 3, ReaderWriterState with Kleisli</a></li>
<li>[Easy Scalaz 4, Free, Trampoline]</li>
<li>[Easy Scalaz 5, ST, IO]</li>
<li>[Easy Scalaz 6, Stream]</li>
</ul>

<p><strong>Monocle</strong></p>

<p><a href="http://1ambda.github.io/scala-monocle-tutorial/">Scala Lens Library, Monocle</a></p>

<p><strong>Functional Programming in Scala</strong> by <em>Martin Odersky</em></p>

<p><a href="http://1ambda.github.io/functional-programming-in-scala-chapter-1/">Chapter 1</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-2/">Chapter 2</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-3/">Chapter 3</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-4/">Chapter</a></p>]]></description><link>http://1ambda.github.io/articles/</link><guid isPermaLink="false">9666f26e-e434-403f-95b1-8e667199693c</guid><category><![CDATA[1ambda]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 28 Feb 2015 16:50:51 GMT</pubDate><content:encoded><![CDATA[<h3 id="scala">Scala</h3>

<p><strong>Scalaz</strong></p>

<ul>
<li><a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1, State</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/">Easy Scalaz 2, Monad Transformer</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/">Easy Scalaz 3, ReaderWriterState with Kleisli</a></li>
<li>[Easy Scalaz 4, Free, Trampoline]</li>
<li>[Easy Scalaz 5, ST, IO]</li>
<li>[Easy Scalaz 6, Stream]</li>
</ul>

<p><strong>Monocle</strong></p>

<p><a href="http://1ambda.github.io/scala-monocle-tutorial/">Scala Lens Library, Monocle</a></p>

<p><strong>Functional Programming in Scala</strong> by <em>Martin Odersky</em></p>

<p><a href="http://1ambda.github.io/functional-programming-in-scala-chapter-1/">Chapter 1</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-2/">Chapter 2</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-3/">Chapter 3</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-4/">Chapter 4</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-5/">Chapter 5</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-6/">Chapter 6</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-7/">Chapter 7</a>  </p>

<p><strong>Reactive Programming</strong> by <em>Martin Odersky</em></p>

<p><a href="http://1ambda.github.io/reactive-programming-1/">Chapter 1</a> - Monads, Random Generators <br>
<a href="http://1ambda.github.io/reactive-programming-2/">Chapter 2</a> - Stateful Object <br>
<a href="http://1ambda.github.io/reactive-programming-3/">Chapter 3</a> - Try, Future, Promise <br>
<a href="http://1ambda.github.io/reactive-programming-4/">Chapter 4</a> - Observable, Rx, Scheduler <br>
<a href="http://1ambda.github.io/reactive-programming-5/">Chapter 5</a> - Actor   </p>

<p><strong>Articles</strong></p>

<p><a href="http://1ambda.github.io/new-to-play-framework-2/">new to Play Framework2</a> <br>
<a href="http://1ambda.github.io/partial-functions-scala/">Partial Functions, Scala</a>  </p>

<h3 id="haskell">Haskell</h3>

<p><strong>Introduction to Functional Programming using Haskell</strong></p>

<p><a href="http://1ambda.github.io/haskell-intro1">Chapter 1</a> - Basics <br>
<a href="http://1ambda.github.io/haskell-intro2">Chapter 2</a> - List Comprehension <br>
<a href="http://1ambda.github.io/haskell-intro3">Chapter 3</a> - Recursion, Higher Order Function <br>
<a href="http://1ambda.github.io/haskell-intro4">Chapter 4</a> - Monad <br>
<a href="http://1ambda.github.io/haskell-intro5">Chapter 5</a> - IO Monad <br>
<a href="http://1ambda.github.io/haskell-intro6">Chapter 6</a> - Type and Class <br>
<a href="http://1ambda.github.io/haskell-intro7">Chapter 7</a> - The Countdown Problem <br>
<a href="http://1ambda.github.io/haskell-intro8">Chapter 8</a> - Lazy Evaluation, Strict <br>
<a href="http://1ambda.github.io/haskell-intro9">Chapter 9</a> - Induction <br>
<a href="http://1ambda.github.io/a-poor-mans-concurrency-monad">Poor Man's Concurrency Monad</a></p>

<h3 id="machinelearning">Machine Learning</h3>

<p><strong>Machine Learning</strong> by <em>Andrew Ng</em>, Coursera</p>

<p><a href="http://1ambda.github.io/machine-learning-week-1/">Chapter 1</a> - Linear Regression <br>
<a href="http://1ambda.github.io/machine-learning-week-2/">Chapter 2</a> - Gradient Descent <br>
<a href="http://1ambda.github.io/machine-learning-week-3/">Chapter 3</a> - Logistic Regression <br>
<a href="http://1ambda.github.io/machine-learning-week-4/">Chapter 4</a> - Neural Network <br>
<a href="http://1ambda.github.io/machine-learning-week-5/">Chapter 5</a> - Back Propagation <br>
<a href="http://1ambda.github.io/machine-learning-week-6/">Chapter 6</a> - Practical Advices <br>
<a href="http://1ambda.github.io/machine-learning-week-7/">Chapter 7</a> - Support Vector Machine <br>
<a href="http://1ambda.github.io/machine-learning-week-8/">Chapter 8</a> - K-means, PCA Details <br>
<a href="http://1ambda.github.io/machine-learning-week-9/">Chapter 9</a> - Anomaly Detection, Recommender System <br>
<a href="http://1ambda.github.io/machine-learning-week-10/">Chapter 10</a> - Stochastic Gradient, Synthetic Data, Ceiling Analysis  </p>

<h3 id="algorithm">Algorithm</h3>

<p><strong>Algorithm: Design and Analysis Part 1</strong> by <em>Tim Roughgarden</em></p>

<p>(1) <a href="http://1ambda.github.io/divide-and-conquer/">Divide and Conquer</a> <br>
(2) <a href="http://1ambda.github.io/randomized-selection/">Randomized Selection</a> <br>
(3) <a href="http://1ambda.github.io/graphs-the-contraction-algorithm/">Graphs, The Contraction Algorithm</a> <br>
(4) <a href="http://1ambda.github.io/graph-search-and-connectivity/">Graph Search and Connectivity</a> <br>
(5) <a href="http://1ambda.github.io/dijkstra-heap-balanced-tree/">Dijkstra, Heap, Red-Black Tree</a> <br>
(6) <a href="http://1ambda.github.io/hash-table-universal-hashing-bloom-filters/">Hash Table, Universal Hashing, Bloom filters</a>  </p>

<p><strong>Algorithms, Part 1</strong> by <em>Robert Sedgewick</em></p>

<p>(1) <a href="http://1ambda.github.io/union-find-algorithms-week-1/">Union Find</a> <br>
(2) <a href="http://1ambda.github.io/analysis-of-algorithms/">Analysis of Algorithms</a> </p>

<p><strong>Algorithms, Part 2</strong> by <em>Robert Sedgewick</em></p>

<p>(1) <a href="http://1ambda.github.io/graph-challenges-minimum-spanning-trees">Spanning Tree, Shortest Paths</a> <br>
(2) <a href="http://1ambda.github.io/radix-sort-suffix-sort">Radix Sort, Suffix Sort</a> <br>
(3) <a href="http://1ambda.github.io/r-way-ternary-search-tries/">R-way, Ternary Tries</a> <br>
(4) <a href="http://1ambda.github.io/substring-search/">KMP, Boyer-Moore, Rabin-Karp</a> <br>
(5) <a href="http://1ambda.github.io/maximum-flow/">Maximum Flow (Ford-Fulkerson)</a> <br>
(6) <a href="http://1ambda.github.io/algorithm-data-compression/">Data Compression, Huffman, LZW</a>   </p>

<h3 id="artificialintelligence">Artificial Intelligence</h3>

<p><strong>Artificial Intelligence (CS188)</strong> by <em>Dan Klein, Pieter Abbeel</em></p>

<p>(1) <a href="http://1ambda.github.io/artificial-intelligence-1">Intro</a> <br>
(2) <a href="http://1ambda.github.io/artificial-intelligence-2">Search</a>  </p>

<p><strong>Artificial Intelligence Planning</strong> by <em>Dr.Gerhard Wickler</em>, <em>Prof. Austin Tate</em></p>

<p>(1) <a href="http://1ambda.github.io/ai-planning-1">Intro</a> <br>
(2) <a href="http://1ambda.github.io/ai-planning-2">A*, STRIPS, forward and backward search</a> <br>
(3) <a href="http://1ambda.github.io/ai-planning-3">PSP, PoP</a> <br>
(4) <a href="http://1ambda.github.io/ai-planning-4">STN, HTN</a>  </p>

<h3 id="cloudcomputing">Cloud Computing</h3>

<p><strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera</p>

<p>(1) <a href="http://1ambda.github.io/cloud-computing-1-1/">MapReduce</a> <br>
(2) <a href="http://1ambda.github.io/cloud-computing-gossip-protocol/">Gossip Protocol</a> <br>
(3) <a href="http://1ambda.github.io/cloud-computing-membership-protocol/">Membership Protocol</a> <br>
(4) <a href="http://1ambda.github.io/cloud-computing-p2p-systems/">P2P Systems</a> <br>
(4) <a href="http://1ambda.github.io/cloud-computing-snapshot/">Global Snapshot</a> <br>
(4) <a href="http://1ambda.github.io/cloud-computing-multicast/">Multicast</a> <br>
(4) <a href="http://1ambda.github.io/cloud-computing-paxos/">Paxos</a>  </p>

<h3 id="dataanalysis">Data Analysis</h3>

<p><strong>Pattern Discovery</strong> by <em>Jiawei Han</em>, Coursera</p>

<p><a href="http://1ambda.github.io/pattern-discovery-1/">Chapter 1</a> - Apriori, FP Growth <br>
<a href="http://1ambda.github.io/pattern-discovery-2/">Chapter 2</a> - Null-invariant, Pattern-Fusion, Constaint   </p>

<p><strong>Intro to Computational Thinking and Data Science</strong>, edx</p>

<p><a href="http://1ambda.github.io/edx-600-2x-1/">Chapter 1</a> - Modeling <br>
<a href="http://1ambda.github.io/edx-600-2x-2/">Chapter 2</a> - Monte Carlo Simulation <br>
<a href="http://1ambda.github.io/edx-600-2x-3/">Chapter 3</a> - Optimization Problem <br>
<a href="http://1ambda.github.io/edx-600-2x-4/">Chapter 4</a> - State Modeling, Hierarchical Clustering   </p>

<p><strong>Coding The Matrix</strong> by <em>Philip Klein</em>, Coursera</p>

<p><a href="http://1ambda.github.io/coding-the-matrix-1/">Chapter 1</a> - Function, Field, Vector <br>
<a href="http://1ambda.github.io/coding-the-matrix-w/">Chapter 2</a> - Vector Space <br>
<a href="http://1ambda.github.io/coding-the-matrix-e/">Chapter 3</a> - Matrix  </p>

<h3 id="processmining">Process Mining</h3>

<p><strong>Process Mining</strong> by <em>Wil Van der Alast</em>, Coursera</p>

<p><a href="http://1ambda.github.io/process-mining-week1/">Week 1</a> - Process Mining Intro <br>
<a href="http://1ambda.github.io/process-mining-week2/">Week 2</a> - Alpha Algorithm <br>
<a href="http://1ambda.github.io/process-mining-week3/">Week 3</a> - Metric, C-nets <br>
<a href="http://1ambda.github.io/process-mining-week4/">Week 4</a> - Conformance Checking, Dotted Chart <br>
<a href="http://1ambda.github.io/process-mining-week5/">Week 5</a> - Decision, Social, Organization Mining  </p>

<h3 id="java">Java</h3>

<p><strong>Articles</strong></p>

<p><a href="http://1ambda.github.io/java-interview-questions-collection-framework/">Java Interview Questions - Collection Framework</a>  </p>

<h3 id="javascript">Javascript</h3>

<p><a href="http://1ambda.github.io/javascript-object-inheritance/">Javascript Inheritance Details</a> <br>
<a href="http://1ambda.github.io/angular-providers/">Angular, Providers</a>  </p>]]></content:encoded></item><item><title><![CDATA[Cloud Computing, P2P Systems]]></title><description><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>P2P 시스템의 기술들은 <em>cloud computing</em> 의 많은 분야에서 활용됩니다. 뒤에서 배울 <em>Chord P2P hashing</em> 같은 경우는 <em>Cassandra</em>, <em>Voldmort</em> 등의 <em>key-value store</em> 에서 쓰이고 있습니다. </p>

<p><br></p>

<h3 id="napster">Napster</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/napster.png" alt=""></p>

<p>최초에 <em>peer</em> 는 서버에게 메세지를 보내 P2P 시스템에 가입했다는 사실을 알립니다.</p>

<p><em>Napster</em> 에서는 중앙에 서버를 두어, 파일이 저장된 <em>peer</em> 를 기록합니다. 각 <em>peer</em> 는 파일이</p>]]></description><link>http://1ambda.github.io/cloud-computing-p2p-systems/</link><guid isPermaLink="false">6e527ab7-0598-4177-b199-dd4ef466f537</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[P2P]]></category><category><![CDATA[Napster]]></category><category><![CDATA[Gnutella]]></category><category><![CDATA[BitTorrent]]></category><category><![CDATA[FastTrack]]></category><category><![CDATA[Chord]]></category><category><![CDATA[Pastry]]></category><category><![CDATA[Kelips]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 28 Feb 2015 16:18:25 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>P2P 시스템의 기술들은 <em>cloud computing</em> 의 많은 분야에서 활용됩니다. 뒤에서 배울 <em>Chord P2P hashing</em> 같은 경우는 <em>Cassandra</em>, <em>Voldmort</em> 등의 <em>key-value store</em> 에서 쓰이고 있습니다. </p>

<p><br></p>

<h3 id="napster">Napster</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/napster.png" alt=""></p>

<p>최초에 <em>peer</em> 는 서버에게 메세지를 보내 P2P 시스템에 가입했다는 사실을 알립니다.</p>

<p><em>Napster</em> 에서는 중앙에 서버를 두어, 파일이 저장된 <em>peer</em> 를 기록합니다. 각 <em>peer</em> 는 파일이 어디있는지 검색하기 위해 중앙 서버에 질의해야 합니다. 그림에서 볼 수 있듯이, 각 파일은 서버가 아니라 <strong>클라이언트</strong> 에 저장되어 있습니다. 파일이 어느 클라이언트(<em>peer</em>) 에 저장되어있는지 알게되면, <em>ping</em> 을 날려 살아있는지 확인 후 파일을 다운 받습니다. </p>

<p><em>Napster</em> 의 문제점은</p>

<ul>
<li>중앙 서버로의 요청이 너무나 많습니다.</li>
<li><p>서버가 다운되면, 시스템이 멈춥니다.</p>

<p><br></p></li>
</ul>

<h3 id="gnutella">Gnutella</h3>

<p><em>Gnutella</em> 는 <em>Napster</em> 시스템에서 <strong>서버</strong>를 제거했습니다. 각 클라이언트 (<em>peer</em>) 는 파일이 어디 저장되어있는지 파악하기 위해 서로 통신하지요. 이처럼 클라이언트가 서버처럼 행동하기때문에 <em>servent</em> 라 부르기도 합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella.png" alt=""></p>

<p>위 슬라이드에서 알 수 있듯이, 각 피어는 근처에 있는 피어로의 링크를 가지고 있습니다. 이 링크는 <em>overlay graph</em> 라 부르기도 합니다.</p>

<p><em>gnutella</em> 에서 피어간 통신에 사용되는 주요 메세지 타입은</p>

<ul>
<li><strong>Query:</strong> search</li>
<li><strong>QueryHit:</strong> reponse to query</li>
<li><strong>Ping:</strong> to probe network for other peers</li>
<li><strong>Pong:</strong> reply to ping, contains address of another peer</li>
<li><strong>Push:</strong> used to initiate file transfer</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella_header.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella_search_ttl.png" alt=""></p>

<p>위 그림에서 <code>TTL = 2</code> 이기 때문에 <em>query</em> 메세지는 <em>2-hop</em> 까지만 전파됩니다. 그리고 <em>gnutella</em> 에서는 각 피어가 최근에 퍼트린 <em>query</em> 메세지 리스트를 유지하고 있기 때문에 같은 메세지를 다시 전파하지 않습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella_queryhit_msg.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella_queryhit_msg_ex.png" alt=""></p>

<p>피어가 보낸 <em>query</em> 에 대해 해당하는 파일을 가지고 있다는 응답은 <em>query hit</em> 메세지를 통해 전달됩니다.</p>

<p><em>gnutella</em> 에서는 과도한 트래픽을 방지하기 위해 다음의 방법을 사용합니다.</p>

<ul>
<li>to avoid duplicate transmissions, each peer maintains a list of recently received messages</li>
<li>query forwarded to all neighbors except peer from which received</li>
<li>each query (identified by <code>DescriptorID</code>) forwarded only once</li>
<li><em>QueryHit</em> routed back only to peer from which <em>Query</em> received with same <code>DescriptorID</code></li>
<li>for flooded messages, duplicates with same <code>DescriptorID</code> and <em>Payload descriptor</em> are dropped</li>
<li><em>QueryHit</em> with <code>DescriptorID</code> for which <em>Query</em> not seen is dropped</li>
</ul>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/after_receiving_queryhit.png" alt=""></p>

<p><em>QueryHit</em> 메세지를 <em>requestor</em> 가 받으면 최적의 <em>responder</em> 를 고르고,  <strong>HTTP</strong> 를 이용해서 몇번의 통신을 한 뒤 파일을 전송받습니다. 여기서 <em>gnutella</em> 가 <em>HTTP</em> 를 이용하는 이유는, HTTP 가 <em>standard</em>, <em>well-debugged</em>, <em>widely used</em> 이기 때문입니다.</p>

<p>그런데 만약, <em>responder</em> 가 방화벽(<em>firewall</em>) 뒤에 있으면 어떻게 될까요? 일반적으로 방화벽은 <em>incomming message</em> 를 필터링 합니다. <em>gnutella</em> 는 이럴 경우 대비해 <em>push</em> 를 만들어 놓았습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/dealing_with_firewalls.png" alt=""></p>

<p><em>query hit</em> 메세지를 받은 후에 <em>requestor</em> 가 보내는 <em>HTTP</em> 메세지에 <em>responder</em> 가 응답하지 않으면 <em>overlay link</em> (이미 연결되어있는) 을 통해서 <em>push</em> 메세지를 <em>requestor</em> 가 보냅니다. <em>responder</em> 는 방화벽 뒤에 있어도, <em>overlay link</em> 를 통해 받은 <em>push</em> 메세지를 확인하고 파일 전송을 시작합니다.</p>

<p>만약 <em>requestor</em> 가 방화벽 뒤에 있다면, <em>gnutella</em> 프로토콜로는 파일을 전송 받을 수 없습니다.</p>

<p><br></p>

<p><em>gnutella</em> 에서 생기는 문제점은 </p>

<ul>
<li><em>ping/pong</em> constituted 50% traffic: use multiplex, cache and reduce freq of <em>ping/pong</em></li>
<li>modem-conncted hosts do not have enough bandwidth for passing gnutella traffic: use a central server to act as proxy for such peers. or use <strong>FastTrack System</strong></li>
<li>large number of <em>free loaders</em></li>
<li>flooding causes excessive traffic: use <strong>Structured P2P system</strong> e.g <strong>Chord System</strong></li>
</ul>

<p><br></p>

<h3 id="fasttrac">FastTrac</h3>

<p><em>FastTrac</em> 은 <em>Kazza</em>, <em>KazzaLite</em>, <em>Grokster</em> 라는 기술을 기반으로 한 <em>Napster</em> <em>Gnutella</em> 의 하이브리드입니다. </p>

<p><em>healthier participants</em> 를 이용하겠다는 기본적인 아이디어로부터 출발했습니다. <em>gnutella</em> 와 비슷하지만 노드중 일부가 <em>supernode</em> 가 되어, 특별한 역할을 수행합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/fast_trac.jpg" alt=""></p>

<ul>
<li><em>supernode</em>는 <em>Napster server</em> 와 비슷하게 근처에 있는 노드의 <code>&lt;file name, peer point&gt;</code> 리스트를 저장합니다</li>
<li><em>supernode</em> 의 멤버십은 시간이 지나면서 변합니다</li>
<li>어떤 노드도 <em>supernode</em> 가 될 수 있습니다. 그러기 위해서는 <em>reputation</em> 을 얻어야 합니다</li>
<li>각 노드는 데이터를 탐색하기 위해 <em>supernode</em> 에 질의합니다</li>
</ul>

<p>이 <em>reputation system</em> 은 <em>Kazaalite</em> 처럼 <em>upload</em> 한 파일의 양으로 결정할 수도 있고, 경제학적인 원리를 적용한 방법도 있습니다</p>

<p><br></p>

<h3 id="bittorrent">BitTorrent</h3>

<p>이전에 언급했듯이 <strong>다운만 받는 peer</strong> 도 존재할 수 있습니다. <em>BitTorrent</em> 는 업로드 하는 <em>peer</em> 에게 보상을 해 주어, <em>peer</em> 들의 업로드를 더 이끌어 낼 수 있습니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/bit_torrent_network.jpg" alt=""></p>

<p><em>BitTorrent</em> 네트워크 구성은 위 슬라이드와 같습니다.</p>

<ul>
<li><strong>Tracker:</strong> 파일당 하나씩 존재하며 <em>heartbeat</em> 를 받아 <em>peer</em> 의 <em>join</em>, <em>leave</em> 를 관리합니다.</li>
<li><strong>Seed:</strong> 전체 파일을 가지고 있는 <em>peer</em> </li>
<li><strong>Leecher:</strong> 파일의 일부분을 가지고 있는 <em>peer</em> </li>
</ul>

<p><em>BitTorrent</em> 에서는 블럭단위로 파일을 전송하는데, 이 때 사용하는 몇 가지 규칙이 있습니다.</p>

<ul>
<li><em>Local Rarest First:</em> 파일을 다운받을때, 귀한 블럭부터 먼저 받습니다</li>
<li><em>Tit for tat:</em> 업로드 하는 만큼, 다운로드 <em>bandwidth</em> 를 할당받습니다. 다시 말해서 업로드를 많이해야 빠르게 받을 수 있습니다</li>
<li><em>Choking:</em> 동시에 업로드하는 <em>neighbor</em> 수를 제한해서 <em>bandwidth</em> 가 너무 많이 사용되지 않도록 합니다. <em>best neighbor</em> 를 선택하여 <em>unchoked set</em> 을 유지하고, 주기적으로 이 집합을 재평가합니다. 이외의 다른 <em>peer</em> 는 <em>choked set</em> 입니다. </li>
</ul>

<p><em>optimistic unchoke</em> 기법은 주기적으로 랜덤한 <em>neighbor</em> 를 <em>unchoke</em> 해서, <em>unchoked set</em> 을 <em>fresh</em> 하게 유지합니다. 여기서 <em>random choice choking</em> 을 쓰는 이유는</p>

<ul>
<li>To avoid the sysem from getting stuck where only a few peers receive service</li>
</ul>

<p><br></p>

<h3 id="dht">DHT</h3>

<p>지금까지 본 <em>Napster</em>, <em>Gnutella</em>, <em>FastTrac</em> 은 일종의 <em>DHT, Distribute Hash Table</em> 입니다.</p>

<p><em>DHT</em> 에서의 <em>performance concerns</em> 는</p>

<ul>
<li>load balancing</li>
<li>fault-tolerance</li>
<li>efficiency of lookup and inserts</li>
<li>locality</li>
</ul>

<p>우리가 배울 <em>Chord</em> 는 이런 구조가 적용된 <em>structured peer to peer system</em> 입니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/performance_comparison_nap_gnu.jpg" alt=""></p>

<p><em>Napster</em> 는 <em>peer</em> 의 경우 파일을 저장하지 않기 때문에 메모리가 많이 들지 않지만, <em>server</em> 에서 많은 메모리를 요구합니다. 서버로 질의가 가기때문에 <em>lookup latency</em> 나 <em>lookup</em> 을 위한 메세지 수 자체는 많지 않지만, 서버의 부하가 상당히 심할 수 있습니다.</p>

<p>반면 <em>Gnutella</em> 에서는 서버가 없습니다. 그렇기 때문에 피어는 파일이 저장되어있는 주변 피어의 목록을 가지고 있어야 하는데, <code>N</code> 만큼의 이웃이 주변에 있을 수 있습니다. 따라서 한 피어에서 필요한 메모리 양은 <code>O(N)</code> 입니다.</p>

<p>그리고 네트워크가 직선으로 구성되어 있다고 할때, <em>lookup latency</em> 는 <code>O(N)</code> (<code>N-1</code>) 이고 룩업을 위한 메세지 수도 <code>O(N)</code> (<code>2(N-1)</code>) 입니다.</p>

<p>반면 <em>Chord</em> 는 모두 <code>O(log N)</code> 입니다. 이론적으로 <em>constant</em> 는 아니지만, <em>real world</em> 에서는 상당히 낮은 수가 될 수 있습니다.</p>

<p><br></p>

<h3 id="chord">Chord</h3>

<p><em>Chord</em> 는 <em>Berkeley</em> 와 <em>MIT</em> 에서 개발된 <em>P2P</em> 프로토콜입니다.<em>latency</em> 와 <em>message cost of routing</em> (<em>lookups</em>/<em>inserts</em>) 를 줄이기 위해 지능적으로 <em>neighbor</em> 를 선택하고 <em>Consistent Hashing</em> 기법을 사용합니다.</p>

<p><em>Consistent Hasing</em> 값은 <em>peer</em> 에 부여되는 주소값으로</p>

<ul>
<li>IP 와 Port로 <em>SHA1</em> 로 해싱해서 160 비트 스트링을 만들고 </li>
<li><code>m</code> 비트로 절단해서 사용합니다</li>
<li><em>peer</em> 의 <em>ID</em> 라 불리기도 하는데, 이 값은 당연히 최대 <code>2^m - 1</code> 입니다</li>
<li>해싱값이므로 <em>unique</em> 하진 않지만 충돌이 일어날 확률은 굉장히 적습니다</li>
<li>그리고 이 값이 <code>2^m</code> 개의 점이 되어 하나의 원을 구성합니다</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/ring_of_peers.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_finger_table.png" alt=""></p>

<p>각 노드는 (반) 시계방향으로의 <em>successor</em> 를 가지고 있고, 다른 노드를 가리키기 위한 <em>finger table</em> 을 가지고 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_file_saving.png" alt=""></p>

<p>파일도 마찬가지로 <em>SHA-1</em> 으로 해싱해서, 160 비트로 짜른 뒤 <code>mod 2^m</code> 연산해서, 같은 값이거나 그보다 큰 값을 가지는 <em>peer</em> 에 저장합니다.</p>

<p>만약 균일하게 해싱된다면 <code>K</code> 개의 키, <code>N</code> 개의 피어에서 파일은 각 피어당 <code>K/N</code> 개씩 저장되므로 피어당 걸리는 부하는 <code>O(K/N)</code> 입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_search_process.png" alt=""></p>

<p>위 그림에서 <code>N80</code> 피어가 <code>K42</code> 파일을 찾을때, </p>

<ul>
<li><em>finger table</em> 에 <code>42</code> 가 없으므로 최대한 먼 <code>N16</code> 에 질의하고, </li>
<li><code>N16</code> 은 <code>N32</code> 와 <code>N80</code> 밖에 모르므로 <code>N32</code> 를 거쳐 <code>N45</code> 로 질의합니다.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_search_analysis.png" alt=""></p>

<p><em>chrod search</em> 는 <code>O(log N)</code> 의 시간이 듭니다. 증명에 대한 <em>intuition</em> 은 쉽습니다.</p>

<p>만약 현재 <code>Here</code> 에서 <code>Key</code> 를 모른다고 합시다. 그러면 그 거리의 <code>1/2</code> 만큼은 점프를 해야합니다. 그것보다 더 적게 점프하면 거리를 <code>d</code> 라 합시다. <em>finger table entry</em> 값은 2배씩 증가하기 때문에, <code>2d</code> 만큼 점프할 수 있는 엔트리가 있어야 하고, 그럼 애초부터 <code>2d</code> 만큼 점프했어야 했기 때문에 모순입니다.</p>

<p><code>log(N)</code> 만큼의 점프 뒤에는 <em>key</em> 까지의 거리는 아무리 멀어봐야 <code>2^m / N</code> 입니다. 균일하게 분포되는 해싱을 쓴다 가정하면, 이 사이에는 적은 수의 노드만 있습니다. 따라서 <code>O(logN)</code> 만큼만 더 점프한다면 높은 확률로 <em>key</em> 를 찾을 수 있습니다. <code>O(logN) + O(logN) = O(logN)</code> 이므로, <em>search</em> 는 <code>O(logN)</code> 입니다.</p>

<p><em>insertion</em> 도 <em>searching</em> 과 마찬가지로 <code>O(logN)</code> 입니다. 그러나 이 성능은 <em>finger table</em> 과 <em>successor</em> 가 잘못되지 않았을 경우에만 참입니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_multiple_successor.png" alt=""></p>

<p><em>chrod</em> 는 <em>successor</em> 한개만 가질땐 <em>failure</em> 에 취약하기 때문에, 위 그림처럼 다수개의 <em>successor</em> 를 가질 수 있습니다. 이 경우 성능은 어떻게될까요?</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/multiple_successor_analysis.png" alt=""></p>

<p><code>2log(N)</code> 개의 <em>successor</em> 를 유지할 경우를 한번 생각해 봅시다. <code>50%</code> 씩 <em>failure</em> 가 발생하면</p>

<ul>
<li>하나의 노드에서 유지하는 <em>successor</em> 중, 적어도 하나의 <em>successor</em> 가 살아있을 확률은</li>
</ul>

<p><img src="http://latex.codecogs.com/gif.latex?1%20-%20%28%7B1%20%5Cover%202%7D%29%5E%7B2logN%7D%20%3D%201%20-%20%7B1%20%5Cover%20N%5E2%7D" alt=""></p>

<ul>
<li>위 확률은 모든 살아있는 노드(<code>50%</code>) 에서 참일때, 다시 말해서 모든 노드에서 적어도 하나의 <em>successor</em> 가 존재할 확률은 <code>N</code> 이 매우 클때</li>
</ul>

<p><img src="http://latex.codecogs.com/gif.latex?%281%20-%20%7B1%20%5Cover%20N%5E2%7D%29%5E%7BN/2%7D%20%3D%20e%5E%7B-%7B1%5Cover%202N%7D%7D%20%5Capprox%201" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_joining.png" alt=""></p>

<ul>
<li>a new peer affects <code>O(logN)</code> other finger entires in the system, on average</li>
<li>number of messages per peer join <code>O(logN * logN)</code></li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_stabilization_protocol.png" alt=""></p>

<p><em>join</em>, <em>leave</em>, <em>failure</em> 등 <em>churn</em> 이 자주 일어나므로 <em>loop</em> 가 있는지 없는지 검사하기 위해 주기적으로 <em>stabilization protocol</em> 를 사용합니다.</p>

<p><br></p>

<h3 id="pastry">Pastry</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/pastry_routing.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/pastry_locality.png" alt=""></p>

<p><em>Pastry</em> 는 <em>chord</em> 처럼 <em>node</em> 에 <em>id</em> 를 부여합니다. <em>routing table</em> 은 <em>prefix matching</em> 에 기반하기 때문에 <code>log(N)</code> 의 성능을 보여줍니다. 그리고 짧은 <em>prefix</em> 일 수록 가까이에 있을 확률이 높습니다.</p>

<p><br></p>

<h3 id="kelips">Kelips</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/kelips.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/kelips2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/kelips3.png" alt=""></p>

<p><em>Kelips</em> 는 <em>1-hop lookup</em> 을 보여줍니다. 이럴 수 있는 이유는 위 그림에서 보듯이 <em>affinity group</em> 이란걸 사용하기 때문입니다. 루트 <code>N</code> 에 가까운 숫자 <code>k</code> 를 정하고, 이 수로 <code>mod</code> 연산을 해, 그룹을 만듭니다. 각각의 그룹은 내에 있는 모든 노드는 서로 어떤 파일을 저장하는지 알고 있습니다. 그리고 각 노드는 다른 그룹으로의 링크를 하나씩 가지고 있습니다. 따라서 어딜가든 거의 1번 혹은 2번 내에 <em>lookup</em> 이 가능합니다.</p>

<p><em>chord</em> 에 비해 메모리를 더 잡아먹긴 합니다. <code>O(logN)</code> 보단 많은 양이지만, 그렇게 많지도 않습니다. 메모리가 귀하다면 <em>chord</em> 나 <em>pastry</em> 를, 그렇지 않고 <em>lookup</em> 속도가 중요하다면 <em>kelips</em> 를 사용하면 됩니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/kelips4.png" alt=""></p>

<p><em>membership</em> 은 <em>gossip-based</em> 프로토콜로 관리할 수 있습니다. </p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://ook.co/solutions/cloud-computing/">Title Image</a> <br>
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></content:encoded></item></channel></rss>