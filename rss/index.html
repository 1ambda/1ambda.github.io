<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Old Lisper]]></title><description><![CDATA[Functional Programming]]></description><link>http://1ambda.github.io/</link><generator>Ghost 0.5</generator><lastBuildDate>Sun, 25 Jan 2015 01:55:14 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[AI Planning 2, Heuristic Search and STRIPS]]></title><description><![CDATA[<p><img src='http://imgs.xkcd.com/comics/ai.png'  alt="" /></p>

<p>이번 시간에는 <em>A* algorithm</em>, <em>heuristics</em>, <em>forward search</em> 등을 배운다.</p>

<h3 id="heuristicsearchstrategies">Heuristic Search Strategies</h3>

<p><em>FIFO</em> 나 <em>LIFO</em> 는 와 달리 <em>heuristic algorithm</em> 은 <em>search space</em> 에 대한 정보를 이용한다. </p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/heuristic_function.png'  alt="" /></p>

<p><em>heuristic function</em> <code>h: state space -&gt; R</code> 은, <em>problem-specific knowledge</em> 를 <em>problem-independent way</em> 로 표현한다. </p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/best_first_search.png'  alt="" /></p>

<p><em>best-first search</em> 알고리즘은 <em>general tree search</em> 알고리즘의 인스턴스로, 가장 낮은 <code>f(n)</code> 값을 가지는 노드를 선택해 탐색한다. 이를 위해 <code>f(n)</code> 값을 오름차순으로 정렬하는 <em>priority queue</em> 이용한다. </p>

<p>만약 <code>f(n) = h(n)</code> 이면, <em>greedy best-first search</em> 라 부른다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/greedy_best_fs.png'  alt="" /></p>

<p><em>optimal</em> 이 아닐 수 있다는 점에 유의하자.</p>

<p>루마니아 투어 문제를 다시 보자.</p>

<p><img src='https://spark-public.s3.amazonaws.com/aiplan/resources/touring-romania-map.png'  alt="" />
<img src='https://spark-public.s3.amazonaws.com/aiplan/resources/touring-romania-heuristic.png'  alt="" /></p>

<p><em>heuristic function</em> 으로 <em>straight line distance</em> 를 이용했는데, 실제 거리와는 차이가 있다. (꼬불꼬불하니까)</p>

<h3 id="aalgorithm">A* algorithm</h3>

<p><em>greedy best-first search</em> 알고리즘은 쉽지만, 항상 <em>optmial solution</em> 를 돌려주지 않는다는 단점이 있다. 여기서 배울 <em>A* algorithm</em> 은 항상 <em>optimal solution</em> 을 찾아낸다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/a_star_algorithm.png'  alt="" /></p>

<p><code>h(n)</code> 은 휴리스틱 펑션이고, <code>g(n)</code> 은 <code>n</code> 에 도달하기 까지의 비용이다. 그리고 이 두 함수를 이용해 만든 <em>evaluation function</em> <code>f(n)</code> 을 <em>best-first search</em> 에 적용해 최적의 해를 찾아낸다.</p>

<blockquote>
  <p>A* search is optimal if <code>h(n)</code> is admissible</p>
</blockquote>

<p><em>A* search</em> 를 이용해 <em>Touring Romania</em> 문제를 풀어보면</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/a_star_touring.png'  alt="" /></p>

<p><em>greedy best-first search</em> 와 비교해보면 트리가 좀 더 큰데, 이건 <em>A* search</em> 가 일반적으로 좀 더 느리다는 사실을 보여준다.</p>

<p><br/></p>

<p><em>8-puzzle</em> 문제도 <em>A* search</em> 로 풀어보자. <em>empty tile</em> 을 옮긴다고 생각하고, <em>cost function</em> <code>g(n)</code> 은 모든 경우 <code>1</code> 로 볼 수 있다. 몇 가지 <code>h(n)</code> 을 생각해 볼 수 있는데,</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/eight_puzzle_heuristics.png'  alt="" /></p>

<p><em>Manhattan block distance</em> 는 제 자리까지 얼마나 더 움직여야하는지를 의미한다.</p>

<h3 id="propertiesofa">Properties of A*</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/admissible_heuristics.png'  alt="" /></p>

<p><em>admissible</em> 이란 말은, 항상 <code>h(n) &lt;= actual distance</code> 임을 의미한다. <code>f(n) = g(n) + h(n)</code> 이므로, <em>heuristic function</em> 이 <em>admissible</em> 하면 가장 적은 <code>f(n)</code> 을 찾는 <em>A* search</em> 는 <em>optimal solution</em> 을 돌려준다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/a_star_completeness.png'  alt="" /></p>

<p><em>A* search</em> 는 <em>complete</em> 하다. 이는 탐색 과정에서 <em>goal node</em> 를 포함한 <em>contour</em> (윤곽, 등고선) 에 도달하기 때문이다. 여기서 <em>contour</em> 란 같은 비용으로 도달할 수 있는 <em>sets of state</em> 다. <em>initial node</em> 에서 시작해서 <em>f-value</em> 가 증가하는 방향으로 탐색이 이루어지므로 결국 꼭지점(<em>goal</em>) 에 도달한다. 사실 <em>heuristics</em> 이 없다면 <em>A* search</em> 는 다익스트라 알고리즘과 동일하다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/touring_romania_contours.png'  alt="" /></p>

<p>기하학적으로 보면 <em>heuristic</em> 이 더 정밀해질 수록 타원이 <em>goal state</em> 에 가깝게 넓어진다.</p>

<p>그리고 <em>completeness</em> 속성은, 거꾸로 말하면 <em>optimal path</em> 를 찾기 위해서 그보다 더 적은 <em>cost</em> 를 가지는 모든 <em>path</em> 를 탐색해야 함을 말한다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/a_star_optimally_efficient.png'  alt="" /></p>

<p><em>A*star</em> 알고리즘은 같은 <em>heuristic</em> 을 이용해, 가장 적은 수의 <em>node</em> 를 확장하면서 <em>optimal solution</em> 을 돌려준다. 만약 이보다 더 적은 <em>node</em> 를 확장하면서, <em>optimal solution</em> 을 돌려준다면 <em>optmial solution</em> 이 아닐 수 있다.</p>

<p>물론 효율성을 결정하는건 <em>heuristic</em> 의 연산 비용 등이 있겠지만, 적어도 <em>node</em> 수와 관련해서는 <em>A* search</em> 가 최적이다.</p>

<h3 id="agraphsearch">A* Graph Search</h3>

<pre><code>function aStarTreeSearch(problem, h)  
  fringe &lt;- priorityQueue(new searchNode(problem.initialState))
  allNodes &lt;- hashTable(fringe)

  loop
    if empty(fringe) then return failure

    node &lt;- selectFrom(fringe) // lowest f-value

    if problem.goalTest(node.state) then
      return pathTo(node)

    for successor in expand(problem, node)
      if not allNodes.contains(successor) then
        fringe &lt;- fringe + successor @ f(successor) // g + h
        allNodes.add(successor)
</code></pre>

<p>여기서 <code>fringe &lt;- fringe + successor @ f(successor)</code> 부분은 <code>fringe</code> 가 우선순위 큐이므로, 우선순위를 결정할 값으로 <em>f-value</em> 인 <code>f(successor)</code> 을 이용한다는 뜻이다.</p>

<p>그리고 <code>if not allNodes.contains(successor) then</code> 부분에서, 사실 노드를 두번째로 발견할 때 더 짧은 경로일 수 있으므로 비교하는 부분이 필요하다. 그러나 <em>heuristic</em> 이 <em>admissible</em> 하지 않으므로 <em>A* search</em> 가 최적해를 돌려주지 않을 수 있다.</p>

<p>최악의 경우 <em>A*</em> 알고리즘은 <code>O(b)</code> 의 <em>time, space complexity</em> 를 가진다. 여기서 <code>b</code> 는 <em>branching factor</em> 이란 뜻이다. 다시 말해서 <em>exponential complexity</em> 란 말이다.</p>

<p><br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/eight_puzzle_search_space.png'  alt="" /></p>

<p><em>eight-puzzle</em> 문제를 다시 보자.</p>

<p>그림에서 볼 수 있듯이, 빈 타일을 움직이다 보면 <em>initial state</em> 로 돌아올 수 있다. 만약 이 문제를 그래프로 표현하면 이미 방문한 노드를 다시 방문하고 있는지 해시테이블을 이용해 검사할 수 있다. 대신, 해시테이블을 만들고 사용하기 위한 비용이 든다. </p>

<p>반면 트리로 문제를 풀게되면, <em>exponential</em> 하게 <em>search space</em> 가 증가하기 때문에 <em>worst case</em> 에선 최적해를 찾기 위해 상당한 시간이 걸릴 수 있다.</p>

<p>한가지 더 생각해볼 문제는 <em>permutation</em> 이다. </p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/permutation.png'  alt="" /></p>

<p>만약 모든 <em>action</em> 이 <em>independent</em> 하다면, <em>solution</em> 까지의 <code>n</code> <em>action</em> 중  <code>n-1</code> <em>contour</em> 를 모두 방문해야 하므로 <code>(n-1)!</code> 의 성능이 나온다.</p>

<h3 id="goodheuristics">Good Heuristics</h3>

<p><em>heuristics</em> 이란 <em>goal node</em> 까지의 <em>estimatied value</em> 를 돌려주는 함수라고 기술적으로 정의할 수 있다.</p>

<ul>
<li><strong>heuristics</strong> are criteria, methods, or principles for deciding which among several alternative courses of action promises to be the most effeictive in order to achieve some goal</li>
</ul>

<p>그렇다면, 무엇이 <em>good heuristics</em> 일까?</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/good_heuristics.png'  alt="" /></p>

<p>평가해야할 <em>state</em> 를 줄이고, 적정 시간 내에 <em>solution</em> 을 찾을 수 있어야 한다. 간단할수록 정확도가 떨어지며, 정확할수록 복잡해진다. <em>accuracy</em> 와 관련해서는, 최적의 <em>actions</em> 을 찾아낸다는 보장은 없지만 <em>good heuristics</em> 이라면 그렇지 않은 것 보다 더 자주 <em>best course of actions</em> 를 찾을 수 있어야 한다.</p>

<ul>
<li>문제가 주어졌을때, 어떻게 좋은 <em>heuristics</em> 을 찾아낼 수 있을까?</li>
<li>이 과정을 자동화 할 수 있을까?</li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/relaxed_problem.png'  alt="" /></p>

<p><em>heuristics</em> 을 찾는 한 가지 방법은 <em>relaxed problem</em> 을 이용하는 것이다. <em>original problem</em> 에서 <em>action</em> 에 대한 <em>restriction</em> 을 좀 제거해서, 이에 대해 얻은 <em>optimal solution</em> 의 비용은 원본 문제에 대한 <em>admissible and consistent heuristic</em> 이다.</p>

<p>이는 <em>restriction</em> 이 제거되었기 때문에, 아무리 많아봐야 (<em>at most</em>) <em>original problem</em> 에 대한 <em>cost</em> 를 가지기 때문이다. 그러므로 <em>admissible</em> 하다. <em>eight-puzzle</em> 을 예로 들어보면 타일을 움직이는 <em>action</em> 에 대해 <em>adjacent</em> 또는 <em>blank</em> 조건을 버릴 수 있다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/8_puzzle_relaxed.png'  alt="" /></p>

<p>지금까지 배운내용들을 좀 정리하면</p>

<ul>
<li><p>Heuristic funciton encodes problem specific knowledge in a problem-independent way by mapping a state to a real number. This information about search states can be used to make the search more efficient</p></li>
<li><p>Greedy best-first search simply uses the heuristic function as the evaluation function. But better solution is provided by the A* algorithm. The evaluation function used by A* algorithm is simply the sum of the heuristic function for a node plus the cost of getting to thast node in the first place.</p></li>
<li><p>A* is optimal. It does not expand more nodes than absolutely necessary. But A* is not the answer to all questions, specifically when it comes to graph search.</p></li>
</ul>

<h3 id="strips">STRIPS</h3>

<p>이제부터는 <em>STRIPS</em> 에 대해 알아보자. <em>planning</em> 의 본질은 원하는 <em>goal</em> 을 얻기 위한 <em>action</em> 을 결정하는 것이다. 즉, 시스템이 이런 결정을 내릴 수 있도록 해 주는 장치가 <em>planner</em> 인데, <em>STRIPS</em> 도 플래너다. </p>

<p><a href='http://en.wikipedia.org/wiki/STRIPS' >Wikipedia: STRIPS</a> 에 의하면</p>

<blockquote>
  <p>In artificial intelligence, STRIPS (Stanford Research Institute Problem Solver) is an <strong>automated planner</strong> developed by Richard Fikes and Nils Nilsson in 1971 at SRI International. The same name was later used to refer to the formal language of the inputs to this planner. This language is the base for most of the languages for expressing automated planning problem instances in use today; such languages are commonly known as action languages.</p>
</blockquote>

<p><em>STRIPS</em> 는 어떤 <em>action</em> 을 사용할지를 결정하는 시스템이므로 <em>representation</em> 과 <em>algorithm</em> 이 필요하다. </p>

<h3 id="structuredstates">Structured States</h3>

<p><em>representation</em> 의 일부인 <em>state</em> 에 대해 먼저 알아보자. <em>state</em> 에 <em>access</em> 할때는 </p>

<ul>
<li>goal test</li>
<li>applicable actions, successor states</li>
<li>equality test, hash function</li>
<li>heuristics estimate</li>
</ul>

<p>이런 행동을 하려면 <em>standardized</em> 된 <em>action</em> <em>state</em> 의 표현 방법이 있어야 하는데, <em>STRIPS repsentation</em> 이 하는 일이 바로 이것이다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_object.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_PDDL.jpg'  alt="" /></p>

<p>먼저 <em>object</em> 를 정의하고, 이를 <em>PDDL</em> <em>(Planning Domain Definition Language)</em> 로 작성한다. <em>robot</em> 은 쉽게 오브젝트라 생각할 수 있지만 <em>piles</em>, <em>pallet</em> 은 떠오르지 않을 수 있다. </p>

<p>두 <em>object</em> 간 관계는 <em>predicates</em> 라 부른다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_predicates.jpg'  alt="" /></p>

<p>여기서 <code>?l1</code>, <code>?l2</code> 등 물음표로 시작하는 것은 변수고 그 타입은 <code>- location</code> 처럼 뒤에 나온다. <a href='https://spark-public.s3.amazonaws.com/aiplan/resources/DWR-operators.txt' >DWR-operators</a> 링크에서 예제 <em>PDDL</em> 을 볼 수 있다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/states_in_strips.jpg'  alt="" /></p>

<p>우리가 작성한 <em>language</em> <code>L</code> 에는 많은 <em>predicates</em>, <em>objects (constant symbols)</em> 이 있지만, <em>functional symbol</em> 은 없다. </p>

<blockquote>
  <p>A state in a STRIPS planning domain is <strong>a set of ground atoms</strong> of <code>L</code></p>
</blockquote>

<p>여기서 <em>atom</em> 이란 <em>a predicate</em> 고, <em>ground</em> 하다는 것은 <em>predicate</em> 과 관련된 <em>object</em> 가 <em>variable</em> 이 아니고, 구체적인 인스턴스라는 뜻이다. </p>

<p>(1) <em>ground atom</em> <code>p</code> 가 <em>state</em> <code>s</code> 내에 있을때에만 <code>p</code> 가 참이다.</p>

<p>(2) <em>literal</em> 은 <em>positive</em> 일 수도 있고, <em>negative</em> 일 수도 있는 <em>atom</em> 이다. 이 때 <em>ground literals</em> <code>g</code> 내에 있는 모든 <em>positive literal</em> 이 <code>s</code> 내에 있고, <code>g</code> 내에 있는 모든 <em>negative literal</em> 이 <code>s</code> 내에 없으면 <em>state</em> <code>s</code> 는 <em>ground literals</em> <code>g</code> 를 만족시킨다.</p>

<h3 id="structuredoperators">Structured Operators</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/operators_actinos_strips.jpg'  alt="" /></p>

<p><em>planning operators</em> 는 <em>name</em>, <em>pre-condition</em>, <em>effect</em> 로 구성되는데, <em>pre-cond</em> 과 <em>effect</em> 는 <em>literals</em> 의 집합이다.</p>

<p>그리고 <em>action</em> 은 <em>planning operator</em> 의 <em>ground instance</em> 다. </p>

<p>쉽게 말해서 <em>operator</em> 는 <em>variable</em> 가 있는 <em>predicate</em> 의 집합이고, <em>action</em> 은 거기서 변수를 <em>constant</em> (실제 <em>object</em>) 로 치환한 것이다. <em>operator</em> 가 좀 더 <em>generic</em> 하다고 보면 이해하기 쉽다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_operators.jpg'  alt="" /></p>

<p>이 <em>operator</em> 를 <em>PDDL</em> 로 표현하면</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_operators_PDDL.jpg'  alt="" /></p>

<p>이제까지 본 <em>literals</em> 를 이용해 <em>applicable</em> 한지, 그리고 어떻게 <em>state transition</em> 을 하는지 살펴보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/state_transition_applicable.jpg'  alt="" /></p>

<p><code>L+</code>, <code>L-</code> 를 각각 <em>positive</em> <em>negative literals</em> 이라고 하자.</p>

<p><em>action</em> <code>a</code> <em>state</em> <code>s</code> 에 대해 <code>a</code> 의 <em>pre-cond+</em> 가 <code>s</code> 에 있고, <em>pre-cond-</em> 가 <code>s</code> 에 없으면 <em>applicable</em> 하다.</p>

<p>그리고 <em>applicable action</em> 에 대해서 <em>state transition</em> <code>r</code> 는 <em>state</em> <code>s</code> 에서 <code>a</code> 의 <em>effect-</em> 를 빼고, 거기에 <em>effect+</em> 를 합치는 것으로 정의한다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/finding_applicable_action.jpg'  alt="" /></p>

<ul>
<li><code>A</code> 는 <em>applicable actions</em> 다. 초기에는 <em>empty</em> </li>
<li><code>op</code> 는 <em>operator</em> </li>
<li><code>precs</code> 는 <em>remaining pre-cond</em></li>
<li>4번째 인자는 <em>value</em> 로 치환된 <em>substitution</em> 리스트다.</li>
<li><code>s</code> 는 <em>state</em></li>
</ul>

<p>먼저 <code>precs+</code> 가 비었는지 검사하고, 무언가 있다면 <code>pp</code> <em>positive pre-cond</em> 를 뽑아내, <em>propositions of state</em> <code>sp</code> 에서 <em>state</em> <code>s</code> 를 하나씩 검사한다. 만약 <em>substitution</em> 이 <em>valid</em> 하면 재귀적으로 반복한다.</p>

<p>더 이상 <code>precs+</code> 가 없으면 <code>precs-</code> 를 검사하면서, 만약 <em>state</em> 가 <em>negative pre-cond</em> <code>np</code> 를 만족하지 못하면, 리턴하고 모두 만족하면 <em>variable</em> 을 모두 치환하여 <em>applicable action</em> 리스트인 <code>A</code> 에 추가한다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/applicable_actions_ex.jpg'  alt="" /></p>

<p>그림에서 왼쪽 케이스를 보면 로봇 <code>r1</code> 이 도착지점인 <code>loc2</code> 에 존재할 수 없기 때문에 <em>not valid</em> </p>

<h3 id="domainsandproblems">Domains and Problems</h3>

<p><em>classical planning</em> 은 다음의 요소로 구성된다.</p>

<ul>
<li><strong>task:</strong> find solution for planning prolem</li>
<li><strong>planning problem:</strong> </li>
</ul>

<p>(1) initial state (atoms - relation, objects) <br />
(2) planning domain (operators - name, prec, effects) <br />
(3) goal  </p>

<ul>
<li><strong>solution</strong> (plan) </li>
</ul>

<p>STRIPS 도 마찬가지로</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/STRIPS_planning_domains.jpg'  alt="" /></p>

<p>따라서 <em>STRIPS planning</em> 문제는 <em>planning domain</em>, <em>inital state</em>, <em>goal</em> 로 구성된다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/STRIPS_planning_problems.jpg'  alt="" /></p>

<p><em>DWR domain</em> 간단예제를 좀 보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_strips_ex1.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_strips_ex2.jpg'  alt="" /></p>

<p>전체 문제는 여기로 <a href='http://projects.laas.fr/planning/DWR-pb1' >DWR-pb1</a></p>

<p><br/></p>

<p>지금까지 본 것은 <em>planner</em> 에게 주어야할 <em>input</em> 이었다. 이제 <em>output</em> 인 <em>plan</em> 이 무엇인지 보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/classical_plans.jpg'  alt="" /></p>

<h3 id="statespacesearch">State-Space Search</h3>

<p>지금까지는 <em>representation</em> 에 대해 봤다. 지금부터는 STRIPS 에서 알고리즘을 어떻게 적용할지 알아보자. 기본적인 아이디어는</p>

<ul>
<li>search space is subset of state space</li>
<li>nodes correspond to world states</li>
<li>arcs correspond to state transitions</li>
<li>path in the search space correspaonds to plan</li>
</ul>

<p>따라서 <em>standard search algorithm</em> (e.g BFS, DFS, A*) 를 <em>planning problem</em> 에 적용할 수 있다. 좀 더 자세히 보자. <em>state-space planning</em> 을 <em>search problem</em> 으로 바꾸기 위해</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/state_space_to_search_problem.png'  alt="" /></p>

<p><em>initial state</em>, <em>goal</em>, 을 정하고 <em>path cost function</em> 으로 <em>action</em> 의 길이를 사용한다. <em>successor function</em> 은 </p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/reachable_successor_states.png'  alt="" /></p>

<p><em>successor state</em> 를 표시하기 위해 감마를 사용하고, 지수 위치에 있는 <code>0, m</code> 등은 몇번째 <em>succssor</em> 인지를 나타낸다. <code>U</code> 는 합집합, 유니온이다. 따라서 <em>transitive closure</em> 는 가능한 모든 합집합이다. (<em>reachable states from initial state</em>)</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/solution_existence.png'  alt="" /></p>

<p>따라서 <em>STRIPS planning problem</em> 에서는 <em>goal state</em> <code>S_g</code> 와 <em>reachable state</em> 인 <em>transitive closure</em> 의 교집합이 <em>empty</em> 가 아니어야 솔루션이 존재한다.</p>

<h3 id="forwardstatespacesearch">Forward State-Space Search</h3>

<pre><code>function fwdSearch(O, s_i, g)  
  state &lt;- s_i
  plan &lt;- &lt;&gt;

  loop
    if state.satisfies(g) then 
      return plan

    applicables &lt;- {ground instance from O applicable in state}

    if applicable.isEmpty() then 
      return failure

    action &lt;- applicable.chooseOne() ; non-deterministic
    state &lt;- r(state, action)
    plan &lt;- plan * &lt;action&gt; ; add action to plan
</code></pre>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_example_fwd_search.png'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/forward_search_properties.png'  alt="" /></p>

<p><em>forward search</em> 는 두가지 속성을 가지는데</p>

<ul>
<li><strong>sound:</strong> if the function returns a plan as a solution then this plan is indeed a solution</li>
<li><strong>complete:</strong> if there exists solution plan then there is an execution trace of the function that will return this solution plan</li>
</ul>

<h3 id="backwardstatespacesearch">Backward State-Space Search</h3>

<p><em>backward search</em> 는 <em>intial state</em> 부터 시작하는 것이 아니라 <em>goal</em> 부터 시작해서 거꾸로 진행하는 알고리즘이다. 먼저 <em>relevant</em> 와 <em>regression set</em> 의 개념부터 알아보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/relevance_regression_sets.png'  alt="" /></p>

<p><em>action</em> <code>a</code>, <em>goal state</em> <code>g</code> 에 대해 </p>

<ul>
<li><code>g</code> 와 <code>effect(a)</code> 의 교집합이 <em>empty</em> 가 아니고</li>
<li><code>g+</code> 와 <code>effect-(a)</code>, <code>g-</code> 와 <code>effect+(a)</code> 의 교집합이 <em>empty</em> 이면</li>
</ul>

<blockquote>
  <p><code>a</code> is relevant for <code>g</code></p>
</blockquote>

<p>이 때 <em>releavant action</em> <code>a</code> 에 대해 <code>g</code> 의 <em>regression set</em> 은 </p>

<p><code>r^(-1) (g, a) = (g - effect(a)) U precond(a)</code> 로 정의한다. <em>relavant action</em> 의 <em>effect</em> 를 제거하고, 그의 <em>pre-condition</em> 을 넣으면 <em>previous state</em> 가 되기 때문이다. 예제를 좀 보면</p>

<pre><code>(define (problem random-pbl1)
  (:domain random-domain)
  (:init
     (S B B) (S C B) (S A C)
     (R B B) (R C B))
  (:goal (and (S A A))))

(define (domain random-domain)
  (:requirements :strips)
  (:action op1
    :parameters (?x1 ?x2 ?x3)
    :precondition (and (S ?x1 ?x2) (R ?x3 ?x1))
    :effect (and (S ?x2 ?x1) (S ?x1 ?x3) (not (R ?x3 ?x1))))
  (:action op2
    :parameters (?x1 ?x2 ?x3)
    :precondition (and (S ?x3 ?x1) (R ?x2 ?x2))
    :effect (and (S ?x1 ?x3) (not (S ?x3 ?x1)))))  
</code></pre>

<p>여기서 <em>relevant action</em> 은 <code>(op1 A A A)</code>, <code>(op1 A A C)</code>, <code>(op1 A B A)</code> 다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/regression_function.png'  alt="" /></p>

<p>따라서 <em>backward search</em> 알고리즘을 이용하면, <em>state-space planning</em> 을 <em>search problem</em> 으로 바꿀때는</p>

<ul>
<li>initial state <code>g</code></li>
<li>goal test: <code>s_i</code> satisfies <code>s</code></li>
<li>path cost function: length of actions</li>
<li>successor function: <code>r^-1 (s)</code></li>
</ul>

<p>예제를 좀 보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/regression_with_operators.png'  alt="" /></p>

<h3 id="summary">Summary</h3>

<p><em>STRIPS</em> 세션을 정리하면</p>

<ul>
<li>STRIPS representation provides a standardized way of representing the <strong>internal structure of states</strong>, namely a sets of ground atoms. So we have objects thar are related by some relations, and sets of these atoms describe what the world states look like.</li>
<li>define interal structure of operators look like. negative effects, positive effects.</li>
<li>define planning domains (initial, goal state), problem using PDDL</li>
<li>to solve planning problem, we can use forward, backward search. Buy they are actually inefficient</li>
</ul>

<p>따라서 다음시간엔 <em>forward, backward</em> 보다 더 효율적인 알고리즘을 배운다.</p>

<h3 id="refs">Refs</h3>

<p>(1) <strong>Artificial Integelligence Planning</strong>, by Dr.Gerhard Wickler, Prof. Austin Tate <br />
(2) <a href='http://imgs.xkcd.com/comics/ai.png' >xkcd image</a> <br />
(3) <a href='http://en.wikipedia.org/wiki/STRIPS' >Wikipedia - STRIPS</a>  </p>]]></description><link>http://1ambda.github.io/ai-planning-2/</link><guid isPermaLink="false">03874979-cc59-4b5f-b9b1-eccfefd1ccc2</guid><category><![CDATA[coursera]]></category><category><![CDATA[artificial intelligence]]></category><category><![CDATA[STRIPS]]></category><category><![CDATA[heuristic]]></category><category><![CDATA[forward-search]]></category><category><![CDATA[backward-search]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 18 Jan 2015 00:26:31 GMT</pubDate></item><item><title><![CDATA[AI Planning 1, Intro]]></title><description><![CDATA[<p><img src='http://www.jcjones.com/Portals/96864/images/IT%20strategic%20planning.png'  alt="" /></p>

<p><br/></p>

<p><em>planning</em> 이란</p>

<ul>
<li>explicit deliberation process that chooses and organizes actions by anticipating their outcomes</li>
<li>aims at acheving some <strong>pre-stated objecives</strong></li>
</ul>

<p>결국 <em>AI planning</em> 이란</p>

<blockquote>
  <p>computational study of this deliberation process</p>
</blockquote>

<p><br/></p>

<p>이런 관점에서 볼 때 <em>AI planning</em> 을 연구하는 이유는</p>

<ul>
<li><p><strong>scientific goal of AI:</strong> <em>understand inteligence</em>. planning is an important component of rational behaviour</p></li>
<li><p><strong>engineering goal of AI:</strong> <em>build intelligent entitie</em> which are choosing and organizing actions for autonomous intelligent machines</p></li>
</ul>

<p><br/></p>

<p><em>planning</em> 을 크게 <strong>domain-specific</strong>, <strong>domain-independent</strong> 로 분류할 수 있다.</p>

<ul>
<li><strong>domain-specific planning:</strong> use specific representations and techniques adapted to each problem. </li>
</ul>

<p>중요한 도메인으로 path and motion, perception, manipulation, commuication planning 등이 있다.</p>

<ul>
<li><strong>domain-independent planning:</strong> use generic representations and techniques. exploit commonalities to all forms of planning. leads to general understanding of planning</li>
</ul>

<blockquote>
  <p><em>domain-independent planning</em> complements <em>domain-specific planning</em> </p>
</blockquote>

<p><br/></p>

<h3 id="conceptualmodelforplanning">Conceptual Model for Planning</h3>

<p>모델로 <em>state-transition system</em> 을 사용하는데, 이 시스템은 <code>(S, A, E, r)</code> 로 구성된다. </p>

<ul>
<li><code>S = {s1, s2,  ... }</code> is a finite or recursively enumerable set of states</li>
<li><code>A = {a1, a2,  ... }</code> is a finite or recursively enumerable set of actions</li>
<li><code>E = {e1, e2,  ... }</code> is a finite or recursively enumerable set of events</li>
<li><code>r: S x (A u E) -&gt; 2^S</code> is a state trasition function</li>
<li>if <code>a</code> in <code>A</code> and <code>r(s, a)</code> is <strong>not empty</strong>, <code>a</code> is applicable in <code>s</code></li>
</ul>

<p><em>state trasition function</em> 은 상태 <code>S</code> 와 액션 <code>A</code> 또는 이벤트 <code>E</code> 를 받아, 가능한 모든 상태 <code>2^S</code> 를 만든다.</p>

<p><em>state trasition system</em> 은 그래프를 이용해서 표현할 수 있다. <code>G = (N, E)</code> 에서 <em>node</em> <code>N</code> 은 상태를, <em>edge</em> <code>E</code> 는 <em>state transition</em> 을 나타낸다.</p>

<p><em>state trasition system</em> 은 모든 가능한 상태를 표현하는 좋은 방법이다. 그러나 우리가 실제로 원하는건 <em>plan</em> 이다. 여기서 <em>plan</em> 이라 하면 주어진 특정 <em>state</em> 에서 시작해서, 원하는 <em>objective</em> 를 얻기까지의 <em>action</em> 을 말한다.</p>

<p><em>objective</em> 는 조건을 만족하는 특정 상태 <code>s</code> 나, 상태의 집합이 될 수 있다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/plan_execution.png'  alt="" /></p>

<p><em>planning</em> 문제를 풀기 위해 <em>plan execution</em> 을 이용하는 경우가 많다. <em>planner</em> 는 <em>state transition system</em> <code>sigma</code> 와 <em>initial state</em>, <em>objectives</em> 를 받아 <em>plan</em> 을 만들고, <em>controller</em> 가 이와 <em>current state</em> (<em>observation</em>) 을 받아 가능한 <em>action</em> 을 만든다. <em>system</em> 은 <em>action</em> 과 외부의 <em>event</em> 에 의해 변화한다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/dynamic_planning.png'  alt="" /></p>

<p>그러나 많은 경우 <em>model</em> 과 현실의 <em>system</em> 이 일치하지 않기 때문에, <em>dynamic planning</em> 이란 방법을 사용한다.</p>

<p>만약 <em>controller</em> 가 <em>real system</em> 과 <em>model</em> 이 다른 경우를 인식해서 <em>planner</em> 에게 <em>execution status</em> 를 넘겨주어 새로운 <em>plan</em> 을 만들도록 한다. 이걸 <em>plan revision</em> 이라 부른다.</p>

<h3 id="searchproblem">Search Problem</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/search_problem.png'  alt="" /></p>

<p><em>search problem</em> 의 4가지 요소는 </p>

<ul>
<li>initial state</li>
<li>successor function</li>
<li>goal</li>
<li>path cost</li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/problem_formulation.png'  alt="" /></p>

<p>여기서 <em>static</em> 이란 말은 <em>no-event</em> 라는 뜻이다. <em>implicit time</em> 은 <em>activity</em> 의 <em>duration</em> 을 고려하지 않는다는 뜻이다.</p>

<h3 id="searchnode">Search Node</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/search_node.png'  alt="" /></p>

<p><em>search problem</em> 을 풀기 위한 알고리즘을 보기 전에, 어떻게 표현할 것인지를 먼저 이야기 하자. <em>search node</em> 의 구성 요소는</p>

<ul>
<li>state</li>
<li>parent node</li>
<li>action</li>
<li>path cost</li>
<li>depth</li>
</ul>

<p>이제 <em>general tree search algorithm</em> 을 보면</p>

<pre><code>function treeSearch(problem, strategy)  
  fringe &lt;- { new searchNode(problem.initialState) }

  loop
    if empty(fringe) then return failure

    node &lt;- selectFrom(fringe, strategy)

    if problem.goalTest(node.state) then
      return pathTo(node)

    fringe &lt;- fringe + expand(problem, node)
</code></pre>

<p>여기서 <code>problem</code> 은 <em>search problem</em> 으로, 위에서 언급 했듯이 <em>initial state</em>, <em>successor function</em>, <em>goal</em>, <em>path cost</em> 를 포함한다.</p>

<p><code>fringe</code> 는 아직 방문하지 않은 노드의 집합이고 마지막 부분에서 <code>expand</code> 함수는 <em>successor function</em> 을 적용해서 새로운 노드를 돌려준다. 이 과정을 <code>fringe</code> 가 비거나, 원하는 노드를 찾을때 까지 반복한다.</p>

<p>재밌는 사실은 <em>search graph</em> 가 유한하더라도 <em>search tree</em> 가 무한할 수 있다. 노드가 두개이면서 <em>bi-directed</em> 인 그래프를 생각해 보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/search_strategy.png'  alt="" /></p>

<p>위에서 본 <em>strategy</em> 는 <em>successfor function</em> 적용을 스케쥴링하는 요소다.</p>

<ul>
<li>selects the next node to be expanded from the fringe</li>
<li>determines the order in which nodes are expanded</li>
<li><strong>aim:</strong> produce a goal state as quickly as possible</li>
</ul>

<p><em>strategy</em> 가 <em>deterministic</em> 이면, 알고리즘도 <em>deterministic</em> 이라 볼 수 있다. 반대로 <em>strategy</em> 가 없으면 <em>non-deterministic</em> 이다.</p>

<p>대부분의 <em>search tree</em> 는 상당히 크다. 요즘 나오는 컴퓨터 메모리에도 올리기 부담스러울 정도로. 따라서 <em>strategy</em> 가 메모리에 올라갈 <em>tree</em> 부분을 결정하고, 그에 따라 알고리즘이 실패할지, 성공할지를 결정하므로 매우 중요하다.</p>

<h3 id="exampleproblem">Example Problem</h3>

<ul>
<li><strong>Sliding-Block Puzzle</strong> (<em>toy problem</em>)</li>
<li><strong>N-Queens</strong> (<em>toy problem</em>)</li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/DWR_domain.png'  alt="" />
<img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/DWR_state.png'  alt="" />
<img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/DWR_action.png'  alt="" />
<img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/DWR_system.png'  alt="" /></p>

<h3 id="context">Context</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/o_plan_agent.png'  alt="" /></p>

<p><img src='https://spark-public.s3.amazonaws.com/aiplan/resources/AI-Planners-Chronology-1990-AI-Magazine.png'  alt="" /></p>

<p align="center">AI Planning, Coursera</p>

<p>그림의 윗 부분을 보면 <em>AI planning</em> 은 3가지 문제로부터 출발한 것을 볼 수 있다.</p>

<ul>
<li>Studies of Human Problem Solving</li>
<li>Operations Research</li>
<li>Theorem Proving</li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/practical_ai_planner.png'  alt="" />
<img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/nonlin.png'  alt="" />
<img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/o_plan.png'  alt="" /></p>

<p><em>O-Plan</em> 은 유닉스 시스템 어드민의 역할을 수행했다고 한다. 쉘 스크립트를 만들고, 볼륨을 삭제하거나 추가하는 등</p>

<p><em>practical AI planner</em> 의 특징으로는</p>

<ul>
<li>hierarchical task network (HTN) planning</li>
<li>partial order planning (POP)</li>
<li>rich domain model</li>
<li>detailed constraint mgmt, simuilations and analyses</li>
<li>intergration with other systems (UI, DB, spreadsheets, etc)</li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/planning_area_tech.png'  alt="" /></p>

<h3 id="coursereading">Course Reading</h3>

<p>(1) <a href='http://aaaipress.org/ojs/index.php/aimagazine/article/download/833/751' >Review of AI Planners to 1990</a>  </p>

<p>Hendler, J.A., Tate, A. and Drummond, M. (1990) “AI Planning: Systems and Techniques”, AI Magazine Vol. 11, No. 2, pp.61-77, Summer 1990, AAAI Press. </p>

<p>(2) <a href='http://www.aiai.ed.ac.uk/project/ix/documents/2003/2003-luc-tate-oplan-web.pdf' >O-Plan Paper</a>  </p>

<p>Tate, A. and Dalton, J. (2003) “O-Plan: a Common Lisp Planning Web Service”, invited paper, in Proceedings of the International Lisp Conference 2003, October 12-25, 2003, New York, NY, USA, October 12-15, 2003. (4 pages) </p>

<h3 id="refs">Refs</h3>

<p>(1) <a href='http://www.jcjones.com/Portals/96864/images/IT%20strategic%20planning.png' >Planning Image</a> <br />
(2) <a href='https://spark-public.s3.amazonaws.com/aiplan/resources/AI-Planners-Chronology-1990-AI-Magazine.png' >AI Planning History Image</a>  </p>]]></description><link>http://1ambda.github.io/ai-planning-1/</link><guid isPermaLink="false">4a959a91-fe5a-47d6-b77b-f5b6b976928a</guid><category><![CDATA[artificial intelligence]]></category><category><![CDATA[planning]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 17 Jan 2015 13:53:19 GMT</pubDate></item><item><title><![CDATA[Intractability]]></title><description><![CDATA[<p><img src='http://simonsoftware.se/xkcdsw/comics/np_complete.png'  alt="" /></p>

<ul>
<li>What is a general-purpose computer?</li>
<li>Are there limits on the power of digital computers?</li>
<li>Are there limits on the power of machines we can build?</li>
</ul>

<p>컴퓨터 과학자들이 <em>computation</em> 에 관해 질문해 온 것들이다. 이 문제에 답하기 위해 <em>computation model</em> 을 좀 살펴보자.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5WXdJalozUVRNd1lUTTBJV0xqSlRNNDBpTmpsek10TVdaM0VUTHpVRE1tWkRPbVoyTHdRVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>긴 테이프가 있고, 기계는 테이프를 하나씩 읽어 <code>0</code>인지 <code>1</code> 인지 판별한다. 여기서 읽는것 뿐만 아니라 출력까지 가능하면 <em>turing machine</em> 이 된다. 일종의 <em>universal computation model</em> 이다.</p>

<p><img src='http://physics.kenyon.edu/coolphys/thrmcmp/turing.jpg'  alt="" /></p>

<p align="center">(<a href='http://physics.kenyon.edu/' >http://physics.kenyon.edu</a>)</p>

<p>근데 놀랍게도 이것보다 더 진보한 연산 모델이 있느냐? 라는 질문에 대해 <strong>없음</strong> 이란 연구 결과가 나왔다고 한다.</p>

<blockquote>
  <p><strong>Church-Turing thesis:</strong></p>
  
  <p>Turing machines can compute any function that can be computed by a physically harnessable process of the natural world.</p>
</blockquote>

<p>여기서 <em>thesis</em> 인 이유는 증명이 아니기 때문이다. <em>mathmatical theorem (정리)</em> 가 아니다. 결국 이것이 의미하는 바는</p>

<ul>
<li>No need to seek more powerful machines or languages</li>
<li>Enables rigorous study of computation (in this universe)</li>
<li>Turing machine is a simple and universal model of computation</li>
</ul>

<p><em>Church-Turing thesis</em> 에 대해 80 년동안이나 반례가 발견되지 않았다. 그리고 수 많은 <em>computation model</em> 이 발견되었지만 모두 <em>turing machine</em> 과 동일한 것으로 밝혀졌다. (lambda caculus, URM, SKI 등)</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWWtOR1owa1ROMFkyTjVnVEx6WWpaNTB5TWxWek10VVRPaFZXTDRVek16Z1RPd1UyTHlRVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>일반적으로 <em>useful algorithm</em> 이란 모든종류의 입력 에 대해 <em>polynomial time</em> <code>aN^b</code> 시간 내에 풀 수 있는 것을 <em>useful algorithm</em> 이라 말한다. </p>

<p><em>polynomial time</em> 알고리즘은 대부분 작은 <code>a, b</code> 를 가지기 때문에 다양한 문제로 적용하는것도 가능하다. 그러나 <code>a, b</code> 가 큰 경우 풀수 없는것과 마찬가지 일때도 있다.</p>

<blockquote>
  <p>Exponential growth dwarfs technological change</p>
</blockquote>

<p>유용하지 않은 알고리즘의 예로, <code>N</code> 지점에 대한 <em>TSP</em> 는 <em>brute force</em> 를 이용하면 <code>N!</code> 이다.</p>

<p>얼마나 유용하지 않은가를 좀 더 생각해보자. 만들 수 있는 가장 큰 병렬 슈퍼컴퓨터를 가정 해보면</p>

<ul>
<li>Suppose you have a giant parallel computing device</li>
<li>With as many processors as eletron in the universe</li>
<li>And each processor has power of today's supercomputers</li>
<li>ANd each processor works for the life of the universe</li>
</ul>

<p>1000 도시의 <em>TSP</em> 를 <em>brute force</em> 로 풀려면, 이 병렬 슈퍼컴퓨터를 우주의 일생동안 돌려도 불가능하다.</p>

<p><code>1000! &gt; 10^1000 &gt; 10^79 * 10^13 * 10^17</code></p>

<p>이런 이유에서 어떤 문제가 <em>polynomial time</em> 내에 풀 수 없으면 <em>intractable</em> 하다고 말한다.</p>

<p>결국 우리가 풀 수 있는 문제는 <em>poly-time algorithm</em> 이 있는 경우이며, 어떤 문제가 이런 <em>poly-time algorithm</em> 을 가질까? 그건 쉽지 않다. 연구중이라고 함.</p>

<p>연구된 바로는 두 종류의 문제가 <em>exponential time</em> 일 것으로 본다.</p>

<ul>
<li>Given a constant-size program, does it half it at most K steps? (input size = <code>c + lgK</code>)</li>
<li>Given <code>N</code>-by-<code>N</code> checkers board position, can the first player foce a win?</li>
</ul>

<h3 id="fourfundamentalproblems">Four fundamental problems</h3>

<p>(1) <strong>LSOLVE:</strong> Given a system of <strong>linear equations</strong>, find a solution</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDT3hVR1ppRkRaeFlETmhaV0x3TVdPaTF5TW1Sek10Z1ROMFlUTG1GVE16UVdZbUYyTDJRVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>가우시안 소거법으로 <em>N-by-N</em> 시스템에서 <code>N^3</code> 시간 안에 해결된다.</p>

<p>(2) <strong>LP:</strong> Given a system of <strong>linear inequalities</strong>, find a solution</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWjRFbVl4STJZNWtET2pGV0xsUkRNaTFDTmpGek10a1RZbFZXTDNrek5sWlRZd1l6TDRRVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><em>Ellipsoid</em> 알고리즘을 이용하면 <em>poly-time</em></p>

<p>(3) <strong>ILP:</strong> Given a system of <strong>linear inequalties</strong>, find <code>0-1</code> solution</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWjFNRE4yWVdNaFZUWnpRV0xrSnpZaTF5TXprek10WUdOaEpUTDRRak5sZGpObGx6THdVVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>no <em>poly-time</em> algorithm known. 있을거 같긴 한데 모른다고 함</p>

<p>(4) <strong>SAT:</strong> Given a system of <strong>boolean equations</strong>, find a binary solution</p>

<p>no <em>poly-time</em> algorithm known 이것도 있을거 같긴 한데 모른다고 함</p>

<h3 id="searchproblems">Search Problems</h3>

<blockquote>
  <p>Given an instance <code>I</code> of a problem, find a solution <code>S</code> or report none exists</p>
</blockquote>

<p>답이 있거나, 없음을 말해줘야 하는데 이를 위해서 효율적으로 (<em>poly-time</em>) <code>S</code> 가 정답인지 검사할 수 있어야 한다.</p>

<p>위에서 본 <em>LSOLVE</em>, <em>LP</em>, <em>ILP</em>, <em>SAT</em> 문제 같은 경우 정답이 있으면 대입해서 <em>poly-time</em> 내에 검증할 수 있으므로 <em>search problem</em> 이다.</p>

<p><em>factor problem</em> 도 <em>search problem</em> 이다. 주어진 <code>n</code> 비트 정수에 대해서, <em>nontrivial factor</em> 인지 아닌지는 나눠보면 되니까.</p>

<p>즉 <em>search problem</em> 에서는 답을 누군가 제공할때 그것이 답인지 아닌지를 <em>poly-time</em> 으로 검사할수 있냐 없냐가 중요하다.</p>

<h3 id="np">NP</h3>

<ul>
<li><strong>NP:</strong> is the class of all search problems. (class definition limits <strong>NP</strong> to yes-no problem)</li>
</ul>

<p>앞에서 본 <em>LSOLVE</em>, <em>LP</em>, <em>ILP</em>, <em>SAT</em>, <em>FACTOR</em> 모두 <strong>NP</strong> 다.</p>

<ul>
<li><strong>P:</strong> is the class of search problems solvable in <em>poly-time</em></li>
</ul>

<p><em>LSOLVE</em>, <em>LP</em>, <em>SORT</em>, <em>STCONN</em> 의 문제는 모두 <strong>P</strong> 다.</p>

<p>즉 답을 <em>poly-time</em> 내에 검증이 가능하면 <strong>NP</strong> 고, 거기에 답을 <em>poly-time</em> 내에 찾는것이 가능하면 <strong>P</strong> 란 이야기. <strong>P</strong> 가 중요한 이유는, 현실적으로 계산 가능한 문제이기 때문이다. </p>

<p>이론적으로는 <code>1010401 * N ^(10^23)</code> 도 계산 가능하다고 본다. <del>음!?!</del></p>

<h3 id="nondeterminism">Nondeterminism</h3>

<blockquote>
  <p>Nondeterministic machine can <strong>guess</strong> the desired solution</p>
</blockquote>

<p><em>regex</em> 의 패턴매칭을 구현할때 했었던 <em>NFA</em> 처럼 일종의 <em>nondeterministic machine</em> 이 있다 하고, 이 기계가 답을 찾아준다고 하자. 예를 들면 이런 느낌이다.</p>

<pre><code class="java">int[] a = new int[N];  
</code></pre>

<p>자바에선 <code>0</code> 으로 초기화 되는데, <em>nondeterministic machine</em> 을 이용하면 답으로 초기화 해주는 것이다.</p>

<p><em>DFA</em> 를 <em>NFA</em> 로 바꾸었듯이, 같은 입력에 대해 다수의 상태를 가지도록 함으로써 튜링 머신(이하 <em>TM</em>) 도 쉽게 <em>nondeterministic</em> 로 만들 수 있다. </p>

<p>그러면 이제 <strong>NP</strong> 가 의미하는 바를 확실히 이해할 수 있다. <em>nondeterministic polynomial time</em>, 다시 말해 <em>search problem</em> 이 <em>nondeterministic TM</em> 위에서 <em>poly-time</em> 내에 풀 수 있다는 것이다.</p>

<p>(1) <em>nondeterministic TM</em> 이 답을 제공한다 <br />
(2) <em>search problem</em> 은 <em>poly-time</em> 내에 답인지 아닌지 판별이 가능하다.</p>

<p>조금 더 이해를 위해 <a href='http://ko.wikipedia.org/wiki/P-NP_%EB%AC%B8%EC%A0%9C' >위키</a>를 인용하면</p>

<blockquote>
  <p>P는 결정론적 튜링 기계를 사용해 다항 시간 내에 답을 구할 수 있는 문제의 집합이고, NP는 비결정론적 튜링 기계를 사용해 다항 시간 내에 답을 구할 수 있는 문제의 집합이다. 여기에서 결정론적 튜링 기계에 사용한 프로그램을 비결정론적 튜링 기계에 적용할 수 있으므로, P는 NP의 부분집합이 된다. 하지만 여기에서 P와 NP가 같은 집합인지, 아니면 P가 NP의 진부분집합인지는 아직 밝혀지지 않았다. 현재 2000년에 클레이 수학연구소가 100만 달러를 걸었다.</p>
</blockquote>

<h3 id="extendedchurchturingthesis">Extended Church-Turing Thesis</h3>

<p>이제까지 나온바를 정리하면</p>

<ul>
<li><strong>NP:</strong> search problems solvable in <em>poly-time</em> on a <strong>nondetermimistic TM</strong></li>
</ul>

<p>그리고 <em>extended Church-Turing thesis</em> 에 의하면</p>

<ul>
<li><strong>P:</strong> search problems solvable in <em>poly-time</em> in the <strong>natural world</strong></li>
</ul>

<p>따라서 </p>

<ul>
<li>To make future computers more efficient, suffices to focus on impoving implementation of existing design</li>
</ul>

<h3 id="pvsnp">P vs NP</h3>

<p><strong>P</strong> = <strong>NP</strong> 일까? 이게 사실이라면, <em>search problem</em> 에서 <em>exponential time</em> 의 <em>brute force</em> 방법을 사용하지 않아도 된다. <em>poly-time</em> 알고리즘이 있다는 이야기니까.</p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/P_np_np-complete_np-hard.svg/800px-P_np_np-complete_np-hard.svg.png'  alt="" /></p>

<p align="center">(<a href='http://commons.wikimedia.org/' >http://commons.wikimedia.org/</a>)</p>

<p><code>P = NP</code> 일 경우 <em>nondeterministic TM</em> 이 별 도움이 안된단 이야기고, <code>P != NP</code> 일 경우, </p>

<blockquote>
  <p>If no, Would learn something fundamental about our universe</p>
</blockquote>

<p>대부분의 학자들은 <code>P != NP</code> 라 믿는다. 이는 <em>non-deterministic TM</em> 이 이전까지 우리가 사용했던 머신보다 더 강력하기 때문이라고 한다. 즉, 문제를 해결하기 위해 필요한 머신의 성능이 훨씬 좋아야 하므로 <code>NP</code> 가 <code>P</code> 와 같진 않을거라는 이야기</p>

<h3 id="classifyingproblems">Classifying Problems</h3>

<ul>
<li><strong>SAT problem:</strong> Given a system fo boolean equations, find a solution</li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWXpFVE81TUdNMWdUTjFVVExqUnpOaTFTTWtKek10Z0RPNU1UTGhCRFp3QVRabVp6THlVVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><code>n</code> 변수의 <em>SAT</em> 문제를 <em>exhausitve search</em> 로 풀면, <code>2^n</code> 의 모든 경우를 다 시도 해봐야 한다. 더 빠른, <em>poly-time</em> 알고리즘으로 풀수는 없을까?</p>

<p>슬프게도 많은 학자들이 연구해 왔지만, 아직까지 발견되지 않았고 대부분의 학자들이 <em>SAT</em> 문제가 <strong>NP</strong> 라는 것에 동의한다. 증명되지 않았으므로 일종의 가정인데, 이 가정을 이용해 <em>reduction</em> 을 해 보자. 그럼 <em>intractable</em> 한 알고리즘을 찾아낼 수 있다.</p>

<blockquote>
  <p>Problem <code>X</code> <strong>poly-time reduces</strong> to problem <code>Y</code> If <code>X</code> can be solved with:</p>
  
  <ul>
  <li>Polynomial number of standard computational steps</li>
  <li>Polynomial number of calls to <code>Y</code></li>
  </ul>
</blockquote>

<p>따라서 <em>SAT</em> 를 문제 <code>Y</code> 로 <em>poly-time reduction</em> 가능하면, <code>Y</code> 는 (거의) <em>intractable</em> 이다. </p>

<ul>
<li>If <code>X</code> cannot be solved in <em>poly-time</em>, then <code>Y</code> connot be solved in *poly-time</li>
<li>If <code>Y</code> can be solved in <em>poly-time</em>, then so can <code>X</code></li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5WTNFRE0zSXpOd1lHTWpsVEx6RWpZNTB5WTBjek10TW1aeVFXTGpKRE40QXpZa056TDJZVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWXpnalkzWXpZbWRqTmpKVEx6SW1NaTFTTmlSMk10a2pZMlVXTDVVV1p4VVRabUoyTDVZVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<h3 id="npcompleteness">NP-Completeness</h3>

<blockquote>
  <p>An <em>NP</em> problem is <strong>NP-complete</strong> if all problems in NP <em>poly-time reduce</em> to it</p>
</blockquote>

<p>즉 모든 <em>NP</em> 문제가 어떤 문제 <code>A</code> 로 <em>poly-time reduction</em> 이 되면 <code>A</code> 는 <em>NP-complete</em> 라는건데, <em>Cook, 1971</em> 에 의해 <em>SAT</em> 가 <em>NP-complete</em> 임이 증명되었다.</p>

<p>증명을 간단히 요약하면</p>

<ul>
<li>Convert <em>non-deterministic TM</em> notation to <em>SAT</em> notation</li>
<li>If you can solve <em>SAT</em>, you can solve any problem in <em>NP</em></li>
</ul>

<p>일종의 <em>reduction</em> 이다.<em>SAT</em> 인스턴스를 <em>poly-time</em> 으로 풀면 <em>non-deterministic TM</em> 문제로 풀 수 있는 <em>NP</em> 문제도 <em>poly-time</em> 으로 풀수 있게된다. </p>

<ul>
<li><em>SAT</em> 를 <em>poly-time</em> 으로 풀면 <code>P = NP</code></li>
<li><em>NP</em> 문제에 대해 <em>poly-time</em> 알고리즘이 없으면 <em>SAT</em> 에 대해서도 없다.</li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWWloVE0zTVdPMlVUWTNNVExoTmpNaTFTWjNJMk10TVdPMVFUTDRJR01sVjJNMEF6TDBjVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5TmxKVE16VURaa2hqWXdVVExqVkRaNTBDTmlWMk10SVdZaVpXTHpRVE94WXpNbGR6TDJjVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>많은 문제가 <em>NP-complete</em> 다.</p>

<h3 id="copingwithintractability">Coping With Intractability</h3>

<p>암호학 같은 경우 <em>intractability</em> 가 널리 쓰인다. <em>RSA</em> 의 경우 </p>

<ul>
<li>To use: multiply two <code>n</code>-bit integers (<em>poly-time</em>)</li>
<li>To break: factor a 2 <code>n</code>-bit integer (unlikely <em>poly-time</em>)</li>
</ul>

<p>근데 1994년에 양자 컴퓨터로는 <code>n</code> 비트 <em>FACTOR</em> 문제가 <code>n^3</code> 안에 풀릴 수 있다는 가설이 제기되었다. 그럼 실 세계에서는 <code>P</code> 만 <em>poly-time</em> 으로 풀린다는 <em>extended Church-Turing thesis</em> 는..</p>

<p>아무튼 <em>intractability</em> 를 해결하기 위해서 쓸 수 있는 몇 가지 테크닉이 있다.</p>

<p>(1) Solve arbitrary instances of the problem</p>

<p><em>specialc cases</em> 는 <em>tractable</em> 일 수 있다. 예를 들어 <code>2-SAT</code> 은 <em>linear time</em> 이다.</p>

<p>(2) Solve the problem to optimality</p>

<p><em>heuristic</em> 을 이용해 알고리즘을 만드는 방법도 있다. 최적은 아니지만 좋은 결과를 낼 수도 있기 때문이다. (TSP assigment heuristics)</p>

<p>그리고 대부분 좋은 결과를 돌려주는 <em>approximation algorithm</em> 을 이용할 수도 있다. <code>MAX-3SAT</code> 은 <code>87.5%</code> 는 보장한다고 함.</p>

<p>(3) Solve the problem in <em>poly-time</em></p>

<p>Complexity theory deals with worst case behavior</p>

<h4 id="hamiltonpath">Hamilton path</h4>

<p>해밀턴 경로의 경우 모든 정점을 한번씩 방문해야 하는데, <em>NP-complete</em> 문제라고 한다. 오일러 경로(<em>edge</em>) 는 쉽다고 함. </p>

<p><em>exponential time</em> 으로 구현할 수 있다. 일반 <em>DFS</em> 와 다른점은 <em>clean up</em> 부분.</p>

<pre><code class="java">public class HamiltonPath  
{
    private boolean[] marked; // vertices on current path
    private int count = 0; // number of Hamiltonian paths

    public HamiltonPath(Graph G)
    {
        marked = new boolean[G.V()];
        for (int v = 0; v &lt; G.V(); v++)
            dfs(G, v, 1);
    }

    //depth is the length of current path (depth of recursion)
    private void dfs(Graph G, int v, int depth)
    {
        marked[v] = true;
        if (depth == G.V()) count++;
        for (int w : G.adj(v))
            if (!marked[w]) dfs(G, w, depth+1); //backtrack if w is already part of path
        marked[v] = false; // clean up
    }
}
</code></pre>

<h3 id="summary">Summary</h3>

<ul>
<li><strong>P:</strong> Class of search problems solvable in <em>poly-time</em></li>
<li><strong>NP:</strong> Clas of all search problems, some of which seem wickedly hard</li>
<li><strong>NP-complete:</strong> Hardest problems in <em>NP</em></li>
<li><p><strong>Intractable:</strong> Problem with no <em>poly-time</em> algorithm</p></li>
<li><p>A <em>poly-time</em> algorithm for an <strong>NP-complete</strong> problem would be a stunning breakthrough (a proof that <code>P = NP</code>)</p></li>
<li>You will confront <strong>NP-complete</strong> problems in your career</li>
<li>Safe yo assume that <code>P != NP</code> and that such problem are intractable</li>
<li>Identify these situations and proceed accordingly</li>
</ul>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='http://www.programering.com/a/MDN4QTMwATQ.html' >Lecture note: intractability</a> <br />
(4) <a href='http://simonsoftware.se/xkcdsw/comic.php?id=44' >xkcd image</a> <br />
(5) <a href='http://physics.kenyon.edu/coolphys/thrmcmp/newcomp.htm' >Turing machine image</a> <br />
(6) <a href='http://ko.wikipedia.org/wiki/P-NP_%EB%AC%B8%EC%A0%9C' >Wikipedia: P-NP 문제</a>  </p>]]></description><link>http://1ambda.github.io/intractability/</link><guid isPermaLink="false">720fd787-5da7-4853-9742-ecf8045586a3</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[intractability]]></category><category><![CDATA[P vs NP]]></category><category><![CDATA[NP completeness]]></category><category><![CDATA[search problem]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 31 Dec 2014 18:47:29 GMT</pubDate></item><item><title><![CDATA[Linear Programming]]></title><description><![CDATA[<p><img src='https://d262ilb51hltx0.cloudfront.net/max/800/1' *WBYODRJUgH8h_QEPnaWS-w.png" alt="" /></p>

<ul>
<li><strong>linear programming:</strong> problem-solving model for optimal allocation of scarce resources, among a number of competing activities that <strong>encompasses</strong></li>
</ul>

<p><em>maxflow</em>, <em>MST</em>, <em>shortest paths</em>, <em>assigment</em>, <em>Ax = b</em>, <em>2-person zero-sum games</em> 등이 있다.</p>

<p>다시 말해서, <em>constraints</em> 를 지키면서 특정 값을 <em>maximize</em> 하는 문제다. 따라서 주어진 문제를 아래의 형태로 <em>reduction</em> 해야 한다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDT3lZak4xUWpNM2NEWmhkVEw1a2pZaDFDT3dNek10RTJONFVXTGtGV1ozVXpNeE0yTDFNak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p algin="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<ul>
<li>fast commercial colvers available</li>
<li>widely applicable problem-solving model</li>
<li>key subroutine for integer programming solves</li>
</ul>

<p>이므로 중요하다고 한다.</p>

<h3 id="brewersproblem">Brewer's Problem</h3>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTWhKRE1pRldPM0lHTmlOV0x6a1RZaDFTTXpJMk10RVdZM1FXTDNJMk00SVROMkUyTDRFak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>양조장에서 맥주 <code>ale</code>, <code>beer</code> 를 생산하는데, 재료인 <code>corn</code>, <code>hops</code> <code>malt</code> 에 의해 생산량이 정해진다. 그리고 두 맥주는 들어가는 재료의 비율이 <del>당연히</del> 다르다.</p>

<p>이 때, 이익을 최대로 하는 각 맥주의 생산량을 구하는 문제다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWnpNbVl5SXpOa0JUWnhnVEwya0ROaTFTWTBZek10VWpNNFFXTDRFbVkxUXpZeWt6THdJak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" />
<img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWTRjRE1tSjJZaWhqWTFRVEx6WUdaNDBTTWhsek10UXpNakpXTHpFR08zVUdaM0V6THpJak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p algin="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>위 그림처럼 <em>contraints</em> 를 그래프 문제로 변환할 수 있다. 이 때 이익을 최대로 하는 <em>optimal solution</em> 은 <em>extreme point</em> 에 위치하는데 이 점들은 <em>2d</em> 에선 2개의 <em>constraints</em> (선분) 이 교차하는 지점에 위치한다.</p>

<p>따라서</p>

<blockquote>
  <p><strong>Goal</strong> maximize linear objective function of <code>n</code> nonnegative variables, subjet to <code>m</code> linear equations</p>
</blockquote>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5TnhFV015UUdOaFpETjVJVExoWnpNaDFDTzNjek10TUdOemdUTDRNMk16STJNaEZ6TDFJak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>문제를 <em>standard form</em> 으로 표시하면</p>

<ul>
<li>add variable <code>Z</code> and equation corresponding to objective function</li>
<li>add <em>slack</em> variable to convert each inequality to an equality</li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDT3lZak4xUWpNM2NEWmhkVEw1a2pZaDFDT3dNek10RTJONFVXTGtGV1ozVXpNeE0yTDFNak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<h4 id="geometry">Geometry</h4>

<ul>
<li>Inequalities define <strong>halfspaces</strong>. feasible region is a <strong>convex polyhedron</strong></li>
<li>A set is <strong>convex</strong> if for any two points <code>a</code> and <code>b</code> in the set, so is <code>1/2(a+b)</code></li>
<li>An <strong>extreme point</strong> of a set is a point in the set that can't be written as <code>1/2(a+b)</code>, where <code>a</code> and <code>b</code> are two distinct points in the set.</li>
</ul>

<p><img src='http://mathworld.wolfram.com/images/eps-gif/ConvexConcave_1000.gif'  alt="" /></p>

<p align="center">(<a href='http://mathworld.wolfram.com/Convex.html' >http://mathworld.wolfram.com/Convex.html</a>)</p>

<p>즉 두 점이 있을때 그 가운데 위치하는 점도 집합 안에 있으면 그 집합은 <em>convex</em> 라 부른다. <em>extreme point</em> 는 도형의 가장 바깥쪽 부분으로 그것보다 외부의 점이 없기 때문에 <code>1/2(a+b)</code> 로 바꿀 수 없다.</p>

<ul>
<li><strong>Extreme point property:</strong></li>
</ul>

<p>If there exists an optimal solution to <code>P</code> (plane), then there exists one that is an extreme point</p>

<p>(1) Number of extreme points to consider is <strong>finite</strong> <br />
(2) But number of extreme points can be <strong>exponential</strong> <br />
(3) Extreme point optimal iff no better adjacent extreme point (<em>greedy property</em>)</p>

<p>특히 3번은 중요한데, <em>global optimum</em> 인지 알기 위해 인접부분만 검사하면 된다. 이는 <em>objective function</em> 이 선형이고, <em>feasible region</em> 이 <em>convex</em> 이기 때문이다.</p>

<h3 id="simplexalgorithm">Simplex Algorithm</h3>

<p>1947년에 만들어진 알고리즘으로 20세기를 대표하는 탑 10 알고리즘중 하나라고 한다. <em>generic algorithm</em> 인데</p>

<ul>
<li>start at some extreme point</li>
<li><strong>Pivot</strong> from one extreme point to an adjacent one (never decreasing objective function)</li>
<li>repeat until optimal</li>
</ul>

<p>위에서 언급했던 <em>greedy property</em> 를 보면 이해가 쉽다. <em>objective function</em> 을 증가시키는 방향으로 <em>extreme point</em> 를 옮겨가다보면 <em>global optimum</em>을 찾을 수 있다.</p>

<h4 id="basicfeasiblesolution">Basic feasible solution</h4>

<blockquote>
  <p>A <strong>basis</strong> is a subset of <code>m</code> of the <code>n</code> variables</p>
</blockquote>

<ul>
<li>set <code>n-m</code> nonbasic variables to <code>0</code>, solve for remaining <code>m</code> variables</li>
<li>solve <code>m</code> equations in <code>m</code> unknowns</li>
<li>if unique and feasible => BFS</li>
<li>BFS &lt;=> extream point</li>
</ul>

<p>뭔소린가 한참을 쳐다봤는데, 그림으로 이해하는게 더 쉽다. <code>n</code> 개의 변수중 <code>m</code> 개를 제외한 것을 다 <code>0</code> 으로 하고, 방정식을 풀면 된다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTT21WMlloUm1aM2dUTmxKV0xsSm1ONTBDT3pVek10STJZM0lUTGtoVE9rTldaeWN6TDFRak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p algin="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p><em>slack variables</em> 로 구성된 <em>basis</em> 부터 시작해서 <em>pivot</em> 연산을 해 나아가면 된다. </p>

<ul>
<li>use the variable whose coefficient in objective function is positive to replace some one in the basis  (each unit increase in that variable from 0 increases objective value due to positive coefficient)</li>
</ul>

<p><em>objective function</em> 에서 계수가 양수인 수를 골라 치환하기 때문에 <code>Z</code> 값이 증가할수 밖에 없다. </p>

<ul>
<li>which variable to replace: </li>
</ul>

<p>Preserves feasibility by ensuring <code>RHS ≥ 0</code> and use minimum ratio rule: <code>min { 480/15, 160/4, 1190/20 }</code></p>

<ul>
<li>when to stop: When no objective function coefficient is positive.</li>
</ul>

<p>처음상태 <code>basis = {SC, SH, SM}</code> 에서 <em>constraint</em> <code>B</code> 를 <code>B = (1/15)(450 - 5A - SC)</code> 로 치환하면 <code>B</code> 가 <code>SC</code> 를 대신에 <em>basis</em> 에 들어간다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWjJFRE5qUkdNeElqTjNRV0wzVTJOaDFpTTNVMk10VVRPMGNUTDVZelkwWUdaMUl6THdVak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" />
<img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTWhWVE5rbERabFJtTTRFV0xqRlRONTBpWmpWek10a1ROMFlXTGtOVFl5QWpNNUV6THlVak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p algin="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p><code>A</code> 까지 치환하면 <em>objective function</em> 에 양수 계수를 가지는 변수가 없으므로  <code>Z</code> 가 더 증가할 여지가 없다. </p>

<h3 id="implementation">Implementation</h3>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTmtGRE1pZHpObEoyWXdrVEwwVVRZNDBTWjBNek10UWpaMVVUTHlJRE1pRkRNMEUyTDBNek4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTWpkVFpqUkRad0FETjFFV0w1VW1aNTBpWTJVMk10Z0RONU1UTG1GV1kwQUROelEyTDNNek4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<pre><code class="java">public class Simplex  
{
    private double[][] a; // simplex tableaux
    private int m, n; // M constraints, N variables

    public Simplex(double[][] A, double[] b, double[] c)
    {
        m = b.length;
        n = c.length;
        a = new double[m+1][m+n+1];
        for (int i = 0; i &lt; m; i++)
            for (int j = 0; j &lt; n; j++)
                a[i][j] = A[i][j];
        for (int j = n; j &lt; m + n; j++) a[j-n][j] = 1.0;
        for (int j = 0; j &lt; n; j++) a[m][j] = c[j];
        for (int i = 0; i &lt; m; i++) a[i][m+n] = b[i];
    }

    //Find entering column q using Bland's rule: index of first column whose objective function coefficient is positive.
    private int bland()
    {
        for (int q = 0; q &lt; m + n; q++)
            if (a[M][q] &gt; 0) return q;
                return -1;
    }

    //Find leaving row p using min ratio rule.
    private int minRatioRule(int q)
    {
        int p = -1;//leaving row
        for (int i = 0; i &lt; m; i++)
        {
            if (a[i][q] &lt;= 0) continue; //consider only positive entries
            else if (p == -1) p = i;
            else if (a[i][m+n] / a[i][q] &lt; a[p][m+n] / a[p][q])
                p = i;
        }
        return p;
    }

    public void pivot(int p, int q)
    {
        for (int i = 0; i &lt;= m; i++)
            for (int j = 0; j &lt;= m+n; j++)
                if (i != p &amp;&amp; j != q)
                    a[i][j] -= a[p][j] * a[i][q] / a[p][q];

        for (int i = 0; i &lt;= m; i++)
            if (i != p) a[i][q] = 0.0;
        for (int j = 0; j &lt;= m+n; j++)
            if (j != q) a[p][j] /= a[p][q];
        a[p][q] = 1.0;
    }

    public void solve()
    {
        while (true)
        {
            int q = bland();
            if (q == -1) break;//entering column q (optimal if -1)
            int p = minRatioRule(q);//leaving row p (unbounded if -1)
            if (p == -1) ...
            pivot(p, q);
        }
}
</code></pre>

<p>원본은 이리로 <a href='http://algs4.cs.princeton.edu/65reductions/Simplex.java.html' >Simplex.java</a></p>

<p>메인 로직 자체는 간단하다.</p>

<p>(1) <code>bland()</code> 로 <em>positive coefficient</em> 인 변수를 찾고 <br />
(2) <code>minRatioRule()</code> 로 어떤 <em>row</em> 택할지 결정한다 <br />
(3) <code>pivot</code> </p>

<p>변수의 수를 <code>N</code>, 제약조건(= <em>inequalities</em>)의 수를 <code>M</code> 이라 했을때 <code>M &gt;= N</code> 이면 러닝타임은 <code>M^2</code> 이다. 이는 <code>pivot</code> 연산이 대부분의 시간을 잡아먹기 때문.</p>

<p>근데 실제 돌려보면 <code>2(M+N) pivot</code> 내에 끝난다고 한다. 왜 그런지는 연구중이라고 함.</p>

<blockquote>
  <p><strong>Pivoting rules:</strong> Carefully balance the cost of finding an entering variable with the number of pivots needed.</p>
  
  <ul>
  <li><p>No pivot rule is known that is guaranteed to be polynomial.</p></li>
  <li><p>Most pivot rules are known to be exponential (or worse) in worst-case.</p></li>
  </ul>
</blockquote>

<h4 id="degeneracy">Degeneracy</h4>

<p>똑같은 <em>extreme point</em> 에 대해서 <em>basis</em> 만 바뀌는 것을 말하는데 위에서 본 <em>bland's rule</em> 이 작은 값부터 차례대로 사용 가능한 변수를 돌려주므로 유한한 수의 피벗이 일어남을 보장한다. </p>

<pre><code class="java">// Find entering column q using Bland's rule: 
// index of first column whose objective function coefficient is positive.
private int bland() {  
    for (int q = 0; q &lt; m + n; q++)
        if (a[M][q] &gt; 0) return q;
            return -1;
}
</code></pre>

<h4 id="implementationissues">Implementation Issues</h4>

<ul>
<li>Avoid stalling (degeneracy): requires artful engineering</li>
<li>Maintain sparsity: requires fancy data structures</li>
<li>Numerical stability: requires advances math</li>
<li>Detect Infeasibility: run "phase i" simplex algorithm</li>
<li>Detect unboundedness: no leaving row</li>
</ul>

<p>그러므로 직접 구현하지 말자.. <del>사실 이해도 어렵다. 만드는 것은 둘째치고</del></p>

<h3 id="reductions">Reductions</h3>

<p><em>unrestricted variable</em> <code>B</code> 가 있는 <em>minimization</em> 문제를 <em>standard form</em> 으로 <em>reduction</em> 하려면</p>

<p>(1) <code>min(13A + 15B)</code> 를 <code>max(-13A - 15B)</code> 로 변경 <br />
(2) <code>4A + 4B &gt; 160</code> <em>constraint</em> 를 <code>4A + 4B - S = 160</code> (<code>S &gt;= 0)</code> <br />
(3) <code>B = B0 - B1</code> (<code>B0 &gt;= 0</code>, <code>B1 =&gt; 0</code>)</p>

<h4 id="maxflow">Max Flow</h4>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTm1Cak4xRURNemNUTXpFVEx3UURNNTBpTjNNek10VWpZalZUTDNNVFoxWURPaUZ6TDVRek4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><em>capacity</em>, <em>flow</em> 를 <em>constraint</em> 로 쉽게 바꿀 수 있다. 앞에서 본 <em>max flow</em> 알고리즘과 비교했을때의 장점은 문제가 더 복잡해지더라도 <em>constraint</em> 만 추가하면 간단하다는 점이다. (성능은 더 느릴수 있다고 함)</p>

<h4 id="bipartitematching">Bipartite Matching</h4>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWjJJelloQnpOeFVtWjJJVEx5RWpNNTBTWjNVek10a1RZbWxUTGlKR04zWVdabUp6THpVek4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>여기서 <code>X_ij</code> 는 사람 <code>i</code> 에게 작업 <code>j</code> 가 할당되었는지의 여부다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDT2pCRE1oaFRPd2dET2hCVExpUm1OaTFpTndJMk10Y3pNbU5XTDNZbVp6SVRNalp6THhVek4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<h3 id="summary">Summary</h3>

<p><em>LP</em> 가 범용적이긴 한데, 먼저 <em>specialized algorithm</em> 을 사용해 보고 안되면 <em>LP</em> 를 쓰자.</p>

<p><a href='https://medium.com/@_marcos_otero/the-real-10-algorithms-that-dominate-our-world-e95fa9f16c04' >읽을거리: The real 10 algorithms that dominate our world</a></p>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='http://www.explainxkcd.com/wiki/index.php/287:_NP-Complete' >getRandomNumber image</a> <br />
(4) <a href='http://www.programering.com/a/MzM2IDNwATM.html' >Lecture note</a> <br />
(5) <a href='http://mathworld.wolfram.com/Convex.html' >Mathword convex</a>  </p>]]></description><link>http://1ambda.github.io/algorithm-linear-programming/</link><guid isPermaLink="false">13fdf909-5ce5-407a-a94f-1d9c14b9ef80</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[linear programming]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 31 Dec 2014 08:28:26 GMT</pubDate></item><item><title><![CDATA[Problem Reduction]]></title><description><![CDATA[<p><img src='https://www.palantir.com/wp-assets/wp-content/static/techblog/2011/09/travelling_salesman_problem.png'  alt="" /></p>

<p>앞으로 남은 3챕터에서 배울 내용은</p>

<p><strong>reduction</strong>, <strong>linear programming</strong>, <strong>intractability</strong> 이다.</p>

<p>따라서 지금까지의 관심에서 좀 벗어나 </p>

<ul>
<li>from individual problems to <em>problem-solving models</em></li>
<li>from linear / quadratic to <em>polynomial / exponential scale</em></li>
<li>from details of implementation to <em>conceptual framework</em></li>
</ul>

<h3 id="introtoreduction">Intro to Reduction</h3>

<p><em>reduction</em> 챕터에서는 다음의 내용을 다룬다.</p>

<ul>
<li>design algorithms </li>
<li>estabilish lower bounds</li>
<li>classify problems</li>
</ul>

<p><em>reduction</em> 의 정의부터 보면</p>

<blockquote>
  <p>Problem <code>X</code> <strong>reduces to</strong> problem <code>Y</code> if you can use an algorithm that solves <code>Y</code> to help solve <code>X</code></p>
</blockquote>

<p>따라서 <code>X</code> 를 푸는데 드는 비용은 <em>reduction</em> 과, <code>Y</code> 를 해결하는 비용의 합이다.</p>

<p><em>median</em> 을 찾는 문제의 경우, 정렬문제로 변환할 수 있다. 이 때의 비용은 <code>N logN + 1</code>인데, <em>reduction</em> (<em>post or preprocessing</em>) 비용이 <code>1</code> 이다.</p>

<p>중복 원소를 제거하는 문제의 경우 정렬뒤, 인접한 원소간 비교하여 제거하는 문제로 치환할 수 있다. <code>N logN + N</code> 의 비용으로, 이 경우 <em>reduction</em> 비용은 <code>N</code> 이다.</p>

<p><em>min cut</em> 의 경우 <em>max flow</em> 알고리즘을 이용해서 풀 수 있고, <em>reduction</em> 하는데 <em>DFS</em> 또는 <em>BFS</em> 로 한번 돌려야 하므로, 치환 비용은 <code>V + E</code> 다.</p>

<p>이외에도 다양한 <em>reduction</em> 예제가 있다.</p>

<ul>
<li>3-collinear -> sorting</li>
<li>CPM -> topological sorting</li>
<li>arbitrage -> shortest path (벨만포드)</li>
<li>Burrows-Wheeler transform -> suffix sort</li>
</ul>

<p>따라서 <code>Y</code> 문제를 풀 수 있을때, <code>X</code> 에 적용 가능한지가 문제가 된다.</p>

<h3 id="convexhull">Convex hull</h3>

<p><img src='http://cgm.cs.mcgill.ca/' ~orm/images/mergech.gif" alt="" /></p>

<p align="center">(<a href='http://cgm.cs.mcgill.ca/' ~orm'>http://cgm.cs.mcgill.ca/~orm</a>)</p>

<p><em>convex hull</em> 은 <em>sorting</em> 으로 바꿀 수 있다.</p>

<blockquote>
  <p><strong>convex hull:</strong> Given <code>N</code> points in the plane, identify the extream points of the convex hull (in counterclockwise order)</p>
  
  <p><strong>sorting:</strong> Given <code>N</code> distinct integers, rearrange them in ascending order</p>
</blockquote>

<p><em>reduction</em> 가능한지는 <em>Graham scan algorithm</em> 으로 증명된다. 비용은 <code>N logN + N</code> 으로, <em>reduction</em> 에 <code>N</code> 만큼의 비용이 든다.</p>

<h4 id="grahamscan">Graham Scan</h4>

<p>먼저 <em>cross product (외적)</em> 에 대해 잠깐 보고가자. 내적은 스칼라지만, 외적은 또 다른 벡터를 돌려준다. 두 벡터에 대해 수직인 벡터를 돌려주고, 그 크기는 두 벡터로 만들어지는 평행사변형의 넓이다.</p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/Cross_product_parallelogram.svg/220px-Cross_product_parallelogram.svg.png'  alt="" /></p>

<p>외적은 벡터를 돌려주고, 그 방향이 <code>sin</code> 에 기반하기 때문에 두 벡터 <code>a, b</code> 의 외적 <code>a x b</code> 의 값에 따라 <code>a</code> 를 기준으로 <code>b</code> 가 좌측에 있는지, 우측에 있는지 알 수 있다. 위 그림에서 <code>b</code> 가 아래쪽을 향할때 <code>a x b</code> 의 방향이 어디가 될지 생각해 보자.</p>

<p><img src='https://lh3.googleusercontent.com/MIO3c8kg5MTNkze8w5Y6AGfDNWF9Vx4EVvlui8S5grVNWbgXBcpIch7E4R2DRr4B4HSlbLOHSBy39UMHLhTOqLkbnjQMCqtN-VBYkcEfeOEDjAyoCFzMllfpUHUicltzfw'  alt="" />
<img src='https://lh6.googleusercontent.com/aaQEU_goK5dBbB_sct7YxtFafk5968K4yDH5nssYy2RSrieKv0yl-FSQbwgxKgc6sRyxum057PTPW9CfJ83Hr3B3aR4yXWTkaQj3mQEPu35-mhB3epOF1IrFCqsBVKiK3g'  alt="" /></p>

<p align="center">(<a href='http://blog.secmem.org/554' >http://blog.secmem.org/554</a>)</p>

<p>이제 <em>graham scan</em> 알고리즘을 보면</p>

<ul>
<li>choose point <code>p</code> with smallest y-coordinate</li>
<li><strong>sort</strong> points by polar angle with <code>p</code> to get simple polygon</li>
<li>consider points in order, and discard those that would create a clockwise turn</li>
</ul>

<p><em>polar angle</em> 은</p>

<p><img src='http://cf.ydcdn.net/1.0.1.26/images/main/polar%20coordinate.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.yourdictionary.com/' >http://www.yourdictionary.com</a>)</p>

<p>그리고 <em>clockwise turn(시계방향)</em> 인지 아닌지 외적으로 구할 수 있다. 외적값이 음수면 시계방향이다. </p>

<p>따라서 최초의 다각형에서, 선분을 순회하면서 현재 선분과 다음 점을 외적해서 반시계 방향인 점들만 택하면 된다. 그러므로 정렬 + 순회이므로 <em>linear time</em> 이다.</p>

<p><a href='http://www.hanbit.co.kr/network/view.html?bi_id=1462' >더 읽을거리: Gift wrapping</a></p>

<h4 id="shortestpath">Shortest Path</h4>

<p>(non-negative weights) <em>undirected graph</em> 의 최단거리도 <em>directed graph</em> 로 치환해서 풀 수 있다. 각 <em>edge</em> 에 양쪽으로 모두 방향을 추가하면 된다. 러닝타임은 <code>E logV + E</code>, 여기서 <code>E</code> 는 <em>reduction cost</em> 다.</p>

<blockquote>
  <p>Can still solve shortest paths problem in undirected graphs (if no negative cycles), but need omre sophistcated techniques</p>
</blockquote>

<h4 id="lineartimereductions">Linear-time reductions</h4>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/algorithm-reduction/1.png'  alt="" /></p>

<h3 id="establishinglowerbounds">Establishing Lower Bounds</h3>

<p><em>comparison-sorting</em> 알고리즘의 <em>lower bound</em> 는 <code>n log n</code> 임을 이전 강의에서 봤었다. <a href='http://1ambda.github.io/randomized-selection/' #lowerboundforsorting">Lower bound for sorting</a> 참조</p>

<p>일반적으로 어떤 문제의 <em>lower bound</em> 를 알긴 상당히 난해한데, <em>reduction</em> 을 이용해서 어떤 문제가 <em>sorting</em> 처럼 이미 <em>lower bound</em> 가 알려진 문제로 변경할 수 있다면 <em>lower bound</em> 를 알 수 있다. (<em>reduction cost</em> 가 그리 크지 않다고 한다면)</p>

<h4 id="lineartimereductions">Linear-time reductions</h4>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/algorithm-reduction/3.png'  alt="" title="" /> </p>

<blockquote>
  <p>Problem <code>X</code> <strong>linear-time reduces</strong> to problem <code>Y</code> if <code>X</code> can be solved with</p>
  
  <ul>
  <li>Linear number of standard computational steps</li>
  <li>Constant number of calls to <code>Y</code></li>
  </ul>
</blockquote>

<p>따라서 문제 <code>X</code> 를 <code>Y</code> 로 <em>linear-time reduction</em> 이 가능하다면 같은 <em>lower bound</em> 를 적용할 수 있다. <code>X</code> 가 <code>k</code> 시간이 걸린다면, <code>Y</code> 도 그러하다는 것이다.</p>

<p>그리고 <code>Y</code> 를 더 빨리 풀 수 있는 기법이 개발되면 <code>X</code> 에도 적용 가능하다는 뜻이다.</p>

<h4 id="lowerboundforconvexhull">Lower bound for convex hull</h4>

<blockquote>
  <p><strong>Proposition:</strong> in quadratic decision tree model (allows linear or quadratic tests), any algorithms for sorting <code>N</code> integers requires <code>Ω(N logN)</code> steps</p>
  
  <p><strong>Proposition:</strong> sorting linear-time reduces to convex hull. So if I can solve convex hull efficiently, I can sort efficiently</p>
</blockquote>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/algorithm-reduction/2.png'  alt="" title="" /> 
이미지를 잘 보면 <em>convex hull</em> 이 <code>y = x^2</code> 선 위에 있다. 그리고 이 위에 있는 모든 점들이 정렬된 순서인걸 볼 수 있다. 그리고 정렬 대상이 2차원 좌표긴 하지만 <em>quadratic decision tree model</em> 내에 있으므로 정렬 문제로 <em>linear-time reduction</em> 이 가능하다.</p>

<blockquote>
  <p><strong>Implication:</strong> Any <em>ccw-based</em> convex hull algorithm requires <code>Ω(N logN)</code> ops (linear or quadratic tests)</p>
</blockquote>

<p>이외에도</p>

<blockquote>
  <ul>
  <li><p>Element distinctness linear-time reduces to finding the mode because if the most frequent integer occurs more than once, then there is a duplicated integer.</p></li>
  <li><p>Closest pair linear-time reduces to element distinctness because the distance between the closest pair is zero if and only if there is a duplicated integer.</p></li>
  </ul>
</blockquote>

<p>두 원소가 같을때만 제거하므로, 위의 문제들로 <em>linear-time reduction</em> 이 가능하다.</p>

<h3 id="classifyingproblems">Classifying Problems</h3>

<p>두 문제 <code>X, Y</code> 가 복잡도가 같음을 보이고 싶다면</p>

<ul>
<li>show that <code>X</code> <em>linear-time reduces</em> to <code>Y</code></li>
<li>show that <code>Y</code> <em>linear-time reduces</em> to <code>X</code></li>
</ul>

<p>그러면 <code>X</code>, <code>Y</code> 가 같은 복잡도를 가지고 있다고 말할 수 있다. 심지어 복잡도를 모름에도.</p>

<p>그리고 서로 <em>reduction</em> 이 가능하므로 한 문제에 대해 빠른 알고리즘을 개발해서, 다른 곳으로 적용이 가능하다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/algorithm-reduction/4.jpg'  alt="" title="" /> </p>

<ul>
<li>use exact algorithm for tractable problems</li>
<li>use heuristics for intractable problems</li>
</ul>

<h3 id="reference">Reference</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='https://www.palantir.com/wp-assets/wp-content/static/techblog/2011/09/travelling_salesman_problem.png' >xkcd image</a> <br />
(4) <a href='http://cgm.cs.mcgill.ca/' ~orm/mergech.html">Convex hull image</a> <br />
(5) <a href='http://ghebook.blogspot.kr/2010/07/vector.html' >전파거북이 - 좌표계 기반 벡터</a> <br />
(6) <a href='http://blog.secmem.org/554' >소프트웨멤버십 - Convex hull</a> <br />
(7) <a href='http://www.yourdictionary.com/polar-coordinate' >Polar angle image</a> <br />
(8) <a href='http://web.cs.dal.ca/' ~mhe/csci3110/handouts/lecture9.htm">sorting - convex hull image</a>  </p>]]></description><link>http://1ambda.github.io/algorithm-reduction/</link><guid isPermaLink="false">0e589543-7f20-4371-9067-2c2db77adb31</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[reduction]]></category><category><![CDATA[convex hull]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 30 Dec 2014 09:05:04 GMT</pubDate></item><item><title><![CDATA[Data Compression]]></title><description><![CDATA[<p><img src='http://www.lawfareblog.com/wp-content/uploads/2013/09/Encryption-in-the-Real-World.jpg'  alt="" /></p>

<h3 id="datacompression">Data Compression</h3>

<p>주된 이유는 전송 시간과 저장 공간을 절약하기 위해서다. 무어의 법칙이 말해주듯이 제품의 성능은 점점 좋아지는데, 그럼에도 불구하고 사람들이 만들어 내는 데이터의 양은 더 급격히 증가한다. 그래서 압축이 필요하다.</p>

<p>이번시간에 배울 기법은 3 가지다.</p>

<ul>
<li>Run-length</li>
<li>Huffman</li>
<li>LZW</li>
</ul>

<p><em>data compression</em> 응용은</p>

<ul>
<li><em>generic file compression</em></li>
</ul>

<p>GZIP 같은 파일 압축이나, PKZIP 같은 아키이빙. 그리고 파일시스템에서도 압축을 할 수 있다.</p>

<ul>
<li><em>multimedia</em>, <em>communication</em>, <em>database</em></li>
</ul>

<p><em>GIF</em>, <em>MP3</em>, <em>V.42 bis model</em>(?) 등 다양한 곳에 압축을 활용한다고 한다.</p>

<p><br/></p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTT2paRE5qTnpZMEVXTjNNVEw0Z1RONDBDTjFFMk10RWpad0VUTGtWRE41SWpNMGt6THlnVE0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>강의에서 사용하는 용어를 좀 정리하고 가자. 바이너리 <code>B</code> 에 대해 <em>compression, 압축</em> <code>C(B)</code> 를 하고 <em>expansion, 복원(?)</em> 를 해서 <code>B</code> 를 얻는다. 중요한점은 <em>loseless</em> 여야 한다는 것.</p>

<p><em>compression ratio</em> 는 <code>C(B) / B</code> 로 정의한다. <em>natural language</em> 의 경우 <code>50~75%</code> 이상의 압축이 가능하다고 한다.</p>

<h4 id="binarystream">Binary Stream</h4>

<p>구현에 사용할 바이너리 스트림 API 를 보자. 코드는 <a href='http://introcs.cs.princeton.edu/java/stdlib/BinaryStdIn.java.html' >BinaryStdIn.java</a> <a href='http://introcs.cs.princeton.edu/java/stdlib/BinaryStdOut.java.html' >BinaryStdOut.java</a> 에서 구할 수 있다.</p>

<pre><code class="java">public class BinaryStdIn {  
    boolean readBoolean() {} //read 1 bit and return as a boolean
    char readChar() {} //read 8 bits and return as a char
    char readChar(int r) {} //read r bitsand return as a char
    [similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits)]
    boolean isEmpty() {} //is the bitstream empty?
    void close() {} //close the bitstream
}

public class BinaryStdOut {  
    void write(boolean b) {} //write the specified bit
    void write(char c) {} //write the specified 8-bit char
    void write(char c, int r) {} //write the r least significant bits of the specified char
    [similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits)]
    void close() {} //close the bitstream
}
</code></pre>

<p>찾아보니까 자바에서 기본적으로 제공되는건 <code>ByteArrayStream</code> 이 있더라.</p>

<h4 id="datarepresentation">Data Representation</h4>

<p><code>12/31/1999</code> 를 표시하는 법을 생각해 보자.</p>

<p>(1) <code>char</code> 면 <em>8 bit</em>  10개니까 <em>80 bit</em> <br />
(2) <code>int</code>  면 <em>32 bit</em>  3개니까 <em>96 bit</em> <br />
(3) <code>bit</code> 단위를 지정할 수 있다면 <em>4 + 5 + 12 + 3(align) = 24 bit</em> </p>

<pre><code class="java">month = 12  
day = 31  
year = 199

BinaryStdOut.write(month, 4)  
BinaryStdOut.write(day, 5)  
BinaryStdOut.write(year, 12)  
</code></pre>

<p>이는 데이터 표현만 잘 해도 알고리즘 없이 상당부분 압축할 수 있다는 소리다. 일레로 1990년도에 만들어졌던 유전자 데이터베이스는 아스키로 <code>AGCT</code> 를 표현했다고 한다. 4종류의 문자밖에 없으니까 <em>2 bit</em> 로 표현 가능함에도 불구하고</p>

<h3 id="universaldatacompression">Universal Data Compression</h3>

<blockquote>
  <p>No algorithm can compress every bitstring</p>
</blockquote>

<p><em>contraction</em> 을 이용해 증명하면</p>

<ul>
<li>모든 비트스트림을 압축할 수 있는 알고리즘 <code>U</code> 가 있다 하자.</li>
<li>주어진 비트스트링 <code>b0</code> 을 압축해서 더 작은 사이즈의 <code>b1</code> 을 얻고</li>
<li>이 과정을 반복하면 사이즈가 <code>0</code> 이 될때까지 압축이 가능하다. 이건 말이 안된다. </li>
<li>따라서 모든 비트스트림을 압축할 수 있는 알고리즘 <code>U</code> 는 없다.</li>
</ul>

<h3 id="runlengthencoding">Run-Length Encoding</h3>

<p><code>0000000000000001111111000000011111111111</code> 의 비트가 있을때 <em>n-bit</em> 로 <code>0</code> 또는 <code>1</code> 의 <em>runs</em> (긴 나열을 말하는 듯함) 을 표시한다. </p>

<p>예를 들어 위의 데이터를 4비트 카운트를 이용해 표시하면</p>

<pre><code>bin  1111 0111 0111 1011  
dec    15    7    7   11  
</code></pre>

<p>만약에 <em>run</em> 의 길이가 지정된 <em>n-bit</em> 로 표시할 수 있는 수보다 크면 <code>0</code> 부터 다시 세면 된다. <em>JPEG</em>, <em>ITU-T T4 Group 3</em> 등에 응용한다고 함.</p>

<p>구현은</p>

<pre><code class="java">// http://algs4.cs.princeton.edu/55compression/RunLength.java.html
public class RunLength {

  private final static int R = 256; // max run-length count
  private final static int lgR = 8; // # of bits per count

  public static void compress() {
    int run = 0;
    boolean old = false;

    while (!BinaryStdIn.isEmpty()) {
      boolean current = BinaryStdIn.readBoolean();

      // alternate bit
      if (current != old) {
        BinaryStdOut.write(run, lgR);
        run = 1;
        old = !old;
      }
      // same bit
      else {
        // max count
        if (run == R - 1) {
          BinaryStdOut.write(run, lgR);
          // print dummy alternate bit whose length is 0
          run = 0;
          BinaryStdOut.write(run, lgR); 
        }

        run++;
      }
    }

    BinaryStdOut.write(run, lgR);
    BinaryStdOut.close();
  }

  public static void expand() {
    boolean bit = false;

    while (!BinaryStdIn.isEmpty()) {
      int run = BinaryStdIn.readInt(lgR); // read lgR bit

      for (int i = 0; i &lt; run; i ++)
        BinaryStdOut.write(bit);

      bit = !bit;
    }

    BinaryStdOut.close();
  }
}
</code></pre>

<p><del>테스틀 어찌해야하는가</del></p>

<p><br/></p>

<p><img src='http://help.adobe.com/en_US/Director/11.0/images/vector_bitmap_image.png'  alt="" /></p>

<p align="center">(<a href='http://help.adobe.com/' >http://help.adobe.com</a>)</p>

<p><em>bitmap</em> 을 압축하는데 <em>run-length</em> 를 사용하면 효과적이다. 글자에서 대부분의 비트가 <code>0</code> (흰색) 이기 때문이다.</p>

<p>흑백 그림을 예로 들어보자. 인치당 <code>300</code> 픽셀이고, 사이즈가 <code>8.5 x 11</code> 인치라 했을때, 한 이미지를 표시하기 위해 필요한 비트는 <code>300 * 8.5 * 300 * 11</code> = <code>8.415</code> 백만 비트가 필요하다.</p>

<h3 id="huffmanencoding">Huffman Encoding</h3>

<p><em>fixed-length code</em> 말고 모스코드같은 <em>variable-length code</em> 를 생각해 보자. </p>

<p>모스코드에서 <code>* * * - - - * * *</code> 는 여러 방법으로 해석될 수 있다. <code>SOS</code>, <code>V7</code>, <code>IAMIE</code>, <code>EEWNI</code> 모두 가능하다. 모호한것이다. 모스부호에서는 이 문제를 해결하기 위해 글자마다 갭을 두어, 올바르게 해석될 수 있도록 한다. </p>

<p>인코딩에서 <em>ambiguity</em> 를 해결하려면 어떤 <em>codeword</em> 도 다른 <em>code word</em> 의 <em>prefix</em> 가 되지 않도록 해야 한다. </p>

<ul>
<li>Fixed-length code</li>
<li>Append special stop char to each codeword (e.g 모스)</li>
<li>Prefix-free code</li>
</ul>

<p>이 중에서 <em>prefix-free</em> 인 코드를 만드는법을 살펴보자. <em>binary trie</em> 를 만들어 <em>leaf</em> 에 문자를 놓고, 그 문자까지 도달하는 경로가 인코딩 값이다. </p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTjJRVE9tTnpZemdETjVVVEw0UTJZaTF5WXdVek10WWpNNUlXTDJRek5oZFRPaWR6THlrVE0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p><em>compression</em> 을 위해 심볼테이블을 만들거나, 아니면 <em>leaf</em> 부터 따라 올라가고, 그 <em>path</em> 를 뒤집어 출력할 수 있다.</p>

<p><em>expansion</em> 은 루트부터 시작해서 <em>path</em> 를 따라 내려가다가 <em>leaf</em> 에서 만나는 문자를 출력하면 된다.</p>

<p>한가지 생각해 볼 것은, 빈도가 많은 문자를 짧은 인코딩 값(<em>path</em>) 를 가지도록 해야 압축률이 높아진다는 것이다. 이를 위해 각 문자의 <em>frequency</em> 를 이용해야 한다.</p>

<p>허프만 코드 API를 보면</p>

<pre><code class="java">public class Huffman {

    // support extended ASCII
    private static final int R = 256;

    private static class Node implements Comparable&lt;Node&gt; {

        private char ch;
        private int  freq;
        private final Node left, right;

        public Node(char ch, int freq, Node left, Node right) {
            this.ch = ch;
            this.freq = freq;
            this.left = left;
            this.right = right;
        }

        public boolean isLeaf() {
            return left == null &amp;&amp; right == null;
        }

        @Override
        public int compareTo(Node that) {
            return this.freq - that.freq;
        }
    }

    public static void compress()
    public static void expand()
    private static Node buildTrie(int[] freq)
    private static void writeTrie(Node x)
    private static void buildCode(String[] st, Node x, String s)
    private static Node readTrie()
}
</code></pre>

<p>이제 <em>expansion</em> 을 구현하자. 스트림의 가장 첫 부분에, 몇 개의 문자인지를 <em>int</em> 로 표시하는 규약을 정하면</p>

<pre><code class="java">public void expand() {  
  Node root = readTrie(); // read in encoding trie
  int N = BinaryStdIn.readInt(); // read in # of chars

  for (int i = 0; i &lt; N; i++) {
    Node x = root;
    while (!x.isLeaf()) {
      if (!BinaryStdIn.readBoolean())
        x = x.left;  // 0
      else
        x = x.right; // 1
    }

    BinaryStdOut.write(x.ch, 8); // print char
  }

  BinaryStdOut.close();
}
</code></pre>

<p><em>running time</em> 은 <code>N</code> 에 비례한다. </p>

<p><em>expansion</em> 하는 쪽에서도 <em>trie</em> 를 가지고 있어야한다. <em>trie</em> 를 전송하기 위해 <code>writeTrie</code> 함수를 만들어 보자. <em>trie</em> 를 <em>preorder</em> 로 순회하면서 <em>leaf</em> 의 경우 <code>1</code> 과 문자 값을, <em>internal node</em> 의 경우 <code>0</code> 을 출력한다.</p>

<pre><code class="scala">private static void writeTrie(Node x) {  
  if (x.isLeaf()) {
    BinaryStdOut.write(true); // leaf
    BinaryStdOut.write(x.ch, 8);
    return;
  }

  BinaryStdOut.write(false);
  writeTrie(x.left);
  writeTrie(x.right);
}
</code></pre>

<p>이러면 비트스트림으로 온 <em>trie</em> 를 해석하는 함수 <code>readTrie</code> 를 만들자. 마찬가지로 <em>pre-order</em> 로 읽는다.</p>

<pre><code class="java">private static Node readTrie() {  
  // leaf
  if (BinaryStdIn.readBoolean()) {
    char c = BinaryStdIn.readChar(8);
    return new Node(c, 0, null, null);
  }

  Node l = readTrie(); 
  Node r = readTrie();
  return new Node('\0', 0, l, r);
}
</code></pre>

<h4 id="shannonfanoalgorithm">Shannon-Fano algorithm</h4>

<p>어떻게 가장 최적(압축률이 높은) <em>prefix-free code</em> 를 만들까? <em>Shannon-Fano</em> 알고리즘을 이용하면</p>

<ul>
<li><em>symbol</em> <code>S</code> 를 <code>freq</code> 으 합이 최대한 같은 두 집단으로 나눈다 <code>S0, S1</code></li>
<li><code>S0</code> 은 <code>0</code> 부터 시작하고, <code>S1</code> 은 <code>1</code> 부터 시작하도록 <em>codeword</em> 를 만든다</li>
<li>위 두 단계를 반복한다.</li>
</ul>

<p>근데 이 알고리즘은 보면 알겠지만, 최적이 아니다. 이는 <code>freq</code> 값이 <code>{5, 1}</code>, <code>{2, 1, 2, 1}</code> 처럼 구성될 수 있기 때문이다.</p>

<h4 id="huffmanalgorithm">Huffman algorithm</h4>

<p>허프만 알고리즘은 최적의 <em>prefix-free code</em> 를 만들기 위해 </p>

<ul>
<li>각 문자를 이용해 <em>single node trie</em> 를 만든다.</li>
<li><code>freq</code> 값이 가장 작은 두개를 골라 합치고, <em>internal node</em> 에 값을 누적</li>
<li>반복한다</li>
</ul>

<p><img src='http://lcm.csa.iisc.ernet.in/dsa/img161.gif'  alt="" /></p>

<p align="center">(<a href='http://lcm.csa.iisc.ernet.in/dsa' >http://lcm.csa.iisc.ernet.in/dsa</a>)</p>

<p>이 과정에서 가장 낮은 <em>frequency</em> 를 갖는 문자가 아래로 가는 것을 보장하기 때문에 최적의 <em>prefix-free code</em> 를 찾는다 말할 수 있다. (좀 더 자세한 증명은 책을 보라고 함)</p>

<p>구현은</p>

<pre><code class="java">// construct huffman encoding trie 
private static Node buildTree(int[] freq) {  
    PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;Node&gt;();

    for (char c = 0; c &lt; R; c++) 
        if (freq[c] &gt; 0)
            pq.add(new Node(c, freq[c], null, null));

    // if only one char
    if (pq.size() == 1) {
        if (freq['\0'] == 0) pq.add(new Node('\0', 0, null, null));
        else                 pq.add(new Node('\1', 0, null, null));
    }

    // merge two tries
    while (pq.size() &gt; 1) {
        Node l = pq.remove();
        Node r = pq.remove();
        Node p = new Node('\0', l.freq + r.freq, l, r); // parent
        pq.add(p);
    }

    return pq.remove();
}
</code></pre>

<h4 id="compression">Compression</h4>

<p>구현은 </p>

<pre><code class="java">public static void compress() {  
    String s = BinaryStdIn.readString(); // input
    char[] input = s.toCharArray();

    // tabulate freq counts
    int[] freq = new int[R];
    for (int i = 0; i &lt; R; i++)
        freq[input[i]]++;

    // build huffman trie
    Node root = buildTrie(freq);

    // build syombol table
    String[] st = new String[R];
    buildCode(st, root, "");

    // print trie for decoder
    writeTrie(root);

    // print N (# of input)
    BinaryStdOut.write(input.length);

    // encode
    for (int i = 0; i &lt; input.length; i++) {
        String code = st[input[i]];

        // traverse huffman trie
        for (int j = 0; j &lt; code.length(); i++) {
            if (code.charAt(j) == '0')
                BinaryStdOut.write(false);
            else if (code.charAt(j) == '1')
                BinaryStdOut.write(true);
            else throw new IllegalStateException("Illegal State");
        }
    }

    BinaryStdOut.close();
}

private static void buildCode(String[] st, Node x, String s) {  
    if (!x.isLeaf()) {
        buildCode(st, x.left, s + '0');
        buildCode(st, x.right, s + '1');
    } else {
        st[x.ch] = s; 
    }
}
</code></pre>

<p>전체 코드는 <a href='http://1ambda.github.io/ko.thetimenow.com/pst/pacific_standard_time' >Huffman.java</a> 로</p>

<h4 id="huffmansummary">Huffman Summary</h4>

<p>정리하면 </p>

<ul>
<li>tabulate char frequencies and build trie</li>
<li>encode file by traversing trie or lookup table</li>
</ul>

<p>러닝타임은 바이너리 힙을 이용할 경우(우선순위 큐) <code>N + RlogR</code> 이다. 여기서 <code>R</code> 은 알파벳 사이즈. <code>N</code> 은 입력 문자의 수다. </p>

<p>즉 <code>N</code> 은 입력 문자를 인코딩 하는데, <code>R logR</code> 은 <code>R</code> 개의 문자에 대해 <code>freq</code> 값을 이용해 <em>trie</em> 를 만드는데 걸리는 시간</p>

<h3 id="lzwcompression">LZW Compression</h3>

<p><em>Lempel-Ziv-Welch</em> 의 약자다. 세 분이 만드신듯</p>

<p>알고리즘을 보기 전에 데이터 압축 모델에 대해 좀 생각해보자.</p>

<p>(1) 빠르고, 범용적이지만 최적은 아닌 <strong>static model</strong> (e.g ASCII)
(2) 모델을 매번 생성하고, 전송해야하지만 최적인 <strong>Dynamic model</strong> (e.g Huffman)</p>

<p>이 둘을 섞은 <em>adaptive model</em> 도 있다. 즉 매 텍스트마다 모델을 업그레이드 해 나가는 것이다. <del>머신러닝?!</del></p>

<blockquote>
  <p>Progressively learn and upate model as you read text</p>
</blockquote>

<ul>
<li>More accurate modeling produces better compression</li>
<li>Decoding must start from beginning</li>
</ul>

<p><em>LZW compression</em> 이 그 예다. <em>LZW</em> 압축 알고리즘은 모델을 읽으면서 만들기 때문에, 전송할 필요가 없다.</p>

<p>텍스트를 읽다가 <em>codeword table</em> 에 이미 존재하면, 문자를 더 읽어 테이블에 없을 경우에만 추가한다. 그림으로 보면</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWmlSR00yUW1OeVF6WWpaVEw0UTJNNDBTTjFVMk10a3pZM01XTHlFV05obGpZNU0yTHhBak0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<ul>
<li>Create ST associating <code>W</code>-bit codewords with string keys</li>
<li>Initialize ST with codewords for single-char keys</li>
<li>Find longest string <code>s</code> in ST that is a prefix of unscanned part of input</li>
<li>Write the <code>W</code>-bit codeword associated with <code>s</code></li>
<li>Add <code>s + c</code> to ST where <code>c</code> is next char in the input</li>
</ul>

<p><em>LZW compression</em> 에선 <em>longest string matching</em> 이 필요하므로 <em>trie</em> 를 이용할 수 있다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWmtsek5pRldPbVJtTmpSVEw1RVRZNTBDT3pFek10UVRZMElXTG1GVFk1TVdPbVZ6THpBak0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<h4 id="lzwimplementation">LZW Implementation</h4>

<p>자세한 코드는 <a href='http://algs4.cs.princeton.edu/55compression/LZW.java.html' >LZW.java</a> 여기로. 그리고 메모리 사용량을 줄이기 위해 <em>ternary search trie</em> 를 이용한다. <a href='http://algs4.cs.princeton.edu/55compression/TST.java.html' >TST.java</a></p>

<pre><code class="java">// ref: http://algs4.cs.princeton.edu/55compression/LZW.java.html
private static final int R = 256;  // # of input chars  
private static final int L = 4096; // # of codewords = 2^W  
private static final int W = 12;   // codeword width

public static void compress() {  
  String input = BinaryStdIn.readString();

  // codewords for single chars
  TST&lt;Integer&gt; tst = new TST&lt;Integer&gt;();
  for(int i = 0; i &lt; R; i++)
    sts.put("" + (char) i, i);

  int code = R + 1;

  while (input.length() &gt; 0) {
    String s = tst.longestPrefixOf(input);
    BinaryStdOut.write(s, W);

    int t = s.length();
    if (t &lt; input.length() &amp;&amp; code &lt; L)
      st.put(input.substring(0, t + 1), code++)

    input = input.substring(t);
  }

  BinaryStdOut.write(R, W); // write "stop" codeword
  BinaryStdOut.close();
}
</code></pre>

<p><em>expansion</em> 은 테이블에서 <em>codeword</em> 를 읽어가면서 테이블을 만들면 된다. 심볼이 아니라 값으로 검색하므로 <code>2^W</code> 길이의 <em>array</em> 만 있으면 된다.</p>

<p><em>tricky case</em> 가 있는데</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTTBNbVp3WVdaaloyWTRJVEwxY1RZaDF5TnlJMk10VUROaGRUTHdVVE4zWTJZM2t6TDFBak0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><em>compression</em> 은 같은데 <em>expansion</em> 이 좀 복잡하다. <code>41 42 81 83 80</code> 에서 <code>83</code> 을 해석할때, 테이블에 있어야 해석을 하는데 없으므로 막혀버린다. </p>

<p>이 경우를 잘 보면 <code>83</code> 을 해석해야 하고, 현재 테이블에 <code>82</code> 까지의 심볼만 존재한다. 그리고 방금 전 까지 읽은건 <code>81</code> 이다. <code>83</code> 은 <code>ABA</code> 인데, 이건 <code>81</code> 의 심볼을 <code>val</code> 이라 하면 <code>val + val.charAt(0)</code> 과 동일하다.</p>

<p>구현은</p>

<pre><code class="java">public static void expand() {  
    String[] st = new String[L];
    int i; // next available codeword value

    for (i = 0; i &lt; R; i++) 
        st[i] = "" + (char) i;

    st[i++] = ""; // termination codeword

    int codeword = BinaryStdIn.readInt(W);
    if (codeword == R) return; // if empty message
    String val = st[codeword];

    while(true) {
        BinaryStdOut.write(val);

        codeword = BinaryStdIn.readInt(W);
        if (codeword == R) break;

        String s = st[codeword];

        // tricky case
        if (codeword == i) s = val + val.charAt(0);
        // add string into table
        if (i &lt; L) st[i++] = val + s.charAt(0);

        val = s;
    }

    BinaryStdOut.close();
}
</code></pre>

<p>해석할때 <code>val</code> 은 지난단계의 해석, <code>s</code> 는 현재 읽은 값의 해석이라 생각하면 쉽다.</p>

<h4 id="losslessdatacompression">Lossless Data Compression</h4>

<p><em>LZW</em> 같은 경우 특허가 있었는데, 2003년에 만료되었다고 한다. 이 알고리즘의 많은 변형이 있는데, <em>LZ77</em> 은 특허가 없어서 오픈소스에 많이 쓰인다고 함. <em>deflate  zlib</em> 는 <em>LZ77</em> 과 <em>Huffman</em> 을 섞여 쓰는 대표적인 압축 알고리즘</p>

<p><em>bit / char</em> 를 기준으로 보면 아스키는 <code>7</code>, 허프만은 <code>4.7</code> 정도의 성능을 보여준다. 1995년에는 <em>Burrows-Wheeler</em> 알고리즘이 발명되었는데 <code>2.29</code> 정도까지 압축한다. 1999년에는 <em>RK</em> 알고리즘이 <code>1.89</code> 까지 압축에 성공함.</p>

<h3 id="summary">Summary</h3>

<ul>
<li><strong>Huffman:</strong> represent <em>fixed-length symbols</em> with <em>variable-length codes</em></li>
<li><strong>LZW:</strong> represent <em>variable-length symbols</em> with <em>fixed-length codes</em></li>
</ul>

<p><em>lossy compression</em> 의 경우 <em>FFT</em>, 프랙탈 등 수학적 도구를 이용해 만드 알고리즘들이 많다.</p>

<p>그리고 압축의 이론적 한계는 <em>shanon entropy</em> 에 의해</p>

<p><img src='http://crackingthenutshell.com/wp-content/uploads/file/shannons-formula-small.jpg'  alt="" /></p>

<h3 id="reference">Reference</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='http://www.lawfareblog.com/2013/09/the-nsa-and-encryption/' >The NSA and Encryption</a> <br />
(4) <a href='http://www.programering.com/a/MTO4YzNwATE.html' >Data Compression Lecture Note</a> <br />
(5) <a href='http://lcm.csa.iisc.ernet.in/dsa/node88.html' >Huffman Algorithm</a>  </p>]]></description><link>http://1ambda.github.io/algorithm-data-compression/</link><guid isPermaLink="false">58cf48f9-4e5e-4a17-80ca-be11ef6ffdc7</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[compression]]></category><category><![CDATA[run-length]]></category><category><![CDATA[huffman]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 29 Dec 2014 06:20:14 GMT</pubDate></item><item><title><![CDATA[Regular Expression, NFA]]></title><description><![CDATA[<p><img src='http://4.bp.blogspot.com/-esm-BsLlh_U/UzlC63ecqEI/AAAAAAAAADs/lgZ2I71OGgs/s1600/2013-02-10-regular-expression-problems.png'  alt="" /></p>

<h3 id="regularexpression">Regular Expression</h3>

<p>이전까지 배웠던 패턴매칭 기법들은 모두 단일 패턴만을 찾았었. (e.g <em>substring search</em>) 일치하는 <strong>집합</strong> 을 원한다면 어떻게 해야할까? </p>

<p>예를 들어 유전자 분석에서는 <em>Fragile X syndrome</em> 은 <code>GCG(CGG|AGG)*CTG</code>  패턴에서 더 많이 반복될수록 <em>fragile x</em> 신드롬일 확률이 높다. 이 경우에는 하나가 아니라 몇번 일치하는지가 중요한 결과값이 된다.</p>

<p>따라서 문자열 같은 단일 패턴이 아니라 <strong>집합</strong> 으로 지정된 패턴을 찾아낼 수 있는 알고리즘이 필요하다.</p>

<p><em>regex</em> 의 응용은</p>

<ul>
<li>natural language processing</li>
<li>scan for virus signatures</li>
<li>syntax highlighting</li>
<li>text filtering</li>
<li>parsing text (compiler, crawler)</li>
</ul>

<blockquote>
  <p>A <strong>regular expression</strong> is a notation to specify a set of string</p>
</blockquote>

<p>사용 가능한 연산으로</p>

<p><img src='http://homepages.ius.edu/RWISMAN/C431/html/ch2-15.gif'  alt="" /></p>

<p align="center">(<a href='http://homepages.ius.edu/RWISMAN' >http://homepages.ius.edu/RWISMAN</a>)</p>

<ul>
<li><em>concat</em> (3)</li>
<li><em>or</em> (4)</li>
<li><em>closure</em> (2)</li>
<li><em>parenthesis</em> (1)</li>
</ul>

<p>괄호 안은 우선순위다. 편의를 위한 연산으로</p>

<ul>
<li><em>wildcard</em> <code>.</code></li>
<li><em>character class</em> <code>[A-Za-z][a-z]*</code></li>
<li><em>at lest 1</em> <code>+</code></li>
<li><em>exactly k</em> <code>[0-9]{5}</code></li>
</ul>

<p><code>[A-E]+</code> 를 기본 연산으로 풀어쓰면 <code>(A|B|C|D|E)(A|B|C|D|E)*</code> 다.</p>

<p>정규표현식을 작성하는 것은 프로그램을 만드는 것과 비슷하다</p>

<ul>
<li>need to understand programming model</li>
<li>can be easier to write than read</li>
<li>can be difficult to debug</li>
</ul>

<blockquote>
  <p>Res are amazingly powerful and expressive. but using them in applications can be amazingly complex and error-prone</p>
</blockquote>

<h3 id="resandnfa">REs and NFA</h3>

<p><em>RE</em> 와 <em>DFA</em> 는 <em>dual</em> 이다. </p>

<ul>
<li><strong>RE:</strong> concise way to desribe a set of string</li>
<li><strong>DFA:</strong> machine to recognize whether a given string in a given set</li>
</ul>

<p><em>Kleene's theorem</em> 에 의하면</p>

<p>어떤 <em>DFA</em> 든 같은 문자열 집합을 기술하는 <em>RE</em> 가 존재하고, 역으로 어느 <em>RE</em> 에 대해서도 같은 문자열 집합을 인식할 수 있는 <em>DFA</em> 가 존재한다.</p>

<p>따라서 <em>RE</em> 로 부터 <em>DFA</em> 를 만들고, 이걸 인풋에 대해 돌리면 된다. 그리고 <em>DFA</em> 를 사용하기 때문에 <em>KMP</em> 알고리즘처럼</p>

<ul>
<li>no backup in text input stream</li>
<li>linear-time guarantee</li>
</ul>

<p>하지만 실제로는 <em>DFA</em> 를 사용하기가 어렵다. 이는 <em>DFA</em> 가 수 많은 상태를 가질 수 있기 때문이다. 따라서 <em>DFA</em> 대신 <em>NFA</em> 를 이용하는 방법이 개발되었다. 
<em>NFA</em> 를 이용하면 <em>quadratic-time guarantee</em> 다.</p>

<p><em>NFA, Nondeterministic finite-state automata</em> 에서는</p>

<ul>
<li><em>RE</em> enclosed in parentheses</li>
<li>One state per <em>RE</em> character (start=<code>0</code>, accpet=<code>M</code>)</li>
<li><em>ε-transition</em> (change state, but dn't scan text)</li>
<li>accept if <strong>any</strong> sequence of transitions ends in accpet state</li>
</ul>

<p>뭔소린가 해서 구글링을 좀 해보니</p>

<blockquote>
  <ul>
  <li><p>If it’s a <strong>DFA</strong>, we know that each word completely determines the final state of the automaton, and we say that the word is accepted if that state is an acceptor state.</p></li>
  <li><p>If it’s an <strong>NFA</strong>, there might be several possible final states that could result from reading a given word; as long as at least one of them is an acceptor state, we say that the automaton accepts the word.</p></li>
  </ul>
</blockquote>

<p><em>DFA</em> 는 입력에 대해 결과값이 항상 하나로 일정하지만, <em>NFA</em> 에서는 복수개의 <em>final state</em> 가 만들어질 수 있다. 그리고 이 때 하나라도 <em>accept</em> 되면,  입력값이 <em>accept</em> 된 것으로 본다.</p>

<p>이 때 다양한 <em>final state</em> 가 만들어 지는 이유는 스캔 없이 상태를 변경하는 <em>ε-transition</em> 때문이다. 따라서 같은 입력이라도, 올바르게 파싱할수도, 그렇지 않을수도 있다.</p>

<p>따라서 <em>NFA</em> 에서는 모든 가능한 경우에 대해 시뮬레이션 해야한다. 그런데, 하나씩 다 해보긴 비효율적이므로 매 문자를 읽을때마다 <em>all possible states</em> 를 유지하면서 <em>match, ε-transition</em> 을 적용해 나간다. 그리고 모든 문자를 다 읽었을때 <em>possible state</em> 에 <em>accept</em> 가 있으면 성공적으로 패턴이 매칭된 것이다.</p>

<p>따라서 <em>possible state</em> 를 얻기 위해 <em>reachability</em> 를 계산해야 하는데 <em>digraph</em> 를 사용하면 문제가 쉬워진다. 방문하지 않은 <em>vertex</em> 가 없을때까지 <em>DFS</em> 를 돌리면 된다. 러닝타임은 <code>E + V</code></p>

<h3 id="nfasimulation">NFA Simulation</h3>

<p>코드는 </p>

<pre><code class="java">public class NFA {  
    private char[] re; // match transition
    private Digraph G; // epsilon transition
    private int M;     // # of states

    public NFA(String regex) {
        M = regex.length();
        re = regex.toCharArray();
        G = buildEpsilonTransitionDigraph();
    }

    private Digraph buildEpsilonTransitionDigraph() {
        // TODO Auto-generated method stub
        return null;
    }

    public boolean recognizes(String txt) {

        Bag&lt;Integer&gt; rs = new Bag&lt;Integer&gt;(); // reachable states
        DirectedDFS dfs = new DirectedDFS(G, 0); 

        // get reachable states initially
        for (int v = 0; v &lt; G.V(); v++) 
            if (dfs.marked(v)) rs.add(v);

        for (int i = 0; i &lt; txt.length(); i++) {

            // match transition
            Bag&lt;Integer&gt; match = new Bag&lt;Integer&gt;();
            for (int v : rs) {
                if (v == M) continue;
                if ((re[v] == txt.charAt(i)) || re[v] == '.')
                    match.add(v + 1); // add next state 
            }

            // run epsilon transition with match
            dfs = new DirectedDFS(G, match);
            rs = new Bag&lt;Integer&gt;();
            for (int v = 0; v &lt; G.V(); v++)
                if (dfs.marked(v)) rs.add(v);
        }

        for (int v : rs) 
            if (v == M) return true;

        return false;
    }
}
</code></pre>

<p><em>NFA simulation</em> 은 <code>N</code> 길이의 텍스트, <code>M</code> 길이의 패턴에 대해서 <em>worst case</em> 일 때 <code>MN</code> 의 성능을 보인다.</p>

<p>이는 <code>N</code> 개의 텍스트에서, 한 문자를 스캔할때 마다 최대 <code>M</code> 개의 <em>state</em> 가 있을 수 있고, 여기에 대해 <em>ε-transition</em> 를 찾기 위해 <em>DFS</em> 를 돌리기 때문이다. </p>

<p>쉽게 말해서 노드 수가 <code>M</code> 인 그래프에 대해 <em>DFS</em> 를 돌리는데, <code>N</code> 번 돌리기 때문에 최악의 경우 <code>MN</code> 의 성능을 보여준다는 것이다.</p>

<p>그리고 뒤에서 자세히 언급하겠지만 <em>NFA construction</em> 에서 그래프의 <em>edge</em> 수가 <code>&lt;= 3M</code> 임을 보장한다. </p>

<h3 id="nfaconstruction">NFA Construction</h3>

<p><em>regex</em> 에 대응하는 <em>NFA</em> 를 만드는 과정은 <em>match, ε-transition</em> 로 이어진 그래프를 만드는것과 동일하다. <em>regex</em> 에서 각 연산들에 대해</p>

<ul>
<li><strong>concatenation:</strong> add <em>match-transition</em> edge from state corresponding to chars in the alphabet to next state</li>
</ul>

<p>알파벳으로부터만 연결하므로 <code>( -&gt; )</code> 등은 <em>match transition</em> 으로 연결하지 않는다.</p>

<ul>
<li><p><strong>parentheses:</strong> add <em>ε-transition</em> edge from parentheses to next state</p></li>
<li><p><strong>closure:</strong> add three <em>ε-transition</em> edges for each <code>*</code> operator</p></li>
</ul>

<p>예를 들어 <code>A*B</code> 의 경우, <code>A -&gt; *</code>, <code>* -&gt; A</code>, <code>* -&gt; B</code> 3개의 <em>ε-transition</em> 을 추가한다. </p>

<ul>
<li><strong>or:</strong> add two <em>ε-transition</em> edges for each <code>|</code> operator</li>
</ul>

<p>예를 들어 <code>( A | B )</code> 의 경우 <code>( -&gt; B</code>, <code>| -&gt; )</code> 로 <em>ε-transition</em> 을 추가한다.</p>

<p><em>NFA</em> 를 만드는데 있어서 한 가지 어려운점은 <em>closure</em> 을 만들기 위해서는 <code>(</code> 를 기억해야 하고, <em>or</em> 을 만들기 위해서는 <code>(</code> 와 <code>|</code> 의 위치를 알고 있어야 한다는 점이다. 스택을 쓰면 된다.</p>

<ul>
<li><code>(</code> 를 만나면 <code>(</code> 를 스택에 넣고</li>
<li><code>|</code> 를 만나면 <code>|</code> 를 스택에 넣자</li>
<li><code>)</code> 를 만나면 <code>(</code> 를 스택에서 빼고, <code>|</code> 도 있다면 그것도 빼자. 스택엣 제거한 <code>(, |</code> 의 위치를 이용해 <em>closure</em>, <em>or</em> 을 만들 수 있다. </li>
</ul>

<p><a href='http://www.youtube.com/watch?v=RYNN-tb9WxI' >Regex to NFA</a> 를 보는게 이해가 더 쉬울듯. (강의 끝부분에 약간 틀린곳이 있으니 댓글을 참조하자.)</p>

<p>구현은</p>

<pre><code class="java">    private Digraph buildEpsilonTransitionDigraph() {

        Digraph G = new Digraph(M + 1); // including the accept state
        Stack&lt;Integer&gt; ops = new Stack&lt;Integer&gt;();

        for (int i = 0; i &lt; M; i++) {
            int lp = i;

            // keep '(', '|' to implement closure, OR
            if (re[i] == '(' || re[i] == '|') ops.push(i);

            // OR
            else if (re[i] == ')') {
                int or = ops.pop();

                if (re[or] == '|') { // if '|' exists
                    lp = ops.pop();
                    G.addEdge(lp, or + 1);
                    G.addEdge(or, i);
                } 
                else lp = or;        // left paren
            }

            if (i &lt; M - 1 &amp;&amp; re[i + 1] == '*') {
                G.addEdge(lp, i + 1);
                G.addEdge(i + 1, lp);
            }

            if (re[i] == '*' || re[i] == '(' || re[i] == ')')
                G.addEdge(i, i + 1);
        }

        return G;
    }
</code></pre>

<p>만약 <code>+</code> 를 만들고 싶다면 <code>*</code> 과 같지만 <code>i -&gt; i + 1</code> 또는 괄호가 있을때는 <code>lp -&gt; i + 1</code> <em>edge</em> 하나를 제거해야 한다. (바로 넘어가는 경우가 없기 때문)</p>

<p><em>NFA</em> 를 만들때 <code>M</code> 길이의 패턴에 대해 시간과 공간 비용은 <code>M</code> 에 비례한다. 이는 아무리 많아봐야 한 <em>state</em> 에 대해 3개의 <em>ε-transition</em>, 2개의 스택 연산이 필요하기 때문이다.</p>

<h3 id="regexapplication"> Regex Application</h3>

<pre><code class="java">String regex = ".*" + p + ".*";  
NFA nfa = new NFA(regex);

while (stdin.hasNext) {  
  String line = stdin.readLine();

  if (nfa.recognize(line))
    println(line)
}
</code></pre>

<p>자주 쓰는 프로그램인 <em>grep</em> 도 <em>regex</em> 를 사용한다. 패턴을 <code>p</code> 를 받아 <code>(.*p.*)</code> 처럼 <em>regex</em> 를 만들어 라인마다 검사할 수 있다. 근데, <em>worst case</em> 에는 라인마다 <code>MN</code> 이니까 <em>brute force substring search</em> 랑 별 차이가 없다.</p>

<p><em>validation</em> 을 위해 사용할수도 있다. 컴파일러에서 변수 이름이 규칙에 맞는지 검사하거나, 사용자의 입력이 올바른 이메일인지 등등.</p>

<p><em>regex</em> 는 대부분의 언어에서 라이브러리 형태로 사용할 수도 있다. 자바에서도 지원하는데</p>

<pre><code class="java">import java.util.regex.Pattern;  
import java.util.regex.Matcher

String regex = args[0];  
Pattern p = Pattern.compile(regex) // create NFA from RE  
Matcher m = p.matcher(input)       // build NFA simulator

while (m.find()) {  
  do something using m.group()
}
</code></pre>

<h4 id="algorithmiccomplexityattacks">Algorithmic complexity attacks</h4>

<p>그리고 대부분의 구현(자바, 그렙, 펄을 포함해서)이 <em>performance</em> 를 보장하지 않는다고 한다.</p>

<pre><code>java Validate "(a|aa)*b" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaac             1.6 seconds  
java Validate "(a|aa)*b" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac           3.7 seconds  
java Validate "(a|aa)*b" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac         9.7 seconds  
java Validate "(a|aa)*b" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac      23.2 seconds  
java Validate "(a|aa)*b" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac    62.2 seconds  
java Validate "(a|aa)*b" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac 161.6 seconds  
</code></pre>

<p>스팸 필터기에 <code>spammer@x.......................................</code> 따위의 주소로 이메일을 보낸다거나.</p>

<h4 id="backreferences">Back References</h4>

<p><code>\1</code> 은 보통 바로 전에 매칭된 부분을 의미한다. 대부분의 언어에서 지원하긴 하는데</p>

<blockquote>
  <p>Pattern matching with back-references in intractable</p>
</blockquote>

<p>요것도 퍼포먼스 어택이 올 수 있다고 함.</p>

<h3 id="summary">Summary</h3>

<p><em>language</em>, <em>abstract machine</em>, <em>non-deterministic</em> 등은 컴퓨터 과학의 중요한 이론적 토대가 된다.</p>

<p>지금까지 공부한 알고리즘은 <em>machine code</em> 를 돌려주는 일종의 컴파일러라 볼 수 있다.</p>

<ul>
<li><strong>KMP:</strong> string -> DFA</li>
</ul>

<p>파서는 필요없고, <em>DFA simulator</em> 를 이용해 실행</p>

<ul>
<li><strong>Grep:</strong> regex -> NFA</li>
</ul>

<p><em>legal</em> 인지 확인할 파서가 필요하며 <em>NFA simulator</em> 를 이용</p>

<ul>
<li><strong>Javac:</strong> java langugage -> java byte code</li>
</ul>

<p>마찬가지로 파서가 필요하며 <em>JVM</em> 을 이용해 실행</p>

<h3 id="reference">Reference</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='http://homepages.ius.edu/RWISMAN/C431/html/Chapter2.htm' >http://homepages.ius.edu/RWISMAN</a> <br />
(4) <a href='http://math.stackexchange.com/questions/563829/difference-between-nfa-and-dfa' >Difference between NFA and DFA</a>  </p>]]></description><link>http://1ambda.github.io/regex-nfa/</link><guid isPermaLink="false">1ffd482b-3d2c-426f-9638-75ff1708d6c8</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[NFA]]></category><category><![CDATA[regex]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 29 Dec 2014 01:10:54 GMT</pubDate></item><item><title><![CDATA[Maximum Flow]]></title><description><![CDATA[<p><img src='https://graph-tool.skewed.de/static/doc/_images/example-edmonds-karp.png'  alt="" /></p>

<h3 id="mincut">Min Cut</h3>

<p><em>edge weighted</em> 그래프에서 <code>st</code>-<em>cut</em> 이란 <em>vertices</em> 를 두개의 <em>disjont sets</em> 으로 나누는 것이다. 이때 <code>s</code>, <code>t</code> 는 각각 다른 집합 <code>A</code>, <code>B</code> 에 속해있다.</p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/0/02/Min-cut.svg/220px-Min-cut.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org/' >http://en.wikipedia.org</a>)</p>

<p><strong>capacity</strong> 란 컷으로 나뉘어진 두 집합 <code>A</code>, <code>B</code> 를 기준으로 <code>A</code> 에서 <code>B</code> 로 가기 위한 모든 <em>edge</em> 의 <em>weight</em> 를 모두 합친 것이다. <code>B</code> 에서 <code>A</code> 로의 <em>edge</em> 는 세지 않는 다는 것에 주의하자.</p>

<p><em>mincut problem</em> 은 <em>min capacity</em> 를 갖는 <em>cut</em> 을 찾는 문제다. 응용으로는</p>

<ul>
<li>실제 전쟁에서 보급로를 끊거나</li>
<li>독재 정부에서 커뮤니케이션을 제한하거나</li>
</ul>

<h3 id="maxflow">Max Flow</h3>

<p><img src='http://kunuk.files.wordpress.com/2010/11/fordfulkerson1.gif?w=700'  alt="" /></p>

<p align="center">(<a href='http://kunuk.wordpress.com/' >http://kunuk.wordpress.com</a>)</p>

<p><em>edge</em> 에 <em>weight</em> 이외에도 <em>flow</em> 를 할당할 수 있다. 이 플로우는 몇 가지 성질을 만족하는데</p>

<ul>
<li><strong>capacity constraint:</strong> <code>0 &lt;= edge's flow &lt;= edge's capa</code></li>
<li><strong>local equilibrium:</strong> <code>inflow = outflow</code> at every vertex except <code>s</code> and <code>t</code></li>
</ul>

<p>즉 한 에지에서 캐퍼시티는 항상 플로우보다 크거나 같고, <code>s, t</code> 를 제외한 모든 노드에서 <em>inflow = outflow</em> 다.</p>

<p><em>flow</em> 의 <em>value</em> 는 <code>t</code> 에서의 <em>inflow</em> 다. 이때 <code>s</code> 를 가리키는 노드가 없고, <code>t</code> 가 가리키는 노드가 없다고 가정한다. 다시 말해 <code>s</code> 는 시작점, <code>t</code> 는 종료지점이다.</p>

<p>따라서 플로우를 어떻게 할당하냐에 따라 <em>value</em> 가 달라질 수 있다. 이 때 <em>maximum flow</em> 문제는 최대 값을 갖는 <em>flow</em> 를 찾는 문제다.</p>

<p><em>max flow</em> 의 응용은</p>

<ul>
<li>운송량을 최대로 하는 보급로를 찾기</li>
</ul>

<h4 id="summary">Summary</h4>

<p>정리하면 <em>weighted digraph</em> 에서 <em>source vertex</em> <code>s</code>, <em>target vertex</em> <code>t</code> 에 대해</p>

<p>두 가지 문제를 정의할 수 있다.</p>

<ul>
<li><strong>min cut:</strong> Find a cut of minimum capacity</li>
<li><strong>max flow:</strong> Find a flow of maximum value</li>
</ul>

<p>사실 이 문제는 상당히 유사한데, <em>dual</em> 관계다. 하나를 풀면 다른 하나도 풀 수 있다.</p>

<h3 id="fordfulkersonalgorithm">Ford-Fulkerson Algorithm</h3>

<p>기본적인 아이디어는 <em>augmenting path</em> 를 찾으면서 <em>flow</em> 값을 증가시키는 것이다.</p>

<ul>
<li><em>forward edge</em> (not full) 을 이용해서 <em>flow</em> 값을 증가시키고</li>
<li><em>backward edge</em> (not empty) 를 이용해서 감소시킬 수 있다</li>
</ul>

<p><em>backward edge</em> 의 아이디어는 <em>local equilibrium</em> 이다. 진행할 수 없는 상황에서 <em>backward edge</em> 를 만들고, 거기서 <em>flow</em> 의 평형을 맞추는 값만큼 뺀 후 다시 진행한다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWXljek0wSTJNaWRqWTNZVEx6RWpaaDF5TTVZMk10TWpabVZUTDVNR1ppbHpZaUJ6TDNNek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>더이상 <em>augmenting path</em> 를 찾을 수 없을 때 알고리즘이 종료된다. 이건 <em>full forward edge</em> 가 존재하거나 <em>empty backword edge</em> 가 만들어졌기 때문이다.</p>

<p><img src='http://www.cs.princeton.edu/courses/archive/spr13/cos226/lectures/summaries/maxFlowCheckpoint.png'  alt="" /></p>

<p align="center">(<a href='http://www.cs.princeton.edu/' >http://www.cs.princeton.edu/</a>)</p>

<p>알고리즘을 서술하면</p>

<pre><code>// Fold-Fulkerson algorithm

Start with 0 flow  
While there exists an augmenting path  
- find an augmenting path
- compute bottleneck capacity
- increase flow on that path by bottleneck capacity
</code></pre>

<p>그럼, 이제 문제는 <em>min cut</em> 은 어떻게 계산하고 <em>augmenting path</em> 는 어떻게 찾을지로 치환된다.</p>

<p>그리고 추가적인 질문으로 <em>FF</em> 알고리즘이 <em>max flow</em> 를 찾는지, 그리고 항상 종료된다는 걸 보장하는지, 종료된다면 얼마만큼의 <em>augmentations</em> 를 찾아내는지를 물어볼 수 있다.</p>

<p>좀 더 자세한 알고리즘 설명은 이 <a href='http://www.cs.princeton.edu/courses/archive/spring13/cos226/lectures/64MaxFlow.pdf' >슬라이드</a> 를 참조할 것</p>

<h3 id="maxflowmincuttheorem">Maxflow-Mincut Theorem</h3>

<p><em>cut</em> 과 <em>flow</em> 는 무슨 관계일까? </p>

<p><em>net flow accros cut</em> <code>(A, B)</code> 는 <code>A-&gt;B</code> 로의 <em>flow</em> 를 모두 합한 것에서 <code>B-&gt;A</code> 로의 <em>flow</em> 를 모두 뺀 것이다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5WWhKV1lsRkRaeVFtTTVZV0xtVkRPaTF5TTFjek10TXpZbGxUTGxCRE1pWkRaaFZ6TDVNek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<blockquote>
  <p><em>flow-value lemma:</em> Let <code>f</code> be any flow and let <code>(A, B)</code> be any cut. Then the net flow accros <code>(A, B)</code> equals the value of <code>f</code></p>
</blockquote>

<p><code>B</code> 의 사이즈에 대해 귀납법을 이용하면 증명은 어렵지 않다.</p>

<p>(1) Base case <code>B = { t }</code></p>

<p><em>base case</em> 에선 당연히 <em>value</em> 와 <em>net flow accros</em> 가 동일하다.</p>

<p>(2) Inductive case</p>

<p><code>A</code> 에서 <code>B</code> 로 <em>vertex</em> 를 하나씩 옮겨도 <em>local equilibrium</em> 이 참이므로 이 속성은 유지된다. 옮기려는 <em>vertex</em> 를 <code>k</code> 라 하면</p>

<p><code>k</code> 를 기준으로 <em>inflow</em></p>

<ul>
<li><code>A -&gt; k</code></li>
<li><code>B -&gt; k</code></li>
</ul>

<p>는 다음의 <em>outflow</em> 와 동일하다.</p>

<ul>
<li><code>k</code> -> <code>A</code></li>
<li><code>k</code> -> <code>B</code></li>
</ul>

<p>그런데 <code>k</code> 를 <code>B</code> 로 옮기게 되면 <em>net flow accros</em> 에 미치는 영향이 <em>inflow</em>, <em>outflow</em> 간 반대가 되지만 어쨌든 <em>local equilibrium</em> 에 의해 값은 같으므로 어차피 <em>value</em> 와 같다.</p>

<p>그리고 결국 <code>k</code> 를 계속 옮기다 보면<code>s</code> 의 <em>outflow</em> 는 <code>t</code> 의 <em>inflow</em> 와 같고 이것인 <em>value of flow</em> 와 같다.</p>

<h4 id="weakduality">Weak Duality</h4>

<p><em>weak duality</em> 란 <code>f</code> 를 아무 플로우, <code>(A, B)</code> 를 어느 컷이라 할 때 </p>

<blockquote>
  <p><em>value of flow</em> <code>&lt;=</code> <em>capacity of cut</em></p>
</blockquote>

<p>이 성립함을 말한다. 따라서 <em>max flow</em> 는 <em>min cut</em> 이다. 증명과정을 좀 보자. 위에서 귀납법으로 참임을 보인 성질에 의해 다음이 성립한다. <del>뜬금없이 증명해버림</del></p>

<p><em>value of flow</em> <code>f</code> = *net flow accros <code>(A, B)</code> &lt;= capacity of <code>(A, B)</code></p>

<ul>
<li><strong>Augmenting path theorem:</strong> A flow <code>f</code> is a maxflow iff no augmenting paths</li>
<li><strong>Maxflow-mincut theorem:</strong> Value of the maxflow = capacity of mincut</li>
</ul>

<p>즉 이 말은 <del>동어 반복의 향연</del></p>

<p>(1) 플로우 <code>f</code> 의 <em>value</em> 와 동일한 값의 <em>capacity</em> 를 가지는 어떤 컷이 있다. <br />
(2) <code>f</code> 는 <em>max flow</em> 다 <br />
(3) <code>f</code> 에 대해 <em>augmenting path</em> 가 없다.</p>

<p>정리해 보면 <em>max flow</em> 로 부터 <em>min cut</em> 을 계산할 수 있다는 소리가 된다. 잘 보면 <em>max flow</em> <code>f</code> 에서는 <em>augmenting path</em> 가 없다.</p>

<p>다시 말해 </p>

<ul>
<li>한 집합은 <code>s</code> 에서 <em>non-full forward</em> 로 출발하지만 <em>empty backward</em> 에 의해 막히고</li>
<li>다른 집단은 <em>full foraward</em> 때문에 <code>t</code> 로의 <em>non empty backword</em> 가 막힌다.</li>
<li>이 두집단의 자르는 <em>cut</em> 은 <em>full forward</em>, <em>empty backward</em> 로만 구성된다.</li>
</ul>

<p>이 컷은 <em>net flow accros cut</em> 고 첫번째 집단은 <code>A</code>, 두번째 집단은 <code>B</code> 가 된다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWjVZR05sSlRPaE4yTm1KVEw1TVdZNTBDTzJnek10VW1ZaUZXTG1CRFpoRkRaaU56THpRek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>따라서 러닝타임은 <em>max flow</em> <code>f</code> 가 주어진다면 모든 <em>vertex</em>, <em>edge</em> 를 한번씩 보며 <code>A</code> 를 찾는 시간이므로 <code>V + E</code> 다.</p>

<h3 id="runningtimeanalysis">Running Time Analysis</h3>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5WTBJRE40a3pNMklXWW1KVEx5SVRaNTB5WWpaek10QVROaGhUTGlSV1lqUkdPM1V6TDNRek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>아까 했던 질문들에 답해보면</p>

<ul>
<li><em>mincut</em> 을 계산하긴 쉽다.</li>
<li><em>BFS</em> 로 <em>augmenting path</em> 를 찾을 수 있다.</li>
<li><em>Ford-Fulkerson</em> 이 종료되면 <em>max flow</em> 를 찾을 수 있다</li>
<li><em>capacity</em> 가 정수거나, <em>argumenting path</em> 를 신중히 고른다면 <em>FF</em> 는 종료된다.</li>
<li>얼마나 많은 <em>augmentations</em> 가 있을진 생각좀 해봐야 한다.</li>
</ul>

<p>간단한 경우부터 좀 보자.</p>

<h4 id="integercapacities">Integer Capacities</h4>

<p><em>edge capacities</em> 가 <code>[1, U]</code> 사이의 값이면 <em>FF</em> 알고리즘에 걸쳐서 모든 <em>flow</em> 값은 정수다. 쉽게 증명 가능한데</p>

<ul>
<li>Bottleneck capacity is an integer</li>
<li>Flow on an edge increases / decreases by bottleneck capa</li>
</ul>

<blockquote>
  <p><code># of augmentations &lt;= max flow value</code></p>
</blockquote>

<p>다시 말해 <em>augmentations</em> 의 수는 <em>max flow value</em> 보다 작거나 같다. 왜냐하면 처음에 <code>0</code> 부터 시작해서 매 <em>augmentation</em> 마다 적어도 <em>value</em> 를 1 씩 증가시키기 때문이다.</p>

<ul>
<li><strong>Integrality theorem:</strong> There exists an integer-values maxflow </li>
</ul>

<p>이 때 <em>FF</em> 알고리즘이 종료되면 <em>max flow</em> 를 찾아내고, 이것은 위에서 보였듯이 <em>integer-value</em> 를 가진다.</p>

<h4 id="badcaseforff">Bad case for FF</h4>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTW1Oek15RW1Zd0FqTWlWVExpbHpZNTBDWmhSMk10VURad01UTDJZek1oTldNeEl6THhVek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p><em>integer value max flow</em> 에선 운이 나쁠 경우 <em>max flow value</em> 만큼 <em>augmentation</em> 이 일어난다. 위 슬라이드에서 볼 수 있듯이 그래프 사이즈에 비해 어마어마한 <em>augmentation</em> 이 일어날 수 있다.</p>

<p>다행히도 <em>shortest, fattest path</em> 를 이용해 이런 상황을 피할 수 있다.</p>

<ul>
<li><em>shortest path:</em> augmenting path with <strong>fuwest number of edges</strong></li>
<li><em>fattest path:</em> augmenting path with <strong>maximum bottleneck capacity</strong></li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5WWtWMk4yTUdNbFZUWmpWVEx6UVdZaTFDTWtOMk10UVdNaUJUTGlaR1owTVRNbVoyTDFVek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>따라서 <em>FF</em> 알고리즘의 성능은 어떤 <em>augmenting path</em> 를 선택하느냐에 따라 달라질 수 있다.</p>

<h3 id="implementation">Implementation</h3>

<p><em>Ford-Fulkerson</em> 알고리즘을 구현함에 있어서 실제로 사용하게 될 값은 두 가지다.</p>

<ul>
<li><em>forward edge residual capacity</em> = <code>c - f</code></li>
<li><em>backward edge residual capacity</em> = <code>f</code></li>
</ul>

<p>따라서 <em>flow</em>, <em>capacity</em> 보다는 <em>residual capacity</em> 를 <em>edge</em> 의 가중치로 표시하는 <em>residual network</em> 를 이용하는편이 더 직관적이다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTT2lSMk1rRkdNNGN6WTVVVExsRjJZNTB5WWlsek10RVRPeVFXTDRjak41TVRObVp6TDNVek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>실제 클래스 구현은</p>

<pre><code class="java">public class FlowEdge {

  private final int v, w;
  private final double capacity;
  private double flow;

  public FlowEdge(int v, int w, double capacity) {
    this.v = v; 
    this.w = w;
    this.capacity = capacity;
  }

  public int from() { return v; }
  public int to() { return w; }
  public double capacity() { return capacity; }
  public double flow() { return flow; }

  // other endpoint
  int other(int vertex) {
    if (vertex == v) return w;
    else if (vertex == w) return v;
    else throw new RuntimeException("Illegal endpoint");
  }

  // residual capacity toward v
  double residualCapacityTo(int vertex) {
    if (vertex == v)      return flow;            // backward edge
    else if (vertex == w) return capacity - flow; // forward edge
    else throw new IllegalArgumentException();
  }

  // add delta flow toward v
  void addResidualFlowTo(int vertex, double delta) {
    if (vertex == v)      flow -= delta; // backward edge
    else if (vertex == w) flow += delta; // forward edge
    else throw new IllegalArgumentException();
  } 
}
</code></pre>

<p><code>FlowNetwork</code> 는</p>

<pre><code class="java">public class FlowNetwork {  
  private final int V;
  // Bag is a list without remove op
  private Bag&lt;FlowEdge&gt;[] adj;

  public FlowNetwork(int V) {
    this.V = V;
    adj = (Bag&lt;FlowEdge&gt;[]) new Bag[V];
    for (int v = 0; v &lt; V; v++)
      adj[v] = new Bag&lt;FlowEdge&gt;();
  }

  public void addEdge(FlowEdge e) {
    int v = e.from();
    int w = e.to();
    adj[v].add(e); // add forward edge
    adj[w].add(e); // add backward edge
  }

  public Iterable&lt;FlowEdge&gt; adj(int v) { 
    return adj[v];
  }

  public int V() { return V; }
}
</code></pre>

<p><em>FF</em> 알고리즘 구현은 아래와 같다. <em>shortest augmenting path</em> 를 찾기 위해 <em>BFS</em> 를 이용했다.</p>

<pre><code class="java">public class FordFulkerson {

  private boolean[] marked;  // ture if s-&gt;v path in residual network
  private FlowEdge[] edgeTo; // last edge on s-&gt;v path
  private double value;      // value of flow

  public FordFulkersen(FlowNetwork G, int s, int t) {
    value = 0.0;

    while (hasAugmentingPath(G, s, t)) {
      double bottle = Double.POSITIVE_INFINITY;

      // compute bottleneck capacity
      for (int v = t; v != s; v = edgeTo[v].other(v))
        bottle = Math.min(bottle, edgeTo[v].residualCapacityTo(v));

      // augment flow
      for (int v = t; v != s; v = edgeTo[v].other(v))
        edgeTo[v].addResidualFlowTo(v, bottle);

      value += bottle;
    }
  }

  // find a shortest augmenting path using BFS
  private boolean hasAugmentingPath(FlowNetwork G, int s, int t) {
    edgeTo = new FlowEdge[G.V()];
    marked = new boolean[G.V()];

    Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
    q.add(s);
    marked[s] = true;

    while (!q.isEmpty()) {
      int v = q.remove();

      for (FlowEdge e : G.adj(v)) {
        int w = e.other(v);

        // path s-&gt;w is in the residual network?
        if (e.residualCapacityTo(w) &gt; 0 &amp;&amp; !marked[w]) {
          edgeTo[w] = e;
          marked[w] = true;
          q.add(w);
        }
      }
    }

    return marked[t];
  }

  public double value() { return value; }
  // is `v` reachable from s in residual network?
  public boolean inCut(int v) { return marked[v]; } 
}
</code></pre>

<p><img src='http://upload.wikimedia.org/wikipedia/en/thumb/0/0e/Max-flow_min-cut_example.svg/288px-Max-flow_min-cut_example.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org/' >http://en.wikipedia.org</a>)</p>

<p>테스트 코드도 좀 돌려보자. 예제는 위와 같고, 코드는 아래에 있다.</p>

<pre><code class="java">public class FordFulkensonTest {

  @Test
  public void test() {
    int E = 5;

    int s = 0;
    int t = 3;

    // http://en.wikipedia.org/wiki/Max-flow_min-cut_theorem#Example
    FlowEdge[] edges = new FlowEdge[E];
    edges[0] = new FlowEdge(s, 1, 4.0);
    edges[1] = new FlowEdge(s, 2, 3.0);
    edges[2] = new FlowEdge(1, 2, 3.0);
    edges[3] = new FlowEdge(1, t, 4.0);
    edges[4] = new FlowEdge(2, t, 5.0);

    int V = 4;
    FlowNetwork G = new FlowNetwork(V);

    for (FlowEdge e : edges)
      G.addEdge(e);

    FordFulkerson FF = new FordFulkerson(G, s, t);

    assert(FF.value() == 7);
  }
}
</code></pre>

<h3 id="maxflowapplication">Max Flow Application</h3>

<p><em>shortest path</em> 처럼 <em>max flow</em> 도 정말 많은 곳에 응용할 수 있다.</p>

<ul>
<li>Bipartite maching</li>
<li>Network reliability</li>
<li>Baseball elimination</li>
<li>Image segmentation</li>
<li>Distributed computing</li>
<li>...</li>
</ul>

<h4 id="bipartitemachingproblem">Bipartite maching problem</h4>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTTRNalowTVdPNE1UTTBVV0x6TVRONDBDTzFVMk10WUROakZUTDJVMk0wVUROa056THhZek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p><code>N</code> 명의 <em>student</em> 가 <code>N</code> 개의 <em>company</em> 로부터 각각 몇개씩의 주문을 받았을 때, <code>1:1</code> 로 대응하는 그래프를 그릴 수 있느냐의 문제다. </p>

<p><em>max flow</em> 알고리즘을 이용해 <em>bipartite maching</em> 문제를 풀 수 있다.</p>

<ul>
<li>Create <code>s</code>, <code>t</code>, one vertex for each student, and one vertex for each company(job)</li>
<li>Add edge from <code>s</code> to each student (capacity 1)</li>
<li>Add edge from each job to <code>t</code> (capacity 1)</li>
<li>Add edge from student to each job offered (infinite capacity)</li>
</ul>

<p>이렇게하면 <em>local equilibrium</em> 에 의해 각 <em>student</em> 마다 하나씩의 <em>out-flow</em> 밖에 가지지 못하고, 마찬가지로 <em>job</em> 도 하나씩의 <em>in-flow</em> 밖에 가지지 못하므로 <code>1:1</code> 대응을 만들 수 있다.</p>

<p>완벽히 매칭이 이루어지는지, 아닌지를 <em>min cut</em> 을 이용해 알 수 있다. 그림을 보자.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTm1OV08xSUdOd1VtWTJNVExsQnpNaDFTWjJRek10WXpNaUZUTGlWMk4wZ1ROa0p6THpZek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<ul>
<li>Let <code>S</code> = students on <code>s</code> side of cut.</li>
<li>Let <code>T</code> = companies on <code>s</code> side of cut.</li>
<li><code>|S|</code> > <code>|T|</code>; students in <code>S</code> can be matched only to companies in <code>T</code>.</li>
</ul>

<h4 id="baseballelimination">Baseball elimination</h4>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5TWhWVE9oZERNeGNET2paVEx6a0RPaDFDTm1WMk10UXpNMllUTGhKVFppSlRZME16TDFZek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<blockquote>
  <p>Which teams have a chance of finishing the season with the most wins?</p>
</blockquote>

<p>이건 게임이 얼마나 남았느냐 뿐만 아니라, 누구와 상대하냐도 문제가 되기 때문에 이렇게 그래프를 그려 풀 수 있다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTTm1SR08yVTJZMlFqTTRnVEwxTURNaTFTWmpoek10TVRZaVJXTDJFMk5sSkdPakp6TDNZek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>여기서 디트로이트 (<code>4</code>) 는 수학적으로 봤을때 우승이 불가능하므로 미리 제거했다. 그리고, <code>s</code> 에서 출발하는 <em>edge</em> 를 각 팀간 남은 경기로, 그리고 <code>t</code> 로 들어가는 <em>edge</em> 를 디트로이트의 남은경기, 이긴경기에서 해당 팀의 이긴경기를 빼서 <em>upper bound</em> 를 설정한다.</p>

<blockquote>
  <p>Team 4 (디트로이트) not eliminated iff all edges pointing from <code>s</code> are full in max flow</p>
</blockquote>

<h3 id="performance">Performance</h3>

<p><em>max flow</em> 문제의 경우 <em>FF</em> 알고리즘을 이용하면 <em>worst case</em> 에서 <code>E^2U</code> 성능이 나온다고 한다. 근데 이건 1955년도에 발견된 알고리즘이고, 가장 최근에는 <em>compact network</em> 라는 기법이 2012년에 만들어졌다. 이건 <code>E^2 / log E</code> 의 <em>worst case performance</em> 라고 함.</p>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Ro$bert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='https://graph-tool.skewed.de/static/doc/flow.html' >https://graph-tool.skewed.de/</a> <br />
(4) <a href='http://en.wikipedia.org/wiki/Cut_' (graph_theory)">Wikipedia: Cut</a> <br />
(5) <a href='http://kunuk.wordpress.com/2010/11/09/graph-flow-ford-fulkerson-algorithm-example-with-c/' >http://kunuk.wordpress.com - Flow</a> <br />
(6) <a href='http://www.programering.com/a/MDN0gDNwATY.html' >http://www.programering.com</a> <br />
(7) <a href='http://en.wikipedia.org/wiki/Max-flow_min-cut_theorem' #Example">Wikipeda - Max Flow</a></p>]]></description><link>http://1ambda.github.io/maximum-flow/</link><guid isPermaLink="false">90497f41-cd0f-4eb0-99bf-f59bbd7d1871</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[maximum flow]]></category><category><![CDATA[ford-fulkerson]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 28 Dec 2014 08:04:11 GMT</pubDate></item><item><title><![CDATA[Reactive Programming 5, Actor]]></title><description><![CDATA[<p><img src='http://prabhubuzz.files.wordpress.com/2012/09/demo1.png'  alt="" /></p>

<p align="center">(<a href='http://prabhubuzz.wordpress.com/' >http://prabhubuzz.wordpress.com</a>)</p>

<p><em>Actor</em> 는 원래 1973년에 인공지능 연구를 위해 개발되었는데, 1995년에는 <em>Erlang/OTP</em> 에서 텔레커뮤니케이션 플랫폼을 위해 사용되기도했다. 2006년에는 스칼라 스탠다드 라이브러리로 구현되었고, 2009년에는 <em>Akka</em> 가 만들어졌다.</p>

<h3 id="whyactors">Why Actors?</h3>

<p>액터가 왜 필요한지를 기존의 스레드를 사용하는 방법과 비교해 알아보자. 지난번에 배웠던 <em>bank account</em> 예제를 들고오면</p>

<pre><code class="scala">class BankAccount {  
  private var balance = 0

  def deposit(amount: Int): Unit = 
    if (amount &gt; 0) balance = balance + amount

  def withraw(amount: Int): Int = 
    if (0 &lt; amount &amp;&amp; amount &lt;= balance) {
      balance = balance - amount
      balance
    } else throw new Error("insufficient funds")
}
</code></pre>

<p>이 예제를 두개의 스레드로 동시에 돌리면 충돌이 난다. 잔고가 얼마인지는 어떤 스레드가 나중에 실행되느냐에 따라 달라질 수 있다. </p>

<p>이를 해결하기 위한 일반적인 방법은 <em>synchronization</em> 을 이용하는 것이다. <em>lock, mutex, semaphore</em> 등을 이용할 수 있다.</p>

<p>스칼라도 이를 지원하기 위해 모든 오브젝트마다 <em>synchronization</em> 블럭을 설정할 수 있다.</p>

<pre><code class="scala">class BankAccount {  
  private var balance = 0

  def deposit(amount: Int): Unit = this.synchronized { 
    if (amount &gt; 0) balance = balance + amount
  }

  def withraw(amount: Int): Int = this.synchronized {
    if (0 &lt; amount &amp;&amp; amount &lt;= balance) {
      balance = balance - amount
      balance
    } else throw new Error("insufficient funds")
  }
}
</code></pre>

<p><code>deposit</code> 도 <code>balance</code> 를 수정하기 때문에 <em>synchronization</em> 블럭이 필요하다. 이 말은 결국 <code>balance</code> 를 수정하는 모든 곳에서 동기화 블럭을 작성해야 한다는 뜻이다.</p>

<pre><code class="scala">def transfer(from: BankAccount, to: BankAccount, amount: Int): Unit = {  
  from.synchronized {
    to.synchronized {
      from.withdraw(amount)
      to.deposit(amount)
    }
  }
}
</code></pre>

<p>과도한 동기화는 데드락을 만들 수 있다. 이를 피하기 위해 <em>ordered lock</em> 을 이용하는 등 다양한 방법이 있다. 그러나 코드가 복잡해진다. 이건 간단한 예제라 별로 복잡해질게 없지만, 더 커다란 예제라면 끔찍해진다.</p>

<ul>
<li>blocking synchronization introduces <strong>dead-lock</strong></li>
<li>blocking is bad for CPU utilization</li>
<li>synchronous communication couples sender and receiver</li>
</ul>

<p><em>non-blocking object</em> 를 이용하되, 병렬로 실행할 수 있는 방법은 없을까? 그게 바로 액터다.</p>

<h3 id="theactormodel">The Actor Model</h3>

<blockquote>
  <p>The Actor Model represents objects and their interactions, resembling human organizations are built upon the laws of physics</p>
</blockquote>

<ul>
<li>Actor is an object with <strong>identity</strong></li>
<li>Actor <strong>has a behavior</strong></li>
<li>Actor only interacts using <strong>asynchonous message passing</strong> </li>
</ul>

<pre><code class="scala">type Receive = PartialFunction[Any, Unit]

trait Actor {  
  def receive: Receive
  ...
}
</code></pre>

<p>액터 타입에서 말해주듯이 메세지를 받는다. 액터는 <code>PartialFunction[Any, Unit]</code> 에서 볼 수 있듯이 어떤 인자든 처리할 수 있지만 아무것도 돌려주진 않는다. 타입 자체가 <em>asynchronous</em> 하게 메세지를 처리함을 보여준다.</p>

<p>간단한 액터를 만들어 보면</p>

<pre><code class="scala">class Counter extends Actor {  
  var count = 0 
  def receive = {
    case "incr" =&gt; count += 1
  }
}
</code></pre>

<p><code>"incr"</code> 만 받고, 자신은 메세지를 주지 않기 때문에 별로 할게 없다. 좀 더 예제를 키워보면</p>

<pre><code class="scala">class Counter extends Actor {  
  var count = 0 
  def receive = {
    case "incr" =&gt; count += 1
    case ("get", customer: ActorRef) =&gt; customer ! count
  }
}
</code></pre>

<p><em>akka</em> 에서 액터는 <code>ActorRef</code> 라는 <em>address</em> 를 이용해서 메세지를 보낼 수 있다. <code>!</code> 는 <em>tell</em> 이라 읽는다. 메세지를 보낸단 뜻이다.</p>

<pre><code class="scala">trait Actor {  
  implicit val self: ActorRef
  def sender: ActorRef
  ...
}

abstract class ActorRef {  
  def !(msg: Any)(implicit sender ActorRef = Actor.noSender): Unit
  def tell(msg: Any, sender: ActorRef) = this.!(msg)(sender)
  ...
}
</code></pre>

<p>얼랭에서는 매번 <code>sender</code> 를 지정하는 모양이다. 그러나 이건 자주 사용되는 패턴이기때문에 메세지를 보낼때 <code>sender</code> 를 <em>implicit</em> 하게 보내 이렇게 코드를 작성할 수 있다.</p>

<pre><code class="scala">def receive = {  
    case "incr" =&gt; count += 1
    case ("get", customer: ActorRef) =&gt; customer ! count
}

// same
def receive = {  
    case "incr" =&gt; count += 1
    case "get" =&gt; sender ! count
}
</code></pre>

<h4 id="theactorscontext">The Actor's Context</h4>

<pre><code class="scala">trait ActorContext {  
  def become(behavior: Receive, discardOld: Boolean = true): Unit
  def unbecome(): Unit
  ...
}

trait Actor {  
  implicit val context: ActorContext
}
</code></pre>

<p>액터는 <code>ActorContext</code> 라는 <em>behavior stack</em> 을 가지고 있는데, <code>become</code> 이용해 <em>push</em> 하거나 <code>unbecome</code> 을 이용해 <em>pop</em> 할 수 있다.</p>

<pre><code class="scala">class Counter extends Actor {  
  def counter(n: Int): Receive = {
    case "incr" =&gt; context.become(counter(n + 1))
    case "get" =&gt; sender ! n
  }

  def receive = counter(0)
}
</code></pre>

<p>여기서 볼 수 있는 것은</p>

<ul>
<li>state change is explicit (<code>become</code>)</li>
<li>state is scoped to current behavior (<code>context</code>)</li>
</ul>

<p>일종의 <em>asynchronous tail-recursion</em> 과 비슷하다.</p>

<h4 id="creatingandstopping">Creating and Stopping</h4>

<p>액터는 액터에 의해서 생성되고, 자기 자신에 의해서도 수행이 중단될 수 있다.</p>

<pre><code class="scala">trait ActorContext {  
  def actorOf(p: Props, name: String): ActorRef
  def stop(a: ActorRef): Unit
}
</code></pre>

<p>이제 <code>Counter</code> 에게 메세지를 보내는 <code>CounterMain</code> 을 만들면</p>

<pre><code class="scala">class CounterMain extends Actor {  
  val counter = context.actorOf(Props[Counter], "counter")

  counter ! "incr"
  counter ! "incr"
  counter ! "incr"
  counter ! "get"

  def receive = {
    case count: Int = &gt;
      println(s"count was $count")
      context.stop(self)
  }
}
</code></pre>

<p>돌리려면 <code>sbt "run-akka akka.Main CounterMain"</code> 처럼 실행해야 한다. <em>sbt</em> 세팅은</p>

<pre><code class="scaka">import sbt._  
import Process._  
import Keys._

name := "reactive-programming"

version := "1.0"

scalaVersion := "2.11.2"

resolvers += "Typesafe Repository" at "http://repo.typesafe.com/typesafe/releases/"

libraryDependencies ++= Seq(  
  "org.scalatest" % "scalatest_2.11" % "2.2.1" % "test",
  "io.reactivex" %% "rxscala" % "0.22.0",
  "com.typesafe.akka" %% "akka-actor" % "2.3.8"
)

testOptions in Test += Tests.Argument("-oI")  
</code></pre>

<p>전체 코드는</p>

<pre><code class="scala">package coursera.chapter5

import akka.actor.Actor  
import akka.actor.Props

class Counter extends Actor {  
  var count = 0

  def receive = {
    case "incr" =&gt;
      println("Counter received 'incr'")
      count += 1
    case "get" =&gt; sender ! count
  }
}

// sbt run-main akka.Main coursera.chapter.CounterMain
class CounterMain extends Actor {

  val counter = context.actorOf(Props[Counter], "counter")

  counter ! "incr"
  counter ! "incr"
  counter ! "incr"
  counter ! "get"

  def receive = {
    case count: Int =&gt;
      println(s"count was $count")
      context.stop(self)
  }
}

// run main actor
&gt; run-main akka.Main coursera.chapter5.CounterMain
[info] Running akka.Main coursera.chapter5.CounterMain
Counter received 'incr'  
Counter received 'incr'  
Counter received 'incr'  
count was 3  
[INFO] [12/27/2014 16:23:40.182] [Main-akka.actor.default-dispatcher-2] [akka://Main/user/app-terminator] application supervisor has terminated, shutting down
[success] Total time: 1 s, completed Dec 27, 2014 4:23:40 PM
&gt;
</code></pre>

<p>정리하자면 액터 모델에서의 <em>computation</em> 은</p>

<ul>
<li>send message</li>
<li>create actors</li>
<li>designate the behavior for the next message</li>
</ul>

<h3 id="messageprocesscingsemantics">Message Processcing Semantics</h3>

<p>액터의 상태를 직접적으로 변경할 수 있는 방법은 없다. 상태를 변경하려면 메세지를 보내야 한다. 그리고 메세지를 보내려면 <em>address, 주소</em> <code>ActorRef</code> 를 알고 있어야 한다.</p>

<ul>
<li>every actor knows its own address <code>self</code></li>
<li>creating an actor returns its address</li>
<li>addresses can be sent within be sent within messages (e.g <code>sender</code>)</li>
</ul>

<p>액터를 잘 보면 서로 독립적인 <em>computation, 연산</em> 을 수행한다. 이들은 병렬적으로 실행되며, 서로 커뮤니케이션 할 수 있는 유일한 방법은 메세지를 보내는 것 뿐이다.</p>

<ul>
<li>local execution, no notion of global synchronization</li>
<li>all actors run fully concurrently</li>
<li>message-passing primitive is one-way communication</li>
</ul>

<p>그리고 액터 하나를 기준으로 보면, <em>single-threaded</em> 로 처리 될 수 있다.</p>

<ul>
<li>messages are recived sequentially</li>
<li>behavior change is effective before processing the next message</li>
<li>processing one message is the atomic unit of execution</li>
</ul>

<p>메세지를 처리하는 메소드는 <em>synchronized method</em> 처럼 동작하지만 블러킹 없이 큐에 메세지를 넣는것으로 대신한다.</p>

<h4 id="bankaccountusingactor">Bank Account using Actor</h4>

<p>액터의 메세지를 <em>companion object</em> 에 정의하는 것 부터 시작하자. </p>

<pre><code class="scala">package coursera.chapter5.banking

import akka.actor.Actor  
import akka.actor.Props

object Account {  
  case class Deposit(amount: BigInt) {
    require(amount &gt; 0)
  }

  case class Withdraw(amount: BigInt) {
    require(amount &gt; 0)
  }

  case object Done
  case object Failed
}

class Account extends Actor {

  import Account._

  var balance = BigInt(0)

  def receive = {
    case Deposit(amount) =&gt; 
      balance += amount
      sender ! Done                      
    case Withdraw(amount) if amount &lt;= balance =&gt;
      balance -= amount
      sender ! Done
    case _ =&gt;
      sender ! Failed
  }
}
</code></pre>

<p><em>transfer</em> 를 구현하려면 한 액터(<code>BankAccount</code>) 로 부터 인출하고, 다른 액터에게 같은 금액을 입금하라고 명령을 내리는 액터를 만들면 된다.</p>

<pre><code class="scala">package coursera.chapter5.banking

import akka.actor.{Actor, Props, ActorRef}

object WireTransfer {  
  case class Transfer(from: ActorRef, to: ActorRef, amount: BigInt)
  case object Done
  case object Failed
}

class WireTransfer extends Actor {  
  import WireTransfer._

  def receive: Receive = {
    case Transfer(from, to, amount) =&gt;
      from ! Account.Withdraw(amount)
      context.become(awaitFrom(to, amount, sender))
  }

  def awaitFrom(to: ActorRef, amount: BigInt, customer: ActorRef): Receive = {
    case Account.Done =&gt;
      to ! Account.Deposit(amount)
      context.become(awaitTo(customer))
    case Account.Failed =&gt; 
      customer ! Failed
      context.stop(self)
  }

  def awaitTo(customer: ActorRef): Receive = {
    case Account.Done =&gt;
      customer ! Done
      context.stop(self)
    case Account.Failed =&gt;
      customer ! Failed
      context.stop(self)
  }
}
</code></pre>

<p>디버깅 위해 <code>akka.event.LoggingReceive</code> 를 구현한 <code>Main</code> 을 보자.</p>

<pre><code class="scala">package coursera.chapter5.banking

import akka.actor.Actor  
import akka.actor.Props  
import akka.event.LoggingReceive

// in sbt
// &gt; run-main akka.Main coursera.chapter5.banking.Main
class Main extends Actor {

  val accA = context.actorOf(Props[Account], "accA")
  val accB = context.actorOf(Props[Account], "accB")

  accA ! Account.Deposit(50)

  def receive = LoggingReceive {
    case Account.Done =&gt; transfer(50)
  }

  def transfer(amount: BigInt): Unit = {
    // transcation
    val tx = context.actorOf(Props[WireTransfer], "tx")

    tx ! WireTransfer.Transfer(accA, accB, amount)
    context.become(LoggingReceive {
      case WireTransfer.Done =&gt;
        println("successfully transfered")
        context.stop(self)
    })
  }
}
</code></pre>

<p>실행하려면 세팅을 좀 바꿔야한다. 나는 <code>main</code> 에서 그냥 실행하니까, <code>main/resources</code> 밑에 <code>application.conf</code> 를 만들고 이 세팅을 넣으면 된다. <code>test</code> 에서 실행하면 마찬가지로 <code>test/resources</code> 에 넣으면 되고.</p>

<pre><code>akka {  
  loglevel = "DEBUG"
    actor {
      debug {
        receive = on
      }
    }
}
</code></pre>

<p>잡다구리한거 제거하고 로그를 뽑으면</p>

<pre><code class="scala">&gt; run-main akka.Main coursera.chapter5.banking.Main
[accountA] received handled message Deposit(50)
[Main] received handled message Done
[accountA] received handled message Withdraw(50)
[accountB] received handled message Deposit(50)
successfully transfered  
[Main] received handled message Done
</code></pre>

<p>액터 모델에서 메세지 전송은 </p>

<blockquote>
  <p>all communication is inherently unreliable</p>
</blockquote>

<p>즉, 메세지가 전달되지 않을수도 있다는 뜻이다. 근데 이건 액터 모델뿐만 아니라 <em>synchronous</em> 에서도 마찬가지다. 컴퓨터가 크래시 나거나, 네트워크가 끊기거나.</p>

<p>그래서 프로토콜을 만들어 메세지가 실제로 전송되었는지 확인해야 한다.</p>

<blockquote>
  <p>delivery of a message requires eventual availability of channel, recipient</p>
</blockquote>

<p>3가지 전략을 사용할 수 있는데</p>

<ul>
<li><strong>at-most-once:</strong> sending once deilvers <code>[0, 1]</code> times</li>
<li><strong>at-least-once:</strong> resending until acknoledged delivers <code>[1, ~</code> times</li>
<li><strong>exactly-once:</strong> processing only first reception delivers 1 time</li>
</ul>

<p>두번째 전략의 경우 센더가 메세지를 다시 보내기 위해 가지고 있어야 한다. 세번째 전략은 가장 비용이 큰 전략인데, 리시버가 메세지가 이미 처리되었는지 아닌지를 판별할 수 있어야 한다.</p>

<p><em>reliability</em> 를 위해 </p>

<ul>
<li>모든 메세지가 <em>persisted</em> 되고 (저장된다는 뜻인듯)</li>
<li><em>unique correlation ID</em> 를 지정할 수 있고</li>
<li>성공할때까지 메세지를 계속 보낼 수 있다.</li>
</ul>

<blockquote>
  <p>Reliability can only be ensured by <strong>business-level acknowledgement</strong></p>
</blockquote>

<p>근데 실제로는 리시버로부터 응답이 오기전까진 제대로 보내졌는지 알 수 없으므로 비즈니스 레벨 측면에서 신뢰성을 정의해야한다는 뜻인것 같다.</p>

<p>은행계좌 예제에 지금까지 논의한 <em>reliability</em> 를 추가하기 위해</p>

<ul>
<li>log acivities of <code>WireTransfer</code> to persistent storage</li>
<li>each transfer has a unique ID</li>
<li>add ID to <code>Withdraw</code> and <code>Deposit</code></li>
<li>store IDs of completed actions within <code>BankAccount</code></li>
</ul>

<h4 id="messageordering">Message Ordering</h4>

<p>본래 액터 모델에는 순서와 관련된 스펙이 없다고 한다. <em>akka</em> 에서는 이 부분을 수정하여 똑같은 목적지로 메세지를 보냈다면, 보낸 순서대로 메세지가 도착한다고 한다.</p>

<blockquote>
  <p>If an actor sends multiple messages to the same destination, they will not arrive out of order (this is <strong>Akka-specific</strong>)</p>
</blockquote>

<p><em>E</em> 언어에서는 더 강화된 룰이 있다고 한다. <em>akka</em> 와는 좀 다른측면에 집중하기 때문이라고 함.</p>

<h3 id="designingactorsystem">Designing Actor System</h3>

<p>액터 모델을 따르는 크롤러를 구현해보자. 웹페이지를 긁어오는 부분부터 보면</p>

<h4 id="webclient">Web Client</h4>

<pre><code class="scala">val client = new AsyncHttpClient  
def get(url: String): String = {  
  val res = client.prepareGet(rul).execute().get
  if (res.getStatusCode &lt; 400)
    res.getResponseBodyExcerpt(131072) // 128KB
  else throw BadStatus(response.getStatusCode)
}
</code></pre>

<p>근데, 긁어오는 부분이 블러킹이라 좀 그렇다. </p>

<ul>
<li>액터에서 이 코드를 사용하면 긁는동안 다른 요청에 반응을 못하고, </li>
<li>이 액터가 반응을 못하면 다른 액터로 그 영향이 전파된다. 수천개의 액터를 가지고있다면..</li>
</ul>

<pre><code class="scala">private val client = new AsyncHttpClient

def ge(url: String)(implicit exec: Executor): Future[String] = {  
  val f = client.prepareGet(url).execute();
  val p = Promis[String]()

  f.addListener(new Runnable {
    def run = {
      val res = f.get
      if (res.getStatusCode &lt; 400)
        p.success(res.getResponseBodyExcerpt(131072))
      else p.failure(BadStatus(response.getStatusCode))
    }
  }, exec)

  p.future
}
</code></pre>

<h4 id="findinglinks">Finding Links</h4>

<pre><code class="scala">val A_TAG = "(?i)&lt;a ([^&gt;]+)&gt;.+?&lt;/a&gt;".r  
val HREF_ATTR = """\s*(?i)href\s*=\s*(?:"([^"]*)"|'([^']*)'|([^'"&gt;\s]+))\s*""".r

def findLinks(body: String): Iterator[String] = {  
  for {
    anchor &lt;- A_TAG.findAllMatchIn(body)
    HREF_ATTR(dquot, quot, bare) &lt;- anchor.subgroups
  } yield if (dquot != null) dquot
  else if (quot != null) quot
  else bare
} 
</code></pre>

<p><code>&lt;a href=</code> 부분이 쌍따옴표나, 따옴표로 감싸져있거나, 아니면 그냥 링크부분이 문자열일 수 있으므로 나눠서 찾아본다.</p>

<h4 id="getteractor">Getter Actor</h4>

<pre><code class="scala">class Getter(url: String, depth: Int) extends Actor {  
  implicit val exec = 
    context.dispatcher.asInstanceOf[Executor with ExecutionContext]

  val future = WebClient.get(url)

  future.onComplete {
    case Success(body) =&gt; self ! body
    case Failure(err)  =&gt; self ! Status.Failure(err)
  }

  ...

}
</code></pre>

<p>이건 너무나 자주 나오는 패턴매칭이므로 <em>akka</em> 에서는 <code>pipeTo</code> 를 이용해 이렇게 줄일 수 있다.</p>

<pre><code class="scala">class Getter(url: String, depth: Int) extends Actor {  
  implicit val exec = 
    context.dispatcher.asInstanceOf[Executor with ExecutionContext]

  val future = WebClient.get(url)
  future.pipeTo(self)

  // or
  WebClient get url pipeTo self
  ... 
}
</code></pre>

<p>여기서 <code>get</code> 과 <code>pipeTo</code> 가 비동기로 실행되야하기 때문에 <code>Executor</code> 가 필요하다. 그리고 이 <code>dispatcher</code> 는 상당히 중요한데, 이 디스패처가 액터를 실행하고, 퓨처를 실행한다. 그리고 이 디스패처는 공유될 수 있다.</p>

<blockquote>
  <p>Actors are run by a dispatcher (potentially shared) which can also run Futures</p>
</blockquote>

<p>메세지를 받는 부분은</p>

<pre><code class="scala">class Getter(url: String, depth: Int) extends Actor {  
  ...

  def receive = {
    case body: String =&gt;
      for (link &lt;- findLinks(body))
        context.parent ! Controller.Check(link, depth)
      stop()
    case _: Status.Failure =&gt; stop()
  }

  def stop(): Unit = {
    context.parent ! Done
    context.stop(self)
  }
}
</code></pre>

<p>모든 액터는 다른 액터에 의해 만들어지기 때문에 <code>context.parent</code> 로 접근할 수 있다.</p>

<h4 id="actorbasedlogging">Actor-Based Logging</h4>

<ul>
<li>Logging includes <em>IO</em> which can block indefinitely</li>
<li><em>Akka</em>'s logging passes that task to dedicated actors</li>
</ul>

<pre><code class="scala">class Controller extends Actor with AtcorLogging {  
  var cache = Set.empty[String]
  var children = Set.empty[ActorRef]

  def receive = {
    case Check(url, depth) =&gt;
      log.debug("{} checking{}", depth, url)
      if (!cache(url) &amp;&amp; depth &gt; 0)
        children += context.actorOf(Props(new Getter(url, depth - 1)))
      cache += url
    case Getter.Done =&gt;
      children -= sender
      if (children.isEmpty) context.parent ! Result(cache)
  }
}
</code></pre>

<p>다른 쿼리를 처리하는 도중에 <code>Result(cache)</code> 가 부모에게 전송되었다고 하자. <em>mutable set</em> 이면 끔찍하다. 그러나 <em>immutable set</em> 을 사용하기 때문에 공유해도 문제 없다.</p>

<h4 id="handlingtimeouts">Handling Timeouts</h4>

<p>웹서버가 어마어마하게 늦게 응답한다면 어떻게 할까?</p>

<pre><code class="scala">class Controller extends Actor with AtcorLogging {  
  context.setReceiveTimeout(10 seconds)

  ...

  def receive = {
    case Check       ...
    case Getter.Done ...
    case ReceiveTimeout =&gt; children foreach (_ ! Getter.Abort)
  }
}

class Getter(url: String, depth: Int) extends Actor {  
  def receive = {
    ...
    case Abort =&gt; stop()
  }

  ...
}
</code></pre>

<h4 id="scheduler">Scheduler</h4>

<p><em>akka</em> 는 <em>high volume</em>, <em>short duration</em>, <em>frequent cancellation</em> 을 위한 <em>time service</em> 를 제공한다. 스케쥴러도 그 중 하나다</p>

<pre><code class="scala">trait Scheduler {  
  def scheduleOnce(delay: FiniteDuration, target: ActorRef, msg: Any)
                   (implicit ec: ExecutionContext): Cancellable
  def scheduleOnce(delay: FiniteDuration)(block: =&gt; Unit)
                   (implicit ec: ExecutionContext): Cancellable
  def scheduleOnce(delay: FiniteDuration, run: Runnable)
                   (implicit ec: ExecutionContext): Cancellable                 
}
</code></pre>

<p>태스크의 실행과 취소가 리소스를 두고 경쟁할 수 있기 때문에 취소가 호출된 후 메세지를 받는 일도 생긴다. 그러나 취소요청된 메세지는 저장되기때문에 필터링 할 수 있어 별 문제가 안된다.</p>

<p>이 스케쥴러를 이용하면 위에서 본 취소 코드를 이렇게도 작성하면...<strong>안된다</strong></p>

<pre><code class="scala">class Controller extends Actor with AtcorLogging {  
  import context.dispatcher
  var children = Set.empty[ActorRef]

  context.system.scheduler.scheduleOnce(10 seconds) {
    children foreach (_ ! Getter.Abort)
  }

  ...
}
</code></pre>

<p>스케쥴러와 액터의 컨텍스트가 다르기 때문에 동시에 <code>children</code> 을 수정하는 코드다. <strong>not thread-safe</strong> 다. 이건 컴파일러 에러도 안준다.</p>

<p>액터의 컨텍스트에 접근하려면 메세지를 보내야 한다.</p>

<pre><code class="scala">class Controller extends Actor with AtcorLogging {  
  import context.dispatcher
  var children = Set.empty[ActorRef]

  context.system.scheduler.scheduleOnce(10 seconds, self, Timeout)

  def receive {
    ...
    case Timeout =&gt; children foreach (_ ! Getter.Abort)
  }

  ...
}
</code></pre>

<p>비슷한 문제를 더 살펴보자.</p>

<pre><code class="scala">class Cache extends Actor {  
  val cache = Map.empty[String, String]
  def receive = {
    case Get(url) =&gt;
      if (cache contains url) sender ! cache(url)
      else
        WebClient get url foreach { body =&gt;
          cache += url -&gt; body // buggy
          sender ! body
        }  
  }
}
</code></pre>

<p>이것도 액터 컨텍스트 밖에서 <code>cache</code> 에 접근하고 있다. <code>get</code> 은 <code>Future</code> 를 돌려주는데, 이건 분명히 액터의 컨텍스트가 아니다. <code>cache += url -&gt; body</code> 이부분</p>

<p>이전과 마찬가지로 액터에게 메세지를 보내는 방식으로 해결할 수 있다. 명심하자 액터 내부의 변수는 액터로 메세지를 보내 변경하자.</p>

<pre><code class="scala">  val cache = Map.empty[String, String]
  def receive = {
    case Get(url) =&gt;
      if (cache contains url) sender ! cache(url)
      else
        WebClient get url map(Result(sender, url, _)) pipeTo self

     case Result(client, url, body) =&gt;
       cache += url -&gt; body
       client ! body
</code></pre>

<p>근데 이것도 문제가 있다. <code>map</code> 이 <code>Future</code> 에 의해 실행되기 때문에, <code>sender</code> 가 메세지를 보낸 사람이란걸 보장할 수가 없다.</p>

<blockquote>
  <p>Do not refer to actor state from code running asynchoronously</p>
</blockquote>

<pre><code class="scala">  val cache = Map.empty[String, String]
  def receive = {
    case Get(url) =&gt;
      if (cache contains url) sender ! cache(url)
      else
        val client = sender
        WebClient get url map(Result(client, url, _)) pipeTo self

     case Result(client, url, body) =&gt;
       cache += url -&gt; body
       client ! body
</code></pre>

<h4 id="thereceptionist">The Receptionist</h4>

<pre><code class="scala">class Receptionist extends Actor {  
  def receive = wating

  // upon Get(url) start a traversal and become running
  val wating: Receive = {
    case Get(url) =&gt; context.become(runNext(Vector(Job(sender, url)))
  }

  // upon Get(url) append that to queue and keep running
  // upon Controller.Result(links) ship that to client
  // and run next job from queue if any
  def running(queue: Vector[Job]): Receive = {
    case Controller.Result(links) =&gt;
      val job = queue.head
      job.client ! Result(job.url, links)
      context.stop(sender)
      context.become(runNext(queue.tail))
    case Get(url) =&gt;
      context.become(enqueueJob(queue, Job(sender, url)))
  }
}

case class Job(client: ActorRef, url: String)  
var reqNo = 0

def runNext(queue: Vector[Job]): Receive = {  
  reqNo += 1
  if (queue.isEmpty) wating
  else {
    val controller = context.actorOf(Props[Controller], s"c$reqNo")
    controller ! Controller.Check[queue.head.url, 2)
    running(queue)
  }
}

def enqueueJob(queue: Vector[Job], job: Job): Receive = {  
  if (queue.size &gt; 3) {
    sender ! Failed(job.url)
    running(queue)
  } else running(queue :+ job)
}
</code></pre>

<p><code>Receive</code> 가 <code>Actor</code> 의 <em>state, 상태</em> 를 나타낸다. 어떤 메세지를 받을 수 있는지 정의하면서</p>

<h4 id="main">Main</h4>

<pre><code class="scala">import akka.actor.{Actor, Props, ReceiveTimeout}  
import scala.concurrent.duration._

class Main extends Actor {  
  import Receptionist._
  import context.dispatcher

  val receptionist = context.actorOf(Props[Receptionist], "receptionist")

  receptionist ! Get("http://www.google.com")

  context.system.scheduler.scheduleOnce(10 seconds, self, ReceiveTimeout)

  def receive = {
    case Result(url, links) =&gt;
      println(links.toVector.sorted.mkString(s"Results for '$url':\n", "\n", "\n"))
    case Failed(url) =&gt;
      println(s"Failed to fetch '$url'\n")
    case ReceiveTimeout =&gt;
      context.stop(self)
  }

  override def postStop(): Unit = {
    WebClient.shutdown()
  }
}
</code></pre>

<p>전체 코드는 <a href='https://github.com/ardumont/scala-lab/tree/master/src/main/scala/concurrency/actor/crawler' >여기</a> 서 확인할 수 있다.</p>

<h4 id="summary">Summary</h4>

<p>(1) A reactive application is <strong>non-blokcing</strong> &amp; <strong>event-driven</strong> top to bottom <br />
(2) Actors are run by a dispatcher (potentially shared) which can also run Futures <br />
(3) Prefer imuutable data structures, since they can be shared <br />
(4) Do not refer to actor state from code running asynchronously <br />
(5) Prefre <code>context.become</code> for different states, with data local to the behavior</p>

<h3 id="testingactorsystem">Testing Actor System</h3>

<p>테스팅은 오직 외부의 <em>observable effects</em> 만 가능하다.</p>

<blockquote>
  <p>Tests can only verify externally observable effects</p>
</blockquote>

<p>여기 <code>Toggle</code> 이란 액터를 하나 만들어 보자.</p>

<pre><code class="scala">import akka.actor.Actor

class Toggle extends Actor {  
  // happy state
  def happy: Receive = {
    case "How are you?" =&gt;
      sender ! "happy"
      context become sad
  }

  // sad state
  def sad: Receive = {
    case "How are you?" =&gt;
      sender ! "sad"
      context become happy
  }

  // initial state: happy
  def receive = happy
}
</code></pre>

<p>이 액터를 테스트할 수 있는 유일한 방법은 메세지를 보내고, 그 응답을 확인하는 것이다. <em>akka</em> 의 테스트킷은 <code>TestProbe</code> 를 제공하는데, 일종의 <em>remote controlled actor</em> 다.</p>

<p><em>SBT</em> 파일에 이렇게 디펜던시를 추가하고</p>

<pre><code class="scala">resolvers += "Typesafe Repository" at "http://repo.typesafe.com/typesafe/releases/"

libraryDependencies ++= Seq(  
  ...
  "com.typesafe.akka" %% "akka-testkit" % "2.3.8",
  ...
)
</code></pre>

<p>아래처럼 사용할 수 있다.</p>

<pre><code class="scala">implicit val system = ActorSystem("TestSys")  
val toggle = sytem.actorOf(Props[Toggle])  
val p = TestProbe()

p.send(toggle, "How are you?")  
p.expectMsg("happy")  
p.send(toggle, "unknown")  
p.expectNoMsg(1 second)  
...
...

system.shutdown()  
</code></pre>

<p>이렇게 더 편하게 쓸 수 있다.</p>

<pre><code class="scala">new TestKit(ActorSystem("TestSys")) with ImplicitSender {  
  val toggle = system.actorOf(Props[Toggle])

  toggle ! "How are you"
  expectMsg("happy")
  ...
  ...
  system.shutdown()
}
</code></pre>

<p><code>ImplicitSender</code> 를 이용하면 테스트 시스템 내에서 자동으로 <em>sender</em> 가 <em>test actor</em> 로 지정된다.</p>

<p>동작하는 코드는 <a href='https://github.com/ardumont/scala-lab/blob/master/src/main/scala/concurrency/actor/toggle/happySad.scala' >여기</a>로</p>

<p><br/></p>

<p>일반적으로 테스트를 작성할때는 독립적인 모듈을 먼저 테스트한다. 그리고 필요한경우 가짜 데이터를 돌려주는 <em>mock</em> 등을 만든다.</p>

<p>데이터베이스에서 데이터를 가져오는 모듈을 테스트하고 싶다면 그것만 테스트하면 된다. 실제 데이터베이스에 연결 해볼 필요는 없다. </p>

<p>앞서 크롤러 같은 경우 <code>Receptionist</code> 를 테스팅하기 위해 가짜 <code>Controller</code> 를 만들 수 있다.</p>

<pre><code class="scala">class FakeController extends Actor {  
  def receive = {
    case Controller.Check(url, depth) =&gt;
      context.system.scheduler.scheduleONce(1 seconds,
                                            sender,
                                            Controller.Result(Set(url)))
  }
}
</code></pre>

<h3 id="references">References</h3>

<p>(1) <em>Reactive Programming</em> by <strong>Martin Ordersky</strong> <br />
(2) <a href='http://prabhubuzz.wordpress.com/2012/09/28/akka-really-mountains-of-concurrency/' >http://prabhubuzz.wordpress.com</a></p>]]></description><link>http://1ambda.github.io/reactive-programming-5/</link><guid isPermaLink="false">99e31196-6379-4fef-b26d-29a2e5d1bb6c</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[reactive programming]]></category><category><![CDATA[actor]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 27 Dec 2014 05:33:25 GMT</pubDate></item><item><title><![CDATA[Reactive Programming 4, Observable, Rx]]></title><description><![CDATA[<p>지난시간엔 단일 데이터에 대해 <em>latency</em> 를 지원하는 <em>Future, Promise</em> 에 대해서 알아봤다. 이번에는 컬렉션에서 <em>latency</em> 를 지원하는 방법인 <em>Observable</em> 을 배워보자.</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<h3 id="fromfuturestoobservables">From Futures to Observables</h3>

<p><code>Future</code> 의 정의를 다시 보면,</p>

<pre><code class="scala">trait Future[T] {  
  def onComplete[U](f: Try[T] =&gt; U)
  (implicit ex: ExecutionContext): Unit
}
</code></pre>

<p>여기서 중요한 부분은 콜백 <code>f</code> 를 받아 <code>Unit</code> 을 돌려준다는 것이다.</p>

<pre><code class="scala">(Try[T] =&gt; Unit) =&gt; Unit
</code></pre>

<p>이제 <code>=&gt;</code> 를 뒤집고, <code>Unit</code> 을 <code>()</code> 로 표기해서 어떤 <em>intuition</em> 을 얻어보자.</p>

<pre><code class="scala">(Try[T] =&gt; Unit) =&gt; Unit
Unit =&gt; (Unit =&gt; Try[T]) // reverse  
() =&gt; (()=&gt; Try[T])      // Unit -&gt; ()

Try[T]                   // simplify  
</code></pre>

<p>여기서 핵심은 <code>()</code> 는 사이드 이펙트를 위해 존재하므로 그 부분을 제거하면 타<code>Future[T]</code> 의 결과는 <code>Try[T]</code> 와 같다는 것이다.</p>

<blockquote>
  <p><code>Future[T]</code> and <code>Try[T]</code> are <strong>dual</strong></p>
</blockquote>

<p><em>duality</em> 란 <a href='http://en.wikipedia.org/wiki/Category_theory' >Category Theory</a> 에 의하면</p>

<blockquote>
  <p>Every statement, theorem, or definition in category theory has a dual which is essentially obtained by <strong>"reversing all the arrows"</strong>.</p>
</blockquote>

<p>처음 시작 부분에서 이런 테이블을 봤을텐데, 여기서도 <em>duality</em> 관계가 나타난다.</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<p>그리고 지난시간에 이메일을 발송하는 코드에서 <code>onComplete</code> 를 몇 번 호출하던 콜백이 받는 <code>Try[T]</code> 는 동일하다는 것을 봤다. 이것은 <code>Future[T]</code> 가 <code>Try[T]</code> 를 돌려주고, 그 값이 일정하다는 사실을 말한다.</p>

<p>이렇게 생각할수도 있다. 콜백 <code>f: Try[T] =&gt; Unit</code> 을 넘기고 <code>Try[T]</code> 를 얻기 위해 <code>asynchronous()</code> 를 사용할 수 있고, <code>Try[T]</code> 를 얻기 전까지 블럭되는 <code>synchronous</code> 를 이용할 수도 있다는 식으로</p>

<pre><code class="scala">def asynchronous(): Future[T]  
def synchronous(): Try[T]  
</code></pre>

<h3 id="iterable">Iterable</h3>

<p><code>Observable[T]</code> 를 보기전에 <em>synchronous data stream</em> 인 <code>Iterable[T]</code> 를 좀 살펴보자.</p>

<pre><code class="scala">trait Iterable[T] { def iterator(): iterator[T] }  
trait Iterator[T] { def hasNext: Boolean; def next(): T }  
</code></pre>

<p><code>while (hasNext) next()</code> 처럼 사용할 수 있다.</p>

<p>그리고 <code>Iterable[T]</code> 를 위한 <code>flatMap</code> 도 정의되어 있다. 따라서 <code>Iterable</code> 은 모나드다.</p>

<pre><code class="scala">def flatMap[B](f: A =&gt; Iterable[B]): Iterable[B]  
</code></pre>

<p>이 <code>Iterator</code> 를 이용해서 디스크에서 파일을 읽는 코드를 작성하면</p>

<pre><code class="scala">def ReadLinesFromDisk(path: String): iterator[String] = {  
  Source.fromFile(path).getLines()
}

val lines = ReadLinesFromDisk(path)

for (line &lt;- lines) {  
  ... DoWork(line) ... // latency
}
</code></pre>

<p>한 라인이 <code>100K</code> 로 어마어마하게 길다면 디스크를 읽기 전까지 기다려야할까? <code>Future</code> 처럼 비동기로 IO 연산을 수행하는 방법을 찾아보자. 이전과 좀 다른점은 지금은 컬렉션을 다루고 있다는 점이다. </p>

<p>이 문제를 해결하기 위해 컬렉션을 순회하는 <code>trait</code> 를 좀 살펴보자. 어떤 일을 해야 하는지 알아야하니까.</p>

<pre><code class="scala">trait Iterable[T] {  
  def iterator(): Iterator[T]
}

trait Iterator[T] {  
  def hasNext: Boolean
  def next(): T
}
</code></pre>

<p><code>Iterable</code>, <code>Iterator</code> 을 좀 간략화 하면, </p>

<ul>
<li><code>Iterable</code> 는 <code>()</code> 를 인자로 받아 <code>Iterator</code> 를 돌려주고</li>
<li><code>Iterator</code> 는 <code>()</code> 를 인자로 받아 <code>Try[Option[T]]</code> 를 돌려준다</li>
</ul>

<p>전체적으로 보면 <code>() =&gt; (() =&gt; Try[Option[T]])</code> 다. 사이드이펙트로 예외를 돌려주거나, <code>None</code> 일수 있거나, 아니면 정상적인 값을 얻을 수 있다는 뜻이다.</p>

<p>타입이 좀 복잡한데, 아까 <em>arrow</em> <code>=&gt;</code> 를 뒤집었던 방법을 다시 사용해서 간단히 만들어 보자. 강의에서는 <em>dualization trick</em> 이라 부른다.</p>

<p>뒤집은 후에는 <code>Try[Option[T]]</code> 를 분해해 보자. 예외를 주거나, 아무 값도 주지 않거나(끝나거나), 값을 주거나.</p>

<pre><code class="scala">() =&gt; (() =&gt; Try[Option[T]])

// reverse
(Try[Option[T]] =&gt; Unit) =&gt; Unit)

// simplify
( T         =&gt; Unit, // Value
  Throwable =&gt; Unit, // Exception
  ()        =&gt; Unit  // Nothing, Terminate
) =&gt; Unit
</code></pre>

<p>즉, 비동기로 컬렉션을 순회하기 위해서는 이런 작업을 처리해줄 무언가가 필요하다. 스칼라에서는 <code>Observable, Observer, Subscription</code> 이 그 일을 담당한다.</p>

<pre><code class="scala">trait Observable[T] {  
  def Subscribe(observer: Observer[T]): Subscription
}

trait Observer[T] {  
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
  def OnCompleted(): Unit
}

trait Subscription {  
  def unsubscribe(): Unit
}
</code></pre>

<p>즉, <code>Observable</code> 에 <code>Try[Option[T]]</code> 에 따라 할일을 지정해 놓은 <code>Observer</code> 를 세팅하고, <code>Subscription</code> 을 얻은 뒤 이후에 필요에 의해 중단해야 하면 <code>unsubscribe</code> 를 호출하는 방식이다. 이는 작업하는 대상이 컬렉션이므로 <code>Future</code> 와는 달리, 하나의 값이 아니라 무한한 값들을 얻어올 수 있기 때문.</p>

<h3 id="futurevsobservable">Future vs Observable</h3>

<p>초반에, 이 테이블을 다시 보면 <code>Iterable</code> 과 <code>Observable</code> 이 <em>dual</em> 이다.</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<p>그리고 이 테이블에 의하면, <code>Future</code> 와 <code>Observable</code> 을 비교해보면 <em>one</em> 과 <em>many</em> 가 의미하는 바를 <em>type</em> 으로 이해할 수 있다.</p>

<pre><code class="scala">Observable[T] = (Try[Option[T]] =&gt; Unit) =&gt; Unit  
Future[T]     = (Try[T]         =&gt; Unit) =&gt; Unit  
</code></pre>

<p>타입을 보면 <code>Future</code> 는 <code>Option</code> 부분이 없지만 <code>Observable</code> 은 있다. 즉 <code>Observable</code> 은 아무런 값도 없다는 사실을 의미하는 타입 <code>Option</code> 을 이용해 <em>종료시점</em> 을 알려줄 수 있기 때문에 <em>multiple values</em> 를 처리할 수 있다.</p>

<p><em>concurrency</em> 측면에선 어떨까? 타입을 살펴보면</p>

<pre><code class="scala">object Future {  
  def apply[T](body: =&gt; T)
   (implicit executor: ExecutionContext): Future[T]
}

trait Observable[T] {  
  def observeOn(scheduler: Scheduler): Observable[T]
}
</code></pre>

<p><code>Observable</code> 의 경우엔 하나의 <code>ExecutionContext</code> 가 아니라 여러개를 가져야 하기 때문에 <code>Scheduler</code> 를 이용한다. 이 부분은 나중에 더 자세히 살펴보자.</p>

<h4 id="observableexample">Observable example</h4>

<pre><code class="scala">val ticks: Observable[Long] = Observable.interval(1 seconds)  
val evens: Observable[Long] = ticks.filter(s =&gt; s % 2 == 0)  
val bufs:  Observable[Seq[Long]] = evens.buffer(2, 1)  
val s = bufs.subscribe(b =&gt; println(b))

readLine()  
s.unsubscribe  
</code></pre>

<p><code>Observable</code> 을 <em>latency</em> 를 지원하는 컬렉션으로 이해하면 쉽다. <code>interval</code>  을 이용해 간격을 지정하거나, 일반 컬렉션처럼 <code>filter</code> 도 사용할 수 있다. <code>evens.buffer</code> 는 그냥 버퍼링이라고 생각하면 된다. 버퍼 크기가 2인 것으로.</p>

<p>이런 것도 가능하다.</p>

<pre><code class="scala">val xs = Observable.range(1, 10)  
val ys = xs.map(x =&gt; x + 1)  
</code></pre>

<p><code>xs</code> 는 비동기 순회를 지원하는 컬렉션이다. <code>filter</code>, <code>map</code>, <code>flatMap</code>, <code>take</code>, <code>zip</code> 등 을 지원한다.</p>

<h3 id="flatmap">flatMap</h3>

<p><img src='https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/flatMap.png'  alt="" /></p>

<p align="center">(<a href='http://reactivex.io/' >http://reactivex.io/</a>)</p>

<p>색깔의 순서를 봐야할 필요가 있다. <code>Observable</code> 은 비동기 연산이기 때문에 순서가 좀 달라질 수 있다. 구현에도 그런 부분이 나타나 있는데 아래의 코드에서 <code>flatten</code> 이 의미하는 바는 <em>non-deterministic merge</em> 다. </p>

<pre><code class="scala">def flatMap(f: T =&gt; Observable[S]): Observable[S] = {  
  map(f).flatten()
}
</code></pre>

<p>다른 코드도 좀 보면</p>

<pre><code class="scala">val xs: Observable[Int] = Observable(3, 2, 1)

val yss: Observable[Observable[Int]] =  
  xs.map(x =&gt; Observable.Interval(x seconds).map(_ =&gt; x).take(2))

val zs: Observalble[Int] = yss.flatten()  
</code></pre>

<p><img src='https://camo.githubusercontent.com/1db5afe0637db37bf24a0476deeb4a6af5f846a1/687474703a2f2f692e696d6775722e636f6d2f5a75364f5034442e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<p>위 코드는 <code>x</code> 초 후에 <code>x</code> 2개를 뱉는 <code>Oberservable</code> 을 만든 후 <code>flatten</code> 을 사용해 껍데기를 벗긴다. <code>List(List(1, 2), List(3)).flatten</code> 하면 <code>List(1, 2, 3)</code> 이 되듯이 <code>Observable[Observable].flatten</code> 도 <code>Observable</code> 을 만든다고 생각하면 쉽다.</p>

<h3 id="merge">Merge</h3>

<p><img src='https://camo.githubusercontent.com/7bf59d06b672be32c63b8c2260e68840b408e100/687474703a2f2f692e696d6775722e636f6d2f64376e74576d462e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<p>예외나, 종료 등 어떤 이유에서든지 먼저 끝나는 <code>Observable</code> 에 의해 <code>merge</code> 가 종료된다는 점에 주의하자.</p>

<h3 id="concat">Concat</h3>

<pre><code class="scala">val xs: Observable[Int] = Observable(3, 2, 1)

val yss: Observable[Observable[Int]] =  
  xs.map(x =&gt; Observable.Interval(x seconds).map(_ =&gt; x).take(2))

val zs: Observalble[Int] = yss.concat  
</code></pre>

<p><img src='https://camo.githubusercontent.com/2a578ecf4d5c6890f82ef27a5eb5330e3a613d4c/687474703a2f2f692e696d6775722e636f6d2f4b386a5147316e2e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<p>여기서 재밌는점은 <code>yss</code> 의 첫번째 원소인 </p>

<pre><code class="scala">Observable.Interval(3 seconds).map(_ =&gt; x).take(2)  
</code></pre>

<p>가 끝나기 전까지 다른 원소들이 버퍼링 되므로 주의해야 한다는 점이다. <em>marble diagram</em> 으로 보면</p>

<p><img src='https://camo.githubusercontent.com/126a399bf6587fd5d3a5e23975b3aeb865573269/687474703a2f2f692e696d6775722e636f6d2f62334a6e564d542e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<h3 id="earthquakesexample">Earthquakes example</h3>

<pre><code class="scala">def usgs(): Observable[EarthQuake] = { ... }

class EarthQuake {  
  ...
  def magnitude: Double
  def location: GeoCoordinate
}

object Magnitude extends Enumeration {  
  def apply(magnitude: Double): Magnitude = { ... }
  type Magnitude = Value

  val Micro, Minor, Light, Moderate, Strong, Major, Great = Value
}

val major = quakes.  
  map(q =&gt; (q.location, Magnitude(q.magnitude))).
  filter { case (loc, mag) =&gt; mag =&gt; Major }

major.subscribe({ case (loc, mag) =&gt;  
  println($"Magnitude ${ msg } quake at ${ loc }")
})
</code></pre>

<p>이런식으로 사용할 수 있다. 더 실제 동작하는 코드는 <a href='https://github.com/headinthebox/CourseraCodeSamplesReactiveProgramming' >여기</a>로. 조금 복잡하다.</p>

<p>위치를 <code>GeoCoordinate</code> 로 받기 때문에, 해당 위치의 나라를 돌려준다든지 등으로 개선할 수 있다.</p>

<pre><code class="scala">def reverseGeocode(g: GeoCoordinate): Future[Country] = { ... }  
</code></pre>

<p>이 함수를 구현하면</p>

<pre><code class="scala">val withCountry: Observable[Observable[EarthQuake, Country)]] =  
  usgs().map(q =&gt; {
    val country: Future[Country] = reverseGeocode(q.location)
    Objservable(country.map(country =&gt; (quake, country)))
  })

// val merged: Observable[(EarthQuake, Country)] =
//  withCountry.flatten()
val merged: Observable[(EarthQuake, Country)] = withCountry.concat()  
</code></pre>

<p>여기서 머징하기 위해 <code>flatten</code> 이나 <code>concat</code> 을 사용할 수 있는데, 언급했듯이 어떤걸 쓰느냐에 따라 순서가 달라질 수 있다. 아래 그림은 각각 <code>flatten</code>, <code>concat</code> 을 설명한다.</p>

<p><img src='https://camo.githubusercontent.com/d33a97e9d34e395be97256e9993798e4ae24362e/687474703a2f2f692e696d6775722e636f6d2f6258665a5a30532e706e67'  alt="" /></p>

<p><img src='https://camo.githubusercontent.com/f8689dc2d0bdd4435a34c5309f54c59b39b85162/687474703a2f2f692e696d6775722e636f6d2f6a3161486e55462e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<h4 id="groupby">group by</h4>

<p><img src='https://camo.githubusercontent.com/f0c975e06586e938d62c8c6c96eac90132cbc591/687474703a2f2f692e696d6775722e636f6d2f6e36543251624b2e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<pre><code class="scala">def groupBy[K](keySelector: T =&gt; K): Observable[(K, Observable[T])]  
</code></pre>

<p>즉 <code>T</code> 를 받아 키 <code>K</code> 를 만들고, 이것에 따라 <code>Observable</code> 을 그룹짓는다. 이걸 응용하면 나라별로 지진을 취합하는 것이 가능하다.</p>

<pre><code class="scala">val byCountry: Observable[(Country, Observable[(EarthQuake, Country)]] =  
  merged.groupBy( case (q, c) =&gt; c }
</code></pre>

<p><img src='https://camo.githubusercontent.com/c5cff5ae933284de2de7ed009c3d4228ea2f1b12/687474703a2f2f692e696d6775722e636f6d2f775852325a4c592e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<p>이제 <code>runningAverage</code> 란 함수가 있다고 해 보자. <code>Observable[Double]</code> 을 받아  업데이트 후 <code>Observable[Double]</code> 을 돌려주는 함수. 그러면 <code>runningAveragePerCountry</code> 는 어떻게 구현할까?</p>

<pre><code class="scala">val byCountry: Observable[(Country, Observable[(EarthQuake, Country)]]  
def runningAverage(s: Observable[Double]): Observable[Double] =  
  { ... }
val runningAveragePerCountry: Observable[(Country, Observable[Double])] =  
  byCountry.map { case (country, cqs) =&gt; 
    (country, runningAverage(cqs.map(_._1.magnitude))
  }
</code></pre>

<h3 id="subscription">Subscription</h3>

<p>지진 예제를 다시 가져오면, 더이상 관심 없을때 <code>unsubscribe</code> 를 호출할 수 있다.</p>

<pre><code class="scala">val quakes: Observable[EarthQuake] = { ... }  
val s: Subscription = quakes.Subscribe(...)

s.unsubscribe()  
</code></pre>

<p>근데, 생각해보면 여러 곳에서 <em>subscription</em> 할 수 있다. <em>UI</em> 같은 경우 그 수가 많을 것이다. 이 경우 <em>unsubscribing</em> 이 <em>cancellation</em> 을 의미하지 않는다. 왜냐하면 다른곳에서 <em>subscribing</em> 하고 있을 수 있기 때문이다.</p>

<p>타입을 좀 보면</p>

<pre><code class="scala">trait Subscription {  
  def unsubscribe(): Unit
}

object Subscription {  
  def apply(unsubscribe: =&gt; Unit): Subscription
}

trait BooleanSubscription extends Subscription {  
  def isUnsubscribed: Boolean
}

trait CompositeSubscription extends BooleanSubscription {  
  def +=(s: Subscription): this.type
  def -=(s: Subscription): this.type
}

trait MultipleAssignmentSubscription extends BooleanSubscription {  
  def subscription: Subscription
  def subscription_=(that: Subscription): this.type
}
</code></pre>

<p>여기서 <code>CompositeSubscription</code> 은 컬렉션처럼 <code>Subscription</code> 을 추가하거나, 제거할 수 있고 <code>unsubscribe</code> 하면 나머지도 모두 취소 된다.</p>

<p><code>MultipleAssignmentSubscription</code> 은 일종의 <em>inner subscription</em> 을 위한 프록시처럼 동작한다. 세팅하고, 교체할 수 있지만, 항상 내부에는 동작하는 하나의 <code>Subscription</code> 이 있다.</p>

<pre><code class="scala">import rx.lang.scala.subscriptions._  
import rx.lang.scala.Subscription

val s = Subscription {  
  println("bye, bye")
}

s.unsubscribe()  
s.unsubscribe() // buggy  
</code></pre>

<p>이 경우 두번째 <code>unsubscribe()</code> 를 호출했을때 <code>"bye, bye"</code> 가 호출되지 않는다. 먼저 <code>unsubscribe()</code> 를 호출했기 때문이다. </p>

<p>직접 <code>Subscription</code> 을 구현할때는 다수의 스레드에서 저마다 <code>unsubscribe()</code> 를 호출할 수 있기 때문에 이 메소드는 <em>idempotent</em> 하게 구현되야 한다.</p>

<p><code>CompositeSubscription</code> 을 이미 <code>unsubscribe</code> 했을땐, 새로운 <code>Subscription</code> 을 추가한다 하더라도 자동으로 <code>unsubscribe</code> 가 호출된다.</p>

<p><code>MultiAssignmentSubscription</code> 의 경우에는 여러번 할당할 수 있으나, 단 하나의 <code>Subscription</code> 만 가리킨다. 따라서 다음 코드를 실행할 경우 <code>b.unsubscribe</code> 만 호출된다.</p>

<pre><code class="scala">val a = Subscription { println("A") }  
val b = Subscription { println("B") }  
val m = MultiAssignmentSubscription()

multi.subscription = a  
multi.subscription = b  
multi.unsubscribe  
</code></pre>

<p><code>CompositeSubscription</code> 과 마찬가지로 이미 <code>unsubscribe</code> 되었다면, 할당되는 <code>Subscription</code> 도 자동으로 <code>unsubscribe</code> 된다.</p>

<p><code>CompositeSubscription</code> 이나 <code>MultiAssignment</code> 를 연산을 공유하는 컨테이너라 볼 수 있겠는데, 그럼 여기서 내부의 것만 <code>unsubscribe</code> 하면 어떻게 될까? 당연히 외부의 <code>MultiAssignment</code> 나 <code>Composite</code> 는 알 길이 없으니 <code>isUnsubscribe</code> 는 <code>false</code> 가 된다.</p>

<h3 id="rxstream">Rx Stream</h3>

<p>자주 보게 될 타입부터 소개하면</p>

<pre><code class="scala">object Observable {  
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

trait Observable[T] {  
  def subscribe(observer: Observer[T]): Subscription
}

trait Observer[T] {  
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
  def OnCompleted(): Unit
}

trait Subscription {  
  def unsubscribe(): Unit
}
</code></pre>

<p>아무런 알림도 못받는 <code>Observable</code> 을 만드는 <code>never</code> 와, <code>onError</code> 를 호출하는 <code>apply</code> 를 구현해 보자.</p>

<pre><code class="scala">def never(): Observable[Nothing] = Observable[Nothing](observer =&gt; {  
  Subscription {}
})

def apply[T](error: Throwable): Observable[T] =  
  Observable[T](observer =&gt; {
    observer.onError(error)
    Subscription {}
  }
</code></pre>

<p>이제 이 함수들을 이용해 다양한 함수를 구현해 보자.</p>

<h4 id="startwith">startWith</h4>

<pre><code class="scala">object Observable {  
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

def switchWith(ss: T*): Observable[T] = {  
  Observer[T](observer =&gt; {
    for(s &lt;- ss) observer onNext(s)
    subscribe(observer)
  }
}
</code></pre>

<h4 id="filter">filter</h4>

<p><img src='http://reactivex.io/assets/operators/filter.png'  alt="" /></p>

<pre><code class="scala">object Observable {  
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

def filter(p: T =&gt; Boolean): Observable[T] = {  
  Observable[T](observer =&gt; {
    subscribe(
      (t: T) =&gt; { if (p(t)) observer.onNext(t) },
      (e: Throwable) =&gt; { observer.onError(e) },
      () =&gt; { observer.onCompleted() }
    )
  })
}
</code></pre>

<p><br/></p>

<h4 id="map">map</h4>

<p><img src='http://reactivex.io/assets/operators/map.png'  alt="" /></p>

<pre><code class="scala">object Observable {  
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

def map[S](f: T =&gt; S): Observable[S] = {  
  Observable[T](observer =&gt; {
    subscribe(
      (t: T) =&gt; { if (p(t)) observer.onNext(f(t)) },
      (e: Throwable) =&gt; { observer.onError(e) },
      () =&gt; { observer.onCompleted() }
    )
  })
}
</code></pre>

<p>그림을 잘 보면 <em>input stream</em> 으로 부터 값을 얻어 함수를 적용하고 <em>output stream</em> 으로 뱉는다. 구현도 마찬가지로 현재의 컨테이너인 <code>Observable</code> 로 부터 값을 얻었을때 함수를 적용하고 어떻게 넘겨줄지를 정의한다. </p>

<p><em>duality</em> 관계인 <code>Iterable</code> 의 <code>map</code> 구현을 보면 더 명확히 알 수 있다.</p>

<pre><code class="scala">def map[S](f: T =&gt; S): Iterable[S] = {  
  new Iterable[S] {
    val it = this.iterator()
    def iterator: Iterator[S] = new Iterator[S] {
      def hasNext: Boolean = { it.hasNext }
      def next(): S = { f(it.next()) }
    }
  }
}
</code></pre>

<h4 id="futuretoobservable">Future to Observable</h4>

<p><code>Future[T]</code> 를 얻어 <code>Observable[T]</code> 로 바꿔보자. <code>T</code> 를 <code>List[T]</code> 로 바꾸듯이. 그럴려면 <code>Subject</code> 를 알아야 하는데, 이건 지난시간에 배운 <code>Promise</code> 비슷한 역할을 한다.</p>

<pre><code class="scala">import scala.concurrent.ExecutionContext.Implicits.global

def race[T](left: Future[T], right: Future[T]): Future[T] = {  
  val p = Promise[T]()

  left  onComplete { p.tryComplete(_) }
  right onComplete { p.tryComplete(_) }

  p.future
}
</code></pre>

<p><code>Promise</code> 로 부터 <code>Future</code> 를 얻고, <code>Future.onComplete</code> 에 콜백을 넘기면, 완료되었을때 <code>Promise.complete</code> 에 의해 호출된다. <code>Promise</code> 는 <code>Future</code> 를 위한 대리자? 프록시쯤으로 볼 수 있다. </p>

<p><code>Observable</code> 과 <code>Subject</code> 도 비슷한 관계다. </p>

<p><img src='https://camo.githubusercontent.com/bf2c5f3f0d9cadd2b62b347d91be4f4024bd5c8d/687474703a2f2f692e696d6775722e636f6d2f4879644b49374c2e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<p>코드로 이해해 보자.</p>

<pre><code class="scala">val channel = PublishSubject[Int]()

val a = channel.subscribe(x =&gt; println("a: " + x))  
val b = channel.subscribe(x =&gt; println("b: " + x))

channel.onNext(42)  
a.unsubscribe()

channel.onNext(4711)  
channel.onComplete()

val c = channel.subscribe(x =&gt; println("c: " + x))  
channel.onNext(13)  
</code></pre>

<p><img src='https://camo.githubusercontent.com/52f18665a6534224028549d548f23833f3abab10/687474703a2f2f692e696d6775722e636f6d2f5671507a6b42372e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<p><code>Subject</code> 는 일종의 채널이라 보면 된다. 위 코드에서 흥미로운 점은 <code>onComplete</code> (<code>!</code> 로 표시) 가 호출 된 뒤에 옵저버 <code>c</code> 를 <code>Subject</code> 에 추가했음에도 <code>c</code> 도 <code>onComplete</code> 가 호출된 것을 알고 있다는 사실이다. </p>

<p><br/></p>

<pre><code class="scala">val channel = ReplaySubject[Int]()

val a = channel.subscribe(x =&gt; println("a: " + x))  
val b = channel.subscribe(x =&gt; println("b: " + x))

channel.onNext(42)  
a.unsubscribe()

channel.onNext(4711)  
channel.onComplete()

val c = channel.subscribe(x =&gt; println("c: " + x))  
channel.onNext(13)  
</code></pre>

<p><img src='https://camo.githubusercontent.com/5a105a4004a31498e930295235501c0963ae7fe0/687474703a2f2f692e696d6775722e636f6d2f577770466d34752e706e67'  alt="" /></p>

<p><code>ReplaySubject</code> 의 경우에는 <code>c</code> 에도 모든 데이터를 받는다. 이는 <code>ReplaySubject</code> 가 히스토리를 캐싱하고있기 때문이다. </p>

<p>다양한 종류의 <code>Subject</code> 를 그림으로 보면</p>

<p><img src='https://camo.githubusercontent.com/ee926edb502552b7b50a1858ae4baf601d19b26b/687474703a2f2f692e696d6775722e636f6d2f78424a5874596d2e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<h4 id="convertingfuturetoobservable">Converting Future to Observable</h4>

<pre><code class="scala">object Observable {  
  def apply[T](f: Future[T]): Observable[T] = {
    val as = AsyncSubject[T]()

    f onComplete {
      case Failure(e) =&gt; { as.onError(e) }
      case Success(c) =&gt; { as.onNext(c); as.onCompleted() }
    }

    as
  }
}
</code></pre>

<p>복잡하게 생각하지 말고 그냥 <code>Promise</code> 랑 비슷한 일을 한다고 이해하면 쉽다.</p>

<h4 id="notifications">Notifications</h4>

<p>지난 시간에 <code>Future</code> 가 <code>Try</code> 를 이용하는걸 봤다. <code>Future[Try[T]</code> 처럼.  <code>Notification</code> 도 이와 비슷하다. <code>Observable[Notification[T]]</code> 처럼 사용한다.</p>

<pre><code class="scala">abstract class Try[+T]  
case class Success[T](elem: T) extends Try[T]  
case class Failure(t: Throwable) extends Try[Nothing]

abstract class Notification[+T]  
case class OnNext[T](elem: T) extends Notification[T]  
case class OnError(t: Throwable) extends Notification[Nothing]  
case object onCompleted extends Notification[Nothing]

def materialize: Observable[Notification[T]] = { ... }  
</code></pre>

<p>차이라면, <em>종료</em> 를 알려주는 <code>onCompleted</code> 가 있다는 것이다. <code>materialize</code> 는 <code>Observable[T]</code> 를 감싸 <code>Observable[Notification[T]]</code> 로 만든다.</p>

<p><img src='https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/materialize.png'  alt="" /></p>

<h4 id="blocking">Blocking</h4>

<p>권할만한 방법은 아니지만, 만약에, 만약에 블러킹이 필요하다면 이런식으로 코드를 작성할 수도 있다는 것을 지난시간에 배웠다.</p>

<pre><code class="scala">val f: Future[String] = { ... }  
val text: String = Await.result(f, 10 seconds)  
</code></pre>

<p><code>Observable</code> 도 마찬가지다.</p>

<p><img src='https://camo.githubusercontent.com/f71128934e19a648745cd6d02664cdc887b55db6/687474703a2f2f692e696d6775722e636f6d2f66683745746f692e706e67'  alt="" /></p>

<pre><code class="scala">val xs: Observable[Long] = Observable.interval(1 seconds).take(5)  
val ys: List[Long] = xs.toBlockingObservable.toList

println(ys)

// all Rx operators are non-blocking
val zs: Observable[Long] = xs.sum  
val s: Long = zs.toBlockingObservable.single  
</code></pre>

<h4 id="observabletoscalartypes">Observable to Scalar Types</h4>

<p><code>Observable</code> 내에 있는 값들을 계산하기 위해 <code>reduce</code> 를 사용할 수 있다. <code>fold</code> 와 비슷하달까</p>

<p><img src='https://camo.githubusercontent.com/c2f1c7ca45a71649a8f64c515c282835ef543b1d/687474703a2f2f692e696d6775722e636f6d2f5130636a64395a2e706e67'  alt="" /></p>

<pre><code class="scala">def reduce(f: (T, T) =&gt; T): Observable[T]  
</code></pre>

<p>재밌는 사실은 리턴타입이 원소가 <code>Observable</code> 을 돌려주기 때문에 <code>Future</code> 와 비슷하다는 것이다.</p>

<h4 id="iterabletoobservable">Iterable to Observable</h4>

<p>잘못된 구현을 먼저 보자.</p>

<pre><code class="scala">def from[T](seq: Iterable[T]): Observable[T] =  
  Observable(o =&gt; {
    seq.foreach(s =&gt; o.onNext(s)) // What if seq is infinite?
    o.onCompleted // What if seq fails?
    Subscription {}
  })
</code></pre>

<p>이 구현의 문제점은, <code>Iterable</code> 이 무한하거나, 실패하면 어떻게 처리할지 전혀 고려하지 않았다는 것이다. 게다가 빈 <code>Subscription</code> 을 돌려주기 때문에, <code>unsubscribe</code> 할 수도 없다.</p>

<p>이 문제를 풀기 위해서는 <em>scheduler</em> 가 필요하다.</p>

<h3 id="scheduler">Scheduler</h3>

<p>우선 돌아가는 코드를 만들기 전에 테스트 케이스부터 작성하자</p>

<pre><code class="scala">// factory method
object Observable {  
  def apply[T](subscribe: Observer[T] =&gt; Subscription): Observable[T]
}

def from[T](seq: Iterable[T]): Observable[T] = { ... }

// infinite seq
def nats(): Iterable[Int] = new Iterable[Int] {  
  val i = -1
  def iterator: Iterator[Int] = new Itertor[Int] {
    def hasNext: Boolean = { true }
    def next(): Int = { i += 1; i }
  }
}

val infinite: Iterable[Int] = nats()  
val subscription = from(infinite).subscribe(x =&gt; println(x))

subscription.unsubscribe()  
</code></pre>

<p>만약 <code>from</code> 이 위에서 본 것처럼 구현되어 있다면 <code>subscription.unsubscribe()</code> 에 도달하지 못한다. 따라서 <em>iteration</em> 을 진행하는 것과는 다른 컨텍스트를 도입해 <code>unsubscribe</code> 를 호출해야 한다. 그래서 스케쥴러가 필요하다. </p>

<p><code>Future</code> 에서는 <code>ExecutionContext</code> 가 있었지만, <code>Observable</code> 은 복수개의 컨텍스트를 조작해야 하므로 스케쥴러를 써야한다.</p>

<pre><code class="scala">object Future[  
  def apply[T](body: =&gt; T)
   (implicit executor: ExecutionContext): Future[T]
}

trait Observable[T] {  
  def observeOn(scheduler: Scheduler): Observable[T]
}

// Runnable == Java's Runnable
trait ExecutionContext {  
  def execute(runnable: Runnable): Unit
}

// '=&gt; Unit' == Runnable
trait Scheduler {  
  def schedule(work: =&gt; Unit) Subsciption
}

// example
val scheduler = Scheduler.newThreadScheduler  
val subscription = scheduler.schedule {  
  println("Hello World!")
}
</code></pre>

<p><code>Future</code> 는 <code>Runnable</code> 을 취소할 수 있는 방법이 없지만, <code>Scheduler</code> 는 <code>Subscription</code> 을 리턴하기 때문에 취소할 수 있다. 그러나 일단 작업이 시작되면 취소할 수 있는 방법은 없다. 아래 예제를 보자</p>

<pre><code class="scala">def from[T](seq: Iterable[T])  
    (implicit s: Scheduler): Observable[T] = {

  Observable[T](o =&gt; {
    s.schedule {
      seq.foreach(x =&gt; observer.onNext(x))
      observer.onCompleted()
    }
  }
}
</code></pre>

<p><code>onNext</code> 가 호출되기 전, 아주 잠깐동안만 작업을 취소할 수 있는 기회가 있다. 다시 말해서, 이터레이션이 통채로 스케쥴링 되기 때문에 좀 별로라는 것이다. 매 이터레이션마다 취소할 기회가 있는 <code>from</code> 을 구현하고 싶다. </p>

<p><code>scheduler</code> 의 다른 시그니쳐를 좀 보자.</p>

<pre><code class="scala">trait Scheduler {  
  def schedule(work: =&gt; Unit): Subscription

  def schedule(work: Scheduler =&gt; Subscription): Subscription

  def schedule(work: (=&gt; Unit) =&gt; Unit): Subscription
}
</code></pre>

<p>두번째 시그니쳐를 보자. <code>schedule</code> 함수가 하는 일이 <code>Scheduler</code> 를 받아 등록하고 <code>Subscription</code> 을 돌려주는 일이라면 그것 자체를 <code>work</code> 로 받고, 해당 <code>work</code> 에서 한번씩만 이터레이션 한다면 매 이터레이션에서 취소할 기회를 가질 수 있다. </p>

<p>이건 사실 세번째 시그니쳐와 동일한데 이유는 뒤에서 보겠다. </p>

<p><code>from</code> 의 새로운 구현을 보면</p>

<pre><code class="scala">def from[T](seq: Iterable[T])  
    (implicit) scheduler: Scheduler): Observable[T] = {

  Observable[T](o =&gt; {
    val it = seq.iterator()

    scheduler.schedule(self =&gt; {
      if (it.hasNext) { o.onNext(it.next()); self() }
      else { o.onCompleted() }
    }
  }
}
</code></pre>

<p><del>으사양반 이게 무슨 개소리요!</del></p>

<p>조금 난해한데, <code>it.hasNext</code> 가 있어서 다음 이터레이션으로 넘어갈 수 있으면 <code>self()</code> 를 호출해 자기 자신을 스케쥴링한다. 따라서 매 이터레이션마다 사용 가능한 <code>Subscription</code> 이 있으므로 취소할 수 있는 기회가 생긴다. </p>

<p><img src='https://camo.githubusercontent.com/216556caf19e30587d4697466b4244b33f182f76/687474703a2f2f692e696d6775722e636f6d2f78683546576a382e706e67'  alt="" /></p>

<p>물론 <code>Subscription</code> 이 갱신되는데 어떻게 하나의 레퍼런스로 그게 가능하느냐 하는 질문이 나올 수 있는데, 우리는 이미 <code>MultipleAssignmentSubscription</code> 을 배웠다. <code>schedule</code> 함수의 내부를 보자.</p>

<pre><code class="scala">def schedule(work: (=&gt; Unit) =&gt; Unit): Subscription = {  
  val subs = new MultipleAssignmentSubscription()

  schedule(scheduler =&gt; {
    def loop(): Unit = {
      subs.Subscription = scheduler.schedule {
        work { loop() }
      }
    }

    loop()
    subs
  })

  subs
}

def from[T](seq: Iterable[T])  
    (implicit) scheduler: Scheduler): Observable[T] = {

  Observable[T](o =&gt; {
    val it = seq.iterator()

    scheduler.schedule(self =&gt; {
      if (it.hasNext) { o.onNext(it.next()); self() }
      else { o.onCompleted() }
    }
  }
}
</code></pre>

<p>즉, <code>self</code> 가 바로 <code>loop</code> 다. 자기 자신을 스케쥴링하는 함수인데, 
<code>work -&gt; loop -&gt; work -&gt; loop -&gt; ...</code> 을 반복하면서 더 이터레이션할 멤버가 없거나, <code>unsubscribe</code> 하기 전까지 재귀적으로 돈다. </p>

<h4 id="schedulertoobservable">Scheduler to Observable</h4>

<p>돌려주는 값 없이 행위 그 자체만 보면, 스케쥴러 그 자체는 <code>Observable[Unit]</code> 에 대응된다. </p>

<pre><code class="scala">object Observable {  
  def apply() (implicit s: Scheduler): Observable[Unit] = {
    Observable(o =&gt; {
      s.schedule(self =&gt; {
        o.onNext(()); self
      })
    })
  }
}

implicit val s = Scheduler.NewThreadScheduler  
val ticks: Observable[Unit] = Observable()  
</code></pre>

<p>이게 실제로 어떻게 동작하나 보면</p>

<pre><code class="scala">object Observable {  
  def apply(s: Observer[T] =&gt; Subscription) = new Observable[T] {
    def subscribe(o: Observer[T]): Subscription = { Magic(s(o)) }
  }
}

val subs = Observable(o =&gt; F(o)).subscribe(observer)

// = conceptually
val subs = Magic(F(observer))  
</code></pre>

<p>여기서 <code>F</code> 나 <code>Magic</code> 는 임의의 함수라 생각하면 된다. (그런게 있나보다 하자.)</p>

<p>이걸 왜 이야기하냐 하면 <em>auto unsubscribe</em> 가 가능하기 때문이다. 스케쥴링 하는 행위를 <em>observable</em> 로 변경할 수 있다면, 스케쥴링이 불가능할때 <em>unsubscribe</em> 하도록 만드는 것이다.</p>

<p><code>F</code> 가 <code>observer.onCompleted</code> 나 <code>observer.OnError</code> 를 호출한다면, <code>Magic</code> 함수에 의해 자동으로 <code>unsubscribe</code> 가 호출된다. 이로인해 다음에 호출되는 <code>onNext</code> 는 아무런 영향도 미치지 않게 된다.</p>

<p>이럴 수 있는 이유는 <code>Observable</code> 을 생성하는 방식이 <em>Rx Contract</em> 을 만족하기 때문이다. (따라서 직접 <code>Observable, Observer</code> 를 만들지 말고 팩토리 메소드를 사용해야한다)</p>

<pre><code class="scala">(onNext)*(onCompleted + onError)?
</code></pre>

<p><code>onNext</code> 는 여러번 호출될 수 있으나 겹치지 않고, <code>onCompleted</code> 나 <code>OnError</code> 는 옵션이지만 (무한한 시퀀스가 존재하기때문) 호출된다면 둘 중 단 한개만, 단 한번 호출되야한다는 것이다. 아까 본 코드를 다시 나열해서 어떻게 그렇게 되나 살펴보자.</p>

<pre><code class="scala">object Observable {  
  def apply() (implicit s: Scheduler): Observable[Unit] = {
    Observable(o =&gt; {
      s.schedule(self =&gt; {
        o.onNext(()); self
      })
    })
  }
}

def schedule(work: (=&gt; Unit) =&gt; Unit): Subscription = {  
  val subs = new MultipleAssignmentSubscription()

  schedule(scheduler =&gt; {
    def loop(): Unit = {
      subs.Subscription = scheduler.schedule {
        work { loop() }
      }
    }

    loop()
    subs
  })

  subs
}


implicit val s = Scheduler.NewThreadScheduler  
val ticks: Observable[Unit] = Observable()

ticks.subscribe(observer)  
</code></pre>

<p>여기서 <code>ticks.subscribe(observer)</code> 를 계속 풀면</p>

<pre><code class="scala">Observable({ o =&gt; scheduler.schedule {  
  self =&gt; o.onNext(()); self()
}}).subscribe(observer)

// unfold create
scheduler.schedule {  
  self =&gt; observer.onNext(()); self()
}

// unfold schedule
val m = new MultipleAssignmentSubscription()

schedule(scheduler =&gt; {  
  def loop(): Unit = {
    m.Subscription = scheduler.schedule {
      { self =&gt; observer.onNext(()); self() }({ loop() })
    }
  }

  loop()
  m
})

// `self` is a continuation
val m = new MultipleAssignmentSubscription()

schedule(scheduler =&gt; {  
  def loop(): Unit = {
    m.Subscription = scheduler.schedule {
      { observer.onNext(()); loop() }
    }
  }

  loop()
  m
})

// extract loop
val m = new MultipleAssignmentSubscription()

def loop(): Unit = {  
    m.Subscription = scheduler.schedule {
      { observer.onNext(()); loop() }
    }
}

schedule(scheduler =&gt; {  
  loop()
  m
})

// apply loop
schedule(scheduler =&gt; {  
  m.Subscription = scheduler.schedule {
      { observer.onNext(()); loop() }
  }

  m
})
</code></pre>

<p>즉 매 스케쥴링마다, <em>subscription</em> 을 갱신하고, 작업을 진행한뒤, 자기 자신을 다시 스케쥴링 한다.</p>

<h4 id="range">Range</h4>

<p>이렇게 응용할 수 있다.</p>

<pre><code class="scala">implicit val scheduler: Scheduler = Scheduler.NewThreadScheduler

def range(start, Int, count: Int):  
  (implicit s: Scheduler) Observable[Int] = {

  Observable(o =&gt; {
    var i = 0
    Observable().subscribe(u =&gt; {
      if (i &lt; count) { o.onNext(start + i); i += 1 }
      else { o.onCompleted() }
    })
  })
}

val xs = range(1, 10)  
    xs.subscribe(x =&gt; println(x))
    println("range out")
</code></pre>

<p>즉 <code>Observable()</code> 은 일종의 무한히 반복되는 스케쥴러고 여기에 액션을 추가해 원하는 작업을 해낼 수 있다. 그리고 작업이 완료되면 자동으로 <em>unsubscribe</em> 를 수행한다. 이제 무한히 긴 스트림을 <code>Observable</code> 로도 다룰 수 있게 되었다.</p>

<h3 id="references">References</h3>

<p>(1) <em>Reactive Programming</em> by <strong>Martin Ordersky</strong> <br />
(2) <a href='http://reactivex.io/' >http://reactivex.io/</a> <br />
(3) <a href='https://github.com/iirvine/principles-of-reactive-programming/blob/master/notes/week-4/002-basic-combinators-on-observable-collections.md' >https://github.com/iirvine</a>  </p>]]></description><link>http://1ambda.github.io/reactive-programming-4/</link><guid isPermaLink="false">d34db484-100f-49c7-b55a-670970d19b33</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[observable]]></category><category><![CDATA[rx]]></category><category><![CDATA[scheduler]]></category><category><![CDATA[subscription]]></category><category><![CDATA[subject]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 26 Dec 2014 09:58:19 GMT</pubDate></item><item><title><![CDATA[Process Mining, Week5]]></title><description><![CDATA[<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-3-728.jpg?cb=1305062373'  alt="" /></p>

<p>지난 4주간 배운바를 간단히 정리해보면</p>

<ul>
<li>첫 2주는 <em>model discovery</em></li>
<li>지난 2주는 <em>conformance checking</em> </li>
</ul>

<p>이 것들은 <em>control flow</em> 에 관련된 것들이었다. 이제는 기본적인 <em>event log</em> 의 데이터 뿐만 아니라 <em>time, resource, data</em> 등을 이용하면서 <em>model enhancement</em> 를 할 수 있는 기법들을 배워보자.</p>

<p>앞으로 이야기 할 내용은</p>

<ul>
<li>mining decision points</li>
<li>mining bottlenecks</li>
<li>mining social networks</li>
<li>comparative process mining</li>
<li>operational support: detect, predict, recommend</li>
</ul>

<h3 id="miningdecisionpoints">Mining Decision Points</h3>

<p><em>model enhancement</em> 은 <em>conformance checking</em> 과는 다르게, 모델을 더 나은 방향으로 <strong>변형</strong>하는 것을 목표로 한다.</p>

<ul>
<li><strong>extend:</strong> adding additional perspectives to the model using event data</li>
<li><strong>repair:</strong> improving the quality of the model using event data</li>
</ul>

<p>먼저 <em>extend</em> 에 대해 이야기 해 보자. <em>decision point</em> 를 마이닝 할 건데, 인풋으로 </p>

<ul>
<li><em>event log</em></li>
<li><em>process model</em></li>
</ul>

<p>이 필요하다. 그리고 로그와 모델이 <strong>aligned</strong> 되어 있다는 가정하에 마이닝을 시작한다.</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-33-728.jpg?cb=1305062373'  alt="" /></p>

<p><em>decision tree</em> 에서 했던것 처럼 <em>predictor variable</em> 을 이용해 <em>response variable</em> 인 <em>transition</em> 을 선택할 수 있다. 이 때 <em>predictor variable</em> 은 <em>event log</em> 에 있는 <em>attribute</em> 다. 예를 들어</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-35-728.jpg?cb=1305062373'  alt="" /></p>

<p>여기서 우측 하단에 <em>inclusive OR</em> 이 있는데, 하나만 택하거나 둘 모두 택할 수 있는 <em>place</em> 다. 이 것도 마찬가지로 <em>decision tree</em> 를 만들듯이 생성할 수 있다. 슬라이드에서는 <code>x, y</code> 로의 두 <em>guard</em> 를 만들었지만 둘다 택 할 수 있는 경우가 있다. 예를 들어 <code>amount &lt; 500, type = silver</code> 면 <code>y, z</code> 모두를 택한다.</p>

<p><em>event log</em> 에 있는 정보 이외에도, <em>decision point</em> 를 마이닝 하기 위해 <em>predictor variable</em> 로 <em>last event</em> 나 <em>previous event</em> 를 사용할 수 있다.</p>

<p>이외에도 <em>predictor variable</em> 는 프로세스 인스턴스의 <em>context</em> 에 근거해서 다양한 값일 수 있는데</p>

<ul>
<li>number of cases running</li>
<li>number of resources present</li>
<li>workload of reousrce</li>
<li>day of the week 등</li>
</ul>

<p>한 가지 주의할점은 더 많은 변수, 더 많은 조합들이 있을수록 데이터가 희박해지기 때문에 <em>overfitting</em> 할 수 있다는 점이다. </p>

<p>이벤트 로그의 속성을 이용해 만든 <em>decision tree</em> 로, 모델에 <em>guard</em> 를 추가할 수 있다. 하지만, 이 가드가 <em>prescriptive</em> 한 것은 아니다. 오히려 <em>descriptive</em> 에 가깝다.</p>

<blockquote>
  <p>The guard discovered are describing what has happend rather than what should have happended</p>
</blockquote>

<h3 id="miningbottlenecks">Mining Bottlenecks</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-29-728.jpg?cb=1305062373'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-30-728.jpg?cb=1305062373'  alt="" /></p>

<p>위 로그를 돌려보면, 이와 같은 <em>duration</em> 같은 정보를 얻을 수 있다.</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-31-728.jpg?cb=1305062373'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-32-728.jpg?cb=1305062373'  alt="" /></p>

<p>이런식으로 볼 수도 있다.</p>

<h3 id="miningsocialnetworks">Mining Social Networks</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-18-728.jpg?cb=1305062373'  alt="" /></p>

<p>잘 보면 이벤트로그를 <em>arrtibute</em> <code>name</code> 과 연관 지었다. </p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-19-728.jpg?cb=1305062373'  alt="" /></p>

<p>이 로그를 이용하면 누가 무엇을 얼마나 실행했는지 파악할 수 있고, 이를 이용해서 그래프를 그릴 수 있다. 한 가지 생각해 볼 점은 노드가 얼마나 <strong>중요한가</strong> 는 정의에 따라 다를 수 있다는 것이다. <em>closeness</em>, <em>out degree</em> 등등.</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-21-728.jpg?cb=1305062373'  alt="" /></p>

<p>이건 누구로 부터 누구로 일이 전달되었는가를 매트릭스로 표현한 것이다. 이걸 이용하면</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-22-728.jpg?cb=1305062373'  alt="" /></p>

<p>이름이 아니라 다른 <em>attribute</em> 인 <em>role</em> 을 이용하면</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-23-728.jpg?cb=1305062373'  alt="" /></p>

<p>소셜 네트워크 마이닝을 위한 기법을 정리하면</p>

<ul>
<li><strong>Resource-activity matrix</strong> 로 누가 무엇을 하는지</li>
<li><strong>Handover of work matrix</strong> 로 일이 어떻게 전달되는지</li>
</ul>

<p>를 파악할 수 있고, 이를 이용해 그래프를 만들 수 있다. 물론 이 외에도 다양한 방법들이 있다.</p>

<h3 id="organizationalmining">Organizational Mining</h3>

<p>클러스터링과 비슷하다고 보면 된다. 이벤트 로그를 기반으로 몇개의 집단으로 묶는 것이다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-24-728.jpg?cb=1305062373'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-25-728.jpg?cb=1305062373'  alt="" /></p>

<p><br/></p>

<p>위의 예에서는 <em>resource</em> 기반으로 묶었지만 <em>case</em> 로 묶어 <em>process variants</em> 를 확인할 수도 있다.</p>

<p>그리고 위에서 발견한 <em>organizational perspective</em> 를 모델에 적용하면 이런 재미난 그림을 얻을 수 있다. 누가 어떤일을 하는지를 넘어, 어떤 집단이 어떤 일을 주로 하는지를 파악할 수 있는 것이다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-26-728.jpg?cb=1305062373'  alt="" /></p>

<p><br/></p>

<p>프로세스 마이닝을 실제 로그에 적용해 보면 스트레스 대비 일의 퍼포먼스를 설명하는 [<em>Yerkes-Dodson law</em>] 도 볼 수 있다고 한다.</p>

<p><img src='http://sourcesofinsight.com/wp-content/uploads/2008/09/yerkes-dodson-human-performance-curve.gif'  alt="" /></p>

<p align="center">(<a href='http://sourcesofinsight.com/' >http://sourcesofinsight.com/</a>)</p>

<p>프로세스 마이닝은 사회과학쪽으로도 유용할 것 같다. <del>근데 이 그래프는 너무 테일러리즘ㅠ</del></p>

<h3 id="conbiningdifferentperspectives">Conbining Different Perspectives</h3>

<p>이 전 까지 배웠던 다양한 <em>perspectives</em> 들</p>

<ul>
<li>data perspective</li>
<li>resource perspective</li>
<li>time perspective</li>
<li>control-flow perspective</li>
</ul>

<p>이런 하나의 모델로 조합해 보자.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-37-728.jpg?cb=1305062373'  alt="" /></p>

<p><br/></p>

<p><em>control flow</em>, 즉 모델에 </p>

<ul>
<li><em>data perspective</em> 를 추가하면 <em>guard</em> 를 얻을 수 있고 </li>
<li><em>time perspective</em> 는 <em>wating time</em>, <em>service time</em> 을 확인하는데 도움을 준다</li>
<li><em>resource perspetive</em> 는 모델을 <em>role</em>, <em>individual</em> 관점에서 이해하는데 도움을 준다.</li>
</ul>

<p>이 조합된 모델에 <em>limitation</em> 이 있다는 것, 그리고 이 모든 것은 <em>descriptive</em>(<strong>as is</strong>) 하다는 것을 명심하자.</p>

<p>다양한 관점이 적용된 모델을 이런 곳에 활용할 수 있다.</p>

<ul>
<li><em>diagnosis</em></li>
<li><em>re-engineering</em></li>
<li>예측이나 추천같은 <em>operational support</em> </li>
<li><strong>What if</strong> 를 다루는 <em>simulation</em> </li>
</ul>

<h3 id="comparativeprocessminingusingprocesscubes">Comparative Process Mining Using Process Cubes</h3>

<p><em>event log</em> 에는 다양한 <em>attribute</em> 를 가지고 있다. 이것들을 서로 비교해 가면서 더 좋은 프로세스 마이닝 모델을 선택할 수 있다. 즉, 다양한 조합의 액티비티, 케이스, 리소스 등을 선택해 가면서 가장 적합한 모델을 찾아내는 것이다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter10toolsupport-121219213613-phpapp01/95/process-mining-chapter10toolsupport-4-638.jpg?cb=1355974631'  alt="" /></p>

<p>이 큐브의 각 축은 차원을 나타내고, 각 셀은 어떤 특정 패턴의 이벤트 로그를 나타낸다 볼 수 있다.</p>

<p>이렇게 프로세스 큐브를 사용하면 다차원 분석이 가능하다. <em>data ware house</em> 나 <em>OLAP</em> 도 비슷한 일을 하긴 하는데, 프로세스 마이닝과의 큰 차이점이 하나 있다.</p>

<blockquote>
  <p>Related, but often data is aggregated it useless for process mining(events are lost)</p>
</blockquote>

<h3 id="refinedprocessminingframework">Refined Process Mining Framework</h3>

<p>전체적인 큰 그림은 아래와 같다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter09operationalsupport-110510153302-phpapp02/95/process-mining-chapter-9-operational-support-4-728.jpg?cb=1305062304'  alt="" /></p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter09operationalsupport-110510153302-phpapp02/95/process-mining-chapter-9-operational-support-5-728.jpg?cb=1305062304'  alt="" /></p>

<p>꼭대기부터 차근차근 보자. 여기서 <em>provenance</em> 란 수집하는 이벤트 로그가 신뢰성이 있어야 한다는 것을 의미한다. 그리고 이 이벤트 로그는 두 가지로 나뉘는데</p>

<ul>
<li><p><strong>Post mortem event data:</strong> refer to information about cases that have completed. i.e., these can be used for process improvement and auditing but not for influencing the cases they refer to</p></li>
<li><p><strong>Pre mortem event data:</strong> If a case is still running, <strong>alive</strong>, then it may be possible that information in the event log about this case <strong>can be exploited</strong> to ensure the correct or efficient handling of this case</p></li>
</ul>

<p>즉 <em>pre mortem</em> 은 현재 진행중인 것을 말한다. <del>와이리 복잡하게 설명하시뮤ㅠ</del>  예를 들어 <em>student-related event data</em> 에서 </p>

<blockquote>
  <p><strong>post mortem:</strong> Understanding where and why students drop out or deviate. Should the curriculum be redesigned? What are the bottlenecks?</p>
  
  <p><strong>pre mortem:</strong> What advice can we give a particular student that is likely do drop out? How to signal the lecturer that the exam is likely to be a <em>massacre</em> due to inactivity of students?</p>
</blockquote>

<p><br/></p>

<h4 id="dejurevsdefacto">De Jure vs De Facto</h4>

<p>큰 그림에서 밑 부분을 보면 모델에도 두 종류가 있다.</p>

<p><strong>de jure model</strong> 은 <em>normative</em> 즉 <strong>되어야 하는 것</strong> 을 설명하는 것이고, <strong>de facto model</strong> 은 <em>descriptive</em>, 즉 <strong>실제로 행해지는 것</strong> 을 설명한다.</p>

<h4 id="cartography">Cartography</h4>

<p><img src='http://image.slidesharecdn.com/processminingchapter09operationalsupport-110510153302-phpapp02/95/process-mining-chapter-9-operational-support-8-728.jpg?cb=1305062304'  alt="" /></p>

<p>이벤트 로그를 이용해서 모델을 발견하고, 개선하고, 진단하는 과정을 말한다</p>

<h4 id="auditing">Auditing</h4>

<p><img src='http://image.slidesharecdn.com/processminingchapter09operationalsupport-110510153302-phpapp02/95/process-mining-chapter-9-operational-support-9-728.jpg?cb=1305062304'  alt="" /></p>

<ul>
<li><strong>detect:</strong> <em>de jure model</em> 과 <em>pre mortem</em> 을 비교해 <em>violation</em> 이 없는지 확인한다.</li>
<li><strong>check:</strong> <em>detect</em> 에서 찾은 것을 수량화하고, 어떤 <em>deviation</em> 인가 확인한다.</li>
<li><strong>compare:</strong> <em>defacto model</em> 과 비교해서 실제에서 어떤 <em>deviation</em> 이 있는가 본다. </li>
<li><strong>promote:</strong> 위 정보를 토대로 모델을 개선한다.</li>
</ul>

<h4 id="navigation">Navigation</h4>

<p><img src='http://image.slidesharecdn.com/processminingchapter09operationalsupport-110510153302-phpapp02/95/process-mining-chapter-9-operational-support-10-728.jpg?cb=1305062304'  alt="" /></p>

<p>이 단계에서는 런타임에 <em>explore</em> 할 수도 있고, <em>prediction</em> 나 <em>recommendation</em> 도 가능하다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://issuu.com/wmpvanderaalst/docs/procminbook?e=14081202/9829483' >Book: Process Mining</a> <br />
(2) <a href='http://www.slideshare.net/wvdaalst/process-mining-chapter08miningadditionalperspectives' >Slide</a> <br />
(3) <strong>Process Mining: Data science in Action</strong> by Wil van der Aalst <br />
(4) <a href='http://1ambda.github.io/www.processmining.org' >www.processmining.org</a> <br />
(5) <a href='http://pais.hse.ru/en/' >http://pais.hse.ru/en/</a> <br />
(6) <a href='http://sourcesofinsight.com/yerkes-dodson-human-performance-curve/' >http://sourcesofinsight.com/</a></p>]]></description><link>http://1ambda.github.io/process-mining-week5/</link><guid isPermaLink="false">0e6897a3-6487-4810-9b0c-3c555faba7d7</guid><category><![CDATA[coursera]]></category><category><![CDATA[process mining]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 24 Dec 2014 03:41:31 GMT</pubDate></item><item><title><![CDATA[Reactive Programming 3, Futures, Promises]]></title><description><![CDATA[<p>이번시간엔 <em>Try</em>, <em>Future</em>, <em>Awaitable</em>, <em>Async</em>, <em>Promise</em> 에 대해 알아본다. <del>모나드가 삶을 윤택하게 하리라</del></p>

<h3 id="monadsandeffects">Monads and Effects</h3>

<p>프로그래밍에서 4가지 본질적 <em>effects</em> 는</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<p><em>asynchoronous computation</em> 을 살펴보기전에 <em>synchronous</em> 부터 살펴볼건데 간단한 어드벤쳐 게임으로 시작하자.</p>

<pre><code class="scala">trait Adventure {  
  def collectCoins(): List[Coin]
  def buyTreasure(coins: List[Coin]): Treasure
}

val adventu  
re = Adventrue()  
val coins = adventure.collectCoins()  
val treasure = adventure.buyTreasure(coins)  
</code></pre>

<p>여기서 <code>collecCoins, buyTreasure</code> 는 구현에 따라 실패할 수도 있다. 예를 들어</p>

<pre><code class="scala">def collectCoins(): List[Coin] = {  
  if (eatenByMonster(this)) throw new GameOverException("Ooops")
  List(Silver, Silver, Gold)
}
def buyTreasure(coins: List[Coin]): Treasure = {  
  if (coins.sumBy(_.value) &lt; treasureCost)
    throw new GameOverException("Nice try!")
  Diamond
}
</code></pre>

<p>그런데, 타입상으로는 <code>collectCoins, buyTreasure</code> 는 함수가 실패할 것이라는 어떠한 정보도 주지 않는다. <code>Try</code> 를 이용해 함수가 예외를 던질수도 있다는 것을 타입에 표시하자.</p>

<h4 id="try">Try</h4>

<p>아래는 <code>Try</code> 의 정의다.</p>

<pre><code class="scala">abstract class Try[T]  
case class Success[T](elem: T) extends Try[T]  
case class Failure[T](t: Throwable) extends Try[Nothing]  
</code></pre>

<p>이걸 게임 함수의 리턴값에 적용하면</p>

<pre><code class="scala">import scala.util.{Try, Success, Failure}

def collectCoins(): Try[List[Coin]] = {  
  if (eatenByMonster(this)) throw new GameOverException("Ooops")
  List(Silver, Silver, Gold)
}
def buyTreasure(coins: List[Coin]): Try[Treasure] = {  
  if (coins.sumBy(_.value) &lt; treasureCost)
    throw new GameOverException("Nice try!")
  Diamond
}

val adventure = Adventrue()  
val coins: Try[List[Coin]] = adventure.collectCoins()  
val treasure = coins match {  
  case Success(cs) =&gt; adventure.buyTreasure(cs)
  case failure @ Failure(t) =&gt; failure
}
</code></pre>

<p>좀 귀찮다. 많이 귀찮다. <em>higher order function</em> 의 은혜를 받아 삶을 좀 윤택하게 해 보자.</p>

<pre><code class="scala">def flatMap[S](f: T =&gt; Try[S]): Try[S]

def flatten[U &lt;: Try[T]]: TRy[U]

def map[S](f: T =&gt; S): Try[T]

def filter(p: T =&gt; Boolean): Try[T]

def recoverWith(f: PartialFunction[Throwable, Try[T]]): Try[T]  
</code></pre>

<p>여기서 <code>flatMap</code> 을 이용하면 코드가 상당히 이뻐질 것 같다.</p>

<p>사실 비밀을 하나 공개하자면, <code>Try[T]</code> 는 모나드다. 그 중에서 <em>exception</em> 을 다루는 모나드.</p>

<p><code>Try</code> 모나드를 이용하면 <em>exception</em> 부분(<code>Try[T]</code>)은 알아서 다루어 주고, 우리가 다뤄야 할 <code>T</code> 부분에 집중하게 해준다.</p>

<p><code>flatMap</code> 이 코드를 어떻게 바꾸는가 한번 보자.</p>

<pre><code class="scala">val treasure: Try[Treasure] =  
  adventure.collectCoins().flatMap(coins =&gt; {
    adventure.buyTreasure(coins)
  }
</code></pre>

<p>리턴타입은 <code>Try[Treasure]</code> 인데 <code>Try</code> 패턴매칭이 사라졌다? 그게 바로 <code>flatMap</code> 이 해주는 일이다. 타입을 다시 보자.</p>

<pre><code class="scala ">def flatMap[S](f: T =&gt; Try[S]): Try[S]  
</code></pre>

<p><code>T</code> 를 받아 <code>Try[S]</code> 를 돌려줄 함수만 넣어주면, 실제 <code>T</code> 를 이 함수에 넣기 위해 해야할 패턴매칭은 알아서 해준다.</p>

<p>그리고 지난 <a href='http://1ambda.github.io/reactive-programming-1/' >1강</a> 에서 모나드속에 있는 타입을 빼기 위해 <em>for expression</em> 을 이용했었다. 마찬가지로 <code>Try</code> 도 가능하다. <code>flatMap</code> 보다 더 이뻐진다.</p>

<pre><code class="scala">val treasure: Try[Treasure] = for {  
  coins &lt;- adventure.collectCoins()
  treasure &lt;- adventure.buyTreasure(coins)
} yield treasure
</code></pre>

<p>우측에서 <code>Try[T]</code> 를 리턴하고, <code>for</code> 가 알아서 <code>Try</code> 를 제거하고 좌측에 <code>T</code> 를 돌려준다.</p>

<p><code>Try</code> 를 다루기 위한 <em>higher order function</em> 이 내부적으로 어떻게 돌아가는지 한번 살펴보자.</p>

<pre><code class="scala">def map[S](f: T =&gt; S): Try[S] = this match {  
  case Succes(value) =&gt; Try(f(Value))
  case failure @ Failure(t) =&gt; failure
}

def flatMap[S](f: T =&gt; Try[S]): Try[S] = this match {  
  case Success(value) =&gt; try { f(value) } catch { cast t =&gt; Failure(t) }
  case failure @ Failure(t) =&gt; failure
}

object Try {  
  def apply[T](r: =&gt; T): Try[T] = {
    try { Success(r) }
    catch { case t =&gt; Failure(t) }
  }
}
</code></pre>

<p><code>flatMap</code> 내부에서 패턴매칭 및 예외 처리를 해준다. </p>

<h3 id="latencyasaneffect">Latency as an Effect</h3>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<p>지금까지 <code>T/Try[T]</code> 에 대해서 봤다. 이번엔 <em>asynchronous</em> 로 옮겨가 <code>Future[T]</code> 를 한번 볼건데, 간단한 네트워크 프로그램을 모델링 하면서 배워보자.</p>

<pre><code class="scala">trait Socket {  
  def readFromMemory(): Array[Byte]
  def sendToEurope(packet: Array[Byte]): Array[Byte]
}

val socket = Socket()  
val packet = socket.readFromMemory()  
val confirmation = socket.sendToEurope(package)  
</code></pre>

<p>이 코드도 이전의 어드벤쳐 게임처럼 실행중에 어떤일이 발생할지 모른다. 예외가 발생하지 않았을때만 정상적으로 실행된다. 게다가 <code>readFromMemory</code>, <code>sendToEurope</code> 동안 함수가 블럭되면 프로그램은 멈춰있다. (<em>heavy effect</em>)</p>

<p>이걸 해결하는게 <em>Future</em> 모나드다. 이 모나드는 <em>exception</em> 과 <em>latency</em> 를 다룬다. <code>Future[T]</code> 의 정의는</p>

<pre><code class="sala">import scala.concurrent._  
import scala.concurrent._ExecutionContext.Implicits.global

trait Future[T] {  
  def onComplete(callback: Try[T] =&gt; Unit)
     (implicit excutor: ExecutionContext): Unit
}
</code></pre>

<p><code>Try[T]</code> 를 받는 콜백을 인자로 필요로 하는 <code>onComplete</code> 메소드가 있다. 아랫 부분에 <code>ExecutionContext</code> 는 백그라운드에서 다른 스레드로 돌리기 위해 사용하고, <code>implicit</code> 는 이런 디테일을 숨기기 위함이다.</p>

<p><em>Future</em> 는 다른 버전으로 작성될 수도 있는데,</p>

<pre><code class="scala">trait Future[T] {  
  def onComplete(success: T =&gt; Unit, 
                 failed Throwale =&gt; Unit): Unit

  def onComplete(callback: Observer[T]): Unit
}

trait Observer[T] {  
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
}
</code></pre>

<p>이건 위 버전에서의 <em>callback</em> 을 좀 세분화 한것이다. 어차피 콜백이 <code>Try[T]</code> 를 받기 때문에 내부에서 <em>case</em> 로 분리해야 하는데, 미리 로직을 분리해서 각각의 경우에 대해 넘겨주는 것이다.</p>

<p>아니면 그 아래 <code>onComplete</code> 정의처럼 <code>Observer</code> 로 감싸서 줄 수 있다. 이것도 마찬가지로 성공했을때의, 실패했을때의 콜백이다.</p>

<p>이제 처음의 소켓 프로그램으로 돌아와서 <em>Future</em> 를 적용하면</p>

<pre><code class="scala">trait Future[T] {  
  def onComplete(callback: Try[T] =&gt; Unit)
     (implicit executor: ExecutionContext): Unit
}

trait Socket {  
  def readFromMemory(): Future[Array[Byte]]
  def sendToEurope(package: ArrayByte]): Future[Array[Byte]]
}
</code></pre>

<p>이제 <code>readFromMemory(), sendToEurope()</code> 의 함수 호출이 긴 시간이 걸릴수 있겠구나 하고 <code>Future</code> 가 리턴타입에 있음을 보고 알 수 있다.</p>

<p><em>future</em> 는 참 좋은건데, 이걸 사용하면 아까 실행 코드는</p>

<pre><code class="scala">// before
val socket = Socket()  
val packet = socket.readFromMemory()  
val confirmation = socket.sendToEurope(package)

// after
val socket = Socket()  
val packet: Future[Array[Byte]] = socket.readFromMemory()

// can't compile
val confirmation: Future[Array[Byte]] =  
  packet onComplete {
    case Success(p) =&gt; socket.sendToEurope(p)
    case Failure(t) =&gt; ...
  }
</code></pre>

<p>잘 보면 <code>onComplete</code> 의 리턴타입은 <code>Unit</code> 이기 때문에 <code>confirmation</code> 은 <code>Future[Array[Byte]]</code> 가 될 수 없다.</p>

<p>한 가지 방법은 <code>confirmation</code> 을 내부에 넣는건데,    그러면 나머지 밑 부분 코드도 모두 <code>Success</code> 내부에 작성해야 한다. <del>자바스크립트 콜백헬</del></p>

<pre><code class="scala">// can't compile
  packet onComplete {
    case Success(p) =&gt; 
      val confirmation = socket.sendToEurope(p)
      ...
      ...
      // callback hell
      ...
    case Failure(t) =&gt; ...
  }
</code></pre>

<p>이 문제를 해결하기 위해 <em>future</em> 를 만들 수 있다. <code>Future</code> 의 <em>companion object</em> 정의를 보면</p>

<pre><code class="scala">object Future {  
  def apply(body =&gt; T)
     (implicit context: ExecutionContext): Future[T]
}
</code></pre>

<p>예제를 보면</p>

<pre><code class="scala">import scala.concurrent.ExecutionContext.Implicit.global  
import akka.serializer._

val memory = Queue[EmailMessage](  
  EmailMessage(from = "Erik",   to = "Roland")
  EmailMessage(from = "Martin", to = "Erik")
  EmailMessage(from = "Roland", to = "Martin"))

def readFromMemory(): Future[Array[Byte]] = Future {  
  val email = queue.dequeue()
  val serializer = serialization.findSerializationFor(email)
  serializer.toBinary(email)
}

val packet: Future[Array[Byte]] = socket.readFromMemory()

packet onSuccess {  
  case bs =&gt; socket.sendToEurope(p)
}

packet onSuccess {  
  case bs =&gt; socket.sendToEurope(p)
}
</code></pre>

<p>이렇게 사용할 수 있다. 이 코드가 모두 실행되면, 이메일 큐에는 두개의 이메일이 남는다. <strong>하나가 아니다!!</strong> <code>Future</code> 는 <strong>미래에 돌려줄 결과</strong>를 가지고 있다고 보면 되는데, 하나의 결과에 대해 두개의 콜백을 호출해도 하나의 결과, 즉 이메일 하나만 뽑아먹었다는 사실은 변하지 않는다.</p>

<h3 id="combinatorsonfutures">Combinators on Futures</h3>

<p>이제 <em>future</em> 가 무슨일을 하는지 알았으면, 이걸 어떻게 모나드스럽게 사용할지 알아보자. 단골손님 <code>flatMap</code> 과 그 친구들이 등장한다.</p>

<pre><code class="scala">trait Awaitable[T] extends AnyRef {  
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}

trait Future[T] extends Awaitable[T] {  
  def filter(p: T =&gt; Boolean): Future[T]
  def flatMap[S](f: T =&gt; Future[S]): Future[S]
  def map[S](f: T =&gt; S): Future[S]
  def recoverWith(f: PartialFunction[Throwable, Future[T]]): Future[T]
}

objec Future {  
  def apply[T](body: =&gt; T): Future[T]
}
</code></pre>

<p><code>flatMap</code> 님을 이용해서 코드를 작성하자.</p>

<pre><code class="scala">val socket = Socket()  
val packet: Future[Array[Byte]] = socket.readFromMemor()  
val confirmation: Future[ArrayByte]] =  
  packet.flatMap(p =&gt; {
    socket.sendToEurope(p)
  }
</code></pre>

<p><code>flatMap</code> 의 정의를 보면 알겠지만, 함수 <code>f: T =&gt; Future[S]</code> 만 제공하면 앞의 <code>Future</code> 를 껍질을 벗겨, <code>T</code> 로 넣어준다. 근데 여기서 재밌는 사실은, <code>flatMap</code> 의 리턴 타입이 <code>Future[S]</code> 기 때문에 <code>confirmation</code> 도 같은 타입이 된다.</p>

<p>즉, <code>flatMap</code> 을 이용하면 모나드를 체이닝할 수 있다. 다른 예제도 좀 보자.</p>

<pre><code class="scala">import scala.concurrent.ExecutionContext.Implicits.global  
import scala.imaginary.Http._

object Http {  
  def apply(url: URL, req: Request): Future[Response] = 
  { .. runs the http request asynchronously }
}

// buggy
def sendToEurope(packet: Array[Byte]): Future[Array[Byte]] =  
  Http(URL("mail.server.eu"), Request(packet))
    .filter(response =&gt; response.isOK)
    .map(response =&gt; response.toByteArray)
</code></pre>

<p>마지막 부분의 코드를 다양하게 활용해 보자.</p>

<pre><code class="scala">def sendTo(url: URL, packet: Array[Byte]): Future[Array[Byte]] =  
  Http(URL("mail.server.eu"), Request(packet))
    .filter(response =&gt; response.isOK)
    .map(response =&gt; response.toByteArray)

def sendToAndBackup(packet: Array[Byte]):  
  Future[(Array[Byte], Array[Byte])] = {
    val europeConfirm = sendTo(mailServer.europe, packet)
    val usaConfirm    = sendTo(mailServer.usa, packet)
    europeConfirm.zip(usaConfirm)
  }
</code></pre>

<p>는 정상적인 코드가 아니다. 유럽이나 미국 둘중 하나라도 실패하면, 전체가 실패한다. 다행히도 스칼라 디자이너가 이런 문제를 해결하기 위한 함수들 <code>recover, recoverWith</code> 를 준비 해 놓았다.</p>

<pre><code class="scala">def recover(f: PartialFunction[Throwable, T]): Future[T]  
def recoverWIth(f: PartialFunction[Throwable, Future[T]): Future[T]  
</code></pre>

<p>타입을 잘보면 예외를 검사해서 다시 <code>Future[T]</code> 를 던지는 함수들이다. 특히 <code>recoverWith</code> 는 또 다른 비동기 연산을 할 수 있도록 <code>Future[T]</code> 를 지원한다.</p>

<p>위의 이메일 예제에 <code>recover, recoverWith</code> 를 적용해 보자.</p>

<pre><code class="scala">def sendTo(url: URL, packet: Array[Byte]): Future[Array[Byte]] =  
  Http(URL("mail.server.eu"), Request(packet))
    .filter(response =&gt; response.isOK)
    .map(response =&gt; response.toByteArray)

def sendToAndBackup(packet: Array[Byte]): Future[Array[Byte]] =  
  sendTo(mailServer.europe, packet) recoverWith {
    case europeError =&gt; sendTo(mailServer.usa, packet) recover {
      case usaError =&gt; usaError.getMessage.toByteArray      
    }
  }
</code></pre>

<p>근데 마지막 부분에서 <code>usaError.getMessage.toByteArray</code> 가 별로 맘에 안든다.  미국으로 보내는건 백업일 뿐이고, 실제로는 유럽에 보내고 싶었다. 그래서 실패한 메세지를 받더라도 유럽쪽 에러를 받고 싶다. 또 다른 문제는 코드가 좀 못생겼다. 이 두가지 문제를 해결해보자.</p>

<pre><code class="scala">def fallbackTo(that: =&gt; Future[T]): Future[T] = {  
  if this future fails take the successful result
  of that future
  if that future fails too, take the error of
  this future
}
</code></pre>

<p>이런 메소드가 있다면 다음처럼 작성할 수 있다.</p>

<pre><code class="scala">def sendSafe(packet: Array[Byte]): Future[Array[Byte]] =  
  sendTo(mailServer.europe, packet) fallbackTo {
    sendTo(mailServer.usa, packet)
  } recover {
    case europeError =&gt; europeError.getMessage.toByteArray
  }
</code></pre>

<p><code>fallbackTo</code> 의 구현은 </p>

<pre><code class="scala">def fallbackTo(that: =&gt; Future[T]): Future[T] = {  
  this recoverWith {
    case _ =&gt; that recoverWith { case _ =&gt; this }
  }
}
</code></pre>

<p><code>Try</code> 에 실패했을때 복구하는 <code>Try</code> 를 만들 수 있다.</p>

<pre><code class="scala">object Try {  
  def apply(f: Future[T]): Future[Try[T]] = 
    f.map(s =&gt; Success(s)) recover { case t =&gt; Failure(t) }
}
</code></pre>

<h4 id="awaitable">Awaitable</h4>

<pre><code class="scala">trait Awaitable[T] extends AnyRef {  
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}

trait Future[T] extends Awaitable[T] {  
  def filter(p: T =&gt; Boolean): Future[T]
  def flatMap[S](f: T =&gt; Future[S]): Future[S]
  def map[S](f: T =&gt; S): Future[S]
  def recoverWith(f: PartialFunction[Throwable, Future[T]]): Future[T]
}
</code></pre>

<p>때때로 <em>asynchronous</em> 보다는 <em>blocking</em> 을 원할 수 있다. 그럴때는 <code>Awaitable</code> 을 사용하면 된다. 지정된 시간동안 블럭 후에 <code>result</code> 함수는 모나드를 벗겨 <code>T</code> 를 돌려준다.</p>

<p>예를 들어</p>

<pre><code class="scala">val socket = Socket()  
val packet: Future[Array[Byte]] = socket.readFromMemory()  
val confirmation: Future[Array[Byte]] =  
  packet.flatMap(socket.sendToSafe(_))

val c = Await.result(confirmation, 2 seconds)  
println(c.toText)  
</code></pre>

<p>여기 잘 보면 <code>2 seconds</code> 라고 썼는데, 진짜 동작하는 코드다.</p>

<pre><code class="scala">import scala.language.postFixOps

object Duration {  
  def apply(length: Long, unit: TimeUnit): Duration
}

val fiveYears = 1826 minutes  
</code></pre>

<h3 id="composingfutures">Composing Futures</h3>

<pre><code class="scala">val socket = Socket()  
val packet: Future[Array[Byte]] =  
  socket.readFromMemory()

val confirmation: Future[Array[Byte]] =  
  packet.flatmap(socket.sendToSafe(_))
</code></pre>

<p>위에서 이런 코드를 작성했었다. 당연히 <em>for expression</em> 으로 변환할 수 있다.</p>

<pre><code class="scala">val socket = Socket()

val confirmation: Future[Array[Byte]] = for {  
  packet  &lt;- socket.readFromMemory()
  confirm &lt;- socket.sendToSafe(packet)
} yield confirm
</code></pre>

<p>여기에 더 많은 <em>control flow</em> 를 도입하려면 어떻게 해야할까? <code>flatMap</code> 만으로는 좀 부족해보인다. 예를 들어 정해진 횟수만큼 <em>retry</em> 를 하고싶다고 하자. 이런 함수를 만들어야 하는데,</p>

<pre><code class="scala">def retry(times: Int)(block: =&gt; Future[T]): Future[T]  
</code></pre>

<p>재귀로 구현하면</p>

<pre><code class="scala">def retry(times: Int)(block: =&gt; Future[T]): Future[T] = {  
  if (times == 0) Future.failed(new Exeception("Sorry")
  else 
    block fallbackTo { 
      retry(times - 1) { block }
    }
}
</code></pre>

<p>음... 못생겼다. 재귀긴 한데.. 에릭 마이어에 의하면 <em>recursion</em> 은 함수형 프로그래밍의 <strong>GOTO</strong> 라고 한다. 재귀 말고 <em>fold</em> 를 사용하자.</p>

<pre><code class="scala">def retry(times: Int)(block: =&gt; Futurep[T]): Future[T] = {  
  val ns: Iterator[Int] = (1 to times).iterator
  val attempts: Iterator[Future[T]] = ns.map(_ =&gt; () =&gt; block)
  val failed = Future.failed(new Exception)

  attempts.foldLeft(failed)
    ((a, block) =&gt; a recoverWith { block() })
}
</code></pre>

<p>즉, <em>future</em> 를 받아 <code>times</code> 만큼의 리스트를 만들어 놓고, <em>fold</em> 를 이용해 <code>recoverWith</code> 를 호출한다. </p>

<p>따라서 <code>retry(3) { block }</code> 코드는 이렇게 확장된다.</p>

<pre><code class="scala">((failed recoverWith block) recoverWith block) recoverWith block
</code></pre>

<p>만약 <em>foldRight</em> 를 이용하면</p>

<pre><code class="scala">def fallbackTo(that: =&gt; Future[T]): Future[T] = {  
  this recoverWith {
    case _ =&gt; that recoverWith { case _ =&gt; this }
  }
}

def retry(times: Int)(block: =&gt; Futurep[T]): Future[T] = {  
  val ns: Iterator[Int] = (1 to times).iterator
  val attempts: Iterator[Future[T]] = ns.map(_ =&gt; () =&gt; block)
  val failed = Future.failed(new Exception)

  attempts.foldRight(() =&gt; failed)
    ((block, a) =&gt; () =&gt; { block() fallbackTo { a() } })
}

retry(3) { block } ()

// ==
block fallbackTo { block fallbackTo { block fallbackTo { failed }}}  
</code></pre>

<p>잘보면 <code>foldRight</code> 부분에서 초기값이 <code>() =&gt; failed</code> 로 변했다. 이는 우리가 <code>fallbackTo</code> 를 이용하기 때문인데, <code>fallbackTo</code> 의 로직상 <code>this</code> 가 실패하면 <code>that</code> 을 시도하게끔 되어있다. <code>that</code> 이 성공하면 <code>that</code> 을 돌려준다.</p>

<p>우리는 이미 실패한 <code>block</code> 을 <code>a</code> 에 쌓아놨기 때문에, 이것을 그대로 돌려주려면 <code>() =&gt;</code> 로 감싸서 성공할 수 있도록 해야한다.</p>

<h3 id="async">Async</h3>

<p>타입에 <em>effect</em> 를 명시하는건 무슨일이 일어나는지 알려주니까 정말 좋긴 한데, 코드를 작성하기가 까다롭다. 좀 간단하게 할 수 있는 방법은 없을까?</p>

<pre><code class="scala">import scala.async.Async._

def async[T](body: =&gt; T)  
  (implicit context: ExecutionContext): Future[T]

def await[T](future: Future[T]): T  
</code></pre>

<p>여기서 <code>async</code> 는 <code>Future</code> 의 팩토리라 보면 된다. 위에서 본 코드와의 다른점은, 내부에 <code>await</code> 함수를 사용할 수 있다. 얼핏 보면 <code>await</code> 은 블럭킹을 위한 <code>Awaitable</code> 과 비슷하게 보이기도 한다. <code>Future</code> 를 받아 <code>T</code> 를 돌려주니까.</p>

<pre><code class="scala">trait Awaitable[T] extends AnyRef {  
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}

// usage
Await.result(confirmation, 2 seconds)  
</code></pre>

<p>그러나 놀랍게도 <code>await</code> 함수는 블럭되지 않는다. 코드를 보기전에 잠깐 설명서를 좀 보면</p>

<blockquote>
  <p><strong>Illegal Uses</strong></p>
  
  <ul>
  <li><p>await requires a directly-enclosing async; this means await must not be used inside a closure nested within in an async block, or insdie a nested object, trait, or class</p></li>
  <li><p>await must not be used inside an expression passed as an argument to a by name parameter</p></li>
  <li><p>await must not be used inside a Boolean short-circuit argument</p></li>
  <li><p>return expression are illegal inside an async block</p></li>
  <li><p>await should not be used under a <strong>try / catch</strong></p></li>
  </ul>
</blockquote>

<p><code>try / catch</code> 구문을 이용할 수 없으므로 <code>Try</code> 모나드를 써야한다. 이제 위에서 봤던 <code>retry</code> 함수를 <code>await</code> 을 이용해서 작성하면</p>

<pre><code class="scala">def retry(times: Int)(block =&gt; Future[T]): Future[T] = async {  
  val i = 0
  var result: Try[T] = Failure(new Exception("sorry man!"))

  while (i &lt; times &amp;&amp; result.isFailure) {
    result = await { Try(block) }
    i += 1
  }

  result.get
}
</code></pre>

<p>코드가 좀 더 이해하기 쉬워졌다. 그리고 내부에서는 <em>mutable state</em> 를 사용할지라도 외부로는 여전히 <em>purely functional</em> 이다.</p>

<p>내친김에 <code>filter</code> 도 구현해 보자.</p>

<pre><code class="scala">def async[T](body: =&gt; T)  
  (implicit context: ExecutionContext): Future[T]
def await[T](future: Future[T]): T

def filter(p: T =&gt; Boolean): Future[T] = async {  
  val x = await { this }

  if (!p(x)) throw new NoSuchElementException()
  else x
}
</code></pre>

<p>여기서 예외를 던지는 이유는 <em>empty future</em> 를 예외로 간주하기 때문이다. 앞서 코드에서도 그랬듯이.</p>

<p><code>flatMap</code> 은 어떨까?</p>

<pre><code class="scala">def async[T](body: =&gt; T)  
  (implicit context: ExecutionContext): Future[T]
def await[T](future: Future[T]): T

def flatMap[S](f: T =&gt; Future[S]): Future[S] =  
  async { await { f(await {this}) }}
</code></pre>

<h3 id="promise">Promise</h3>

<p><code>await</code> 없이 <code>filter</code> 를 만들려면 <code>Promise</code> 를 사용할 수 있다.</p>

<pre><code class="scala">def filter(pred: T =&gt; Boolean): Future[T] = {  
  val p = Promise[T]()

  this onComplete {
    case Failure(e) =&gt; p.failure(e)
    case Success(x) =&gt; 
      if (!pred(x)) p.failure(new NoSuchElementException)
      else p.success(x)
  }

  p.future
}
</code></pre>

<p><code>Promise</code> 의 정의를 보면</p>

<pre><code class="scala">trait Promise[T] {  
  def future: Future[T]
  def complete(result: Try[T]): Unit
  def tryComplete(result: Try[T]): Boolean
}

trait Future[T] {  
  def onCompleted(f: Try[T] =&gt; Unit): Unit
}
</code></pre>

<p><code>Promise</code> 는 <code>Future</code> 를 담고 있는데, <code>Future.onCompleted</code> 에 등록된 콜백 <code>f: Try[T] =&gt; Unit</code> 은, <code>Promise.complete</code> 에 의해 호출된다. </p>

<p><code>Promise.complete</code> 는 한번만 호출될 수 있다. 상식적으로 생각해봐도 그렇다. 따라서 <code>tryComplete</code> 를 만들어, 이미 완료되었으면 <code>false</code> 를 얻어 검사한다.</p>

<p>재미난 예제를 하나 더 보자.</p>

<pre><code class="scala">import scala.concurrent.ExecutionContext.Implicits.global

def race[T](left: Future[T], right: Future[T]): Future[T] = {  
  val p = Promise[T]()

  left  onComplete { p.tryComplete(_) }
  right onComplete { p.tryComplete(_) }

  p.future
}
</code></pre>

<p>두 <code>left, right</code> <em>computation</em> 중 먼저 끝나는 연산이 돌려주는 <code>Try[T]</code> 가 <code>p.future.onComplete</code> 의 콜백에 삽입된다. </p>

<p>어떤 리소스를 얻길 원하는데 로컬 캐싱값과 리모트 값 둘 중 먼저 얻어오는 것을 사용하려고 할 때 이런 코드를 작성할 수 있다. <em>HTML5</em> 에도 <em>worker</em>(?) 라고 이렇게 활용할 수 있는 기능이 있는걸로 안다.</p>

<p><code>Promise</code> 에는 몇 가지 함수들이 더 있다.</p>

<pre><code class="scala">trait Promise[T] {  
  def future: Future[T]
  def complete(result: Try[T]): Unit
  def tryComplete(result: Try[T]): Boolean

  // helper method
  def success(value: T): Unit = this.complete(Success(value))
  def failure(t: Throwable): Unit = this.complete(Failure(t))
}
</code></pre>

<p>이제 아까 <code>filter</code> 로 다시 돌아가자.</p>

<pre><code class="scala">// async version
def filter(p: T =&gt; Boolean): Future[T] = async {  
  val x = await { this }

  if (!p(x)) throw new NoSuchElementException()
  else x
}

// promise version
def filter(pred: T =&gt; Boolean): Future[T] = {  
  val p = Promise[T]()

  this onComplete {
    case Failure(e) =&gt; p.failure(e)
    case Success(x) =&gt; 
      if (!pred(x)) p.failure(new NoSuchElementException)
      else p.success(x)
  }

  p.future
}
</code></pre>

<p><code>zip</code> 도 <code>Promise</code> 와 <code>await</code> 이용해 작성해 보자.</p>

<pre><code class="scala">// promise version
def zip[S, R](that: Future[S], f: (T, S) =&gt; R): Future[R] = {  
  val p = Promise[R]()

  this onComplete {
    case Failure(e) =&gt; p.failure(e)
    case Success(x) =&gt; that onComplete {
      case Failure(e) =&gt; p.failure(e)
      case Success(y) =&gt; p.success(f(x, y))
    }
  }

  p.future
}

// async version
def zip[S, R](p: Future[S], f: (T, S) =&gt; R): Future[R] = async {  
  f(await { this }, await {that })
}
</code></pre>

<p><del>갓 async</del> </p>

<p>시퀀스도 <code>await</code> 을 이용해서 구현하면</p>

<pre><code class="scala">def sequence[T](fs: List[Future[T]]): Future[List[T]] = async {  
  var _fs = fs
  var r = ListBuffer[T]()
  while (_fs != Nil) {
    r += await { _fs.head }
    _fs = _fs.tail
  }

  r.result
}
</code></pre>

<p>즉 <code>Future[T]</code> 를 하나씩 <em>async</em> 하게 얻어, 리스트로 돌려준다. 만약 이걸 <code>Promise</code> 로 구현하면</p>

<pre><code class="scala">def sequence[T](fs: List[Future[T]]): Future[List[T]] = {  
  val successful = Promise[List[T]]()
  successful.success(Nil)

  fs.foldRight(successful.future) {
    (f, acc) =&gt; for {x &lt;- f; xs &lt;- acc} yield x :: xs
  }
}
</code></pre>

<p><code>Future[T]</code> 를 누적해서 리스트를 만들어야 하기 때문에 <code>Promise.complete(Nil)</code> 을 세팅해 이것의 <code>Promise.future</code> 를 <code>foldRight</code> 의 초기값으로 사용한다.</p>

<p>그리고 <em>for expression</em> 에서 <code>f: Future[T], acc: Future[List[T]]</code> 다. 따라서 <code>for</code> 구문에서 모나드가 벗겨져 <code>x: T, xs: List[T]</code> 이며 성공적으로 <code>x</code> 를 가져오면 컨싱한다.</p>

<p>지금까지 <code>Try</code> 와 <code>Future</code> 를 살펴봤다. 다음엔 하나의 값이 아니라 컬렉션을 <em>async</em> 하게 어떻게 처리하나 알아보자.</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<h3 id="references">References</h3>

<p>(1) <em>Reactive Programming</em> by <strong>Martin Ordersky</strong>  </p>]]></description><link>http://1ambda.github.io/reactive-programming-3/</link><guid isPermaLink="false">9519a124-ef47-4ab8-9521-c7641b60eb23</guid><category><![CDATA[coursera]]></category><category><![CDATA[reactive programming]]></category><category><![CDATA[ scala]]></category><category><![CDATA[futures]]></category><category><![CDATA[promises]]></category><category><![CDATA[awaitable]]></category><category><![CDATA[try]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 21 Dec 2014 11:09:38 GMT</pubDate></item><item><title><![CDATA[Reactive Programming 2, Stateful]]></title><description><![CDATA[<p>지금까지 우리가 작성한 프로그램은 <em>side-effect free</em> 였기 때문에, <strong>time</strong> 이 중요한 요소가 아니였다. 무슨말인고 하니, 모든 프로그램은 <em>sequence of actions</em> 에 대해 항상 같은 결과를 주게 되어있었다.</p>

<p>이건 <em>substitution model</em> 에 반영되어 있다. </p>

<h3 id="substitutionmodel">Substitution Model</h3>

<p><em>substitution model</em> 을 복습해 보면, 프로그램의 <em>evaluation</em> 은 <em>rewriting</em> 이다.</p>

<pre><code class="scala">def f(x1, ..., xn) = B; ... f(v1, ..., vn)  
</code></pre>

<p>은 다음처럼 평가된다. 여기서 <code>B</code> 는 펑션 바디. </p>

<pre><code class="scala">def f(x1, ..., xn) = B; ... f(v1/x1, ..., vn/xn) B  
</code></pre>

<p>예를 들어</p>

<pre><code class="scala">def interate(n: Int, f: Int =&gt; Int, x: Int) =  
  if (n == 0) x else iterate(n-1, f, f(x))

def square(x: int) = x * x  
</code></pre>

<p><code>iterate(1, square, 3)</code> 은 이렇게 평가된다.</p>

<pre><code class="scala">if (1 == 0) 3 else iterate(1-1, square, square(3))  
iterate(0, square, square(3))  
iterate(0, square, 3 * 3)  
iterate(0, square, 9)  
if (0 == 0) 9 else iterate(0-1, square, square(9))  
9  
</code></pre>

<p>그런데 여기서 재미난 부분이 있다. <em>rewriting</em> 은 어느 <em>term</em> 에서나 일어날 수 있고, 모든 <em>종료되는</em> <em>rewriting</em> 은 같은 결과를 만든다.</p>

<blockquote>
  <p>Rewriting can be done anywhere in a term, and all rewritings which terminated lead to the same solution</p>
</blockquote>

<p>그리고 이 개념이 람다 대수와, 함수형 프로그래밍의 기반이다. 아래의 두 식은 같은 식이다. </p>

<pre><code class="scala">if (1 == 0) 3 iterate(1 - 1, square, square(3))

// ==
iterate(0, square, square(3))

// ==
if (1 == 0) 3 else iterate(1 - 1, square, 3 * 3)  
</code></pre>

<p>어느 부분에 집중하냐에 따라 <em>term</em> 에서의 <em>rewriting</em> 이 달라질 수는 있으나, 결과는 같다. 이걸 <em>confluence (합류)</em> 라 부르기도 하고 <a href='http://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem' >Church-Rosser Theorem</a> 이라 부르기도 한다.</p>

<h3 id="statefulobject">Stateful Object</h3>

<p>지금까지는 <em>pure functional world</em> 의 이야기였다. 이제 좀 바깥 세상 이야기를 해보자. 상태가 변하고 하는것들.</p>

<p>일반적으로 <em>world</em> 를 <em>a set of objects</em> 로 정의할 수 있으며, 이 <em>object</em> 들은 시간이 지남에 따라 <em>change</em> 가 일어난다. </p>

<blockquote>
  <p>An object <strong>has a state</strong> if its behavior is influenced by its history</p>
</blockquote>

<p>예를 들어서 <em>은행 계좌</em> 는 <em>state</em> 를 가지고 있다. 왜냐하면 다음 질문의 답이</p>

<blockquote>
  <p><strong>"Can I withdraw 100 CHF?"</strong></p>
</blockquote>

<p>계좌의 이전 상태들이 어땠는지에 따라 달라지기 때문이다. (<em>may vary over the course of the lifetime of the account</em>)</p>

<p>모든 <em>mutable state</em> 는 <em>variable</em> 을 이용해 만들 수 있는데 스칼라에서는 <em>value definition</em> 인 <code>val</code> 대신에 <em>variable definition</em> 인 <code>var</code> 을 이용한다.</p>

<p>실제로는 <code>var</code> 보다는 다수의 <em>variable</em> 을 가진 <em>object</em> 를 이용해 오브젝트를 나타낸다. 아래는 은행 계좌 예제</p>

<pre><code class="scala">  class BankAccount {
    private var balance = 0

    def deposit(amount: Int): Unit = {
      if (amount &gt; 0) balance = balance + amount
    }

    def withdraw(amount: Int): Unit = {
      if (0 &lt; amount &amp;&amp; amount &lt;= balance) balance = balance - amount
      else throw new Error("insufficient")
    }
  }
</code></pre>

<p>여기서 <code>BankAcoount</code> 는 <code>deposit</code> 과 <code>withdraw</code> 가 어떻게 얼마나 호출되었는지(히스토리)에 따라 상태 <code>balance</code> 가 달라진다. </p>

<p>여기서 지난번에 배웠던 <code>Stream</code> 의 구현을 잠깐 보자. 이건 <em>stateful object</em> 일까?</p>

<pre><code class="scala">def const[T](hd: T, tl: =&gt; Stream[T]) = new Stream[T] {  
  def head = hd
  private var tlOpt = Option[Stream[T]] = None
  def tail: T = tlOpt match {
    case Some(x) =&gt; x
    case None =&gt; tlOpt = Some(tl); tail
  }
}
</code></pre>

<p>이건 시스템이 어떠한가 하는 <em>가정</em> 에 따라 참일수도, 아닐수도 있다.</p>

<p>(1) 만약에 <code>tl</code> 연산에서 <em>side-effct</em> 가 없다면 <code>tlOpt</code> 를 캐시하기 위한 최적화는 이 클래스 외부에 대해 어떤 영향도 없으므로 스트림은 <em>stateful object</em> 가 아니다.</p>

<p>(2) 반대로 <code>tl</code> 을 계산하는 과정에서 <em>print</em> 나 등등 <em>side-effect</em> 가 발생한다면 첫번째로 <code>tl</code> 을 호출하냐, 두번째로 호출하냐에 따라 <em>print</em> 가 발생할 수, 아닐수도 있으므로 <em>stateful object</em> 다.</p>

<p>그럼 이제 이런 은행계좌 클래스를 생각해 보자.</p>

<pre><code class="scala">class BankAccountProxy(ba: BankAccount) {  
  def deposit(amount: Int) = ba.deposit(amount)
  def withdraw(amount: Int) = ba.withdraw(amount)
}
</code></pre>

<p>사실 이 <code>BankAccountProxy</code> 클래스는 어느 <em>varaible</em> 도 가지고 있지 않지만, 이 클래스의 <em>behavior</em> 이 <code>ba</code> 의 <em>state</em> 를 결정하기 때문에 <em>stateful object</em> 다.</p>

<h3 id="identityandchange">Identity and Change</h3>

<p>이번엔 두 <em>state</em> 가 같은지를 판별하는 문제를 생각해 보자.</p>

<p><em>assignment</em> 는 두 <em>expression</em> 이 서로 같은지(<em>the same</em>)에 대한 질문을 던진다.</p>

<p>예를 들어 <code>val x = E; val y = E</code> 라 하자. 여기서 <code>E</code> 는 임의의 <em>expression</em>. 여기서 <em>assignment</em> 가 없다면 아래 식 처럼 바꿔 쓸 수 있다.</p>

<pre><code class="scala">val x = E; val y = x  
</code></pre>

<p><em>property</em> 를 <strong>referential transparency</strong> 라 부른다. 근데 만약 <em>assigment</em> 가 있으면, 두 <em>formulation</em> 은 다를 수 있다.</p>

<pre><code class="scala">val x = new BankAccount  
val y = new BankAccount  
</code></pre>

<h4 id="operationalequivalence">Operational Equivalence</h4>

<p>두 변수가 같은지를 판별하기 위해서, <em>같다</em> 라는 말을 좀 더 엄밀히 정의해 보자. </p>

<blockquote>
  <p>The precise meaning of <strong>"being the same"</strong> is defined by the property of <em>operational equivalence</em>*</p>
</blockquote>

<p><code>x, y</code> 두 개의 <em>definition</em> 을 가지고 있다고 하자. </p>

<blockquote>
  <p><code>x</code> and <code>y</code> are operationally equivalent if <strong>no possible test</strong> can disingquish between them</p>
</blockquote>

<p>그러므로 우리는 <code>x, y</code> 가 같은지 비교하기 위해 </p>

<blockquote>
  <p>Execute the definitions followed by an arbitrary sequence <code>f</code> of operations that involves <code>x</code> an <code>y</code>, observing the possible outcomes.</p>
</blockquote>

<pre><code class="scala">val x = new BankAccount  
val y = new BankAccount  
f(x, y)

// another execution
val x = new BankAccount  
val y = new BankAccount  
f(x, x)  
</code></pre>

<blockquote>
  <p>Then, execute the definitions with another sequence <code>S'</code> obtains by renaming all occurences of <code>y</code> by <code>x</code> in <code>S</code></p>
</blockquote>

<p>만약 이 실행 결과가 다르다면 <code>x, y</code> 는 다른것이고 그 반대로 모든 <code>(S, S')</code> 가 같은 결과를 돌려준다면 <code>x, y</code> 는 같다. 왜냐하면 더이상 구분할 수 없기 때문이다. 이게 바로 <em>operationally equivalence</em></p>

<p>이제 이 <em>operational equvalence</em> 를 이용해서 위에서 나온 질문을 해결해 보자. <em>counter example</em> 로,</p>

<pre><code class="scala">// sequence S
val x = new BankAccount  
val y = new BankAccount

x deposit 30  // 30  
y withdraw 20 // error: insufficient

// sequnece S'
val x = new BankAccount  
val y = new BankAccount

x deposit 30  // 30  
x withdraw 20 // 10  
</code></pre>

<p>따라서 <code>x, y</code> 는 서로 다르다. 반면 <code>val y = x</code> 로 정의한다면 어떤 <em>operation</em> 도 두 변수를 구분할 수 없기 때문에 똑같다.</p>

<h4 id="assignmentandsubstitutionmodel">Assignment and Substitution Model</h4>

<p>지금까지 논의한 바를 정리해 보면 <em>assignment</em> 가 도입됨에 따라 우리가 가진 <em>computation model</em> 이 적용 불가능해 졌다.</p>

<pre><code class="scala">val x = new BankAccount  
val y = x

// will be replaced to, but not correct
val x = new BankAccount  
val y = new BankAccount  
</code></pre>

<p>위 식은 아래 식처럼 치환되지만, 절대 같은 결과가 아니다. 다른 프로그램이 된다!</p>

<blockquote>
  <p><em>The substitution model</em> <strong>ceases</strong> to be valid when we add the <em>assignment</em></p>
</blockquote>

<p><em>store</em> 개념을 도입하면 <em>substituion model</em> 을 적용 가능하지만, 이건 프로그램을 상당히 복잡하게 만든다.</p>

<p><em>purely functional world</em> 에서 벗어나니 세상이 복잡해졌다. 어떻게 두 세계를 잘 버무릴수 있을까?</p>

<h3 id="loops">Loops</h3>

<p>사실 <em>loop</em> 는 <em>imperative programming</em> 에서 필수적인 요소는 아니다. <em>variable</em> 만으로 절차형 언어를 모델링하기에 충분하긴 한데, 어쨌든 있긴 하니까 함수형 언어에서도 모델링 할 수 있는 방법을 강구해보자. <em>function</em> 으로 할 수 있다. </p>

<pre><code class="scala">def power(x: Double. exp: Int): Double = {  
  var r = 1.0
  var i = exp

  while (i &gt; 0) { r = r * x; i = i - 1}
  r
}
</code></pre>

<p>스칼라에서 <code>while</code> 은 키워드니까, <code>WHILE</code> 을 이용해 루프를 모델링하는 함수를 만들어 보자.</p>

<pre><code class="scala">def WHILE(condition: =&gt; Boolean)(body: =&gt; Unit): Unit = {  
  if (condition) {
    body
    WHILE(condition)(body)
  } else ()
}
</code></pre>

<ul>
<li><em>re-evaluation</em> 을 피하기 위해서 (인자로넘길때) <code>condition, body</code> 는 <em>by name</em> 으로 넘겨야 한다. </li>
<li><code>WHILE</code> 은 <em>tail-recursive</em> 이므로 <em>constant stack-size</em> 를 가진다.</li>
</ul>

<p><em>repeat</em> 는 이런식으로</p>

<pre><code class="scala">def REPEAT(body: =&gt; Unit)(condition: =&gt; Boolean): Unit = {  
  body
  if (condition) ()
  else REPEAT(body)(condition)
}
</code></pre>

<p><em>until</em> 을 만들고 싶으면 내부 함수를 만들면 된다.</p>

<pre><code class="scala">// ref: https://gist.github.com/metasim/7503601
def REPEAT(body: =&gt; Unit) = new {  
  def UNTIL(condition: =&gt; Boolean): Unit = {
    body
    if (condition) ()
    else UNTIL(condition)
  }
}

// test code
REPEAT {  
  x = x + 1
} UNTIL (x &gt; 3)
</code></pre>

<h4 id="forloops">For-Loops</h4>

<p>자바의 <em>for-loop</em> 를 단순히 <em>higher-order function</em> 를 사용하는것 만으로는 모델링하기 어렵다. 왜냐하면 <code>i</code> 의 <em>declaration</em> 이 포함되어있기 때문이다.</p>

<pre><code class="java">for (int i = 1; i &lt; 3; i = i + 1) { System.out.print(i + " "); }  
</code></pre>

<p>스칼라에서도 비슷한 루프를 제공하긴 하는데, 위 루프보다는 <em>extended</em> 루프에 더 가깝다.</p>

<pre><code class="scala">for (i &lt;- 1 until 3) { System.out.print(i + " ") }  
</code></pre>

<p><em>for loop</em> 는 <em>foreach combinator</em> 로  번역 된다. 참고로 <em>for expression</em> 은 <code>map, flatMap</code> 으로 번역된다.</p>

<pre><code class="scala">def foreach(f: T =&gt; Unit): Unit =  
  // apply 'f' to each element of the collection

// example
for (i &lt;- 1 until 3; j &lt;- "abc") println(i + " " + j)

// translated to
(1 until 3).foreach(i =&gt; "abc" foreach (j =&gt; println(i + " " + j)))
</code></pre>

<h3 id="discreteeventsimulation">Discrete Event Simulation</h3>

<p>지금까지 <em>world</em> 를 모델링 할 수 있는 <em>state</em> 와, 여기에 적용할 수 있는 <em>control structure</em> 를 살펴봤는데, 이걸 이용해서 시뮬레이션을 해보자.</p>

<h4 id="digitalcircuit">Digital Circuit</h4>

<p><em>digital circuit</em> 은 <strong>wires</strong> 와 <strong>functional components</strong> 로 구성된다. </p>

<blockquote>
  <p>Wires transport signals thar are transformed by components</p>
</blockquote>

<p><em>signal</em> 을 <code>True, False</code> 로 표현하자. 그리고 기본 <em>components</em> 로</p>

<ul>
<li>Inverter</li>
<li>AND Gate</li>
<li>OR Gate</li>
</ul>

<p>그러면 다른 컴포넌트들은 이 조합으로 만들 수 있다. 그리고 각 컴포넌트는 <em>delay</em> 를 가질 수 있다.</p>

<pre><code class="scala">def inverter(input: Wire, output: Wire): Unit  
def andGate(a1: Wire, a2: Wire, output: Wire): Unit  
def orGate(o1: Wire, o2: Wire, output: Wire): Unit  
</code></pre>

<p>이제 <em>half adder, HA</em> 를 만들어 보면 </p>

<p><img src='http://i.msdn.microsoft.com/dynimg/IC141779.gif'  alt="" /></p>

<p align="center">(<a href='http://msdn.microsoft.com/' >http://msdn.microsoft.com</a>)</p>

<pre><code class="scala">def halfAdder(a: Wire, b: Wire, c: Wire, s: Wire): Unit = {  
  val d = new Wire
  val e = new Wire

  orGate(a, b, d)
  andGate(a, b, e)
  inverter(c, e)
  andGate(d, e, s)
}
</code></pre>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Full_Adder_Blocks.svg/2000px-Full_Adder_Blocks.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikibooks.org/' >http://en.wikibooks.org</a>)</p>

<p><img src='http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/ietron/fulladd.gif'  alt="" /></p>

<p align="center">(<a href='http://hyperphysics.phy-astr.gsu.edu/' >http://hyperphysics.phy-astr.gsu.edu</a>)</p>

<p>그러면 <em>full adder</em> 는</p>

<pre><code class="scala">def fullAdder(a: Wire, b: Wire, cin: Wire, sum: Wire, cout: Wire): Unit = {  
  val s = new Wire
  val c1 = new Wire
  val c2 = new Wire

  halfAdder(b, cin, s, c1)
  halfAdder(a, s, sum, c2)
  orGate(c1, c2, cout)
}
</code></pre>

<h4 id="action">Action</h4>

<p><em>discrete event simulator</em> 는 특정 <em>moment</em> 에서의 수행되는 <em>actions</em> 이다. 아무런 파라미터도 필요없는 <em>action</em> 은</p>

<pre><code class="scala">type Action = () =&gt; Unit  
</code></pre>

<p>어떤 <em>side-effect</em> 를 수행하면서 <em>time</em> 을 시뮬레이션 할 수 있다.</p>

<h4 id="simulator">Simulator</h4>

<pre><code class="scala">  trait Simulation {
    def currentTime: Int = ???
    def afterDelay(delay: Int)(block: =&gt; Unit): Unit = ???
    def run(): Unit = ???
  }
</code></pre>

<ul>
<li><code>currentTime</code> returns the current simulated time</li>
<li><code>afterDelay</code> registeres an action to perform after a certain delay</li>
<li><code>run</code> performs the simulation until there are no more actions wating</li>
</ul>

<p>이렇게 시뮬레이터 <em>trait</em> 를 만들고 상속 구조를 만들면</p>

<pre><code class="scala"> Simulation
     |
   Gates     // Wire, AND, OR, INV
     |
  Circuits   // HA, ADDER  
     |
MySimulation // implementation  
</code></pre>

<h4 id="wire">Wire</h4>

<pre><code class="scala">class Wire {  
  private var sigVal = false
  private var actions: List[Action] = List()

  def getSignal: Boolean = sigVal
  def setSignal(s: Boolean): Unit =
    if (s != sigVal) {
      sigVal = s
      actions foreach (_())
    }

 def addAcion(a: Action): Unit = {
    actions = a :: actions
    a()
  }
}
</code></pre>

<h4 id="inverterandorgates">Inverter, AND, OR Gates</h4>

<p><em>input wire</em> 로 부터의 입력을 뒤집어서 <em>output wire</em> 에다 돌려주는 <code>inverter</code> 를 구현할 수 있다. 근데 회로에서는 <em>delay</em> 가 있기 때문에 바로는 뒤집기 보다는 <code>InvertDelay</code> 이후에 신호를 반전시키는 <em>action</em> 을 구현하자. 아까 <code>Simulation</code> 내의 <code>afterDelay</code> 를 구현하면 된다.</p>

<pre><code class="scala">  def andGate(in1: Wire, in2: Wire, output: Wire): Unit = {
    def andAction(): Unit = {
      val in1Signal = in1.getSignal
      val in2Signal = in2.getSignal
      afterDelay(AddGateDelay) { output setSignal (in1Signal &amp; in2Signal) }
    }

    in1 addAction andAction
    in2 addAction andAction
  }

  def orGate(in1: Wire, in2: Wire, output: Wire): Unit = {
    def orAction(): Unit = {
      val in1Signal = in1.getSignal
      val in2Signal = in2.getSignal
      afterDelay(OrGateDelay) { output setSignal (in1Signal | in2Signal) }
    }

    in1 addAction orAction
    in2 addAction orAction
  }

  def inverter(input: Wire, output: Wire): Unit = {
    def invertAction(): Unit = {
      val inputSig = input.getSignal
      afterDelay(InverterDelay) { output setSignal (!inputSig) }
    }
    input addAction invertAction
  }
</code></pre>

<p><br/></p>

<p><del>혼란이 오기 시작했다</del></p>

<blockquote>
  <p>What happens if we compute <code>in1Sig</code> and <code>in2Sig</code> inline inside <code>afterDelay</code> instead of computing them as value?</p>
</blockquote>

<p>당연히 <em>delay</em> 후의 <em>signal</em> 값을 가지고 <em>action list</em> 에 추가하므로 제대로 모델링하지 못한다.</p>

<pre><code class="scala">afterDelay(OrGateDelay) {  
  output setSignal (in1.getSignal | in2.getSignal)
}
</code></pre>

<h3 id="thesimulationtrait">The Simulation Trait</h3>

<p>지금까지를 정리하면, <code>Wire</code> 클래스는 <em>statefule object</em> 를 나타낸다. 상태 <code>signal</code>, <code>actions</code> 는 <code>addAction, setSignal</code> 호출에 의해 정해진다. 이 함수들의 호출은 일종의 <em>event</em> 이며, <em>delay</em> 와 <em>action</em> 으로 구성된다.</p>

<p>그리고 이 모든 <code>Event</code> 는 <code>Simulation</code> <em>trait</em> 내 리스트로 저장된다. 일종의 할일 목록이나, <em>history</em> 로 보면 쉬울듯. </p>

<pre><code class="scala">type Action = () =&gt; Unit  
case class Event(time: Int, action: Action)  
private type Agenda = List[Event]  
private var agenda: Agenda = List()

private var curtime: Int = 0  
def currentTime: Int = curtime  
</code></pre>

<p>현재 시뮬레이션 타임을 기록하기 위해 <code>curtime</code> 정의하고, 이를 이용해 <code>Event</code> 를 정의할 수 있다. <code>Event(curtime + delay, () =&gt; block)</code> 처럼</p>

<pre><code class="scala">def afterDelay(delay: Int)(block: =&gt; Unit): Unit = {  
  val item = Event(currentTime + delay, () =&gt; block)
  agenda = insert(agenda, item)
}

private def insert(ag: List[Event], item: Event): List[Event] = ag match {  
  case first :: rest if first.time &lt;= item.time =&gt; first :: insert(rest, item)
  case _ =&gt; item :: ag
}
</code></pre>

<p>그리고 <code>agenda</code> 에 있는 액션들을 처리할 <code>loop</code> 와 시뮬레이션을 돌릴 <code>run</code> 함수를 구현하면</p>

<pre><code class="scala">private def loop(): Unit = agenda match {  
  case first :: rest =&gt;
    agenda = rest
    curtime = first.time
    first.action()
    loop()
  case _ =&gt;
}

def run(): Unit = {  
  afterDelay(0) {
    println("*** simulation started, time = " + currentTime + " ***")
  }

  loop()
}
</code></pre>

<p>그리고 시뮬레이션 자체는 아무런 <em>output</em> 도 주지 않기 때문에, 디버깅에 유용한 <code>probe</code> 함수를 추가하자. 디버깅용 <em>action</em> 을 추가한다 생각하면 쉽다. 일종의 <em>gate</em> 이기도 하다.</p>

<pre><code class="scala">def probe(name: String, wire: Wire): Unit = {  
  def probeAction(): Unit = {
    println(s"$name $currentTime value = ${wire.getSignal}")
  }

  wire addAction probeAction
}
</code></pre>

<p>이제 각 게이트마다의 딜레이를 위한 <em>trait</em> 를 만들자. 회로를 무엇으로 구성하냐에 따라 다를 수 있으므로 <em>trait</em> 으로 만드는건 좋은 선택이다.</p>

<pre><code class="scala">trait Parameters {  
  def InverterDelay = 2
  def AndGateDelay = 2
  def OrGateDelay = 2
}
</code></pre>

<h4 id="implementation">Implementation</h4>

<pre><code class="scala">
</code></pre>

<h4 id="test">Test</h4>

<pre><code class="scala">trait Simulation {  
  type Action = () =&gt; Unit
  case class Event(time: Int, action: Action)
  private type Agenda = List[Event]
  private var agenda: Agenda = List()

  private var curtime: Int = 0
  def currentTime: Int = curtime

  def afterDelay(delay: Int)(block: =&gt; Unit): Unit = {
    val item = Event(currentTime + delay, () =&gt; block)
    agenda = insert(agenda, item)
  }

  private def insert(ag: List[Event], item: Event): List[Event] = ag match {
    case first :: rest if first.time &lt;= item.time =&gt; first :: insert(rest, item)
    case _ =&gt; item :: ag
  }

  private def loop(): Unit = agenda match {
    case first :: rest =&gt;
      agenda = rest
      curtime = first.time
      first.action()
      loop()
    case _ =&gt;
  }

  def run(): Unit = {
    afterDelay(0) {
      println("*** simulation started, time = " + currentTime + " ***")
    }

    loop()
  }

}

abstract class Gates extends Simulation {

  def AndGateDelay: Int
  def OrGateDelay: Int
  def InverterGateDelay: Int

  class Wire {
    private var sigVal = false
    private var actions: List[Action] = List()

    def getSignal: Boolean = sigVal
    def setSignal(s: Boolean): Unit =
      if (s != sigVal) {
        sigVal = s
        actions foreach (_())
      }

    def addAction(a: Action): Unit = {
      actions = a :: actions
      a()
    }
  }

  def andGate(in1: Wire, in2: Wire, output: Wire): Unit = {
    def andAction(): Unit = {
      val in1Signal = in1.getSignal
      val in2Signal = in2.getSignal
      afterDelay(AndGateDelay) { output setSignal (in1Signal &amp; in2Signal) }
    }

    in1 addAction andAction
    in2 addAction andAction
  }

  def orGate(in1: Wire, in2: Wire, output: Wire): Unit = {
    def orAction(): Unit = {
      val in1Signal = in1.getSignal
      val in2Signal = in2.getSignal
      afterDelay(OrGateDelay) { output setSignal (in1Signal | in2Signal) }
    }

    in1 addAction orAction
    in2 addAction orAction
  }

  def inverter(input: Wire, output: Wire): Unit = {
    def invertAction(): Unit = {
      val inputSig = input.getSignal
      afterDelay(InverterGateDelay) { output setSignal (!inputSig) }
    }
    input addAction invertAction
  }

  def probe(name: String, wire: Wire): Unit = {
    def probeAction(): Unit = {
      println(s"$name $currentTime value = ${wire.getSignal}")
    }

    wire addAction probeAction
  }
}

abstract class Circuits extends Gates {

  // input a, b
  // output sum, carry
  def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire): Unit = {
    val d = new Wire
    val e = new Wire

    orGate(a, b, d)
    andGate(a, b, c)
    inverter(c, e)
    andGate(d, e, s)
  }

  def fullAdder(a: Wire, b: Wire, cin: Wire, sum: Wire, cout: Wire): Unit = {
    val s = new Wire
    val c1 = new Wire
    val c2 = new Wire

    halfAdder(b, cin, s, c1)
    halfAdder(a, s, sum, c2)
    orGate(c1, c2, cout)
  }
}

trait Parameters {  
  def InverterGateDelay = 2
  def AndGateDelay = 3
  def OrGateDelay = 5
}
</code></pre>

<p>테스트코드는</p>

<pre><code class="scala">object test extends Circuits with Parameters  
import test._  
val in1, in2, sum, carry = new Wire

halfAdder(in1, in2, sum, carry)  
probe("sum", sum)  
probe("carry", carry)

in1.setSignal(true)  
test.run()  
in2.setSignal(true)  
test.run()  
</code></pre>

<p>결과는</p>

<pre><code class="scala">sum 0 value = false  
carry 0 value = false  
*** simulation started, time = 0 ***
sum 8 value = true  
*** simulation started, time = 8 ***
carry 11 value = true  
sum 16 value = false  
</code></pre>

<p>흐름을 정리해 보면,</p>

<p>(1) <code>halfAdder</code> <br />
(2) <code>orGate, andGate, invertGate</code> <br />
(3) <code>addAction</code>
(4) <code>a()</code> -> <code>afterDelay</code> <br />
(5) <code>insert</code> 에서 시간을 고려해 이벤트리스트에 삽입 <br />
(6) <code>loop</code> 가 돌아가면서 모든 <code>action</code> 실행</p>

<h4 id="avariant">A Variant</h4>

<p><em>OR gate</em> 는 <em>AND, Invert</em> 로 구성될 수 있다. <code>a | b = ~(~a &amp; ~b)</code> 이기 때문인데</p>

<pre><code class="scala">def orGateAlt(in1: Wire, in2: Wire, output: Wire): Unit = {  
  def orAction(): Unit = {
    val notIn1, notIn2, notOut = new Wire
    inverter(in1,notIn1);
    inverter(in2,notIn2);
    andGate(notIn1, notIn2, notOut)
    inverter(notOut, output)
  }
}
</code></pre>

<p>만약에 이 <em>OR Gate</em> 를 사용하면 어떻게 될까? 시간은 당연히 달라지고, 추가적인 이벤트도 발생한다.</p>

<h3 id="summary">Summary</h3>

<ul>
<li><em>state</em> 와 <em>assignment</em> 는 모델을 더 복잡하게 만든다. </li>
<li><em>referential transparency</em> 도 포기해야 한다</li>
</ul>

<p>반면</p>

<ul>
<li><em>discrete event simulation</em> 같은 특정 형태의 프로그램을 우아하게 작성할 수 있다</li>
<li>시스템은 <em>mutable list of actions</em> 로 표현되고</li>
<li><em>action</em> 이 호출되면 그 효과로 인해 오브젝트의 상태가 변한다</li>
<li>미래에 호출될 <em>action</em> 을 <em>install</em> 할 수 있다.</li>
</ul>

<h3 id="references">References</h3>

<p>(1) <em>Reactive Programming</em> by <strong>Martin Ordersky</strong> <br />
(2) <a href='http://msdn.microsoft.com/en-us/library/aa288734' (v=vs.71).aspx">MSDN: Half Adder</a></p>]]></description><link>http://1ambda.github.io/reactive-programming-2/</link><guid isPermaLink="false">1f0f0056-8b79-426c-abcb-ce9071c541bb</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[reactive programming]]></category><category><![CDATA[referential transparency]]></category><category><![CDATA[operational equivalence]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 21 Dec 2014 01:57:05 GMT</pubDate></item><item><title><![CDATA[하스켈로 배우는 함수형 언어 9]]></title><description><![CDATA[<h3 id="intro">Intro</h3>

<p>이번시간엔 함수형 프로그래밍에서 <em>property</em> 를 증명하는 방법인 <em>induction</em> 에 대해 배워보고, 하스켈에서 알고리즘의 성능이 어떨까에 대해 좀 논의해 보겠습니다. 마지막엔 <em>Rose Tree</em> 를 구현하면서 <em>Functor, Monoid, Foldable</em> 등에 대해 좀 알아봅시다.</p>

<p>수학에서 다음 두 식은 똑같습니다.</p>

<pre><code>xz + yz = (x + y)z  
</code></pre>

<p>근데, 잘 보면 연산의 수가 다릅니다. 좌측은 3개고, 우측은 2개면 되지요. 하스켈에서도 이런 생각들을 좀 해봅시다. <em>built-in</em> 연산자에 대해서뿐만 아니라, <em>user-defined</em> 연산자 (함수) 에 대해서도 생각할 수 있으니까, 좀 다양하겠네요.</p>

<h3 id="reasoningabouthaskell">Reasoning about Haskell</h3>

<pre><code class="haskell">double :: Int -&gt; Int  
double x = x + x  
</code></pre>

<p>이제 모든 <code>x + x</code> 는 <code>double x</code> 로, 바꿀 수 있죠. 그 반대도 가능하고요. 근데, <em>multiple equations</em> 를 쓰면 좀 얘기가 다릅니다.</p>

<pre><code class="haskell">isZero :: Int -&gt; Bool  
isZero 0 = True  
isZero n = False  
</code></pre>

<p>첫번째 식 <code>isZero 0 = True</code> 는 어느 방향으로든 자유롭게 적용가능하지만, 두번째는 아닙니다. 사실은 이런 뜻이거든요</p>

<pre><code class="haskell">isZero 0          = True  
isZero n | n /= 0 = False  
</code></pre>

<p>이제 좌우를 쉽게 치환할 수 있습니다. 이렇게 식의 순서에 의존하지 않는 패턴을 <em>disjoint</em> 혹은 <em>non-overlapping</em> 이라 부릅니다.</p>

<blockquote>
  <p>Patterns that do not rely on the order in which the are matched are called <em>disjoint</em> or <em>non-overlapping</em></p>
</blockquote>

<p>프로그램에 대해서 <em>reasoning</em> 할 땐 가능하면 <em>non-overlapping</em> 패턴을 사용하는게 좋습니다. <em>standard library</em> 에 있는 대부분의 함수들은 이런식으로 작성 되어있습니다.</p>

<h3 id="simpleexamples">Simple examples</h3>

<pre><code class="haskell">reverse :: [a] -&gt; [a]  
reverse [] = []  
reverse (x:xs) reverse xs ++ [x]  
</code></pre>

<p>이 구현을 보면 <code>reverse [x] = [x]</code> 입니다. 근데, 이걸 연산하려면</p>

<pre><code class="haskell">reverse [x]  
reverse (x:[])  
reverse [] ++ [x]  
[] ++ [x]
[x]
</code></pre>

<p>따라서 <code>reverse [x] = [x]</code> 를 추가해서 효율적인 구현을 할 수 있습니다. </p>

<h3 id="inductiononnumbers">Induction on numbers</h3>

<p>함수형 프로그램은 종종 재귀를 이용해 작성되는데, 여기에 <em>induction</em> 을 이용할 수 있습니다. 예전에 본 자연수 타입 <code>Nat</code> 의 정의를 떠올려 보면</p>

<pre><code class="haskell">data Nat = Zero | Succ Nat  
</code></pre>

<p>어떤 유한한 수에 대해서 어떤 <em>property</em> <code>p</code> 를 증명하려고 할 때, 먼저 <em>base case</em> 인 <code>Zero</code> 에 대해 보이고, <em>inductive case</em> <code>Succ</code> 에 대해서 보이면 됩니다. 더 자세히는, 어떤 자연수 <code>n</code> 에 대해서 <code>p</code> 가 참일때 (<em>induction hypothesis</em>), <code>Succ n</code> 에 대해서도 참임을 보이면 됩니다.</p>

<p>구체적인 예제를 보도록 하죠. 두 <code>Nat</code> 를 더해 <code>Nat</code> 를 만드는 <code>add</code> 함수를 만들면</p>

<pre><code class="haskell">add :: Nat -&gt; Nat -&gt; Nat  
add Zero m = m  
add (Succ n) m = Succ (add n m)  
</code></pre>

<p>첫 번째씩 <code>add Zero m = m</code> 은 모든 자연수 <code>m</code> 에 대해 참이기 때문에, <code>add n Zero = n</code> 을 증명하겠습니다. 이걸 가설 <code>p</code> 라 부릅시다. </p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">add Zero Zero  
Zero  
</code></pre>

<p>(2) <em>inductive case</em></p>

<p>이 단계에서는 <code>p</code> 가 자연수 <code>n</code> 에 대해 참일때 <code>p (Succ n)</code> 이 참임을 보이면 됩니다. 다시 말해 가설 <code>p</code> <code>add n Zero = n</code> 을 이용해 <code>add (Succ n) Zero = Succ n</code> 임을 보여야 합니다.</p>

<pre><code class="haskell">add (Succ n) Zero -- should be `Succ n`

= Succ (add n Zero) 

= Succ n -- by induction hypothesis
</code></pre>

<p>다른 속성으로 <em>associativity</em> 를 증명할 수도 있습니다. </p>

<pre><code class="haskell">add x (add y z) = add (add x y) z  
</code></pre>

<p>인자가 3개인데 무엇부터 시작해야 할까요? <code>add</code> 는 패턴매칭을 이용해 작성되었고, 재귀 부분이  첫번째 인자를 주로 이용하므로 <code>x</code> 를 선택하는게 자연스러울 겁니다. <code>y</code>는 1 번 쓰이고, <code>z</code>는 첫번째 인자로 한번도 안쓰이네요. </p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">add Zero (y z) -- should be `add (add Zero y) z`

= add y z
= add (add Zero y) z -- unapplying add
</code></pre>

<p>(2) <em>inductive case</em></p>

<p><code>p</code> 는 `add x (add y z) = add (add x y) z</p>

<pre><code class="haskell">add (Succ x) (add y z) -- should be 'add (add (Succ x) y) z`

= Succ (add x (add y z)) -- apply outer add
= Succ (add (add x y) z) -- induction hypothesis
= add (Succ (add x y) z) -- unapply outer add
= add (add (Succ x) y) z -- unapply inner add
</code></pre>

<p>이렇게 <em>unapply, apply</em> 를 편하게 할 수 있는 이유는 위에서 <code>add</code> 를 <em>non-overlapping</em> 패턴으로 작성했기 때문이지요.</p>

<p><em>induction</em> 을 <em>recursive type</em> 인 <code>Nat</code> 에 적용했지만, <code>Integer</code> 타입에도 적용할 수 있습니다.</p>

<p>어떤 <em>property</em> <code>p</code> 를 <code>n &gt;= 0</code> 에 대해 증명하려고 할 때는 먼저 <em>base case</em> 인 <code>0</code> 에 대해 참임을 보이고, <code>n &gt;= 0</code> 일때, <code>n + 1</code> 에 대해서도 참임을 보이면 됩니다.</p>

<pre><code class="haskell">replicate :: Int -&gt; a -&gt; [a]  
replicate 0 _       = []  
replicate (n + 1) x = x : replicate n x  
-- replicate n x = x : replicate (n - 1) x
</code></pre>

<p>요즘 컴파일러는 <code>n + 1</code> 패턴을 막아서 아마 주석처리부분처럼 작성해야 합니다. 무튼 저 정의대로만 보면, <code>n</code> 에 대해 참일때 <code>n + 1</code> 일때도 참임을 보이는건 정말 쉽습니다. 정의 그 자체가 <em>induction</em> 이니까요.</p>

<h3 id="inductiononlists">Induction on lists</h3>

<p>재귀는 자연수에만 쓸 수 있는건 아니고, 리스트와 같은 다양한 재귀적인 타입에 사용할 수 있습니다. <em>base case</em> 는 <code>[]</code> 이 되겠고, <em>successor function</em> 은 <code>:</code> 이 되겠네요.</p>

<p>그러므로 리스트에 대해 어떤 <em>property</em> <code>p</code> 를 증명하려면, 먼저 <code>[]</code> 에 대해 참임을 보이고 <code>p xs</code> 가 참일때 <code>p x:xs</code> 가 참임을 보이면 됩니다. <del>참 쉽죠?</del></p>

<p><em>reverse</em> 연산에 대해 <code>reverse (reverse xs) = xs</code> 를 증명해 봅시다.</p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">reverse (reverse []) -- should be '[]'

= reverse []
= []
</code></pre>

<p>(2) <em>inductive case</em></p>

<pre><code class="haskell">-- induction hypothesis

reverse (reverse xs) = xs  
</code></pre>

<p>증명은</p>

<pre><code class="haskell">reverse (reverse x:xs) -- = x:xs

= reverse (reverse xs ++ [x])
= reverse [x] ++ reverse (reverse xs) -- by distributivity
= [x] ++ xs -- induction hypothesis
= x:xs
</code></pre>

<p>여기서 사용한 성질중에 하나가 <em>distributivity</em> 인데,</p>

<pre><code class="haskell">-- induction hypothesis
reverse (xs ++ ys) = reverse ys ++ reverse xs  
</code></pre>

<p>(1) <em>base-case</em> </p>

<pre><code class="haskell">reverse ([] ++ ys) -- reverse ys ++ reverse [] 

= reverse ys
= [] ++ reverse ys -- unapply ++
= reverse [] ++ reverse ys
</code></pre>

<p>(2) <em>inductive case</em></p>

<pre><code class="haskell">reverse ((x:xs) ++ ys) -- reverse ys ++ reverse (x:xs)

= reverse (x:(xs ++ ys))
= reverse (xs ++ ys) ++ [x]
= reverse ys ++ (reverse xs ++ [x])
= reverse ys ++ (reverse (x:xs)) -- unapply second reverse
</code></pre>

<p>이 증명은 <code>++</code> 가 <em>associative</em> 라는 사실을 이용해 증명했는데, 이것도 마찬가지로 증명할 수 있습니다.</p>

<h3 id="markingappendvanish">Marking append vanish</h3>

<p>많은 재귀 함수들이 <code>++</code> 연산을 이용해 작성되었는데, 편하긴 하지만 재귀적으로 사용되면 비용이 좀 듭니다. 따라서 이번에는 <code>++</code> 를 제거 해서 좀 더 효율적으로 함수를 작성해봅시다.</p>

<p><code>reverse</code> 함수부터 해 보면</p>

<pre><code class="haskell">reverse :: [a] -&gt; [a]  
reverse [] = []  
reverse (x:xs) = reverse xs ++ [x]  
</code></pre>

<p>이렇게 작성된 <code>reverse</code> 함수의 성능은 어떨까요? 먼저 생각해 볼 것은 <code>xs ++ ys</code> 을 <em>evaluation</em> 하기 위해 얼마의 스텝이 필요할까? 입니다. <code>xs ++ ys</code> 는 <code>xs</code> 를 쪼개가면서 <code>xs</code> 에 붙이기 때문에, <code>xs + 1</code> 만큼의 스텝이 필요하죠.</p>

<p>참고로 <code>append</code> 의 정의는</p>

<pre><code class="haskell">append :: [a] -&gt; [a] -&gt; [a]  
append [ ] xs    = xs  
append (x:xs) ys = x : append xs ys  
</code></pre>

<p>좀 간단히 생각하기 위해 <code>xs, ys</code> 가 <em>fully evaluated</em> 되었다 합시다. 그 결과로 <code>++</code> 는 첫 번째 인자 <code>xs</code> 의 길이에 비례하는 <em>linear time</em> 퍼포먼스를 보여줍니다.</p>

<p>결과적으로 <code>reverse xs</code> 의 성능은, 길이를 <code>n</code> 이라 했을 때 <code>1 + 2 + ... + n + 1</code> 입니다. <code>(n^2 + 3n + 2) / 2</code> 겠네요. 이는 <code>reverse</code> 함수가 <em>quadratic time</em> 의 함수라는걸 말해줍니다. 1000 개를 뒤집으려면, 10000000 번만큼 연산을 해야한다는 소리지요.</p>

<p>다행히도 <em>induction</em> 을 이용해 쓸모없는 <code>++</code> 부분을 제거하고, 성능을 개선할 수 있습니다.</p>

<p><code>reverse</code> 와 <code>++</code> 를 합친 좀 더 <em>general</em> 한 함수를 만듭시다. <code>reverse'</code> 라 부를건데, <code>reverse xs += ys</code> 와 같은 일을 할겁니다. </p>

<pre><code class="haskell">reverse' xs ys -- = reverse xs ++ ys  
</code></pre>

<p>이렇게 만들면 <code>reverse</code> 자체는 이렇게 정의할 수 있습니다. <code>[]</code> 가 <em>append</em> 를 위한 <em>identity</em> 라는 점을 이용한 것이지요.</p>

<pre><code class="haskell">reverse xs = reverse' xs []  
</code></pre>

<p>신기하게도 이 속성을 증명하면서, 이 <code>reverse'</code> 의 정의 자체를 얻을 수 있습니다. </p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">reverse' [] ys 

= reverse [] ++ ys 
= [] ++ ys
= ys
</code></pre>

<p>(2) <em>inductive case</em></p>

<pre><code class="haskell">reverse' (x:xs) ys

= reverse (x:xs) ++ ys
= (reverse xs ++ [x]) ++ ys
= reverse xs ++ ([x] ++ ys]) -- by associativity of ++
= reverse' xs ([x] ++ ys) -- by induction hypothesis
= reverse' xs (x:ys)
</code></pre>

<p>따라서 <code>reverse'</code> 의 정의는</p>

<pre><code class="haskell">reverse' [a] -&gt; [a] -&gt; [a]  
reverse' [] y = ys  
reverse' (x:xs) ys = reverse' xs (x:ys)  
</code></pre>

<p>아까 언급했던대로 <code>reverse</code> 를 다시 만들면</p>

<pre><code class="haskell">reverse :: [a] -&gt; [a]  
reverse xs = reverse' xs []  
</code></pre>

<p>이제는 <code>x:ys</code> 처럼, 하나씩 분리해 나가면서 붙기때문에 성능이더 빠릅니다. 정확히는 <code>n + 2</code>  연산이 필요하지요. <em>linear time</em> 입니다. </p>

<p>사실은 7장 에서 이미 개선된 <em>reverse</em> 를 봤었습니다. <code>reverse = foldl (:) []</code> 기억 나시나요?</p>

<h4 id="flatten">flatten</h4>

<pre><code class="haskell">data Tree = Leaf Int | Node Tree Tree  
flatten :: Tree -&gt; [Int]  
flatten (Leaf n) = [n]  
flatten (Node l r) = flatten l ++ flatten r  
</code></pre>

<p>이 <code>flatten</code> 도 <code>++</code> 때문에 느립니다. 위 <code>reverse</code> 처럼 개선해 보면</p>

<pre><code class="haskell">flatten' t ns = flatten t ++ [ns]  
</code></pre>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">flatten' (Leaf n) ns

= flatten (Leaf n) ++ ns
= [n] ++ ns
n:ns  
</code></pre>

<p>(2) <em>inductive case</em></p>

<pre><code class="haskell">flatten' (Node l r) ns

= (flatten l ++ flatten r) ++ ns
= flatten l ++ (flatten r ++ ns) -- associativity
= flatten' l ++ (faltten r ++ ns) -- hypothesis
= flatten' l (flatten' r ns)
</code></pre>

<p>따라서 <code>flatten'</code>, <code>flatten</code> 은</p>

<pre><code class="haskell">flatten' :: Tree -&gt; [Int] -&gt; [Int]  
flatten' (Leaf n) ns = n:ns  
flatten' (Node l r) ns = flatten' l (flatten' r ns)

flatten :: Tree -&gt; [Int]  
flatten t = flatten' t []  
</code></pre>

<h3 id="compilercorrectness">Compiler Correctness</h3>

<pre><code class="haskell">data Expr = Val Int | Add Expr Expr

eval :: Expr -&gt; Int  
eval (Val n) = n  
eval (Add x y) = eval x + eval y  
</code></pre>

<p>지난번에 만들었던 이 계산 기계를 잘 보면, <em>expression</em> 이 간접적으로 <em>evaluated</em> 됩니다. 스택을 이용해 실행되는 코드의 도움을 받아서요. </p>

<p>자세히 보면 스택은 <em>integer list</em> 고, 코드는 <em>push, add</em> 연산의 리스트입니다. 따라서</p>

<pre><code class="haskell">type Stack = [Int]  
type Code = [Op]  
data Op = PUSH Int | ADD  
</code></pre>

<p>결국 코드를 실행한다는 말은 초기 스택을 받아, 이걸 이용해 계산을 하고 다시 스택을 돌려준다는 뜻입니다.</p>

<pre><code class="haskell">exec :: Code -&gt; Stack -&gt; Stack  
exec []         s       = s  
exec (PUSH n:c) s       = exec c (n:s)  
exec (ADD:c)    (m:n:s) = exec c (m+n:s)  
</code></pre>

<p>이제 <code>Expr</code> 을 <code>Code</code> 로 변경하는 함수 <code>compile</code> 를 만들면</p>

<pre><code class="haskell">compile' :: Expr -&gt; Code  
compile' (Val n) = [PUSH n]  
compile' (Add x y) = compile x ++ compile y ++ [ADD]

compile :: Expr -&gt; Code  
compile e = compile' e  
</code></pre>

<p>그리고 화면에 출력을 위해 <code>Show</code> 를 구현하고 샘플식 <code>e</code> 를 만들면</p>

<pre><code class="haskell">instance Show Expr where  
  show (Val n) = "(Val " ++ show n ++ ")"
  show (Add x y) = "(Add " ++ show x ++ " " ++ show y ++ ")"

instance Show Op where  
  show (PUSH n) = "(PUSH " ++ show n ++ ")"
  show (ADD) = "(ADD)"

e :: Expr  
e = (Add (Add (Val 2) (Val 3)) (Val 4))  
</code></pre>

<pre><code class="haskell">&gt; e
-- (Add (Add (Val 2) (Val 3)) (Val 4))

&gt; eval e
-- 9

&gt; compile e
-- [(PUSH 2),(PUSH 3),(ADD),(PUSH 4),(ADD)]
</code></pre>

<p>잘 보면, 식을 컴파일해서 초기스택 <code>[]</code> 와 함께 실행시킨 것은, <code>[eval e]</code> 와 같다는 것을 알 수 있지요. <code>[]</code> 대신 임의의 스택 <code>s</code> 를 이용하면</p>

<pre><code class="haskell">exec (compile e) s = eval e:s  
</code></pre>

<p>(1) <em>base-case:</em> <code>(Val n)</code></p>

<pre><code class="haskell">exec (compile (Val n)) s

= exec [PUSH n] s
= n : s
eval (Val n) : s -- unapply eval  
</code></pre>

<p>(2) <em>inductive case:</em> <code>(Add x y)</code></p>

<pre><code class="haskell">exec (compile (Add x y)) s

= exec (compile x ++ compile y ++ [ADD]) s
= exec (compile x ++ (compile y ++ [ADD])) s -- associativity
= exec (compile y ++ [ADD]) (exec (compile x) s) -- distributivity of exec
= exec (compile y ++ [ADD]) (eval x:s) -- induction hypothesis for x
= exec [ADD] (exec (compile y) (eval x:s)) -- distributivity
= exec [ADD] (eval y : eval x : s)
= (eval x + eval y) : s -- apply exec
= eval (Add x y) : s -- unapply eval
</code></pre>

<p>위에서 쓴 <code>exec</code> 의 <em>distributivity</em> 를 보이면</p>

<pre><code class="haskell">exec (c ++ d) s = exec d (exec c s)  
</code></pre>

<p><code>c</code> 가 <code>PUSH</code> 일때, 그리고 <code>ADD</code> 일때로 나눠서 증명하면 되죠.</p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">exec ([] ++ d) s 

= exec d s
= exec d (exec [] s) -- unapply exec
</code></pre>

<p>(2-1) <em>inductive case:</em> <code>PUSH n</code></p>

<pre><code class="haskell">exec ((PUSH n : c) ++ d) s

= exec (PUSH n : (c ++ d)) s
= exec (c ++ d) (n:s)
= exec d (exec c (n:s)) -- induction hypothesis
= exec d (exec (PUSH n:c) s) -- unapply exec
</code></pre>

<p>(2-2) <em>inductive case:</em> <code>ADD</code></p>

<pre><code class="haskell">exec ((ADD : c) ++ d) s  
= exec (ADD : (c ++ d)) s
= exec (ADD : (c ++ d)) (m:n:s') -- assume s == m:n:s'
= exec (c ++ d) (m+n:s') -- apply exec
= exec d (exec c (m+n:s')) -- induction hypothesis
= exec d (exec (ADD : c) (m:n:s')) -- unapply exec
= exec d (exec (ADD : c) s)
</code></pre>

<p><code>s</code> 를 <code>m:n:s'</code> 로 의 가정은 <em>underflow error</em> 를 겪을 수 있는것처럼 보이지만, 실제로는 그렇지 않습니다. 왜냐하면 <code>ADD</code> 연산이 들어있다는 자체가 최소한 두개의 숫자는 스택에 포함한다는 뜻이기 때문입니다. (<code>exec</code> 의 정의를 보세요)</p>

<p>그리고 이전 장에서 <em>append</em> 연산에 적용했던 테크닉을 다시 가져와서, <em>distributivity property</em> 의 <em>underflow</em> 이슈를 예방할 수 있습니다. 이 속성을 유지하도록 하면요</p>

<pre><code class="haskell">compile' e c = compile e ++ c  
</code></pre>

<p>이 속성을 <em>induction</em> 을 이용해서 차근차근 풀면, 아래와 같은 정의를 얻을 수 있습니다.</p>

<pre><code class="haskell">compile' :: Expr -&gt; Code -&gt; Code  
compile' (Val n) c = PUSH n : c  
compile' (Add x y) = compile' x (compile' y (ADD : c))

compile e = compile' e []  
</code></pre>

<p>그러면 <em>compiler correctness</em> 는 </p>

<pre><code class="haskell">exec (compiler' e c) s = exec c (eval e : s)  
</code></pre>

<p>해석은 원문을 첨부하겠습니다.</p>

<blockquote>
  <p>That is, compiling an expression and then executing the resulting code together with arbitrary additional code gives the same result as executing the additional code with the value of the expression on top of the original stack</p>
  
  <p>Note that with <code>s = c = [ ]</code>, this new result simplifies to <code>exec (compile e) [] = [eval e]</code>, our original statement of correctness. </p>
  
  <p>In addition to avoiding the problem of stack underflow in the correctness proof, the accumulator version of the compiler has two further benefits. </p>
  
  <p>First of all, <strong>it avoids the use of ++,</strong> and is hence more efficient. And, </p>
  
  <p>secondly, <strong>the new proof is less than half the combined length of our previous two proofs.</strong> As is often the case in formal reasoning, generalising a result in the appropriate manner can considerably simplify its proof. Mathematics is an excellent tool for guiding the development of efficient programs with simple proofs!</p>
</blockquote>

<h3 id="rosetree">Rose Tree</h3>

<p>로즈 트리는 원소의 개수가 <em>unbounded</em> 인 트리입니다. 이렇게 정의할 수 있습니다.</p>

<pre><code class="haskell">data a = a :&gt; [Rose a] deriving Show  
</code></pre>

<p>여기서 <code>:&gt;</code> 는 <em>constructor</em> 입니다. 생성자가 <em>infix</em> 연산자로 올때는 <code>:</code> 로 시작해야 합니다. <code>deriving Show</code> 는 좀 디버깅 쉬우라고, 화면에 출력하기 위해 사용했습니다.</p>

<p>몇 가지 헬퍼 함수를 만들면,</p>

<pre><code class="haskell">root :: Rose a -&gt; a  
root (x :&gt; xs) = x

children :: Rose a -&gt; [Rose a]  
children (x :&gt; xs) = r

size :: Rose a -&gt; Int  
size (x :&gt; xs) = 1 + sum (map size xs)

leaves :: Rose a -&gt; Int  
leaves (_ :&gt; []) = 1  
leaves (_ :&gt; xs) = 1 + sum (map leaves xs)  
</code></pre>

<p>샘플 로즈 트리를 만들어 봅시다. </p>

<pre><code class="haskell">tree = 'x' :&gt; map (flip (:&gt;) []) ['a'..'z']

-- same as
tree = 'x' :&gt; map (\c -&gt; c :&gt; []) ['a'..'z'] 

&gt; tree
-- 'x' :&gt; ['a' :&gt; [],'b' :&gt; [],'c' :&gt; [],'d' :&gt; [],'e' :&gt; [],'f' :&gt; [],'g' :&gt; [],'h' :&gt; [],'i' :&gt; [],'j' :&gt; [],'k' :&gt; [],'l' :&gt; [],'m' :&gt; [],'n' :&gt; [],'o' :&gt; [],'p' :&gt; [],'q' :&gt; [],'r' :&gt; [],'s' :&gt; [],'t' :&gt; [],'u' :&gt; [],'v' :&gt; [],'w' :&gt; [],'x' :&gt; [],'y' :&gt; [],'z' :&gt; []]

&gt; size tree
-- 27

&gt; leaves tree
-- 26
</code></pre>

<h3 id="functor">Functor</h3>

<p>좀 삼삼하죠? 할게 별로 없으니. <em>rose tree</em> 를 <em>functor</em> 로 만들어 봅시다. 아래 짤방이 아마 세상에서 펑터를 가장 쉽게 설명할겁니다. <code>fmap (+3) (Just 2)</code> 에 대해</p>

<p><img src='http://adit.io/imgs/functors/fmap_just.png'  alt="" /></p>

<p align="center">(<a href='http://adit.io/' >http://adit.io</a>)</p>

<p>즉, <code>Just</code> 는 펑터이므로 <code>2</code> 를 꺼내 <code>+3</code> 을 적용하고, 다시 <code>Just</code> 를 씌워 <code>Just 5</code>로 만들어 줍니다. 그게 <code>fmap</code> 이 하는 일이고, 모든 <em>functor</em> 는 <code>fmap</code> 이 적용 가능합니다. <em>functor</em> 의 정의를 보면</p>

<pre><code class="haskell">class  Functor f  where  
    fmap        :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p>타입이 직관적이죠? <code>a -&gt; b</code> 함수를 받아, <code>f a</code> 에 함수를 적용해서 <code>f b</code> 를 만듭니다. <code>f</code> 는 컨테이너라고 보시면 됩니다. <code>Maybe</code> 같은 것들요 대표적인 <code>Functor</code> 로</p>

<pre><code class="haskell">instance  Functor Maybe  where  
    fmap f Nothing = Nothing
    fmap f (Just x) = Just (f x)


instance  Functor []  where  
    fmap = map 
</code></pre>

<p>그럼 우리가 만든 <code>Rose</code> 는 어떻게 해야 <code>Functor</code> 로 만들 수 있을까요?</p>

<pre><code class="haskell">instance Functor Rose  where  
    fmap g (x :&gt; xs) = g x :&gt; map (fmap g) xs  
</code></pre>

<p>직관적으로 보면 됩니다. 루트에 <code>g</code> 를 적용하고, <code>xs</code> 는 <code>[Rose]</code> 이므로 <code>x :&gt; xs</code> 와 똑같이 취급해서 <code>fmap g</code> 를 적용하면 됩니다. 이 때 지켜줘야 하는 <em>functor laws</em> 는</p>

<pre><code class="haskell">fmap id  ==  id  
fmap (f . g)  ==  fmap f . fmap g  
</code></pre>

<p>그럼 이제, 좀 재미난걸 할 수 있습니다. 이젠 <code>Rose</code> 가 <em>functor</em> 니까요. 다양한 함수를 적용할 수 있죠. </p>

<pre><code class="haskell">tree' = 1 :&gt; map (flip (:&gt;) []) [1..5]

&gt; tree'
-- 1 :&gt; [1 :&gt; [],2 :&gt; [],3 :&gt; [],4 :&gt; [],5 :&gt; []]

&gt; fmap (+1) tree'
-- 2 :&gt; [2 :&gt; [],3 :&gt; [],4 :&gt; [],5 :&gt; [],6 :&gt; []]

&gt; fmap (*10) tree'
-- 10 :&gt; [10 :&gt; [],20 :&gt; [],30 :&gt; [],40 :&gt; [],50 :&gt; []]

&gt; fmap (:&gt; []) tree'
-- (1 :&gt; []) :&gt; [(1 :&gt; []) :&gt; [],(2 :&gt; []) :&gt; [],(3 :&gt; []) :&gt; [],(4 :&gt; []) :&gt; [],(5 :&gt; []) :&gt; []]
</code></pre>

<h3 id="monoid">Monoid</h3>

<p><em>monoid</em> 는 <code>mempty</code>, <code>mappend</code> 두개의 함수를 가지고 있는 <code>m</code> 타입의 인스턴스입니다.</p>

<ul>
<li><code>mappend :: m -&gt; m -&gt; m</code> 은 <em>associative</em> 한 연산자로, 두 <code>m</code> 을 받아서, 하나의 <code>m</code> 으로 합칩니다. </li>
<li><code>mempty :: m</code> 은 <code>mappend</code> 의 <em>neutral element</em> 를 표현합니다. </li>
</ul>

<p>뭔소리야 하실텐데, 우리 주변의 많은 것들이 <em>monoid</em> 입니다. 예제를 봅시다.</p>

<pre><code class="haskell">&gt; (5 + 6) + 10 == 5 + (6 + 10)
True

&gt; (5 * 6) * 10 == 5 * (6 * 10)
True

&gt; ("Hello" ++ " ") ++ "world!" == "Hello" ++ (" " ++ "world!")
True  
</code></pre>

<p><code>[Char]</code> 에서 <code>mempty</code> 는 <code>[]</code> <code>mappend</code> 는 <code>++</code> 입니다. <code>Integer</code> 의 <code>mappend</code> 는 다양한데, <code>+</code> 라면 <code>mempty</code> 가 <code>0</code> 이고, <code>*</code> 라면 <code>mempty</code> 가 <code>1</code> 일 겁니다. 항등원 기억나시죠? 그거랑 비슷합니다.</p>

<pre><code class="haskell">class  Monoid a  where  
    mappend :: a -&gt; a -&gt; a
    mempty  :: m
    mconcat :: [a] -&gt; a
    mconcat :: foldr mappend mempty
</code></pre>

<p><code>mconcat</code> 은 <code>foldr (++) []</code> 를 생각하시면 이해가 쉽습니다. 네! 리스트도 모노이듭니다!</p>

<pre><code class="haskell">instance  Monoid [a]  where  
    mempty = []
    mappend = (++)
</code></pre>

<p>모노이드를 일종의 연산과 그에 대한 항등원이 구현된 클래스라 보셔도 됩니다. 그러면 <code>Sum</code>, <code>Product</code> 모노이드를 만들어 보죠. <code>Rose</code> 에 적용할 수 있을 것 같아요.</p>

<pre><code class="haskell">newtype Sum a = Sum { getSum :: a } deriving Show  
newtype Product a = Product a deriving Show

unProduct :: Product a -&gt; a  
unProduct (Product x) = x

instance Num a =&gt; Monoid (Sum a) where  
  mempty = Sum 0
  Sum x `mappend` Sum y = Sum (x + y)

instance Num a =&gt; Monoid (Product a) where  
  mempty = Product 1
  Product x `mappend` Product y = Product (x * y)
</code></pre>

<p>중간에 보면 <code>unProduct</code> 란게 있는데, 생성자에서 <code>getSum</code> 처럼 <em>accessor</em> 를 만들어 주면 필요 없고, 안만들어 주면 저렇게 만들어서 써야 합니다. 차이점을 보여드리기 위해 두 방법을 모두 사용 해봤어요. 근데, <em>accessor</em> 가 있으면 출력때 같이 나와서 좀 불편합니다.</p>

<pre><code class="haskell">-- 6 * (3 + 4)
&gt; unProduct (Product 6 `mappend` (Product . getSum $ Sum 3 `mappend` Sum 4))

-- 42
</code></pre>

<p>무튼, 이제 모노이드도 있겠다, <code>Rose</code> 에 적용할 수 있습니다. 이게 무슨 뜻이냐면, <code>Rose</code> 컨테이너가 가진 <em>value</em> 가 <code>Product</code>, <code>Sum</code> 연산이 가능하게끔 바꿀 수 있다는 뜻입니다.</p>

<pre><code class="haskell">&gt; tree'
-- 1 :&gt; [1 :&gt; [],2 :&gt; [],3 :&gt; [],4 :&gt; [],5 :&gt; []]

&gt; fmap Sum tree'
-- Sum 1 :&gt; [Sum 1 :&gt; [],Sum 2 :&gt; [],Sum 3 :&gt; [],Sum 4 :&gt; [],Sum 5 :&gt; []]

&gt; fmap Product tree'
-- Product 1 :&gt; [Product 1 :&gt; [],Product 2 :&gt; [],Product 3 :&gt; [],Product 4 :&gt; [],Product 5 :&gt; []]
</code></pre>

<h3 id="foldable">Foldable</h3>

<p><img src='https://www.haskell.org/wikiupload/thumb/3/39/FunctorHierarchy.svg/558px-FunctorHierarchy.svg.png'  alt="" /></p>

<p align="center">(<a href='https://www.haskell.org/' >https://www.haskell.org</a>)</p>

<p><em>foldable</em> 은 진짜 말 그대로 접을 수 있는 연산 <code>fold</code> 를 지원하는 인스턴스를 말합니다.</p>

<pre><code class="haskell">class Foldable t where  
    fold    :: Monoid m =&gt; t m -&gt; m
    foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m

    foldr   :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldr'  :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b

    foldl   :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldl'  :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b

    foldr1  :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a
    foldl1  :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a
</code></pre>

<p>여기선 <code>fold, foldMap</code> 만 다루도록 하죠. <code>fold</code> 의 타입을 보면 아시겠지만, <code>Monoid  m</code> 의 컨테이너인 <code>Foldable t</code> 를 접어서 단일 <code>m</code> 으로 만듭니다.</p>

<p>따라서 복수개의 <code>Sum, Product</code> 를 접어 하나로 만들수 있지요. 어차피 이 두 모노이드에 대해 연산 자체는 정해져 있기 때문에 접는법만 알려주면 됩니다. </p>

<p>그리고 더 중요한 사실은, <code>Rose</code> 가 <code>Foldable</code> 이 되면 <code>Sum</code> 등이 적용된 <code>Rose</code> 를 접어 계산할 수 있습니다. 다시 말해 컨테이너에, 연산을 추가하고, <code>fold</code> 할 수 있다는 이야기지요. </p>

<p>아참! <code>foldMap</code> 은 이름에서 볼 수 있듯이 <code>fmap</code> 후 <code>fold</code> 한다고 생각하면 쉽습니다. <code>fold . fmap</code> 처럼요.</p>

<pre><code class="haskell">class Functor f =&gt; Foldable f where  
  fold :: Monoid m    =&gt; f m -&gt; m
  foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; (f a -&gt; m)
  foldMap = fold $ fmap g a

instance Foldable Rose where  
  fold (x :&gt; xs) = (h.g) xs `mappend` x
    where g = map (fold)
          h = foldr (mappend) mempty
</code></pre>

<p>직관적으로 보면 쉽습니다. <code>h</code> 는 모노이드 <code>m</code> 을 펼치는 역할을 합니다. <code>g</code> 는 <code>f m</code> 을  재귀적으로 펼치구요. 이는 로즈 트리가, 복수개의 자식 노드를 가질 수 있기 때문에 그런건데, 어찌 되었든 펼치면서 노드를 끝에다 붙여 나갑니다. </p>

<p>먼저 로즈 트리를 펼친 후에 모노이드를 합칠거니까, 순서는 <code>(g.h)</code> 입니다.</p>

<p>이제 그러면, 로즈트리가 <em>functor</em> 이므로 모노이드로 감쌀 수 있고 (연산을 지정할 수 있고)    게다가 <em>foldable</em> 이므로 그 연산을 이용해 하나로 접을 수 있습니다. </p>

<pre><code class="haskell">&gt; tree'
-- 1 :&gt; [1 :&gt; [],2 :&gt; [],3 :&gt; [],4 :&gt; [],5 :&gt; []]

&gt; fmap Sum tree'
-- Sum 1 :&gt; [Sum 1 :&gt; [],Sum 2 :&gt; [],Sum 3 :&gt; [],Sum 4 :&gt; [],Sum 5 :&gt; []]

&gt; fold $ fmap Sum tree'
-- Sum 16

&gt; unSum $ fold $ fmap Sum tree'
-- 16
</code></pre>

<p><del>갓스켈</del></p>

<h3 id="references">References</h3>

<p>(1) <strong>DelftX FP 101x</strong> <br />
(2) <em>Programming in Haskell</em> <br />
(3) <a href='http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html' >Functor, Monad, Applicative</a> <br />
(4) <a href='http://en.wikibooks.org/wiki/Haskell/Monoids' >Haskell WikiBooks - Monoids</a> <br />
(5) <a href='https://www.haskell.org/haskellwiki/Foldable_and_Traversable' >Foldable, Traversable</a> <br />
(6) <a href='http://blog.jakubarnold.cz/2014/07/30/foldable-and-traversable.html' >foldable and traversable</a></p>]]></description><link>http://1ambda.github.io/haskell-intro9/</link><guid isPermaLink="false">129bd89e-f8b4-4154-8c14-4f5c61aa2a43</guid><category><![CDATA[edx]]></category><category><![CDATA[haskell]]></category><category><![CDATA[induction]]></category><category><![CDATA[functor]]></category><category><![CDATA[monoid]]></category><category><![CDATA[foldable]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 18 Dec 2014 08:24:13 GMT</pubDate></item><item><title><![CDATA[Substring Search Algorithm]]></title><description><![CDATA[<h3 id="introtosubstringsearch">Intro to Substring Search</h3>

<p><code>N</code> 길이의 텍스트에서 <code>M</code> 길이의 패턴을 찾는 문제다. 일반적으로 <code>N &gt;&gt; M</code> 이다. <code>N</code> 이 좀 많이 (무한히) 길기 때문에 지난시간까지 배운 알고리즘을 적용하기가 좀 힘들다.</p>

<p>(1) <em>suffix sort</em> 를 쓰려고 보니 <em>suffixes</em> 를 만드는 것 자체가 어렵다. 따라서 <em>manber-myers MSD</em> 도 패스.</p>

<p>(2) <em>R-way</em> 든 <em>Ternary</em> 든 <em>tries</em> 자체를 만들기 어렵다. 탐색해야 할 문서는 어마어마하기 때문에 메모리의 양이 모자랄 수 밖에 없다. </p>

<p>뭔가 문서를 <em>streaming</em> 취급하면서 처리할 수 있는 알고리즘이 필요하다.</p>

<p>주된 <em>application</em> 은</p>

<ul>
<li><strong>computer forensics:</strong> search memory, disk for signatures</li>
<li><code>CTRL + F</code></li>
<li><strong>spam filtering:</strong> 특정 패턴이 발견되면 스팸이라 볼 수 있다.</li>
<li><strong>internet traffic monitoring:</strong> 보안</li>
<li><strong>screen scraping:</strong> 관련있는 패턴을 추출할 수 있다.</li>
</ul>

<p>자바에서는 <code>indexOf</code> 메소드가 문자열에서 해당 패턴을 발견해 시작 인덱스를 돌려준다.</p>

<h3 id="bruteforce">Brute Force</h3>

<p><del>언젠가 양자 컴퓨터가 나오면 쓸모 있을까</del></p>

<pre><code class="java">public static int bruteForce(String pattern, String docs) {  
    int M = pattern.length();
    int N = docs.length();

    for (int i = 0; i &lt; N - M; i ++) {
        int j;

        for (j = 0; j &lt; M; j++) 
            if (pattern.charAt(j) != docs.charAt(i + j)) break;

        if (j == M) return i;
    }

    return N;
}
</code></pre>

<p>성능은 <em>worst case</em> 에서 <code>~M N</code> 번의 <em>char compares</em> 가 필요하다. 예를 들어 문서가 <code>AAAAAAAAAAAB</code> 고 패턴이 <code>AAAAAB</code> 면 최악이다.</p>

<h4 id="backup">Backup</h4>

<p>대부분의 <em>application</em> 에서 <em>backup</em> 하길 원치 않는다. 서론에 언급했듯이 스트림처럼 취급하고싶은데, <em>brute force</em> 에서는 <em>backup</em> 이 필요하기 때문에 <em>last <code>M</code> characters</em> 의 버퍼를 유지한다거나의 방법을 쓸 수 있다.</p>

<p>아래의 구현은 똑같은 비교 회수를 가지는데, <em>backup</em> 한다는걸 확실히 보여준다.</p>

<ul>
<li><code>i</code> points to end of sequence of already-matched chars in docs</li>
<li><code>j</code> stores # of already-matched chars (end of sequence in pattern)</li>
</ul>

<pre><code class="java">public static int bruteForceBackup(String pattern, String docs) {  
    int i, N = docs.length();
    int j, M = pattern.length();

    for (i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++) 
        if (docs.charAt(i + j) == pattern.charAt(j)) j++;
        else { i -= j; j = 0; }

    if (j == M) return i - M;
    else return N;
}
</code></pre>

<p>이게 <code>M</code> 이 작으면 문제가 안되는데, <code>M</code> 이 크면 문제가 될 수 있다.</p>

<p>우리가 풀어야 할 문제는</p>

<p>(1) <em>linear-tme guarantee</em> 가 필요 <br />
(2) <em>backup</em> 하지 않기</p>

<h3 id="knuthmorrispratt">Knuth-Morris-Pratt</h3>

<p>아이디어는 간단하다. 매칭에 실패했을 경우, 현재까지 처리한 문자들에 대한 <em>정보</em> 를 가지고 있기 때문에, 이걸 이용해서 필요 없는 부분을 건너 뛴다.</p>

<pre><code>// pattern: BAAAAAAAAA

A B A A A A B A A A A A A A A A  
  B A A A A ^ // fail
            B // ignore previous chars
</code></pre>

<h4 id="dfa">DFA</h4>

<p><em>Knuth-Morris-Pratt</em> 알고리즘은 <em>deterministic finite state automation, DFA</em> 란 것에 이론적으로 기반한다.</p>

<p><em>DFA</em> 는 <em>abstract string-searching machine</em> 이다.</p>

<ul>
<li>Finite number of states (including start and halt)</li>
<li><strong>Exactly one transition</strong> for each char in alphabet</li>
<li>Accept if sequence of transitions leads to half state</li>
</ul>

<p><img src='http://www-igm.univ-mlv.fr/' ~lecroq/string/images/rwadfa2.png" alt="" /></p>

<p align="center">(<a href='http://www-igm.univ-mlv.fr/' >http://www-igm.univ-mlv.fr</a>)</p>

<p>더 크게 보면 <em>DFA</em> 는 <em>Finite State Machine, FSM</em> 의 한 종류다. <em>DFA</em> 말고도 <em>Nondeterministic Finite Automata, NFA</em> 가 있는데,  차이점은 이렇다.</p>

<blockquote>
  <p>비결정적 유한 오토마타는 결정적 유한 오토마타와는 다르게 입력 기호에 대해서 <code>\epsilon</code>-transition 에 의해 0개 이상의 이동이 가능하다. 만약 가능한 다음 상태의 경우가 없다면, 기계는 입력을 거부한다.</p>
</blockquote>

<p>결정적 유한 오토마타는 입력값에 대해 출력 값이 1개라는 소리 같은데, 좀 모호해서 더 찾아봤다. <a href='http://math.stackexchange.com/questions/563829/difference-between-nfa-and-dfa' >여기</a> 에 의하면</p>

<blockquote>
  <p>Each input to a <strong>DFA</strong> or <strong>NFA</strong> affects the state of the automaton: if it was in state q immediately before the input, either it will be in some state q′ after the input, or the input will cause it to choke. (Note that q′ may be the same as q.) Suppose that we have an automaton in a state q. The difference in behavior between a DFA and an NFA is this:</p>
  
  <ul>
  <li><p>If it’s a <strong>DFA</strong>, each possible input determines the resulting state q′ uniquely. Every input causes a state change, and the new state is completely determined by the input. Moreover, the automaton can change state only after reading an input.</p></li>
  <li><p>If it’s an <strong>NFA</strong>, some inputs may allow a choice of resulting states, and some may cause the automaton to choke, because there is no new state corresponding to that input. Moreover, the automaton may be constructed so that it can change state to some new state q′ without reading any input at all.</p></li>
  </ul>
  
  <p>As a consequence of this difference in behavior, DFA’s and NFA’s differ in another very important respect.</p>
  
  <ul>
  <li><p>If you start a <strong>DFA</strong> in its initial state and input some word w, the state q in which the DFA ends up is completely determined by w: inputting w to the DFA will always cause it to end up in state q. This is what is meant by calling it deterministic.</p></li>
  <li><p>If you start an <strong>NFA</strong> in its initial state and input some word w, there may be several possible states in which it can end up, since some of the inputs along the way may have allowed a choice of state changes. Consequently, you can’t predict from w alone in exactly which state the automaton will finish; this is what is meant by calling it nondeterministic. (And it’s actually a little worse than I’ve indicated, since an NFA is also allowed to have more than one initial state.)</p></li>
  </ul>
  
  <p>Finally, these differences affect how we determine what words are accepted (or recognized) by an automaton.</p>
  
  <ul>
  <li><p>If it’s a <strong>DFA</strong>, we know that each word completely determines the final state of the automaton, and we say that the word is accepted if that state is an acceptor state.</p></li>
  <li><p>If it’s an <strong>NFA</strong>, there might be several possible final states that could result from reading a given word; as long as at least one of them is an acceptor state, we say that the automaton accepts the word.</p></li>
  </ul>
</blockquote>

<p><del>갓 아메리카</del></p>

<p>똑같은 입력에 대해 <em>NFA</em> 는 다양한 최종상태를 만들 수 있다고 한다. 그래서 그 중 하나라도 <em>accept</em> 되면, 처리 된 것으로 받아들인다고 함. 어디서 주워들은 <em>NP hardness</em> 와 비스무리한 개념인것 같다. 그림을 다시 보면</p>

<p><img src='http://www-igm.univ-mlv.fr/' ~lecroq/string/images/rwadfa2.png" alt="" /></p>

<p align="center">(<a href='http://www-igm.univ-mlv.fr/' >http://www-igm.univ-mlv.fr</a>)</p>

<p>검색하려는 패턴, 즉 <em>desired state</em> 나열하고 <em>transition</em> 를 그려가며 <em>DFA</em> 를 만든다. 이를 이용해 텍스트를 파싱하면서 <em>final state</em> 에 도달하는지 보면 된다.    </p>

<p>구현은 </p>

<pre><code class="java">public int kmpStringSearch(String docs, String pattern) {  
  int i, j;
  int N = docs.length(), M = pattern.length();
  Int[][] dfa = createDFA(pattern);

  for (i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++) {
    j = dfa[txt.charAt(i)][j];
  }

  if (j == M) return i - M 
  else N
}
</code></pre>

<p>재밌는 사실은 <em>backup</em> 이 더이상 필요 없기 때문에 입력을 <em>stream</em> 으로 받을 수도 있다.</p>

<pre><code>public int kmpStringSearch(In in, String pattern) {  
  int i, j;
  int M = pattern.length();
  Int[][] dfa = createDFA(pattern);

  for (i = 0, j = 0; !in.isEmpty() &amp;&amp; j &lt; M; i++) {
    j = dfa[in.readChar()][j];
  }

  if (j == M) return i - M 
  else N
}
</code></pre>

<p>따라서 <em>running time</em> 은 <em>DFA</em> 만 있다면 확실히 <code>N</code> 번의 <em>char access</em> 다. 그럼 이제 문제는, <em>DFA</em> 를 만드는데 얼마나 시간이 걸릴것 인가? </p>

<p><em>DFA</em> 를 만들면서 알아보자. <code>ABABAC</code> 의 패턴이 있을때</p>

<p>(1) <em>match transition</em></p>

<p>현재 상태가 <code>j</code> 이고 다음 문자인 <code>c</code> 가 <code>c == pattern.charAt(j)</code> 이면 <em>match transition</em> 이므로 <code>j++</code> 이다.</p>

<p>따라서 패턴 <code>ABABAC</code> 의 <em>DFA</em> 는</p>

<pre><code>               j     0 1 2 3 4 5 
pattern.charAt(j)    A B A B A C

dfa[][j]          A  1   3   5  
                  B    2   4  
                  C            6                  
</code></pre>

<p>(2) <em>mismatch transition</em></p>

<p>상태 <code>j</code> 에서 <code>c != pattern.chatAt(j)</code> 이면, <em>mismatch</em> 다. 그러면  방금 전까지 만든 <code>j-1</code> 까지의 <em>DFA</em> 를 이용해서 <code>pattern[1 .. j-1]</code> 까지를 인풋으로 넣어 돌리면 된다. 무슨말인고 하니</p>

<p><code>ABABAC</code> 에서 현재 <em>state</em> 가 <code>5</code> 면, 다음 인풋으로 <code>C</code> 를 받아야한다. <code>ABABA^C</code> 이렇게 표기하자. 그러면, <code>ABABA</code> 까지의 <em>DFA</em> 를 만들었으므로, 첫 문자 <code>A</code> 를 버리고 다음 문자 <code>C</code> 를 포함해서 <code>BABAC</code> 를 인풋으로 해서 <em>DFA</em> 를 돌리면 된다.</p>

<p>예를 들어 <code>j = 5</code>, <code>c = A, B</code> 에 대해 <code>j = 4</code> 까지의 <em>DFA</em> 를 짓고</p>

<pre><code>               j     0 1 2 3 4 5 
pattern.charAt(j)    A B A B A C

dfa[][j]          A  1 1 3 1 5  
                  B  0 2 0 4 0
                  C  0 0 0 0 0 6                  
</code></pre>

<p>에 대해서 <code>BABA</code> 를 반복하면, <code>j = 3</code> 이다. 따라서</p>

<ul>
<li><code>dfa['A'][5] = dfa['A'][3] = 1</code></li>
<li><code>dfa['B'][5] = dfa['B'][3] = 4</code></li>
</ul>

<p>이게 잘 보면 매번 <code>j - 1</code> 의 스텝을 반복해야하는 걸로 보일 수 있는데, 그러지 말고 <code>pattern[1 .. j-1]</code> 을 <em>state</em> <code>X</code> 라 부르고, 이걸 유지하면 <em>transition</em> 을 <em>constant time</em> 으로 지을 수 있다. 즉 <code>j</code> 가 하나 증가할 때 마다 </p>

<p><code>X = dfa[pattern.charAt(j)][X]</code></p>

<p>이렇게 <code>X</code> 를 업데이트하면, <code>j - 1</code> 까지의 상태가 <code>X</code> 다. 따라서 <em>DFA</em> 를 <em>linear time</em> 으로 만들 수 있다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTT3lJR08zSUdOalZUTm1WV0x6UVRPaDFDTmhkek10RXpZeFFXTGpWR1p3a1RZekkyTDRnek0wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<h4 id="performance">Performance</h4>

<p><em>DFA</em> 를 만드는 속도는 <code>M</code> <em>char access</em> 이므로 전체 문서를 검색하는데 걸리는 시간은 <code>M + N</code> <em>char access</em> 다. (<code>M</code> 은 패턴의 길이, <code>N</code> 은 문서의 길이)</p>

<p>그러나 <em>DFA</em> 를 만드는데 필요한 메모리가 <code>R * M</code> 이다.</p>

<p><em>NFA</em> 를 이용하면 <em>KMP</em> 알고리즘을 더 개선할 수 있다. <code>M</code> 에 비례하는 시간, 공간만으로도 패턴을 문서에서 탐색할 수 있다고 한다. <a href='http://algs4.cs.princeton.edu/53substring/KMPplus.java.html' >KMPplus.java</a></p>

<h4 id="kmpimplementation">KMP Implementation</h4>

<p>구현하면</p>

<pre><code class="java">public class DFA {

    int[][] dfa;

    public DFA(String pattern, int R) {
        int M = pattern.length();

        // initialize
        dfa = new int[R][];
        for (int r = 0; r &lt; R; r++)
            dfa[r] = new int[M];

        dfa[pattern.charAt(0)][0] = 1;

        // build DFA
        for (int X = 0, j = 1; j &lt; M; j++) {
            // mismatch
            for (int c = 0; c &lt; R; c++)
                dfa[c][j] = dfa[c][X];

            // match
            dfa[pattern.charAt(j)][j] = j + 1;

            // update X
            X = dfa[pattern.charAt(j)][X];
        }
    }

    public int search(String docs) {

        int i, j, M = pattern.length(), N = docs.length();

        for (i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++) {
            j = dfa[docs.charAt(i)][j];
        }

        if (j == M) return i - M;
        else return N;
    }
}
</code></pre>

<h3 id="boyermoore">Boyer-Moore</h3>

<p><em>KMP</em> 알고리즘은 <em>linear time</em> 인데, 이보다 더 빠르게 할 수 있을까?</p>

<p><br/></p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTmtkVE5qaHpZaWRUWWhSVEx5STJNaDFDWmlCek10SUdaeFlUTGlGVE0yRVdPakp6TDRJRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>패턴의 우측부터 매칭해 가면, 꽤나 많은 <code>M</code> 사이즈의 텍스트를 빠르게 제낄 수 있다. 문제는 패턴이 어디까지 매칭되었는지에 따라 스킵할 수 있는 문자가 다르다는 것이다. 경우를 좀 나눠서 살펴보자 <code>i</code> 는 현재 문서의 탐색할 인덱스를, <code>^</code> 는 <em>mismatch</em> 를 나타낸다.</p>

<pre><code class="java">// case 1

          i     ^
. . . . . . . . T L E . . . . 
          N E E D L E

                  i
. . . . . . . . T L E . . . . 
                  N E E D L E
</code></pre>

<p><em>case 1</em> 은 운이 좋아서, 미스매치 <code>T</code> 가 패턴에 없기 때문에 <code>T</code> 다음으로 <code>i</code> 를 옮길 수 있다.</p>

<pre><code class="java">// case 2a

          i     ^
. . . . . . . . N L E . . . . 
          N E E D L E

                i 
. . . . . . . . N L E . . . . 
                N E E D L E
</code></pre>

<p>여기선 <em>mismatch</em> 문자 <code>N</code> 이 패턴에 있기 때문에 <em>rightmost</em> <code>N</code> 을 찾아 다시 비교를 시작한다. (우측부터 비교하기 때문)</p>

<pre><code class="java">// case 2b

          i     ^
. . . . . . . . E L E . . . . 
          N E E D L E

// rightmost 'E'          

      i          
. . . . . . . . E L E . . . . 
      N E E D L E


// just increament `i` by 1

                i         
. . . . . . . . E L E . . . . 
            N E E D L E
</code></pre>

<p>이 경우엔 <em>rightmost</em> <code>E</code> 가 별로 도움이 안되므로, 그냥 <code>i</code> 를 증가시킨다.</p>

<p>다시 한번 정리하면, </p>

<p>(1) 우측부터 시작해서 비교하다 <em>mismatch</em> 문자가 있을 때 필요 없는 문자를 몇개나 제낄 수 있느냐 하는 문제는, 패턴 안에서 해당 <em>mismatch</em> 문자가 있느냐 없느냐에 따라 다르다.</p>

<p>(2) 없다면 모두 제껴버리면 되는거고, </p>

<p>(3) 있다면 그 문자가 얼마나 우측에 오느냐에 따라 스킵할 수 있는 문자의 수가 달라진다. 우측에 오면 올 수록 거기서 부터 다시 비교해야 하기 때문에, <em>heuristic</em> 이 별로 도움이 안될 수도 있다. <em>case 2b</em> 가 바로 그 예다. 그럴때는 그냥 1 만큼 증가시키는것이 더 나을 수도 있다. </p>

<p><em>skip table</em> 을 만들면</p>

<pre><code class="java">int M = pattern.length();  
int[] right = new int[R];

for (i = 0; i &lt; R; i++) right[i] = -1;  
for (j = 0; j &lt; M; j++) right[pattern.charAt(j)] = j;  
</code></pre>

<p>이 테이블을 이용해 탐색을 하면</p>

<pre><code class="java">int N = docs.length();  
int M = pattern.length();

for (int i = 0; i &lt;= N - M; i++) {  
  int skip = 0;

  for (int j = M - 1; j &gt;=0; j--) {
    if (docs.charAt(i + j) != pattern.charAt(j)) {
      skip = Math.max(1, j - right[docs.charAt(i + j)]);
      break;
    }
  }

  if (skip == 0) return i;
}

return N;  
</code></pre>

<p>이 알고리즘에서 <code>skip</code> 을 계산하는 부분을 잘 보면</p>

<pre><code class="java">skip = Math.max(1, j - right[docs.charAt(i + j)]);  
</code></pre>

<p>현재 비교가 진행된 <code>j</code> 에서 <em>mismatch</em> 문자의 인덱스를 뺄셈해서 1 보다 큰지를 비교한다. 만약 1 보다 작다면, 다시 말해 <code>0</code> 이나 음수라면 <code>skip</code> 이 마이너스로, 즉 왼쪽으로 되기 때문에 스킵할 필요가 없다. 그냥 우측으로 <code>+1</code> 해서 다시 비교하면 된다.</p>

<p>전체 코드는</p>

<pre><code class="java">public class BoyerMoore {

    int[] right;
    String pattern;

    public BoyerMoore(String pattern, int R) {

        this.pattern = pattern;
        int M = pattern.length();

        // initialize skip table
        right = new int[R];
        for (int i = 0; i &lt; R; i++) right[i] = -1;
        for (int j = 0; j &lt; M; j++) right[pattern.charAt(j)] = j;
    }

    public int search(String docs) {

        int M = pattern.length();
        int N = docs.length();

        for (int i = 0; i &lt;= N - M; i++) {
            int skip = 0;

            for (int j = M - 1; j &gt;=0; j--) {
                if (pattern.charAt(j) != docs.charAt(i + j)) {
                    // calculate skip value
                    skip = Math.max(1, j - right[docs.charAt(i + j)]);
                    break;
                }
            }

            if (skip == 0) return i;
        }

        return N;
    }
}
</code></pre>

<p>이건 <em>bad character</em> 라는 특성을 이용한 방법이고, <em>good suffix</em> 등을 과 비교하여 얼마나 더 스킵할지를 결정할 수 있다. </p>

<p>보이어 무어 알고리즘에 대한 설명은 <a href='http://xenostudy.tistory.com/72' >여기</a>가 제일 잘 되어있다. </p>

<h4 id="performance">Performance</h4>

<p>일반적으로는(휴리스틱) <code>~N/M</code> 의 <em>char compare</em> 비교를 한다고 알려져있다. <em>sublinear</em> 한건데, </p>

<p><em>worst case</em> 에서는 <code>~ MN</code> 이다. 예를 들어 패턴이 <code>ABBBB</code> 고 문서가 <code>BBBBBBBBBBBBBBBBB..</code> 일때 최악이다.</p>

<p><em>worst case</em> 를 <code>~3N</code> 까지 개선할 수 있다. <em>KMP-like rule</em> 을 더해 반복적인 패턴을 비하면 된다.</p>

<p>실제로 보이어 무어 알고리즘은 검색할 문자열이 길때 효과가 있다. 그래야 스킵할것이 많기 때문이다. 그러나 대부분의 경우 검색어가 그다지 길지 않다는 것.</p>

<h3 id="rabinkarp">Rabin-Karp</h3>

<p><img src='http://terpconnect.umd.edu/' ~sthomas2/images/rabinkarp.jpg" alt="" /></p>

<p align="center">(<a href='http://terpconnect.umd.edu/' >http://terpconnect.umd.edu</a>)</p>

<p>기본 아이디어는 <em>modular hashing</em> 이다. 인덱스를 하나씩 증가시켜가면서 문자열의 해싱 값을 비교한다.</p>

<p>먼저 해야할 일은 <em>hash function</em> 을 만드는 건데, <code>t_i</code> 를 문서(<code>txt</code>) 의 <code>i</code> 번째 캐릭터라 하면</p>

<p><img src='http://chart.apis.google.com/chart?cht=tx&amp;chl=x_t%20%3D%20t_i%20R%5E%7BM-1%7D%5C%20%20%2B%5C%20%20t_%7Bi%2B1%7D%20R%5E%7BM-2%7D%5C%20%20%2B%5C%20%20%5Ccdots%20%5C%20%5C%20%20%2B%5C%20%20%20t_%7Bi%2BM-1%7D%20R%5E%7B0%7D%5C%20%5C%20%20' (mod)%5C%20%5C%20%20Q" alt="" /></p>

<p>여기서 <code>M</code>-<em>digit</em>, <code>R</code>-<em>base</em>, <code>Q</code> modulo 다. <code>M</code>-<em>degree</em> 다항식인데, <em>Horner's method</em> 를 쓰면 중복된 계산 없이 <em>linear time</em> 으로 <em>evaluation</em> 가능하다. </p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWjBnak1rUkRPeUVqWWpSVEwwRW1NaDFpWjVVek10WVROME1UTDNjVFl4SUdaemt6TDNjRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com/</a>)</p>

<p>난 첨에 뭔소린가 했는데 다항식의 값을 구할 때 중복된 계산을 피하기 위해 이렇게 구현하는걸 말한다.</p>

<p><img src='http://web-ext.u-aizu.ac.jp/course/alg1/ex/uk/ex04/horner2.png'  alt="" /></p>

<p><code>R</code> 에 대한 다항식이기 때문에, 해싱함수의 구현은</p>

<pre><code class="java">private long hash(String key, int M, int Q) {  
  long h = 0;

  for(int j = 0; j &lt; M; j++)
    h = (R * h + key.charAt(j)) % Q;

  return h;
}
</code></pre>

<p><code>x_i</code> 의 해싱값을 계산하고, 매칭이 안되면 다음으로 넘어가 <code>x_(i+1)</code> 을 계산해야 한다. 그런데, 좀 더 효율적으로 할 수 있는 방법이 없을까? 당연히 가능하다. 두 해싱값 서로 다른 1개의 항 빼고는 모두 같은 항을 가지고 있기 때문이다. </p>

<p><img src='http://chart.apis.google.com/chart?cht=tx&amp;chl=x_i%5C%20%20%3D%5C%20t_iR%5E%7BM-1%7D%5C%20%2B%5C%20t_%7Bi%2B1%7DR%5E%7BM-2%7D%5C%20%2B%5C%20%5Ccdots%5C%20%2B%5C%20t_%7Bi%20%2B%20M%20-%201%7DR%5E0%5C%5C%0A%5C%20%5C%5C%20%0A%5C%20%5C%5C%0A%5C%20%5C%5C%0A%5C%20%5C%5C%0A%5C%20%5C%5C%0Ax_i%5C%20%20%3D%5C%20t_%7Bi%20%2B%201%7DR%5E%7BM-1%7D%5C%20%2B%5C%20t_%7Bi%2B1%7DR%5E%7BM-2%7D%5C%20%2B%5C%20%5Ccdots%5C%20%2B%5C%20t_%7Bi%20%2B%20M%7DR%5E0'  alt="" /></p>

<p>따라서 <code>x_(i+1)</code> 은</p>

<p><img src='http://chart.apis.google.com/chart?cht=tx&amp;chl=x_%7Bi%2B1%7D%5C%20%20%3D%5C%20%20' (x_i%5C%20%20%5C%20-%20t_iR%5E%7BM-1%7D)%5C%20%20*%5C%20%20R%5C%20%2B%5C%20%20t_%7Bi%2BM%7D%20" alt="" /></p>

<p>이므로, 상수 시간 내에 다음 문자열의 해시값을 구할 수 있다. 따라서 매 <code>i</code> 마다 상수 시간이므로 <code>~N</code> 으로 패턴을 찾을 수 있다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTmhKR00yWVROaEpHT2psVEwzTW1ONTBpWndjek10Z1RNbGxUTHpNR054WVdPM1l6TDVjRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com/</a>)</p>

<h4 id="implementation">Implementation</h4>

<p>전체 코드는 <a href='http://algs4.cs.princeton.edu/53substring/RabinKarp.java.html' >RabinKarp.java</a> 로</p>

<pre><code class="java">public class RabinKarp {

    String pattern;
    long patternHash;
    int M;
    long Q;
    int R;
    long RM; // R^(M-1) % Q

    public RabinKarp(String pattern) {
        this.pattern = pattern;

        R = 25;
        M = pattern.length();
        Q = longRandomPrime();

        // pre-compute R^(M-1) % Q for use in removing leading digit
        RM = 1;
        for (int i = 1; i &lt;= M-1; i++)
            RM = (RM * R) % Q;

        patternHash = hash(pattern, M);
    }

    private long hash(String key, int M) {
        long h = 0;

        for (int j = 0; j &lt; M; j++)
            h = (R * h + key.charAt(j)) % Q; 
        return h;
    }

    private static long longRandomPrime() {
        BigInteger prime = BigInteger.probablePrime(31, new Random());
        return prime.longValue();
    }

    public int search(String docs) {
        int N = docs.length();
        long docsHash = hash(docs, M);

        if (docsHash == patternHash) return 0;

        for (int i = M; i &lt; N; i++) {
            // remove leading digit
            docsHash = (docsHash + Q - RM * docs.charAt(i-M) % Q) % Q;
            // add trailing digit
            docsHash = (docsHash * R + docs.charAt(i)) % Q;

            // match
            if (patternHash == docsHash) return i - M + 1;
        }

        return N;
    }
}
</code></pre>

<p>참고로, 해시값을 비교하는 것에는 두 가지 버전이 있다.</p>

<p>(1) <strong>Monte Carlo version:</strong> return match if hash match <br />
(2) <strong>Las Vegas version:</strong> check for substring match if hash match and continue search if false collision.</p>

<p>몬테 카를로는 확률적으로 여러번 구해서 맞는 값을 찾는거다. 근데 만약에 <code>Q</code> 가 <code>MN^2</code> 정도로 상당히 크다면, 충돌이 일어날 확률은 <code>1/N</code> 이다.</p>

<p>실제 돌려보면 <code>Q</code> 를 충분히 크게 고르되, 오버플로우가 안 일어나면 <code>1/Q</code> 의 적은 확률로 충돌이 일어난다.</p>

<p>따라서</p>

<p>(1) <strong>Monte Carlo version</strong></p>

<ul>
<li>Always runs in linear time</li>
<li>Extremely likely to return correct answer (but not always)</li>
</ul>

<p>(2) <strong>Las Vegas version</strong></p>

<ul>
<li>Always returns correct answer</li>
<li>Extremely likely to run in linear time (but worst case is <code>M N</code>)</li>
</ul>

<p>라스베가스 버전에서 <em>worst case</em> 는, 충돌이 매번 나고 매번 검사하는건데. 그럴 일은 거의 없다.</p>

<h4 id="prosandcons">Pros and cons</h4>

<p><em>rabin-karp</em> 알고리즘은 앞서 보았던 <em>KMP</em> 나 <em>boyed moore</em> 에 비해 장점이 있는데</p>

<ul>
<li>Extends to 2d patterns</li>
<li>Extends to finding multiple patterns</li>
</ul>

<p>예를 들어서 다양한 패턴을 찾고싶다 하면, 그 패턴들의 심볼 테이블을 만들어 놓고 검색하면 된다.</p>

<p>단점으로는</p>

<ul>
<li>Arithmetic ops slower than char compares</li>
<li>라스베가스 버전은 백업을 필요로 함</li>
<li>poor worst case guarantee</li>
</ul>

<h3 id="summary">Summary</h3>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWTVNMlkxWVdOMUVXTXdJV0w0TWpZaDF5TjJrek10WTJZM0lXTDRjek5pSldabFIyTDBrRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Ro$bert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='http://math.stackexchange.com/questions/563829/difference-between-nfa-and-dfa' >Difference between NFA and DFA</a> <br />
(4) <a href='http://www-igm.univ-mlv.fr/' ~lecroq/string/node4.html">Automaton</a> <br />
(5) <a href='http://somemoreacademic.blogspot.kr/2012/09/boyer-moore-string-matching-algorithm.html' >Boyer Moore string matching algorithm</a> <br />
(6) <a href='http://xenostudy.tistory.com/72' >보이어 무어 알고리즘에 대한 고찰</a> <br />
(7) <a href='http://terpconnect.umd.edu/' ~sthomas2/rabin-karp.html">Rabin-Karp Algorithm</a></p>]]></description><link>http://1ambda.github.io/substring-search/</link><guid isPermaLink="false">2c08e92e-2241-4624-988e-32d552ed67e1</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[substring search]]></category><category><![CDATA[boyer-moore]]></category><category><![CDATA[rabin-karp]]></category><category><![CDATA[knuth-morris-pratt]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 17 Dec 2014 15:16:42 GMT</pubDate></item></channel></rss>