<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Old Lisper]]></title><description><![CDATA[Functional Programming]]></description><link>http://1ambda.github.io/</link><generator>Ghost 0.5</generator><lastBuildDate>Sat, 21 Feb 2015 14:33:58 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Cloud Computing, Gossip Protocol]]></title><description><![CDATA[<p><img src='http://ook.co/wp-content/uploads/cloudcomputing.png'  alt="" /></p>

<h3 id="multicast">Multicast</h3>

<p>이번시간에 배울 내용은 <em>Gossip Protocol</em> (혹은 <em>Epidemic Protocol</em>) 입니다.</p>

<p>기존에는 특정 그룹에게 메세지를 보내기 위해 <em>multicast</em> 를 이용했지만, 클라우드 컴퓨티 환경에서는</p>

<ul>
<li>프로세스가 죽어 노드가 크래쉬를 일으킬수도</li>
<li>네트워크 문제때문에 패킷이 딜레이되거나, 드랍될 수 있고</li>
<li>노드가 빠르게 증가합니다.</li>
</ul>

<p>그러나 멀티캐스트는 <em>fault-tolerance</em> 와 <em>scalability</em> 측면에서 부족한 부분이 많았습니다. 이런 문제를 해결하기 위해 다양한 방법이 도입되었는데</p>

<p>(1) <strong>Centralized:</strong> 중앙 서버에서 <em>TCP, UDP</em> 패킷을 날립니다. 간단한 구현이지만 중앙서버의 오버헤드가 높고, 수천개의 노드가 있을때 <em>latency</em> 가 생깁니다. 노드의 수를 <code>N</code> 이라 했을때, 모든 노드에 메시지가 전달되는데 <code>O(N)</code> 시간이 걸리지요.</p>

<p>(2) <strong>Tree-Based:</strong> 전달 받은 노드에서, 다시 패킷을 전달하여 경로가 <em>tree</em> 형태로 구성됩니다. <em>balanced tree</em> 라면 어떤 그룹에 패킷이 전달되는데 <code>O(logN)</code> 의 시간이 걸립니다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/tree_based_multicast.jpg'  alt="" /></p>

<p>이 방법의 단점은 </p>

<ul>
<li><em>tree</em> 를 구성하고 유지하는데 필요한 오버헤드</li>
<li><em>root</em> 에 가까운 곳에서 <em>failure</em> 가 발생했을때의 파급력</li>
</ul>

<p>일반적으로 <em>tree-based multicast</em> 프로토콜에서는 <em>spanning tree</em> 를 구성해서 최단비용으로 패킷을 전달합니다. 그리고 메시지가 올바르게 전달되었는지 <em>ACK</em> 또는 <em>NAK</em> 를 이용하는데 <em>SRM</em> 이던 <em>RMTP</em> 던 여전히 <code>O(N)</code> 만큼의 <em>ACK/NAK</em> 오버헤드가 발생합니다.</p>

<p><br/></p>

<h3 id="gossip">Gossip</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/gossip_example1.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/gossip_example2.jpg'  alt="" /></p>

<p>가십 프로토콜은 위 그림처럼 작동합니다.</p>

<ul>
<li>주기적으로 랜덤한 타겟을 골라 <em>gossip message</em> 를 전송합니다</li>
<li>그리고 이것을 받아 <em>infected</em> 상태가 된 노드도 똑같이 행동합니다.</li>
</ul>

<p>이걸 <em>Push gossip</em> 이라 부릅니다. <em>multiple message</em> 를 가십하기 위해 랜덤 서브셋을 선택하거나, <em>recently-received</em> 메시지를 를 선택하거나, <em>higher priority one</em> 을 고를 수 있습니다.</p>

<p>어떤 가십 메시지에 대해 대부분의 노드가 <em>infected</em> 되었을때 <em>push gossip</em> 은 비효율적입니다. 이때는 <em>uninfected</em> 노드가, 새로운 가십메시지가 있는지 주변 노드에게 물어보는 <strong>pull gossip</strong> 이 오버헤드가 더 적습니다.</p>

<ul>
<li><strong>Pull gossip:</strong> Periodically poll a few random selected processes for new multicast meesages that you haven't received</li>
</ul>

<p><br/></p>

<h3 id="gossipanalysis">Gossip Analysis</h3>

<p>가십프로토콜은 다음의 특징을 가집니다.</p>

<ul>
<li><strong>lightweight</strong> in large groups</li>
<li>spreads a multicast quickly</li>
<li>highly <em>fault-tolerant</em></li>
</ul>

<p>이를 위해 간단한 증명을 해보도록 하겠습니다.</p>

<ul>
<li>전체 <code>n+1</code> 의 <em>population</em> 에 대해 </li>
<li><em>uninfected individuals</em> 의 수를 <code>x</code></li>
<li><em>infected individuals</em> 의 수를 <code>y</code> </li>
<li><em>individual pair</em> 간의 <em>contract rate</em> 를 <code>β</code> 라 하면</li>
</ul>

<p>항상 <code>x + y = n + 1</code> 이고, 시작상태에서는 <code>x_0 = n, y_0 = 1</code> 입니다. 그리고 시간이 지날때마다 <em>uninfected</em> <code>y</code> 는 다음처럼 감소합니다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Cfrac%7B%5Cmathrm%7Bd%7D%20x%7D%7B%5Cmathrm%7Bd%7D%20t%7D%20%3D%20-%5Cbeta%20xy'  alt="" /></p>

<p>그러면 이 수식으로부터 다음을 이끌어 낼 수 있습니다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?x%20%3D%20%7B%20n%28n&plus;1%29%20%5Cover%20%7Bn%20&plus;%20e%5E%7B%5Cbeta%28n&plus;1%29t%7D%7D%7D'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?y%20%3D%20%7B%20%28n&plus;1%29%20%5Cover%20%7B1%20&plus;%20ne%5E%7B-%5Cbeta%28n&plus;1%29t%7D%7D%7D'  alt="" /></p>

<p>그리고 <em>infected node</em> 가 랜덤하게 <code>b</code> 개의 노드를 고른다 하면 <code>β</code> 는 </p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Cbeta%20%3D%20%7Bb%20%5Cover%20b%7D'  alt="" /></p>

<p>그리고 시간 <code>t</code> 를 가십이 진행되는 <em>round</em> 라 보고 <code>t = clog(n)</code> 이라 치환하겠습니다. 다음을 이끌어낼 수 있습니다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?y%20%5Capprox%20%28n&plus;1%29%20-%20%7B1%20%5Cover%20n%5E%7Bcb-2%7D%7D'  alt="" /></p>

<p>이 식으로부터 <em>gossip protocol</em> 이 <em>low latency</em>, <em>reliability</em>, <em>lightweight</em> 하다는 것을 알 수 있습니다.</p>

<p>(1) <strong>low latency</strong></p>

<p><code>c, b</code> 를 <code>n</code> 과 독립적으로 아주 작은 숫자로 세팅하면 <code>clog(n)</code> <em>round</em> 이므로 적은 시간 내에 메시지가 전파됩니다.</p>

<p>(2) <strong>reliability</strong></p>

<p><code>n</code> 이 매우 크면 <code>1 / n^{cb-2}</code> 가 <code>0</code> 에 가까워지므로, <code>1 / n^{cb-2}</code> 만큼의 노드를 제외한 모든 노드가 <em>infected</em> 된다는 것을 알 수 있습니다.</p>

<p>(3) <strong>lightweight</strong></p>

<p>각 노드는 <code>cb log(n)</code> 만큼의 <em>gossip message</em> 만 전파합니다. 이론적으로는 <code>log(N)</code> 은 상수가 아니지만, 실제로는 아주 천천히 증가하는 숫자기에 작은 숫자처럼 생각할 수 있습니다.</p>

<p><br/></p>

<h3 id="faulttolerance">Fault-Tolerance</h3>

<p><em>50% packet loss</em> 를 생각해 봅시다. <code>b</code> 를 <code>2/b</code> 로 치환하면 됩니다. 그러면 이전과 같은 <em>reliability</em> <em>0% packet loss</em> 를 위하 두배의 <em>round</em> 만큼만 더 진행하면 됩니다.</p>

<p><em>node failure</em> 는 어떨까요? 50% 노드에서 <em>failure</em> 가 발생한다면 <code>n, b</code> 을 <code>2/n, 2/b</code> 으로 치환하면 됩니다. 이는 <em>contract rate</em> 에서 가십 메시지를 전달하는 <code>n</code> 중 <code>2/n</code> 의 노드만 살아있고, 선택되는 <code>b</code> 중 <code>b/2</code> 노드만 살아있기 때문입니다. 이 경우에도 상수만 곱하면 이전과 같은 <em>reliability</em> 를 얻을 수 있습니다.</p>

<p><em>failure</em> 와 관련해서 한 가지 생각해 볼 문제가 있습니다. 모든 노드가 죽는것이 가능할까요? 물론 가능합니다 초기에 모든 노드가 죽으면요. 그러나 <em>improbable</em> 입니다. 일단 몇개의 노드가 <em>infected</em> 되면, 이후에는 퍼지는 속도가 훨씬 더 빠르기 때문입니다. 루머나 바이러스가 퍼질 수 있는 이유를 생각하면 이해하기 쉽습니다.</p>

<p><br/></p>

<h3 id="pullgossip">Pull Gossip</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/pull_gossip_analysis.jpg'  alt="" /></p>

<p>그림에서 볼 수 있듯이, 어떤 형태의 가십 프로토콜이던 <code>2/N</code> 까지 전달할때는 <code>O(logN)</code> 만큼의 시간이 걸립니다. 그 이후에는 <em>pull gossip</em> 이 훨씬 빠르죠.</p>

<p><code>i</code> <em>round</em> 후에 남아있는 <em>uninfected node</em> 의 수를 <code>p_i</code> 라 합시다. <em>pull gossip</em> 을 이용할때 다음 단계에서도 <em>uninfected</em> 일 확률은 </p>

<p><img src='http://latex.codecogs.com/gif.latex?p_%7Bi&plus;1%7D%20%3D%20p_i%5E%7Bk&plus;1%7D'  alt="" /></p>

<p>이는 <code>p_i</code> 자체가 <em>uninfected</em> 여야 하고, 이 노드가 선택하는 <code>k = b</code> 만큼의 노드도 <em>uninfected</em> 여야 하는데, 이 확률은 극히 낮습니다. 슬라이드에서 보듯이 <em>super-exponential</em> 하고, 그렇기 때문에 <em>second half</em> 부터는 <em>pull gossip</em> 이 <code>O(log(logN))</code> 입니다.</p>

<p><br/></p>

<h3 id="topologyawaregossip">Topology-Aware Gossip</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/topology_aware_gossip.jpg'  alt="" /></p>

<p>만약 <em>uninfected node</em> 를 <em>uniformly random</em> 하게 고른다면 위 그림에서 라우터의 오버헤드는 <code>O(N)</code> 이 됩니다. 더 정확하게는 <em>round</em> 마다 <code>b * (2/n)</code> 이 될겁니다. </p>

<p>이를 해결하기 위해, 서브넷에 <code>n_i</code> 개의 노드가 있을때 자신이 속한 서브넷에 있는 <em>uninfected node</em> 를 더 자주 고르게, 확률을 <code>1 - (1/n_i)</code> 가 되도록 합니다. 그러면, 현재 서브넷에 있는 노드를 선택할 확률이 1 에 가까우므로 <code>O(logN)</code> 시간 내에 전파되고, 라우터의 오버헤드는 <code>(n_i) / (n_i)</code> 가 되어, <code>O(1)</code> 이 됩니다. </p>

<p><br/></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href='http://ook.co/solutions/cloud-computing/' >Title Image</a> <br />
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></description><link>http://1ambda.github.io/cloud-computing-gossip-protocol/</link><guid isPermaLink="false">791b3276-2b13-469d-96ff-21b0b279bfd2</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[gossip]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 21 Feb 2015 05:41:54 GMT</pubDate></item><item><title><![CDATA[Pattern Discovery 2]]></title><description><![CDATA[<p><img src='https://m1.behance.net/rendition/modules/7116731/disp/d18c13cd5b49bf40b41e6ef0610b26d3.png'  alt="" /></p>

<p>패턴 마이닝을 통해 만들어지는 수많은 <em>pattern</em>, <em>rule</em> 이 모두 유용한 것은 아닙니다. 따라서 <em>interestingness measure</em> 을 위해 객관적이거나, 주관적인 평가방법을 이용할 수 있습니다.</p>

<p>(1) <strong>Objective interestingness measures</strong></p>

<ul>
<li>support, confidence, correlation</li>
</ul>

<p>(2) <strong>Subjective interestingness measures</strong></p>

<ul>
<li><em>Query-based:</em> relevant to a user's particular request</li>
<li><em>Against one's knowledge-base:</em> unexpected, freshness, timeliness</li>
<li><em>Visualization tools:</em> Multi-dimensional, interactive examination</li>
</ul>

<p>이 방법중, 먼저 객관적인 방법에 대해 좀 더 알아보겠습니다.</p>

<p><br/></p>

<h3 id="liftchisquared">Lift, χ²(Chi-squared)</h3>

<p><em>confidence</em> 는 두 변수가 관련있는지 말해주지만, <em>positive</em> 혹은 <em>negative</em> 관계인지 말해주지 않습니다. 이를 판별하기 위해 <em>lift</em> 를 이용할 수 있죠</p>

<p><img src='http://latex.codecogs.com/gif.latex?lift%28B%2C%20C%29%20%5C%5C%20%5C%5C%20%3D%20%7Bc%28B%20-%3E%20C%29%20%5Cover%20s%28C%29%7D%20%5C%5C%20%5C%5C%20%5C%5C%20%3D%20%7Bs%28B%20%5Ccup%20C%29%20%5Cover%20%7Bs%28B%29%20%5Ctimes%20s%28C%29%7D%7D'  alt="" /></p>

<p><code>Lift(B, C)</code> 는 <code>B</code> 와 <code>C</code> 가 얼마나 관련있는지를 말해줍니다. 수식을 보면 알겠지만</p>

<ul>
<li><code>Lift(B, C) = 1</code> 이면 <code>B</code> 와 <code>C</code> 는 <em>independent</em></li>
<li><code>&gt; 1</code> 이면 <em>positive correlated</em></li>
<li><code>&lt; 1</code> 이면 <em>negative correlated</em></li>
</ul>

<p><br/></p>

<p><em>correlated events</em> 를 판별하는 다른 방법은 <code>χ²</code> 를 이용하는 것입니다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Cchi%5E2%20%3D%20%5Csum%20%7B%28observed%20-%20expected%29%5E2%20%5Cover%20expected%7D'  alt="" /></p>

<ul>
<li><code>χ² = 0</code> 이면 <em>independent</em></li>
<li><code>χ² &gt; 1</code> 이면 <em>correlated</em> 이며 <em>positive</em> 인지 <em>negative</em> 인지는 <em>expected</em> 값과 비교하면 알 수 있습니다.</li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/null_transaction.jpg'  alt="" /></p>

<p>그러나 <em>lift</em> 와 <em>chi-squared</em> 가 항상 좋은 평가지표는 아닙니다. 위 테이블을 보면 <code>Lift(B, C) = 8.44</code> 입니다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?lift%28B%2C%20C%29%20%5C%5C%20%5C%5C%20%3D%20%7B%28100/102100%29%20%5Cover%20%7B%281100/102100%29%20' *%20%281100/102100%29%7D%7D%20%5C%5C%20%5C%5C%20%3D%208.4380" alt="" /></p>

<p>이는 <code>~B and ~C</code> 부분의 숫자가 <code>B, C</code> 보다 월등히 높아서 그런데, 이런 영역을 <em>null transaction</em> 이라 부릅니다. </p>

<p><code>B, C</code> 는 같이 일어날 확률이 상당히 낮지만, <em>null transaction</em> 때문에 높은것처럼 보입니다.</p>

<p><br/></p>

<h3 id="nullinvariantmeasures">Null Invariant Measures</h3>

<p><em>lift</em> 와 <em>chi-squared</em> 는 많은 수의 <em>null transaction</em> 이 있을 때 좋은 평가 지표가 될 수 없습니다. </p>

<p>이를 해결하기 위해 <em>null transaction</em> 에 영향을 받지 않는 <em>null-invaraint measures</em> 를 사람들이 만들어 두었습니다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/null_invariant_measures.jpg'  alt="" /></p>

<p><em>null invariance</em> 는 <em>massive transaction data</em> 를 마이닝할때 아주 중요합니다. <em>null transaction</em> 이 아주 많을 수 있기 때문이죠. </p>

<p>그러면 이 많은 <em>measures</em> 중 어떤것이 가장 나을까요? 예제 데이터로 한번 비교해 봅시다. <code>m</code> 은 <em>milk</em>, <code>c</code> 는 <em>coffee</em> 입니다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/comparison_of_measures.jpg'  alt="" /></p>

<blockquote>
  <p>Kulc holds firm and is in balance of both directional implications</p>
</blockquote>

<p>여기에 <em>imbalance ratio</em> 라는 개념을 도입할 수 있습니다.</p>

<ul>
<li><strong>imbalance ratio:</strong> measure the imbalance of two itemsets <code>A</code> and <code>B</code> in rule implications</li>
</ul>

<p><img src='http://latex.codecogs.com/gif.latex?IR%28A%2C%20B%29%20%5C%5C%20%5C%5C%20%3D%20%7B%7B%7Cs%28A%29%20-%20s%28B%29%7D%20%5Cover%20s%28A%29%20&plus;%20s%28B%29%20-%20s%28A%5Ccup%20B%29%7D'  alt="" /></p>

<p><em>Kulc</em> 와 <em>IR</em> 을 이용하면 조금 더 데이터를 자세히 살펴볼 수 있죠.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/IR.jpg'  alt="" /></p>

<ul>
<li>D4 is <em>neutral</em>, <em>balanced</em></li>
<li>D5 is <em>neutral</em>, but <em>imbalanced</em></li>
<li>D6 is <em>neutral</em>, but very <em>imbalanced</em></li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/DBLP_example.jpg'  alt="" /></p>

<p><code>ID 5</code> 를 보면, <em>Kulc</em> 는 아이템 <code>A, B</code> 가 상당한 연관성이 있지만, <em>imbalance</em> 하므로 <code>0.562</code> 의 값을 돌려주는 것을 볼 수 있습니다.</p>

<p><br/></p>

<h2 id="5miningdiversepatterns">5. Mining Diverse Patterns</h2>

<p>이번 시간에 배울 주제들은 다음과 같습니다.</p>

<ul>
<li>Mining Multiple-Level Associations</li>
<li>Mining Multi-Dimensional Associations</li>
<li>Mining Quantitative Associations</li>
<li>Mining Negative Correlations</li>
<li>Mining Compressed and Redundancy-Aware Patterns</li>
<li>Mining Long/Colossal Patterns</li>
</ul>

<p><br/></p>

<h3 id="multilevelassociations">Multi-Level Associations</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/multi_level_items.jpg'  alt="" /></p>

<p><em>item</em> 은 하위 계층으로 다시 분류될 수 있습니다. 이럴때는 단순히 <em>uniform min support</em> 를 이용하는 것보다, 아래 계층으로 내려갈수록 <em>reduced min support</em> 를 이용하는 편이 더 낫습니다.</p>

<p>그리고 한번의 여러 단계(<em>multi-level</em>) 을 마이닝하기 위해 <em>shared multi-level mining</em> 이란 기법을 이용할 수 있습니다.  이건 뒷부분에서 더 살펴보겠습니다.</p>

<p><em>multi-level association</em> 마이닝의 문제점은 <em>redundant rules</em> 을 만들 수 있다는 점입니다. 따라서 필터링 기법이 필요합니다. <code>level 1</code> 에서 발견된 룰을, <code>level 2</code> 에서 다시 검사하지 않는것 처럼요</p>

<ul>
<li><code>milk -&gt; wheat bread [s=8%, c=70%]</code></li>
<li><code>2% milk -&gt; wheat breadk [s=2%, c=72%]</code></li>
</ul>

<p>아이템에 따라서 <em>customized min support</em> 가 필요한 경우도 있습니다. 우유나 빵은 그렇지 않아도 상관 없지만, <em>diamond</em>, <em>watch</em> 등은 커스터마이징이 꼭 필요합니다. 고가의 아이템이니까요. 이 경우 <em>group-based individualized min-support</em> 를 이용하면 됩니다.</p>

<ul>
<li><code>{diamon, watch}: 0.05%; {bread, milk}: 5%;, ...</code></li>
</ul>

<p><br/></p>

<h3 id="multidimensionalassociations">Multi-Dimensional Associations</h3>

<p><em>multi-dimensional</em> 의 예는</p>

<p>(1) <strong>inter-dimension association rules</strong> (no repeated pred)</p>

<p><code>age(X, "18-25") ∩ occupation(X, "student") =&gt; buys(X, "coke")</code></p>

<p>(2) <strong>hybrid-dimension association rules</strong> (repeated pred)</p>

<p><code>age(X, "18-25") ∩ buys(X, "popcorn") =&gt; buys(X, "coke")</code></p>

<p><em>attribute</em> 는 <em>categorical</em> 이거나 <em>quantitative</em> 일 수 있습니다. </p>

<p><br/></p>

<h3 id="quantitativeassociations">Quantitative Associations</h3>

<p><em>numerical attribute</em> (e.g <em>age, salary</em>) 를 마이닝 하기 위해 다양한 <em>method</em> 를 사용할 수 있습니다.</p>

<p>(1) static discretization based on prefefined concept hierarchies. data cube-based aggregation</p>

<p>(2) dynamic discretization based on data distribution</p>

<p>(3) clustering: distance-based association. first one-dimensional clustering, then association</p>

<p>(4) deviation analysis</p>

<p><br/></p>

<h3 id="negativecorrelations">Negative Correlations</h3>

<p><em>rare pattern</em> 과 <em>negative pattern</em> 은 다릅니다.</p>

<p>(1) <strong>Rare patterns</strong></p>

<ul>
<li>아주 낮은 <em>support</em> 지만, 롤렉스 시계를 사는 행위처럼 중요할 수 있습니다</li>
<li><em>individualized</em>, <em>group-based min support</em> 를 다양한 아이템 그룹에 설정해서 마이닝합니다.</li>
</ul>

<p>(2) <strong>Negative patterns</strong></p>

<ul>
<li>자동차를 동시에 2개 사는것처럼, 같이 일어나는 경우가 드뭅니다 (<em>unlikely to happen together</em>)</li>
</ul>

<p><br/></p>

<p><em>negative pattern</em> 은 어떻게 마이닝할까요? 한가지 방법은 <em>lift</em> 에서 사용했던 <em>support-based definition</em> 을 이용하는 것입니다.</p>

<ul>
<li><code>s(A ∪ B) &lt;&lt; s(A) X s(B)</code></li>
</ul>

<p>이 정의는 작은 <em>transaction dataset</em> 에서는 통하지만, 데이터 크기가 커지면 적용되지 않습니다.</p>

<p>(1) 전체 200개의 트랜잭션에 대해</p>

<ul>
<li><code>s(A∪B) = 0.005, s(A) x s(B) = 0.25, s(A∪B) &lt;&lt; s(A) X s(B)</code></li>
</ul>

<p>(2) 전체 10^5 개의 트랜잭션에 대해</p>

<ul>
<li><code>s(A∪B) = 1/10^5, s(A) x s(B) = 1/10^3 X 1/10^3, s(A∪B) &gt;&gt; s(A) X s(B)</code></li>
</ul>

<p>이전에 봤었던 <em>null transaction</em> 때문입니다. <em>support-based definition</em> 은 <em>not null-invariant</em> 입니다.</p>

<p>이를 해결하기 위해 <em>Kulczynski measure-based definition</em> 을 이용하면</p>

<p><img src='http://latex.codecogs.com/gif.latex?%28P%28A%7CB%29%20&plus;%20P%28B%7CA%29%29%20/%202%20%3C%20%5Cepsilon'  alt="" /></p>

<p>여기서 <code>ɛ</code> 는 <em>negative pattern threshold</em> 를 의미합니다. 만약 위 수식이 <code>ɛ</code> 보다 작으면 <em>negatively correlated</em> 란 뜻이지요. </p>

<p><br/></p>

<h3 id="compressedpatterns">Compressed Patterns</h3>

<p>때로는 너무 많아 의미가 없는 <em>scattered pattern</em> 때문에 <em>compressed pattern</em> 을 마이닝 할 필요가 있습니다. </p>

<p><em>compressed pattern</em> 인 <em>closed pattern</em> 과 <em>max pattern</em> 의 정의를 복습해보면</p>

<ul>
<li><strong>closed pattern:</strong> A pattern <code>x</code> is <strong>closed</strong> if <code>x</code> is frequent, and there exists no super pattern <code>Y ⊃ X</code> with the same support as <code>X</code></li>
<li><strong>max pattern:</strong> A pattern <code>X</code> is a <strong>max pattern</strong>. if <code>X</code> is frequent and there exists no frequent super-pattern <code>Y ⊃ X</code></li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/compressed_pattern.jpg'  alt="" /></p>

<p>예를 들어 위 그림에서 <code>P1, 2, 3, 4, 5</code>는 모두 <em>closed</em> 고, <code>P3</code> 는 <em>max pattern</em> 입니다. <em>P3</em> 만 남기자니 <em>information loss</em> 가 너무 많고, 다 남기자니 엣지가 없습니다. <code>P2, P3, P4</code> 정도면 적당할 것 같습니다.</p>

<p>이 적당한 정도를 결정하기 위해 <em>pattern distance measure</em> 을 사용할 수 있습니다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?Dist%28P_1%2C%20P_2%29%20%3D%201%20-%20%7B%7CT%28P_1%29%20%5Ccap%20T%28P_2%29%7C%20%5Cover%20%7CT%28P_1%29%20%5Ccup%20T%28P_2%29%7C%7D'  alt="" /></p>

<p>그리고 이 <em>distance</em> 값을 이용해 <em>δ-cluserting</em> 을 합니다. </p>

<ul>
<li><strong>δ-clustering:</strong> For each pattern <code>P</code>, find all patterns which can be expressed by <code>P</code> and whose distance to within <code>δ</code> (<em>δ-cover</em>)</li>
</ul>

<p><br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/redundancy_aware_top_k.jpg'  alt="" /></p>

<p><em>Redundancy-Aware Top-k pattern</em> 이란 기법도 있습니다.</p>

<p><code>(a)</code> 가 본래 패턴이고, <em>traditional top-k</em> 기법으로는 가장 컴팩트한(진한) 3개의 패턴만 남깁니다. 따라서 우측 클러스터는 버려지죠.</p>

<p>이를 막기 위해 클러스터별로 하나씩 남기는 <code>(d)</code> <em>summarization</em> 을 이용할 수도 있으나, 이건 중요한 것만을 돌려주지 않습니다. </p>

<p>따라서 두 방법을 조합한 <code>(b)</code>, 중복을 허용하는 <em>redundancy-aware top-k</em> 를 이용하면 적절한 패턴을 남기고, 나머지는 버릴 수 있습니다.</p>

<p>이를 위해 <em>MMS (Maximal Marginal Significance)</em> 메소드를 사용할 수 있습니다.</p>

<p><br/></p>

<h3 id="colossalpatterns">Colossal Patterns</h3>

<p><em>long pattern mining</em> 은 소셜 네트워크 분석이나, 바이오인포메틱스, 소프트웨어 엔지니어링등 다양한 분야에서 필요로 합니다. 그러나, 지금까지 우리가 본건 길이가 10 보다 적은 패턴을 마이닝하는 기법들이었습니다.</p>

<p><em>long pattern</em> 을 분석하기 어려운 이유는 지난시간에 봤듯이 <em>downward closure property</em> 때문입니다. <em>frequent pattern</em> 의 <em>sub-pattern</em> 은 적어도 그만큼은 빈번하기 때문에, 패턴의 길이가 길고 <em>frequent</em> 하다면, 그 수많은 서브패턴을 분석해야 하는 것이지요.</p>

<p><em>BFS (e.g Apriori)</em>, <em>DFS (e.g FPgrowth)</em> 등 무엇을 이용하든 수 많은 패턴을 검색해야 하고, <em>combinatorial explosion</em> 과 마주할 수 밖에 없습니다.</p>

<p><code>40C20</code> 컴비네이션의 경우 기존에 존재하는 가장 빠른 마이닝 알고리즘들(e.g FP-Close, LCM)도 계산을 완료하지 못하는 경우가 많습니다. 그러나 놀랍게도 <em>pattern-fusion</em> 알고리즘은 1초만에 결과를 돌려줍니다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/pattern_fusion1.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/pattern_fusion2.jpg'  alt="" /></p>

<p>즉, 작은 <em>core pattern</em> 을 모아 <em>colossal pattern</em> 을 만들어 낸다는 것이지요.</p>

<ul>
<li><strong>core patterns</strong> of a colossal pattern <code>α</code>: A set of subpatterns of <code>α</code> that cluster around <code>α</code> by sharing a similar support</li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/robustness_of_colossal_pattern.jpg'  alt="" /></p>

<p><em>core pattern</em> 에 대한 더 엄밀한 정의는 위와 같습니다.</p>

<p><em>frequent pattern</em> <code>α</code> 에 대해, <em>sub-pattern</em> 인 <code>β</code> 는  다음을 만족하면 <em>τ-core pattern</em> 입니다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?%7B%7CD_%5Calpha%7C%20%5Cover%20%7CD_%5Cbeta%7C%7D%20%5Cgeq%20%5Ctau%5C%20%28where%5C%20%5Ctau%5C%20is%5C%20core%5C%20ratio%29'  alt="" /></p>

<p>그리고 패턴 <code>α</code> 에서 <code>d</code> 만큼의 아이템을 제거해도, 여전히 <em>τ-core pattern of α</em> 이면 <code>α</code> 를 <em>(d, τ)-robust</em> 라 부릅니다. 따라서 <code>d</code> 만큼의 아이템이 있거나 없어도, 코어패턴이므로 전체 숫자는 <code>2^d</code> 만큼의 코어패턴을 만들 수 있습니다.</p>

<p>그러므로 <em>colossal pattern</em> 이라면, 정말 많은 수의 <em>core pattern</em> 을 만들 수 있습니다. 그리고 이런 <em>core pattern</em> 은  <em>distance</em> 가 충분히 작으므로 <em>dense ball</em> 형태로 뭉칩니다. 결과적으로 <em>random pattern space</em> 에서 패턴을 뽑으면, <em>dense ball</em> 내의 패턴일 확률이 굉장히 높습니다.</p>

<p>이를 기반으로한 <em>Pattern-Fusion Algorithm</em> 은</p>

<ol>
<li><p><strong>Initialize (creating initial pool)</strong>: </p></li>
<li><p>Use an existing algorithm to min all frequent patterns up to a small size (e.g 3)</p></li>
<li><p><strong>Iteration (iterative pattern fusion):</strong> </p></li>
<li><p>At each iteration, <code>K</code> seed patterns are randomly picked from the current pattern pool</p></li>
<li>For each seed pattern thus picked, we find all the patterns within a bounding ball centered at the seed pattern</li>
<li>All these patterns found are fused tohether to generate a set of super-patterns</li>
<li><p>All the super-patterns thus generated form a new pool for the next iteration</p></li>
<li><p><strong>Termination:</strong></p></li>
<li><p>when the current poll contains no more than <code>K</code> patterns at the beginning of an iteration</p></li>
</ol>

<p><br/></p>

<h2 id="6constraintbasedmining">6. Constraint-Based Mining</h2>

<p>이번시간에 배울 내용은 다음과 같습니다.</p>

<ul>
<li>Different Pruning Strategies</li>
<li>Constrainted Mining with Pattern Anti-Monotonicity</li>
<li>Constrainted Mining with Pattern Monotonicity</li>
<li>Constrainted Mining with Data Anti-Monotonicity</li>
<li>Constrainted Mining with Succinct Constraints</li>
<li>Constrainted Mining with Convertible Constraints</li>
<li>Hanlding Multiple Constraints</li>
</ul>

<p>왜 <em>Constraint-Based Mining</em> 이 필요할까요? 데이터셋에 있는 <strong>all</strong> 패턴을 <strong>autonomously</strong> 하게 찾는것은 불가능합니다. 이는 <em>compressed pattern mining</em> 에서 언급했듯이, 너무 많은 패턴이 있기 때문이지요. 특히 데이터셋이 커지면 사용자가 관심 없는 데이터가 기하급수적으로 늘어납니다.</p>

<p>따라서 패턴 마이닝은 사용자가 무엇을 원하는지 <em>data mining query language</em> 나 <em>GUI</em> 를 통해서 직접 명령을 내리는 <em>interactive</em> 한 과정이 되야 합니다.</p>

<p><em>constraints</em> 를 이용하면 다음과 같은 장점이 있습니다.</p>

<ul>
<li><strong>user flexibility:</strong> provides <strong>constraints</strong> on what to be mined</li>
<li><strong>optimization:</strong> explores such constraints for efficient mining</li>
</ul>

<p><br/></p>

<h3 id="differentpruning">Different Pruning</h3>

<p><em>constraints</em> 에 따라 <em>pruning strategy</em> 달라집니다.</p>

<p>(1) <strong>pattern space pruning constraints</strong></p>

<ul>
<li><em>anti-monotonic:</em> if constraint <code>c</code> is violated, its further mining can be terminated</li>
<li><em>monotonic:</em> if <code>c</code> is satisfied, no need to check <code>c</code> agina</li>
<li><em>succinct:</em> <code>c</code> can be enforced by directly manipulating the data</li>
<li><em>convertible:</em> <code>c</code> can be converted to monotonic or anti-monotonic if items can be propery ordered in processing</li>
</ul>

<p>(2) <strong>data space pruning constraints</strong></p>

<ul>
<li><em>data succinct:</em> data space can be pruned at the initial pattern mining process</li>
<li><em>data anti-monotonic:</em> if a transaction <code>t</code> doesn't satisfy <code>c</code>, then <code>t</code> can be pruned to reduce data processing effort</li>
</ul>

<p><br/></p>

<h3 id="antimonotonicity">Anti-Monotonicity</h3>

<p><em>constaint</em> <code>C</code> 는 다음의 경우에 <em>anti-monotone</em> 이라고 말합니다.</p>

<ul>
<li>If an itemset <code>S</code> <strong>violates</strong> constraint <code>C</code>, so does any of its superset</li>
<li>That is, mining on itemset <code>S</code> can be terminated</li>
</ul>

<p>예를 들어서 다음의 제약조건은 <em>anti-monotone</em> 입니다</p>

<ul>
<li><code>sum(S.price) &lt;= v</code></li>
<li><code>range(S.profit) &lt;= 15</code> </li>
<li><code>support(S) &gt;= k</code></li>
</ul>

<p>따라서 <em>Apriori pruning</em> 은 본질적으론 <em>anti-monotonic constaint</em> 에 기반합니다.</p>

<p>반대로 <code>sum(S.price) &gt;= v</code> 는 <em>not anti-monotone</em> 입니다.</p>

<p><br/></p>

<h3 id="monotonicity">Monotonicity</h3>

<p><em>itemset</em> <code>S</code> 가 <em>constaint</em> <code>c</code> 를 만족할때, <code>S</code> 의 <em>superset</em> 도 그러하다면 <code>c</code> 는 <em>monotone</em> 이라 부릅니다. 다음은 모두 <em>monotone</em> 입니다.</p>

<ul>
<li><code>sum(S.price) &gt;= v</code></li>
<li><code>min(S.price) &lt;= v</code></li>
<li><code>range(S.profit) &gt;= 15</code></li>
</ul>

<p><br/></p>

<h3 id="dataantimonotonicity">Data Anti-Monotonicity</h3>

<p><em>data anti-monotone</em> 는 <em>transaction</em> 기반으로 <em>pruning</em> 을 진행해 나아갑니다. 정의는 이렇습니다.</p>

<ul>
<li>In the mining process, if a data entry <code>t</code> cannot satisfy a pattern <code>p</code> under <code>c</code>, <code>t</code> cannot satisfy <code>p</code>'s superset either</li>
</ul>

<p>다음은 모두 <em>data anti-monotone</em> 입니다.</p>

<ul>
<li><code>sum(S.price) &gt;= v</code> </li>
<li><code>min(S.price) &lt;= v</code></li>
<li><code>range(S.profit) &gt;= 25</code></li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/data_anti_monotone.jpg'  alt="" /></p>

<p><br/></p>

<h3 id="succinctconstaints">Succinct Constaints</h3>

<p><em>succintness</em> 는 <em>data space</em> 와 <em>pattern space</em> 를 모두 <em>pruning</em> 합니다.</p>

<blockquote>
  <p>if the constaint <code>c</code> can be enforced by directly manipulating the data</p>
</blockquote>

<p>(1) To find those patterns without item <code>i</code></p>

<p><em>pattern space pruning</em> 처럼 <code>i</code> 을 DB 에서 제거합니다.</p>

<p>(2) To find those patterns containing item <code>i</code></p>

<p><em>data space pruning</em> 처럼 <em>i-projected</em> DB 만 마이닝 합니다.</p>

<p>(3) <code>min(S.price) &lt;= v</code> is succinct</p>

<p><code>price &lt;= v</code> 에서 시작해서, <em>high-price item</em> 을 제거해 나가기 때문에 <em>pattern + data space pruning</em> 입니다.</p>

<p>(4) <code>sum(S.price) &gt;= v</code> is not succinct</p>

<p><em>itemset</em> <code>S</code> 의 <em>sum</em> 이 점점 크기때문에, 미리 제거할 수 없습니다.</p>

<p><br/></p>

<h3 id="convertibleconstaints">Convertible Constaints</h3>

<blockquote>
  <p>Convert tough constaints into (anti-) monotone by proper ordering of items in transactions</p>
</blockquote>

<p><code>avg(S.profit) &gt; 20</code> 같은 경우는 <em>anti-monotone</em> 도 <em>monotone</em> 도 아닙니다. </p>

<ul>
<li>만약 현재 만족한다고 했을때, 아주 작은 <code>profit*</code> 을 가지는 아이템을 추가하면 <em>violation</em> 이고,</li>
<li>만약 현재 위반한다고 했을때, 아주 큰 값을 추가하면 <em>satisfaction</em> 이기 때문입니다.</li>
</ul>

<p>이런 <em>constaint</em> 에 대해서도 <em>pruning advantage</em> 를 얻고자 하는것이 바로 <em>convertible constaints</em> 의 목적입니다. 가능하면 <em>anti-monotone</em> 이 더 선호되는데, 이는 <em>monotone</em> 일 경우 검사만 하지 않고, <em>anti-monotone</em> 일 경우 <em>super-pattern</em> 을 날려버릴 수 있기 때문입니다.</p>

<ul>
<li>만약 <code>c: avg(S.profit &gt; 20)</code> 에 대해서 </li>
<li><em>itemset</em> 을 내림차순으로 <code>S: {a, g, f, b, h, d, c, e}</code> 정렬하고 </li>
<li><code>avg(ab) = 20</code>, <code>g = 20</code> 이면</li>
</ul>

<p><em>constaint</em> <code>C</code> 는 <em>anti-monotone</em> 이라 할 수 있습니다. 왜냐하면 패턴 내부가 <code>profit</code> 을 기준으로 내림차순으로 되어서, 어떤 <em>item entry</em> 를 뽑아도 <code>c</code> 를 만족할 수 없기 때문입니다.</p>

<p>아쉽게도 이 방법은 <em>level-wise candidate generation</em> 을 하는 <em>Apriori</em> 알고리즘엔 적용되지 않습니다.</p>

<p><br/></p>

<h3 id="hanldingmultipleconstaints">Hanlding Multiple Constaints</h3>

<p>다수개의 <em>constaints</em> 를 사용하는것은 좋으나, <em>item ordering</em> 에서 충돌이 생길 수 있습니다. 이럴땐 먼저 하나의 <em>constaint</em> 기준으로 정렬하고, 나머지는 <em>projected databases</em> 를 마이닝할때 하면 좋습니다.</p>

<p>예를 들어 다음 두개의 <em>constaints</em> 가 있을때</p>

<ul>
<li><code>c1: avg(S.profit) &gt; 20</code></li>
<li><code>c2: avg(S.price) &lt; 50</code></li>
</ul>

<p><code>c1</code> 이 더 강력한 <em>pruning power</em> 가 있다고 생각하고, <code>c1</code> 먼저  <em>anti-monotone</em> 으로 변경 한 후, 각 <em>projected-DB</em> 에서 트랜잭션을 오름차순으로 정렬해 <code>c2</code> 를 마이닝에 이용합니다.    </p>

<p><br/></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href='https://www.behance.net/gallery/625042/Icon-and-pattern-with-a-marketing-theme' >Title image</a> <br />
(2) <strong>Pattern Discovery</strong> by <em>Jiawei Han</em> </p>]]></description><link>http://1ambda.github.io/pattern-discovery-2/</link><guid isPermaLink="false">eae33e61-9556-4292-99f1-9b45d93ceb62</guid><category><![CDATA[coursera]]></category><category><![CDATA[pattern discovery]]></category><category><![CDATA[data mining]]></category><category><![CDATA[lift]]></category><category><![CDATA[pattern-fusion]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 20 Feb 2015 02:49:15 GMT</pubDate></item><item><title><![CDATA[Artificial Intelligence 2, Search]]></title><description><![CDATA[<p><img src='http://picm.yourswallpaper.com/other/box-robot_18407.jpg'  alt="" /></p>

<p><br/></p>

<h3 id="agents">Agents</h3>

<p><em>agent</em> 가 <em>good decision</em> 을 내릴려면 <em>planning</em> 을 해야합니다. 그러기 위해선 어떤 <em>action</em> 이 좋을지 <em>search (탐색)</em> 해 보아야 하고 결국 풀어야 할 문제는 <em>search problem</em> 이 됩니다.</p>

<p>(1) <strong>reflex agent</strong></p>

<ul>
<li>Choose action based on current percept (and maybe memory)</li>
<li>May have memory or a model of the world's current state</li>
<li>Do not consider the future consequences of their action</li>
<li>Consider how the world <strong>IS</strong></li>
</ul>

<p>자신이 인지하는 <em>environment</em> 에 기반하여 어떤 <em>action</em> 을 취할지 결정하나, <em>action</em> 의 결과를 고려하지 않고 결정을 내리기에 문제가 생길 수 있습니다. <em>reflext agent</em> 가 <em>rational</em> 할 수 있을까요?</p>

<blockquote>
  <p>Of course. Rationality is a function of the actions you take, not the computation. So if you had a big enough, good enough lookup table, and you're taking the right actions. <strong>Rationality doesn't care what process led to them.</strong> Reflex is a comment on the thought process</p>
</blockquote>

<p>(2) <strong>planning agents</strong></p>

<p><em>planning agent</em> 는 <em>reflex agent</em> 와는 다르게 <strong>what if</strong> 를 질문합니다. 따라서</p>

<ul>
<li>Decisions based on (hypothesized) consequences of actions</li>
<li>Must have a model of how the world evolves in response to actinos</li>
<li>Must formulate a goal(test)</li>
<li>Consider how the world <strong>WOULD BE</strong></li>
</ul>

<p><em>planning agent</em> 는 <em>action</em> 을 선택할때 <em>real world</em> 에서 실제로 실행해보진 않습니다. 대신 <em>model</em> 을 이용해 <em>simulation</em> 을 해봅니다. 따라서 <em>planning agent</em> 에서는 <em>real world</em> 를 반드시 모델링 해야 합니다.</p>

<blockquote>
  <p>In order to have a planning agent, you must have <strong>a model of the world</strong></p>
</blockquote>

<p>그렇기 때문에 모델상에서 <em>goal</em> 인지 테스트 할 수 있는 방법도 필요합니다. </p>

<p><em>planning</em> 과 관련해서 <em>complete planning</em> 과 <em>optimal planning</em> 이 있습니다. <em>complete planning</em> 은 <em>solution</em> 을 찾아내고, <em>optimal planning</em> 은 <em>best solution</em> 을 찾아냅니다.</p>

<p>또한 <em>planning agent</em> 는 한번에 <em>plan</em> 을 세워 실행할 수도 있지만, 매 실행 후 다시 <em>re-planning</em> 할 수도 있습니다. </p>

<p><br/></p>

<h3 id="searchproblem">Search Problem</h3>

<p><em>search problem</em> 은 다음처럼 구성됩니다.</p>

<ul>
<li><strong>A state space:</strong> models how the world is</li>
<li><strong>A successor function (with actions, costs):</strong> models how it evolves in response to your actions</li>
<li><strong>A start state</strong> and <strong>a goal test</strong></li>
</ul>

<p>그리고 <em>solution</em> 은 <em>start state</em> 를 <em>goal state</em> 로 변환하는 <em>a sequence of actions (a plan)</em> 입니다.</p>

<p>다시 정리하자면, <em>state</em> 는 <em>world</em> 를 어떻게 모델링 하는지를 나타내고, <em>successor function</em> 은 <em>action</em> 에 <em>world</em> 가 어떻게 반응할지를 나타냅니다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/artificial-intelligence/search/searchprbs_are_models.jpg'  alt="" /></p>

<blockquote>
  <p>Search problems are just models</p>
</blockquote>

<p>실제로 현실세계를 그대로 시뮬레이션하기엔 복잡하기때문에, 이를 계산하기 위해 <em>rough</em> 한 모델이 필요합니다. 이 <em>model</em> 적절하다면 <em>search problem</em> 의 결과도 정확합니다.</p>

<p>모델을 너무 추상화 해서 만들면 (<em>abstract too much</em>) 문제를 풀 수 없고, 그 반대라면 현실세계의 복잡함을 모두 다뤄야 하기 때문에 계산이 어려울 수 있습니다. 따라서 적절한 정도의 <em>abstraction</em> 이 필요합니다.</p>

<p>예를 들어 모든 <em>dot</em> 을 먹는 팩맨 에이전트를 만든다고 할때, <em>state</em> 에 문제를 풀기에 필요 이상의 정보를 넣으면 <em>search space</em> 가 너무 커져 계산이 어렵고, 너무 추상화해서 문제를 풀기에 필요한 정보가 부족하면 <em>solution</em> 을 찾는다 해도 올바른 <em>solution</em> 이 아닐 수 있습니다.</p>

<p><br/></p>

<h3 id="searchstategraph">Search State Graph</h3>

<p><em>state space graph</em> 는 <em>search problem</em> 의 <em>mathematical representation</em> 입니다.</p>

<ul>
<li>Nodes are (abstracted) world configurations</li>
<li>Arcs represent successors (action results)</li>
<li>The goal test is a set of goal nodes (maybe only one)</li>
<li>In a search graph, each state occurs only once</li>
</ul>

<h3 id="searchstatetree">Search State Tree</h3>

<p><em>search tree</em> 는 <em>plan</em> 이 어떠할지를 나타내는 일종의 <em>what if tree</em> 입니다. </p>

<ul>
<li>The start state is the root node</li>
<li>Children correspond to successors</li>
<li>Nodes show states, but correspond to <strong>PLANS</strong> that achieve those states</li>
<li>For most problems, we can never actually build the whole tree</li>
</ul>

<p><em>general tree search</em> 알고리즘은</p>

<pre><code>function TREE-SEARCH(problem, strategy) returns a solution, or failure

  initialize the search tree using the initial state of problem

  loop do
    if there are no candidates for expansion 
      then return failure

    choose a leaf node for expansion according to strategy

    if the node contains a goal state
      then return the corresponding solution
      else expand the node and 
           add the resulting nodes to the search tree

  end
</code></pre>

<p>여기서 중요한 요소는 <em>fringe (현재 고려중인 nodes)</em>, <em>expansion</em>, <em>exploration strategy</em> 다. 특히 어떤 <em>fringe nodes</em> 를 선택할 것인가가 중요한 질문이 됩니다.</p>

<p>널리 알려진 방법으로 <em>Depth-First Serach</em>, <em>Breadth-First Search</em> 등이 있습니다. 이들 <em>search algorithm</em> 의 성능을 평가하기 위해 다음 요소를 고려할 수 있습니다. </p>

<ul>
<li><strong>complete:</strong> guaranteed to find a solution if one exists</li>
<li><strong>optimal:</strong> guaranteed to find the least cost path</li>
<li>time complexity</li>
<li>space complexity</li>
</ul>

<p>그리고 <em>DFS</em> 은 <em>branching factor</em> <code>b</code>, <em>depth</em> <code>m</code> 이라 했을때 </p>

<ul>
<li>At any given time during the search, the number of nodes on the fringe can be no larger than <code>b*m</code></li>
<li>The number of nodes expanded throughout the entire search can be as large as <code>b^m</code></li>
</ul>

<p><em>BFS</em> 알고리즘에서 <em>branching factor</em> <code>b</code>, <em>depth</em> <code>s</code> 라 했을때 </p>

<ul>
<li>At any given time during the search, the number of nodes on the fringe can be large as <code>b^s</code></li>
<li>The number of nodes expanded throughout the entire search can be as large as <code>b^s</code></li>
</ul>

<p>두 방법을 섞은 <em>iterative deepening</em> 이란 알고리즘도 있습니다. <em>limit 1</em> 까지는 <em>DFS</em> 를 돌려보고, 실패하면 <em>limit2</em> 까지 <em>DFS</em> 를 돌려보는 방식입니다. </p>

<p><em>Uniform Cost Search (UCS)</em> 란 것도 있는데 <em>priority queue</em> 를 이용해서 더 낮은 <em>cost</em> 부터 탐색하는 방식입니다. <em>UCS</em> 는 <em>complete</em>, <em>optimal search</em> 입니다. 단점으로는 </p>

<ul>
<li>Explores options in every direction</li>
<li>No information about goal location</li>
</ul>

<p><br/></p>

<p>지금까지 배운 <em>search algorithm</em> 은 모두 <em>uninformed search</em> 입니다. 간단히 정리하면</p>

<ul>
<li>search operates <strong>over models of the world</strong></li>
<li>the agent doesn't actually try all the plans out in the real world</li>
<li>planning in all <strong>"in simulation"</strong></li>
<li><strong>your search is only as good as your models</strong></li>
</ul>

<p>위에서 본 <em>search algorithm</em> 은 <em>fringe strategies</em> 만 다르고 모두 동일합니다. 개념상으로는 모든 <em>fringes</em> 는 <em>priority queue</em>  입니다. <em>DFS</em> 와 <em>BFS</em> 의 경우에는 각각 <em>stack</em>, <em>queue</em> 를 이용해서 <em>priority queue</em> 의 <em>log(n)</em> 오버헤드를 피할 수 있습니다.</p>

<p><br/></p>

<h3 id="informedsearch">Informed Search</h3>

<p>이번시간에는 <em>state</em> 의 정보를 이용하는 <em>informed search</em> 와 <em>graph search</em> 를 배웁니다. <em>informed search</em> 의 기본적인 아이디어는 <em>direction</em> 을 결정할때, <em>goal</em> 에 가까운 방향인지를 알 수 있는 정보를 이용하는 것입니다.</p>

<p>(1) <strong>informed search</strong></p>

<ul>
<li>heuristics</li>
<li>greedy search</li>
<li>A* search</li>
</ul>

<p>(2) <strong>Graph Search</strong></p>

<p><br/></p>

<h3 id="searchheuristics">Search Heuristics</h3>

<p><em>A heuristic is:</em></p>

<ul>
<li>A function that <strong>estimatees</strong> how close a state is to a goal</li>
<li>Designed for a particular search problem</li>
</ul>

<p>문제에 따라 <em>heuristics</em> 는 다릅니다. 루마니아 투어 문제의 경우 <em>직선거리</em> 가 될 수 있고, 팬케잌 문제(하노이탑) 의 경우 잘못 올려진 팬케잌의 수가 <em>heuristic function</em> 이 될 수 있습니다.</p>

<p>이런 <em>heuristics</em> 을 어떻게 알고리즘에 적용할까요? 하나는 <em>DFS</em> 처럼 같은 <em>sibling</em> 사이에서 더 낮은 <em>heuristics</em> 값을 가지는 <em>fringe</em> 를 선택하는 방법이 있습니다. 이걸 <em>greedy search</em> 라 부릅니다.</p>

<p>반면 <em>BFS</em> 처럼 같은 <em>heuristics</em> 값을 가지는 모든 <em>fringe</em> 를 탐색할 수도 있습니다. 이걸 <em>A* search</em> 라 부릅니다.</p>

<p><br/></p>

<h3 id="greedysearch">Greedy Search</h3>

<p><em>greedy search</em> 는 <em>heuristic</em> <em>(estimate of distance to nearest goal for each state)</em> 을 이용해서 <em>fringe</em> 를 선택하지만, <em>DFS</em> 처럼 <em>badly-guided</em> 될 수 있습니다. 항상 <em>optimal</em> 한 솔루션을 찾아주진 않는다는 이야기입니다.</p>

<p></br></p>

<h3 id="asearch">A* Search</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/artificial-intelligence/search/ucs_plus_greedy.jpg'  alt="" /></p>

<p><em>A* Search</em> 는 <code>f(n) = g(n) + h(n)</code> 을 이용합니다. 즉, 지금까지 온 거리 <code>g(n)</code> 과 앞으로 남은 (예측) 거리 <code>h(n)</code> 을 더한 값을 이용해서 어떤 <em>fringe</em> 를 선택할지 결정합니다. </p>

<p><em>A*</em> 와 관련해서 생각해 볼 한가지는 <em>goal fringe</em> 를 <em>enqueue</em> 할 때가 아니라 <em>dequeue</em> 할때 <em>stop</em> 해야한다는 것 입니다. 이는 현재 <em>queue</em> 에 있는 것중 <em>goal</em> 까지 더 작은 <code>g(n)</code> 을 가진 <em>fringe</em> 가 존재할 수 있기 때문이죠.</p>

<p><em>A* search</em> 는 <em>admissible</em> 하면 <em>optimal</em> 입니다. 여기서 <em>admissible (optimistic)</em> 하다는 뜻은 <em>heuristics</em> 값 <code>h(n)</code>이 절대로 실제 <em>cost</em> <code>h*(n)</code> 보다 높지 않다는 뜻입니다. (always underestimate)</p>

<p><code>0 &lt;= h(n) &lt;= h*(n)</code></p>

<ul>
<li><strong>Inadmissible (pessimistic)</strong> heuristics <strong>break</strong> optimality by trapping good plans on the fringe</li>
<li><strong>Admissible (optimistic)</strong> heuristics slow down bad plans but never outweigh true costs</li>
</ul>

<p><br/></p>

<p><em>uniform-cost search</em> 와 <em>A* search</em> 를 기하학적으로 비교해보면, <em>UCS</em> 는 정원의 등고선을 그리며 <em>goal</em> 을 탐색하지만 <em>A*</em> 는 <em>goal</em> 쪽으로 기운 타원형태의 등고선이 만들어집니다.</p>

<p>정리하자면</p>

<ul>
<li><strong>DFS, BFS:</strong> uninformed search, don't consider cost</li>
<li><strong>UCS:</strong> uninformed search, only consider cost</li>
<li><strong>Greedy search:</strong> informed search, only consider heuristic</li>
<li><strong>A* search:</strong> informed search which uses both cost and heuristic</li>
</ul>

<p><br/></p>

<h3 id="admissibleheuristics">Admissible Heuristics</h3>

<p>어려운 <em>search problem</em> 을 최적으로 풀어내려면 <em>admissible heuristics</em> 를 만들어야 하는데, 이 <em>admissible heuristics</em> 은  본래 문제에서 <em>constaints</em> 가 조금 줄어들어 새로운 <em>action</em> 을 사용할 수 있는 <em>relaxed problem</em> 의 솔루션이 될 수 있습니다. </p>

<p>그리고 <em>inadmissible heuristic</em> 도 때로는 유용할 수 있습니다. <em>optimal solution</em> 이 꼭 필요하지 않다면요. </p>

<p>그러나 이번에는 <em>admissible heuristics</em> 을 만드는 연습을 해보겠습니다. <em>8 puzzle</em> 을 <em>search problem</em> 으로 해서요. 먼저 해야 할 질문은</p>

<ul>
<li>What are the states?</li>
<li>How many states?</li>
<li>What are actions?</li>
<li>How many successor from the start state?</li>
<li>What should the costs be?</li>
</ul>

<p>(1) 만약 <em>heuristic</em> 을 <em>number of tiles misplaced</em> 로 한다면, 이건 <em>admissible</em> 일까요? </p>

<p>당연히 <em>admissible heuristic</em> 입니다. 왜냐하면 어느 <em>action</em> 도 한번에 <code>1</code> 개 이상의 타일을 옮길 수 없으니까요. 그런데 이건 <em>relaxed problem heuristic</em> 입니다. 최대 <code>8</code> 번만에 문제를 풀려면 타일을 직접 정확한 위치에 붙여야 합니다. 부직포 붙이듯이요.</p>

<p>(2) 만약 타일을 직접 목적지로 한번에 움직이진 않지만, 다른 타일을 무시하고 움직일 수 있다면 어떨까요? 아까보단 <em>less relaxed</em> 하다고 생각해봅시다. 이 경우 <em>manhattan distance</em> 를 이용할 수 있습니다.   이것도 마찬가지로 <em>relaxed heuristic</em> 이지만 아까보단 좀 덜 루즈합니다. </p>

<p>아까보다는 <em>heuristic</em> <code>h</code> 값이 더 커졌으니까, 가장 정확한 <em>heuristic</em> (actual cost) 값은 이것보다는 적어도 크다고 생각할 수 있습니다. 일종의 <em>lower bound</em> 라고 보면 쉽습니다. </p>

<p>그리고 <em>heuristic</em> 이 더 정확해졌기 때문에, <em>expanded nodes</em> 수도 이전보다 훨씬 줄어들게 됩니다.</p>

<p>(3) <em>actual cost</em> 를 <em>heuristic</em> 으로 사용하면 어떨까요? 이 값은 당연히 <em>admissible</em> 합니다. <code>h(n) = h*(n)</code> 이니까요. 게다가 <em>expanded nodes</em> 수도 가장 적습니다. </p>

<p>다만 문제는, 가장 정확한 <em>heuristic</em> 이기 때문에 매 턴마다 이 값을 계산하기 위한 연산 비용이 비쌉니다. 이것이 <em>A*</em> 알고리즘이 가진 <em>trade-off</em> 입니다. <em>quality of estimate</em> 와 <em>work per node</em>  를 적절히 조절해서 <em>heuristic</em> 을 만들어야 합니다.</p>

<blockquote>
  <p>As heuristics get closer to the true cost, you will expand fewer nodes but usually do more work per node to compute the heuristic itself</p>
</blockquote>

<p>나침반을 보고 길을 찾을때, <em>loose heuristic</em> 은 좀 더 넓은 범위에서 맞다고 알려주어 이용하기 쉽다면, <em>actual cost</em> 의 경우에는 나침반이 제시하는 올바른 방향이 너무나 작기때문에 자세히 보고, 여러번봐야 하는것과 비슷합니다.</p>

<p>정리하자면 <em>heuristic</em> 이 <em>actual cost</em> 에 가깝다고 해서 반드시 좋은건 아닙니다. 연산시간을 고려하면 적정 수준의 <em>loose heuristic</em> 을 사용할 필요가 있습니다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/artificial-intelligence/search/heuristic_dominance.jpg'  alt="" /></p>

<p>모든 <em>heuristic</em> 값이 더 크면 <em>dominance</em> 라고 말합니다. 다시 말해 더 정확한, <em>actual cost</em> 에 가깝다는 뜻입니다. 그리고 <em>admissible</em> 한 두 <em>heuristics</em> 에 대해 그 <em>max</em> 값도 당연히 <em>admissible</em> 합니다.</p>

<p><em>bottom lattice</em> 를 <em>zero heuristic</em>, <em>top</em> 을 <em>exact</em> 라 부릅니다. 만약 <em>zero heuristic</em> 을 이용하면 <em>uniform-cost search</em> 와 동일합니다.</p>

<h3 id="graphsearch">Graph Search</h3>

<p><em>tree search</em> 는 중복되는 부분에 대해 다시 탐색하므로 비효율적입니다. 이 부분을 개선하기 위해 <strong>모든 state 를 단 한번만</strong> <em>expand</em> 할 수 있습니다. <em>set of expanded states</em> 를 유지하고, <em>state</em> 를 탐색하기 전에 이미 <em>expanded</em> 되었는지 검사하면 됩니다.</p>

<p><em>graph search</em> 는 <em>completeness</em> 엔 문제가 없으나 <em>not-optimal</em> 일 수 있습니다. 아래 예제를 보면 <em>sub-optimal solution</em> 을 리턴합니다. <em>admissible heuristic</em> 임에도 불구하고요.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/artificial-intelligence/search/a_star_graph_suboptimal.jpg'  alt="" /></p>

<p><br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/artificial-intelligence/search/consistency.jpg'  alt="" /></p>

<p>이건 <em>consistency</em> 속성이 만족되지 않아서 그렇습니다. <em>goal</em> 까지의 <em>admissibility</em> 뿐만 아니라, 각 <em>arc</em> 마다도 <code>h &lt;= actual cost</code> 를 만족하면 <em>consistent</em> 하다고 말합니다. 만약 <em>heuristic</em> 이 <em>consistent</em> 하면 <em>f value</em> 가 절대로 줄지 않기 때문에 결과적으로 <em>graph search</em> 를 통한 결과도 <em>optimal</em> 이 됩니다.</p>

<ul>
<li><em>Fact 1:</em> In tree search, A* expands nodes in increasing total <em>f value</em> (<strong>f-contours</strong>)</li>
<li><em>Fact 2:</em> For every state <code>s</code>, nodes that reach <code>s</code> optimally are expanded before nodes that reach <code>s</code> suboptimally</li>
</ul>

<p><br/></p>

<h3 id="optimality">Optimality</h3>

<p>(1) Tree Search</p>

<ul>
<li>만약 <em>heuristic</em> 이 <em>admissible</em> 이면 A* 는 <em>optimal</em> 입니다</li>
<li><em>UCS</em> 는 <code>h = 0</code> 인 <em>special case</em> 입니다</li>
</ul>

<p>(2) Graph Search</p>

<ul>
<li>만약 <em>heuristic</em> 이 <em>consistent</em> 이면, A* 는 <em>optimal</em> 입니다.</li>
<li><em>UCS</em> 도 <code>h = 0</code> 이어서 <em>consistent heuristic</em> 이므로 <em>optimal</em></li>
</ul>

<blockquote>
  <p>Consistency implies admissibility</p>
</blockquote>

<p>일반적으로 대부분의 <em>natural admissible heuristic</em> 는 <em>consistent</em> 합니다. 특히 <em>relaxed problems</em> 에서 나왔다면 더더욱요</p>

<p><br/></p>

<h3 id="refs">Refs</h3>

<p>(1) <strong>Artificial Integelligence (CS 188)</strong> by <em>Dan Klein, Pieter Abbeel</em> <br />
(2) <a href='http://imgkid.com/cute-box-robot-tumblr.shtml' >Title Image</a>  </p>]]></description><link>http://1ambda.github.io/artificial-intelligence-2/</link><guid isPermaLink="false">82a14f90-2790-4df3-bef8-a080f0141d64</guid><category><![CDATA[edx]]></category><category><![CDATA[artificial intelligence]]></category><category><![CDATA[CS188]]></category><category><![CDATA[search]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 19 Feb 2015 06:59:46 GMT</pubDate></item><item><title><![CDATA[Artificial Intelligence 1, Intro]]></title><description><![CDATA[<p><img src='http://www.land-of-web.com/wp-content/uploads/2012/08/w30.jpg'  alt="" /></p>

<h3 id="ai"> AI</h3>

<p>사람처럼 행동하는것? 사람처럼 생각하는것? 무엇이 <em>AI</em> 일까?</p>

<blockquote>
  <p>Act Rationally</p>
</blockquote>

<p>여기서 <em>rational</em> 은</p>

<ul>
<li>Maximally achieving pre-defined goals</li>
<li>Rationality only concerns what decisions are made. not the thought process begind them</li>
<li>Goals are expressed in terms of the utility of outcomes</li>
</ul>

<p>따라서 <em>rational</em> 의 의미는 <strong>maximizing your expected utility</strong> </p>

<p><br/></p>

<h3 id="brain">Brain</h3>

<p>인간의 뇌는 <em>rational decision</em> 을 내리는데 상당히 뛰어나지만, 완벽하지는 않다. 이런 <em>brain</em> 를 모방해서 인공지능을 만들어보려 했지만 뇌는 <em>software</em> 만큼 <em>modular</em> 하지 않기 때문에 <em>reverse engineering</em> 해서 인공지능을 만들긴 어려웠다.</p>

<p>과학자들이 뇌를 분석하는 과정에서 얻은 <em>lessons learned</em> 는 <strong>memory</strong> 와 <strong>simuation</strong> 이 <em>decision making</em> 에서 아주 중요한 요소라는 것이다.</p>

<p><br/></p>

<h3 id="whatcanaido">What Can AI Do?</h3>

<p>(1) <strong>Language</strong></p>

<ul>
<li>Translation</li>
</ul>

<p>(2) <strong>Vision (Perception)</strong></p>

<ul>
<li>Object and face recognition</li>
<li>Scene segmentation</li>
<li>Image classification</li>
</ul>

<p>(3) <strong>Robotics</strong></p>

<ul>
<li>Vehicles</li>
<li>Rescure</li>
<li>Soccer!</li>
<li>Lots of automations</li>
</ul>

<p>(4) <strong>Logic</strong></p>

<ul>
<li>Theorem provers</li>
<li>NASA fault diagnosis</li>
<li>Question answering</li>
</ul>

<p>(5) <strong>Game Playing</strong></p>

<p>(6) <strong>Decision Making</strong></p>

<ul>
<li>Scheduling (e.g airline routing)</li>
<li>Route Planning (e.g Google maps)</li>
<li>Medical diagnosis</li>
<li>Web search engines</li>
<li>Spam classifiers</li>
<li>Automated help desks</li>
<li>Fraud dections</li>
<li>Productrecommendations</li>
<li>Lots more!</li>
</ul>

<p><br/></p>

<h3 id="designingrationalagents">Designing Rational Agents</h3>

<p>CS188 에서는 <em>rational agent</em> 를 디자인하는 방법을 배운다. <em>rational agent</em> 란 <em>행동(act)</em> 과 <em>인지 (perceive)</em> 를 할 수 있는 <em>개체 (entity)</em> 다. 즉, <em>환경 (environment)</em> 를 인식해서 그에 맞는 판단을 내린 후 행동하는 소프트웨어로 볼 수 있다. </p>

<ul>
<li>A <strong>rational agent</strong> selects actions that maximize its (expected) <strong>utility</strong></li>
<li>Characteristics of the <strong>percepts</strong>, <strong>environment</strong>, and <strong>action space</strong> dictate techniques for selecting rational actions</li>
</ul>

<p>이 수업에서 배우는 것은 어떤 <em>environment</em> 와 어떤 <em>percept</em> 를  가지고 있는지를 파악한 후, 이와 관련된 기존의 테크닉을 이용해서 <em>언제</em>, <em>어떻게</em> 문제를 풀 수 있는지를 배운다.</p>

<p><br/></p>

<h3 id="coursetopics">Course Topics</h3>

<p>Part 1: <strong>Making Decisions</strong></p>

<ul>
<li>Fast search / planning</li>
<li>Constraint satisfaction</li>
<li>Adversarial and uncertain search</li>
</ul>

<p>Part 2: <strong>Reasoning under Uncertainty</strong></p>

<ul>
<li>Bayer' nets</li>
<li>Decision theory</li>
<li>Machine learning</li>
</ul>

<p>Throughout: <strong>Applications</strong></p>

<ul>
<li>Natural language processing</li>
<li>Vision</li>
<li>Robotics</li>
<li>Games</li>
</ul>

<p><br/></p>

<h3 id="refs">Refs</h3>

<p>(1) <strong>Artificial Integelligence (CS 188)</strong> by <em>Dan Klein, Pieter Abbeel</em> <br />
(2) <a href='http://www.land-of-web.com/inspiration/photography/meet-the-danbo-cute-little-cardboard-robot-photos.html' >Title Image</a>  </p>]]></description><link>http://1ambda.github.io/artificial-intelligence-1/</link><guid isPermaLink="false">a5116bfa-3786-420b-860a-a78024e945aa</guid><category><![CDATA[edx]]></category><category><![CDATA[artificial intelligence]]></category><category><![CDATA[CS188]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 19 Feb 2015 04:51:28 GMT</pubDate></item><item><title><![CDATA[Cloud Computing, MapReduce]]></title><description><![CDATA[<p><img src='http://ook.co/wp-content/uploads/cloudcomputing.png'  alt="" /></p>

<h3 id="intro">Intro</h3>

<p><em>map</em> 과 <em>reduce</em> 라는 단어는 <em>functional language</em> 에서 왔다.</p>

<ul>
<li><em>map:</em> processes each record sequentially and independently</li>
<li><em>reduce:</em> processes set of all records in batches</li>
</ul>

<pre><code class="lisp">(map square '(1 2 3 4))
;; (1 4 9 16)

(reduce + '(1 4 9 16))
;; (+16 (+9 (+4 1)))
;; 30
</code></pre>

<p><br/></p>

<h3 id="mapreduce">MapReduce</h3>

<p><img src='http://webmapreduce.sourceforge.net/docs/User_Guide/images/map-reduce.png'  alt="" /></p>

<p align="center">(<a href='http://webmapreduce.sourceforge.net/' >http://webmapreduce.sourceforge.net/</a>)</p>

<blockquote>
  <p><em>Map:</em> <strong>Parallelly</strong> process <strong>a large number</strong> of individual records to generate intermediate key/value pairs
  <br/> <br />
  <em>Reduce:</em> processes and merges all intermediate values associated per key</p>
</blockquote>

<p>각 키는 하나의 <em>reducer</em> 에 할당되고, <em>partitioning keys</em> 에 의해 <em>reduce</em> 가 진행된다. 자주 쓰이는 기법으로 <em>hash partitioning</em> 이 있다. <code>hash(key) % # of reduce servers</code></p>

<pre><code class="java">public static class MapClass extends MapReduceBase  
            implements Mapper&lt;LongWriteable, Text, Text, IntWritable&gt; {

  private final static IntWritable one = new IntWritable(1);
  private Text word = new Text();

  public void map(LongWritable key, Text value, 
                  OutputCollector&lt;Text, IntWritable&gt; output,
                  Reporter reporter) throws IOException {

    String line = value.toString();
    StringTokenizer itr = new StringTokenizer(line);

    while (itr.hasMoreTokens()) {
      word.set(itr.nextToken());
      output.collect(word, one);
    }
  }
}

public static class ReduceClass extends MapReduceBase  
            implements Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {

  public void reduce(Text key, Iterator&lt;IntWritable&gt; values,
                     OutputCollector&lt;Text, IntWritable&gt; output,
                     Reporter reporter) throw IOException {

    int sum = 0;
    while (values.hasNext()) {
      sum += values.next().get();
    }

    output.collect(key, new IntWritable(sum));
  }                     
}

public void run(String inputPath, String outputPath) throw Exception {

  // The job
  JobConf conf = new JobConf(WordCount.class);
  conf.setJobName("mywordcount");

  // The keys are words
  (srings) conf.setOutputKeyClass(Text.class);

  // The values are counts (ints)
  conf.setOutputValueClass(IntWritable.class);
  conf.setMapperClass(MapClass.class);
  conf.setReducerClass(ReduceClass.class);

  FileInputFormat.addInputPat(conf, new Path(inputPath);
  FileOutputFormat.setOutputPath(conf, new Path(outputPath));

  JobClient.runJob(conf);
}
</code></pre>

<p><br/></p>

<h3 id="mapreduceapplication">MapReduce Application</h3>

<p>(1) <strong>Distributed Grep</strong> </p>

<ul>
<li><em>input:</em> large set of files</li>
<li><em>output:</em> lines that match pattern</li>
<li><em>map:</em> emits a line if it matches the supplied pattern</li>
<li><em>reduce:</em> copies the intermediate data to output</li>
</ul>

<p>(2) <strong>Reverse Web-Link Graph</strong></p>

<ul>
<li><em>input:</em> web graph(tuple <code>(a,b)</code> where page <code>a</code> -> page <code>b</code>)</li>
<li><em>output:</em> for each page, list of pages that link to it</li>
<li><em>map:</em> process we log and for each input <code>&lt;source, target&gt;</code>, it outputs <code>&lt;target, source&gt;</code></li>
<li><em>reduce:</em> emits <code>&lt;target, list(source)&gt;</code></li>
</ul>

<p>(3) <strong>Count of URL Access Frequency</strong></p>

<ul>
<li><em>input:</em> log of accessed URLs</li>
<li><p><em>output:</em> for each URL, the number of total accesses for that URL</p></li>
<li><p><em>map:</em> process web log and outputs <code>&lt;URL, 1&gt;</code></p></li>
<li><em>multiple reducers:</em> emits `<URL, URL_count></li>
<li><strong>chain another MapReduce job to calculate</strong> <code>overall_count</code></li>
</ul>

<p>(4) <em>Sort</em></p>

<ul>
<li><em>map</em> task's output is sorted (e.g., <em>quicksort</em>)</li>
<li><em>reduce</em> task's input is osrted (e.g., <em>mergesort</em>)</li>
</ul>

<p>따라서 정렬을 하기 위해</p>

<ul>
<li><em>map:</em> <code>&lt;key, value&gt;</code> -> <code>&lt;value, _&gt;</code> (identity)</li>
<li><em>reduce:</em> <code>&lt;key, value&gt;</code> -> <code>&lt;key, value&gt;</code> (identity)</li>
</ul>

<p>이 때 <em>parttition key</em> 로 <em>range</em> 를 사용하는 것이 가능하다. 다만, 특정 구간에 <em>data</em> 가 몰려있을 수 있으므로 <em>dstiribution</em> 을 고려해 <em>reducer</em> 에게 할당해주면 된다.</p>

<p><br/></p>

<h3 id="scheduling">Scheduling</h3>

<p>일반 <em>user</em> 는</p>

<ul>
<li>Write a Map program, write a Reduce program</li>
<li>Submit job; wait for result</li>
<li>Need to know nothing about parallel/distributed programming</li>
</ul>

<p>그러나 내부적으로는</p>

<ul>
<li>Parallelize Map</li>
<li>Transfer data from Map to Reduce</li>
<li>Parallelize Reduce</li>
<li>Implement Stroage for Map input, Map output, Reduce input, Reduce output</li>
</ul>

<p>그리고 <em>reduce</em> 가 시작되기 전에 반드시 <em>map</em> 이 끝나야 한다. 다시 말해서 <em>map phase</em> 와 <em>reduce phase</em> 사이에는 <em>barrier</em> 가 있어야 한다. 그렇지 않으면 결과가 부정확할 수 있다.</p>

<p>이제 하나하나씩 살펴보자.</p>

<p>(1) <em>Parallelize Map:</em> Easy. Each map task is independent of the other</p>

<p>(2) <em>Transfer data from Map to Reduce:</em> All map output records with same key assigned to same Reduce task. Use <strong>Partitionning Function</strong></p>

<p>(3) <em>Parallelize Reduce:</em> Easy. Each reduce task is independent of the other</p>

<p>(4) <em>Implement Storage for Map input, Map output, Reduce input and Reduce output:</em></p>

<ul>
<li>Map input: from <strong>distributed file system</strong></li>
<li>Map output: to local disk at Map node; Use <strong>local file systems</strong></li>
<li>Reduce input: from (multiple) remote disks; Uses local file systems</li>
<li>Reduce output: to <strong>distributed file system</strong></li>
</ul>

<p>DFS 의 예로 <em>Google File System</em>, <em>HDFS</em> 등이 있다.</p>

<p><br/></p>

<p>하둡은 스케쥴러로 <em>YARN, Yet Another Resouce Negotiator</em>를 사용한다. <em>YARN</em> 은 각 서버를 <em>a collection of containers</em> 로 취급한다. 여기서 <em>container = some CPU + some Memory</em> 다.</p>

<p><em>YARN</em> 은 크게 3파트로 나눌 수 있는데</p>

<ul>
<li><em>Global Resource Manager(RM):</em> scheduling</li>
<li><em>Per-server Node Manager(NM):</em> Daemon and server-specific functions</li>
<li><em>Per-application(job) Application Master(AM):</em> Container negotiation with RM and NMs, Detecting task failures of that job</li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week1/YARN.jpg'  alt="" /></p>

<p><em>container</em> 가 필요하면 <em>AM1</em> 이 <em>RM</em> 에게 알리고, <em>Node B</em> 의 <em>NM2</em> 에서 <em>Task</em> 가 끝나면, <em>RM</em> 이 <em>Node A</em> 의 <em>AM1</em> 에게 사용 가능한 컨테이너가 있다는 사실을 알려 <em>AM1</em> 이 <em>NM2</em> 에게 컨테이너를 사용하겠다는 요청을 보내는 식이다.</p>

<p><br/></p>

<h3 id="faulttolerance">Fault-Tolerance</h3>

<p>(1) Server Failure</p>

<ul>
<li><em>NM</em> hearbeats to <em>RM</em>. If server fails <em>RM</em> lets all affected <em>AMs</em> know, and <em>AMs</em> take action</li>
<li><em>NM</em> keeps track of each task running at its server. If task fails while in-progress, mark the task as idle and restart it</li>
<li><em>AM</em> heartbeats to <em>RM</em>. On failure, <em>RM</em> restarts <em>AM</em>, which then syncs up with its running tasks</li>
</ul>

<p>(2) RM Failure</p>

<ul>
<li>Use old checkpoints and bring up secondary <em>RM</em></li>
<li>Heartbeats also used to piggyback container requests. Avoids extra mesages</li>
</ul>

<p>요약하자면, <em>NM</em>, <em>AM</em> 은 <em>RM</em> 에게 <em>heartbeat</em> 를 보낸다. <em>NM</em> 에서 오류가 나면 <em>RM</em> 이 영향을 받는 <em>AM</em> 에게 알리고, 해당 <em>AM</em> 이 적절히 처리한다. 또한 <em>NM</em> 은 <em>task</em> 를 유지하면서, <em>task</em> 에러가 발생하면 재시작한다. <em>AM</em> 에서 오류가 나면 <em>RM</em> 이 재시작하고, 해당 <em>AM</em> 의 태스크와 싱크를 맞춘다. <em>RM</em> 에서 오류가 날 경우엔 <em>secondary RM</em> 을 이용한다.</p>

<h3 id="stragglers">Stragglers</h3>

<p><em>slow nodes</em> 를 부르는 다른말이다. <em>speculative execution</em> 으로 해결할 수 있다. 보통 느린 이유는 <em>disk</em>, <em>network bandwidth</em>, <em>CPU</em>, <em>memory</em> 등 때문인데 <em>task</em> 를 복제해서 다른 <em>node</em> 에서 돌린 뒤 먼저 완료되는 노드의 결과를 이용하는 방식이다.</p>

<blockquote>
  <p>Perform backup (replicated) execution of straggler task: task considered done when first replica completed</p>
</blockquote>

<h3 id="locality">Locality</h3>

<p><em>cloud</em> 의 <em>hierarchical topology</em> 때문에 <em>GFS</em>, <em>HDFS</em> 등은 각 <em>chunk</em> 를 3군데에 복제한다. 이때 같은 <em>rack</em> 에 위치할수도 아닐수도 있다.</p>

<p><em>MapReduce</em> 연산에서는 <em>map task</em> 를 스케쥴링할때 가능하면 다음의 순서로 배치한다.</p>

<p>(1) <em>chunk</em> 가 있는 머신에 or failing that <br />
(2) 아니면 같은 <em>rack</em> 에 or failing that <br />
(3) Anywhere  </p>

<p><br/></p>

<h3 id="summary">Summary</h3>

<p>(1) MapReduce uses parallelization + aggregation to schedule applications across clusters.</p>

<p>(2) Need to deal with failure</p>

<p>(3) Plenty of ongoing research work in scheduling and fault-tolerance for Mapreduce and Hadoop</p>

<p><br/></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href='http://ook.co/solutions/cloud-computing/' >Title Image</a> <br />
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera <br />
(3) <a href='http://webmapreduce.sourceforge.net/docs/User_Guide/sect-User_Guide-Introduction-What_is_Map_Reduce.html' >MapReduce Image</a>  </p>]]></description><link>http://1ambda.github.io/cloud-computing-1-1/</link><guid isPermaLink="false">663ff3ef-8d2f-4c15-8897-90acbda32548</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[MapReduce]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 13 Feb 2015 12:34:11 GMT</pubDate></item><item><title><![CDATA[Coding The Matrix 1, Function, Field and Vector]]></title><description><![CDATA[<p><img src='http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg'  alt="" /></p>

<h3 id="thefunction">The Function</h3>

<blockquote>
  <p><strong>Function Invertibility Theorem:</strong> A function <code>f</code> is invertible if and only if it is <strong>one-to-one</strong> and <strong>onto</strong></p>
</blockquote>

<p><br/></p>

<h3 id="thefield">The Field</h3>

<pre><code class="pyhon">In [6]: 1+3j + (10+20j)  
Out[6]: (11+23j)

In [7]: x = 1+3j

In [8]: (x-1)**2  
Out[8]: (-9+0j)

In [9]: x.real  
Out[9]: 1.0

In [10]: x.imag  
Out[10]: 3.0

In [11]: type(1+2j)  
Out[11]: complex  
</code></pre>

<blockquote>
  <p>Such a collection of "numbers" with <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> is called a <strong>field</strong>. Different fields are like different classes obeying the same interface</p>
</blockquote>

<p><em>field</em> <code>C</code> 는 <em>complex numbers</em> 다. 이걸 공부해야 하는 이유는</p>

<ul>
<li><code>C</code> is similar enough to <code>R</code> to be familiar but different enough to illustrate the idea of a filed</li>
<li>Complex numbers are intellectual ancestors of vectors</li>
<li>In more advanced parts of linear algebra, complex numbers play an important role</li>
</ul>

<p><br/></p>

<h3 id="playingwithc">Playing with C</h3>

<p><em>complex numbers</em> <code>C</code> 상에서는 한 축이 <em>real number</em>, 다른 축이 <em>imagenary number</em> (<em>python</em> 에선 <code>j</code> 로 표시) 다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/c_function_composition.jpg'  alt="" /></p>

<p>이 때 <em>translation</em> <code>f = z + z0</code> 를 <em>arrow</em> 처럼 볼 수 있다. <code>z0</code> 에서 시작해서 <code>z + z0</code> 를 향하는 화살표로</p>

<p>따라서 <code>f1(z) = z + z1</code>, <code>f2(z) = z + z2</code> 가 있을때 <em>function composition</em> <code>(f1 * f2)(z)</code> 는, <em>adding arrow</em> 처럼 생각할 수 있다.</p>

<p><a href='http://resources.codingthematrix.com/' >http://resources.codingthematrix.com/</a> 여기서 준비물을 구하고 아래 코드를 실행해 보자.</p>

<pre><code>In [1]: from plotting import plot

In [2]: L = [2+2j, 3+2j, 1.75+1j, 2+1j, 2.25+1j, 2.5+1j, 2.75+1j, 3+1j, 3.25+1j]

In [3]: plot(L)

In [4]: plot({z/2 for z in L})  
</code></pre>

<p>벡터와 비슷하게 스케일링은 양수를 곱하면 된다. <em>arrow</em> 를 뒤집고 싶으면 <code>-1</code> 을 곱하면 되고, </p>

<p>반시계방향으로 90도 <em>rotation</em> 을 원하면 <code>f(z) = iz</code> <em>translation</em> 을 사용하면 된다. <code>x+yi</code> 가 <code>-y+xi</code> 가 된다.</p>

<p><em>complex number</em> 에서는 <code>z</code> 와 <code>1 + 0i</code> 의 각도를 <em>argument</em> 라 부르는데, 이를 구하기 위한 공식을 오일러가 만들어 두었다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/argument_def.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/euler_argument.jpg'  alt="" /></p>

<p>어느 <em>real number</em> <code>θ</code> 에 대해서, <code>e^(θi)</code> 가 단위 원 위의 <em>argument</em> <code>θ</code> 를 가진 점 <code>z</code> 가 된다.</p>

<p>따라서 <code>θ = π</code> 일때, <code>e^(πi) = -1</code> 이다.</p>

<pre><code class="python">In [1]: from plotting import plot  
In [2]: from math import e, pi  
In [3]: plot([e**(t*2*pi*1j/20) for t in range(20)])  
</code></pre>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/rotation.jpg'  alt="" /></p>

<p>따라서 기존 <code>z</code> 값에 원하는 라디안 값 <code>k</code> 만큼 <code>e^(ki)</code> 를 곱해주면 <em>exponentiation law</em> 에 의해서, 그만큼 회전한다.</p>

<pre><code class="python">In [11]: plot([e**(pi*1j/4) * z for z in L])  
</code></pre>

<p><br/></p>

<h3 id="playingwithgf2">Playing with GF(2)</h3>

<p><em>Galois Field 2</em> has just two elements <code>0</code> and <code>1</code></p>

<p><em>GF(2)</em> 에서는 특이하게도 <em>addition</em> 이 <em>XOR</em> 과 같다. <em>multiplication</em> 나 <em>usual algebraic laws</em> (e.g multiplication distribution) 는 기존과 동일하다.</p>

<pre><code class="python">In [1]: from GF2 import one

In [2]: def encrypt(p, k): return p+k

In [3]: k = one

In [4]: p = one

In [5]: c = en  
%env       encrypt    enumerate

In [5]: c = encrypt(p, k)

In [6]: c  
Out[6]: 0  
</code></pre>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/encryption.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/encryption2.jpg'  alt="" /></p>

<p>더 자세히는, <code>p</code> 를 어떻게 선택하는지는 <code>c</code> 의 <em>probability distribution</em> 에 영향을 주지 않기때문에 <em>Eve</em> 가 <code>c</code> 를 관찰한다 할지라도 <code>p</code> 에 대해 정보를 얻을 수 없다.</p>

<p>왜 이 <em>cryptosystem</em> 이 <em>perfect secrecy</em> 를 만드는걸까? </p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/perfect_secrecy1.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/perfect_secrecy2.jpg'  alt="" /></p>

<p><code>p = 0</code> 에 대해 <code>k</code> 를 받아 <code>c</code> 를 돌려주는 함수를 <code>f0</code> 이라 하면, <code>f0</code> 은 <em>one-to-one,  onto function</em> 이다. 따라서 <code>k</code> 를 선택하는 확률이 균일하다면 <code>c</code> 의 확률도 <em>uniformly distribution</em> 이다. <code>f1</code> 도 마찬가지다.</p>

<p>이 아이디어가 <em>one-time pad</em> 라는 <em>cryptosystem</em> 의 근간이다.</p>

<blockquote>
  <p>If each bit is encrypted with its own one-bit key, the cryptosystem is <strong>unbreakable</strong></p>
</blockquote>

<p><br/></p>

<p><em>GF(2)</em> 를 <em>network coding</em> 에도 사용할 수 있다. 커스터머 <code>c</code>, <code>d</code> 에게 동시에 <em>video streaming</em> 을 하면 중간지점에서 병목이 발생할 수 있는데 <code>b1 + b2</code> 를 더해 나중에 <code>c</code> 와 <code>d</code> 에서 <em>substraction</em> 을 이용해 원래 비트를 구하면 된다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/network_coding.jpg'  alt="" /></p>

<p><br/></p>

<h3 id="vector">Vector</h3>

<p><em>quaternions</em> (4원수) 에 관한 이야기부터 시작한다.</p>

<blockquote>
  <p>해밀턴은 복소수가 2차원 평면상의 점으로 표현될 수 있다는 사실로부터, 3차원 공간에서 점을 표현하는 같은 방법을 찾으려 하였다. 3차원 공간에서의 정점은 3개의 수로 이루어지며, 해밀턴은 그 3개의 수들을 어떻게 더하고 곱할 수 있는지에 관해 생각해왔다. 그러나 그는 두개의 정점간의 나누기를 어떻게 정의할지 알지 못했고, 난관에 부딪히고 말았다.</p>
  
  <p>1843년 10월 16일, 해밀턴은 그의 아내와 더블린의 로열 운하(영어: Royal Canal, 아일랜드어: An Chanáil Ríoga)을 걷고 있었다. 브로엄 다리(Brougham Bridge, 현재는 브룸 다리 Broom Bridge)를 걷고 있을 때, 나누기에 관한 해답이 그의 뇌리를 스쳤다. 그는 3개의 요소(Triples)를 나누지는 못하지만, 4개의 요소(quadruples)를 나눌 수 있다는 걸 생각했다. 4개의 요소 중, 3요소를 이용해 3차원 공간의 정점을 표현 할 수 있다. 해밀턴은 3차원 공간상의 정점에 대한 그의 새로운 수체계를 표현할 수 있었다. 그는 이 수체계의 기본 규칙을 다리에 새겨놓았다.</p>
  
  <p><code>i^2 = j^2 = k^2 = ijk = -1</code></p>
  
  <p>해밀턴은 위의 기본적인 규칙을 적용한 4개의 요소를 "사원수"라고 명명했다. 그 후 그는 사원수를 연구하고 알리는데 그의 남은 여생을 바쳤다. 그는 "사원수론자"(Quaternionists)라는 학파를 창시하고, 몇권의 책을 출판하여 사원수를 전파시켰다. 그의 마지막 책 《사원수 원론》(Elements of Quaternions)는 800여 쪽으로 구성되어 있고, 해밀턴 사망 직후에 출판되었다.</p>
  
  <p>해밀턴의 죽음 이후, 그의 제자인 피터 거스리 테이트는 사원수의 연구를 계속하였다. 당시 더블린에서는 사원수가 의무적인 시험의 하나였다. 현재는 공간 운동학, 맥스월 방정식 등의 벡터를 이용하여 설명하는 물리와 기하학의 논제들은 그 당시에는 모두 사원수를 이용하여 설명되었다. 또한 사원수에 관한 전문적인 연구학회인 사원수 학회(영어: The Quaternion Society)도 존재하였다.</p>
  
  <p>1880년대 중반부터 조사이어 윌러드 기브스와 올리버 헤비사이드가 제안한 벡터 해석학이 사원수 표현을 대신하기 시작했다. 벡터는 사원수와 같은 현상을 설명하였기 때문에, 고전 사원수 연구에서 많은 아이디어와 용어 등을 빌려왔다. 그러나 벡터 해석이 보다 간결한 개념과 표기법을 가지고 있었기에 사원수는 수학과 물리에서 비주류가 되었다. 이는 해밀턴의 사원수가 이해하기 난해하고, 표기가 친숙하지 않았으며, 그의 저작물에 길고 불분명한 표현이 많았기 때문이다.</p>
  
  <p>그러나 사원수는 20세기 말에 공간상에서의 회전에 관한 사원수의 유용성에 의해서 다시 주목받기 시작했다. 사원수를 이용한 회전의 표현은 행렬을 사용하는 표현에 비해 더욱 간결했고 계산이 빨랐다. 이런 이유로, 사원수는 컴퓨터 그래픽, 제어이론, 신호처리, 자세제어(attitue control), 물리학, 생물정보학, 분자동역학, 컴퓨터 시뮬레이션, 궤도역학(orbital mechanics)등에 사용되고 있다. </p>
</blockquote>

<p></br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/vectors_are_functions.jpg'  alt="" /></p>

<p><em>vector</em> 를 정의역(<em>domain</em>) 에서 치역(<em>image</em>) 로 대응되는 일종의 <em>function</em> 이라 볼 수 있다. <em>python</em> 에서는 <em>dictionary</em> 로 쉽게 나타낼 수 있다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/sparsity.jpg'  alt="" /></p>

<p><em>vector</em> 에서 <code>0</code> 이 많으면 <em>sparse vector</em> 라 부르고, <code>k</code> 개 만큼만 <code>0</code> 이 아닌 원소가 있으면 <em>k-sparse</em> 라 부른다. <em>vector</em> 의 몇번째 원소가 <code>0</code>이 아닌지를 나타내야되기 때문에 <em>k-sparse vector</em> 는 <em>k proportional space</em>  가 필요하다. </p>

<p><em>physical sensors</em> 로 얻어지는 <em>signal</em> 은 대부분 <em>sparse vector</em> 가 아니기 때문에 공간을 아끼기 위해, <em>signal</em> 을 <em>lossy compression</em> 으로 압축해서 보내는 법을 강의 후반부에서 배울 것이다.</p>

<p><br/></p>

<h3 id="additionmultiplication">Addition, Multiplication</h3>

<pre><code class="python">In [1]: from plotting import plot  
In [2]: v = [3, 2]  
In [3]: def scalar_vector_mult(alpha, v): return [alpha * x for x in v]  
In [4]: plot([scalar_vector_mult(i/10, v) for i in range(11)])  
</code></pre>

<p><img src='http://latex.codecogs.com/gif.latex?%5Calpha%5B3%2C%202%5D%20&plus;%20%5B0.5%2C%201%5D%20%5C%5C%20%3D%20%5Calpha%28%5B3.5%2C%203%5D%20-%20%5B0.5%2C%201%5D%29%20&plus;%20%5B0.5%2C%201%5D%20%5C%5C%20%3D%20%5Calpha%5B3.5%2C%203%5D%20-%20%5Calpha%5B0.5%2C%201%5D%20&plus;%20%5B0.5%2C%201%5D%20%5C%5C%20%3D%20%5Calpha%5B3.5%2C%203%5D%20-%20%281%20-%20%5Calpha%29%5B0.5%2C%201%5D%20%5C%5C%20%3D%20%5Calpha%5B3.5%2C%203%5D%20-%20%5Cbeta%5B0.5%2C%201%5D%20%5C%5C%20%5C%5C%20%28where%5C%20%5Calpha%2C%20%5Cbeta%20%3E%200%2C%20%5C%20%5Calpha%20&plus;%20%5Cbeta%20%3D%201%29'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/convex_comb.jpg'  alt="" /></p>

<p><em>arbitrary line segment</em> 를 <em>addition</em>, <em>multiplication</em> 을 이용해 <code>a[3, 2] + [0.5, 1]</code> 처럼 표현할 수 있는데, 여기서 식을 좀 더 변형해 <em>convex combination</em> 을 만들 수 있다. 이걸 이용하면 <code>u, v</code> 의 비중이 얼마냐에 따라 <em>output</em> 이 어떻게 달라지는지를 쉽게 표현할 수 있다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/convex_comb_ex.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/affine_comb.jpg'  alt="" /></p>

<p><code>[0.5, 1]</code> 부터 <code>[3.5, 3]</code> 까지 <em>infinite line</em> 을 표현하기 위해 <em>affine combination</em> 을 이용할 수 있다. 더 자세한 내용은 <a href='http://en.wikipedia.org/wiki/Linear_combination' >Wiki: line combination</a> 을 참고하자</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/line_comb.jpg'  alt="" /></p>

<p></br></p>

<h3 id="dictionarybasedrepresentation">Dictionary-based Representation</h3>

<p>앞서 언급했듯이 <em>vector</em> 는 <em>domain</em> <code>D</code> 로 부터 어떤 <em>field</em> 로 <em>mapping</em> 하는 <em>function</em> 이다. 파이썬에서는 이런 <em>function</em> 을 <em>dictionary</em> 로 표현할 수 있다.</p>

<pre><code class="python">class Vec:  
    def __init__(self, domain, function):
        self.D = domain
        self.f = function


def zero_vec(D):  
    return Vec(D, {d: 0 for d in D})


def setItem(v, d, val):  
    v.f[d] = val


def getItem(v, d):  
    return v.f[d] if d in v.f else 0


def list2vec(L):  
    return Vec(set(range(len(L))), {k:v for k, v in enumerate(L)})

# vec test
v = Vec({'A', 'B', 'C'}, {'A': 1})  
for d in v.D:  
    if d in v.f:
        print(v.F[d])

# zero_vec test
D = {'A', 'B', 'C'}  
v = zero_vec(D)  
for d in v.D:  
    print v.f[d]

# list2vec test
L = [1, 2, 3, 4]  
V = list2vec(L)

for d in V.D:  
    print(d)
    print(V.f[d])
</code></pre>

<p><br/></p>

<h3 id="vectorsovergf2">Vectors over GF(2)</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/GF2_perfect_secrecy.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/all_or_nothing_secret.jpg'  alt="" /></p>

<p>두명에게 나누어 <code>v</code> 를 전송하기 위해 <em>uniform distribution</em> 으로 <code>vA</code> 를 얻어 <code>vB = v - vA</code> 를 만든 뒤 각 한명씩에게 <code>vA</code>, <code>vB</code> 를 전송하는 것이다.</p>

<p><code>vA</code> 는 랜덤 <em>n-vector</em> 고 <code>vB</code> 는 <code>f(x) = v - x</code> 의 <em>output</em> 인데, 이 함수의 <em>input</em> 이 랜덤하게 골라졌으므로 이것만으로는 어떤것도 얻을 수 없다.</p>

<p><img src='http://cdn.phys.org/newman/gfx/news/2012/jhygjfvjgv.jpg'  alt="" /></p>

<p><em>RSA</em> 가 이 테크닉을 사용한다고 한다.</p>

<ul>
<li>Split each password into two parts</li>
<li>Store the two parts on two separate servers</li>
</ul>

<p><br/></p>

<h3 id="dotproduct">Dot-Product</h3>

<p><em>inner product</em> (내적) 이라 부른다. <em>scalar</em> 값을 돌려주고 두 벡터가 이루는 각을 알 수 있다. 외적과 내적에 관한 자세한 내용은 <a href='http://mrw0119.tistory.com/12' >프로그래밍에 미치다 - 외적, 내적 분해</a> 를 참고하자.</p>

<p>내적은 <em>linear equation</em> 에 사용할 수 있다.</p>

<pre><code class="python">D = {"radio", "sensor", "CPU", "memory"}  
duration = {"radio": 0.1, "sensor": 0.5, "CPU": 1, "memory": 0.5} # second  
rate = {"radio": 500, "sensor": 20, "CPU": 1000, "memory": 200} # mA

duration * rate  
</code></pre>

<p><em>linear equation</em> 과 관련해서 중요한 질문들을 던져보자.</p>

<ul>
<li>Is there an algorithm for solving a system of linear equations?</li>
<li>How can we know whether there is only one solution</li>
<li>What if our data are slightly inaccurate</li>
</ul>

<p>이후의 강의들에서 위에서 던진 질문들을 해결할 것이다.</p>

<p><br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/dot_product_measuring_similarity.jpg'  alt="" /></p>

<p>두 음성이 비슷한지 <em>dot-product</em> 로 비교할 수 있다. 매 부분마다 음성이 비슷한지 비교해야 하므로 연산이 느릴 수 있지만 <em>Fast Fourier Transform</em> 을 이용하면 계산을 빠르게 수행할 수 있다.</p>

<p><br/></p>

<h3 id="dotproductovergf2">Dot-Product over GF(2)</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/dot_product_auth.jpg'  alt="" /></p>

<p>몇번의 질문을 컴퓨터가 던지는것과 비슷하게 <em>n-vector password</em> <code>x</code> 에 대해 컴퓨터가 <em>random n-vector</em> <code>a</code> 를 보내고, 사람이 <em>dot-product</em> 값 <code>a * x = b</code>  를 보낸다.</p>

<p><em>eavesdropper</em> 가 <code>a1, ..., an</code> <code>b1, ..., bn</code> 값을 도청한다면 패스워드를 알기 위해선 다음의 질문을 반드시 해결해야 한다</p>

<ul>
<li><strong>How many solutions for that linear equation?</strong></li>
<li><strong>How to compute them?</strong></li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/attacking_simple_auth.jpg'  alt="" /></p>

<p>만약 <em>Eve</em> 가 <code>01011</code> 과 <code>11110</code> 을 관찰했다면 <code>01011 + 11110</code> 에 대해서는   그림에서 보듯이 해킹이 가능하다. 따라서 추가적으로 던져야 할 질문은</p>

<ul>
<li><strong>If a vector satisfies the equations, then what other equations does the vector satisfy?</strong></li>
</ul>

<p><br/></p>

<h3 id="triangularsystem">Triangular System</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/1-vector/triangular_system.jpg'  alt="" /></p>

<ul>
<li>If <code>rowlist[i][i]</code> is zero procedure will raise <code>ZeroDivisionError</code></li>
<li>If this never happens, solution found is the only solution to the system</li>
</ul>

<p>위의 코드는 <code>D = {0, 1, ..., n-1}</code> <em>domain</em> 에 대해서만 작동하기 때문에 다른 도메인에서 돌아갈 수 있도록 코드를 수정하면</p>

<pre><code class="python">def trianuglar_solve(rowlist, domain, b):  
    x = zero_vec(set(label_list))

    for r in reversed(range(len(rowlist))):
        c = label_list[r]
        x[c] = (b[r] - x * rowlist[r]) / rowlist[r][c]

    return x
</code></pre>

<p><br/></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href='http://colorsark.deviantart.com/art/3D-Cube-342632998' >Title image</a> <br />
(2) <strong>Coding the Matrix</strong> by <em>Philip Klein</em> <br />
(3) <a href='http://ko.wikipedia.org/wiki/%EC%82%AC%EC%9B%90%EC%88%98' >Wiki: 4원수</a> <br />
(4) <a href='http://wiki.mathnt.net/index.php?title=%ED%95%B4%EB%B0%80%ED%84%B4%EC%9D%98_%EC%82%AC%EC%9B%90%EC%88%98' (quarternions)">Math Wiki: 4원수</a> <br />
(5) <a href='http://en.wikipedia.org/wiki/Linear_combination' >Wiki: line combination</a> <br />
(6) <a href='http://mrw0119.tistory.com/12' >프로그래밍에 미치다 - 외적, 내적 분해</a>  </p>]]></description><link>http://1ambda.github.io/coding-the-matrix-1/</link><guid isPermaLink="false">46c525c5-23be-4306-9722-8ec9f3f90112</guid><category><![CDATA[coursera]]></category><category><![CDATA[linear algebra]]></category><category><![CDATA[vector]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 12 Feb 2015 11:00:01 GMT</pubDate></item><item><title><![CDATA[Pattern Discovery 1]]></title><description><![CDATA[<p><img src='https://m1.behance.net/rendition/modules/7116731/disp/d18c13cd5b49bf40b41e6ef0610b26d3.png'  alt="" /></p>

<p><strong>Patterns represent intrinsic and important properties of datasets</strong>. Pattern discovery is uncovering patterns (inherent regularities) from massive data sets </p>

<ul>
<li>What products were often purchased together?</li>
<li>What are the subsequent purchases after buying an iPad?</li>
</ul>

<p><br/></p>

<h3 id="supportconfidence">Support, Confidence</h3>

<pre><code>;; item bought

Beer, Nut, Diaper  
Beer, Coffee, Diaper  
Beer, Diaper, Eggs  
Nuts, Eggs, Milk  
Nuts, Coffee, Diaper, Eggs, Milk  
</code></pre>

<p><em>support</em> <code>s</code> 는 전체 구매 중에서, 해당 아이템이 구매되었을 확률이다. <em>min support</em> 를 50% 로 한다면, </p>

<ul>
<li><em>freq 1-itemset:</em> Beer(60%), Nuts(60%), Diaper(80%), Eggs(60%)</li>
<li><em>freq 2-itemset:</em> {Beer, Diaper} (60%)</li>
</ul>

<p><em>confidence</em> <code>c</code> 는 <code>X</code> 가 포함되어있을때 <code>Y</code> 까지 구매되었을 조건부 확률이다. <code>c = sup(X ∪ Y) / sup(X)</code></p>

<p><em>association rule</em> 은, <em>min support</em> 와 <em>min confidence</em> 를 정해놓고, 그 이상이 되는 <em>rule</em> <code>X -&gt; Y</code> 를 찾는 것이다.</p>

<ul>
<li><code>Beer -&gt; Diaper</code> (s:60%, c:100%)</li>
<li><code>Diaper -&gt; Beer</code> (s:60%, c:75%)</li>
</ul>

<p><br/></p>

<h3 id="closedpatterns">Closed Patterns</h3>

<p>이렇게 패턴을 구하면, 다수개의 물품이 있는 <em>transaction</em> 에서는 너무 많은 패턴이 생긴다.</p>

<pre><code>;; TDB1 

T1: {a1, ..., a50}  
T2: {a1, ..., a100}  
</code></pre>

<p><em>min supoort</em> 를 <code>1</code> 이라 하면 <em>1-itemset</em>, <em>2-itemset</em>, .. <em>100-itemset</em> 처럼 <code>2^100 - 1</code> 개의 <em>sub pattern</em> 이 생긴다.</p>

<p>이 문제를 해결하기 위해 <em>lossless compression</em> 인 <em>closed pattern</em> 이란 개념을 도입해 보자.</p>

<blockquote>
  <p><strong>closed pattern:</strong> A pattern(itemset) <code>X</code> is <strong>closed</strong> if <code>X</code> is frequent, and there exists no super pattern <code>Y ⊃ X</code>, with the same support as <code>X</code></p>
</blockquote>

<p>위와 똑같은 <code>TDB</code> 에 대해 <em>closed pattern</em> 을 구하면</p>

<p><code>P1: "{a1, ..., a50}: 2" , P2: "{a1, ..., a100}: 1"</code></p>

<p><br/></p>

<p><em>closed pattern</em> 대신 <em>max pattern</em> 을 이용할 수 있다.</p>

<blockquote>
  <p><strong>max pattern:</strong> A pattern <code>X</code> is a <strong>max-pattern</strong> if <code>X</code> is frequent and there exists no frequent super-pattern <code>Y ⊃ X</code></p>
</blockquote>

<p>정의를 보면 <em>support</em> 값을 신경쓰지 않는다. 위와 같은 <code>TDB</code> 에 대해 <em>max-pattern</em> 을 찾으면</p>

<p><code>P: "{a1, ..., a100}: 1</code></p>

<p>당연히 <em>lossy compression</em> 이다. </p>

<p><br/></p>

<h3 id="downardclosureproperty">Downard Closure Property</h3>

<p><em>Apriori property</em> 라 부르기도 하는데, 핵심은 이렇다.</p>

<p><code>{beer, diaper, nuts}</code> 가 <em>frequent</em> 하면 <em>subitem</em> 인 <code>{beer diaper}</code> 는 적어도 그 만큼은 <em>frequent</em> 해야한다는 것이다.</p>

<blockquote>
  <p><em>Apriori:</em> Any subset of a frequent itemset must be frequent</p>
</blockquote>

<p>따라서 <code>S</code> 의 어떤 <em>subset</em> 도 <em>infrequent</em> 하면 <code>S</code> 가 <em>frequent</em> 할 일이 없으므로, 가지치기 할 수 있다는 것이다.</p>

<blockquote>
  <p><em>Apriori pruning principle:</em> if there is any itemset which is infreqent, its superset should not even be generated</p>
</blockquote>

<p><br/></p>

<h3 id="theapriorialgorithm">The Apriori Algorithm</h3>

<p><em>level-wise</em>, <em>candidate generation and test</em></p>

<pre><code>initially, scan DB once to get frequent 1-itemset

repeat  
  generate length-(k+1) candidate itemsets from length-k frequent itemsets
  test the candidates against DB to find frequent (k+1) itemset
  Set k := k + 1

until no frequent or candidate set can be generated  
</code></pre>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week1/apriori_algorithm.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week1/apriori_example.jpg'  alt="" /></p>

<p><em>apirori</em> 알고리즘이 나온 이래로, 성능을 개선하기 위한 많은 기법들이 발표됬다.</p>

<p>(1) Reduce passes of transaction database scans <br />
- partitioning
- dynamic itemset counting</p>

<p>(2) Shrink the number of candidates <br />
- Hashing
- Pruning by support lower bounding
- Sampling</p>

<p>(3) Exploring special data structures <br />
- Tree projection
- H-miner
- Hypercube decomposition</p>

<p><br/></p>

<h3 id="partitioning">Partitioning</h3>

<blockquote>
  <p><em>Theorem:</em> Any itemset that is potentially frequent in TDB must be frequent in at least one of the partitions of TDB</p>
</blockquote>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week1/partitioning.jpg'  alt="" /></p>

<p>어느 <em>local TDB</em> 에서도 <em>frequent</em> 하지 않으면 <em>global TDB</em> 에서도 <em>frequent</em> 하지 않기 때문에, <em>global</em> 에서 <em>frequent</em> 하려면  적어도 <em>partitioning</em> 된 <em>local TDB</em> 중 하나에서는 <em>frequent</em> 해야 한다.</p>

<p>따라서 <em>scan 1</em> 에서 <em>partitining</em> 하고 <em>local pattern</em> 을 찾고, <em>scan 2</em> 에서 <em>global frequent pattern</em> 을 구하면 된다. 딱 2번만 <em>TDB</em> 에 접근한다.</p>

<p><br/></p>

<h3 id="directhashingandpruning">Direct Hashing and Pruning</h3>

<p><em>DHP</em> 는 <em>candidates</em> 의 수를 줄이기 위해 사용하는 기법이다.</p>

<blockquote>
  <p><em>observation:</em> A <code>k</code>-itemset whose corresponding hashing bucket count is below the threshold cannot be frequent</p>
</blockquote>

<p>기본적인 아이디어는 <em>item</em> 이 <em>frequent</em> 하다면, <em>hashing bucket</em> 에 들어갔을때 그 <em>count</em> 값이 <em>threshold</em> 보다 높아야 한다는 것이다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week1/DHP.jpg'  alt="" /></p>

<p><br/></p>

<h3 id="verticaldataformat">Vertical Data Format</h3>

<blockquote>
  <p><em>ECLAT</em> (Equivalence Class Transformation) is a depth first search algorithm using set intersection    </p>
</blockquote>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week1/ECLAT.jpg'  alt="" /></p>

<p><em>ECLAT</em> 은 <em>item</em> 기준으로 접근하는 방법이다. <code>t(X) = t(Y)</code> 이면 <code>X</code> 와 <code>Y</code> 가 언제나 같이 일어나고, <code>t(X) ⊂ t(Y)</code> 이면 <code>X</code> 가 있을땐 언제나 <code>Y</code> 가 있다.</p>

<p><em>diffset</em> 연산을 이용하면 공간을 많이 아낄 수 있다. <em>intersection</em> 은 교집합이므로, 공통부분과 그렇지 않은 부분이 생기는데, 다른 부분만 보관하는 것이다.</p>

<p><br/></p>

<h3 id="fpgrowth">FP Growth</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week1/FPGrowth.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week1/FPGrowth_example.jpg'  alt="" /></p>

<p><em>FP-tree</em> 를 만들고, 이를 이용해 <em>conditinal pattern bases</em> 를 구한다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week1/conditional_pattern_bases.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week1/conditional_pattern_bases2.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week1/scaling_FPGrowth.jpg'  alt="" /></p>

<p><br/></p>

<h3 id="miningclosedpattern">Mining Closed Pattern</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week1/mining_closed_pattern.jpg'  alt="" /></p>

<p><em>closed pattern</em> 에 대해 쓸 수 있는 다양한 기법이 있다. <em>itemset merging</em> 도 그중 하나인데, </p>

<p><em>d-proj. db</em> 인 <code>{acef, acf}</code> 를
<em>acfd-proj. db</em> 인 <code>{e}</code> 로 바꾸어, <code>{acfd:2}</code> 를 얻을 수 있다.</p>

<p>이외에도 위 그림에 나온 많은 테크닉들이 있다.</p>

<p><br/></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href='https://www.behance.net/gallery/625042/Icon-and-pattern-with-a-marketing-theme' >Title image</a> <br />
(2) <em>Pattern Discovery</em>, Coursera  </p>]]></description><link>http://1ambda.github.io/pattern-discovery-1/</link><guid isPermaLink="false">ad3d19ae-0fcc-41f5-bba3-829c06518bf2</guid><category><![CDATA[coursera]]></category><category><![CDATA[pattern discovery]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 12 Feb 2015 07:57:41 GMT</pubDate></item><item><title><![CDATA[AI Planning 4, STN, HTN]]></title><description><![CDATA[<p><img src='http://uxmag.com/sites/default/files/legacy/articleimage_15.jpg'  alt="" /></p>

<p>지금까지 <em>State-Space Planning</em>, <em>Plan-Space Planning</em> 기법을 배웠는데, 이 두 가지는 같은 문제를 푸는 방법이었다. 이제 문제를 조금 변형해, 인간의 사고와 비슷하게 <em>Task</em> 중심으로 분할해서 해결하는 법을 배워보자. </p>

<h3 id="stn">STN</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/STN_planning.jpg'  alt="" /></p>

<p><em>terms</em> 는 <em>constant</em>, <em>variable</em>, <em>object</em> 따위의 것들이고 <em>literals</em> 는 참이거나 거짓이 될 수 있는 <em>proposition</em> 이다. </p>

<p><em>task network</em> 에서 새롭게 도입되는 것은</p>

<ul>
<li><strong>task:</strong> to be performed</li>
<li><strong>method:</strong> describing ways in which tasks can be performed</li>
<li><strong>organized collections of tasks:</strong> called task networks</li>
</ul>

<p><em>DWR</em> 예제로 보면</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/DWR_STN_example.jpg'  alt="" /></p>

<p><br/></p>

<h3 id="task">Task</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/tasks_def.jpg'  alt="" /></p>

<p><em>task</em> 는 <code>T_S</code> 처럼 <em>non-primitive</em> 일 수도, <code>t1, ..., tn</code> 처럼 <em>subsete</em> 에 속하는 <em>primitive task</em> 일 수 있다. </p>

<p><em>task</em> 를 <code>t_i(r1, ..., rk)</code> 라 표기하는데, <code>r</code> 은 <em>task</em> 에 의해 조작되는 <em>object</em> 등의 <em>term</em> 이다. </p>

<p>그리고 슬라이드에 나와 있듯이 <em>ground task</em> 는 <em>variable</em> 이 아니라 <em>action</em> 처럼 <em>constant</em> 를 가져야 하고, <em>action</em> 은 <em>ground primitive task</em> 만 <em>accomplish</em> 할 수 있다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/simple_task_network_def.jpg'  alt="" /></p>

<p><em>STN</em> 은 <em>acyclic directed graph</em> <code>(U, E)</code> 다. 각 <em>node</em> 는 <em>task</em> 고, <em>edge</em> 는 <em>task</em> 의 <em>partial ordering</em> 을 정의한다. <code>t_i &lt; t_j</code> 처럼</p>

<p>그리고 <em>task network</em> 는 모든 <em>node</em> 가 <em>ground/primitive</em> 일때만 <em>ground/primitive</em> 고, 하나라도 아니라면 <em>unground/non-primitive</em> 다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/total_ordered_STN.jpg'  alt="" /></p>

<p><em>STN</em> <code>w</code> 는 위상 정렬처럼, 모든 <em>edge</em> 가 <em>node</em> 에 대해 순서를 정의할 수 있으면 <em>totally ordered</em> 하다고 말한다. 그러면 <code>w</code> 는 <em>task</em> 의 시퀀스로 나타낼 수 있다. <code>w = &lt;t1, ..., tn&gt;</code></p>

<p>그리고 <code>w</code> 가 <em>totally ordered</em>, <em>ground</em>, <em>primitive</em> 이면 <code>w</code> 를 위한 <em>plan</em> <code>ㅠ</code> 는</p>

<p><code>ㅠ(w) = &lt;a1, ..., an&gt;</code> where <code>ai = ti</code>, <code>1 &lt;= i &lt;= n</code></p>

<p><br/></p>

<p>DWR 예제로 STN 의 표기법을 알아보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/STNs_DWR_ex.jpg'  alt="" /></p>

<p><code>take</code> <em>task</em> 는 똑같은 <em>operator</em> 이름이 있으므로 <em>primitive</em> 고, 변수가 없으므로 <em>ground</em> 다. </p>

<p><code>move-stack</code> 은 <em>DWR domain</em> 에 정의한 같은 이름의 <em>operator</em> 가 없으므로 <em>non-primitive</em> 이고, 변수가 있으므로 <em>unground</em> 다.</p>

<p>이 3개의 <em>task</em> 를 기반으로 <em>task network</em> 를 구성할 수 있다.</p>

<p><code>w1</code> 은 <code>(t1, t2), (t1, t3)</code> 고, <code>t2, t3</code> 에 대한 <em>ordering</em> 이 없으므로 <em>partially ordered network</em> 다.</p>

<p><br/></p>

<h3 id="methodsrefinements">Methods (Refinements)</h3>

<blockquote>
  <p><strong>method:</strong> describing ways in which tasks can be performed</p>
</blockquote>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/STN_method_def.jpg'  alt="" /></p>

<p>메소드는 <em>name</em>, <em>task</em>, <em>precond</em> <em>network</em> 로 구성되어 있다.</p>

<ul>
<li><em>name(m)</em>: <code>n(x1, ..., xk)</code> 의 형태로 <em>unique</em> 한 심볼 <code>n</code> 과 다뤄지는 <em>variable</em> 인 <code>x</code> 를 포함한다</li>
<li><em>task(m)</em>: <em>non-primitive task</em></li>
<li><em>precond(m)</em>: set of literals</li>
<li><em>network(m)</em>: task network <code>(U, E)</code> containing the set of subtasks <code>U</code> of <code>m</code></li>
</ul>

<p>잘 보면 <em>effect</em> 가 없는데, 여기선 <em>goal</em> 을 달성하는 것이 아니라 <em>task</em> 를 수행해야 하기 때문에 <em>effect</em> 는 없고 <em>precond</em> 만 신경쓴다.</p>

<p>그리고 <em>task</em> 는 무엇을 달성해야 하는지를 나타내기 때문에, <em>task</em> 가 같으면 같은 <em>method</em> 가 아니냐고 질문할 수 있으나, <em>network</em> 때문에 다르다. <em>network</em> 는 <em>subtask</em> 를 <em>ordering</em> 한 것으로 <strong>어떻게</strong> <em>task</em> 를 수행할지를 나타내기 때문이다.</p>

<p>만약 <em>method</em> 의 <em>network</em> 가 <em>partially ordered</em> 이면 <em>method</em> 도 <em>partially ordered metohd</em> 라 부른다.</p>

<p><br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/STN_method_DWR_ex.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/STN_method_DWR_ex2.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/STN_method_DWR_ex3.jpg'  alt="" /></p>

<p><br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/app_relev.jpg'  alt="" /></p>

<p><em>appicability</em> 는 <em>action</em> 과 비슷하다. </p>

<p>만약 <em>substitution</em> <code>σ</code> 에 대해, <code>σ(t) = task(m)</code> 이면 메소드 인스턴스 <code>m</code> 이 태스크 <code>t</code> 와 <em>relevant</em> 하다고 말한다. <del>왜죠?</del></p>

<p>무슨 뜻인가 하면, 우리가 달성하려고 하는 <code>t</code> 에 대해 <code>σ(t)</code> 가 메소드의 태스크인 <code>task(m)</code> 과 동일하면, 해당 <code>t</code> 를 위해 메소드 <code>m</code> 을 사용할 수 있다는 뜻이다.</p>

<p>그리고 태스크 <code>t</code> 와 <em>relevant</em> 인 <em>method</em> <code>m</code> 에 대해 </p>

<ul>
<li><code>δ(t, m, σ) = σ(network(m))</code> 또는</li>
<li><code>δ(t, m, σ) = σ(&lt;subtasks(m)&gt;)</code> if <code>m</code> is <strong>totally ordered</strong></li>
</ul>

<p>로 <em>decomposition</em> 할 수 있다. 그냥 분해인데, 표기법을 저렇게 사용한다고 보면 된다. 당연히 <em>decomposition</em> 되면 <em>subtask</em> 가 되는데, <em>totally ordered</em> 면 <em>subtask</em> 만 돌려주면 되고, 아니라면 <em>network</em> 를 돌려주면 된다는 이야기. DWR 예제로 보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/STN_method_DWR_ex2.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/method_app_relev_DWR_ex.jpg'  alt="" /></p>

<p><em>substitution</em> 을 적용했을때<em>task</em> 이름이 같으므로 <em>relevant</em> 하고 <em>precond</em> 를 검사해보면 <em>applicable</em> 하다는 것을 알 수 있다.</p>

<p><br/></p>

<h3 id="decomposition">Decomposition</h3>

<p><em>method decomposition</em> 을 자세히 살펴보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/method_decomp_DWR_ex.jpg'  alt="" /></p>

<p><br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/decomposition_def.jpg'  alt="" /></p>

<p><code>w</code> 를 <em>STN</em> 이라고 하면, <code>U</code> 에 속하는 <em>task</em> <code>t</code> (<em>predecessors</em> 가 없는) 에 대해 <em>relevant</em> 메소드 <code>m</code> 이 있고, <em>substitution</em> <code>σ</code> 와, <code>m</code> 의 <em>network</em> <code>(U_m, E_m)</code> 이 있다. 이 때 <em>decomposition</em> <code>δ(w, t, m, σ)</code> 은</p>

<ul>
<li><code>t</code> is replaced in <code>U</code> by <code>σ(U_m)</code></li>
<li>edges in <code>E</code> involving <code>t</code> are replaced by edges to appropriate nodes in <code>σ(U_m)</code></li>
</ul>

<p><br/></p>

<h3 id="domainsproblemsandsolution">Domains, Problems and Solution</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/STN_planning_domain.jpg'  alt="" /></p>

<p><em>STN planning domain</em> <code>D = (O, M)</code> 이다. <code>O</code> 는 <em>STRIPS planning operators</em>, <code>M</code> 은 <em>STN methods</em> 다. 만약 모든 메소드가 <em>totally ordered</em> 이면 <code>D</code> 도 <em>total-order STN planning domain</em> 이다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/STN_planning_problem.jpg'  alt="" /></p>

<p><em>STN planning problem</em> <code>P</code> 는 <code>P = (s_i, w_i, O, M)</code> 으로 구성된다. 잘보면 <em>goal</em> 대신 <em>initial state network</em> 인 <code>w_i</code> 가 있다. <code>w_i</code> 와 <code>D = (O, M)</code> 이 <em>totally ordered</em> 면 <code>P</code> 를 <em>total order STN planning problem</em> 이라 부른다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/STN_planning_solution.jpg'  alt="" /></p>

<p>(1) <code>w_i</code> 와 <em>plan</em> <code>ㅠ</code> 가 <em>empty</em> 여서 태스크가 없거나  </p>

<p>(2) <em>predecessors</em> 가 없는 <em>primitive task</em> <code>t</code> 에 대해, <code>a1 = t</code> 가 <code>s_i</code> 에 <em>applicable</em> 하고, <code>ㅠ = &lt;a2, ..., an&gt;</code> 이 <code>P' = (γ(s_i, a1), w_i - {t}, O, M)</code> 의 솔루션이거나  </p>

<p>(3) <em>predecessors</em> 가 없는 <em>non-primitive task</em> <code>t</code> 에 대해 <em>relevant</em> 메소드 <em>m</em> 이 <code>s_i</code> 에 대해 <em>applicable</em> 하고, <code>ㅠ</code> 가 <code>P' = (s_i, δ(w, t, m, σ), O, M)</code> 면 된다.</p>

<p>즉 <em>primitive task</em> 일때는 <em>action</em> 으로 시작하고, 아닐때는 <em>decomposition</em> 한 네트워크에 대해 <code>ㅠ</code> 를 찾으면 된다.</p>

<p></br></p>

<h3 id="stnplanning">STN Planning</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/state_vs_plan_planner.jpg'  alt="" /></p>

<p>여기서 <em>TFD</em> 는 <em>Total-order Forward Decomposition</em> 의 약자다.</p>

<pre><code>function Ground-TFD(s, &lt;t, ..., tk&gt;, O, M)  
  // empty plan, no task
  if k = 0 return &lt;&gt;

  if t1.isPrimitive() thne
    actions = {(a, σ), a = σ(t1) and a applicable in s}

    if actions.isEmpty() then return failure
    (a, σ) = actions.chooseOne()
    plan &lt;- Ground-TFD(γ(s, a), σ(&lt;t2, ..., tk&gt;), O, M)

    if plan = failure then return failure
    else return &lt;a&gt; * plan // add plan 

  else 
    methods = {(m, σ) | m is relevant for σ(t1) and m is appicable in s}

    if methods.isEmpty then return failure

    (m, σ) = methods.chooseOne()
    // prepend subtasks
    plan &lt;- subtasks(m) * σ(&lt;t2, ..., tk&gt;)

    return Ground-TFD(s, plan, O, M)
</code></pre>

<p><em>DWR</em> 예제를 보면</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/DWR_decompos_tree_ex.jpg'  alt="" /></p>

<p><code>move-stack</code> 은 <em>non-primitive</em> 이므로 <em>decomposition</em> 하고, 이 과정을 반복하면서 <em>ground, primitive task</em> 를 얻어 <em>action</em> 으로 해결한다.</p>

<p><br/></p>

<h3 id="tfdvsfowardbackwardsearch">TFD vs Foward/Backward Search</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/TFD_vs_fwd_backwd.jpg'  alt="" /></p>

<ul>
<li>TFD consider only applicable actions like forward search</li>
<li>TFD consider only relevant actions like backward search</li>
<li>TFD generate actions execution order. current world state always known</li>
<li>Ground-TFD can be generalized to Lifted-TFD resulting in same advantages as lifted backward search</li>
</ul>

<p><em>TFD</em> 의 경우 <em>action execution order</em> 를 생성하기 때문에, 현재 어디에 위치해 있는지를 알 수 있다. 이 때문에 <em>goal</em> 까지 더 빠르게 가기 위한 <em>good heuristics</em> 를 적용할 수 있다.</p>

<p><em>Lifted-TFD</em> 는 <em>variable</em> 을 최대한 유지해, 불필요한 <em>binding</em> 을 막는다.</p>

<p><br/></p>

<p><em>Partial-order FD</em> 코드도 살펴보자.</p>

<pre><code>function Ground-PFD(s, w, O, M)  
  if w.U = {} return &lt;&gt;

  task &lt;- { t ∈ U | t has no predecessors in w.E}.chooseOne()

  if task.isPrimitive() then
    actions = {(a, σ) | a = σ(t1) and a applicable in s}

    if actions.isEmpty() then return failure

    (a, σ) = actions.chooseOne()
    plan &lt;- Ground-PFD(γ(s, a), σ(w-{task}), O, M)

    if plan = failure then return failure
    else return &lt;a&gt; * plan

  else
    methods = {(m, σ) | m is relevant for σ(t1) and m is applicable in s}

    if methods.isEmpty then return failure

    (m, σ) = methods.chooseOne()

    return Gound-PFD(s, δ(w, task, m, σ), O, M)    
</code></pre>

<p><em>TFD</em> 와 별 차이가 없다. 초기에 <em>TFD</em> 가 아니므로 인자로 <em>network</em> 인 <code>w</code> 를 받아, <code>task</code> 를 직접 구하는거 이외에는.</p>

<p><br/></p>

<h3 id="htnplanning">HTN Planning</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/precond_STN_planning.jpg'  alt="" /></p>

<p><em>STN planning</em> 에서는 <em>ordering constaints</em> 를 유지해야 하고, <em>applicability</em> 를 테스트하기 위해서 <em>precondition</em> 을 이용했다. 또한 <em>effect</em> 없이 <em>precond</em> 만 이용하므로 반드시 <em>forward search</em> 를 해야 했다.</p>

<p><em>HTN planning</em> 에서는 <em>ordering constaints</em> 나 <em>precondition</em> 이외에 추가적으로 <em>general constraints</em> 를 유지하여 다른 종류의 <em>constraints</em> 를 조합하는 등 더 유연하게 플래닝할 수 있다. </p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/HTN_methods_def.jpg'  alt="" /></p>

<p>예를 들어 <em>HTN methods</em> 는 <code>constr(m)</code> 을 포함한다. <em>DWR</em> 예제를 보자.</p>

<p><br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/HTN_method_DWR_ex.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/HTN_method_DWR_ex2.jpg'  alt="" /></p>

<p><code>move-one</code> 같은 경우 <code>no-move</code> 대신 이용하는데, 이는 <em>HTN planning</em> 에서는 <em>task</em> 가 없으면 <em>constraints</em> 를 추가할 수 없기 때문이다. </p>

<p><br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/HTN_vs_STRIPS.jpg'  alt="" /></p>

<p><em>HTN</em> 은 <em>STN</em> 의 더 유연한 버전이고, <em>STN</em> 은 <em>undecidable</em> 한 문제를 풀 수 있지만, <em>STRIPS</em> 에서는 불가능하다. <em>STRIPS</em> 에서는 유한한 오브젝트, 아톰 등으로 구성된 유한한 상태 공간을 탐색하기 때문이다. 반대로 <em>STN</em> 이 <em>background</em> 를 더 필요로 하지만, 더 <em>expressie</em> 함을 알 수 있다.</p>

<p>그렇다고 <em>STRIPS</em> 가 후지다는 것이 아니라, 서로 다른 종류의 문제를 풀 수 있는 두개의 방법이라 보면 된다.</p>

<p>참고로 <em>non-recursive STN</em> 은 <em>STRIPS</em> 로 번역될 수 있다고 한다. 그리고 <em>regular STN</em> 은 <em>STRIPS</em> 와 동일하다고 하는데, <em>regular</em> 란 뜻은 <em>recursive call</em> 이 그리 많지 않은 것을 의미한다.</p>

<h3 id="sipe2htnplanner">SIPE-2 HTN Planner</h3>

<p><a href='https://www.youtube.com/watch?v=gE0wPgT2qrw' >Youtube: SIPE-2 HTN Planner by David Wilkins</a></p>

<h3 id="refs">Refs</h3>

<p>(1) <strong>Artificial Integelligence Planning</strong>, by Dr.Gerhard Wickler, Prof. Austin Tate <br />
(2) <a href='http://uxmag.com/articles/psychological-usability-heuristics' >brain image</a>  </p>]]></description><link>http://1ambda.github.io/ai-planning-4/</link><guid isPermaLink="false">6235b69f-6206-4ec8-af7f-780a8f1d76cb</guid><category><![CDATA[coursera]]></category><category><![CDATA[artificial intelligence]]></category><category><![CDATA[STN]]></category><category><![CDATA[HTN]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 01 Feb 2015 02:42:11 GMT</pubDate></item><item><title><![CDATA[AI Planning 3, PSP, PoP]]></title><description><![CDATA[<p><img src='http://www.dailygalaxy.com/.a/6a00d8341bf7f753ef019affc63311970d-800wi'  alt="" /></p>

<h3 id="partialplan">Partial Plan</h3>

<p>이 전까지는 <em>plan</em> 을 <em>goal state</em> 를 달성하기 위한 <em>action</em> 의 나열로서 봤다. <em>plan</em> 자체를 하나의 솔루션으로 본 것이다. <em>partial plan</em> 은 이와 달리, 탐색 공간이 <em>state</em> 가 아니라 <em>plan</em> 으로 구성되어있다는 생각에서 시작한다.</p>

<ul>
<li><strong>state-space search:</strong> search through graph of nodes rpresenting world states</li>
<li><strong>plan-space search:</strong> search through graph of plans.</li>
</ul>

<p>(1) <strong>nodes</strong> are partially specified plans. <br />
(2) <strong>arcs</strong> are plan refinement opreations. <br />
(3) <strong>solutions</strong> are partial-order plans.</p>

<p><em>partial plan</em> 이란</p>

<ul>
<li>subset of the actions</li>
<li>subset of the organizational structure including temporal ordering of actions and rationale (<em>what the action achieves in the plan</em>)</li>
<li>subset of varaible bindings</li>
</ul>

<p>좀 더 <em>formal</em> 한 정의는</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/partial_plan_def.jpg'  alt="" /></p>

<ul>
<li><code>A</code> 는 <em>partially instantiated</em> 된 <em>operators</em> 다.</li>
<li><code>&lt;</code> 는 <em>ordering constraint</em></li>
<li><code>B</code> 는 <em>variable binding</em></li>
<li><code>L</code> 은 <em>casual links</em> 로 <em>action</em> 간 <em>ordering</em> 과 여기에 필요한 <em>proposition</em> (<em>effect</em>, <em>precond</em>), <em>binding constraint</em> 를 포
함한다. <code>a_i</code> 를 <em>producer</em> <code>a_j</code> 를 <em>consumer</em> 라 부르기도 한다. </li>
</ul>

<p><br/></p>

<h3 id="planrefinemeents">Plan Refinemeents</h3>

<p><em>partial plan</em> 의 구성요소는</p>

<ul>
<li>initial state</li>
<li>goal conditions</li>
<li>set of operators with different varaibles</li>
</ul>

<h4 id="addingactions">Adding Actions</h4>

<p><em>unsatisfied pre-cond</em>, <em>unsatisfied goal condition</em> 을 위해서 <em>partial plan</em> 에 <em>action</em> 을 추가해야 한다. <em>forward search</em> 나 <em>backward search</em> 에서는 앞이나 뒤에만 <em>action</em> 을 추가할 수 있었지만 <em>partial plan</em> 에선 그런 제약이 없다. </p>

<p>예제를 보면 <em>initial state</em> 와 <em>goal</em> 로만 구성된 <em>empty plan</em> 에서 시작해서 <em>partial plan</em> 을 점점 키워간다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/adding_action_ex.jpg'  alt="" /></p>

<p><br/></p>

<h4 id="addingcasuallinks">Adding Casual Links</h4>

<p>위에서 언급했듯이 <em>partial plan</em> 은 <em>action</em> 간 <em>casual links</em> 를 포함하고 있다. <em>action</em> 간 <em>invalid pre-cond, effect</em> 를 방지하기 위해서 필요하다. </p>

<p>두 종류의 <em>provider</em> 가 있을 수 있다.</p>

<p>(1) <em>action</em> 의 <em>effect</em> <br />
(2) <em>initial state</em> 를 담고있는 <em>atom</em> </p>

<p>마찬가지로 <em>consumer</em> 도</p>

<p>(1) <em>action</em> 의 <em>pre-condition</em> 거나 
(2) <em>goal condition</em> 일 수 있다. </p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/adding_casual_links_ex.jpg'  alt="" /></p>

<p><br/></p>

<h4 id="addingvariablebindng">Adding Variable Bindng</h4>

<ul>
<li>new operators introduce new (copies of) variables into the plan</li>
<li>solution plan must contain actions</li>
<li>varaible binding constraints keep track of possible values for varaibles and co-designation</li>
</ul>

<p>새로운 <em>operator</em> 가 사용될때 마다, 새로운 <em>varaible</em> 이 <em>plan</em> 에 추가된다. 그런데 솔루션에는 <em>action</em> 이 있어야 하므로 <em>possible value</em> 를 테이블로 유지해야 한다. <em>casual links</em> 를 추가하면서 <em>effect</em> 와 <em>pre-cond</em> 를 연결했지만, <em>variable</em> 까지 고려하면 <em>invalid</em> 한 경우가 생길수도 있으므로 이를 막기 위해 <em>varaible binding</em> 이 필요하다. 예제를 보면</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/adding_variable_ex.jpg'  alt="" /></p>

<h4 id="addingorderingconstraints">Adding Ordering Constraints</h4>

<p><em>partial plan</em> 은 <em>ordering constraint</em> 를 포함하고 있다. </p>

<ul>
<li>binary relation specifying the temporal order between actions in the plan</li>
</ul>

<p><em>ordering constraints</em> 를 추가해야 하는 이유는</p>

<ul>
<li>all actions must come after initial state</li>
<li>all actions must come before goal</li>
<li>casual link implies ordering constaint</li>
<li>to avoid possible interference between actions</li>
</ul>

<p>예제를 보자. 그림에서 <em>variable binding</em> 이 표시되어 있진 않지만, 있다고 보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/adding_ordering_const.jpg'  alt="" /></p>

<h3 id="planspacesearch">Plan-Space Search</h3>

<p>지금까지 <em>partial plan</em> 을 구성하는 방법에 대해 배웠고, 이제 <em>partial plan</em> 을 노드로 삼는 <em>plan-space search</em> 에 대해 알아보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/initial_search_state.jpg'  alt="" /></p>

<p>최초에는 두개의 더미 <em>action</em> 인 <em>init</em>, <em>goal</em> 을 가지고 <code>init &lt; goal</code> 의 <em>ordering constaint</em> 를 가진다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/initial_search_state_ex.jpg'  alt="" /></p>

<p>이제 <em>plan refinement operators</em> 를 적용해서 하나 이상의 <em>successor</em> 를 찾기 위한 <em>successor function</em> 을 정의해 보자.</p>

<ul>
<li>adding an action to <code>A</code></li>
<li>adding an ordering constaint to <code>&lt;</code></li>
<li>adding a binding constaint to <code>B</code></li>
<li>adding a casual link to <code>L</code></li>
</ul>

<p>보면 알겠지만 <em>plan-space search</em> 는 두 가지 문제를 <em>decoupling</em> 한다.</p>

<p>(1) <em>which actions to execute as part of our plan</em> <br />
(2) <em>how to organize these actions?</em>, <em>what is the organizational structure that underlies our plan?</em></p>

<p><em>plan-space search</em> 를 다른관점에서 볼 수도 있다. <em>possible plan</em> 을 <em>partial plan</em> 으로 줄여가는 것이다.</p>

<p><br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/total_vs_partial_order.jpg'  alt="" /></p>

<p><em>planning problem</em> <code>P</code> 는 <em>state transition system</em>, <em>initial state</em>, <em>goal</em> 로 구성된다. 이때 <em>plan</em> <code>ㅠ</code> 에 대해 <code>r(s_i, ㅠ)</code> 가 <code>g</code> 를 만족시키면, <code>ㅠ</code> 는 솔루션이다.</p>

<p><code>r(s_i, ㅠ)</code> 는 <em>ground action</em> 의 시퀀스로만 정의되는데</p>

<ul>
<li>partial order corresponds to total order in which all partial order constaints are respected</li>
<li>partial instantiation corresponds to grounding in which variables are assigned values consistent with binding constraints</li>
</ul>

<p>생각해보면 <em>partially instantiated varaibles</em> 을 <em>fully ground plan</em> 으로 바꿀 수 있는 경우의 수가 많기 때문에 어떤 것을 사용할지 결정해야 한다. 이를 위해 <em>partial order solution</em> 을 정의하면</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/partial_order_solution.jpg'  alt="" /></p>

<p>위 슬라이드에서 볼 수 있듯이 두 가지 조건이 갖추어지면 <em>plan</em> <code>ㅠ</code> 가 <em>(partial order) solution</em> 이 될 수 있다.</p>

<ul>
<li>its ordering constaints <code>&lt;</code> and binding constraints <code>B</code> are consistent and</li>
<li>for every total order seq <code>&lt;a1, ... , ak&gt;</code> of all the actions in <code>A - {init, goal}</code> that is </li>
</ul>

<p>(1) totally ordered and grounded and respects <code>&lt;</code> and <code>B</code> <br />
(2) <code>r(s_i, &lt;a1, ..., ak&gt;)</code> must satisfy <code>g</code></p>

<p>흥미로운점은 <em>casual links</em> 가 아무런 역할도 하지 않는다는 것이다. 두번째는 위 과정을 <em>goal test</em> 로 쓰기 위해 <em>computational procedure</em> 로 바꾸면, 퍼포먼스가 별로라는 사실도 알 수 있다.</p>

<p>만약 우리가 모든 <em>total order seq</em> 를 테스트 해야하고, 수 많은 <em>seq</em> 가 있다면 <em>goal</em> 을 검증하기 위해 수 많은 작업을 해야한다.</p>

<p>물론 <em>plan</em> 을 만드는 과정에서 <em>action</em> 의 <em>pre-cond</em> 가 <em>casual links</em> 에 의해 지정되기 때문에, 우리가 만들고 있는 <em>plan</em> 이 <em>goal</em> 을 만족하는지, 아닌지 알 수 있다. 문제는 <em>pre-cond</em> 만으로는 <em>goal</em> 을 만족하는지 아닌지 충분하지 않다는 점이다.</p>

<h3 id="threatsandflaws">Threats and Flaws</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/threat_example.jpg'  alt="" /></p>

<p>위 그림에서 <em>action</em> <code>3</code> 과 <code>1</code> 은 <code>at(robot, loc1)</code> 을 서로 추가하고, 삭제한다. 따라서 병렬로 실행되면 <em>dummy action</em> 인 <em>goal</em> 이 실행되지 않을 수 있다. 이 경우를 <em>threat</em> 라고 부르며, 간단한 해결 방법으로 <em>action</em> <code>2</code> 에서 <code>1</code> 로 <em>ordering</em> 을 추가할 수 있다. 정의를 보면</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/threat_def.jpg'  alt="" /></p>

<p><em>casual link</em> <code>a_i -&gt; [p] -&gt; a_j</code> 에 에 대해 <em>threat</em> <code>a_k</code> 는 <code>p</code> 와 <em>unifiable effect</em> <code>~ q</code> 를 가지고 있고, <em>ordering constraint</em> <code>a_i &lt; a_k</code>, <code>a_k  &lt; a_j</code> 가 있다. 다시 말해 <code>a_i</code> 의 <em>effect</em> 를 상쇄할 수 있다는 말이다.</p>

<p><em>unsatisfied sub-goal</em> 과 <em>threat</em> 같은 것들을 <em>flaw</em> 라 부른다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/flaws_def.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/flawless_plan.jpg'  alt="" /></p>

<p>만약 <em>partial plan</em> <code>ㅠ = (A, &lt;, B, L)</code> 가 </p>

<p>(1) <code>ㅠ</code> has no flaws <br />
(2) the ordering constaints <code>&lt;</code> are not circular <br />
(3) the variable bindings <code>B</code> are consistent  </p>

<p>이면 <em>partial plan</em> <code>ㅠ</code> 는 <em>planning problem</em> <code>P</code> 의 솔루션이다.</p>

<p><br/></p>

<h3 id="pspalgorithm">PSP algorithm</h3>

<p><em>plan-space planning</em> 을 잠깐 복습해보면,</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/psp_as_search_prb.jpg'  alt="" /></p>

<p><em>operator</em>, <em>initial state</em> <em>goal</em> 로 구성된 <em>planning problem</em> 이 주어졌을때, <em>search problem</em> 은 위 슬라이드처럼 정의할 수 있다.</p>

<p><br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/PSP_basic_ops.jpg'  alt="" /></p>

<p><em>PSP, Plan-Space Planner</em> 의 기본적인 아이디어는 <em>partial plan</em> <code>ㅠ</code> 가 <em>flaw</em> 가 없을때 까지 <code>&lt;</code>, <code>B</code> 를 <em>valid</em> 하게 유지하면서 <em>refine</em> 하는 것이다. 따라서 <em>flaw</em> 를 찾고, 이걸 해결할 수 있는 <em>resolvers</em> 를 구한 뒤 적절히 선택해 나아가면 된다. 알고리즘은 </p>

<pre><code>function PSP(plan)  
  allFlaws &lt;- plan.openGoals() + plan.threats()

  if allFlaws.empty() then return plan

  flaw &lt;- allFlaws.selectOne()
  allResolvers &lt;- flaw.getResolvers(plan)

  if allResolver.empty() then return failure

  resolver &lt;- allResolvers.chooseOne()
  newPlan &lt;- plan.refine(resolver)

  return PSP(newPlan)
</code></pre>

<p>여기서 <code>chooseOne()</code> 과 <code>selectOne()</code> 이라는 두개의 선택 함수를 볼 수 있는데</p>

<ul>
<li><code>chooseOne()</code> is non-deterministic choice</li>
<li><code>selectOne()</code> is deterministic selection</li>
</ul>

<p><code>chooseOne()</code> 의 경우 <em>non-deterministic</em> 이기 때문에 실패할 경우 <em>backtracking</em> 할 수 있도록 해야 한다.</p>

<p>반면 <code>selectOne()</code> 은 <em>deterministic</em> 이기 때문에 <em>backtracking</em> 이 필요 없다. 대신 고려해야 할 것은</p>

<p>(1) <em>order</em> 가 <em>effcientcy</em> 에 영향을 미치기 때문에 어떤걸 선택하느냐가 중요하다. (<em>order</em> 는 <em>completeness</em> 와는 관련 없다) <br />
(2) 모든 <em>flaw</em> 는 <em>plan</em> 이 <em>solution</em> 이 되기 전에 <em>resolved</em> 되야 한다.  </p>

<p><br/></p>

<h3 id="pspimplementation">PSP Implementation</h3>

<pre><code>function PSP(plan)  
  allFlaws &lt;- plan.openGoals() + plan.threats()

  if allFlaws.empty() then return plan

  flaw &lt;- allFlaws.selectOne()
  allResolvers &lt;- flaw.getResolvers(plan)

  if allResolver.empty() then return failure

  resolver &lt;- allResolvers.chooseOne()
  newPlan &lt;- plan.refine(resolver)

  return PSP(newPlan)
</code></pre>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/plan_openGoals.jpg'  alt="" /></p>

<p><em>unachieved sub-goal</em> 의 리스트는 <em>action</em> 을 추가하면서 <em>precondition</em> 때문에 늘어나고, <em>casual link</em> 을 추가할때는 <em>protected proposition</em> 때문에 감소한다. </p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/plan_threats.jpg'  alt="" /></p>

<p><em>threat</em> 의 경우에는 새로운 액션 <code>a_new</code> 에 대해 기존의 링크 <code>L</code> 내에 있는 모든 <code>a_i -&gt; [p] -&gt; a_j</code> 에 대해 <code>a_new &lt; a_i</code>, <code>a_j &lt; a_new</code> 인지 검사하고, 참이면 패스한다. 참이 아닐경우 <code>p</code> 와 <code>~q</code> 의 <em>effect</em> 가 상쇄되는지 검사하여 <em>threat</em> 인지 검사한다.</p>

<p><em>casual link</em> <code>a_i -&gt; [p] -&gt; a_j</code> 를 추가할때는 기존의 <em>action</em> <code>a_old</code> 에 대해 <em>threat</em> 가 될 수 있는지 위처럼 검사한다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/flaw_getResolvers.jpg'  alt="" /></p>

<p>먼저 <em>unachieved precondition</em> 을 제거하는 <em>resolver</em> 를 구하는 방법을 알아보자. 기존의 <em>valid action</em> 의 <em>effect</em> <code>q</code> 에 대해 <em>unachieved precondition</em> <code>p</code> 를 해겨할 수 있으면 <em>resolver</em> 를 추가한다. <em>operator</em> 로 부터 직접 <em>action</em> 을 만들어 <em>casual link</em> 까지 추가할 수도 있다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/flaw_getResolvers2.jpg'  alt="" /></p>

<p><em>threat</em> 를 제거하는 <em>resolver</em> 는 위처럼 구할 수 있다. <code>a_i -&gt; [p] -&gt; a_j</code> 에 대한 <em>threat</em> <code>a_t</code> 에 대해 <code>a_t &lt; a_i</code>, <code>a_j &lt; a_t</code> 를 추가하거나, <em>variable binding</em> 을 추가하는 방법이 있다. <code>v</code> 의 <em>substitution</em> 이 <code>v</code> 와 다르면서, 동시에 <code>B</code> 와 <em>consistent</em> 해야만 <em>resolver</em> 다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/plan_refine.jpg'  alt="" /></p>

<p><em>ordering</em> 이나 <em>binding constraints</em>, <em>casual links</em>, <em>new action</em> 을 추가하면서 <em>refinement</em> 를 할 수 있다. 이 때 <em>resolver</em> 를 찾기 위한 <em>unachieved precondition</em>, <em>threat</em> 를 업데이트 해야 한다.</p>

<p><br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/maintain_ordering_consts.jpg'  alt="" /></p>

<p><em>ordering constaints</em> 는 질의하거나, 새로운 <em>ordering</em> 을 추가하기 위해 유지해야 한다. 이를 위한 표현 방법으로 위 슬라이드처럼 3가지 방법중 하나를 사용할 수 있다.</p>

<p><em>transitive closure</em> 를 유지하는 방법의 경우, <em>query (질의)</em> 는 빠르나 새로운 연산의 추가가 느릴 수 있다. 그러나 <em>planner</em> 의 경우 <em>query</em> 가 더 자주사용되는 연산이므로 좋은 표현 방법이다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/maintain_vcs.jpg'  alt="" /></p>

<p><em>unary constriants</em> 와 <em>equality</em> 는 <em>linear time</em> 으로 구할 수 있다. <em>inequality</em> 의 경우에는 <em>exponential time</em> 이 필요하고, 일반적으로 <em>NP-complete</em> 문제라고 알려져 있다.</p>

<p><em>inequality</em> 를 도입하는 것은 <em>threat</em> 를 풀 수 있는 <em>resolver</em> 이기 때문에 꼭 필요한데, 퍼포먼스가 문제가 될 수 있다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/PSP_sound_comp.jpg'  alt="" /></p>

<p><em>sound</em> 는, <em>planner</em> 가 리턴하는 것이 <em>solution</em> 이란 뜻이고 <em>complete</em> 하다는 것은 <em>solution</em> 이 있으면 <em>planner</em> 가 반드시 찾아낸다는 뜻이다. </p>

<p><br/></p>

<h3 id="thepopplanner">The PoP Planner</h3>

<p><em>Partial Order Planning</em></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/PSP_data_flow.jpg'  alt="" /></p>

<p><em>PoP</em> 플래너는 모든 <em>threat</em> 를 위 슬라이드에 표시된 초록색 부분에서 루프로 다룬다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/PoP_impl.jpg'  alt="" /></p>

<p><em>action</em>, <em>precondition</em> 을 하나의 <em>set</em> 으로 하여 <em>agenda</em> 라는 <em>input</em> 으로 취급한다. 그리고 <em>flaw type</em> 에 의해서 <em>search control</em> 이 진행된다. 코드로 보면</p>

<pre><code>funciton PoP(plan, agenda)  
  if agenda.empty then return plan

  (a_g, p_g) &lt;- agenda.selectOne()
  agenda &lt;- agenda - (a_g, p_g)
  relevant &lt;- plan.getProviders(p_g)

  if relevant.empty() then return failure

  // non-deterministic, use backtracking
  (a_p, p_p, σ) &lt;- relevant.chooseOne() 
  plan.L &lt;- plan.L ∪ &lt;a_p -&gt; [σ(p_g)] -&gt; a_g&gt;
  plan.B &lt;- plan.B ∪ σ

  if a_p is not in plan.A then
    plan.add(a_p)
    agenda &lt;- agenda + a_p.preconditions

  newPlan &lt;- plan

  for each threat on &lt;a_p -&gt; [p] -&gt; a_g&gt; or due to a_p do
    allResolvers &lt;- threat.getResolvers(newPlan)

    // backtracking
    if allResolvers.empty() then return failure

    resolver &lt;- allResolvers.chooseOne()
    newPlan &lt;- newPlan.refine(resolver)

  return PoP(newPlan, agenda)
</code></pre>

<p><em>back-propagation</em> 과 비슷하게 <em>goal</em> 부터 시작한다. <em>plan</em> 의 <em>casual links</em>, <em>binding</em> 을 추가해 가면서 진행한다.</p>

<h4 id="statespacevsplanspace">State-Space vs Plan-Space</h4>

<p><em>state-space</em> 플래너와 <em>plan-space</em> 플래너를 비교하면, </p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/3-partial-plan/state_vs_plan_planner.jpg'  alt="" /></p>

<p>(1) <em>state-space</em> 는 유한한 탐색 공간을 가진다. 매 스탭마다 유한한 수의 오브젝트와 릴레이션을 다루기 때문이다. 반면 <em>plan-space</em> 에선 탐색공간이 무한할 수 있다. 그러나 무한한 공간을 모두 다 탐색하는 것은 아니고, 솔루션을 찾기 위해 그 일부만 탐색한다.</p>

<p>(2) <em>state-space</em> 는 보통 <em>graph</em> 로 표현되고, 실제로는 <em>tree</em> 를 탐색한다.  반면 <em>plan-space</em> 에서는 어떤 <em>intermediate representation</em> 을 사용하는지 명확하지 않다. 이건 상당히 중요한데, 대부분의 모던 휴리스틱 기법들이 <em>explicit representation of intermediate states</em> 에 의존하기 때문이다.</p>

<p>(3) <em>state-space</em> 기법에선 <em>action ordering</em> 이 어떻게 탐색할지를 결정하는 반면 <em>plan-space</em> 에서 <em>action</em> 의 선택과 <em>organization</em> 은 독립적이다. 더 유연하다.</p>

<p>(4) <em>state-space</em> 에선 <em>casual structure</em> 가 <em>implicit</em> 한 반면 <em>plan-space</em> 에선 <em>casual links</em> 라는 <em>explicit representation</em> 으로 보여진다. 왜 이 <em>action</em> 을 사용하는지에 대한 명확한 기준이 있기 때문에 <em>current plan</em> 이 잘못되었을 때 수정하기 더 쉽다.</p>

<p>(5) <em>state-space</em> 에서는 <em>search-node</em> 가 더 간단하다. <em>set of ground atoms</em> 기 때문에 <em>successor</em> 를 계산하기도 더 쉽다. 반면 <em>plan-space</em> 에서는 <em>constraint network</em> 를 유지해야 하기 때문에 복잡하고, <em>successor</em> 를 계산하기도 쉽지 않다.</p>

<p>요즘에는 효율적인 휴리스틱 때문에 <em>state-space</em> 가 좀 더 많이 이용되는 편이라고 한다.</p>

<h3 id="refs">Refs</h3>

<p>(1) <strong>Artificial Integelligence Planning</strong>, by Dr.Gerhard Wickler, Prof. Austin Tate <br />
(2) <a href='http://www.dailygalaxy.com/my_weblog/2013/10/artificial-intelligence-will-it-end-the-human-epoch.html' >brain image</a>  </p>]]></description><link>http://1ambda.github.io/ai-planning-3/</link><guid isPermaLink="false">6a780098-7f04-4775-882d-bfcb570c396b</guid><category><![CDATA[coursera]]></category><category><![CDATA[artificial intelligence]]></category><category><![CDATA[PSP]]></category><category><![CDATA[PoP]]></category><category><![CDATA[state-space]]></category><category><![CDATA[plan-space]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 25 Jan 2015 04:59:52 GMT</pubDate></item><item><title><![CDATA[AI Planning 2, Heuristic Search and STRIPS]]></title><description><![CDATA[<p><img src='http://imgs.xkcd.com/comics/ai.png'  alt="" /></p>

<p>이번 시간에는 <em>A* algorithm</em>, <em>heuristics</em>, <em>forward search</em> 등을 배운다.</p>

<h3 id="heuristicsearchstrategies">Heuristic Search Strategies</h3>

<p><em>FIFO</em> 나 <em>LIFO</em> 는 와 달리 <em>heuristic algorithm</em> 은 <em>search space</em> 에 대한 정보를 이용한다. </p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/heuristic_function.png'  alt="" /></p>

<p><em>heuristic function</em> <code>h: state space -&gt; R</code> 은, <em>problem-specific knowledge</em> 를 <em>problem-independent way</em> 로 표현한다. </p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/best_first_search.png'  alt="" /></p>

<p><em>best-first search</em> 알고리즘은 <em>general tree search</em> 알고리즘의 인스턴스로, 가장 낮은 <code>f(n)</code> 값을 가지는 노드를 선택해 탐색한다. 이를 위해 <code>f(n)</code> 값을 오름차순으로 정렬하는 <em>priority queue</em> 이용한다. </p>

<p>만약 <code>f(n) = h(n)</code> 이면, <em>greedy best-first search</em> 라 부른다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/greedy_best_fs.png'  alt="" /></p>

<p><em>optimal</em> 이 아닐 수 있다는 점에 유의하자.</p>

<p>루마니아 투어 문제를 다시 보자.</p>

<p><img src='https://spark-public.s3.amazonaws.com/aiplan/resources/touring-romania-map.png'  alt="" />
<img src='https://spark-public.s3.amazonaws.com/aiplan/resources/touring-romania-heuristic.png'  alt="" /></p>

<p><em>heuristic function</em> 으로 <em>straight line distance</em> 를 이용했는데, 실제 거리와는 차이가 있다. (꼬불꼬불하니까)</p>

<h3 id="aalgorithm">A* algorithm</h3>

<p><em>greedy best-first search</em> 알고리즘은 쉽지만, 항상 <em>optmial solution</em> 를 돌려주지 않는다는 단점이 있다. 여기서 배울 <em>A* algorithm</em> 은 항상 <em>optimal solution</em> 을 찾아낸다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/a_star_algorithm.png'  alt="" /></p>

<p><code>h(n)</code> 은 휴리스틱 펑션이고, <code>g(n)</code> 은 <code>n</code> 에 도달하기 까지의 비용이다. 그리고 이 두 함수를 이용해 만든 <em>evaluation function</em> <code>f(n)</code> 을 <em>best-first search</em> 에 적용해 최적의 해를 찾아낸다.</p>

<blockquote>
  <p>A* search is optimal if <code>h(n)</code> is admissible</p>
</blockquote>

<p><em>A* search</em> 를 이용해 <em>Touring Romania</em> 문제를 풀어보면</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/a_star_touring.png'  alt="" /></p>

<p><em>greedy best-first search</em> 와 비교해보면 트리가 좀 더 큰데, 이건 <em>A* search</em> 가 일반적으로 좀 더 느리다는 사실을 보여준다.</p>

<p><br/></p>

<p><em>8-puzzle</em> 문제도 <em>A* search</em> 로 풀어보자. <em>empty tile</em> 을 옮긴다고 생각하고, <em>cost function</em> <code>g(n)</code> 은 모든 경우 <code>1</code> 로 볼 수 있다. 몇 가지 <code>h(n)</code> 을 생각해 볼 수 있는데,</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/eight_puzzle_heuristics.png'  alt="" /></p>

<p><em>Manhattan block distance</em> 는 제 자리까지 얼마나 더 움직여야하는지를 의미한다.</p>

<h3 id="propertiesofa">Properties of A*</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/admissible_heuristics.png'  alt="" /></p>

<p><em>admissible</em> 이란 말은, 항상 <code>h(n) &lt;= actual distance</code> 임을 의미한다. <code>f(n) = g(n) + h(n)</code> 이므로, <em>heuristic function</em> 이 <em>admissible</em> 하면 가장 적은 <code>f(n)</code> 을 찾는 <em>A* search</em> 는 <em>optimal solution</em> 을 돌려준다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/a_star_completeness.png'  alt="" /></p>

<p><em>A* search</em> 는 <em>complete</em> 하다. 이는 탐색 과정에서 <em>goal node</em> 를 포함한 <em>contour</em> (윤곽, 등고선) 에 도달하기 때문이다. 여기서 <em>contour</em> 란 같은 비용으로 도달할 수 있는 <em>sets of state</em> 다. <em>initial node</em> 에서 시작해서 <em>f-value</em> 가 증가하는 방향으로 탐색이 이루어지므로 결국 꼭지점(<em>goal</em>) 에 도달한다. 사실 <em>heuristics</em> 이 없다면 <em>A* search</em> 는 다익스트라 알고리즘과 동일하다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/touring_romania_contours.png'  alt="" /></p>

<p>기하학적으로 보면 <em>heuristic</em> 이 더 정밀해질 수록 타원이 <em>goal state</em> 에 가깝게 넓어진다.</p>

<p>그리고 <em>completeness</em> 속성은, 거꾸로 말하면 <em>optimal path</em> 를 찾기 위해서 그보다 더 적은 <em>cost</em> 를 가지는 모든 <em>path</em> 를 탐색해야 함을 말한다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/a_star_optimally_efficient.png'  alt="" /></p>

<p><em>A*star</em> 알고리즘은 같은 <em>heuristic</em> 을 이용해, 가장 적은 수의 <em>node</em> 를 확장하면서 <em>optimal solution</em> 을 돌려준다. 만약 이보다 더 적은 <em>node</em> 를 확장하면서, <em>optimal solution</em> 을 돌려준다면 <em>optmial solution</em> 이 아닐 수 있다.</p>

<p>물론 효율성을 결정하는건 <em>heuristic</em> 의 연산 비용 등이 있겠지만, 적어도 <em>node</em> 수와 관련해서는 <em>A* search</em> 가 최적이다.</p>

<h3 id="agraphsearch">A* Graph Search</h3>

<pre><code>function aStarTreeSearch(problem, h)  
  fringe &lt;- priorityQueue(new searchNode(problem.initialState))
  allNodes &lt;- hashTable(fringe)

  loop
    if empty(fringe) then return failure

    node &lt;- selectFrom(fringe) // lowest f-value

    if problem.goalTest(node.state) then
      return pathTo(node)

    for successor in expand(problem, node)
      if not allNodes.contains(successor) then
        fringe &lt;- fringe + successor @ f(successor) // g + h
        allNodes.add(successor)
</code></pre>

<p>여기서 <code>fringe &lt;- fringe + successor @ f(successor)</code> 부분은 <code>fringe</code> 가 우선순위 큐이므로, 우선순위를 결정할 값으로 <em>f-value</em> 인 <code>f(successor)</code> 을 이용한다는 뜻이다.</p>

<p>그리고 <code>if not allNodes.contains(successor) then</code> 부분에서, 사실 노드를 두번째로 발견할 때 더 짧은 경로일 수 있으므로 비교하는 부분이 필요하다. 그러나 <em>heuristic</em> 이 <em>admissible</em> 하지 않으므로 <em>A* search</em> 가 최적해를 돌려주지 않을 수 있다.</p>

<p>최악의 경우 <em>A*</em> 알고리즘은 <code>O(b)</code> 의 <em>time, space complexity</em> 를 가진다. 여기서 <code>b</code> 는 <em>branching factor</em> 이란 뜻이다. 다시 말해서 <em>exponential complexity</em> 란 말이다.</p>

<p><br/></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/eight_puzzle_search_space.png'  alt="" /></p>

<p><em>eight-puzzle</em> 문제를 다시 보자.</p>

<p>그림에서 볼 수 있듯이, 빈 타일을 움직이다 보면 <em>initial state</em> 로 돌아올 수 있다. 만약 이 문제를 그래프로 표현하면 이미 방문한 노드를 다시 방문하고 있는지 해시테이블을 이용해 검사할 수 있다. 대신, 해시테이블을 만들고 사용하기 위한 비용이 든다. </p>

<p>반면 트리로 문제를 풀게되면, <em>exponential</em> 하게 <em>search space</em> 가 증가하기 때문에 <em>worst case</em> 에선 최적해를 찾기 위해 상당한 시간이 걸릴 수 있다.</p>

<p>한가지 더 생각해볼 문제는 <em>permutation</em> 이다. </p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/permutation.png'  alt="" /></p>

<p>만약 모든 <em>action</em> 이 <em>independent</em> 하다면, <em>solution</em> 까지의 <code>n</code> <em>action</em> 중  <code>n-1</code> <em>contour</em> 를 모두 방문해야 하므로 <code>(n-1)!</code> 의 성능이 나온다.</p>

<h3 id="goodheuristics">Good Heuristics</h3>

<p><em>heuristics</em> 이란 <em>goal node</em> 까지의 <em>estimatied value</em> 를 돌려주는 함수라고 기술적으로 정의할 수 있다.</p>

<ul>
<li><strong>heuristics</strong> are criteria, methods, or principles for deciding which among several alternative courses of action promises to be the most effeictive in order to achieve some goal</li>
</ul>

<p>그렇다면, 무엇이 <em>good heuristics</em> 일까?</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/good_heuristics.png'  alt="" /></p>

<p>평가해야할 <em>state</em> 를 줄이고, 적정 시간 내에 <em>solution</em> 을 찾을 수 있어야 한다. 간단할수록 정확도가 떨어지며, 정확할수록 복잡해진다. <em>accuracy</em> 와 관련해서는, 최적의 <em>actions</em> 을 찾아낸다는 보장은 없지만 <em>good heuristics</em> 이라면 그렇지 않은 것 보다 더 자주 <em>best course of actions</em> 를 찾을 수 있어야 한다.</p>

<ul>
<li>문제가 주어졌을때, 어떻게 좋은 <em>heuristics</em> 을 찾아낼 수 있을까?</li>
<li>이 과정을 자동화 할 수 있을까?</li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/relaxed_problem.png'  alt="" /></p>

<p><em>heuristics</em> 을 찾는 한 가지 방법은 <em>relaxed problem</em> 을 이용하는 것이다. <em>original problem</em> 에서 <em>action</em> 에 대한 <em>restriction</em> 을 좀 제거해서, 이에 대해 얻은 <em>optimal solution</em> 의 비용은 원본 문제에 대한 <em>admissible and consistent heuristic</em> 이다.</p>

<p>이는 <em>restriction</em> 이 제거되었기 때문에, 아무리 많아봐야 (<em>at most</em>) <em>original problem</em> 에 대한 <em>cost</em> 를 가지기 때문이다. 그러므로 <em>admissible</em> 하다. <em>eight-puzzle</em> 을 예로 들어보면 타일을 움직이는 <em>action</em> 에 대해 <em>adjacent</em> 또는 <em>blank</em> 조건을 버릴 수 있다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/8_puzzle_relaxed.png'  alt="" /></p>

<p>지금까지 배운내용들을 좀 정리하면</p>

<ul>
<li><p>Heuristic funciton encodes problem specific knowledge in a problem-independent way by mapping a state to a real number. This information about search states can be used to make the search more efficient</p></li>
<li><p>Greedy best-first search simply uses the heuristic function as the evaluation function. But better solution is provided by the A* algorithm. The evaluation function used by A* algorithm is simply the sum of the heuristic function for a node plus the cost of getting to thast node in the first place.</p></li>
<li><p>A* is optimal. It does not expand more nodes than absolutely necessary. But A* is not the answer to all questions, specifically when it comes to graph search.</p></li>
</ul>

<p><br/></p>

<h3 id="summary">Summary</h3>

<p>(1) <em>heuristic function</em> <code>h: state space -&gt; R</code> 은 <em>problem-specific knowledge</em> 를 <em>problem-independent way</em> 로 표현한다. 여기서 <code>h(n)</code> 값은 노드 <code>n</code> 에서 <em>goal</em> 까지의  <em>estimated cost</em> 의 최소 값이다.</p>

<p>(2) <em>best-first search</em> 는 <em>evaluation function</em> 인 <code>f</code> 를 기준으로 <code>f-value</code> 를 정렬해 다음에 어떤 노드를 탐색할지 결정한다.</p>

<p>(3) 만약 <code>f = h</code> 이면 <em>greedy best-first search</em> 라 부른다.</p>

<p>(4) <em>A* Search</em> 는 <em>evaluation function</em> <code>f(n) = h(n) + g(n)</code> 을 이용한다. <code>h(n)</code> 은 <em>heuristic function</em>, <code>g(n)</code> 은 <code>n</code> 까지 도달하는 비용이다. </p>

<p>(5) 따라서 <code>f(n)</code> 은 <code>n</code> 을 통과하여 <em>goal</em> 까지 도달하는데 걸리는 <em>cheapest solution</em> 의 <em>estimated cost</em> 다.</p>

<p>(6) 만약 <em>heuristic function</em> <code>h(n)</code> 이 <em>admissible</em> 하면, 다시 말해 <code>h(n) &lt;= actual distance</code> 이면 <em>A*</em> 는 <em>optimal solution</em> 을 돌려준다. 이는 <code>f(n) = g(n) + h(n)</code> 이기 때문이다.</p>

<p>(7) <em>A* search</em> 는 <em>complete</em> 하다. 이 말은 탐색과정에서 같은 비용으로 도달할 수 있는 모든 <em>state</em> 의 집합인 <em>contour</em> (등고선) 을 방문하면서 결국에는 <em>goal node</em> 를 찾는다는 뜻이다. </p>

<p>(8) 기하학적으로 보면 <em>heuristic</em> 이 정밀해질 수록 타원(등고선) 이 <em>goal state</em> 에 가깝게 넓어진다. </p>

<p><br/></p>

<h3 id="strips">STRIPS</h3>

<p>이제부터는 <em>STRIPS</em> 에 대해 알아보자. <em>planning</em> 의 본질은 원하는 <em>goal</em> 을 얻기 위한 <em>action</em> 을 결정하는 것이다. 즉, 시스템이 이런 결정을 내릴 수 있도록 해 주는 장치가 <em>planner</em> 인데, <em>STRIPS</em> 도 플래너다. </p>

<p><a href='http://en.wikipedia.org/wiki/STRIPS' >Wikipedia: STRIPS</a> 에 의하면</p>

<blockquote>
  <p>In artificial intelligence, STRIPS (Stanford Research Institute Problem Solver) is an <strong>automated planner</strong> developed by Richard Fikes and Nils Nilsson in 1971 at SRI International. The same name was later used to refer to the formal language of the inputs to this planner. This language is the base for most of the languages for expressing automated planning problem instances in use today; such languages are commonly known as action languages.</p>
</blockquote>

<p><em>STRIPS</em> 는 어떤 <em>action</em> 을 사용할지를 결정하는 시스템이므로 <em>representation</em> 과 <em>algorithm</em> 이 필요하다. </p>

<h3 id="structuredstates">Structured States</h3>

<p><em>representation</em> 의 일부인 <em>state</em> 에 대해 먼저 알아보자. <em>state</em> 에 <em>access</em> 할때는 </p>

<ul>
<li>goal test</li>
<li>applicable actions, successor states</li>
<li>equality test, hash function</li>
<li>heuristics estimate</li>
</ul>

<p>이런 행동을 하려면 <em>standardized</em> 된 <em>action</em> <em>state</em> 의 표현 방법이 있어야 하는데, <em>STRIPS repsentation</em> 이 하는 일이 바로 이것이다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_object.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_PDDL.jpg'  alt="" /></p>

<p>먼저 <em>object</em> 를 정의하고, 이를 <em>PDDL</em> <em>(Planning Domain Definition Language)</em> 로 작성한다. <em>robot</em> 은 쉽게 오브젝트라 생각할 수 있지만 <em>piles</em>, <em>pallet</em> 은 떠오르지 않을 수 있다. </p>

<p>두 <em>object</em> 간 관계는 <em>predicates</em> 라 부른다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_predicates.jpg'  alt="" /></p>

<p>여기서 <code>?l1</code>, <code>?l2</code> 등 물음표로 시작하는 것은 변수고 그 타입은 <code>- location</code> 처럼 뒤에 나온다. <a href='https://spark-public.s3.amazonaws.com/aiplan/resources/DWR-operators.txt' >DWR-operators</a> 링크에서 예제 <em>PDDL</em> 을 볼 수 있다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/states_in_strips.jpg'  alt="" /></p>

<p>우리가 작성한 <em>language</em> <code>L</code> 에는 많은 <em>predicates</em>, <em>objects (constant symbols)</em> 이 있지만, <em>functional symbol</em> 은 없다. </p>

<blockquote>
  <p>A state in a STRIPS planning domain is <strong>a set of ground atoms</strong> of <code>L</code></p>
</blockquote>

<p>여기서 <em>atom</em> 이란 <em>a predicate</em> 고, <em>ground</em> 하다는 것은 <em>predicate</em> 과 관련된 <em>object</em> 가 <em>variable</em> 이 아니고, 구체적인 인스턴스라는 뜻이다. </p>

<p>(1) <em>ground atom</em> <code>p</code> 가 <em>state</em> <code>s</code> 내에 있을때에만 <code>p</code> 가 참이다.</p>

<p>(2) <em>literal</em> 은 <em>positive</em> 일 수도 있고, <em>negative</em> 일 수도 있는 <em>atom</em> 이다. 이 때 <em>ground literals</em> <code>g</code> 내에 있는 모든 <em>positive literal</em> 이 <code>s</code> 내에 있고, <code>g</code> 내에 있는 모든 <em>negative literal</em> 이 <code>s</code> 내에 없으면 <em>state</em> <code>s</code> 는 <em>ground literals</em> <code>g</code> 를 만족시킨다.</p>

<h3 id="structuredoperators">Structured Operators</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/operators_actinos_strips.jpg'  alt="" /></p>

<p><em>planning operators</em> 는 <em>name</em>, <em>pre-condition</em>, <em>effect</em> 로 구성되는데, <em>pre-cond</em> 과 <em>effect</em> 는 <em>literals</em> 의 집합이다.</p>

<p>그리고 <em>action</em> 은 <em>planning operator</em> 의 <em>ground instance</em> 다. </p>

<p>쉽게 말해서 <em>operator</em> 는 <em>variable</em> 가 있는 <em>predicate</em> 의 집합이고, <em>action</em> 은 거기서 변수를 <em>constant</em> (실제 <em>object</em>) 로 치환한 것이다. <em>operator</em> 가 좀 더 <em>generic</em> 하다고 보면 이해하기 쉽다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_operators.jpg'  alt="" /></p>

<p>이 <em>operator</em> 를 <em>PDDL</em> 로 표현하면</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_operators_PDDL.jpg'  alt="" /></p>

<p>이제까지 본 <em>literals</em> 를 이용해 <em>applicable</em> 한지, 그리고 어떻게 <em>state transition</em> 을 하는지 살펴보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/state_transition_applicable.jpg'  alt="" /></p>

<p><code>L+</code>, <code>L-</code> 를 각각 <em>positive</em> <em>negative literals</em> 이라고 하자.</p>

<p><em>action</em> <code>a</code> <em>state</em> <code>s</code> 에 대해 <code>a</code> 의 <em>pre-cond+</em> 가 <code>s</code> 에 있고, <em>pre-cond-</em> 가 <code>s</code> 에 없으면 <em>applicable</em> 하다.</p>

<p>그리고 <em>applicable action</em> 에 대해서 <em>state transition</em> <code>r</code> 는 <em>state</em> <code>s</code> 에서 <code>a</code> 의 <em>effect-</em> 를 빼고, 거기에 <em>effect+</em> 를 합치는 것으로 정의한다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/finding_applicable_action.jpg'  alt="" /></p>

<ul>
<li><code>A</code> 는 <em>applicable actions</em> 다. 초기에는 <em>empty</em> </li>
<li><code>op</code> 는 <em>operator</em> </li>
<li><code>precs</code> 는 <em>remaining pre-cond</em></li>
<li>4번째 인자는 <em>value</em> 로 치환된 <em>substitution</em> 리스트다.</li>
<li><code>s</code> 는 <em>state</em></li>
</ul>

<p>먼저 <code>precs+</code> 가 비었는지 검사하고, 무언가 있다면 <code>pp</code> <em>positive pre-cond</em> 를 뽑아내, <em>propositions of state</em> <code>sp</code> 에서 <em>state</em> <code>s</code> 를 하나씩 검사한다. 만약 <em>substitution</em> 이 <em>valid</em> 하면 재귀적으로 반복한다.</p>

<p>더 이상 <code>precs+</code> 가 없으면 <code>precs-</code> 를 검사하면서, 만약 <em>state</em> 가 <em>negative pre-cond</em> <code>np</code> 를 만족하지 못하면, 리턴하고 모두 만족하면 <em>variable</em> 을 모두 치환하여 <em>applicable action</em> 리스트인 <code>A</code> 에 추가한다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/applicable_actions_ex.jpg'  alt="" /></p>

<p>그림에서 왼쪽 케이스를 보면 로봇 <code>r1</code> 이 도착지점인 <code>loc2</code> 에 존재할 수 없기 때문에 <em>not valid</em> </p>

<h3 id="domainsandproblems">Domains and Problems</h3>

<p><em>classical planning</em> 은 다음의 요소로 구성된다.</p>

<ul>
<li><strong>task:</strong> find solution for planning prolem</li>
<li><strong>planning problem:</strong> </li>
</ul>

<p>(1) initial state (atoms - relation, objects) <br />
(2) planning domain (operators - name, prec, effects) <br />
(3) goal  </p>

<ul>
<li><strong>solution</strong> (plan) </li>
</ul>

<p>STRIPS 도 마찬가지로</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/STRIPS_planning_domains.jpg'  alt="" /></p>

<p>따라서 <em>STRIPS planning</em> 문제는 <em>planning domain</em>, <em>inital state</em>, <em>goal</em> 로 구성된다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/STRIPS_planning_problems.jpg'  alt="" /></p>

<p><em>DWR domain</em> 간단예제를 좀 보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_strips_ex1.jpg'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_domain_strips_ex2.jpg'  alt="" /></p>

<p>전체 문제는 여기로 <a href='http://projects.laas.fr/planning/DWR-pb1' >DWR-pb1</a></p>

<p><br/></p>

<p>지금까지 본 것은 <em>planner</em> 에게 주어야할 <em>input</em> 이었다. 이제 <em>output</em> 인 <em>plan</em> 이 무엇인지 보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/classical_plans.jpg'  alt="" /></p>

<h3 id="statespacesearch">State-Space Search</h3>

<p>지금까지는 <em>representation</em> 에 대해 봤다. 지금부터는 STRIPS 에서 알고리즘을 어떻게 적용할지 알아보자. 기본적인 아이디어는</p>

<ul>
<li>search space is subset of state space</li>
<li>nodes correspond to world states</li>
<li>arcs correspond to state transitions</li>
<li>path in the search space correspaonds to plan</li>
</ul>

<p>따라서 <em>standard search algorithm</em> (e.g BFS, DFS, A*) 를 <em>planning problem</em> 에 적용할 수 있다. 좀 더 자세히 보자. <em>state-space planning</em> 을 <em>search problem</em> 으로 바꾸기 위해</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/state_space_to_search_problem.png'  alt="" /></p>

<p><em>initial state</em>, <em>goal</em>, 을 정하고 <em>path cost function</em> 으로 <em>action</em> 의 길이를 사용한다. <em>successor function</em> 은 </p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/reachable_successor_states.png'  alt="" /></p>

<p><em>successor state</em> 를 표시하기 위해 감마를 사용하고, 지수 위치에 있는 <code>0, m</code> 등은 몇번째 <em>succssor</em> 인지를 나타낸다. <code>U</code> 는 합집합, 유니온이다. 따라서 <em>transitive closure</em> 는 가능한 모든 합집합이다. (<em>reachable states from initial state</em>)</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/solution_existence.png'  alt="" /></p>

<p>따라서 <em>STRIPS planning problem</em> 에서는 <em>goal state</em> <code>S_g</code> 와 <em>reachable state</em> 인 <em>transitive closure</em> 의 교집합이 <em>empty</em> 가 아니어야 솔루션이 존재한다.</p>

<h3 id="forwardstatespacesearch">Forward State-Space Search</h3>

<pre><code>function fwdSearch(O, s_i, g)  
  state &lt;- s_i
  plan &lt;- &lt;&gt;

  loop
    if state.satisfies(g) then 
      return plan

    applicables &lt;- {ground instance from O applicable in state}

    if applicable.isEmpty() then 
      return failure

    action &lt;- applicable.chooseOne() ; non-deterministic
    state &lt;- r(state, action)
    plan &lt;- plan * &lt;action&gt; ; add action to plan
</code></pre>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/DWR_example_fwd_search.png'  alt="" /></p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/forward_search_properties.png'  alt="" /></p>

<p><em>forward search</em> 는 두가지 속성을 가지는데</p>

<ul>
<li><strong>sound:</strong> if the function returns a plan as a solution then this plan is indeed a solution</li>
<li><strong>complete:</strong> if there exists solution plan then there is an execution trace of the function that will return this solution plan</li>
</ul>

<h3 id="backwardstatespacesearch">Backward State-Space Search</h3>

<p><em>backward search</em> 는 <em>intial state</em> 부터 시작하는 것이 아니라 <em>goal</em> 부터 시작해서 거꾸로 진행하는 알고리즘이다. 먼저 <em>relevant</em> 와 <em>regression set</em> 의 개념부터 알아보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/relevance_regression_sets.png'  alt="" /></p>

<p><em>action</em> <code>a</code>, <em>goal state</em> <code>g</code> 에 대해 </p>

<ul>
<li><code>g</code> 와 <code>effect(a)</code> 의 교집합이 <em>empty</em> 가 아니고</li>
<li><code>g+</code> 와 <code>effect-(a)</code>, <code>g-</code> 와 <code>effect+(a)</code> 의 교집합이 <em>empty</em> 이면</li>
</ul>

<blockquote>
  <p><code>a</code> is relevant for <code>g</code></p>
</blockquote>

<p>이 때 <em>releavant action</em> <code>a</code> 에 대해 <code>g</code> 의 <em>regression set</em> 은 </p>

<p><code>r^(-1) (g, a) = (g - effect(a)) U precond(a)</code> 로 정의한다. <em>relavant action</em> 의 <em>effect</em> 를 제거하고, 그의 <em>pre-condition</em> 을 넣으면 <em>previous state</em> 가 되기 때문이다. 예제를 좀 보면</p>

<pre><code>(define (problem random-pbl1)
  (:domain random-domain)
  (:init
     (S B B) (S C B) (S A C)
     (R B B) (R C B))
  (:goal (and (S A A))))

(define (domain random-domain)
  (:requirements :strips)
  (:action op1
    :parameters (?x1 ?x2 ?x3)
    :precondition (and (S ?x1 ?x2) (R ?x3 ?x1))
    :effect (and (S ?x2 ?x1) (S ?x1 ?x3) (not (R ?x3 ?x1))))
  (:action op2
    :parameters (?x1 ?x2 ?x3)
    :precondition (and (S ?x3 ?x1) (R ?x2 ?x2))
    :effect (and (S ?x1 ?x3) (not (S ?x3 ?x1)))))  
</code></pre>

<p>여기서 <em>relevant action</em> 은 <code>(op1 A A A)</code>, <code>(op1 A A C)</code>, <code>(op1 A B A)</code> 다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/regression_function.png'  alt="" /></p>

<p>따라서 <em>backward search</em> 알고리즘을 이용하면, <em>state-space planning</em> 을 <em>search problem</em> 으로 바꿀때는</p>

<ul>
<li>initial state <code>g</code></li>
<li>goal test: <code>s_i</code> satisfies <code>s</code></li>
<li>path cost function: length of actions</li>
<li>successor function: <code>r^-1 (s)</code></li>
</ul>

<p>예제를 좀 보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/2-heuristic-strips/regression_with_operators.png'  alt="" /></p>

<h3 id="summary">Summary</h3>

<p><em>STRIPS</em> 세션을 정리하면</p>

<ul>
<li>STRIPS representation provides a standardized way of representing the <strong>internal structure of states</strong>, namely a sets of ground atoms. So we have objects thar are related by some relations, and sets of these atoms describe what the world states look like.</li>
<li>define interal structure of operators look like. negative effects, positive effects.</li>
<li>define planning domains (initial, goal state), problem using PDDL</li>
<li>to solve planning problem, we can use forward, backward search. Buy they are actually inefficient</li>
</ul>

<p>따라서 다음시간엔 <em>forward, backward</em> 보다 더 효율적인 알고리즘을 배운다.</p>

<h3 id="refs">Refs</h3>

<p>(1) <strong>Artificial Integelligence Planning</strong>, by Dr.Gerhard Wickler, Prof. Austin Tate <br />
(2) <a href='http://imgs.xkcd.com/comics/ai.png' >xkcd image</a> <br />
(3) <a href='http://en.wikipedia.org/wiki/STRIPS' >Wikipedia - STRIPS</a>  </p>]]></description><link>http://1ambda.github.io/ai-planning-2/</link><guid isPermaLink="false">03874979-cc59-4b5f-b9b1-eccfefd1ccc2</guid><category><![CDATA[coursera]]></category><category><![CDATA[artificial intelligence]]></category><category><![CDATA[STRIPS]]></category><category><![CDATA[heuristic]]></category><category><![CDATA[forward-search]]></category><category><![CDATA[backward-search]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 18 Jan 2015 00:26:31 GMT</pubDate></item><item><title><![CDATA[AI Planning 1, Intro]]></title><description><![CDATA[<p><img src='http://www.jcjones.com/Portals/96864/images/IT%20strategic%20planning.png'  alt="" /></p>

<p><br/></p>

<p><em>planning</em> 이란</p>

<ul>
<li>explicit deliberation process that chooses and organizes actions by anticipating their outcomes</li>
<li>aims at acheving some <strong>pre-stated objecives</strong></li>
</ul>

<p>결국 <em>AI planning</em> 이란</p>

<blockquote>
  <p>computational study of this deliberation process</p>
</blockquote>

<p><br/></p>

<p>이런 관점에서 볼 때 <em>AI planning</em> 을 연구하는 이유는</p>

<ul>
<li><p><strong>scientific goal of AI:</strong> <em>understand inteligence</em>. planning is an important component of rational behaviour</p></li>
<li><p><strong>engineering goal of AI:</strong> <em>build intelligent entitie</em> which are choosing and organizing actions for autonomous intelligent machines</p></li>
</ul>

<p><br/></p>

<p><em>planning</em> 을 크게 <strong>domain-specific</strong>, <strong>domain-independent</strong> 로 분류할 수 있다.</p>

<ul>
<li><strong>domain-specific planning:</strong> use specific representations and techniques adapted to each problem. </li>
</ul>

<p>중요한 도메인으로 path and motion, perception, manipulation, commuication planning 등이 있다.</p>

<ul>
<li><strong>domain-independent planning:</strong> use generic representations and techniques. exploit commonalities to all forms of planning. leads to general understanding of planning</li>
</ul>

<blockquote>
  <p><em>domain-independent planning</em> complements <em>domain-specific planning</em> </p>
</blockquote>

<p><br/></p>

<h3 id="conceptualmodelforplanning">Conceptual Model for Planning</h3>

<p>모델로 <em>state-transition system</em> 을 사용하는데, 이 시스템은 <code>(S, A, E, r)</code> 로 구성된다. </p>

<ul>
<li><code>S = {s1, s2,  ... }</code> is a finite or recursively enumerable set of states</li>
<li><code>A = {a1, a2,  ... }</code> is a finite or recursively enumerable set of actions</li>
<li><code>E = {e1, e2,  ... }</code> is a finite or recursively enumerable set of events</li>
<li><code>r: S x (A u E) -&gt; 2^S</code> is a state trasition function</li>
<li>if <code>a</code> in <code>A</code> and <code>r(s, a)</code> is <strong>not empty</strong>, <code>a</code> is applicable in <code>s</code></li>
</ul>

<p><em>state trasition function</em> 은 상태 <code>S</code> 와 액션 <code>A</code> 또는 이벤트 <code>E</code> 를 받아, 가능한 모든 상태 <code>2^S</code> 를 만든다.</p>

<p><em>state trasition system</em> 은 그래프를 이용해서 표현할 수 있다. <code>G = (N, E)</code> 에서 <em>node</em> <code>N</code> 은 상태를, <em>edge</em> <code>E</code> 는 <em>state transition</em> 을 나타낸다.</p>

<p><em>state trasition system</em> 은 모든 가능한 상태를 표현하는 좋은 방법이다. 그러나 우리가 실제로 원하는건 <em>plan</em> 이다. 여기서 <em>plan</em> 이라 하면 주어진 특정 <em>state</em> 에서 시작해서, 원하는 <em>objective</em> 를 얻기까지의 <em>action</em> 을 말한다.</p>

<p><em>objective</em> 는 조건을 만족하는 특정 상태 <code>s</code> 나, 상태의 집합이 될 수 있다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/plan_execution.png'  alt="" /></p>

<p><em>planning</em> 문제를 풀기 위해 <em>plan execution</em> 을 이용하는 경우가 많다. <em>planner</em> 는 <em>state transition system</em> <code>sigma</code> 와 <em>initial state</em>, <em>objectives</em> 를 받아 <em>plan</em> 을 만들고, <em>controller</em> 가 이와 <em>current state</em> (<em>observation</em>) 을 받아 가능한 <em>action</em> 을 만든다. <em>system</em> 은 <em>action</em> 과 외부의 <em>event</em> 에 의해 변화한다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/dynamic_planning.png'  alt="" /></p>

<p>그러나 많은 경우 <em>model</em> 과 현실의 <em>system</em> 이 일치하지 않기 때문에, <em>dynamic planning</em> 이란 방법을 사용한다.</p>

<p>만약 <em>controller</em> 가 <em>real system</em> 과 <em>model</em> 이 다른 경우를 인식해서 <em>planner</em> 에게 <em>execution status</em> 를 넘겨주어 새로운 <em>plan</em> 을 만들도록 한다. 이걸 <em>plan revision</em> 이라 부른다.</p>

<h3 id="searchproblem">Search Problem</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/search_problem.png'  alt="" /></p>

<p><em>search problem</em> 의 4가지 요소는 </p>

<ul>
<li>initial state</li>
<li>successor function</li>
<li>goal</li>
<li>path cost</li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/problem_formulation.png'  alt="" /></p>

<p>여기서 <em>static</em> 이란 말은 <em>no-event</em> 라는 뜻이다. <em>implicit time</em> 은 <em>activity</em> 의 <em>duration</em> 을 고려하지 않는다는 뜻이다.</p>

<h3 id="searchnode">Search Node</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/search_node.png'  alt="" /></p>

<p><em>search problem</em> 을 풀기 위한 알고리즘을 보기 전에, 어떻게 표현할 것인지를 먼저 이야기 하자. <em>search node</em> 의 구성 요소는</p>

<ul>
<li>state</li>
<li>parent node</li>
<li>action</li>
<li>path cost</li>
<li>depth</li>
</ul>

<p>이제 <em>general tree search algorithm</em> 을 보면</p>

<pre><code>function treeSearch(problem, strategy)  
  fringe &lt;- { new searchNode(problem.initialState) }

  loop
    if empty(fringe) then return failure

    node &lt;- selectFrom(fringe, strategy)

    if problem.goalTest(node.state) then
      return pathTo(node)

    fringe &lt;- fringe + expand(problem, node)
</code></pre>

<p>여기서 <code>problem</code> 은 <em>search problem</em> 으로, 위에서 언급 했듯이 <em>initial state</em>, <em>successor function</em>, <em>goal</em>, <em>path cost</em> 를 포함한다.</p>

<p><code>fringe</code> 는 아직 방문하지 않은 노드의 집합이고 마지막 부분에서 <code>expand</code> 함수는 <em>successor function</em> 을 적용해서 새로운 노드를 돌려준다. 이 과정을 <code>fringe</code> 가 비거나, 원하는 노드를 찾을때 까지 반복한다.</p>

<p>재밌는 사실은 <em>search graph</em> 가 유한하더라도 <em>search tree</em> 가 무한할 수 있다. 노드가 두개이면서 <em>bi-directed</em> 인 그래프를 생각해 보자.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/search_strategy.png'  alt="" /></p>

<p>위에서 본 <em>strategy</em> 는 <em>successfor function</em> 적용을 스케쥴링하는 요소다.</p>

<ul>
<li>selects the next node to be expanded from the fringe</li>
<li>determines the order in which nodes are expanded</li>
<li><strong>aim:</strong> produce a goal state as quickly as possible</li>
</ul>

<p><em>strategy</em> 가 <em>deterministic</em> 이면, 알고리즘도 <em>deterministic</em> 이라 볼 수 있다. 반대로 <em>strategy</em> 가 없으면 <em>non-deterministic</em> 이다.</p>

<p>대부분의 <em>search tree</em> 는 상당히 크다. 요즘 나오는 컴퓨터 메모리에도 올리기 부담스러울 정도로. 따라서 <em>strategy</em> 가 메모리에 올라갈 <em>tree</em> 부분을 결정하고, 그에 따라 알고리즘이 실패할지, 성공할지를 결정하므로 매우 중요하다.</p>

<h3 id="exampleproblem">Example Problem</h3>

<ul>
<li><strong>Sliding-Block Puzzle</strong> (<em>toy problem</em>)</li>
<li><strong>N-Queens</strong> (<em>toy problem</em>)</li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/DWR_domain.png'  alt="" />
<img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/DWR_state.png'  alt="" />
<img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/DWR_action.png'  alt="" />
<img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/DWR_system.png'  alt="" /></p>

<h3 id="context">Context</h3>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/o_plan_agent.png'  alt="" /></p>

<p><img src='https://spark-public.s3.amazonaws.com/aiplan/resources/AI-Planners-Chronology-1990-AI-Magazine.png'  alt="" /></p>

<p align="center">AI Planning, Coursera</p>

<p>그림의 윗 부분을 보면 <em>AI planning</em> 은 3가지 문제로부터 출발한 것을 볼 수 있다.</p>

<ul>
<li>Studies of Human Problem Solving</li>
<li>Operations Research</li>
<li>Theorem Proving</li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/practical_ai_planner.png'  alt="" />
<img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/nonlin.png'  alt="" />
<img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/o_plan.png'  alt="" /></p>

<p><em>O-Plan</em> 은 유닉스 시스템 어드민의 역할을 수행했다고 한다. 쉘 스크립트를 만들고, 볼륨을 삭제하거나 추가하는 등</p>

<p><em>practical AI planner</em> 의 특징으로는</p>

<ul>
<li>hierarchical task network (HTN) planning</li>
<li>partial order planning (POP)</li>
<li>rich domain model</li>
<li>detailed constraint mgmt, simuilations and analyses</li>
<li>intergration with other systems (UI, DB, spreadsheets, etc)</li>
</ul>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/ai-planning/1-intro/planning_area_tech.png'  alt="" /></p>

<h3 id="coursereading">Course Reading</h3>

<p>(1) <a href='http://aaaipress.org/ojs/index.php/aimagazine/article/download/833/751' >Review of AI Planners to 1990</a>  </p>

<p>Hendler, J.A., Tate, A. and Drummond, M. (1990) “AI Planning: Systems and Techniques”, AI Magazine Vol. 11, No. 2, pp.61-77, Summer 1990, AAAI Press. </p>

<p>(2) <a href='http://www.aiai.ed.ac.uk/project/ix/documents/2003/2003-luc-tate-oplan-web.pdf' >O-Plan Paper</a>  </p>

<p>Tate, A. and Dalton, J. (2003) “O-Plan: a Common Lisp Planning Web Service”, invited paper, in Proceedings of the International Lisp Conference 2003, October 12-25, 2003, New York, NY, USA, October 12-15, 2003. (4 pages) </p>

<h3 id="refs">Refs</h3>

<p>(1) <a href='http://www.jcjones.com/Portals/96864/images/IT%20strategic%20planning.png' >Planning Image</a> <br />
(2) <a href='https://spark-public.s3.amazonaws.com/aiplan/resources/AI-Planners-Chronology-1990-AI-Magazine.png' >AI Planning History Image</a>  </p>]]></description><link>http://1ambda.github.io/ai-planning-1/</link><guid isPermaLink="false">4a959a91-fe5a-47d6-b77b-f5b6b976928a</guid><category><![CDATA[artificial intelligence]]></category><category><![CDATA[planning]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 17 Jan 2015 13:53:19 GMT</pubDate></item><item><title><![CDATA[Intractability]]></title><description><![CDATA[<p><img src='http://simonsoftware.se/xkcdsw/comics/np_complete.png'  alt="" /></p>

<ul>
<li>What is a general-purpose computer?</li>
<li>Are there limits on the power of digital computers?</li>
<li>Are there limits on the power of machines we can build?</li>
</ul>

<p>컴퓨터 과학자들이 <em>computation</em> 에 관해 질문해 온 것들이다. 이 문제에 답하기 위해 <em>computation model</em> 을 좀 살펴보자.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5WXdJalozUVRNd1lUTTBJV0xqSlRNNDBpTmpsek10TVdaM0VUTHpVRE1tWkRPbVoyTHdRVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>긴 테이프가 있고, 기계는 테이프를 하나씩 읽어 <code>0</code>인지 <code>1</code> 인지 판별한다. 여기서 읽는것 뿐만 아니라 출력까지 가능하면 <em>turing machine</em> 이 된다. 일종의 <em>universal computation model</em> 이다.</p>

<p><img src='http://physics.kenyon.edu/coolphys/thrmcmp/turing.jpg'  alt="" /></p>

<p align="center">(<a href='http://physics.kenyon.edu/' >http://physics.kenyon.edu</a>)</p>

<p>근데 놀랍게도 이것보다 더 진보한 연산 모델이 있느냐? 라는 질문에 대해 <strong>없음</strong> 이란 연구 결과가 나왔다고 한다.</p>

<blockquote>
  <p><strong>Church-Turing thesis:</strong></p>
  
  <p>Turing machines can compute any function that can be computed by a physically harnessable process of the natural world.</p>
</blockquote>

<p>여기서 <em>thesis</em> 인 이유는 증명이 아니기 때문이다. <em>mathmatical theorem (정리)</em> 가 아니다. 결국 이것이 의미하는 바는</p>

<ul>
<li>No need to seek more powerful machines or languages</li>
<li>Enables rigorous study of computation (in this universe)</li>
<li>Turing machine is a simple and universal model of computation</li>
</ul>

<p><em>Church-Turing thesis</em> 에 대해 80 년동안이나 반례가 발견되지 않았다. 그리고 수 많은 <em>computation model</em> 이 발견되었지만 모두 <em>turing machine</em> 과 동일한 것으로 밝혀졌다. (lambda caculus, URM, SKI 등)</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWWtOR1owa1ROMFkyTjVnVEx6WWpaNTB5TWxWek10VVRPaFZXTDRVek16Z1RPd1UyTHlRVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>일반적으로 <em>useful algorithm</em> 이란 모든종류의 입력 에 대해 <em>polynomial time</em> <code>aN^b</code> 시간 내에 풀 수 있는 것을 <em>useful algorithm</em> 이라 말한다. </p>

<p><em>polynomial time</em> 알고리즘은 대부분 작은 <code>a, b</code> 를 가지기 때문에 다양한 문제로 적용하는것도 가능하다. 그러나 <code>a, b</code> 가 큰 경우 풀수 없는것과 마찬가지 일때도 있다.</p>

<blockquote>
  <p>Exponential growth dwarfs technological change</p>
</blockquote>

<p>유용하지 않은 알고리즘의 예로, <code>N</code> 지점에 대한 <em>TSP</em> 는 <em>brute force</em> 를 이용하면 <code>N!</code> 이다.</p>

<p>얼마나 유용하지 않은가를 좀 더 생각해보자. 만들 수 있는 가장 큰 병렬 슈퍼컴퓨터를 가정 해보면</p>

<ul>
<li>Suppose you have a giant parallel computing device</li>
<li>With as many processors as eletron in the universe</li>
<li>And each processor has power of today's supercomputers</li>
<li>ANd each processor works for the life of the universe</li>
</ul>

<p>1000 도시의 <em>TSP</em> 를 <em>brute force</em> 로 풀려면, 이 병렬 슈퍼컴퓨터를 우주의 일생동안 돌려도 불가능하다.</p>

<p><code>1000! &gt; 10^1000 &gt; 10^79 * 10^13 * 10^17</code></p>

<p>이런 이유에서 어떤 문제가 <em>polynomial time</em> 내에 풀 수 없으면 <em>intractable</em> 하다고 말한다.</p>

<p>결국 우리가 풀 수 있는 문제는 <em>poly-time algorithm</em> 이 있는 경우이며, 어떤 문제가 이런 <em>poly-time algorithm</em> 을 가질까? 그건 쉽지 않다. 연구중이라고 함.</p>

<p>연구된 바로는 두 종류의 문제가 <em>exponential time</em> 일 것으로 본다.</p>

<ul>
<li>Given a constant-size program, does it half it at most K steps? (input size = <code>c + lgK</code>)</li>
<li>Given <code>N</code>-by-<code>N</code> checkers board position, can the first player foce a win?</li>
</ul>

<h3 id="fourfundamentalproblems">Four fundamental problems</h3>

<p>(1) <strong>LSOLVE:</strong> Given a system of <strong>linear equations</strong>, find a solution</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDT3hVR1ppRkRaeFlETmhaV0x3TVdPaTF5TW1Sek10Z1ROMFlUTG1GVE16UVdZbUYyTDJRVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>가우시안 소거법으로 <em>N-by-N</em> 시스템에서 <code>N^3</code> 시간 안에 해결된다.</p>

<p>(2) <strong>LP:</strong> Given a system of <strong>linear inequalities</strong>, find a solution</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWjRFbVl4STJZNWtET2pGV0xsUkRNaTFDTmpGek10a1RZbFZXTDNrek5sWlRZd1l6TDRRVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><em>Ellipsoid</em> 알고리즘을 이용하면 <em>poly-time</em></p>

<p>(3) <strong>ILP:</strong> Given a system of <strong>linear inequalties</strong>, find <code>0-1</code> solution</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWjFNRE4yWVdNaFZUWnpRV0xrSnpZaTF5TXprek10WUdOaEpUTDRRak5sZGpObGx6THdVVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>no <em>poly-time</em> algorithm known. 있을거 같긴 한데 모른다고 함</p>

<p>(4) <strong>SAT:</strong> Given a system of <strong>boolean equations</strong>, find a binary solution</p>

<p>no <em>poly-time</em> algorithm known 이것도 있을거 같긴 한데 모른다고 함</p>

<h3 id="searchproblems">Search Problems</h3>

<blockquote>
  <p>Given an instance <code>I</code> of a problem, find a solution <code>S</code> or report none exists</p>
</blockquote>

<p>답이 있거나, 없음을 말해줘야 하는데 이를 위해서 효율적으로 (<em>poly-time</em>) <code>S</code> 가 정답인지 검사할 수 있어야 한다.</p>

<p>위에서 본 <em>LSOLVE</em>, <em>LP</em>, <em>ILP</em>, <em>SAT</em> 문제 같은 경우 정답이 있으면 대입해서 <em>poly-time</em> 내에 검증할 수 있으므로 <em>search problem</em> 이다.</p>

<p><em>factor problem</em> 도 <em>search problem</em> 이다. 주어진 <code>n</code> 비트 정수에 대해서, <em>nontrivial factor</em> 인지 아닌지는 나눠보면 되니까.</p>

<p>즉 <em>search problem</em> 에서는 답을 누군가 제공할때 그것이 답인지 아닌지를 <em>poly-time</em> 으로 검사할수 있냐 없냐가 중요하다.</p>

<h3 id="np">NP</h3>

<ul>
<li><strong>NP:</strong> is the class of all search problems. (class definition limits <strong>NP</strong> to yes-no problem)</li>
</ul>

<p>앞에서 본 <em>LSOLVE</em>, <em>LP</em>, <em>ILP</em>, <em>SAT</em>, <em>FACTOR</em> 모두 <strong>NP</strong> 다.</p>

<ul>
<li><strong>P:</strong> is the class of search problems solvable in <em>poly-time</em></li>
</ul>

<p><em>LSOLVE</em>, <em>LP</em>, <em>SORT</em>, <em>STCONN</em> 의 문제는 모두 <strong>P</strong> 다.</p>

<p>즉 답을 <em>poly-time</em> 내에 검증이 가능하면 <strong>NP</strong> 고, 거기에 답을 <em>poly-time</em> 내에 찾는것이 가능하면 <strong>P</strong> 란 이야기. <strong>P</strong> 가 중요한 이유는, 현실적으로 계산 가능한 문제이기 때문이다. </p>

<p>이론적으로는 <code>1010401 * N ^(10^23)</code> 도 계산 가능하다고 본다. <del>음!?!</del></p>

<h3 id="nondeterminism">Nondeterminism</h3>

<blockquote>
  <p>Nondeterministic machine can <strong>guess</strong> the desired solution</p>
</blockquote>

<p><em>regex</em> 의 패턴매칭을 구현할때 했었던 <em>NFA</em> 처럼 일종의 <em>nondeterministic machine</em> 이 있다 하고, 이 기계가 답을 찾아준다고 하자. 예를 들면 이런 느낌이다.</p>

<pre><code class="java">int[] a = new int[N];  
</code></pre>

<p>자바에선 <code>0</code> 으로 초기화 되는데, <em>nondeterministic machine</em> 을 이용하면 답으로 초기화 해주는 것이다.</p>

<p><em>DFA</em> 를 <em>NFA</em> 로 바꾸었듯이, 같은 입력에 대해 다수의 상태를 가지도록 함으로써 튜링 머신(이하 <em>TM</em>) 도 쉽게 <em>nondeterministic</em> 로 만들 수 있다. </p>

<p>그러면 이제 <strong>NP</strong> 가 의미하는 바를 확실히 이해할 수 있다. <em>nondeterministic polynomial time</em>, 다시 말해 <em>search problem</em> 이 <em>nondeterministic TM</em> 위에서 <em>poly-time</em> 내에 풀 수 있다는 것이다.</p>

<p>(1) <em>nondeterministic TM</em> 이 답을 제공한다 <br />
(2) <em>search problem</em> 은 <em>poly-time</em> 내에 답인지 아닌지 판별이 가능하다.</p>

<p>조금 더 이해를 위해 <a href='http://ko.wikipedia.org/wiki/P-NP_%EB%AC%B8%EC%A0%9C' >위키</a>를 인용하면</p>

<blockquote>
  <p>P는 결정론적 튜링 기계를 사용해 다항 시간 내에 답을 구할 수 있는 문제의 집합이고, NP는 비결정론적 튜링 기계를 사용해 다항 시간 내에 답을 구할 수 있는 문제의 집합이다. 여기에서 결정론적 튜링 기계에 사용한 프로그램을 비결정론적 튜링 기계에 적용할 수 있으므로, P는 NP의 부분집합이 된다. 하지만 여기에서 P와 NP가 같은 집합인지, 아니면 P가 NP의 진부분집합인지는 아직 밝혀지지 않았다. 현재 2000년에 클레이 수학연구소가 100만 달러를 걸었다.</p>
</blockquote>

<h3 id="extendedchurchturingthesis">Extended Church-Turing Thesis</h3>

<p>이제까지 나온바를 정리하면</p>

<ul>
<li><strong>NP:</strong> search problems solvable in <em>poly-time</em> on a <strong>nondetermimistic TM</strong></li>
</ul>

<p>그리고 <em>extended Church-Turing thesis</em> 에 의하면</p>

<ul>
<li><strong>P:</strong> search problems solvable in <em>poly-time</em> in the <strong>natural world</strong></li>
</ul>

<p>따라서 </p>

<ul>
<li>To make future computers more efficient, suffices to focus on impoving implementation of existing design</li>
</ul>

<h3 id="pvsnp">P vs NP</h3>

<p><strong>P</strong> = <strong>NP</strong> 일까? 이게 사실이라면, <em>search problem</em> 에서 <em>exponential time</em> 의 <em>brute force</em> 방법을 사용하지 않아도 된다. <em>poly-time</em> 알고리즘이 있다는 이야기니까.</p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/P_np_np-complete_np-hard.svg/800px-P_np_np-complete_np-hard.svg.png'  alt="" /></p>

<p align="center">(<a href='http://commons.wikimedia.org/' >http://commons.wikimedia.org/</a>)</p>

<p><code>P = NP</code> 일 경우 <em>nondeterministic TM</em> 이 별 도움이 안된단 이야기고, <code>P != NP</code> 일 경우, </p>

<blockquote>
  <p>If no, Would learn something fundamental about our universe</p>
</blockquote>

<p>대부분의 학자들은 <code>P != NP</code> 라 믿는다. 이는 <em>non-deterministic TM</em> 이 이전까지 우리가 사용했던 머신보다 더 강력하기 때문이라고 한다. 즉, 문제를 해결하기 위해 필요한 머신의 성능이 훨씬 좋아야 하므로 <code>NP</code> 가 <code>P</code> 와 같진 않을거라는 이야기</p>

<h3 id="classifyingproblems">Classifying Problems</h3>

<ul>
<li><strong>SAT problem:</strong> Given a system fo boolean equations, find a solution</li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWXpFVE81TUdNMWdUTjFVVExqUnpOaTFTTWtKek10Z0RPNU1UTGhCRFp3QVRabVp6THlVVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><code>n</code> 변수의 <em>SAT</em> 문제를 <em>exhausitve search</em> 로 풀면, <code>2^n</code> 의 모든 경우를 다 시도 해봐야 한다. 더 빠른, <em>poly-time</em> 알고리즘으로 풀수는 없을까?</p>

<p>슬프게도 많은 학자들이 연구해 왔지만, 아직까지 발견되지 않았고 대부분의 학자들이 <em>SAT</em> 문제가 <strong>NP</strong> 라는 것에 동의한다. 증명되지 않았으므로 일종의 가정인데, 이 가정을 이용해 <em>reduction</em> 을 해 보자. 그럼 <em>intractable</em> 한 알고리즘을 찾아낼 수 있다.</p>

<blockquote>
  <p>Problem <code>X</code> <strong>poly-time reduces</strong> to problem <code>Y</code> If <code>X</code> can be solved with:</p>
  
  <ul>
  <li>Polynomial number of standard computational steps</li>
  <li>Polynomial number of calls to <code>Y</code></li>
  </ul>
</blockquote>

<p>따라서 <em>SAT</em> 를 문제 <code>Y</code> 로 <em>poly-time reduction</em> 가능하면, <code>Y</code> 는 (거의) <em>intractable</em> 이다. </p>

<ul>
<li>If <code>X</code> cannot be solved in <em>poly-time</em>, then <code>Y</code> connot be solved in *poly-time</li>
<li>If <code>Y</code> can be solved in <em>poly-time</em>, then so can <code>X</code></li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5WTNFRE0zSXpOd1lHTWpsVEx6RWpZNTB5WTBjek10TW1aeVFXTGpKRE40QXpZa056TDJZVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWXpnalkzWXpZbWRqTmpKVEx6SW1NaTFTTmlSMk10a2pZMlVXTDVVV1p4VVRabUoyTDVZVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<h3 id="npcompleteness">NP-Completeness</h3>

<blockquote>
  <p>An <em>NP</em> problem is <strong>NP-complete</strong> if all problems in NP <em>poly-time reduce</em> to it</p>
</blockquote>

<p>즉 모든 <em>NP</em> 문제가 어떤 문제 <code>A</code> 로 <em>poly-time reduction</em> 이 되면 <code>A</code> 는 <em>NP-complete</em> 라는건데, <em>Cook, 1971</em> 에 의해 <em>SAT</em> 가 <em>NP-complete</em> 임이 증명되었다.</p>

<p>증명을 간단히 요약하면</p>

<ul>
<li>Convert <em>non-deterministic TM</em> notation to <em>SAT</em> notation</li>
<li>If you can solve <em>SAT</em>, you can solve any problem in <em>NP</em></li>
</ul>

<p>일종의 <em>reduction</em> 이다.<em>SAT</em> 인스턴스를 <em>poly-time</em> 으로 풀면 <em>non-deterministic TM</em> 문제로 풀 수 있는 <em>NP</em> 문제도 <em>poly-time</em> 으로 풀수 있게된다. </p>

<ul>
<li><em>SAT</em> 를 <em>poly-time</em> 으로 풀면 <code>P = NP</code></li>
<li><em>NP</em> 문제에 대해 <em>poly-time</em> 알고리즘이 없으면 <em>SAT</em> 에 대해서도 없다.</li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWWloVE0zTVdPMlVUWTNNVExoTmpNaTFTWjNJMk10TVdPMVFUTDRJR01sVjJNMEF6TDBjVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5TmxKVE16VURaa2hqWXdVVExqVkRaNTBDTmlWMk10SVdZaVpXTHpRVE94WXpNbGR6TDJjVE8xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>많은 문제가 <em>NP-complete</em> 다.</p>

<h3 id="copingwithintractability">Coping With Intractability</h3>

<p>암호학 같은 경우 <em>intractability</em> 가 널리 쓰인다. <em>RSA</em> 의 경우 </p>

<ul>
<li>To use: multiply two <code>n</code>-bit integers (<em>poly-time</em>)</li>
<li>To break: factor a 2 <code>n</code>-bit integer (unlikely <em>poly-time</em>)</li>
</ul>

<p>근데 1994년에 양자 컴퓨터로는 <code>n</code> 비트 <em>FACTOR</em> 문제가 <code>n^3</code> 안에 풀릴 수 있다는 가설이 제기되었다. 그럼 실 세계에서는 <code>P</code> 만 <em>poly-time</em> 으로 풀린다는 <em>extended Church-Turing thesis</em> 는..</p>

<p>아무튼 <em>intractability</em> 를 해결하기 위해서 쓸 수 있는 몇 가지 테크닉이 있다.</p>

<p>(1) Solve arbitrary instances of the problem</p>

<p><em>specialc cases</em> 는 <em>tractable</em> 일 수 있다. 예를 들어 <code>2-SAT</code> 은 <em>linear time</em> 이다.</p>

<p>(2) Solve the problem to optimality</p>

<p><em>heuristic</em> 을 이용해 알고리즘을 만드는 방법도 있다. 최적은 아니지만 좋은 결과를 낼 수도 있기 때문이다. (TSP assigment heuristics)</p>

<p>그리고 대부분 좋은 결과를 돌려주는 <em>approximation algorithm</em> 을 이용할 수도 있다. <code>MAX-3SAT</code> 은 <code>87.5%</code> 는 보장한다고 함.</p>

<p>(3) Solve the problem in <em>poly-time</em></p>

<p>Complexity theory deals with worst case behavior</p>

<h4 id="hamiltonpath">Hamilton path</h4>

<p>해밀턴 경로의 경우 모든 정점을 한번씩 방문해야 하는데, <em>NP-complete</em> 문제라고 한다. 오일러 경로(<em>edge</em>) 는 쉽다고 함. </p>

<p><em>exponential time</em> 으로 구현할 수 있다. 일반 <em>DFS</em> 와 다른점은 <em>clean up</em> 부분.</p>

<pre><code class="java">public class HamiltonPath  
{
    private boolean[] marked; // vertices on current path
    private int count = 0; // number of Hamiltonian paths

    public HamiltonPath(Graph G)
    {
        marked = new boolean[G.V()];
        for (int v = 0; v &lt; G.V(); v++)
            dfs(G, v, 1);
    }

    //depth is the length of current path (depth of recursion)
    private void dfs(Graph G, int v, int depth)
    {
        marked[v] = true;
        if (depth == G.V()) count++;
        for (int w : G.adj(v))
            if (!marked[w]) dfs(G, w, depth+1); //backtrack if w is already part of path
        marked[v] = false; // clean up
    }
}
</code></pre>

<h3 id="summary">Summary</h3>

<ul>
<li><strong>P:</strong> Class of search problems solvable in <em>poly-time</em></li>
<li><strong>NP:</strong> Clas of all search problems, some of which seem wickedly hard</li>
<li><strong>NP-complete:</strong> Hardest problems in <em>NP</em></li>
<li><p><strong>Intractable:</strong> Problem with no <em>poly-time</em> algorithm</p></li>
<li><p>A <em>poly-time</em> algorithm for an <strong>NP-complete</strong> problem would be a stunning breakthrough (a proof that <code>P = NP</code>)</p></li>
<li>You will confront <strong>NP-complete</strong> problems in your career</li>
<li>Safe yo assume that <code>P != NP</code> and that such problem are intractable</li>
<li>Identify these situations and proceed accordingly</li>
</ul>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='http://www.programering.com/a/MDN4QTMwATQ.html' >Lecture note: intractability</a> <br />
(4) <a href='http://simonsoftware.se/xkcdsw/comic.php?id=44' >xkcd image</a> <br />
(5) <a href='http://physics.kenyon.edu/coolphys/thrmcmp/newcomp.htm' >Turing machine image</a> <br />
(6) <a href='http://ko.wikipedia.org/wiki/P-NP_%EB%AC%B8%EC%A0%9C' >Wikipedia: P-NP 문제</a>  </p>]]></description><link>http://1ambda.github.io/intractability/</link><guid isPermaLink="false">720fd787-5da7-4853-9742-ecf8045586a3</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[intractability]]></category><category><![CDATA[P vs NP]]></category><category><![CDATA[NP completeness]]></category><category><![CDATA[search problem]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 31 Dec 2014 18:47:29 GMT</pubDate></item><item><title><![CDATA[Linear Programming]]></title><description><![CDATA[<p><img src='https://d262ilb51hltx0.cloudfront.net/max/800/1' *WBYODRJUgH8h_QEPnaWS-w.png" alt="" /></p>

<ul>
<li><strong>linear programming:</strong> problem-solving model for optimal allocation of scarce resources, among a number of competing activities that <strong>encompasses</strong></li>
</ul>

<p><em>maxflow</em>, <em>MST</em>, <em>shortest paths</em>, <em>assigment</em>, <em>Ax = b</em>, <em>2-person zero-sum games</em> 등이 있다.</p>

<p>다시 말해서, <em>constraints</em> 를 지키면서 특정 값을 <em>maximize</em> 하는 문제다. 따라서 주어진 문제를 아래의 형태로 <em>reduction</em> 해야 한다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDT3lZak4xUWpNM2NEWmhkVEw1a2pZaDFDT3dNek10RTJONFVXTGtGV1ozVXpNeE0yTDFNak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p algin="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<ul>
<li>fast commercial colvers available</li>
<li>widely applicable problem-solving model</li>
<li>key subroutine for integer programming solves</li>
</ul>

<p>이므로 중요하다고 한다.</p>

<h3 id="brewersproblem">Brewer's Problem</h3>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTWhKRE1pRldPM0lHTmlOV0x6a1RZaDFTTXpJMk10RVdZM1FXTDNJMk00SVROMkUyTDRFak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>양조장에서 맥주 <code>ale</code>, <code>beer</code> 를 생산하는데, 재료인 <code>corn</code>, <code>hops</code> <code>malt</code> 에 의해 생산량이 정해진다. 그리고 두 맥주는 들어가는 재료의 비율이 <del>당연히</del> 다르다.</p>

<p>이 때, 이익을 최대로 하는 각 맥주의 생산량을 구하는 문제다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWnpNbVl5SXpOa0JUWnhnVEwya0ROaTFTWTBZek10VWpNNFFXTDRFbVkxUXpZeWt6THdJak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" />
<img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWTRjRE1tSjJZaWhqWTFRVEx6WUdaNDBTTWhsek10UXpNakpXTHpFR08zVUdaM0V6THpJak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p algin="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>위 그림처럼 <em>contraints</em> 를 그래프 문제로 변환할 수 있다. 이 때 이익을 최대로 하는 <em>optimal solution</em> 은 <em>extreme point</em> 에 위치하는데 이 점들은 <em>2d</em> 에선 2개의 <em>constraints</em> (선분) 이 교차하는 지점에 위치한다.</p>

<p>따라서</p>

<blockquote>
  <p><strong>Goal</strong> maximize linear objective function of <code>n</code> nonnegative variables, subjet to <code>m</code> linear equations</p>
</blockquote>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5TnhFV015UUdOaFpETjVJVExoWnpNaDFDTzNjek10TUdOemdUTDRNMk16STJNaEZ6TDFJak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>문제를 <em>standard form</em> 으로 표시하면</p>

<ul>
<li>add variable <code>Z</code> and equation corresponding to objective function</li>
<li>add <em>slack</em> variable to convert each inequality to an equality</li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDT3lZak4xUWpNM2NEWmhkVEw1a2pZaDFDT3dNek10RTJONFVXTGtGV1ozVXpNeE0yTDFNak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<h4 id="geometry">Geometry</h4>

<ul>
<li>Inequalities define <strong>halfspaces</strong>. feasible region is a <strong>convex polyhedron</strong></li>
<li>A set is <strong>convex</strong> if for any two points <code>a</code> and <code>b</code> in the set, so is <code>1/2(a+b)</code></li>
<li>An <strong>extreme point</strong> of a set is a point in the set that can't be written as <code>1/2(a+b)</code>, where <code>a</code> and <code>b</code> are two distinct points in the set.</li>
</ul>

<p><img src='http://mathworld.wolfram.com/images/eps-gif/ConvexConcave_1000.gif'  alt="" /></p>

<p align="center">(<a href='http://mathworld.wolfram.com/Convex.html' >http://mathworld.wolfram.com/Convex.html</a>)</p>

<p>즉 두 점이 있을때 그 가운데 위치하는 점도 집합 안에 있으면 그 집합은 <em>convex</em> 라 부른다. <em>extreme point</em> 는 도형의 가장 바깥쪽 부분으로 그것보다 외부의 점이 없기 때문에 <code>1/2(a+b)</code> 로 바꿀 수 없다.</p>

<ul>
<li><strong>Extreme point property:</strong></li>
</ul>

<p>If there exists an optimal solution to <code>P</code> (plane), then there exists one that is an extreme point</p>

<p>(1) Number of extreme points to consider is <strong>finite</strong> <br />
(2) But number of extreme points can be <strong>exponential</strong> <br />
(3) Extreme point optimal iff no better adjacent extreme point (<em>greedy property</em>)</p>

<p>특히 3번은 중요한데, <em>global optimum</em> 인지 알기 위해 인접부분만 검사하면 된다. 이는 <em>objective function</em> 이 선형이고, <em>feasible region</em> 이 <em>convex</em> 이기 때문이다.</p>

<h3 id="simplexalgorithm">Simplex Algorithm</h3>

<p>1947년에 만들어진 알고리즘으로 20세기를 대표하는 탑 10 알고리즘중 하나라고 한다. <em>generic algorithm</em> 인데</p>

<ul>
<li>start at some extreme point</li>
<li><strong>Pivot</strong> from one extreme point to an adjacent one (never decreasing objective function)</li>
<li>repeat until optimal</li>
</ul>

<p>위에서 언급했던 <em>greedy property</em> 를 보면 이해가 쉽다. <em>objective function</em> 을 증가시키는 방향으로 <em>extreme point</em> 를 옮겨가다보면 <em>global optimum</em>을 찾을 수 있다.</p>

<h4 id="basicfeasiblesolution">Basic feasible solution</h4>

<blockquote>
  <p>A <strong>basis</strong> is a subset of <code>m</code> of the <code>n</code> variables</p>
</blockquote>

<ul>
<li>set <code>n-m</code> nonbasic variables to <code>0</code>, solve for remaining <code>m</code> variables</li>
<li>solve <code>m</code> equations in <code>m</code> unknowns</li>
<li>if unique and feasible => BFS</li>
<li>BFS &lt;=> extream point</li>
</ul>

<p>뭔소린가 한참을 쳐다봤는데, 그림으로 이해하는게 더 쉽다. <code>n</code> 개의 변수중 <code>m</code> 개를 제외한 것을 다 <code>0</code> 으로 하고, 방정식을 풀면 된다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTT21WMlloUm1aM2dUTmxKV0xsSm1ONTBDT3pVek10STJZM0lUTGtoVE9rTldaeWN6TDFRak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p algin="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p><em>slack variables</em> 로 구성된 <em>basis</em> 부터 시작해서 <em>pivot</em> 연산을 해 나아가면 된다. </p>

<ul>
<li>use the variable whose coefficient in objective function is positive to replace some one in the basis  (each unit increase in that variable from 0 increases objective value due to positive coefficient)</li>
</ul>

<p><em>objective function</em> 에서 계수가 양수인 수를 골라 치환하기 때문에 <code>Z</code> 값이 증가할수 밖에 없다. </p>

<ul>
<li>which variable to replace: </li>
</ul>

<p>Preserves feasibility by ensuring <code>RHS ≥ 0</code> and use minimum ratio rule: <code>min { 480/15, 160/4, 1190/20 }</code></p>

<ul>
<li>when to stop: When no objective function coefficient is positive.</li>
</ul>

<p>처음상태 <code>basis = {SC, SH, SM}</code> 에서 <em>constraint</em> <code>B</code> 를 <code>B = (1/15)(450 - 5A - SC)</code> 로 치환하면 <code>B</code> 가 <code>SC</code> 를 대신에 <em>basis</em> 에 들어간다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWjJFRE5qUkdNeElqTjNRV0wzVTJOaDFpTTNVMk10VVRPMGNUTDVZelkwWUdaMUl6THdVak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" />
<img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTWhWVE5rbERabFJtTTRFV0xqRlRONTBpWmpWek10a1ROMFlXTGtOVFl5QWpNNUV6THlVak4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p algin="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p><code>A</code> 까지 치환하면 <em>objective function</em> 에 양수 계수를 가지는 변수가 없으므로  <code>Z</code> 가 더 증가할 여지가 없다. </p>

<h3 id="implementation">Implementation</h3>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTmtGRE1pZHpObEoyWXdrVEwwVVRZNDBTWjBNek10UWpaMVVUTHlJRE1pRkRNMEUyTDBNek4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTWpkVFpqUkRad0FETjFFV0w1VW1aNTBpWTJVMk10Z0RONU1UTG1GV1kwQUROelEyTDNNek4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<pre><code class="java">public class Simplex  
{
    private double[][] a; // simplex tableaux
    private int m, n; // M constraints, N variables

    public Simplex(double[][] A, double[] b, double[] c)
    {
        m = b.length;
        n = c.length;
        a = new double[m+1][m+n+1];
        for (int i = 0; i &lt; m; i++)
            for (int j = 0; j &lt; n; j++)
                a[i][j] = A[i][j];
        for (int j = n; j &lt; m + n; j++) a[j-n][j] = 1.0;
        for (int j = 0; j &lt; n; j++) a[m][j] = c[j];
        for (int i = 0; i &lt; m; i++) a[i][m+n] = b[i];
    }

    //Find entering column q using Bland's rule: index of first column whose objective function coefficient is positive.
    private int bland()
    {
        for (int q = 0; q &lt; m + n; q++)
            if (a[M][q] &gt; 0) return q;
                return -1;
    }

    //Find leaving row p using min ratio rule.
    private int minRatioRule(int q)
    {
        int p = -1;//leaving row
        for (int i = 0; i &lt; m; i++)
        {
            if (a[i][q] &lt;= 0) continue; //consider only positive entries
            else if (p == -1) p = i;
            else if (a[i][m+n] / a[i][q] &lt; a[p][m+n] / a[p][q])
                p = i;
        }
        return p;
    }

    public void pivot(int p, int q)
    {
        for (int i = 0; i &lt;= m; i++)
            for (int j = 0; j &lt;= m+n; j++)
                if (i != p &amp;&amp; j != q)
                    a[i][j] -= a[p][j] * a[i][q] / a[p][q];

        for (int i = 0; i &lt;= m; i++)
            if (i != p) a[i][q] = 0.0;
        for (int j = 0; j &lt;= m+n; j++)
            if (j != q) a[p][j] /= a[p][q];
        a[p][q] = 1.0;
    }

    public void solve()
    {
        while (true)
        {
            int q = bland();
            if (q == -1) break;//entering column q (optimal if -1)
            int p = minRatioRule(q);//leaving row p (unbounded if -1)
            if (p == -1) ...
            pivot(p, q);
        }
}
</code></pre>

<p>원본은 이리로 <a href='http://algs4.cs.princeton.edu/65reductions/Simplex.java.html' >Simplex.java</a></p>

<p>메인 로직 자체는 간단하다.</p>

<p>(1) <code>bland()</code> 로 <em>positive coefficient</em> 인 변수를 찾고 <br />
(2) <code>minRatioRule()</code> 로 어떤 <em>row</em> 택할지 결정한다 <br />
(3) <code>pivot</code> </p>

<p>변수의 수를 <code>N</code>, 제약조건(= <em>inequalities</em>)의 수를 <code>M</code> 이라 했을때 <code>M &gt;= N</code> 이면 러닝타임은 <code>M^2</code> 이다. 이는 <code>pivot</code> 연산이 대부분의 시간을 잡아먹기 때문.</p>

<p>근데 실제 돌려보면 <code>2(M+N) pivot</code> 내에 끝난다고 한다. 왜 그런지는 연구중이라고 함.</p>

<blockquote>
  <p><strong>Pivoting rules:</strong> Carefully balance the cost of finding an entering variable with the number of pivots needed.</p>
  
  <ul>
  <li><p>No pivot rule is known that is guaranteed to be polynomial.</p></li>
  <li><p>Most pivot rules are known to be exponential (or worse) in worst-case.</p></li>
  </ul>
</blockquote>

<h4 id="degeneracy">Degeneracy</h4>

<p>똑같은 <em>extreme point</em> 에 대해서 <em>basis</em> 만 바뀌는 것을 말하는데 위에서 본 <em>bland's rule</em> 이 작은 값부터 차례대로 사용 가능한 변수를 돌려주므로 유한한 수의 피벗이 일어남을 보장한다. </p>

<pre><code class="java">// Find entering column q using Bland's rule: 
// index of first column whose objective function coefficient is positive.
private int bland() {  
    for (int q = 0; q &lt; m + n; q++)
        if (a[M][q] &gt; 0) return q;
            return -1;
}
</code></pre>

<h4 id="implementationissues">Implementation Issues</h4>

<ul>
<li>Avoid stalling (degeneracy): requires artful engineering</li>
<li>Maintain sparsity: requires fancy data structures</li>
<li>Numerical stability: requires advances math</li>
<li>Detect Infeasibility: run "phase i" simplex algorithm</li>
<li>Detect unboundedness: no leaving row</li>
</ul>

<p>그러므로 직접 구현하지 말자.. <del>사실 이해도 어렵다. 만드는 것은 둘째치고</del></p>

<h3 id="reductions">Reductions</h3>

<p><em>unrestricted variable</em> <code>B</code> 가 있는 <em>minimization</em> 문제를 <em>standard form</em> 으로 <em>reduction</em> 하려면</p>

<p>(1) <code>min(13A + 15B)</code> 를 <code>max(-13A - 15B)</code> 로 변경 <br />
(2) <code>4A + 4B &gt; 160</code> <em>constraint</em> 를 <code>4A + 4B - S = 160</code> (<code>S &gt;= 0)</code> <br />
(3) <code>B = B0 - B1</code> (<code>B0 &gt;= 0</code>, <code>B1 =&gt; 0</code>)</p>

<h4 id="maxflow">Max Flow</h4>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTm1Cak4xRURNemNUTXpFVEx3UURNNTBpTjNNek10VWpZalZUTDNNVFoxWURPaUZ6TDVRek4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><em>capacity</em>, <em>flow</em> 를 <em>constraint</em> 로 쉽게 바꿀 수 있다. 앞에서 본 <em>max flow</em> 알고리즘과 비교했을때의 장점은 문제가 더 복잡해지더라도 <em>constraint</em> 만 추가하면 간단하다는 점이다. (성능은 더 느릴수 있다고 함)</p>

<h4 id="bipartitematching">Bipartite Matching</h4>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWjJJelloQnpOeFVtWjJJVEx5RWpNNTBTWjNVek10a1RZbWxUTGlKR04zWVdabUp6THpVek4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>여기서 <code>X_ij</code> 는 사람 <code>i</code> 에게 작업 <code>j</code> 가 할당되었는지의 여부다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDT2pCRE1oaFRPd2dET2hCVExpUm1OaTFpTndJMk10Y3pNbU5XTDNZbVp6SVRNalp6THhVek4xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<h3 id="summary">Summary</h3>

<p><em>LP</em> 가 범용적이긴 한데, 먼저 <em>specialized algorithm</em> 을 사용해 보고 안되면 <em>LP</em> 를 쓰자.</p>

<p><a href='https://medium.com/@_marcos_otero/the-real-10-algorithms-that-dominate-our-world-e95fa9f16c04' >읽을거리: The real 10 algorithms that dominate our world</a></p>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='http://www.explainxkcd.com/wiki/index.php/287:_NP-Complete' >getRandomNumber image</a> <br />
(4) <a href='http://www.programering.com/a/MzM2IDNwATM.html' >Lecture note</a> <br />
(5) <a href='http://mathworld.wolfram.com/Convex.html' >Mathword convex</a>  </p>]]></description><link>http://1ambda.github.io/algorithm-linear-programming/</link><guid isPermaLink="false">13fdf909-5ce5-407a-a94f-1d9c14b9ef80</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[linear programming]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 31 Dec 2014 08:28:26 GMT</pubDate></item><item><title><![CDATA[Problem Reduction]]></title><description><![CDATA[<p><img src='https://www.palantir.com/wp-assets/wp-content/static/techblog/2011/09/travelling_salesman_problem.png'  alt="" /></p>

<p>앞으로 남은 3챕터에서 배울 내용은</p>

<p><strong>reduction</strong>, <strong>linear programming</strong>, <strong>intractability</strong> 이다.</p>

<p>따라서 지금까지의 관심에서 좀 벗어나 </p>

<ul>
<li>from individual problems to <em>problem-solving models</em></li>
<li>from linear / quadratic to <em>polynomial / exponential scale</em></li>
<li>from details of implementation to <em>conceptual framework</em></li>
</ul>

<h3 id="introtoreduction">Intro to Reduction</h3>

<p><em>reduction</em> 챕터에서는 다음의 내용을 다룬다.</p>

<ul>
<li>design algorithms </li>
<li>estabilish lower bounds</li>
<li>classify problems</li>
</ul>

<p><em>reduction</em> 의 정의부터 보면</p>

<blockquote>
  <p>Problem <code>X</code> <strong>reduces to</strong> problem <code>Y</code> if you can use an algorithm that solves <code>Y</code> to help solve <code>X</code></p>
</blockquote>

<p>따라서 <code>X</code> 를 푸는데 드는 비용은 <em>reduction</em> 과, <code>Y</code> 를 해결하는 비용의 합이다.</p>

<p><em>median</em> 을 찾는 문제의 경우, 정렬문제로 변환할 수 있다. 이 때의 비용은 <code>N logN + 1</code>인데, <em>reduction</em> (<em>post or preprocessing</em>) 비용이 <code>1</code> 이다.</p>

<p>중복 원소를 제거하는 문제의 경우 정렬뒤, 인접한 원소간 비교하여 제거하는 문제로 치환할 수 있다. <code>N logN + N</code> 의 비용으로, 이 경우 <em>reduction</em> 비용은 <code>N</code> 이다.</p>

<p><em>min cut</em> 의 경우 <em>max flow</em> 알고리즘을 이용해서 풀 수 있고, <em>reduction</em> 하는데 <em>DFS</em> 또는 <em>BFS</em> 로 한번 돌려야 하므로, 치환 비용은 <code>V + E</code> 다.</p>

<p>이외에도 다양한 <em>reduction</em> 예제가 있다.</p>

<ul>
<li>3-collinear -> sorting</li>
<li>CPM -> topological sorting</li>
<li>arbitrage -> shortest path (벨만포드)</li>
<li>Burrows-Wheeler transform -> suffix sort</li>
</ul>

<p>따라서 <code>Y</code> 문제를 풀 수 있을때, <code>X</code> 에 적용 가능한지가 문제가 된다.</p>

<h3 id="convexhull">Convex hull</h3>

<p><img src='http://cgm.cs.mcgill.ca/' ~orm/images/mergech.gif" alt="" /></p>

<p align="center">(<a href='http://cgm.cs.mcgill.ca/' ~orm'>http://cgm.cs.mcgill.ca/~orm</a>)</p>

<p><em>convex hull</em> 은 <em>sorting</em> 으로 바꿀 수 있다.</p>

<blockquote>
  <p><strong>convex hull:</strong> Given <code>N</code> points in the plane, identify the extream points of the convex hull (in counterclockwise order)</p>
  
  <p><strong>sorting:</strong> Given <code>N</code> distinct integers, rearrange them in ascending order</p>
</blockquote>

<p><em>reduction</em> 가능한지는 <em>Graham scan algorithm</em> 으로 증명된다. 비용은 <code>N logN + N</code> 으로, <em>reduction</em> 에 <code>N</code> 만큼의 비용이 든다.</p>

<h4 id="grahamscan">Graham Scan</h4>

<p>먼저 <em>cross product (외적)</em> 에 대해 잠깐 보고가자. 내적은 스칼라지만, 외적은 또 다른 벡터를 돌려준다. 두 벡터에 대해 수직인 벡터를 돌려주고, 그 크기는 두 벡터로 만들어지는 평행사변형의 넓이다.</p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/Cross_product_parallelogram.svg/220px-Cross_product_parallelogram.svg.png'  alt="" /></p>

<p>외적은 벡터를 돌려주고, 그 방향이 <code>sin</code> 에 기반하기 때문에 두 벡터 <code>a, b</code> 의 외적 <code>a x b</code> 의 값에 따라 <code>a</code> 를 기준으로 <code>b</code> 가 좌측에 있는지, 우측에 있는지 알 수 있다. 위 그림에서 <code>b</code> 가 아래쪽을 향할때 <code>a x b</code> 의 방향이 어디가 될지 생각해 보자.</p>

<p><img src='https://lh3.googleusercontent.com/MIO3c8kg5MTNkze8w5Y6AGfDNWF9Vx4EVvlui8S5grVNWbgXBcpIch7E4R2DRr4B4HSlbLOHSBy39UMHLhTOqLkbnjQMCqtN-VBYkcEfeOEDjAyoCFzMllfpUHUicltzfw'  alt="" />
<img src='https://lh6.googleusercontent.com/aaQEU_goK5dBbB_sct7YxtFafk5968K4yDH5nssYy2RSrieKv0yl-FSQbwgxKgc6sRyxum057PTPW9CfJ83Hr3B3aR4yXWTkaQj3mQEPu35-mhB3epOF1IrFCqsBVKiK3g'  alt="" /></p>

<p align="center">(<a href='http://blog.secmem.org/554' >http://blog.secmem.org/554</a>)</p>

<p>이제 <em>graham scan</em> 알고리즘을 보면</p>

<ul>
<li>choose point <code>p</code> with smallest y-coordinate</li>
<li><strong>sort</strong> points by polar angle with <code>p</code> to get simple polygon</li>
<li>consider points in order, and discard those that would create a clockwise turn</li>
</ul>

<p><em>polar angle</em> 은</p>

<p><img src='http://cf.ydcdn.net/1.0.1.26/images/main/polar%20coordinate.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.yourdictionary.com/' >http://www.yourdictionary.com</a>)</p>

<p>그리고 <em>clockwise turn(시계방향)</em> 인지 아닌지 외적으로 구할 수 있다. 외적값이 음수면 시계방향이다. </p>

<p>따라서 최초의 다각형에서, 선분을 순회하면서 현재 선분과 다음 점을 외적해서 반시계 방향인 점들만 택하면 된다. 그러므로 정렬 + 순회이므로 <em>linear time</em> 이다.</p>

<p><a href='http://www.hanbit.co.kr/network/view.html?bi_id=1462' >더 읽을거리: Gift wrapping</a></p>

<h4 id="shortestpath">Shortest Path</h4>

<p>(non-negative weights) <em>undirected graph</em> 의 최단거리도 <em>directed graph</em> 로 치환해서 풀 수 있다. 각 <em>edge</em> 에 양쪽으로 모두 방향을 추가하면 된다. 러닝타임은 <code>E logV + E</code>, 여기서 <code>E</code> 는 <em>reduction cost</em> 다.</p>

<blockquote>
  <p>Can still solve shortest paths problem in undirected graphs (if no negative cycles), but need omre sophistcated techniques</p>
</blockquote>

<h4 id="lineartimereductions">Linear-time reductions</h4>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/algorithm-reduction/1.png'  alt="" /></p>

<h3 id="establishinglowerbounds">Establishing Lower Bounds</h3>

<p><em>comparison-sorting</em> 알고리즘의 <em>lower bound</em> 는 <code>n log n</code> 임을 이전 강의에서 봤었다. <a href='http://1ambda.github.io/randomized-selection/' #lowerboundforsorting">Lower bound for sorting</a> 참조</p>

<p>일반적으로 어떤 문제의 <em>lower bound</em> 를 알긴 상당히 난해한데, <em>reduction</em> 을 이용해서 어떤 문제가 <em>sorting</em> 처럼 이미 <em>lower bound</em> 가 알려진 문제로 변경할 수 있다면 <em>lower bound</em> 를 알 수 있다. (<em>reduction cost</em> 가 그리 크지 않다고 한다면)</p>

<h4 id="lineartimereductions">Linear-time reductions</h4>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/algorithm-reduction/3.png'  alt="" title="" /> </p>

<blockquote>
  <p>Problem <code>X</code> <strong>linear-time reduces</strong> to problem <code>Y</code> if <code>X</code> can be solved with</p>
  
  <ul>
  <li>Linear number of standard computational steps</li>
  <li>Constant number of calls to <code>Y</code></li>
  </ul>
</blockquote>

<p>따라서 문제 <code>X</code> 를 <code>Y</code> 로 <em>linear-time reduction</em> 이 가능하다면 같은 <em>lower bound</em> 를 적용할 수 있다. <code>X</code> 가 <code>k</code> 시간이 걸린다면, <code>Y</code> 도 그러하다는 것이다.</p>

<p>그리고 <code>Y</code> 를 더 빨리 풀 수 있는 기법이 개발되면 <code>X</code> 에도 적용 가능하다는 뜻이다.</p>

<h4 id="lowerboundforconvexhull">Lower bound for convex hull</h4>

<blockquote>
  <p><strong>Proposition:</strong> in quadratic decision tree model (allows linear or quadratic tests), any algorithms for sorting <code>N</code> integers requires <code>Ω(N logN)</code> steps</p>
  
  <p><strong>Proposition:</strong> sorting linear-time reduces to convex hull. So if I can solve convex hull efficiently, I can sort efficiently</p>
</blockquote>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/algorithm-reduction/2.png'  alt="" title="" /> 
이미지를 잘 보면 <em>convex hull</em> 이 <code>y = x^2</code> 선 위에 있다. 그리고 이 위에 있는 모든 점들이 정렬된 순서인걸 볼 수 있다. 그리고 정렬 대상이 2차원 좌표긴 하지만 <em>quadratic decision tree model</em> 내에 있으므로 정렬 문제로 <em>linear-time reduction</em> 이 가능하다.</p>

<blockquote>
  <p><strong>Implication:</strong> Any <em>ccw-based</em> convex hull algorithm requires <code>Ω(N logN)</code> ops (linear or quadratic tests)</p>
</blockquote>

<p>이외에도</p>

<blockquote>
  <ul>
  <li><p>Element distinctness linear-time reduces to finding the mode because if the most frequent integer occurs more than once, then there is a duplicated integer.</p></li>
  <li><p>Closest pair linear-time reduces to element distinctness because the distance between the closest pair is zero if and only if there is a duplicated integer.</p></li>
  </ul>
</blockquote>

<p>두 원소가 같을때만 제거하므로, 위의 문제들로 <em>linear-time reduction</em> 이 가능하다.</p>

<h3 id="classifyingproblems">Classifying Problems</h3>

<p>두 문제 <code>X, Y</code> 가 복잡도가 같음을 보이고 싶다면</p>

<ul>
<li>show that <code>X</code> <em>linear-time reduces</em> to <code>Y</code></li>
<li>show that <code>Y</code> <em>linear-time reduces</em> to <code>X</code></li>
</ul>

<p>그러면 <code>X</code>, <code>Y</code> 가 같은 복잡도를 가지고 있다고 말할 수 있다. 심지어 복잡도를 모름에도.</p>

<p>그리고 서로 <em>reduction</em> 이 가능하므로 한 문제에 대해 빠른 알고리즘을 개발해서, 다른 곳으로 적용이 가능하다.</p>

<p><img src='https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/algorithm-reduction/4.jpg'  alt="" title="" /> </p>

<ul>
<li>use exact algorithm for tractable problems</li>
<li>use heuristics for intractable problems</li>
</ul>

<h3 id="reference">Reference</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='https://www.palantir.com/wp-assets/wp-content/static/techblog/2011/09/travelling_salesman_problem.png' >xkcd image</a> <br />
(4) <a href='http://cgm.cs.mcgill.ca/' ~orm/mergech.html">Convex hull image</a> <br />
(5) <a href='http://ghebook.blogspot.kr/2010/07/vector.html' >전파거북이 - 좌표계 기반 벡터</a> <br />
(6) <a href='http://blog.secmem.org/554' >소프트웨멤버십 - Convex hull</a> <br />
(7) <a href='http://www.yourdictionary.com/polar-coordinate' >Polar angle image</a> <br />
(8) <a href='http://web.cs.dal.ca/' ~mhe/csci3110/handouts/lecture9.htm">sorting - convex hull image</a>  </p>]]></description><link>http://1ambda.github.io/algorithm-reduction/</link><guid isPermaLink="false">0e589543-7f20-4371-9067-2c2db77adb31</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[reduction]]></category><category><![CDATA[convex hull]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 30 Dec 2014 09:05:04 GMT</pubDate></item><item><title><![CDATA[Data Compression]]></title><description><![CDATA[<p><img src='http://www.lawfareblog.com/wp-content/uploads/2013/09/Encryption-in-the-Real-World.jpg'  alt="" /></p>

<h3 id="datacompression">Data Compression</h3>

<p>주된 이유는 전송 시간과 저장 공간을 절약하기 위해서다. 무어의 법칙이 말해주듯이 제품의 성능은 점점 좋아지는데, 그럼에도 불구하고 사람들이 만들어 내는 데이터의 양은 더 급격히 증가한다. 그래서 압축이 필요하다.</p>

<p>이번시간에 배울 기법은 3 가지다.</p>

<ul>
<li>Run-length</li>
<li>Huffman</li>
<li>LZW</li>
</ul>

<p><em>data compression</em> 응용은</p>

<ul>
<li><em>generic file compression</em></li>
</ul>

<p>GZIP 같은 파일 압축이나, PKZIP 같은 아키이빙. 그리고 파일시스템에서도 압축을 할 수 있다.</p>

<ul>
<li><em>multimedia</em>, <em>communication</em>, <em>database</em></li>
</ul>

<p><em>GIF</em>, <em>MP3</em>, <em>V.42 bis model</em>(?) 등 다양한 곳에 압축을 활용한다고 한다.</p>

<p><br/></p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTT2paRE5qTnpZMEVXTjNNVEw0Z1RONDBDTjFFMk10RWpad0VUTGtWRE41SWpNMGt6THlnVE0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>강의에서 사용하는 용어를 좀 정리하고 가자. 바이너리 <code>B</code> 에 대해 <em>compression, 압축</em> <code>C(B)</code> 를 하고 <em>expansion, 복원(?)</em> 를 해서 <code>B</code> 를 얻는다. 중요한점은 <em>loseless</em> 여야 한다는 것.</p>

<p><em>compression ratio</em> 는 <code>C(B) / B</code> 로 정의한다. <em>natural language</em> 의 경우 <code>50~75%</code> 이상의 압축이 가능하다고 한다.</p>

<h4 id="binarystream">Binary Stream</h4>

<p>구현에 사용할 바이너리 스트림 API 를 보자. 코드는 <a href='http://introcs.cs.princeton.edu/java/stdlib/BinaryStdIn.java.html' >BinaryStdIn.java</a> <a href='http://introcs.cs.princeton.edu/java/stdlib/BinaryStdOut.java.html' >BinaryStdOut.java</a> 에서 구할 수 있다.</p>

<pre><code class="java">public class BinaryStdIn {  
    boolean readBoolean() {} //read 1 bit and return as a boolean
    char readChar() {} //read 8 bits and return as a char
    char readChar(int r) {} //read r bitsand return as a char
    [similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits)]
    boolean isEmpty() {} //is the bitstream empty?
    void close() {} //close the bitstream
}

public class BinaryStdOut {  
    void write(boolean b) {} //write the specified bit
    void write(char c) {} //write the specified 8-bit char
    void write(char c, int r) {} //write the r least significant bits of the specified char
    [similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits)]
    void close() {} //close the bitstream
}
</code></pre>

<p>찾아보니까 자바에서 기본적으로 제공되는건 <code>ByteArrayStream</code> 이 있더라.</p>

<h4 id="datarepresentation">Data Representation</h4>

<p><code>12/31/1999</code> 를 표시하는 법을 생각해 보자.</p>

<p>(1) <code>char</code> 면 <em>8 bit</em>  10개니까 <em>80 bit</em> <br />
(2) <code>int</code>  면 <em>32 bit</em>  3개니까 <em>96 bit</em> <br />
(3) <code>bit</code> 단위를 지정할 수 있다면 <em>4 + 5 + 12 + 3(align) = 24 bit</em> </p>

<pre><code class="java">month = 12  
day = 31  
year = 199

BinaryStdOut.write(month, 4)  
BinaryStdOut.write(day, 5)  
BinaryStdOut.write(year, 12)  
</code></pre>

<p>이는 데이터 표현만 잘 해도 알고리즘 없이 상당부분 압축할 수 있다는 소리다. 일레로 1990년도에 만들어졌던 유전자 데이터베이스는 아스키로 <code>AGCT</code> 를 표현했다고 한다. 4종류의 문자밖에 없으니까 <em>2 bit</em> 로 표현 가능함에도 불구하고</p>

<h3 id="universaldatacompression">Universal Data Compression</h3>

<blockquote>
  <p>No algorithm can compress every bitstring</p>
</blockquote>

<p><em>contraction</em> 을 이용해 증명하면</p>

<ul>
<li>모든 비트스트림을 압축할 수 있는 알고리즘 <code>U</code> 가 있다 하자.</li>
<li>주어진 비트스트링 <code>b0</code> 을 압축해서 더 작은 사이즈의 <code>b1</code> 을 얻고</li>
<li>이 과정을 반복하면 사이즈가 <code>0</code> 이 될때까지 압축이 가능하다. 이건 말이 안된다. </li>
<li>따라서 모든 비트스트림을 압축할 수 있는 알고리즘 <code>U</code> 는 없다.</li>
</ul>

<h3 id="runlengthencoding">Run-Length Encoding</h3>

<p><code>0000000000000001111111000000011111111111</code> 의 비트가 있을때 <em>n-bit</em> 로 <code>0</code> 또는 <code>1</code> 의 <em>runs</em> (긴 나열을 말하는 듯함) 을 표시한다. </p>

<p>예를 들어 위의 데이터를 4비트 카운트를 이용해 표시하면</p>

<pre><code>bin  1111 0111 0111 1011  
dec    15    7    7   11  
</code></pre>

<p>만약에 <em>run</em> 의 길이가 지정된 <em>n-bit</em> 로 표시할 수 있는 수보다 크면 <code>0</code> 부터 다시 세면 된다. <em>JPEG</em>, <em>ITU-T T4 Group 3</em> 등에 응용한다고 함.</p>

<p>구현은</p>

<pre><code class="java">// http://algs4.cs.princeton.edu/55compression/RunLength.java.html
public class RunLength {

  private final static int R = 256; // max run-length count
  private final static int lgR = 8; // # of bits per count

  public static void compress() {
    int run = 0;
    boolean old = false;

    while (!BinaryStdIn.isEmpty()) {
      boolean current = BinaryStdIn.readBoolean();

      // alternate bit
      if (current != old) {
        BinaryStdOut.write(run, lgR);
        run = 1;
        old = !old;
      }
      // same bit
      else {
        // max count
        if (run == R - 1) {
          BinaryStdOut.write(run, lgR);
          // print dummy alternate bit whose length is 0
          run = 0;
          BinaryStdOut.write(run, lgR); 
        }

        run++;
      }
    }

    BinaryStdOut.write(run, lgR);
    BinaryStdOut.close();
  }

  public static void expand() {
    boolean bit = false;

    while (!BinaryStdIn.isEmpty()) {
      int run = BinaryStdIn.readInt(lgR); // read lgR bit

      for (int i = 0; i &lt; run; i ++)
        BinaryStdOut.write(bit);

      bit = !bit;
    }

    BinaryStdOut.close();
  }
}
</code></pre>

<p><del>테스틀 어찌해야하는가</del></p>

<p><br/></p>

<p><img src='http://help.adobe.com/en_US/Director/11.0/images/vector_bitmap_image.png'  alt="" /></p>

<p align="center">(<a href='http://help.adobe.com/' >http://help.adobe.com</a>)</p>

<p><em>bitmap</em> 을 압축하는데 <em>run-length</em> 를 사용하면 효과적이다. 글자에서 대부분의 비트가 <code>0</code> (흰색) 이기 때문이다.</p>

<p>흑백 그림을 예로 들어보자. 인치당 <code>300</code> 픽셀이고, 사이즈가 <code>8.5 x 11</code> 인치라 했을때, 한 이미지를 표시하기 위해 필요한 비트는 <code>300 * 8.5 * 300 * 11</code> = <code>8.415</code> 백만 비트가 필요하다.</p>

<h3 id="huffmanencoding">Huffman Encoding</h3>

<p><em>fixed-length code</em> 말고 모스코드같은 <em>variable-length code</em> 를 생각해 보자. </p>

<p>모스코드에서 <code>* * * - - - * * *</code> 는 여러 방법으로 해석될 수 있다. <code>SOS</code>, <code>V7</code>, <code>IAMIE</code>, <code>EEWNI</code> 모두 가능하다. 모호한것이다. 모스부호에서는 이 문제를 해결하기 위해 글자마다 갭을 두어, 올바르게 해석될 수 있도록 한다. </p>

<p>인코딩에서 <em>ambiguity</em> 를 해결하려면 어떤 <em>codeword</em> 도 다른 <em>code word</em> 의 <em>prefix</em> 가 되지 않도록 해야 한다. </p>

<ul>
<li>Fixed-length code</li>
<li>Append special stop char to each codeword (e.g 모스)</li>
<li>Prefix-free code</li>
</ul>

<p>이 중에서 <em>prefix-free</em> 인 코드를 만드는법을 살펴보자. <em>binary trie</em> 를 만들어 <em>leaf</em> 에 문자를 놓고, 그 문자까지 도달하는 경로가 인코딩 값이다. </p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTjJRVE9tTnpZemdETjVVVEw0UTJZaTF5WXdVek10WWpNNUlXTDJRek5oZFRPaWR6THlrVE0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p><em>compression</em> 을 위해 심볼테이블을 만들거나, 아니면 <em>leaf</em> 부터 따라 올라가고, 그 <em>path</em> 를 뒤집어 출력할 수 있다.</p>

<p><em>expansion</em> 은 루트부터 시작해서 <em>path</em> 를 따라 내려가다가 <em>leaf</em> 에서 만나는 문자를 출력하면 된다.</p>

<p>한가지 생각해 볼 것은, 빈도가 많은 문자를 짧은 인코딩 값(<em>path</em>) 를 가지도록 해야 압축률이 높아진다는 것이다. 이를 위해 각 문자의 <em>frequency</em> 를 이용해야 한다.</p>

<p>허프만 코드 API를 보면</p>

<pre><code class="java">public class Huffman {

    // support extended ASCII
    private static final int R = 256;

    private static class Node implements Comparable&lt;Node&gt; {

        private char ch;
        private int  freq;
        private final Node left, right;

        public Node(char ch, int freq, Node left, Node right) {
            this.ch = ch;
            this.freq = freq;
            this.left = left;
            this.right = right;
        }

        public boolean isLeaf() {
            return left == null &amp;&amp; right == null;
        }

        @Override
        public int compareTo(Node that) {
            return this.freq - that.freq;
        }
    }

    public static void compress()
    public static void expand()
    private static Node buildTrie(int[] freq)
    private static void writeTrie(Node x)
    private static void buildCode(String[] st, Node x, String s)
    private static Node readTrie()
}
</code></pre>

<p>이제 <em>expansion</em> 을 구현하자. 스트림의 가장 첫 부분에, 몇 개의 문자인지를 <em>int</em> 로 표시하는 규약을 정하면</p>

<pre><code class="java">public void expand() {  
  Node root = readTrie(); // read in encoding trie
  int N = BinaryStdIn.readInt(); // read in # of chars

  for (int i = 0; i &lt; N; i++) {
    Node x = root;
    while (!x.isLeaf()) {
      if (!BinaryStdIn.readBoolean())
        x = x.left;  // 0
      else
        x = x.right; // 1
    }

    BinaryStdOut.write(x.ch, 8); // print char
  }

  BinaryStdOut.close();
}
</code></pre>

<p><em>running time</em> 은 <code>N</code> 에 비례한다. </p>

<p><em>expansion</em> 하는 쪽에서도 <em>trie</em> 를 가지고 있어야한다. <em>trie</em> 를 전송하기 위해 <code>writeTrie</code> 함수를 만들어 보자. <em>trie</em> 를 <em>preorder</em> 로 순회하면서 <em>leaf</em> 의 경우 <code>1</code> 과 문자 값을, <em>internal node</em> 의 경우 <code>0</code> 을 출력한다.</p>

<pre><code class="scala">private static void writeTrie(Node x) {  
  if (x.isLeaf()) {
    BinaryStdOut.write(true); // leaf
    BinaryStdOut.write(x.ch, 8);
    return;
  }

  BinaryStdOut.write(false);
  writeTrie(x.left);
  writeTrie(x.right);
}
</code></pre>

<p>이러면 비트스트림으로 온 <em>trie</em> 를 해석하는 함수 <code>readTrie</code> 를 만들자. 마찬가지로 <em>pre-order</em> 로 읽는다.</p>

<pre><code class="java">private static Node readTrie() {  
  // leaf
  if (BinaryStdIn.readBoolean()) {
    char c = BinaryStdIn.readChar(8);
    return new Node(c, 0, null, null);
  }

  Node l = readTrie(); 
  Node r = readTrie();
  return new Node('\0', 0, l, r);
}
</code></pre>

<h4 id="shannonfanoalgorithm">Shannon-Fano algorithm</h4>

<p>어떻게 가장 최적(압축률이 높은) <em>prefix-free code</em> 를 만들까? <em>Shannon-Fano</em> 알고리즘을 이용하면</p>

<ul>
<li><em>symbol</em> <code>S</code> 를 <code>freq</code> 으 합이 최대한 같은 두 집단으로 나눈다 <code>S0, S1</code></li>
<li><code>S0</code> 은 <code>0</code> 부터 시작하고, <code>S1</code> 은 <code>1</code> 부터 시작하도록 <em>codeword</em> 를 만든다</li>
<li>위 두 단계를 반복한다.</li>
</ul>

<p>근데 이 알고리즘은 보면 알겠지만, 최적이 아니다. 이는 <code>freq</code> 값이 <code>{5, 1}</code>, <code>{2, 1, 2, 1}</code> 처럼 구성될 수 있기 때문이다.</p>

<h4 id="huffmanalgorithm">Huffman algorithm</h4>

<p>허프만 알고리즘은 최적의 <em>prefix-free code</em> 를 만들기 위해 </p>

<ul>
<li>각 문자를 이용해 <em>single node trie</em> 를 만든다.</li>
<li><code>freq</code> 값이 가장 작은 두개를 골라 합치고, <em>internal node</em> 에 값을 누적</li>
<li>반복한다</li>
</ul>

<p><img src='http://lcm.csa.iisc.ernet.in/dsa/img161.gif'  alt="" /></p>

<p align="center">(<a href='http://lcm.csa.iisc.ernet.in/dsa' >http://lcm.csa.iisc.ernet.in/dsa</a>)</p>

<p>이 과정에서 가장 낮은 <em>frequency</em> 를 갖는 문자가 아래로 가는 것을 보장하기 때문에 최적의 <em>prefix-free code</em> 를 찾는다 말할 수 있다. (좀 더 자세한 증명은 책을 보라고 함)</p>

<p>구현은</p>

<pre><code class="java">// construct huffman encoding trie 
private static Node buildTree(int[] freq) {  
    PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;Node&gt;();

    for (char c = 0; c &lt; R; c++) 
        if (freq[c] &gt; 0)
            pq.add(new Node(c, freq[c], null, null));

    // if only one char
    if (pq.size() == 1) {
        if (freq['\0'] == 0) pq.add(new Node('\0', 0, null, null));
        else                 pq.add(new Node('\1', 0, null, null));
    }

    // merge two tries
    while (pq.size() &gt; 1) {
        Node l = pq.remove();
        Node r = pq.remove();
        Node p = new Node('\0', l.freq + r.freq, l, r); // parent
        pq.add(p);
    }

    return pq.remove();
}
</code></pre>

<h4 id="compression">Compression</h4>

<p>구현은 </p>

<pre><code class="java">public static void compress() {  
    String s = BinaryStdIn.readString(); // input
    char[] input = s.toCharArray();

    // tabulate freq counts
    int[] freq = new int[R];
    for (int i = 0; i &lt; R; i++)
        freq[input[i]]++;

    // build huffman trie
    Node root = buildTrie(freq);

    // build syombol table
    String[] st = new String[R];
    buildCode(st, root, "");

    // print trie for decoder
    writeTrie(root);

    // print N (# of input)
    BinaryStdOut.write(input.length);

    // encode
    for (int i = 0; i &lt; input.length; i++) {
        String code = st[input[i]];

        // traverse huffman trie
        for (int j = 0; j &lt; code.length(); i++) {
            if (code.charAt(j) == '0')
                BinaryStdOut.write(false);
            else if (code.charAt(j) == '1')
                BinaryStdOut.write(true);
            else throw new IllegalStateException("Illegal State");
        }
    }

    BinaryStdOut.close();
}

private static void buildCode(String[] st, Node x, String s) {  
    if (!x.isLeaf()) {
        buildCode(st, x.left, s + '0');
        buildCode(st, x.right, s + '1');
    } else {
        st[x.ch] = s; 
    }
}
</code></pre>

<p>전체 코드는 <a href='http://1ambda.github.io/ko.thetimenow.com/pst/pacific_standard_time' >Huffman.java</a> 로</p>

<h4 id="huffmansummary">Huffman Summary</h4>

<p>정리하면 </p>

<ul>
<li>tabulate char frequencies and build trie</li>
<li>encode file by traversing trie or lookup table</li>
</ul>

<p>러닝타임은 바이너리 힙을 이용할 경우(우선순위 큐) <code>N + RlogR</code> 이다. 여기서 <code>R</code> 은 알파벳 사이즈. <code>N</code> 은 입력 문자의 수다. </p>

<p>즉 <code>N</code> 은 입력 문자를 인코딩 하는데, <code>R logR</code> 은 <code>R</code> 개의 문자에 대해 <code>freq</code> 값을 이용해 <em>trie</em> 를 만드는데 걸리는 시간</p>

<h3 id="lzwcompression">LZW Compression</h3>

<p><em>Lempel-Ziv-Welch</em> 의 약자다. 세 분이 만드신듯</p>

<p>알고리즘을 보기 전에 데이터 압축 모델에 대해 좀 생각해보자.</p>

<p>(1) 빠르고, 범용적이지만 최적은 아닌 <strong>static model</strong> (e.g ASCII)
(2) 모델을 매번 생성하고, 전송해야하지만 최적인 <strong>Dynamic model</strong> (e.g Huffman)</p>

<p>이 둘을 섞은 <em>adaptive model</em> 도 있다. 즉 매 텍스트마다 모델을 업그레이드 해 나가는 것이다. <del>머신러닝?!</del></p>

<blockquote>
  <p>Progressively learn and upate model as you read text</p>
</blockquote>

<ul>
<li>More accurate modeling produces better compression</li>
<li>Decoding must start from beginning</li>
</ul>

<p><em>LZW compression</em> 이 그 예다. <em>LZW</em> 압축 알고리즘은 모델을 읽으면서 만들기 때문에, 전송할 필요가 없다.</p>

<p>텍스트를 읽다가 <em>codeword table</em> 에 이미 존재하면, 문자를 더 읽어 테이블에 없을 경우에만 추가한다. 그림으로 보면</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWmlSR00yUW1OeVF6WWpaVEw0UTJNNDBTTjFVMk10a3pZM01XTHlFV05obGpZNU0yTHhBak0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<ul>
<li>Create ST associating <code>W</code>-bit codewords with string keys</li>
<li>Initialize ST with codewords for single-char keys</li>
<li>Find longest string <code>s</code> in ST that is a prefix of unscanned part of input</li>
<li>Write the <code>W</code>-bit codeword associated with <code>s</code></li>
<li>Add <code>s + c</code> to ST where <code>c</code> is next char in the input</li>
</ul>

<p><em>LZW compression</em> 에선 <em>longest string matching</em> 이 필요하므로 <em>trie</em> 를 이용할 수 있다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWmtsek5pRldPbVJtTmpSVEw1RVRZNTBDT3pFek10UVRZMElXTG1GVFk1TVdPbVZ6THpBak0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<h4 id="lzwimplementation">LZW Implementation</h4>

<p>자세한 코드는 <a href='http://algs4.cs.princeton.edu/55compression/LZW.java.html' >LZW.java</a> 여기로. 그리고 메모리 사용량을 줄이기 위해 <em>ternary search trie</em> 를 이용한다. <a href='http://algs4.cs.princeton.edu/55compression/TST.java.html' >TST.java</a></p>

<pre><code class="java">// ref: http://algs4.cs.princeton.edu/55compression/LZW.java.html
private static final int R = 256;  // # of input chars  
private static final int L = 4096; // # of codewords = 2^W  
private static final int W = 12;   // codeword width

public static void compress() {  
  String input = BinaryStdIn.readString();

  // codewords for single chars
  TST&lt;Integer&gt; tst = new TST&lt;Integer&gt;();
  for(int i = 0; i &lt; R; i++)
    sts.put("" + (char) i, i);

  int code = R + 1;

  while (input.length() &gt; 0) {
    String s = tst.longestPrefixOf(input);
    BinaryStdOut.write(s, W);

    int t = s.length();
    if (t &lt; input.length() &amp;&amp; code &lt; L)
      st.put(input.substring(0, t + 1), code++)

    input = input.substring(t);
  }

  BinaryStdOut.write(R, W); // write "stop" codeword
  BinaryStdOut.close();
}
</code></pre>

<p><em>expansion</em> 은 테이블에서 <em>codeword</em> 를 읽어가면서 테이블을 만들면 된다. 심볼이 아니라 값으로 검색하므로 <code>2^W</code> 길이의 <em>array</em> 만 있으면 된다.</p>

<p><em>tricky case</em> 가 있는데</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTTBNbVp3WVdaaloyWTRJVEwxY1RZaDF5TnlJMk10VUROaGRUTHdVVE4zWTJZM2t6TDFBak0xOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p><em>compression</em> 은 같은데 <em>expansion</em> 이 좀 복잡하다. <code>41 42 81 83 80</code> 에서 <code>83</code> 을 해석할때, 테이블에 있어야 해석을 하는데 없으므로 막혀버린다. </p>

<p>이 경우를 잘 보면 <code>83</code> 을 해석해야 하고, 현재 테이블에 <code>82</code> 까지의 심볼만 존재한다. 그리고 방금 전 까지 읽은건 <code>81</code> 이다. <code>83</code> 은 <code>ABA</code> 인데, 이건 <code>81</code> 의 심볼을 <code>val</code> 이라 하면 <code>val + val.charAt(0)</code> 과 동일하다.</p>

<p>구현은</p>

<pre><code class="java">public static void expand() {  
    String[] st = new String[L];
    int i; // next available codeword value

    for (i = 0; i &lt; R; i++) 
        st[i] = "" + (char) i;

    st[i++] = ""; // termination codeword

    int codeword = BinaryStdIn.readInt(W);
    if (codeword == R) return; // if empty message
    String val = st[codeword];

    while(true) {
        BinaryStdOut.write(val);

        codeword = BinaryStdIn.readInt(W);
        if (codeword == R) break;

        String s = st[codeword];

        // tricky case
        if (codeword == i) s = val + val.charAt(0);
        // add string into table
        if (i &lt; L) st[i++] = val + s.charAt(0);

        val = s;
    }

    BinaryStdOut.close();
}
</code></pre>

<p>해석할때 <code>val</code> 은 지난단계의 해석, <code>s</code> 는 현재 읽은 값의 해석이라 생각하면 쉽다.</p>

<h4 id="losslessdatacompression">Lossless Data Compression</h4>

<p><em>LZW</em> 같은 경우 특허가 있었는데, 2003년에 만료되었다고 한다. 이 알고리즘의 많은 변형이 있는데, <em>LZ77</em> 은 특허가 없어서 오픈소스에 많이 쓰인다고 함. <em>deflate  zlib</em> 는 <em>LZ77</em> 과 <em>Huffman</em> 을 섞여 쓰는 대표적인 압축 알고리즘</p>

<p><em>bit / char</em> 를 기준으로 보면 아스키는 <code>7</code>, 허프만은 <code>4.7</code> 정도의 성능을 보여준다. 1995년에는 <em>Burrows-Wheeler</em> 알고리즘이 발명되었는데 <code>2.29</code> 정도까지 압축한다. 1999년에는 <em>RK</em> 알고리즘이 <code>1.89</code> 까지 압축에 성공함.</p>

<h3 id="summary">Summary</h3>

<ul>
<li><strong>Huffman:</strong> represent <em>fixed-length symbols</em> with <em>variable-length codes</em></li>
<li><strong>LZW:</strong> represent <em>variable-length symbols</em> with <em>fixed-length codes</em></li>
</ul>

<p><em>lossy compression</em> 의 경우 <em>FFT</em>, 프랙탈 등 수학적 도구를 이용해 만드 알고리즘들이 많다.</p>

<p>그리고 압축의 이론적 한계는 <em>shanon entropy</em> 에 의해</p>

<p><img src='http://crackingthenutshell.com/wp-content/uploads/file/shannons-formula-small.jpg'  alt="" /></p>

<h3 id="reference">Reference</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='http://www.lawfareblog.com/2013/09/the-nsa-and-encryption/' >The NSA and Encryption</a> <br />
(4) <a href='http://www.programering.com/a/MTO4YzNwATE.html' >Data Compression Lecture Note</a> <br />
(5) <a href='http://lcm.csa.iisc.ernet.in/dsa/node88.html' >Huffman Algorithm</a>  </p>]]></description><link>http://1ambda.github.io/algorithm-data-compression/</link><guid isPermaLink="false">58cf48f9-4e5e-4a17-80ca-be11ef6ffdc7</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[compression]]></category><category><![CDATA[run-length]]></category><category><![CDATA[huffman]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 29 Dec 2014 06:20:14 GMT</pubDate></item></channel></rss>