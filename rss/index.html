<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Old Lisper]]></title><description><![CDATA[Lisp, Emacs, Scala]]></description><link>http://1ambda.github.io/</link><generator>Ghost 0.5</generator><lastBuildDate>Mon, 22 Dec 2014 02:23:50 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Reactive Programming 3, Futures, Promises]]></title><description><![CDATA[<p>이번시간엔 <em>Try</em>, <em>Future</em>, <em>Awaitable</em>, <em>Async</em>, <em>Promise</em> 에 대해 알아본다. <del>모나드가 삶을 윤택하게 하리라</del></p>

<h3 id="monadsandeffects">Monads and Effects</h3>

<p>프로그래밍에서 4가지 본질적 <em>effects</em> 는</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<p><em>asynchoronous computation</em> 을 살펴보기전에 <em>synchronous</em> 부터 살펴볼건데 간단한 어드벤쳐 게임으로 시작하자.</p>

<pre><code class="scala">trait Adventure {  
  def collectCoins(): List[Coin]
  def buyTreasure(coins: List[Coin]): Treasure
}

val adventu  
re = Adventrue()  
val coins = adventure.collectCoins()  
val treasure = adventure.buyTreasure(coins)  
</code></pre>

<p>여기서 <code>collecCoins, buyTreasure</code> 는 구현에 따라 실패할 수도 있다. 예를 들어</p>

<pre><code class="scala">def collectCoins(): List[Coin] = {  
  if (eatenByMonster(this)) throw new GameOverException("Ooops")
  List(Silver, Silver, Gold)
}
def buyTreasure(coins: List[Coin]): Treasure = {  
  if (coins.sumBy(_.value) &lt; treasureCost)
    throw new GameOverException("Nice try!")
  Diamond
}
</code></pre>

<p>그런데, 타입상으로는 <code>collectCoins, buyTreasure</code> 는 함수가 실패할 것이라는 어떠한 정보도 주지 않는다. <code>Try</code> 를 이용해 함수가 예외를 던질수도 있다는 것을 타입에 표시하자.</p>

<h4 id="try">Try</h4>

<p>아래는 <code>Try</code> 의 정의다.</p>

<pre><code class="scala">abstract class Try[T]  
case class Success[T](elem: T) extends Try[T]  
case class Failure[T](t: Throwable) extends Try[Nothing]  
</code></pre>

<p>이걸 게임 함수의 리턴값에 적용하면</p>

<pre><code class="scala">import scala.util.{Try, Success, Failure}

def collectCoins(): Try[List[Coin]] = {  
  if (eatenByMonster(this)) throw new GameOverException("Ooops")
  List(Silver, Silver, Gold)
}
def buyTreasure(coins: List[Coin]): Try[Treasure] = {  
  if (coins.sumBy(_.value) &lt; treasureCost)
    throw new GameOverException("Nice try!")
  Diamond
}

val adventure = Adventrue()  
val coins: Try[List[Coin]] = adventure.collectCoins()  
val treasure = coins match {  
  case Success(cs) =&gt; adventure.buyTreasure(cs)
  case failure @ Failure(t) =&gt; failure
}
</code></pre>

<p>좀 귀찮다. 많이 귀찮다. <em>higher order function</em> 의 은혜를 받아 삶을 좀 윤택하게 해 보자.</p>

<pre><code class="scala">def flatMap[S](f: T =&gt; Try[S]): Try[S]

def flatten[U &lt;: Try[T]]: TRy[U]

def map[S](f: T =&gt; S): Try[T]

def filter(p: T =&gt; Boolean): Try[T]

def recoverWith(f: PartialFunction[Throwable, Try[T]]): Try[T]  
</code></pre>

<p>여기서 <code>flatMap</code> 을 이용하면 코드가 상당히 이뻐질 것 같다.</p>

<p>사실 비밀을 하나 공개하자면, <code>Try[T]</code> 는 모나드다. 그 중에서 <em>exception</em> 을 다루는 모나드.</p>

<p><code>Try</code> 모나드를 이용하면 <em>exception</em> 부분(<code>Try[T]</code>)은 알아서 다루어 주고, 우리가 다뤄야 할 <code>T</code> 부분에 집중하게 해준다.</p>

<p><code>flatMap</code> 이 코드를 어떻게 바꾸는가 한번 보자.</p>

<pre><code class="scala">val treasure: Try[Treasure] =  
  adventure.collectCoins().flatMap(coins =&gt; {
    adventure.buyTreasure(coins)
  }
</code></pre>

<p>리턴타입은 <code>Try[Treasure]</code> 인데 <code>Try</code> 패턴매칭이 사라졌다? 그게 바로 <code>flatMap</code> 이 해주는 일이다. 타입을 다시 보자.</p>

<pre><code class="scala ">def flatMap[S](f: T =&gt; Try[S]): Try[S]  
</code></pre>

<p><code>T</code> 를 받아 <code>Try[S]</code> 를 돌려줄 함수만 넣어주면, 실제 <code>T</code> 를 이 함수에 넣기 위해 해야할 패턴매칭은 알아서 해준다.</p>

<p>그리고 지난 <a href='http://1ambda.github.io/reactive-programming-1/' >1강</a> 에서 모나드속에 있는 타입을 빼기 위해 <em>for expression</em> 을 이용했었다. 마찬가지로 <code>Try</code> 도 가능하다. <code>flatMap</code> 보다 더 이뻐진다.</p>

<pre><code class="scala">val treasure: Try[Treasure] = for {  
  coins &lt;- adventure.collectCoins()
  treasure &lt;- adventure.buyTreasure(coins)
} yield treasure
</code></pre>

<p>우측에서 <code>Try[T]</code> 를 리턴하고, <code>for</code> 가 알아서 <code>Try</code> 를 제거하고 좌측에 <code>T</code> 를 돌려준다.</p>

<p><code>Try</code> 를 다루기 위한 <em>higher order function</em> 이 내부적으로 어떻게 돌아가는지 한번 살펴보자.</p>

<pre><code class="scala">def map[S](f: T =&gt; S): Try[S] = this match {  
  case Succes(value) =&gt; Try(f(Value))
  case failure @ Failure(t) =&gt; failure
}

def flatMap[S](f: T =&gt; Try[S]): Try[S] = this match {  
  case Success(value) =&gt; try { f(value) } catch { cast t =&gt; Failure(t) }
  case failure @ Failure(t) =&gt; failure
}

object Try {  
  def apply[T](r: =&gt; T): Try[T] = {
    try { Success(r) }
    catch { case t =&gt; Failure(t) }
  }
}
</code></pre>

<p><code>flatMap</code> 내부에서 패턴매칭 및 예외 처리를 해준다. </p>

<h3 id="latencyasaneffect">Latency as an Effect</h3>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<p>지금까지 <code>T/Try[T]</code> 에 대해서 봤다. 이번엔 <em>asynchronous</em> 로 옮겨가 <code>Future[T]</code> 를 한번 볼건데, 간단한 네트워크 프로그램을 모델링 하면서 배워보자.</p>

<pre><code class="scala">trait Socket {  
  def readFromMemory(): Array[Byte]
  def sendToEurope(packet: Array[Byte]): Array[Byte]
}

val socket = Socket()  
val packet = socket.readFromMemory()  
val confirmation = socket.sendToEurope(package)  
</code></pre>

<p>이 코드도 이전의 어드벤쳐 게임처럼 실행중에 어떤일이 발생할지 모른다. 예외가 발생하지 않았을때만 정상적으로 실행된다. 게다가 <code>readFromMemory</code>, <code>sendToEurope</code> 동안 함수가 블럭되면 프로그램은 멈춰있다. (<em>heavy effect</em>)</p>

<p>이걸 해결하는게 <em>Future</em> 모나드다. 이 모나드는 <em>exception</em> 과 <em>latency</em> 를 다룬다. <code>Future[T]</code> 의 정의는</p>

<pre><code class="sala">import scala.concurrent._  
import scala.concurrent._ExecutionContext.Implicits.global

trait Future[T] {  
  def onComplete(callback: Try[T] =&gt; Unit)
     (implicit excutor: ExecutionContext): Unit
}
</code></pre>

<p><code>Try[T]</code> 를 받는 콜백을 인자로 필요로 하는 <code>onComplete</code> 메소드가 있다. 아랫 부분에 <code>ExecutionContext</code> 는 백그라운드에서 다른 스레드로 돌리기 위해 사용하고, <code>implicit</code> 는 이런 디테일을 숨기기 위함이다.</p>

<p><em>Future</em> 는 다른 버전으로 작성될 수도 있는데,</p>

<pre><code class="scala">trait Future[T] {  
  def onComplete(success: T =&gt; Unit, 
                 failed Throwale =&gt; Unit): Unit

  def onComplete(callback: Observer[T]): Unit
}

trait Observer[T] {  
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
}
</code></pre>

<p>이건 위 버전에서의 <em>callback</em> 을 좀 세분화 한것이다. 어차피 콜백이 <code>Try[T]</code> 를 받기 때문에 내부에서 <em>case</em> 로 분리해야 하는데, 미리 로직을 분리해서 각각의 경우에 대해 넘겨주는 것이다.</p>

<p>아니면 그 아래 <code>onComplete</code> 정의처럼 <code>Observer</code> 로 감싸서 줄 수 있다. 이것도 마찬가지로 성공했을때의, 실패했을때의 콜백이다.</p>

<p>이제 처음의 소켓 프로그램으로 돌아와서 <em>Future</em> 를 적용하면</p>

<pre><code class="scala">trait Future[T] {  
  def onComplete(callback: Try[T] =&gt; Unit)
     (implicit executor: ExecutionContext): Unit
}

trait Socket {  
  def readFromMemory(): Future[Array[Byte]]
  def sendToEurope(package: ArrayByte]): Future[Array[Byte]]
}
</code></pre>

<p>이제 <code>readFromMemory(), sendToEurope()</code> 의 함수 호출이 긴 시간이 걸릴수 있겠구나 하고 <code>Future</code> 가 리턴타입에 있음을 보고 알 수 있다.</p>

<p><em>future</em> 는 참 좋은건데, 이걸 사용하면 아까 실행 코드는</p>

<pre><code class="scala">// before
val socket = Socket()  
val packet = socket.readFromMemory()  
val confirmation = socket.sendToEurope(package)

// after
val socket = Socket()  
val packet: Future[Array[Byte]] = socket.readFromMemory()

// can't compile
val confirmation: Future[Array[Byte]] =  
  packet onComplete {
    case Success(p) =&gt; socket.sendToEurope(p)
    case Failure(t) =&gt; ...
  }
</code></pre>

<p>잘 보면 <code>onComplete</code> 의 리턴타입은 <code>Unit</code> 이기 때문에 <code>confirmation</code> 은 <code>Future[Array[Byte]]</code> 가 될 수 없다.</p>

<p>한 가지 방법은 <code>confirmation</code> 을 내부에 넣는건데,    그러면 나머지 밑 부분 코드도 모두 <code>Success</code> 내부에 작성해야 한다. <del>자바스크립트 콜백헬</del></p>

<pre><code class="scala">// can't compile
  packet onComplete {
    case Success(p) =&gt; 
      val confirmation = socket.sendToEurope(p)
      ...
      ...
      // callback hell
      ...
    case Failure(t) =&gt; ...
  }
</code></pre>

<p>이 문제를 해결하기 위해 <em>future</em> 를 만들 수 있다. <code>Future</code> 의 <em>companion object</em> 정의를 보면</p>

<pre><code class="scala">object Future {  
  def apply(body =&gt; T)
     (implicit context: ExecutionContext): Future[T]
}
</code></pre>

<p>예제를 보면</p>

<pre><code class="scala">import scala.concurrent.ExecutionContext.Implicit.global  
import akka.serializer._

val memory = Queue[EmailMessage](  
  EmailMessage(from = "Erik",   to = "Roland")
  EmailMessage(from = "Martin", to = "Erik")
  EmailMessage(from = "Roland", to = "Martin"))

def readFromMemory(): Future[Array[Byte]] = Future {  
  val email = queue.dequeue()
  val serializer = serialization.findSerializationFor(email)
  serializer.toBinary(email)
}

val packet: Future[Array[Byte]] = socket.readFromMemory()

packet onSuccess {  
  case bs =&gt; socket.sendToEurope(p)
}

packet onSuccess {  
  case bs =&gt; socket.sendToEurope(p)
}
</code></pre>

<p>이렇게 사용할 수 있다. 이 코드가 모두 실행되면, 이메일 큐에는 두개의 이메일이 남는다. <strong>하나가 아니다!!</strong> <code>Future</code> 는 <strong>미래에 돌려줄 결과</strong>를 가지고 있다고 보면 되는데, 하나의 결과에 대해 두개의 콜백을 호출해도 하나의 결과, 즉 이메일 하나만 뽑아먹었다는 사실은 변하지 않는다.</p>

<h3 id="combinatorsonfutures">Combinators on Futures</h3>

<p>이제 <em>future</em> 가 무슨일을 하는지 알았으면, 이걸 어떻게 모나드스럽게 사용할지 알아보자. 단골손님 <code>flatMap</code> 과 그 친구들이 등장한다.</p>

<pre><code class="scala">trait Awaitable[T] extends AnyRef {  
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}

trait Future[T] extends Awaitable[T] {  
  def filter(p: T =&gt; Boolean): Future[T]
  def flatMap[S](f: T =&gt; Future[S]): Future[S]
  def map[S](f: T =&gt; S): Future[S]
  def recoverWith(f: PartialFunction[Throwable, Future[T]]): Future[T]
}

objec Future {  
  def apply[T](body: =&gt; T): Future[T]
}
</code></pre>

<p><code>flatMap</code> 님을 이용해서 코드를 작성하자.</p>

<pre><code class="scala">val socket = Socket()  
val packet: Future[Array[Byte]] = socket.readFromMemor()  
val confirmation: Future[ArrayByte]] =  
  packet.flatMap(p =&gt; {
    socket.sendToEurope(p)
  }
</code></pre>

<p><code>flatMap</code> 의 정의를 보면 알겠지만, 함수 <code>f: T =&gt; Future[S]</code> 만 제공하면 앞의 <code>Future</code> 를 껍질을 벗겨, <code>T</code> 로 넣어준다. 근데 여기서 재밌는 사실은, <code>flatMap</code> 의 리턴 타입이 <code>Future[S]</code> 기 때문에 <code>confirmation</code> 도 같은 타입이 된다.</p>

<p>즉, <code>flatMap</code> 을 이용하면 모나드를 체이닝할 수 있다. 다른 예제도 좀 보자.</p>

<pre><code class="scala">import scala.concurrent.ExecutionContext.Implicits.global  
import scala.imaginary.Http._

object Http {  
  def apply(url: URL, req: Request): Future[Response] = 
  { .. runs the http request asynchronously }
}

// buggy
def sendToEurope(packet: Array[Byte]): Future[Array[Byte]] =  
  Http(URL("mail.server.eu"), Request(packet))
    .filter(response =&gt; response.isOK)
    .map(response =&gt; response.toByteArray)
</code></pre>

<p>마지막 부분의 코드를 다양하게 활용해 보자.</p>

<pre><code class="scala">def sendTo(url: URL, packet: Array[Byte]): Future[Array[Byte]] =  
  Http(URL("mail.server.eu"), Request(packet))
    .filter(response =&gt; response.isOK)
    .map(response =&gt; response.toByteArray)

def sendToAndBackup(packet: Array[Byte]):  
  Future[(Array[Byte], Array[Byte])] = {
    val europeConfirm = sendTo(mailServer.europe, packet)
    val usaConfirm    = sendTo(mailServer.usa, packet)
    europeConfirm.zip(usaConfirm)
  }
</code></pre>

<p>는 정상적인 코드가 아니다. 유럽이나 미국 둘중 하나라도 실패하면, 전체가 실패한다. 다행히도 스칼라 디자이너가 이런 문제를 해결하기 위한 함수들 <code>recover, recoverWith</code> 를 준비 해 놓았다.</p>

<pre><code class="scala">def recover(f: PartialFunction[Throwable, T]): Future[T]  
def recoverWIth(f: PartialFunction[Throwable, Future[T]): Future[T]  
</code></pre>

<p>타입을 잘보면 예외를 검사해서 다시 <code>Future[T]</code> 를 던지는 함수들이다. 특히 <code>recoverWith</code> 는 또 다른 비동기 연산을 할 수 있도록 <code>Future[T]</code> 를 지원한다.</p>

<p>위의 이메일 예제에 <code>recover, recoverWith</code> 를 적용해 보자.</p>

<pre><code class="scala">def sendTo(url: URL, packet: Array[Byte]): Future[Array[Byte]] =  
  Http(URL("mail.server.eu"), Request(packet))
    .filter(response =&gt; response.isOK)
    .map(response =&gt; response.toByteArray)

def sendToAndBackup(packet: Array[Byte]): Future[Array[Byte]] =  
  sendTo(mailServer.europe, packet) recoverWith {
    case europeError =&gt; sendTo(mailServer.usa, packet) recover {
      case usaError =&gt; usaError.getMessage.toByteArray      
    }
  }
</code></pre>

<p>근데 마지막 부분에서 <code>usaError.getMessage.toByteArray</code> 가 별로 맘에 안든다.  미국으로 보내는건 백업일 뿐이고, 실제로는 유럽에 보내고 싶었다. 그래서 실패한 메세지를 받더라도 유럽쪽 에러를 받고 싶다. 또 다른 문제는 코드가 좀 못생겼다. 이 두가지 문제를 해결해보자.</p>

<pre><code class="scala">def fallbackTo(that: =&gt; Future[T]): Future[T] = {  
  if this future fails take the successful result
  of that future
  if that future fails too, take the error of
  this future
}
</code></pre>

<p>이런 메소드가 있다면 다음처럼 작성할 수 있다.</p>

<pre><code class="scala">def sendSafe(packet: Array[Byte]): Future[Array[Byte]] =  
  sendTo(mailServer.europe, packet) fallbackTo {
    sendTo(mailServer.usa, packet)
  } recover {
    case europeError =&gt; europeError.getMessage.toByteArray
  }
</code></pre>

<p><code>fallbackTo</code> 의 구현은 </p>

<pre><code class="scala">def fallbackTo(that: =&gt; Future[T]): Future[T] = {  
  this recoverWith {
    case _ =&gt; that recoverWith { case _ =&gt; this }
  }
}
</code></pre>

<p><code>Try</code> 에 실패했을때 복구하는 <code>Try</code> 를 만들 수 있다.</p>

<pre><code class="scala">object Try {  
  def apply(f: Future[T]): Future[Try[T]] = 
    f.map(s =&gt; Success(s)) recover { case t =&gt; Failure(t) }
}
</code></pre>

<h4 id="awaitable">Awaitable</h4>

<pre><code class="scala">trait Awaitable[T] extends AnyRef {  
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}

trait Future[T] extends Awaitable[T] {  
  def filter(p: T =&gt; Boolean): Future[T]
  def flatMap[S](f: T =&gt; Future[S]): Future[S]
  def map[S](f: T =&gt; S): Future[S]
  def recoverWith(f: PartialFunction[Throwable, Future[T]]): Future[T]
}
</code></pre>

<p>때때로 <em>asynchronous</em> 보다는 <em>blocking</em> 을 원할 수 있다. 그럴때는 <code>Awaitable</code> 을 사용하면 된다. 지정된 시간동안 블럭 후에 <code>result</code> 함수는 모나드를 벗겨 <code>T</code> 를 돌려준다.</p>

<p>예를 들어</p>

<pre><code class="scala">val socket = Socket()  
val packet: Future[Array[Byte]] = socket.readFromMemory()  
val confirmation: Future[Array[Byte]] =  
  packet.flatMap(socket.sendToSafe(_))

val c = Await.result(confirmation, 2 seconds)  
println(c.toText)  
</code></pre>

<p>여기 잘 보면 <code>2 seconds</code> 라고 썼는데, 진짜 동작하는 코드다.</p>

<pre><code class="scala">import scala.language.postFixOps

object Duration {  
  def apply(length: Long, unit: TimeUnit): Duration
}

val fiveYears = 1826 minutes  
</code></pre>

<h3 id="composingfutures">Composing Futures</h3>

<pre><code class="scala">val socket = Socket()  
val packet: Future[Array[Byte]] =  
  socket.readFromMemory()

val confirmation: Future[Array[Byte]] =  
  packet.flatmap(socket.sendToSafe(_))
</code></pre>

<p>위에서 이런 코드를 작성했었다. 당연히 <em>for expression</em> 으로 변환할 수 있다.</p>

<pre><code class="scala">val socket = Socket()

val confirmation: Future[Array[Byte]] = for {  
  packet  &lt;- socket.readFromMemory()
  confirm &lt;- socket.sendToSafe(packet)
} yield confirm
</code></pre>

<p>여기에 더 많은 <em>control flow</em> 를 도입하려면 어떻게 해야할까? <code>flatMap</code> 만으로는 좀 부족해보인다. 예를 들어 정해진 횟수만큼 <em>retry</em> 를 하고싶다고 하자. 이런 함수를 만들어야 하는데,</p>

<pre><code class="scala">def retry(times: Int)(block: =&gt; Future[T]): Future[T]  
</code></pre>

<p>재귀로 구현하면</p>

<pre><code class="scala">def retry(times: Int)(block: =&gt; Future[T]): Future[T] = {  
  if (times == 0) Future.failed(new Exeception("Sorry")
  else 
    block fallbackTo { 
      retry(times - 1) { block }
    }
}
</code></pre>

<p>음... 못생겼다. 재귀긴 한데.. 에릭 마이어에 의하면 <em>recursion</em> 은 함수형 프로그래밍의 <strong>GOTO</strong> 라고 한다. 재귀 말고 <em>fold</em> 를 사용하자.</p>

<pre><code class="scala">def retry(times: Int)(block: =&gt; Futurep[T]): Future[T] = {  
  val ns: Iterator[Int] = (1 to times).iterator
  val attempts: Iterator[Future[T]] = ns.map(_ =&gt; () =&gt; block)
  val failed = Future.failed(new Exception)

  attempts.foldLeft(failed)
    ((a, block) =&gt; a recoverWith { block() })
}
</code></pre>

<p>즉, <em>future</em> 를 받아 <code>times</code> 만큼의 리스트를 만들어 놓고, <em>fold</em> 를 이용해 <code>recoverWith</code> 를 호출한다. </p>

<p>따라서 <code>retry(3) { block }</code> 코드는 이렇게 확장된다.</p>

<pre><code class="scala">((failed recoverWith block) recoverWith block) recoverWith block
</code></pre>

<p>만약 <em>foldRight</em> 를 이용하면</p>

<pre><code class="scala">def fallbackTo(that: =&gt; Future[T]): Future[T] = {  
  this recoverWith {
    case _ =&gt; that recoverWith { case _ =&gt; this }
  }
}

def retry(times: Int)(block: =&gt; Futurep[T]): Future[T] = {  
  val ns: Iterator[Int] = (1 to times).iterator
  val attempts: Iterator[Future[T]] = ns.map(_ =&gt; () =&gt; block)
  val failed = Future.failed(new Exception)

  attempts.foldRight(() =&gt; failed)
    ((block, a) =&gt; () =&gt; { block() fallbackTo { a() } })
}

retry(3) { block } ()

// ==
block fallbackTo { block fallbackTo { block fallbackTo { failed }}}  
</code></pre>

<p>잘보면 <code>foldRight</code> 부분에서 초기값이 <code>() =&gt; failed</code> 로 변했다. 이는 우리가 <code>fallbackTo</code> 를 이용하기 때문인데, <code>fallbackTo</code> 의 로직상 <code>this</code> 가 실패하면 <code>that</code> 을 시도하게끔 되어있다. <code>that</code> 이 성공하면 <code>that</code> 을 돌려준다.</p>

<p>우리는 이미 실패한 <code>block</code> 을 <code>a</code> 에 쌓아놨기 때문에, 이것을 그대로 돌려주려면 <code>() =&gt;</code> 로 감싸서 성공할 수 있도록 해야한다.</p>

<h3 id="async">Async</h3>

<p>타입에 <em>effect</em> 를 명시하는건 무슨일이 일어나는지 알려주니까 정말 좋긴 한데, 코드를 작성하기가 까다롭다. 좀 간단하게 할 수 있는 방법은 없을까?</p>

<pre><code class="scala">import scala.async.Async._

def async[T](body: =&gt; T)  
  (implicit context: ExecutionContext): Future[T]

def await[T](future: Future[T]): T  
</code></pre>

<p>여기서 <code>async</code> 는 <code>Future</code> 의 팩토리라 보면 된다. 위에서 본 코드와의 다른점은, 내부에 <code>await</code> 함수를 사용할 수 있다. 얼핏 보면 <code>await</code> 은 블럭킹을 위한 <code>Awaitable</code> 과 비슷하게 보이기도 한다. <code>Future</code> 를 받아 <code>T</code> 를 돌려주니까.</p>

<pre><code class="scala">trait Awaitable[T] extends AnyRef {  
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}

// usage
Await.result(confirmation, 2 seconds)  
</code></pre>

<p>그러나 놀랍게도 <code>await</code> 함수는 블럭되지 않는다. 코드를 보기전에 잠깐 설명서를 좀 보면</p>

<blockquote>
  <p><strong>Illegal Uses</strong></p>
  
  <ul>
  <li><p>await requires a directly-enclosing async; this means await must not be used inside a closure nested within in an async block, or insdie a nested object, trait, or class</p></li>
  <li><p>await must not be used inside an expression passed as an argument to a by name parameter</p></li>
  <li><p>await must not be used inside a Boolean short-circuit argument</p></li>
  <li><p>return expression are illegal inside an async block</p></li>
  <li><p>await should not be used under a <strong>try / catch</strong></p></li>
  </ul>
</blockquote>

<p><code>try / catch</code> 구문을 이용할 수 없으므로 <code>Try</code> 모나드를 써야한다. 이제 위에서 봤던 <code>retry</code> 함수를 <code>await</code> 을 이용해서 작성하면</p>

<pre><code class="scala">def retry(times: Int)(block =&gt; Future[T]): Future[T] = async {  
  val i = 0
  var result: Try[T] = Failure(new Exception("sorry man!"))

  while (i &lt; times &amp;&amp; result.isFailure) {
    result = await { Try(block) }
    i += 1
  }

  result.get
}
</code></pre>

<p>코드가 좀 더 이해하기 쉬워졌다. 그리고 내부에서는 <em>mutable state</em> 를 사용할지라도 외부로는 여전히 <em>purely functional</em> 이다.</p>

<p>내친김에 <code>filter</code> 도 구현해 보자.</p>

<pre><code class="scala">def async[T](body: =&gt; T)  
  (implicit context: ExecutionContext): Future[T]
def await[T](future: Future[T]): T

def filter(p: T =&gt; Boolean): Future[T] = async {  
  val x = await { this }

  if (!p(x)) throw new NoSuchElementException()
  else x
}
</code></pre>

<p>여기서 예외를 던지는 이유는 <em>empty future</em> 를 예외로 간주하기 때문이다. 앞서 코드에서도 그랬듯이.</p>

<p><code>flatMap</code> 은 어떨까?</p>

<pre><code class="scala">def async[T](body: =&gt; T)  
  (implicit context: ExecutionContext): Future[T]
def await[T](future: Future[T]): T

def flatMap[S](f: T =&gt; Future[S]): Future[S] =  
  async { await { f(await {this}) }}
</code></pre>

<h3 id="promise">Promise</h3>

<p><code>await</code> 없이 <code>filter</code> 를 만들려면 <code>Promise</code> 를 사용할 수 있다.</p>

<pre><code class="scala">def filter(pred: T =&gt; Boolean): Future[T] = {  
  val p = Promise[T]()

  this onComplete {
    case Failure(e) =&gt; p.failure(e)
    case Success(x) =&gt; 
      if (!pred(x)) p.failure(new NoSuchElementException)
      else p.success(x)
  }

  p.future
}
</code></pre>

<p><code>Promise</code> 의 정의를 보면</p>

<pre><code class="scala">trait Promise[T] {  
  def future: Future[T]
  def complete(result: Try[T]): Unit
  def tryComplete(result: Try[T]): Boolean
}

trait Future[T] {  
  def onCompleted(f: Try[T] =&gt; Unit): Unit
}
</code></pre>

<p><code>Promise</code> 는 <code>Future</code> 를 담고 있는데, <code>Future.onCompleted</code> 에 등록된 콜백 <code>f: Try[T] =&gt; Unit</code> 은, <code>Promise.complete</code> 에 의해 호출된다. </p>

<p><code>Promise.complete</code> 는 한번만 호출될 수 있다. 상식적으로 생각해봐도 그렇다. 따라서 <code>tryComplete</code> 를 만들어, 이미 완료되었으면 <code>false</code> 를 얻어 검사한다.</p>

<p>재미난 예제를 하나 더 보자.</p>

<pre><code class="scala">import scala.concurrent.ExecutionContext.Implicits.global

def race[T](left: Future[T], right: Future[T]): Future[T] = {  
  val p = Promise[T]()

  left  onComplete { p.tryComplete(_) }
  right onComplete { p.tryComplete(_) }

  p.future
}
</code></pre>

<p>두 <code>left, right</code> <em>computation</em> 중 먼저 끝나는 연산이 돌려주는 <code>Try[T]</code> 가 <code>p.future.onComplete</code> 의 콜백에 삽입된다. </p>

<p>어떤 리소스를 얻길 원하는데 로컬 캐싱값과 리모트 값 둘 중 먼저 얻어오는 것을 사용하려고 할 때 이런 코드를 작성할 수 있다. <em>HTML5</em> 에도 <em>worker</em>(?) 라고 이렇게 활용할 수 있는 기능이 있는걸로 안다.</p>

<p><code>Promise</code> 에는 몇 가지 함수들이 더 있다.</p>

<pre><code class="scala">trait Promise[T] {  
  def future: Future[T]
  def complete(result: Try[T]): Unit
  def tryComplete(result: Try[T]): Boolean

  // helper method
  def success(value: T): Unit = this.complete(Success(value))
  def failure(t: Throwable): Unit = this.complete(Failure(t))
}
</code></pre>

<p>이제 아까 <code>filter</code> 로 다시 돌아가자.</p>

<pre><code class="scala">// async version
def filter(p: T =&gt; Boolean): Future[T] = async {  
  val x = await { this }

  if (!p(x)) throw new NoSuchElementException()
  else x
}

// promise version
def filter(pred: T =&gt; Boolean): Future[T] = {  
  val p = Promise[T]()

  this onComplete {
    case Failure(e) =&gt; p.failure(e)
    case Success(x) =&gt; 
      if (!pred(x)) p.failure(new NoSuchElementException)
      else p.success(x)
  }

  p.future
}
</code></pre>

<p><code>zip</code> 도 <code>Promise</code> 와 <code>await</code> 이용해 작성해 보자.</p>

<pre><code class="scala">// promise version
def zip[S, R](that: Future[S], f: (T, S) =&gt; R): Future[R] = {  
  val p = Promise[R]()

  this onComplete {
    case Failure(e) =&gt; p.failure(e)
    case Success(x) =&gt; that onComplete {
      case Failure(e) =&gt; p.failure(e)
      case Success(y) =&gt; p.success(f(x, y))
    }
  }

  p.future
}

// async version
def zip[S, R](p: Future[S], f: (T, S) =&gt; R): Future[R] = async {  
  f(await { this }, await {that })
}
</code></pre>

<p><del>갓 async</del> </p>

<p>시퀀스도 <code>await</code> 을 이용해서 구현하면</p>

<pre><code class="scala">def sequence[T](fs: List[Future[T]]): Future[List[T]] = async {  
  var _fs = fs
  var r = ListBuffer[T]()
  while (_fs != Nil) {
    r += await { _fs.head }
    _fs = _fs.tail
  }

  r.result
}
</code></pre>

<p>즉 <code>Future[T]</code> 를 하나씩 <em>async</em> 하게 얻어, 리스트로 돌려준다. 만약 이걸 <code>Promise</code> 로 구현하면</p>

<pre><code class="scala">def sequence[T](fs: List[Future[T]]): Future[List[T]] = {  
  val successful = Promise[List[T]]()
  successful.success(Nil)

  fs.foldRight(successful.future) {
    (f, acc) =&gt; for {x &lt;- f; xs &lt;- acc} yield x :: xs
  }
}
</code></pre>

<p><code>Future[T]</code> 를 누적해서 리스트를 만들어야 하기 때문에 <code>Promise.complete(Nil)</code> 을 세팅해 이것의 <code>Promise.future</code> 를 <code>foldRight</code> 의 초기값으로 사용한다.</p>

<p>그리고 <em>for expression</em> 에서 <code>f: Future[T], acc: Future[List[T]]</code> 다. 따라서 <code>for</code> 구문에서 모나드가 벗겨져 <code>x: T, xs: List[T]</code> 이며 성공적으로 <code>x</code> 를 가져오면 컨싱한다.</p>

<p>지금까지 <code>Try</code> 와 <code>Future</code> 를 살펴봤다. 다음엔 하나의 값이 아니라 컬렉션을 <em>async</em> 하게 어떻게 처리하나 알아보자.</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<h3 id="references">References</h3>

<p>(1) <em>Reactive Programming</em> by <strong>Martin Ordersky</strong>  </p>]]></description><link>http://1ambda.github.io/reactive-programming-3/</link><guid isPermaLink="false">9519a124-ef47-4ab8-9521-c7641b60eb23</guid><category><![CDATA[coursera]]></category><category><![CDATA[reactive programming]]></category><category><![CDATA[ scala]]></category><category><![CDATA[futures]]></category><category><![CDATA[promises]]></category><category><![CDATA[awaitable]]></category><category><![CDATA[try]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 21 Dec 2014 11:09:38 GMT</pubDate></item><item><title><![CDATA[Reactive Programming 2, Stateful]]></title><description><![CDATA[<p>지금까지 우리가 작성한 프로그램은 <em>side-effect free</em> 였기 때문에, <strong>time</strong> 이 중요한 요소가 아니였다. 무슨말인고 하니, 모든 프로그램은 <em>sequence of actions</em> 에 대해 항상 같은 결과를 주게 되어있었다.</p>

<p>이건 <em>substitution model</em> 에 반영되어 있다. </p>

<h3 id="substitutionmodel">Substitution Model</h3>

<p><em>substitution model</em> 을 복습해 보면, 프로그램의 <em>evaluation</em> 은 <em>rewriting</em> 이다.</p>

<pre><code class="scala">def f(x1, ..., xn) = B; ... f(v1, ..., vn)  
</code></pre>

<p>은 다음처럼 평가된다. 여기서 <code>B</code> 는 펑션 바디. </p>

<pre><code class="scala">def f(x1, ..., xn) = B; ... f(v1/x1, ..., vn/xn) B  
</code></pre>

<p>예를 들어</p>

<pre><code class="scala">def interate(n: Int, f: Int =&gt; Int, x: Int) =  
  if (n == 0) x else iterate(n-1, f, f(x))

def square(x: int) = x * x  
</code></pre>

<p><code>iterate(1, square, 3)</code> 은 이렇게 평가된다.</p>

<pre><code class="scala">if (1 == 0) 3 else iterate(1-1, square, square(3))  
iterate(0, square, square(3))  
iterate(0, square, 3 * 3)  
iterate(0, square, 9)  
if (0 == 0) 9 else iterate(0-1, square, square(9))  
9  
</code></pre>

<p>그런데 여기서 재미난 부분이 있다. <em>rewriting</em> 은 어느 <em>term</em> 에서나 일어날 수 있고, 모든 <em>종료되는</em> <em>rewriting</em> 은 같은 결과를 만든다.</p>

<blockquote>
  <p>Rewriting can be done anywhere in a term, and all rewritings which terminated lead to the same solution</p>
</blockquote>

<p>그리고 이 개념이 람다 대수와, 함수형 프로그래밍의 기반이다. 아래의 두 식은 같은 식이다. </p>

<pre><code class="scala">if (1 == 0) 3 iterate(1 - 1, square, square(3))

// ==
iterate(0, square, square(3))

// ==
if (1 == 0) 3 else iterate(1 - 1, square, 3 * 3)  
</code></pre>

<p>어느 부분에 집중하냐에 따라 <em>term</em> 에서의 <em>rewriting</em> 이 달라질 수는 있으나, 결과는 같다. 이걸 <em>confluence (합류)</em> 라 부르기도 하고 <a href='http://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem' >Church-Rosser Theorem</a> 이라 부르기도 한다.</p>

<h3 id="statefulobject">Stateful Object</h3>

<p>지금까지는 <em>pure functional world</em> 의 이야기였다. 이제 좀 바깥 세상 이야기를 해보자. 상태가 변하고 하는것들.</p>

<p>일반적으로 <em>world</em> 를 <em>a set of objects</em> 로 정의할 수 있으며, 이 <em>object</em> 들은 시간이 지남에 따라 <em>change</em> 가 일어난다. </p>

<blockquote>
  <p>An object <strong>has a state</strong> if its behavior is influenced by its history</p>
</blockquote>

<p>예를 들어서 <em>은행 계좌</em> 는 <em>state</em> 를 가지고 있다. 왜냐하면 다음 질문의 답이</p>

<blockquote>
  <p><strong>"Can I withdraw 100 CHF?"</strong></p>
</blockquote>

<p>계좌의 이전 상태들이 어땠는지에 따라 달라지기 때문이다. (<em>may vary over the course of the lifetime of the account</em>)</p>

<p>모든 <em>mutable state</em> 는 <em>variable</em> 을 이용해 만들 수 있는데 스칼라에서는 <em>value definition</em> 인 <code>val</code> 대신에 <em>variable definition</em> 인 <code>var</code> 을 이용한다.</p>

<p>실제로는 <code>var</code> 보다는 다수의 <em>variable</em> 을 가진 <em>object</em> 를 이용해 오브젝트를 나타낸다. 아래는 은행 계좌 예제</p>

<pre><code class="scala">  class BankAccount {
    private var balance = 0

    def deposit(amount: Int): Unit = {
      if (amount &gt; 0) balance = balance + amount
    }

    def withdraw(amount: Int): Unit = {
      if (0 &lt; amount &amp;&amp; amount &lt;= balance) balance = balance - amount
      else throw new Error("insufficient")
    }
  }
</code></pre>

<p>여기서 <code>BankAcoount</code> 는 <code>deposit</code> 과 <code>withdraw</code> 가 어떻게 얼마나 호출되었는지(히스토리)에 따라 상태 <code>balance</code> 가 달라진다. </p>

<p>여기서 지난번에 배웠던 <code>Stream</code> 의 구현을 잠깐 보자. 이건 <em>stateful object</em> 일까?</p>

<pre><code class="scala">def const[T](hd: T, tl: =&gt; Stream[T]) = new Stream[T] {  
  def head = hd
  private var tlOpt = Option[Stream[T]] = None
  def tail: T = tlOpt match {
    case Some(x) =&gt; x
    case None =&gt; tlOpt = Some(tl); tail
  }
}
</code></pre>

<p>이건 시스템이 어떠한가 하는 <em>가정</em> 에 따라 참일수도, 아닐수도 있다.</p>

<p>(1) 만약에 <code>tl</code> 연산에서 <em>side-effct</em> 가 없다면 <code>tlOpt</code> 를 캐시하기 위한 최적화는 이 클래스 외부에 대해 어떤 영향도 없으므로 스트림은 <em>stateful object</em> 가 아니다.</p>

<p>(2) 반대로 <code>tl</code> 을 계산하는 과정에서 <em>print</em> 나 등등 <em>side-effect</em> 가 발생한다면 첫번째로 <code>tl</code> 을 호출하냐, 두번째로 호출하냐에 따라 <em>print</em> 가 발생할 수, 아닐수도 있으므로 <em>stateful object</em> 다.</p>

<p>그럼 이제 이런 은행계좌 클래스를 생각해 보자.</p>

<pre><code class="scala">class BankAccountProxy(ba: BankAccount) {  
  def deposit(amount: Int) = ba.deposit(amount)
  def withdraw(amount: Int) = ba.withdraw(amount)
}
</code></pre>

<p>사실 이 <code>BankAccountProxy</code> 클래스는 어느 <em>varaible</em> 도 가지고 있지 않지만, 이 클래스의 <em>behavior</em> 이 <code>ba</code> 의 <em>state</em> 를 결정하기 때문에 <em>stateful object</em> 다.</p>

<h3 id="identityandchange">Identity and Change</h3>

<p>이번엔 두 <em>state</em> 가 같은지를 판별하는 문제를 생각해 보자.</p>

<p><em>assignment</em> 는 두 <em>expression</em> 이 서로 같은지(<em>the same</em>)에 대한 질문을 던진다.</p>

<p>예를 들어 <code>val x = E; val y = E</code> 라 하자. 여기서 <code>E</code> 는 임의의 <em>expression</em>. 여기서 <em>assignment</em> 가 없다면 아래 식 처럼 바꿔 쓸 수 있다.</p>

<pre><code class="scala">val x = E; val y = x  
</code></pre>

<p><em>property</em> 를 <strong>referential transparency</strong> 라 부른다. 근데 만약 <em>assigment</em> 가 있으면, 두 <em>formulation</em> 은 다를 수 있다.</p>

<pre><code class="scala">val x = new BankAccount  
val y = new BankAccount  
</code></pre>

<h4 id="operationalequivalence">Operational Equivalence</h4>

<p>두 변수가 같은지를 판별하기 위해서, <em>같다</em> 라는 말을 좀 더 엄밀히 정의해 보자. </p>

<blockquote>
  <p>The precise meaning of <strong>"being the same"</strong> is defined by the property of <em>operational equivalence</em>*</p>
</blockquote>

<p><code>x, y</code> 두 개의 <em>definition</em> 을 가지고 있다고 하자. </p>

<blockquote>
  <p><code>x</code> and <code>y</code> are operationally equivalent if <strong>no possible test</strong> can disingquish between them</p>
</blockquote>

<p>그러므로 우리는 <code>x, y</code> 가 같은지 비교하기 위해 </p>

<blockquote>
  <p>Execute the definitions followed by an arbitrary sequence <code>f</code> of operations that involves <code>x</code> an <code>y</code>, observing the possible outcomes.</p>
</blockquote>

<pre><code class="scala">val x = new BankAccount  
val y = new BankAccount  
f(x, y)

// another execution
val x = new BankAccount  
val y = new BankAccount  
f(x, x)  
</code></pre>

<blockquote>
  <p>Then, execute the definitions with another sequence <code>S'</code> obtains by renaming all occurences of <code>y</code> by <code>x</code> in <code>S</code></p>
</blockquote>

<p>만약 이 실행 결과가 다르다면 <code>x, y</code> 는 다른것이고 그 반대로 모든 <code>(S, S')</code> 가 같은 결과를 돌려준다면 <code>x, y</code> 는 같다. 왜냐하면 더이상 구분할 수 없기 때문이다. 이게 바로 <em>operationally equivalence</em></p>

<p>이제 이 <em>operational equvalence</em> 를 이용해서 위에서 나온 질문을 해결해 보자. <em>counter example</em> 로,</p>

<pre><code class="scala">// sequence S
val x = new BankAccount  
val y = new BankAccount

x deposit 30  // 30  
y withdraw 20 // error: insufficient

// sequnece S'
val x = new BankAccount  
val y = new BankAccount

x deposit 30  // 30  
x withdraw 20 // 10  
</code></pre>

<p>따라서 <code>x, y</code> 는 서로 다르다. 반면 <code>val y = x</code> 로 정의한다면 어떤 <em>operation</em> 도 두 변수를 구분할 수 없기 때문에 똑같다.</p>

<h4 id="assignmentandsubstitutionmodel">Assignment and Substitution Model</h4>

<p>지금까지 논의한 바를 정리해 보면 <em>assignment</em> 가 도입됨에 따라 우리가 가진 <em>computation model</em> 이 적용 불가능해 졌다.</p>

<pre><code class="scala">val x = new BankAccount  
val y = x

// will be replaced to, but not correct
val x = new BankAccount  
val y = new BankAccount  
</code></pre>

<p>위 식은 아래 식처럼 치환되지만, 절대 같은 결과가 아니다. 다른 프로그램이 된다!</p>

<blockquote>
  <p><em>The substitution model</em> <strong>ceases</strong> to be valid when we add the <em>assignment</em></p>
</blockquote>

<p><em>store</em> 개념을 도입하면 <em>substituion model</em> 을 적용 가능하지만, 이건 프로그램을 상당히 복잡하게 만든다.</p>

<p><em>purely functional world</em> 에서 벗어나니 세상이 복잡해졌다. 어떻게 두 세계를 잘 버무릴수 있을까?</p>

<h3 id="loops">Loops</h3>

<p>사실 <em>loop</em> 는 <em>imperative programming</em> 에서 필수적인 요소는 아니다. <em>variable</em> 만으로 절차형 언어를 모델링하기에 충분하긴 한데, 어쨌든 있긴 하니까 함수형 언어에서도 모델링 할 수 있는 방법을 강구해보자. <em>function</em> 으로 할 수 있다. </p>

<pre><code class="scala">def power(x: Double. exp: Int): Double = {  
  var r = 1.0
  var i = exp

  while (i &gt; 0) { r = r * x; i = i - 1}
  r
}
</code></pre>

<p>스칼라에서 <code>while</code> 은 키워드니까, <code>WHILE</code> 을 이용해 루프를 모델링하는 함수를 만들어 보자.</p>

<pre><code class="scala">def WHILE(condition: =&gt; Boolean)(body: =&gt; Unit): Unit = {  
  if (condition) {
    body
    WHILE(condition)(body)
  } else ()
}
</code></pre>

<ul>
<li><em>re-evaluation</em> 을 피하기 위해서 (인자로넘길때) <code>condition, body</code> 는 <em>by name</em> 으로 넘겨야 한다. </li>
<li><code>WHILE</code> 은 <em>tail-recursive</em> 이므로 <em>constant stack-size</em> 를 가진다.</li>
</ul>

<p><em>repeat</em> 는 이런식으로</p>

<pre><code class="scala">def REPEAT(body: =&gt; Unit)(condition: =&gt; Boolean): Unit = {  
  body
  if (condition) ()
  else REPEAT(body)(condition)
}
</code></pre>

<p><em>until</em> 을 만들고 싶으면 내부 함수를 만들면 된다.</p>

<pre><code class="scala">// ref: https://gist.github.com/metasim/7503601
def REPEAT(body: =&gt; Unit) = new {  
  def UNTIL(condition: =&gt; Boolean): Unit = {
    body
    if (condition) ()
    else UNTIL(condition)
  }
}

// test code
REPEAT {  
  x = x + 1
} UNTIL (x &gt; 3)
</code></pre>

<h4 id="forloops">For-Loops</h4>

<p>자바의 <em>for-loop</em> 를 단순히 <em>higher-order function</em> 를 사용하는것 만으로는 모델링하기 어렵다. 왜냐하면 <code>i</code> 의 <em>declaration</em> 이 포함되어있기 때문이다.</p>

<pre><code class="java">for (int i = 1; i &lt; 3; i = i + 1) { System.out.print(i + " "); }  
</code></pre>

<p>스칼라에서도 비슷한 루프를 제공하긴 하는데, 위 루프보다는 <em>extended</em> 루프에 더 가깝다.</p>

<pre><code class="scala">for (i &lt;- 1 until 3) { System.out.print(i + " ") }  
</code></pre>

<p><em>for loop</em> 는 <em>foreach combinator</em> 로  번역 된다. 참고로 <em>for expression</em> 은 <code>map, flatMap</code> 으로 번역된다.</p>

<pre><code class="scala">def foreach(f: T =&gt; Unit): Unit =  
  // apply 'f' to each element of the collection

// example
for (i &lt;- 1 until 3; j &lt;- "abc") println(i + " " + j)

// translated to
(1 until 3).foreach(i =&gt; "abc" foreach (j =&gt; println(i + " " + j)))
</code></pre>

<h3 id="discreteeventsimulation">Discrete Event Simulation</h3>

<p>지금까지 <em>world</em> 를 모델링 할 수 있는 <em>state</em> 와, 여기에 적용할 수 있는 <em>control structure</em> 를 살펴봤는데, 이걸 이용해서 시뮬레이션을 해보자.</p>

<h4 id="digitalcircuit">Digital Circuit</h4>

<p><em>digital circuit</em> 은 <strong>wires</strong> 와 <strong>functional components</strong> 로 구성된다. </p>

<blockquote>
  <p>Wires transport signals thar are transformed by components</p>
</blockquote>

<p><em>signal</em> 을 <code>True, False</code> 로 표현하자. 그리고 기본 <em>components</em> 로</p>

<ul>
<li>Inverter</li>
<li>AND Gate</li>
<li>OR Gate</li>
</ul>

<p>그러면 다른 컴포넌트들은 이 조합으로 만들 수 있다. 그리고 각 컴포넌트는 <em>delay</em> 를 가질 수 있다.</p>

<pre><code class="scala">def inverter(input: Wire, output: Wire): Unit  
def andGate(a1: Wire, a2: Wire, output: Wire): Unit  
def orGate(o1: Wire, o2: Wire, output: Wire): Unit  
</code></pre>

<p>이제 <em>half adder, HA</em> 를 만들어 보면 </p>

<p><img src='http://i.msdn.microsoft.com/dynimg/IC141779.gif'  alt="" /></p>

<p align="center">(<a href='http://msdn.microsoft.com/' >http://msdn.microsoft.com</a>)</p>

<pre><code class="scala">def halfAdder(a: Wire, b: Wire, c: Wire, s: Wire): Unit = {  
  val d = new Wire
  val e = new Wire

  orGate(a, b, d)
  andGate(a, b, e)
  inverter(c, e)
  andGate(d, e, s)
}
</code></pre>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Full_Adder_Blocks.svg/2000px-Full_Adder_Blocks.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikibooks.org/' >http://en.wikibooks.org</a>)</p>

<p><img src='http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/ietron/fulladd.gif'  alt="" /></p>

<p align="center">(<a href='http://hyperphysics.phy-astr.gsu.edu/' >http://hyperphysics.phy-astr.gsu.edu</a>)</p>

<p>그러면 <em>full adder</em> 는</p>

<pre><code class="scala">def fullAdder(a: Wire, b: Wire, cin: Wire, sum: Wire, cout: Wire): Unit = {  
  val s = new Wire
  val c1 = new Wire
  val c2 = new Wire

  halfAdder(b, cin, s, c1)
  halfAdder(a, s, sum, c2)
  orGate(c1, c2, cout)
}
</code></pre>

<h4 id="action">Action</h4>

<p><em>discrete event simulator</em> 는 특정 <em>moment</em> 에서의 수행되는 <em>actions</em> 이다. 아무런 파라미터도 필요없는 <em>action</em> 은</p>

<pre><code class="scala">type Action = () =&gt; Unit  
</code></pre>

<p>어떤 <em>side-effect</em> 를 수행하면서 <em>time</em> 을 시뮬레이션 할 수 있다.</p>

<h4 id="simulator">Simulator</h4>

<pre><code class="scala">  trait Simulation {
    def currentTime: Int = ???
    def afterDelay(delay: Int)(block: =&gt; Unit): Unit = ???
    def run(): Unit = ???
  }
</code></pre>

<ul>
<li><code>currentTime</code> returns the current simulated time</li>
<li><code>afterDelay</code> registeres an action to perform after a certain delay</li>
<li><code>run</code> performs the simulation until there are no more actions wating</li>
</ul>

<p>이렇게 시뮬레이터 <em>trait</em> 를 만들고 상속 구조를 만들면</p>

<pre><code class="scala"> Simulation
     |
   Gates     // Wire, AND, OR, INV
     |
  Circuits   // HA, ADDER  
     |
MySimulation // implementation  
</code></pre>

<h4 id="wire">Wire</h4>

<pre><code class="scala">class Wire {  
  private var sigVal = false
  private var actions: List[Action] = List()

  def getSignal: Boolean = sigVal
  def setSignal(s: Boolean): Unit =
    if (s != sigVal) {
      sigVal = s
      actions foreach (_())
    }

 def addAcion(a: Action): Unit = {
    actions = a :: actions
    a()
  }
}
</code></pre>

<h4 id="inverterandorgates">Inverter, AND, OR Gates</h4>

<p><em>input wire</em> 로 부터의 입력을 뒤집어서 <em>output wire</em> 에다 돌려주는 <code>inverter</code> 를 구현할 수 있다. 근데 회로에서는 <em>delay</em> 가 있기 때문에 바로는 뒤집기 보다는 <code>InvertDelay</code> 이후에 신호를 반전시키는 <em>action</em> 을 구현하자. 아까 <code>Simulation</code> 내의 <code>afterDelay</code> 를 구현하면 된다.</p>

<pre><code class="scala">  def andGate(in1: Wire, in2: Wire, output: Wire): Unit = {
    def andAction(): Unit = {
      val in1Signal = in1.getSignal
      val in2Signal = in2.getSignal
      afterDelay(AddGateDelay) { output setSignal (in1Signal &amp; in2Signal) }
    }

    in1 addAction andAction
    in2 addAction andAction
  }

  def orGate(in1: Wire, in2: Wire, output: Wire): Unit = {
    def orAction(): Unit = {
      val in1Signal = in1.getSignal
      val in2Signal = in2.getSignal
      afterDelay(OrGateDelay) { output setSignal (in1Signal | in2Signal) }
    }

    in1 addAction orAction
    in2 addAction orAction
  }

  def inverter(input: Wire, output: Wire): Unit = {
    def invertAction(): Unit = {
      val inputSig = input.getSignal
      afterDelay(InverterDelay) { output setSignal (!inputSig) }
    }
    input addAction invertAction
  }
</code></pre>

<p><br/></p>

<p><del>혼란이 오기 시작했다</del></p>

<blockquote>
  <p>What happens if we compute <code>in1Sig</code> and <code>in2Sig</code> inline inside <code>afterDelay</code> instead of computing them as value?</p>
</blockquote>

<p>당연히 <em>delay</em> 후의 <em>signal</em> 값을 가지고 <em>action list</em> 에 추가하므로 제대로 모델링하지 못한다.</p>

<pre><code class="scala">afterDelay(OrGateDelay) {  
  output setSignal (in1.getSignal | in2.getSignal)
}
</code></pre>

<h3 id="thesimulationtrait">The Simulation Trait</h3>

<p>지금까지를 정리하면, <code>Wire</code> 클래스는 <em>statefule object</em> 를 나타낸다. 상태 <code>signal</code>, <code>actions</code> 는 <code>addAction, setSignal</code> 호출에 의해 정해진다. 이 함수들의 호출은 일종의 <em>event</em> 이며, <em>delay</em> 와 <em>action</em> 으로 구성된다.</p>

<p>그리고 이 모든 <code>Event</code> 는 <code>Simulation</code> <em>trait</em> 내 리스트로 저장된다. 일종의 할일 목록이나, <em>history</em> 로 보면 쉬울듯. </p>

<pre><code class="scala">type Action = () =&gt; Unit  
case class Event(time: Int, action: Action)  
private type Agenda = List[Event]  
private var agenda: Agenda = List()

private var curtime: Int = 0  
def currentTime: Int = curtime  
</code></pre>

<p>현재 시뮬레이션 타임을 기록하기 위해 <code>curtime</code> 정의하고, 이를 이용해 <code>Event</code> 를 정의할 수 있다. <code>Event(curtime + delay, () =&gt; block)</code> 처럼</p>

<pre><code class="scala">def afterDelay(delay: Int)(block: =&gt; Unit): Unit = {  
  val item = Event(currentTime + delay, () =&gt; block)
  agenda = insert(agenda, item)
}

private def insert(ag: List[Event], item: Event): List[Event] = ag match {  
  case first :: rest if first.time &lt;= item.time =&gt; first :: insert(rest, item)
  case _ =&gt; item :: ag
}
</code></pre>

<p>그리고 <code>agenda</code> 에 있는 액션들을 처리할 <code>loop</code> 와 시뮬레이션을 돌릴 <code>run</code> 함수를 구현하면</p>

<pre><code class="scala">private def loop(): Unit = agenda match {  
  case first :: rest =&gt;
    agenda = rest
    curtime = first.time
    first.action()
    loop()
  case _ =&gt;
}

def run(): Unit = {  
  afterDelay(0) {
    println("*** simulation started, time = " + currentTime + " ***")
  }

  loop()
}
</code></pre>

<p>그리고 시뮬레이션 자체는 아무런 <em>output</em> 도 주지 않기 때문에, 디버깅에 유용한 <code>probe</code> 함수를 추가하자. 디버깅용 <em>action</em> 을 추가한다 생각하면 쉽다. 일종의 <em>gate</em> 이기도 하다.</p>

<pre><code class="scala">def probe(name: String, wire: Wire): Unit = {  
  def probeAction(): Unit = {
    println(s"$name $currentTime value = ${wire.getSignal}")
  }

  wire addAction probeAction
}
</code></pre>

<p>이제 각 게이트마다의 딜레이를 위한 <em>trait</em> 를 만들자. 회로를 무엇으로 구성하냐에 따라 다를 수 있으므로 <em>trait</em> 으로 만드는건 좋은 선택이다.</p>

<pre><code class="scala">trait Parameters {  
  def InverterDelay = 2
  def AndGateDelay = 2
  def OrGateDelay = 2
}
</code></pre>

<h4 id="implementation">Implementation</h4>

<pre><code class="scala">
</code></pre>

<h4 id="test">Test</h4>

<pre><code class="scala">trait Simulation {  
  type Action = () =&gt; Unit
  case class Event(time: Int, action: Action)
  private type Agenda = List[Event]
  private var agenda: Agenda = List()

  private var curtime: Int = 0
  def currentTime: Int = curtime

  def afterDelay(delay: Int)(block: =&gt; Unit): Unit = {
    val item = Event(currentTime + delay, () =&gt; block)
    agenda = insert(agenda, item)
  }

  private def insert(ag: List[Event], item: Event): List[Event] = ag match {
    case first :: rest if first.time &lt;= item.time =&gt; first :: insert(rest, item)
    case _ =&gt; item :: ag
  }

  private def loop(): Unit = agenda match {
    case first :: rest =&gt;
      agenda = rest
      curtime = first.time
      first.action()
      loop()
    case _ =&gt;
  }

  def run(): Unit = {
    afterDelay(0) {
      println("*** simulation started, time = " + currentTime + " ***")
    }

    loop()
  }

}

abstract class Gates extends Simulation {

  def AndGateDelay: Int
  def OrGateDelay: Int
  def InverterGateDelay: Int

  class Wire {
    private var sigVal = false
    private var actions: List[Action] = List()

    def getSignal: Boolean = sigVal
    def setSignal(s: Boolean): Unit =
      if (s != sigVal) {
        sigVal = s
        actions foreach (_())
      }

    def addAction(a: Action): Unit = {
      actions = a :: actions
      a()
    }
  }

  def andGate(in1: Wire, in2: Wire, output: Wire): Unit = {
    def andAction(): Unit = {
      val in1Signal = in1.getSignal
      val in2Signal = in2.getSignal
      afterDelay(AndGateDelay) { output setSignal (in1Signal &amp; in2Signal) }
    }

    in1 addAction andAction
    in2 addAction andAction
  }

  def orGate(in1: Wire, in2: Wire, output: Wire): Unit = {
    def orAction(): Unit = {
      val in1Signal = in1.getSignal
      val in2Signal = in2.getSignal
      afterDelay(OrGateDelay) { output setSignal (in1Signal | in2Signal) }
    }

    in1 addAction orAction
    in2 addAction orAction
  }

  def inverter(input: Wire, output: Wire): Unit = {
    def invertAction(): Unit = {
      val inputSig = input.getSignal
      afterDelay(InverterGateDelay) { output setSignal (!inputSig) }
    }
    input addAction invertAction
  }

  def probe(name: String, wire: Wire): Unit = {
    def probeAction(): Unit = {
      println(s"$name $currentTime value = ${wire.getSignal}")
    }

    wire addAction probeAction
  }
}

abstract class Circuits extends Gates {

  // input a, b
  // output sum, carry
  def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire): Unit = {
    val d = new Wire
    val e = new Wire

    orGate(a, b, d)
    andGate(a, b, c)
    inverter(c, e)
    andGate(d, e, s)
  }

  def fullAdder(a: Wire, b: Wire, cin: Wire, sum: Wire, cout: Wire): Unit = {
    val s = new Wire
    val c1 = new Wire
    val c2 = new Wire

    halfAdder(b, cin, s, c1)
    halfAdder(a, s, sum, c2)
    orGate(c1, c2, cout)
  }
}

trait Parameters {  
  def InverterGateDelay = 2
  def AndGateDelay = 3
  def OrGateDelay = 5
}
</code></pre>

<p>테스트코드는</p>

<pre><code class="scala">object test extends Circuits with Parameters  
import test._  
val in1, in2, sum, carry = new Wire

halfAdder(in1, in2, sum, carry)  
probe("sum", sum)  
probe("carry", carry)

in1.setSignal(true)  
test.run()  
in2.setSignal(true)  
test.run()  
</code></pre>

<p>결과는</p>

<pre><code class="scala">sum 0 value = false  
carry 0 value = false  
*** simulation started, time = 0 ***
sum 8 value = true  
*** simulation started, time = 8 ***
carry 11 value = true  
sum 16 value = false  
</code></pre>

<p>흐름을 정리해 보면,</p>

<p>(1) <code>halfAdder</code> <br />
(2) <code>orGate, andGate, invertGate</code> <br />
(3) <code>addAction</code>
(4) <code>a()</code> -> <code>afterDelay</code> <br />
(5) <code>insert</code> 에서 시간을 고려해 이벤트리스트에 삽입 <br />
(6) <code>loop</code> 가 돌아가면서 모든 <code>action</code> 실행</p>

<h4 id="avariant">A Variant</h4>

<p><em>OR gate</em> 는 <em>AND, Invert</em> 로 구성될 수 있다. <code>a | b = ~(~a &amp; ~b)</code> 이기 때문인데</p>

<pre><code class="scala">def orGateAlt(in1: Wire, in2: Wire, output: Wire): Unit = {  
  def orAction(): Unit = {
    val notIn1, notIn2, notOut = new Wire
    inverter(in1,notIn1);
    inverter(in2,notIn2);
    andGate(notIn1, notIn2, notOut)
    inverter(notOut, output)
  }
}
</code></pre>

<p>만약에 이 <em>OR Gate</em> 를 사용하면 어떻게 될까? 시간은 당연히 달라지고, 추가적인 이벤트도 발생한다.</p>

<h3 id="summary">Summary</h3>

<ul>
<li><em>state</em> 와 <em>assignment</em> 는 모델을 더 복잡하게 만든다. </li>
<li><em>referential transparency</em> 도 포기해야 한다</li>
</ul>

<p>반면</p>

<ul>
<li><em>discrete event simulation</em> 같은 특정 형태의 프로그램을 우아하게 작성할 수 있다</li>
<li>시스템은 <em>mutable list of actions</em> 로 표현되고</li>
<li><em>action</em> 이 호출되면 그 효과로 인해 오브젝트의 상태가 변한다</li>
<li>미래에 호출될 <em>action</em> 을 <em>install</em> 할 수 있다.</li>
</ul>

<h3 id="references">References</h3>

<p>(1) <em>Reactive Programming</em> by <strong>Martin Ordersky</strong> <br />
(2) <a href='http://msdn.microsoft.com/en-us/library/aa288734' (v=vs.71).aspx">MSDN: Half Adder</a></p>]]></description><link>http://1ambda.github.io/reactive-programming-2/</link><guid isPermaLink="false">1f0f0056-8b79-426c-abcb-ce9071c541bb</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[reactive programming]]></category><category><![CDATA[referential transparency]]></category><category><![CDATA[operational equivalence]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 21 Dec 2014 01:57:05 GMT</pubDate></item><item><title><![CDATA[하스켈로 배우는 함수형 언어 9]]></title><description><![CDATA[<h3 id="intro">Intro</h3>

<p>이번시간엔 함수형 프로그래밍에서 <em>property</em> 를 증명하는 방법인 <em>induction</em> 에 대해 배워보고, 하스켈에서 알고리즘의 성능이 어떨까에 대해 좀 논의해 보겠습니다. 마지막엔 <em>Rose Tree</em> 를 구현하면서 <em>Functor, Monoid, Foldable</em> 등에 대해 좀 알아봅시다.</p>

<p>수학에서 다음 두 식은 똑같습니다.</p>

<pre><code>xz + yz = (x + y)z  
</code></pre>

<p>근데, 잘 보면 연산의 수가 다릅니다. 좌측은 3개고, 우측은 2개면 되지요. 하스켈에서도 이런 생각들을 좀 해봅시다. <em>built-in</em> 연산자에 대해서뿐만 아니라, <em>user-defined</em> 연산자 (함수) 에 대해서도 생각할 수 있으니까, 좀 다양하겠네요.</p>

<h3 id="reasoningabouthaskell">Reasoning about Haskell</h3>

<pre><code class="haskell">double :: Int -&gt; Int  
double x = x + x  
</code></pre>

<p>이제 모든 <code>x + x</code> 는 <code>double x</code> 로, 바꿀 수 있죠. 그 반대도 가능하고요. 근데, <em>multiple equations</em> 를 쓰면 좀 얘기가 다릅니다.</p>

<pre><code class="haskell">isZero :: Int -&gt; Bool  
isZero 0 = True  
isZero n = False  
</code></pre>

<p>첫번째 식 <code>isZero 0 = True</code> 는 어느 방향으로든 자유롭게 적용가능하지만, 두번째는 아닙니다. 사실은 이런 뜻이거든요</p>

<pre><code class="haskell">isZero 0          = True  
isZero n | n /= 0 = False  
</code></pre>

<p>이제 좌우를 쉽게 치환할 수 있습니다. 이렇게 식의 순서에 의존하지 않는 패턴을 <em>disjoint</em> 혹은 <em>non-overlapping</em> 이라 부릅니다.</p>

<blockquote>
  <p>Patterns that do not rely on the order in which the are matched are called <em>disjoint</em> or <em>non-overlapping</em></p>
</blockquote>

<p>프로그램에 대해서 <em>reasoning</em> 할 땐 가능하면 <em>non-overlapping</em> 패턴을 사용하는게 좋습니다. <em>standard library</em> 에 있는 대부분의 함수들은 이런식으로 작성 되어있습니다.</p>

<h3 id="simpleexamples">Simple examples</h3>

<pre><code class="haskell">reverse :: [a] -&gt; [a]  
reverse [] = []  
reverse (x:xs) reverse xs ++ [x]  
</code></pre>

<p>이 구현을 보면 <code>reverse [x] = [x]</code> 입니다. 근데, 이걸 연산하려면</p>

<pre><code class="haskell">reverse [x]  
reverse (x:[])  
reverse [] ++ [x]  
[] ++ [x]
[x]
</code></pre>

<p>따라서 <code>reverse [x] = [x]</code> 를 추가해서 효율적인 구현을 할 수 있습니다. </p>

<h3 id="inductiononnumbers">Induction on numbers</h3>

<p>함수형 프로그램은 종종 재귀를 이용해 작성되는데, 여기에 <em>induction</em> 을 이용할 수 있습니다. 예전에 본 자연수 타입 <code>Nat</code> 의 정의를 떠올려 보면</p>

<pre><code class="haskell">data Nat = Zero | Succ Nat  
</code></pre>

<p>어떤 유한한 수에 대해서 어떤 <em>property</em> <code>p</code> 를 증명하려고 할 때, 먼저 <em>base case</em> 인 <code>Zero</code> 에 대해 보이고, <em>inductive case</em> <code>Succ</code> 에 대해서 보이면 됩니다. 더 자세히는, 어떤 자연수 <code>n</code> 에 대해서 <code>p</code> 가 참일때 (<em>induction hypothesis</em>), <code>Succ n</code> 에 대해서도 참임을 보이면 됩니다.</p>

<p>구체적인 예제를 보도록 하죠. 두 <code>Nat</code> 를 더해 <code>Nat</code> 를 만드는 <code>add</code> 함수를 만들면</p>

<pre><code class="haskell">add :: Nat -&gt; Nat -&gt; Nat  
add Zero m = m  
add (Succ n) m = Succ (add n m)  
</code></pre>

<p>첫 번째씩 <code>add Zero m = m</code> 은 모든 자연수 <code>m</code> 에 대해 참이기 때문에, <code>add n Zero = n</code> 을 증명하겠습니다. 이걸 가설 <code>p</code> 라 부릅시다. </p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">add Zero Zero  
Zero  
</code></pre>

<p>(2) <em>inductive case</em></p>

<p>이 단계에서는 <code>p</code> 가 자연수 <code>n</code> 에 대해 참일때 <code>p (Succ n)</code> 이 참임을 보이면 됩니다. 다시 말해 가설 <code>p</code> <code>add n Zero = n</code> 을 이용해 <code>add (Succ n) Zero = Succ n</code> 임을 보여야 합니다.</p>

<pre><code class="haskell">add (Succ n) Zero -- should be `Succ n`

= Succ (add n Zero) 

= Succ n -- by induction hypothesis
</code></pre>

<p>다른 속성으로 <em>associativity</em> 를 증명할 수도 있습니다. </p>

<pre><code class="haskell">add x (add y z) = add (add x y) z  
</code></pre>

<p>인자가 3개인데 무엇부터 시작해야 할까요? <code>add</code> 는 패턴매칭을 이용해 작성되었고, 재귀 부분이  첫번째 인자를 주로 이용하므로 <code>x</code> 를 선택하는게 자연스러울 겁니다. <code>y</code>는 1 번 쓰이고, <code>z</code>는 첫번째 인자로 한번도 안쓰이네요. </p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">add Zero (y z) -- should be `add (add Zero y) z`

= add y z
= add (add Zero y) z -- unapplying add
</code></pre>

<p>(2) <em>inductive case</em></p>

<p><code>p</code> 는 `add x (add y z) = add (add x y) z</p>

<pre><code class="haskell">add (Succ x) (add y z) -- should be 'add (add (Succ x) y) z`

= Succ (add x (add y z)) -- apply outer add
= Succ (add (add x y) z) -- induction hypothesis
= add (Succ (add x y) z) -- unapply outer add
= add (add (Succ x) y) z -- unapply inner add
</code></pre>

<p>이렇게 <em>unapply, apply</em> 를 편하게 할 수 있는 이유는 위에서 <code>add</code> 를 <em>non-overlapping</em> 패턴으로 작성했기 때문이지요.</p>

<p><em>induction</em> 을 <em>recursive type</em> 인 <code>Nat</code> 에 적용했지만, <code>Integer</code> 타입에도 적용할 수 있습니다.</p>

<p>어떤 <em>property</em> <code>p</code> 를 <code>n &gt;= 0</code> 에 대해 증명하려고 할 때는 먼저 <em>base case</em> 인 <code>0</code> 에 대해 참임을 보이고, <code>n &gt;= 0</code> 일때, <code>n + 1</code> 에 대해서도 참임을 보이면 됩니다.</p>

<pre><code class="haskell">replicate :: Int -&gt; a -&gt; [a]  
replicate 0 _       = []  
replicate (n + 1) x = x : replicate n x  
-- replicate n x = x : replicate (n - 1) x
</code></pre>

<p>요즘 컴파일러는 <code>n + 1</code> 패턴을 막아서 아마 주석처리부분처럼 작성해야 합니다. 무튼 저 정의대로만 보면, <code>n</code> 에 대해 참일때 <code>n + 1</code> 일때도 참임을 보이는건 정말 쉽습니다. 정의 그 자체가 <em>induction</em> 이니까요.</p>

<h3 id="inductiononlists">Induction on lists</h3>

<p>재귀는 자연수에만 쓸 수 있는건 아니고, 리스트와 같은 다양한 재귀적인 타입에 사용할 수 있습니다. <em>base case</em> 는 <code>[]</code> 이 되겠고, <em>successor function</em> 은 <code>:</code> 이 되겠네요.</p>

<p>그러므로 리스트에 대해 어떤 <em>property</em> <code>p</code> 를 증명하려면, 먼저 <code>[]</code> 에 대해 참임을 보이고 <code>p xs</code> 가 참일때 <code>p x:xs</code> 가 참임을 보이면 됩니다. <del>참 쉽죠?</del></p>

<p><em>reverse</em> 연산에 대해 <code>reverse (reverse xs) = xs</code> 를 증명해 봅시다.</p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">reverse (reverse []) -- should be '[]'

= reverse []
= []
</code></pre>

<p>(2) <em>inductive case</em></p>

<pre><code class="haskell">-- induction hypothesis

reverse (reverse xs) = xs  
</code></pre>

<p>증명은</p>

<pre><code class="haskell">reverse (reverse x:xs) -- = x:xs

= reverse (reverse xs ++ [x])
= reverse [x] ++ reverse (reverse xs) -- by distributivity
= [x] ++ xs -- induction hypothesis
= x:xs
</code></pre>

<p>여기서 사용한 성질중에 하나가 <em>distributivity</em> 인데,</p>

<pre><code class="haskell">-- induction hypothesis
reverse (xs ++ ys) = reverse ys ++ reverse xs  
</code></pre>

<p>(1) <em>base-case</em> </p>

<pre><code class="haskell">reverse ([] ++ ys) -- reverse ys ++ reverse [] 

= reverse ys
= [] ++ reverse ys -- unapply ++
= reverse [] ++ reverse ys
</code></pre>

<p>(2) <em>inductive case</em></p>

<pre><code class="haskell">reverse ((x:xs) ++ ys) -- reverse ys ++ reverse (x:xs)

= reverse (x:(xs ++ ys))
= reverse (xs ++ ys) ++ [x]
= reverse ys ++ (reverse xs ++ [x])
= reverse ys ++ (reverse (x:xs)) -- unapply second reverse
</code></pre>

<p>이 증명은 <code>++</code> 가 <em>associative</em> 라는 사실을 이용해 증명했는데, 이것도 마찬가지로 증명할 수 있습니다.</p>

<h3 id="markingappendvanish">Marking append vanish</h3>

<p>많은 재귀 함수들이 <code>++</code> 연산을 이용해 작성되었는데, 편하긴 하지만 재귀적으로 사용되면 비용이 좀 듭니다. 따라서 이번에는 <code>++</code> 를 제거 해서 좀 더 효율적으로 함수를 작성해봅시다.</p>

<p><code>reverse</code> 함수부터 해 보면</p>

<pre><code class="haskell">reverse :: [a] -&gt; [a]  
reverse [] = []  
reverse (x:xs) = reverse xs ++ [x]  
</code></pre>

<p>이렇게 작성된 <code>reverse</code> 함수의 성능은 어떨까요? 먼저 생각해 볼 것은 <code>xs ++ ys</code> 을 <em>evaluation</em> 하기 위해 얼마의 스텝이 필요할까? 입니다. <code>xs ++ ys</code> 는 <code>xs</code> 를 쪼개가면서 <code>xs</code> 에 붙이기 때문에, <code>xs + 1</code> 만큼의 스텝이 필요하죠.</p>

<p>참고로 <code>append</code> 의 정의는</p>

<pre><code class="haskell">append :: [a] -&gt; [a] -&gt; [a]  
append [ ] xs    = xs  
append (x:xs) ys = x : append xs ys  
</code></pre>

<p>좀 간단히 생각하기 위해 <code>xs, ys</code> 가 <em>fully evaluated</em> 되었다 합시다. 그 결과로 <code>++</code> 는 첫 번째 인자 <code>xs</code> 의 길이에 비례하는 <em>linear time</em> 퍼포먼스를 보여줍니다.</p>

<p>결과적으로 <code>reverse xs</code> 의 성능은, 길이를 <code>n</code> 이라 했을 때 <code>1 + 2 + ... + n + 1</code> 입니다. <code>(n^2 + 3n + 2) / 2</code> 겠네요. 이는 <code>reverse</code> 함수가 <em>quadratic time</em> 의 함수라는걸 말해줍니다. 1000 개를 뒤집으려면, 10000000 번만큼 연산을 해야한다는 소리지요.</p>

<p>다행히도 <em>induction</em> 을 이용해 쓸모없는 <code>++</code> 부분을 제거하고, 성능을 개선할 수 있습니다.</p>

<p><code>reverse</code> 와 <code>++</code> 를 합친 좀 더 <em>general</em> 한 함수를 만듭시다. <code>reverse'</code> 라 부를건데, <code>reverse xs += ys</code> 와 같은 일을 할겁니다. </p>

<pre><code class="haskell">reverse' xs ys -- = reverse xs ++ ys  
</code></pre>

<p>이렇게 만들면 <code>reverse</code> 자체는 이렇게 정의할 수 있습니다. <code>[]</code> 가 <em>append</em> 를 위한 <em>identity</em> 라는 점을 이용한 것이지요.</p>

<pre><code class="haskell">reverse xs = reverse' xs []  
</code></pre>

<p>신기하게도 이 속성을 증명하면서, 이 <code>reverse'</code> 의 정의 자체를 얻을 수 있습니다. </p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">reverse' [] ys 

= reverse [] ++ ys 
= [] ++ ys
= ys
</code></pre>

<p>(2) <em>inductive case</em></p>

<pre><code class="haskell">reverse' (x:xs) ys

= reverse (x:xs) ++ ys
= (reverse xs ++ [x]) ++ ys
= reverse xs ++ ([x] ++ ys]) -- by associativity of ++
= reverse' xs ([x] ++ ys) -- by induction hypothesis
= reverse' xs (x:ys)
</code></pre>

<p>따라서 <code>reverse'</code> 의 정의는</p>

<pre><code class="haskell">reverse' [a] -&gt; [a] -&gt; [a]  
reverse' [] y = ys  
reverse' (x:xs) ys = reverse' xs (x:ys)  
</code></pre>

<p>아까 언급했던대로 <code>reverse</code> 를 다시 만들면</p>

<pre><code class="haskell">reverse :: [a] -&gt; [a]  
reverse xs = reverse' xs []  
</code></pre>

<p>이제는 <code>x:ys</code> 처럼, 하나씩 분리해 나가면서 붙기때문에 성능이더 빠릅니다. 정확히는 <code>n + 2</code>  연산이 필요하지요. <em>linear time</em> 입니다. </p>

<p>사실은 7장 에서 이미 개선된 <em>reverse</em> 를 봤었습니다. <code>reverse = foldl (:) []</code> 기억 나시나요?</p>

<h4 id="flatten">flatten</h4>

<pre><code class="haskell">data Tree = Leaf Int | Node Tree Tree  
flatten :: Tree -&gt; [Int]  
flatten (Leaf n) = [n]  
flatten (Node l r) = flatten l ++ flatten r  
</code></pre>

<p>이 <code>flatten</code> 도 <code>++</code> 때문에 느립니다. 위 <code>reverse</code> 처럼 개선해 보면</p>

<pre><code class="haskell">flatten' t ns = flatten t ++ [ns]  
</code></pre>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">flatten' (Leaf n) ns

= flatten (Leaf n) ++ ns
= [n] ++ ns
n:ns  
</code></pre>

<p>(2) <em>inductive case</em></p>

<pre><code class="haskell">flatten' (Node l r) ns

= (flatten l ++ flatten r) ++ ns
= flatten l ++ (flatten r ++ ns) -- associativity
= flatten' l ++ (faltten r ++ ns) -- hypothesis
= flatten' l (flatten' r ns)
</code></pre>

<p>따라서 <code>flatten'</code>, <code>flatten</code> 은</p>

<pre><code class="haskell">flatten' :: Tree -&gt; [Int] -&gt; [Int]  
flatten' (Leaf n) ns = n:ns  
flatten' (Node l r) ns = flatten' l (flatten' r ns)

flatten :: Tree -&gt; [Int]  
flatten t = flatten' t []  
</code></pre>

<h3 id="compilercorrectness">Compiler Correctness</h3>

<pre><code class="haskell">data Expr = Val Int | Add Expr Expr

eval :: Expr -&gt; Int  
eval (Val n) = n  
eval (Add x y) = eval x + eval y  
</code></pre>

<p>지난번에 만들었던 이 계산 기계를 잘 보면, <em>expression</em> 이 간접적으로 <em>evaluated</em> 됩니다. 스택을 이용해 실행되는 코드의 도움을 받아서요. </p>

<p>자세히 보면 스택은 <em>integer list</em> 고, 코드는 <em>push, add</em> 연산의 리스트입니다. 따라서</p>

<pre><code class="haskell">type Stack = [Int]  
type Code = [Op]  
data Op = PUSH Int | ADD  
</code></pre>

<p>결국 코드를 실행한다는 말은 초기 스택을 받아, 이걸 이용해 계산을 하고 다시 스택을 돌려준다는 뜻입니다.</p>

<pre><code class="haskell">exec :: Code -&gt; Stack -&gt; Stack  
exec []         s       = s  
exec (PUSH n:c) s       = exec c (n:s)  
exec (ADD:c)    (m:n:s) = exec c (m+n:s)  
</code></pre>

<p>이제 <code>Expr</code> 을 <code>Code</code> 로 변경하는 함수 <code>compile</code> 를 만들면</p>

<pre><code class="haskell">compile' :: Expr -&gt; Code  
compile' (Val n) = [PUSH n]  
compile' (Add x y) = compile x ++ compile y ++ [ADD]

compile :: Expr -&gt; Code  
compile e = compile' e  
</code></pre>

<p>그리고 화면에 출력을 위해 <code>Show</code> 를 구현하고 샘플식 <code>e</code> 를 만들면</p>

<pre><code class="haskell">instance Show Expr where  
  show (Val n) = "(Val " ++ show n ++ ")"
  show (Add x y) = "(Add " ++ show x ++ " " ++ show y ++ ")"

instance Show Op where  
  show (PUSH n) = "(PUSH " ++ show n ++ ")"
  show (ADD) = "(ADD)"

e :: Expr  
e = (Add (Add (Val 2) (Val 3)) (Val 4))  
</code></pre>

<pre><code class="haskell">&gt; e
-- (Add (Add (Val 2) (Val 3)) (Val 4))

&gt; eval e
-- 9

&gt; compile e
-- [(PUSH 2),(PUSH 3),(ADD),(PUSH 4),(ADD)]
</code></pre>

<p>잘 보면, 식을 컴파일해서 초기스택 <code>[]</code> 와 함께 실행시킨 것은, <code>[eval e]</code> 와 같다는 것을 알 수 있지요. <code>[]</code> 대신 임의의 스택 <code>s</code> 를 이용하면</p>

<pre><code class="haskell">exec (compile e) s = eval e:s  
</code></pre>

<p>(1) <em>base-case:</em> <code>(Val n)</code></p>

<pre><code class="haskell">exec (compile (Val n)) s

= exec [PUSH n] s
= n : s
eval (Val n) : s -- unapply eval  
</code></pre>

<p>(2) <em>inductive case:</em> <code>(Add x y)</code></p>

<pre><code class="haskell">exec (compile (Add x y)) s

= exec (compile x ++ compile y ++ [ADD]) s
= exec (compile x ++ (compile y ++ [ADD])) s -- associativity
= exec (compile y ++ [ADD]) (exec (compile x) s) -- distributivity of exec
= exec (compile y ++ [ADD]) (eval x:s) -- induction hypothesis for x
= exec [ADD] (exec (compile y) (eval x:s)) -- distributivity
= exec [ADD] (eval y : eval x : s)
= (eval x + eval y) : s -- apply exec
= eval (Add x y) : s -- unapply eval
</code></pre>

<p>위에서 쓴 <code>exec</code> 의 <em>distributivity</em> 를 보이면</p>

<pre><code class="haskell">exec (c ++ d) s = exec d (exec c s)  
</code></pre>

<p><code>c</code> 가 <code>PUSH</code> 일때, 그리고 <code>ADD</code> 일때로 나눠서 증명하면 되죠.</p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">exec ([] ++ d) s 

= exec d s
= exec d (exec [] s) -- unapply exec
</code></pre>

<p>(2-1) <em>inductive case:</em> <code>PUSH n</code></p>

<pre><code class="haskell">exec ((PUSH n : c) ++ d) s

= exec (PUSH n : (c ++ d)) s
= exec (c ++ d) (n:s)
= exec d (exec c (n:s)) -- induction hypothesis
= exec d (exec (PUSH n:c) s) -- unapply exec
</code></pre>

<p>(2-2) <em>inductive case:</em> <code>ADD</code></p>

<pre><code class="haskell">exec ((ADD : c) ++ d) s  
= exec (ADD : (c ++ d)) s
= exec (ADD : (c ++ d)) (m:n:s') -- assume s == m:n:s'
= exec (c ++ d) (m+n:s') -- apply exec
= exec d (exec c (m+n:s')) -- induction hypothesis
= exec d (exec (ADD : c) (m:n:s')) -- unapply exec
= exec d (exec (ADD : c) s)
</code></pre>

<p><code>s</code> 를 <code>m:n:s'</code> 로 의 가정은 <em>underflow error</em> 를 겪을 수 있는것처럼 보이지만, 실제로는 그렇지 않습니다. 왜냐하면 <code>ADD</code> 연산이 들어있다는 자체가 최소한 두개의 숫자는 스택에 포함한다는 뜻이기 때문입니다. (<code>exec</code> 의 정의를 보세요)</p>

<p>그리고 이전 장에서 <em>append</em> 연산에 적용했던 테크닉을 다시 가져와서, <em>distributivity property</em> 의 <em>underflow</em> 이슈를 예방할 수 있습니다. 이 속성을 유지하도록 하면요</p>

<pre><code class="haskell">compile' e c = compile e ++ c  
</code></pre>

<p>이 속성을 <em>induction</em> 을 이용해서 차근차근 풀면, 아래와 같은 정의를 얻을 수 있습니다.</p>

<pre><code class="haskell">compile' :: Expr -&gt; Code -&gt; Code  
compile' (Val n) c = PUSH n : c  
compile' (Add x y) = compile' x (compile' y (ADD : c))

compile e = compile' e []  
</code></pre>

<p>그러면 <em>compiler correctness</em> 는 </p>

<pre><code class="haskell">exec (compiler' e c) s = exec c (eval e : s)  
</code></pre>

<p>해석은 원문을 첨부하겠습니다.</p>

<blockquote>
  <p>That is, compiling an expression and then executing the resulting code together with arbitrary additional code gives the same result as executing the additional code with the value of the expression on top of the original stack</p>
  
  <p>Note that with <code>s = c = [ ]</code>, this new result simplifies to <code>exec (compile e) [] = [eval e]</code>, our original statement of correctness. </p>
  
  <p>In addition to avoiding the problem of stack underflow in the correctness proof, the accumulator version of the compiler has two further benefits. </p>
  
  <p>First of all, <strong>it avoids the use of ++,</strong> and is hence more efficient. And, </p>
  
  <p>secondly, <strong>the new proof is less than half the combined length of our previous two proofs.</strong> As is often the case in formal reasoning, generalising a result in the appropriate manner can considerably simplify its proof. Mathematics is an excellent tool for guiding the development of efficient programs with simple proofs!</p>
</blockquote>

<h3 id="rosetree">Rose Tree</h3>

<p>로즈 트리는 원소의 개수가 <em>unbounded</em> 인 트리입니다. 이렇게 정의할 수 있습니다.</p>

<pre><code class="haskell">data a = a :&gt; [Rose a] deriving Show  
</code></pre>

<p>여기서 <code>:&gt;</code> 는 <em>constructor</em> 입니다. 생성자가 <em>infix</em> 연산자로 올때는 <code>:</code> 로 시작해야 합니다. <code>deriving Show</code> 는 좀 디버깅 쉬우라고, 화면에 출력하기 위해 사용했습니다.</p>

<p>몇 가지 헬퍼 함수를 만들면,</p>

<pre><code class="haskell">root :: Rose a -&gt; a  
root (x :&gt; xs) = x

children :: Rose a -&gt; [Rose a]  
children (x :&gt; xs) = r

size :: Rose a -&gt; Int  
size (x :&gt; xs) = 1 + sum (map size xs)

leaves :: Rose a -&gt; Int  
leaves (_ :&gt; []) = 1  
leaves (_ :&gt; xs) = 1 + sum (map leaves xs)  
</code></pre>

<p>샘플 로즈 트리를 만들어 봅시다. </p>

<pre><code class="haskell">tree = 'x' :&gt; map (flip (:&gt;) []) ['a'..'z']

-- same as
tree = 'x' :&gt; map (\c -&gt; c :&gt; []) ['a'..'z'] 

&gt; tree
-- 'x' :&gt; ['a' :&gt; [],'b' :&gt; [],'c' :&gt; [],'d' :&gt; [],'e' :&gt; [],'f' :&gt; [],'g' :&gt; [],'h' :&gt; [],'i' :&gt; [],'j' :&gt; [],'k' :&gt; [],'l' :&gt; [],'m' :&gt; [],'n' :&gt; [],'o' :&gt; [],'p' :&gt; [],'q' :&gt; [],'r' :&gt; [],'s' :&gt; [],'t' :&gt; [],'u' :&gt; [],'v' :&gt; [],'w' :&gt; [],'x' :&gt; [],'y' :&gt; [],'z' :&gt; []]

&gt; size tree
-- 27

&gt; leaves tree
-- 26
</code></pre>

<h3 id="functor">Functor</h3>

<p>좀 삼삼하죠? 할게 별로 없으니. <em>rose tree</em> 를 <em>functor</em> 로 만들어 봅시다. 아래 짤방이 아마 세상에서 펑터를 가장 쉽게 설명할겁니다. <code>fmap (+3) (Just 2)</code> 에 대해</p>

<p><img src='http://adit.io/imgs/functors/fmap_just.png'  alt="" /></p>

<p align="center">(<a href='http://adit.io/' >http://adit.io</a>)</p>

<p>즉, <code>Just</code> 는 펑터이므로 <code>2</code> 를 꺼내 <code>+3</code> 을 적용하고, 다시 <code>Just</code> 를 씌워 <code>Just 5</code>로 만들어 줍니다. 그게 <code>fmap</code> 이 하는 일이고, 모든 <em>functor</em> 는 <code>fmap</code> 이 적용 가능합니다. <em>functor</em> 의 정의를 보면</p>

<pre><code class="haskell">class  Functor f  where  
    fmap        :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p>타입이 직관적이죠? <code>a -&gt; b</code> 함수를 받아, <code>f a</code> 에 함수를 적용해서 <code>f b</code> 를 만듭니다. <code>f</code> 는 컨테이너라고 보시면 됩니다. <code>Maybe</code> 같은 것들요 대표적인 <code>Functor</code> 로</p>

<pre><code class="haskell">instance  Functor Maybe  where  
    fmap f Nothing = Nothing
    fmap f (Just x) = Just (f x)


instance  Functor []  where  
    fmap = map 
</code></pre>

<p>그럼 우리가 만든 <code>Rose</code> 는 어떻게 해야 <code>Functor</code> 로 만들 수 있을까요?</p>

<pre><code class="haskell">instance Functor Rose  where  
    fmap g (x :&gt; xs) = g x :&gt; map (fmap g) xs  
</code></pre>

<p>직관적으로 보면 됩니다. 루트에 <code>g</code> 를 적용하고, <code>xs</code> 는 <code>[Rose]</code> 이므로 <code>x :&gt; xs</code> 와 똑같이 취급해서 <code>fmap g</code> 를 적용하면 됩니다. 이 때 지켜줘야 하는 <em>functor laws</em> 는</p>

<pre><code class="haskell">fmap id  ==  id  
fmap (f . g)  ==  fmap f . fmap g  
</code></pre>

<p>그럼 이제, 좀 재미난걸 할 수 있습니다. 이젠 <code>Rose</code> 가 <em>functor</em> 니까요. 다양한 함수를 적용할 수 있죠. </p>

<pre><code class="haskell">tree' = 1 :&gt; map (flip (:&gt;) []) [1..5]

&gt; tree'
-- 1 :&gt; [1 :&gt; [],2 :&gt; [],3 :&gt; [],4 :&gt; [],5 :&gt; []]

&gt; fmap (+1) tree'
-- 2 :&gt; [2 :&gt; [],3 :&gt; [],4 :&gt; [],5 :&gt; [],6 :&gt; []]

&gt; fmap (*10) tree'
-- 10 :&gt; [10 :&gt; [],20 :&gt; [],30 :&gt; [],40 :&gt; [],50 :&gt; []]

&gt; fmap (:&gt; []) tree'
-- (1 :&gt; []) :&gt; [(1 :&gt; []) :&gt; [],(2 :&gt; []) :&gt; [],(3 :&gt; []) :&gt; [],(4 :&gt; []) :&gt; [],(5 :&gt; []) :&gt; []]
</code></pre>

<h3 id="monoid">Monoid</h3>

<p><em>monoid</em> 는 <code>mempty</code>, <code>mappend</code> 두개의 함수를 가지고 있는 <code>m</code> 타입의 인스턴스입니다.</p>

<ul>
<li><code>mappend :: m -&gt; m -&gt; m</code> 은 <em>associative</em> 한 연산자로, 두 <code>m</code> 을 받아서, 하나의 <code>m</code> 으로 합칩니다. </li>
<li><code>mempty :: m</code> 은 <code>mappend</code> 의 <em>neutral element</em> 를 표현합니다. </li>
</ul>

<p>뭔소리야 하실텐데, 우리 주변의 많은 것들이 <em>monoid</em> 입니다. 예제를 봅시다.</p>

<pre><code class="haskell">&gt; (5 + 6) + 10 == 5 + (6 + 10)
True

&gt; (5 * 6) * 10 == 5 * (6 * 10)
True

&gt; ("Hello" ++ " ") ++ "world!" == "Hello" ++ (" " ++ "world!")
True  
</code></pre>

<p><code>[Char]</code> 에서 <code>mempty</code> 는 <code>[]</code> <code>mappend</code> 는 <code>++</code> 입니다. <code>Integer</code> 의 <code>mappend</code> 는 다양한데, <code>+</code> 라면 <code>mempty</code> 가 <code>0</code> 이고, <code>*</code> 라면 <code>mempty</code> 가 <code>1</code> 일 겁니다. 항등원 기억나시죠? 그거랑 비슷합니다.</p>

<pre><code class="haskell">class  Monoid a  where  
    mappend :: a -&gt; a -&gt; a
    mempty  :: m
    mconcat :: [a] -&gt; a
    mconcat :: foldr mappend mempty
</code></pre>

<p><code>mconcat</code> 은 <code>foldr (++) []</code> 를 생각하시면 이해가 쉽습니다. 네! 리스트도 모노이듭니다!</p>

<pre><code class="haskell">instance  Monoid [a]  where  
    mempty = []
    mappend = (++)
</code></pre>

<p>모노이드를 일종의 연산과 그에 대한 항등원이 구현된 클래스라 보셔도 됩니다. 그러면 <code>Sum</code>, <code>Product</code> 모노이드를 만들어 보죠. <code>Rose</code> 에 적용할 수 있을 것 같아요.</p>

<pre><code class="haskell">newtype Sum a = Sum { getSum :: a } deriving Show  
newtype Product a = Product a deriving Show

unProduct :: Product a -&gt; a  
unProduct (Product x) = x

instance Num a =&gt; Monoid (Sum a) where  
  mempty = Sum 0
  Sum x `mappend` Sum y = Sum (x + y)

instance Num a =&gt; Monoid (Product a) where  
  mempty = Product 1
  Product x `mappend` Product y = Product (x * y)
</code></pre>

<p>중간에 보면 <code>unProduct</code> 란게 있는데, 생성자에서 <code>getSum</code> 처럼 <em>accessor</em> 를 만들어 주면 필요 없고, 안만들어 주면 저렇게 만들어서 써야 합니다. 차이점을 보여드리기 위해 두 방법을 모두 사용 해봤어요. 근데, <em>accessor</em> 가 있으면 출력때 같이 나와서 좀 불편합니다.</p>

<pre><code class="haskell">-- 6 * (3 + 4)
&gt; unProduct (Product 6 `mappend` (Product . getSum $ Sum 3 `mappend` Sum 4))

-- 42
</code></pre>

<p>무튼, 이제 모노이드도 있겠다, <code>Rose</code> 에 적용할 수 있습니다. 이게 무슨 뜻이냐면, <code>Rose</code> 컨테이너가 가진 <em>value</em> 가 <code>Product</code>, <code>Sum</code> 연산이 가능하게끔 바꿀 수 있다는 뜻입니다.</p>

<pre><code class="haskell">&gt; tree'
-- 1 :&gt; [1 :&gt; [],2 :&gt; [],3 :&gt; [],4 :&gt; [],5 :&gt; []]

&gt; fmap Sum tree'
-- Sum 1 :&gt; [Sum 1 :&gt; [],Sum 2 :&gt; [],Sum 3 :&gt; [],Sum 4 :&gt; [],Sum 5 :&gt; []]

&gt; fmap Product tree'
-- Product 1 :&gt; [Product 1 :&gt; [],Product 2 :&gt; [],Product 3 :&gt; [],Product 4 :&gt; [],Product 5 :&gt; []]
</code></pre>

<h3 id="foldable">Foldable</h3>

<p><img src='https://www.haskell.org/wikiupload/thumb/3/39/FunctorHierarchy.svg/558px-FunctorHierarchy.svg.png'  alt="" /></p>

<p align="center">(<a href='https://www.haskell.org/' >https://www.haskell.org</a>)</p>

<p><em>foldable</em> 은 진짜 말 그대로 접을 수 있는 연산 <code>fold</code> 를 지원하는 인스턴스를 말합니다.</p>

<pre><code class="haskell">class Foldable t where  
    fold    :: Monoid m =&gt; t m -&gt; m
    foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m

    foldr   :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldr'  :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b

    foldl   :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldl'  :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b

    foldr1  :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a
    foldl1  :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a
</code></pre>

<p>여기선 <code>fold, foldMap</code> 만 다루도록 하죠. <code>fold</code> 의 타입을 보면 아시겠지만, <code>Monoid  m</code> 의 컨테이너인 <code>Foldable t</code> 를 접어서 단일 <code>m</code> 으로 만듭니다.</p>

<p>따라서 복수개의 <code>Sum, Product</code> 를 접어 하나로 만들수 있지요. 어차피 이 두 모노이드에 대해 연산 자체는 정해져 있기 때문에 접는법만 알려주면 됩니다. </p>

<p>그리고 더 중요한 사실은, <code>Rose</code> 가 <code>Foldable</code> 이 되면 <code>Sum</code> 등이 적용된 <code>Rose</code> 를 접어 계산할 수 있습니다. 다시 말해 컨테이너에, 연산을 추가하고, <code>fold</code> 할 수 있다는 이야기지요. </p>

<p>아참! <code>foldMap</code> 은 이름에서 볼 수 있듯이 <code>fmap</code> 후 <code>fold</code> 한다고 생각하면 쉽습니다. <code>fold . fmap</code> 처럼요.</p>

<pre><code class="haskell">class Functor f =&gt; Foldable f where  
  fold :: Monoid m    =&gt; f m -&gt; m
  foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; (f a -&gt; m)
  foldMap = fold $ fmap g a

instance Foldable Rose where  
  fold (x :&gt; xs) = (h.g) xs `mappend` x
    where g = map (fold)
          h = foldr (mappend) mempty
</code></pre>

<p>직관적으로 보면 쉽습니다. <code>h</code> 는 모노이드 <code>m</code> 을 펼치는 역할을 합니다. <code>g</code> 는 <code>f m</code> 을  재귀적으로 펼치구요. 이는 로즈 트리가, 복수개의 자식 노드를 가질 수 있기 때문에 그런건데, 어찌 되었든 펼치면서 노드를 끝에다 붙여 나갑니다. </p>

<p>먼저 로즈 트리를 펼친 후에 모노이드를 합칠거니까, 순서는 <code>(g.h)</code> 입니다.</p>

<p>이제 그러면, 로즈트리가 <em>functor</em> 이므로 모노이드로 감쌀 수 있고 (연산을 지정할 수 있고)    게다가 <em>foldable</em> 이므로 그 연산을 이용해 하나로 접을 수 있습니다. </p>

<pre><code class="haskell">&gt; tree'
-- 1 :&gt; [1 :&gt; [],2 :&gt; [],3 :&gt; [],4 :&gt; [],5 :&gt; []]

&gt; fmap Sum tree'
-- Sum 1 :&gt; [Sum 1 :&gt; [],Sum 2 :&gt; [],Sum 3 :&gt; [],Sum 4 :&gt; [],Sum 5 :&gt; []]

&gt; fold $ fmap Sum tree'
-- Sum 16

&gt; unSum $ fold $ fmap Sum tree'
-- 16
</code></pre>

<p><del>갓스켈</del></p>

<h3 id="references">References</h3>

<p>(1) <strong>DelftX FP 101x</strong> <br />
(2) <em>Programming in Haskell</em> <br />
(3) <a href='http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html' >Functor, Monad, Applicative</a> <br />
(4) <a href='http://en.wikibooks.org/wiki/Haskell/Monoids' >Haskell WikiBooks - Monoids</a> <br />
(5) <a href='https://www.haskell.org/haskellwiki/Foldable_and_Traversable' >Foldable, Traversable</a> <br />
(6) <a href='http://blog.jakubarnold.cz/2014/07/30/foldable-and-traversable.html' >foldable and traversable</a></p>]]></description><link>http://1ambda.github.io/haskell-intro9/</link><guid isPermaLink="false">129bd89e-f8b4-4154-8c14-4f5c61aa2a43</guid><category><![CDATA[edx]]></category><category><![CDATA[haskell]]></category><category><![CDATA[induction]]></category><category><![CDATA[functor]]></category><category><![CDATA[monoid]]></category><category><![CDATA[foldable]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 18 Dec 2014 08:24:13 GMT</pubDate></item><item><title><![CDATA[Substring Search Algorithm]]></title><description><![CDATA[<h3 id="introtosubstringsearch">Intro to Substring Search</h3>

<p><code>N</code> 길이의 텍스트에서 <code>M</code> 길이의 패턴을 찾는 문제다. 일반적으로 <code>N &gt;&gt; M</code> 이다. <code>N</code> 이 좀 많이 (무한히) 길기 때문에 지난시간까지 배운 알고리즘을 적용하기가 좀 힘들다.</p>

<p>(1) <em>suffix sort</em> 를 쓰려고 보니 <em>suffixes</em> 를 만드는 것 자체가 어렵다. 따라서 <em>manber-myers MSD</em> 도 패스.</p>

<p>(2) <em>R-way</em> 든 <em>Ternary</em> 든 <em>tries</em> 자체를 만들기 어렵다. 탐색해야 할 문서는 어마어마하기 때문에 메모리의 양이 모자랄 수 밖에 없다. </p>

<p>뭔가 문서를 <em>streaming</em> 취급하면서 처리할 수 있는 알고리즘이 필요하다.</p>

<p>주된 <em>application</em> 은</p>

<ul>
<li><strong>computer forensics:</strong> search memory, disk for signatures</li>
<li><code>CTRL + F</code></li>
<li><strong>spam filtering:</strong> 특정 패턴이 발견되면 스팸이라 볼 수 있다.</li>
<li><strong>internet traffic monitoring:</strong> 보안</li>
<li><strong>screen scraping:</strong> 관련있는 패턴을 추출할 수 있다.</li>
</ul>

<p>자바에서는 <code>indexOf</code> 메소드가 문자열에서 해당 패턴을 발견해 시작 인덱스를 돌려준다.</p>

<h3 id="bruteforce">Brute Force</h3>

<p><del>언젠가 양자 컴퓨터가 나오면 쓸모 있을까</del></p>

<pre><code class="java">public static int bruteForce(String pattern, String docs) {  
    int M = pattern.length();
    int N = docs.length();

    for (int i = 0; i &lt; N - M; i ++) {
        int j;

        for (j = 0; j &lt; M; j++) 
            if (pattern.charAt(j) != docs.charAt(i + j)) break;

        if (j == M) return i;
    }

    return N;
}
</code></pre>

<p>성능은 <em>worst case</em> 에서 <code>~M N</code> 번의 <em>char compares</em> 가 필요하다. 예를 들어 문서가 <code>AAAAAAAAAAAB</code> 고 패턴이 <code>AAAAAB</code> 면 최악이다.</p>

<h4 id="backup">Backup</h4>

<p>대부분의 <em>application</em> 에서 <em>backup</em> 하길 원치 않는다. 서론에 언급했듯이 스트림처럼 취급하고싶은데, <em>brute force</em> 에서는 <em>backup</em> 이 필요하기 때문에 <em>last <code>M</code> characters</em> 의 버퍼를 유지한다거나의 방법을 쓸 수 있다.</p>

<p>아래의 구현은 똑같은 비교 회수를 가지는데, <em>backup</em> 한다는걸 확실히 보여준다.</p>

<ul>
<li><code>i</code> points to end of sequence of already-matched chars in docs</li>
<li><code>j</code> stores # of already-matched chars (end of sequence in pattern)</li>
</ul>

<pre><code class="java">public static int bruteForceBackup(String pattern, String docs) {  
    int i, N = docs.length();
    int j, M = pattern.length();

    for (i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++) 
        if (docs.charAt(i + j) == pattern.charAt(j)) j++;
        else { i -= j; j = 0; }

    if (j == M) return i - M;
    else return N;
}
</code></pre>

<p>이게 <code>M</code> 이 작으면 문제가 안되는데, <code>M</code> 이 크면 문제가 될 수 있다.</p>

<p>우리가 풀어야 할 문제는</p>

<p>(1) <em>linear-tme guarantee</em> 가 필요 <br />
(2) <em>backup</em> 하지 않기</p>

<h3 id="knuthmorrispratt">Knuth-Morris-Pratt</h3>

<p>아이디어는 간단하다. 매칭에 실패했을 경우, 현재까지 처리한 문자들에 대한 <em>정보</em> 를 가지고 있기 때문에, 이걸 이용해서 필요 없는 부분을 건너 뛴다.</p>

<pre><code>// pattern: BAAAAAAAAA

A B A A A A B A A A A A A A A A  
  B A A A A ^ // fail
            B // ignore previous chars
</code></pre>

<h4 id="dfa">DFA</h4>

<p><em>Knuth-Morris-Pratt</em> 알고리즘은 <em>deterministic finite state automation, DFA</em> 란 것에 이론적으로 기반한다.</p>

<p><em>DFA</em> 는 <em>abstract string-searching machine</em> 이다.</p>

<ul>
<li>Finite number of states (including start and halt)</li>
<li><strong>Exactly one transition</strong> for each char in alphabet</li>
<li>Accept if sequence of transitions leads to half state</li>
</ul>

<p><img src='http://www-igm.univ-mlv.fr/' ~lecroq/string/images/rwadfa2.png" alt="" /></p>

<p align="center">(<a href='http://www-igm.univ-mlv.fr/' >http://www-igm.univ-mlv.fr</a>)</p>

<p>더 크게 보면 <em>DFA</em> 는 <em>Finite State Machine, FSM</em> 의 한 종류다. <em>DFA</em> 말고도 <em>Nondeterministic Finite Automata, NFA</em> 가 있는데,  차이점은 이렇다.</p>

<blockquote>
  <p>비결정적 유한 오토마타는 결정적 유한 오토마타와는 다르게 입력 기호에 대해서 <code>\epsilon</code>-transition 에 의해 0개 이상의 이동이 가능하다. 만약 가능한 다음 상태의 경우가 없다면, 기계는 입력을 거부한다.</p>
</blockquote>

<p>결정적 유한 오토마타는 입력값에 대해 출력 값이 1개라는 소리 같은데, 좀 모호해서 더 찾아봤다. <a href='http://math.stackexchange.com/questions/563829/difference-between-nfa-and-dfa' >여기</a> 에 의하면</p>

<blockquote>
  <p>Each input to a <strong>DFA</strong> or <strong>NFA</strong> affects the state of the automaton: if it was in state q immediately before the input, either it will be in some state q′ after the input, or the input will cause it to choke. (Note that q′ may be the same as q.) Suppose that we have an automaton in a state q. The difference in behavior between a DFA and an NFA is this:</p>
  
  <ul>
  <li><p>If it’s a <strong>DFA</strong>, each possible input determines the resulting state q′ uniquely. Every input causes a state change, and the new state is completely determined by the input. Moreover, the automaton can change state only after reading an input.</p></li>
  <li><p>If it’s an <strong>NFA</strong>, some inputs may allow a choice of resulting states, and some may cause the automaton to choke, because there is no new state corresponding to that input. Moreover, the automaton may be constructed so that it can change state to some new state q′ without reading any input at all.</p></li>
  </ul>
  
  <p>As a consequence of this difference in behavior, DFA’s and NFA’s differ in another very important respect.</p>
  
  <ul>
  <li><p>If you start a <strong>DFA</strong> in its initial state and input some word w, the state q in which the DFA ends up is completely determined by w: inputting w to the DFA will always cause it to end up in state q. This is what is meant by calling it deterministic.</p></li>
  <li><p>If you start an <strong>NFA</strong> in its initial state and input some word w, there may be several possible states in which it can end up, since some of the inputs along the way may have allowed a choice of state changes. Consequently, you can’t predict from w alone in exactly which state the automaton will finish; this is what is meant by calling it nondeterministic. (And it’s actually a little worse than I’ve indicated, since an NFA is also allowed to have more than one initial state.)</p></li>
  </ul>
  
  <p>Finally, these differences affect how we determine what words are accepted (or recognized) by an automaton.</p>
  
  <ul>
  <li><p>If it’s a <strong>DFA</strong>, we know that each word completely determines the final state of the automaton, and we say that the word is accepted if that state is an acceptor state.</p></li>
  <li><p>If it’s an <strong>NFA</strong>, there might be several possible final states that could result from reading a given word; as long as at least one of them is an acceptor state, we say that the automaton accepts the word.</p></li>
  </ul>
</blockquote>

<p><del>갓 아메리카</del></p>

<p>똑같은 입력에 대해 <em>NFA</em> 는 다양한 최종상태를 만들 수 있다고 한다. 그래서 그 중 하나라도 <em>accept</em> 되면, 처리 된 것으로 받아들인다고 함. 어디서 주워들은 <em>NP hardness</em> 와 비스무리한 개념인것 같다. 그림을 다시 보면</p>

<p><img src='http://www-igm.univ-mlv.fr/' ~lecroq/string/images/rwadfa2.png" alt="" /></p>

<p align="center">(<a href='http://www-igm.univ-mlv.fr/' >http://www-igm.univ-mlv.fr</a>)</p>

<p>검색하려는 패턴, 즉 <em>desired state</em> 나열하고 <em>transition</em> 를 그려가며 <em>DFA</em> 를 만든다. 이를 이용해 텍스트를 파싱하면서 <em>final state</em> 에 도달하는지 보면 된다.    </p>

<p>구현은 </p>

<pre><code class="java">public int kmpStringSearch(String docs, String pattern) {  
  int i, j;
  int N = docs.length(), M = pattern.length();
  Int[][] dfa = createDFA(pattern);

  for (i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++) {
    j = dfa[txt.charAt(i)][j];
  }

  if (j == M) return i - M 
  else N
}
</code></pre>

<p>재밌는 사실은 <em>backup</em> 이 더이상 필요 없기 때문에 입력을 <em>stream</em> 으로 받을 수도 있다.</p>

<pre><code>public int kmpStringSearch(In in, String pattern) {  
  int i, j;
  int M = pattern.length();
  Int[][] dfa = createDFA(pattern);

  for (i = 0, j = 0; !in.isEmpty() &amp;&amp; j &lt; M; i++) {
    j = dfa[in.readChar()][j];
  }

  if (j == M) return i - M 
  else N
}
</code></pre>

<p>따라서 <em>running time</em> 은 <em>DFA</em> 만 있다면 확실히 <code>N</code> 번의 <em>char access</em> 다. 그럼 이제 문제는, <em>DFA</em> 를 만드는데 얼마나 시간이 걸릴것 인가? </p>

<p><em>DFA</em> 를 만들면서 알아보자. <code>ABABAC</code> 의 패턴이 있을때</p>

<p>(1) <em>match transition</em></p>

<p>현재 상태가 <code>j</code> 이고 다음 문자인 <code>c</code> 가 <code>c == pattern.charAt(j)</code> 이면 <em>match transition</em> 이므로 <code>j++</code> 이다.</p>

<p>따라서 패턴 <code>ABABAC</code> 의 <em>DFA</em> 는</p>

<pre><code>               j     0 1 2 3 4 5 
pattern.charAt(j)    A B A B A C

dfa[][j]          A  1   3   5  
                  B    2   4  
                  C            6                  
</code></pre>

<p>(2) <em>mismatch transition</em></p>

<p>상태 <code>j</code> 에서 <code>c != pattern.chatAt(j)</code> 이면, <em>mismatch</em> 다. 그러면  방금 전까지 만든 <code>j-1</code> 까지의 <em>DFA</em> 를 이용해서 <code>pattern[1 .. j-1]</code> 까지를 인풋으로 넣어 돌리면 된다. 무슨말인고 하니</p>

<p><code>ABABAC</code> 에서 현재 <em>state</em> 가 <code>5</code> 면, 다음 인풋으로 <code>C</code> 를 받아야한다. <code>ABABA^C</code> 이렇게 표기하자. 그러면, <code>ABABA</code> 까지의 <em>DFA</em> 를 만들었으므로, 첫 문자 <code>A</code> 를 버리고 다음 문자 <code>C</code> 를 포함해서 <code>BABAC</code> 를 인풋으로 해서 <em>DFA</em> 를 돌리면 된다.</p>

<p>예를 들어 <code>j = 5</code>, <code>c = A, B</code> 에 대해 <code>j = 4</code> 까지의 <em>DFA</em> 를 짓고</p>

<pre><code>               j     0 1 2 3 4 5 
pattern.charAt(j)    A B A B A C

dfa[][j]          A  1 1 3 1 5  
                  B  0 2 0 4 0
                  C  0 0 0 0 0 6                  
</code></pre>

<p>에 대해서 <code>BABA</code> 를 반복하면, <code>j = 3</code> 이다. 따라서</p>

<ul>
<li><code>dfa['A'][5] = dfa['A'][3] = 1</code></li>
<li><code>dfa['B'][5] = dfa['B'][3] = 4</code></li>
</ul>

<p>이게 잘 보면 매번 <code>j - 1</code> 의 스텝을 반복해야하는 걸로 보일 수 있는데, 그러지 말고 <code>pattern[1 .. j-1]</code> 을 <em>state</em> <code>X</code> 라 부르고, 이걸 유지하면 <em>transition</em> 을 <em>constant time</em> 으로 지을 수 있다. 즉 <code>j</code> 가 하나 증가할 때 마다 </p>

<p><code>X = dfa[pattern.charAt(j)][X]</code></p>

<p>이렇게 <code>X</code> 를 업데이트하면, <code>j - 1</code> 까지의 상태가 <code>X</code> 다. 따라서 <em>DFA</em> 를 <em>linear time</em> 으로 만들 수 있다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTT3lJR08zSUdOalZUTm1WV0x6UVRPaDFDTmhkek10RXpZeFFXTGpWR1p3a1RZekkyTDRnek0wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<h4 id="performance">Performance</h4>

<p><em>DFA</em> 를 만드는 속도는 <code>M</code> <em>char access</em> 이므로 전체 문서를 검색하는데 걸리는 시간은 <code>M + N</code> <em>char access</em> 다. (<code>M</code> 은 패턴의 길이, <code>N</code> 은 문서의 길이)</p>

<p>그러나 <em>DFA</em> 를 만드는데 필요한 메모리가 <code>R * M</code> 이다.</p>

<p><em>NFA</em> 를 이용하면 <em>KMP</em> 알고리즘을 더 개선할 수 있다. <code>M</code> 에 비례하는 시간, 공간만으로도 패턴을 문서에서 탐색할 수 있다고 한다. <a href='http://algs4.cs.princeton.edu/53substring/KMPplus.java.html' >KMPplus.java</a></p>

<h4 id="kmpimplementation">KMP Implementation</h4>

<p>구현하면</p>

<pre><code class="java">public class DFA {

    int[][] dfa;

    public DFA(String pattern, int R) {
        int M = pattern.length();

        // initialize
        dfa = new int[R][];
        for (int r = 0; r &lt; R; r++)
            dfa[r] = new int[M];

        dfa[pattern.charAt(0)][0] = 1;

        // build DFA
        for (int X = 0, j = 1; j &lt; M; j++) {
            // mismatch
            for (int c = 0; c &lt; R; c++)
                dfa[c][j] = dfa[c][X];

            // match
            dfa[pattern.charAt(j)][j] = j + 1;

            // update X
            X = dfa[pattern.charAt(j)][X];
        }
    }

    public int search(String docs) {

        int i, j, M = pattern.length(), N = docs.length();

        for (i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++) {
            j = dfa[docs.charAt(i)][j];
        }

        if (j == M) return i - M;
        else return N;
    }
}
</code></pre>

<h3 id="boyermoore">Boyer-Moore</h3>

<p><em>KMP</em> 알고리즘은 <em>linear time</em> 인데, 이보다 더 빠르게 할 수 있을까?</p>

<p><br/></p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTmtkVE5qaHpZaWRUWWhSVEx5STJNaDFDWmlCek10SUdaeFlUTGlGVE0yRVdPakp6TDRJRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>패턴의 우측부터 매칭해 가면, 꽤나 많은 <code>M</code> 사이즈의 텍스트를 빠르게 제낄 수 있다. 문제는 패턴이 어디까지 매칭되었는지에 따라 스킵할 수 있는 문자가 다르다는 것이다. 경우를 좀 나눠서 살펴보자 <code>i</code> 는 현재 문서의 탐색할 인덱스를, <code>^</code> 는 <em>mismatch</em> 를 나타낸다.</p>

<pre><code class="java">// case 1

          i     ^
. . . . . . . . T L E . . . . 
          N E E D L E

                  i
. . . . . . . . T L E . . . . 
                  N E E D L E
</code></pre>

<p><em>case 1</em> 은 운이 좋아서, 미스매치 <code>T</code> 가 패턴에 없기 때문에 <code>T</code> 다음으로 <code>i</code> 를 옮길 수 있다.</p>

<pre><code class="java">// case 2a

          i     ^
. . . . . . . . N L E . . . . 
          N E E D L E

                i 
. . . . . . . . N L E . . . . 
                N E E D L E
</code></pre>

<p>여기선 <em>mismatch</em> 문자 <code>N</code> 이 패턴에 있기 때문에 <em>rightmost</em> <code>N</code> 을 찾아 다시 비교를 시작한다. (우측부터 비교하기 때문)</p>

<pre><code class="java">// case 2b

          i     ^
. . . . . . . . E L E . . . . 
          N E E D L E

// rightmost 'E'          

      i          
. . . . . . . . E L E . . . . 
      N E E D L E


// just increament `i` by 1

                i         
. . . . . . . . E L E . . . . 
            N E E D L E
</code></pre>

<p>이 경우엔 <em>rightmost</em> <code>E</code> 가 별로 도움이 안되므로, 그냥 <code>i</code> 를 증가시킨다.</p>

<p>다시 한번 정리하면, </p>

<p>(1) 우측부터 시작해서 비교하다 <em>mismatch</em> 문자가 있을 때 필요 없는 문자를 몇개나 제낄 수 있느냐 하는 문제는, 패턴 안에서 해당 <em>mismatch</em> 문자가 있느냐 없느냐에 따라 다르다.</p>

<p>(2) 없다면 모두 제껴버리면 되는거고, </p>

<p>(3) 있다면 그 문자가 얼마나 우측에 오느냐에 따라 스킵할 수 있는 문자의 수가 달라진다. 우측에 오면 올 수록 거기서 부터 다시 비교해야 하기 때문에, <em>heuristic</em> 이 별로 도움이 안될 수도 있다. <em>case 2b</em> 가 바로 그 예다. 그럴때는 그냥 1 만큼 증가시키는것이 더 나을 수도 있다. </p>

<p><em>skip table</em> 을 만들면</p>

<pre><code class="java">int M = pattern.length();  
int[] right = new int[R];

for (i = 0; i &lt; R; i++) right[i] = -1;  
for (j = 0; j &lt; M; j++) right[pattern.charAt(j)] = j;  
</code></pre>

<p>이 테이블을 이용해 탐색을 하면</p>

<pre><code class="java">int N = docs.length();  
int M = pattern.length();

for (int i = 0; i &lt;= N - M; i++) {  
  int skip = 0;

  for (int j = M - 1; j &gt;=0; j--) {
    if (docs.charAt(i + j) != pattern.charAt(j)) {
      skip = Math.max(1, j - right[docs.charAt(i + j)]);
      break;
    }
  }

  if (skip == 0) return i;
}

return N;  
</code></pre>

<p>이 알고리즘에서 <code>skip</code> 을 계산하는 부분을 잘 보면</p>

<pre><code class="java">skip = Math.max(1, j - right[docs.charAt(i + j)]);  
</code></pre>

<p>현재 비교가 진행된 <code>j</code> 에서 <em>mismatch</em> 문자의 인덱스를 뺄셈해서 1 보다 큰지를 비교한다. 만약 1 보다 작다면, 다시 말해 <code>0</code> 이나 음수라면 <code>skip</code> 이 마이너스로, 즉 왼쪽으로 되기 때문에 스킵할 필요가 없다. 그냥 우측으로 <code>+1</code> 해서 다시 비교하면 된다.</p>

<p>전체 코드는</p>

<pre><code class="java">public class BoyerMoore {

    int[] right;
    String pattern;

    public BoyerMoore(String pattern, int R) {

        this.pattern = pattern;
        int M = pattern.length();

        // initialize skip table
        right = new int[R];
        for (int i = 0; i &lt; R; i++) right[i] = -1;
        for (int j = 0; j &lt; M; j++) right[pattern.charAt(j)] = j;
    }

    public int search(String docs) {

        int M = pattern.length();
        int N = docs.length();

        for (int i = 0; i &lt;= N - M; i++) {
            int skip = 0;

            for (int j = M - 1; j &gt;=0; j--) {
                if (pattern.charAt(j) != docs.charAt(i + j)) {
                    // calculate skip value
                    skip = Math.max(1, j - right[docs.charAt(i + j)]);
                    break;
                }
            }

            if (skip == 0) return i;
        }

        return N;
    }
}
</code></pre>

<p>이건 <em>bad character</em> 라는 특성을 이용한 방법이고, <em>good suffix</em> 등을 과 비교하여 얼마나 더 스킵할지를 결정할 수 있다. </p>

<p>보이어 무어 알고리즘에 대한 설명은 <a href='http://xenostudy.tistory.com/72' >여기</a>가 제일 잘 되어있다. </p>

<h4 id="performance">Performance</h4>

<p>일반적으로는(휴리스틱) <code>~N/M</code> 의 <em>char compare</em> 비교를 한다고 알려져있다. <em>sublinear</em> 한건데, </p>

<p><em>worst case</em> 에서는 <code>~ MN</code> 이다. 예를 들어 패턴이 <code>ABBBB</code> 고 문서가 <code>BBBBBBBBBBBBBBBBB..</code> 일때 최악이다.</p>

<p><em>worst case</em> 를 <code>~3N</code> 까지 개선할 수 있다. <em>KMP-like rule</em> 을 더해 반복적인 패턴을 비하면 된다.</p>

<p>실제로 보이어 무어 알고리즘은 검색할 문자열이 길때 효과가 있다. 그래야 스킵할것이 많기 때문이다. 그러나 대부분의 경우 검색어가 그다지 길지 않다는 것.</p>

<h3 id="rabinkarp">Rabin-Karp</h3>

<p><img src='http://terpconnect.umd.edu/' ~sthomas2/images/rabinkarp.jpg" alt="" /></p>

<p align="center">(<a href='http://terpconnect.umd.edu/' >http://terpconnect.umd.edu</a>)</p>

<p>기본 아이디어는 <em>modular hashing</em> 이다. 인덱스를 하나씩 증가시켜가면서 문자열의 해싱 값을 비교한다.</p>

<p>먼저 해야할 일은 <em>hash function</em> 을 만드는 건데, <code>t_i</code> 를 문서(<code>txt</code>) 의 <code>i</code> 번째 캐릭터라 하면</p>

<p><img src='http://chart.apis.google.com/chart?cht=tx&amp;chl=x_t%20%3D%20t_i%20R%5E%7BM-1%7D%5C%20%20%2B%5C%20%20t_%7Bi%2B1%7D%20R%5E%7BM-2%7D%5C%20%20%2B%5C%20%20%5Ccdots%20%5C%20%5C%20%20%2B%5C%20%20%20t_%7Bi%2BM-1%7D%20R%5E%7B0%7D%5C%20%5C%20%20' (mod)%5C%20%5C%20%20Q" alt="" /></p>

<p>여기서 <code>M</code>-<em>digit</em>, <code>R</code>-<em>base</em>, <code>Q</code> modulo 다. <code>M</code>-<em>degree</em> 다항식인데, <em>Horner's method</em> 를 쓰면 중복된 계산 없이 <em>linear time</em> 으로 <em>evaluation</em> 가능하다. </p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWjBnak1rUkRPeUVqWWpSVEwwRW1NaDFpWjVVek10WVROME1UTDNjVFl4SUdaemt6TDNjRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com/</a>)</p>

<p>난 첨에 뭔소린가 했는데 다항식의 값을 구할 때 중복된 계산을 피하기 위해 이렇게 구현하는걸 말한다.</p>

<p><img src='http://web-ext.u-aizu.ac.jp/course/alg1/ex/uk/ex04/horner2.png'  alt="" /></p>

<p><code>R</code> 에 대한 다항식이기 때문에, 해싱함수의 구현은</p>

<pre><code class="java">private long hash(String key, int M, int Q) {  
  long h = 0;

  for(int j = 0; j &lt; M; j++)
    h = (R * h + key.charAt(j)) % Q;

  return h;
}
</code></pre>

<p><code>x_i</code> 의 해싱값을 계산하고, 매칭이 안되면 다음으로 넘어가 <code>x_(i+1)</code> 을 계산해야 한다. 그런데, 좀 더 효율적으로 할 수 있는 방법이 없을까? 당연히 가능하다. 두 해싱값 서로 다른 1개의 항 빼고는 모두 같은 항을 가지고 있기 때문이다. </p>

<p><img src='http://chart.apis.google.com/chart?cht=tx&amp;chl=x_i%5C%20%20%3D%5C%20t_iR%5E%7BM-1%7D%5C%20%2B%5C%20t_%7Bi%2B1%7DR%5E%7BM-2%7D%5C%20%2B%5C%20%5Ccdots%5C%20%2B%5C%20t_%7Bi%20%2B%20M%20-%201%7DR%5E0%5C%5C%0A%5C%20%5C%5C%20%0A%5C%20%5C%5C%0A%5C%20%5C%5C%0A%5C%20%5C%5C%0A%5C%20%5C%5C%0Ax_i%5C%20%20%3D%5C%20t_%7Bi%20%2B%201%7DR%5E%7BM-1%7D%5C%20%2B%5C%20t_%7Bi%2B1%7DR%5E%7BM-2%7D%5C%20%2B%5C%20%5Ccdots%5C%20%2B%5C%20t_%7Bi%20%2B%20M%7DR%5E0'  alt="" /></p>

<p>따라서 <code>x_(i+1)</code> 은</p>

<p><img src='http://chart.apis.google.com/chart?cht=tx&amp;chl=x_%7Bi%2B1%7D%5C%20%20%3D%5C%20%20' (x_i%5C%20%20%5C%20-%20t_iR%5E%7BM-1%7D)%5C%20%20*%5C%20%20R%5C%20%2B%5C%20%20t_%7Bi%2BM%7D%20" alt="" /></p>

<p>이므로, 상수 시간 내에 다음 문자열의 해시값을 구할 수 있다. 따라서 매 <code>i</code> 마다 상수 시간이므로 <code>~N</code> 으로 패턴을 찾을 수 있다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTmhKR00yWVROaEpHT2psVEwzTW1ONTBpWndjek10Z1RNbGxUTHpNR054WVdPM1l6TDVjRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com/</a>)</p>

<h4 id="implementation">Implementation</h4>

<p>전체 코드는 <a href='http://algs4.cs.princeton.edu/53substring/RabinKarp.java.html' >RabinKarp.java</a> 로</p>

<pre><code class="java">public class RabinKarp {

    String pattern;
    long patternHash;
    int M;
    long Q;
    int R;
    long RM; // R^(M-1) % Q

    public RabinKarp(String pattern) {
        this.pattern = pattern;

        R = 25;
        M = pattern.length();
        Q = longRandomPrime();

        // pre-compute R^(M-1) % Q for use in removing leading digit
        RM = 1;
        for (int i = 1; i &lt;= M-1; i++)
            RM = (RM * R) % Q;

        patternHash = hash(pattern, M);
    }

    private long hash(String key, int M) {
        long h = 0;

        for (int j = 0; j &lt; M; j++)
            h = (R * h + key.charAt(j)) % Q; 
        return h;
    }

    private static long longRandomPrime() {
        BigInteger prime = BigInteger.probablePrime(31, new Random());
        return prime.longValue();
    }

    public int search(String docs) {
        int N = docs.length();
        long docsHash = hash(docs, M);

        if (docsHash == patternHash) return 0;

        for (int i = M; i &lt; N; i++) {
            // remove leading digit
            docsHash = (docsHash + Q - RM * docs.charAt(i-M) % Q) % Q;
            // add trailing digit
            docsHash = (docsHash * R + docs.charAt(i)) % Q;

            // match
            if (patternHash == docsHash) return i - M + 1;
        }

        return N;
    }
}
</code></pre>

<p>참고로, 해시값을 비교하는 것에는 두 가지 버전이 있다.</p>

<p>(1) <strong>Monte Carlo version:</strong> return match if hash match <br />
(2) <strong>Las Vegas version:</strong> check for substring match if hash match and continue search if false collision.</p>

<p>몬테 카를로는 확률적으로 여러번 구해서 맞는 값을 찾는거다. 근데 만약에 <code>Q</code> 가 <code>MN^2</code> 정도로 상당히 크다면, 충돌이 일어날 확률은 <code>1/N</code> 이다.</p>

<p>실제 돌려보면 <code>Q</code> 를 충분히 크게 고르되, 오버플로우가 안 일어나면 <code>1/Q</code> 의 적은 확률로 충돌이 일어난다.</p>

<p>따라서</p>

<p>(1) <strong>Monte Carlo version</strong></p>

<ul>
<li>Always runs in linear time</li>
<li>Extremely likely to return correct answer (but not always)</li>
</ul>

<p>(2) <strong>Las Vegas version</strong></p>

<ul>
<li>Always returns correct answer</li>
<li>Extremely likely to run in linear time (but worst case is <code>M N</code>)</li>
</ul>

<p>라스베가스 버전에서 <em>worst case</em> 는, 충돌이 매번 나고 매번 검사하는건데. 그럴 일은 거의 없다.</p>

<h4 id="prosandcons">Pros and cons</h4>

<p><em>rabin-karp</em> 알고리즘은 앞서 보았던 <em>KMP</em> 나 <em>boyed moore</em> 에 비해 장점이 있는데</p>

<ul>
<li>Extends to 2d patterns</li>
<li>Extends to finding multiple patterns</li>
</ul>

<p>예를 들어서 다양한 패턴을 찾고싶다 하면, 그 패턴들의 심볼 테이블을 만들어 놓고 검색하면 된다.</p>

<p>단점으로는</p>

<ul>
<li>Arithmetic ops slower than char compares</li>
<li>라스베가스 버전은 백업을 필요로 함</li>
<li>poor worst case guarantee</li>
</ul>

<h3 id="summary">Summary</h3>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWTVNMlkxWVdOMUVXTXdJV0w0TWpZaDF5TjJrek10WTJZM0lXTDRjek5pSldabFIyTDBrRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Ro$bert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='http://math.stackexchange.com/questions/563829/difference-between-nfa-and-dfa' >Difference between NFA and DFA</a> <br />
(4) <a href='http://www-igm.univ-mlv.fr/' ~lecroq/string/node4.html">Automaton</a> <br />
(5) <a href='http://somemoreacademic.blogspot.kr/2012/09/boyer-moore-string-matching-algorithm.html' >Boyer Moore string matching algorithm</a> <br />
(6) <a href='http://xenostudy.tistory.com/72' >보이어 무어 알고리즘에 대한 고찰</a> <br />
(7) <a href='http://terpconnect.umd.edu/' ~sthomas2/rabin-karp.html">Rabin-Karp Algorithm</a></p>]]></description><link>http://1ambda.github.io/substring-search/</link><guid isPermaLink="false">2c08e92e-2241-4624-988e-32d552ed67e1</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[substring search]]></category><category><![CDATA[boyer-moore]]></category><category><![CDATA[rabin-karp]]></category><category><![CDATA[knuth-morris-pratt]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 17 Dec 2014 15:16:42 GMT</pubDate></item><item><title><![CDATA[Reactive Programming 1, Monads]]></title><description><![CDATA[<h3 id="whatisreactiveprogramming">What is Reactive Programming?</h3>

<p><em>reactive</em> 란 뜻은</p>

<ul>
<li><em>React to events</em> <strong>(event-driven)</strong></li>
<li><em>React to load</em> <strong>(scalable)</strong></li>
<li><em>React to failures</em> <strong>(resilient)</strong></li>
<li><em>React to users</em> <strong>(responsive)</strong></li>
</ul>

<h4 id="eventdriven">Event-driven</h4>

<p><em>event-driven</em> 을 통해 <em>scalable, resilient</em> 해질 수 있고, 이 3가지를 통해 <em>responsive</em> 한 서비스를 만들 수 있다.</p>

<p>옛날에는 시스템이 <em>multi-threaded</em> 로 구성되어 <em>shared, synchronized state</em> 를 통해 커뮤니케이션 했었다. 그래서</p>

<blockquote>
  <p>Strong coupling, hard to compose</p>
</blockquote>

<p>근데 요즘 시스템은 <em>loosely coupled even handlers</em> 로 구성되기 때문에</p>

<blockquote>
  <p>Events can be handled asynchoronously, without blokcing</p>
</blockquote>

<h4 id="scalable">Scalable</h4>

<blockquote>
  <p>An application is <strong>scalable</strong> if it is able to be expanded according ot its usage</p>
</blockquote>

<ul>
<li><strong>scale up:</strong> make use of parallelism in multi-core systems</li>
<li><strong>scale out:</strong> make use of multiple server nodes</li>
</ul>

<blockquote>
  <p><strong>Important for scalability:</strong> minimize shared mutable state</p>
  
  <p><strong>Important for scale out:</strong> location transparency, resilience</p>
</blockquote>

<h4 id="resilient">Resilient</h4>

<blockquote>
  <p>An application is <strong>resilient</strong> if it can recover quickly from failures</p>
</blockquote>

<p>일반적으로 <em>resilience</em> 는 나중에 (<em>afterthought</em>) 추가하기 어렵다. 시작부터 디자인의 일부로 고려해야한다. 이를 위해</p>

<ul>
<li>loose coupling</li>
<li>strong ecapsulation of state</li>
<li>pervasive supervisor hierarchies</li>
</ul>

<h4 id="responsive">Responsive</h4>

<blockquote>
  <p>An application is <strong>responsive</strong> if it provides rich, real-time interaction with its users even under load and in the presence of failures.</p>
  
  <p>Responsive applications can be built on an event-driven, scalable, and resilient architecture</p>
  
  <p>Still need careful attention to algorithms, system design, back-pressure, and many other details.</p>
</blockquote>

<h4 id="callback">Callback</h4>

<p>보통 이벤트를 다루기 위해 <em>callback</em> 이 사용되는데 자바를 예로 들면</p>

<pre><code class="scala">class Counter extends ActionListener {  
  private var count = 0
  button.addActinoListener(this)

  def actionPerformed(e: ActionEvent): Unit = {
    count += 1
  }
}
</code></pre>

<p>여기서 볼 수 있는 문제는 </p>

<p>(1) <em>shared mutable state</em> 가 필요하다 <br />
(2) <em>composing</em> 하기 힘들다 <br />
(3) 시스템이 커지면 <em>callback hell</em> 이 될 수 있다</p>

<h4 id="composableeventabstraction">Composable Event Abstraction</h4>

<p>일반적으로 함수형 프로그래밍에서 이를 해결하기 위한 방법은 <em>composable event abstraction</em> 이다.</p>

<ul>
<li>Events are first class</li>
<li>Events are often represented as messages</li>
<li>Handlers of events are also first-class</li>
<li>Complex handlers can be composed from primitive ones</li>
</ul>

<p>이 수업에서 다룰 내용은 <em>monad</em>, <em>future</em>, <em>observables</em>, <em>actor</em>, <em>supervisor</em>, <em>distributed actor</em> 등이다.</p>

<h4 id="functionpatternmaching">Function, Pattern Maching</h4>

<p>잠깐 복습하고 가면 <em>JSON</em> 을 모델링 하기 위해서</p>

<pre><code class="scala">abstract class JSON  
case class JSeq (elems: List[JSON])           extends JSON  
case class JObj (bindings: Map[String, JSON]) extends JSON  
case class JNum (num: Double)                 extends JSON  
case class JStr (str: String)                 extends JSON  
case class JBool (b: Boolean)                 extends JSON  
case class JNull                              extends JSON  
</code></pre>

<p>그러면 요로코롬 데이터를 표현할 수 있다.</p>

<pre><code class="scala">  val data = JObj(Map(
    "firstName"   -&gt; JStr("Jason"),
    "lastName"    -&gt; JStr("Bone"),
    "phoneNumber" -&gt; JSeq(List(
      JObj(Map(
        "type" -&gt; JStr("home"), "number" -&gt; JStr("212 555 3347"),
        "type" -&gt; JStr("fax"),  "number" -&gt; JStr("33312 555 3347")
      ))
    ))
  ))
</code></pre>

<p>자바스크립트에서 이거랑 똑같다. 좀 스칼라 버전이 복잡해 보이는데, 오더스키 말로는 더 문법적으로 간편하도록 작성할 수 있다고 한다. 아마 어디 라이브러리에 구현되어있을듯</p>

<pre><code class="javascript">data = {  
  "firstName": "Json",
  "lastName": "Bone",
  "phoneNumber": [
    { "type: "home", "number", "212 555 3347" },
    { "type: "fax",  "number", "33312 555 3347" }
  ]
}
</code></pre>

<p>이제 <code>JSON</code> 을 출력하는 <code>show</code> 함수를 만들어 보면</p>

<pre><code class="scala">  def show(json: JSON): String = json match {
    case JSeq(elems) =&gt; "[" + (elems map show mkString ", ") + "]"
    case JObj(bindings) =&gt;
      val assocs = bindings map {
        case (key, value) =&gt; "\"" + key + "\":" + show(value)
      }
      "{" + (assocs mkString ", ") + "}"

    case JNum(num) =&gt; num.toString
    case JStr(str) =&gt; "\"" + str + "\""
    case JBool(b) =&gt; b.toString
    case JNull() =&gt; "null"
  }
</code></pre>

<p><em>case class</em> 가 나와서 잠깐 보면 다음 타입은 무엇일까?</p>

<pre><code class="scala">{ case (key, value) =&gt; ...  }
</code></pre>

<p>이것 자체로는 아무 타입이 아닌데, 타입을 지정해 주면 <em>function</em> 이 될 수 있다. 무슨말인고 하니</p>

<pre><code class="scala">type JBinding = (String, JSON)  
val f = { case (key, value) =&gt; ...  } // error  
val f: JBinding =&gt; String = { case (key, value) =&gt; ...  }  
</code></pre>

<p>두 번째 <code>val</code> 만 성공적으로 컴파일된다. 그리고 스칼라에서 모든 구체적인 타입은 <em>class</em> 나 <em>trait</em> 의 구현체인데 <em>function</em> 도 마찬가지다.</p>

<p><code>JBinding =&gt; String</code> 은 <code>scala.Function1[JBinding, String]</code> 이다. 다시 말해서 모든 함수는 <code>Function</code> <em>trait</em> 의 구현이다.</p>

<pre><code class="scala">trait Function[-A, +R] {  
  def apply(x: A): R
}
</code></pre>

<p>여기서 <code>-A</code>, <code>+R</code> 등은 <em>variance</em> 와 관련된 것인데, 이 <em>variance</em> 란 것이 어떤 두 타입사이에 관계가 있다면, 컨테이너에 넣었을때의 관계는 어떠한가를 기술하는 것이다. </p>

<ul>
<li><code>S &lt;: T</code> means <strong>S is a subtype of T</strong></li>
<li><code>S :&gt; T</code> means <strong>S is a supertype of T</strong></li>
</ul>

<p>이걸 <em>bound</em> 라 부른다. 따라서 <em>mixed bound</em> 도 있다. <code>S &gt;: NonEmpty &lt;: IntSet]</code> 이라던지.</p>

<p><code>A &lt;: B</code>, 즉 <em>lower bound</em> 가 있고, 컨테이너 <code>C</code> 가 있을때</p>

<ul>
<li><code>C[A] &lt;: C[B]</code> means <strong>C is covariant</strong>, <code>C[+A]</code></li>
<li><code>C[A] &gt;: C[B]</code> means <strong>C is contravariant</strong>, <code>C[-A]</code></li>
<li>상관 없으면 <strong>C is non-variant</strong>, <code>C[A]</code></li>
</ul>

<p>위에서 봤듯이 함수의 파라미터는 <em>contravariant</em>, 리턴타입은 <em>covariant</em> 인데 이는 파라미터를 나중에 함수 호출할 수 있기 때문이다.</p>

<p>더 자세한 내용은 <a href='http://1ambda.github.io/functional-programming-in-scala-chapter-4/' >Functional Programming in Scala Chapter4</a> 를 참조하자.</p>

<p>함수는 <em>trait</em> 의 구현이고, <code>Map</code> 은 <code>Function1</code> 의 서브클래스다. 따라서 맵을 사용할때 <code>exampleMap(key)</code> 처럼 사용할 수 있다.</p>

<p><code>Seq</code> 도 마찬가지로 서브클래스다. 그래서 <code>Vector(3)</code> 처럼 사용할 수 있다.</p>

<h4 id="collection">Collection</h4>

<p>컬렉션도 잠깐 복습해 보자.</p>

<p><img src='http://librairie.immateriel.fr/baw/9780596155957/httpatomoreillycomsourceoreillyimages322250.png'  alt="" /></p>

<p align="center">(<a href='http://librairie.immateriel.fr/' >http://librairie.immateriel.fr</a>)</p>

<p><img src='http://i.stack.imgur.com/2fjoA.png'  alt="" /></p>

<p align="center">(<a href='http://stackoverflow.com/' >http://stackoverflow.com</a>)</p>

<p><em>filter, map</em> 과 같은 메소드들은 다양한 컬렉션을 지원하지만, <em>list</em> 에서는 <em>tail recursive</em> 하게 정의되어 있다고 한다.</p>

<h3 id="forexpression">For Expression</h3>

<p>스칼라에서 <code>for</code> 구문은 <code>map, flatMap</code> 그리고 <em>lazy variant</em> <code>filter</code> 로 번역된다.</p>

<p>(1) <code>for (x &lt;- e1) yield e2</code> 는</p>

<p><code>e1.map(x =&gt; e2)</code> 다.</p>

<p>(2) <code>for (x &lt;- e1 if f; s) yield e2</code> 는</p>

<p>여기서 <code>f</code> 는 <em>filter</em> 고 <code>s</code> 는 <em>sequence of generators and filters</em> 다. 따라서</p>

<p><code>for (x &lt;- e1.withFilter(x =&gt; f); s) yield e2</code> 로 번역된다. 외울 필요는 없고 <code>for</code> 루프를 쓸 때 <code>withFilter</code> 때문에 메모리 낭비가 적다는 사실 정도만 알고 있으면 된다.</p>

<blockquote>
  <p>You can think of <code>withFilter</code> as a variant of <code>filter</code> that doesn't produce an intermediate list, but instead filters the following <code>map</code> or <code>flatMap</code> function application</p>
</blockquote>

<p>(3) <code>for (x &lt;- e1; y &lt;- e2; s) yield e3</code> 는</p>

<p><code>e1.flatMap(x =&gt; for (y &lt;- e2; s) yield e3)</code> 로 번역된다.</p>

<p>(4) <code>for</code> 구문에서 <em>generator</em> 의 <em>left-hand side</em> 가 패턴일 수 있다. 무슨말인고 하니</p>

<pre><code class="scala">val data: List[JSON] = ...

for {  
  JObj(bindings) &lt;- data
  JSeq(phones) &lt;- bindings("phoneNumber")
  JObj(phone) &lt;- phones
  JStr(digits) = phone("number")
  if digits startWith "212"
} yield (bindings("firstName"), bindings("lastName"))
</code></pre>

<p><code>pattern &lt;- expr</code> 은 이렇게 번역된다.</p>

<pre><code class="scala">x &lt;- expr withFilter {  
        case pattern =&gt; true
        case _ =&gt; false
     } map {
       case pattern =&gt; x
     }
</code></pre>

<h3 id="functionalrandomgenerators">Functional Random Generators</h3>

<p><code>for</code> 구문은 <em>collection</em> 에만 쓸 수 있지 않다. <code>map, flatMap, withFilter</code> 만 구현 된다면 다른 곳으로의 응용도 가능하다. (LINQ 도 그 예라고 본것 같음)</p>

<p><em>random value generator</em> 가 하나의 예제인데, 뭔지 살펴보자.</p>

<pre><code class="scala">  trait Generator[+T] {
    def generate: T
  }

  val integers = new Generator[Int] {
    val rand = new java.util.Random
    def generate = rand.nextInt()
  }

  val booleans = new Generator[Boolean] {
    def generate = integers.generate &gt; 0
  }

  val pairs = new Generator[(Int, Int)] {
    def generate = (integers.generate, integers.generate)
  }
</code></pre>

<p>말 그대로 랜덤한 값들을 타입별로 생성해주는거다. 근데, 매번 해야하는 <em>boilerplate</em> 땜에 귀찮타. 더 좋은 방법은 없을까? 예를 들어 이렇게 쓸 수 있다면,</p>

<pre><code class="scala">val booleans = for (x &lt;- integers) yield x &gt; 0

def pairs[T, U](t: Generator[T], u: Generator[U]) = for {  
  x &lt;- t
  y &lt;- u
} yield (x, y)
</code></pre>

<p><del>존나</del> 쿨하다! 근데 이게 스칼라에서 이렇게 번역되기 때문에</p>

<pre><code class="scala">val booleans = integers map (x =&gt; x &gt; 0)

def pairs[T, U](t: Generator[T], u: Generator[U]) =  
  t flatMap(x =&gt; u map (y =&gt; (x, y)))
</code></pre>

<p><em>generator</em> 을 위한 <code>map</code>, <code>flatMap</code> 을 만들어야 한다. 이 함수들이  새로운 타입을 위한 <code>Generator</code> 를 돌려주면 된다. <del>모나드 느낌이 솔솔 난다</del></p>

<pre><code class="scala">trait Generator[+T] {  
  self =&gt; // an alias for "this"
  def generate: T

  def map[S](f: T =&gt; S): Generator[S] = new Generator[S] {
    def generate = f(self.generate)
  }

  def flatMap[S](f: T =&gt; Generator[S]): Generator[S] = 
    new Generator[S] {
      def generate = f(self.generate).generate
    }
}
</code></pre>

<p>여기서 <code>self</code> 가 필요한 이유는 <code>map</code> 함수 내부에서 <code>this</code> 컨텍스트를 사용할 수 없기 때문이다. <code>map</code> 의 <code>this</code> 로 해석되어 무한루프에 빠진다.</p>

<p>이렇게 <code>Generator</code> 를 위한 <code>map, flatMap</code> 을 만들면 <code>booleans</code> 가 이렇게 번역된다.</p>

<pre><code class="scala">val booleans = for (x &lt;- integers) yield x &gt; 0

val booleans = integers map { x =&gt; x &gt; 0 }

val booleans = new Generator[Booelan] {  
  def generate = (x =&gt; x &gt; 0)(integers.generate)
}

val booleans = new Generator[Booelan] {  
  def generate = integers.generate &gt; 0
}
</code></pre>

<pre><code class="scala">def pairs[T, U](t: Generator[T], u: Generator[U]) = t flatMap {  
  x =&gt; u map { y =&gt; (x, y) }
}

...
...
...

def pairs[T, U](t: Generator[T], u: Generator[U]) =  
  new Generator[(T, U)] {
    def generate = (t.generate, u.generate)
  }
</code></pre>

<p>여기 몇개 더 유용한 <em>generator</em> 를 좀 살펴보면</p>

<pre><code class="scala">  def single[T](x: T): Generator[T] = new Generator[T] {
    def generator = x
  }

  def choose(l: Int, h: Int): Generator[Int] =
    for (x &lt;- integers) yield l + x % (h - l)

  def oneOf[T](xs: T*): Generator[T] =
    for (i &lt;- choose(0, xs.length)) yield xs(i)
</code></pre>

<p>재밌는 사실은 <em>Generator</em> 가 <em>building block</em> 이 된다는 사실이다. <em>Generator</em> 를 조합해 <em>Generator</em> 를 만들고.</p>

<p>처음에 <em>reactive programming</em> 에 관해서 잠깐 이야기 하면서 <em>compose</em> 란 단어가 나왔는데, 이게 바로 <em>composing</em> 의 강력함이다.</p>

<h4 id="listgenerator">List Generator</h4>

<pre><code class="scala">  def lists: Generator[List[Int]] = for {
    isEmpty &lt;- booleans
    list &lt;- if (isEmpty) emptyLists else nonEmptyLists
  } yield list

  def emptyLists = single(Nil)

  def nonEmptyLists = for {
    head &lt;- integers
    tail &lt;- lists
  } yield head :: tail
</code></pre>

<h4 id="treegenerator">Tree Generator</h4>

<pre><code class="scala">  // tree generator
  trait Tree
  case class Leaf(x: Int)                   extends Tree
  case class Inner(left: Tree, right: Tree) extends Tree

  def leafs: Generator[Leaf] = for {
    x &lt;- integers
  } yield Leaf(x)

  def inners: Generator[Inner] = for {
    l &lt;- trees
    r &lt;- trees
  } yield Inner(l, r)

  def trees: Generator[Tree] = for {
    isLeaf &lt;- booleans
    tree &lt;- if (isLeaf) leafs else inners
  } yield tree
</code></pre>

<p>코드를 보면, 좀 뭔가 감이 올테다. 바로 <code>map</code>, <code>flatMap</code> 을 <code>Geneartor</code> 에 대해서 정의했기 때문에 <code>for</code> 내부에서 <code>Generator</code> 에서 <code>T</code> 타입을 빼올 수 있다. 그리고 <code>yield</code> 를 이용해 만드는 것 또한 <code>Generator</code> 가 된다. </p>

<p><del>오더스키 교수는 진짜 천재같다. 모나드를 이렇게 설명하다니. 예전 강의 들을때도 정말 쉽게 설명한다는 느낌을 많이 받았는데</del></p>

<h4 id="applicationrandomtesting">Application: Random Testing</h4>

<p>유닛테스팅을 할때 <em>input</em> 에 대해서 <em>expected output</em> 과 비교해 테스팅을 진행하는데, <em>input</em> 을 직접 만들지 않고 테스팅이 가능할까?</p>

<blockquote>
  <p>Yes, By generating random test inputs</p>
</blockquote>

<pre><code class="scala">def randomTest[T](g: Generator[T], times: Int = 100)(f: T =&gt; Boolean): Unit = {  
  for (i &lt;- 0 until times) {
    val value = g.generate
    assert(f(value), "test failed for" + value)
  }
  println("passed " + times + "tests")
}
</code></pre>

<p>이런 테스팅을 한다면, </p>

<pre><code class="scala">randomTest(pairs(lists, lits)) {  
  case (xs, ys) =&gt; (xs ++ ys).length &gt; xs.length
}
</code></pre>

<p>실패할 것이다. 둘다 <code>Nil</code> 이면 실패한다.</p>

<p>우리는 <em>test</em> 를 작성할 필요가 없고, 항상 참이어야 하는 <em>properties</em> 만 작성하면 된다. 그게 <a href='http://www.scalacheck.org/' ><em>ScalaCheck</em></a> 도구의 기본 아이디어다.</p>

<p><em>ScalaCheck</em> 튜토리얼을 보면 </p>

<pre><code class="scala">import org.scalacheck.Properties  
import org.scalacheck.Prop.forAll

object StringSpecification extends Properties("String") {

  property("startsWith") = forAll { (a: String, b: String) =&gt;
    (a+b).startsWith(a)
  }

  property("concatenate") = forAll { (a: String, b: String) =&gt;
    (a+b).length &gt; a.length &amp;&amp; (a+b).length &gt; b.length
  }

  property("substring") = forAll { (a: String, b: String, c: String) =&gt;
    (a+b+c).substring(a.length, a.length+b.length) == b
  }
}
</code></pre>

<p>하스켈의 <a href='https://www.haskell.org/haskellwiki/Introduction_to_QuickCheck1' ><em>QuickCheck</em></a> 가 먼저 구현되었다고 한다.</p>

<pre><code class="haskell">*A&gt; quickCheck ((\s -&gt; (reverse.reverse) s == s) :: [Char] -&gt; Bool)
</code></pre>

<h3 id="monads">Monads</h3>

<p><del>올것이 왔다</del></p>

<blockquote>
  <p>Data structures with <code>map</code> and <code>flatMap</code> seem to be quite common.</p>
  
  <p>In fact there's a name that describe this class of a data structure together with some algebraic laws that they hould have</p>
  
  <p>They are called <strong>monads</strong></p>
</blockquote>

<p>모나드는 <code>M[T]</code> 타입으로 표시하는데, 다음의 함수들을 구현해야 한다. 하스켈에서 <code>&gt;&gt;=, return</code> 과 동일하다.</p>

<pre><code class="scala">trait M[T] {  
  // `&gt;&gt;=` called bind
  def flatMap[U](f: T =&gt; M[U]): M[U]
}

// return
def unit[T](x: T): M[T]  
</code></pre>

<p>이미 우리가 모르는 사이에 썼던 모나드를 보면</p>

<ul>
<li><code>List</code> is a monad with <code>unit(x) = List(x)</code></li>
<li><code>Set</code> is a monad with <code>unit(x) = Set(x)</code></li>
<li><code>Option</code> is a monad with <code>unit(x) = Some(x)</code></li>
<li><code>Generator</code> is a monad with <code>unit(x) = single(x)</code></li>
</ul>

<p><code>flatMap</code> 은 이들 타입에 두루 쓰일 수 있는 반면 스칼라에서 <code>unit</code> 은 각 모나드 마다 다르다. </p>

<p>그리고 <code>map</code> 은 모나드에서 <code>flatMap</code> 과 <code>unit</code> 을 조합해 만들 수 있다.</p>

<pre><code class="scala">m map f

== m flatMap (x =&gt; unit(f(x)))
== m flatMap (f andThen unit) // composing functions
</code></pre>

<p>즉 <code>f</code> 를 받아 적용하고, <code>unit</code> 으로 모나드로 감싼뒤 <code>flatMap</code> 을 이용해 <em>flattening</em> 하면 <code>map</code> 의 결과가 나온다.</p>

<h4 id="monadlaws">Monad Laws</h4>

<ul>
<li><em>associativity</em></li>
</ul>

<pre><code class="scala">m flatMap f flatMap g == m flatMap (x =&gt; f(x) flatMap g)  
</code></pre>

<ul>
<li><em>left unit</em></li>
</ul>

<pre><code class="scala">unit(x) flatMap f == f(x)  
</code></pre>

<ul>
<li><em>right unit</em></li>
</ul>

<pre><code class="scala">m flatMap unit = m  
</code></pre>

<p><a href='http://en.wikibooks.org/wiki/Haskell/Understanding_monads' #Monad_Laws">하스켈 문법</a>으로 보면</p>

<pre><code class="haskell">(m &gt;&gt;= f) &gt;&gt;= g  =  m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)  -- associativity

return x &gt;&gt;= f   =  f x                      -- left unit

m &gt;&gt;= return     =  m                        -- right unit  
</code></pre>

<p><em>associativity</em> 와 관련해서, <em>monoid</em> 란 것도 있는데 이건 <em>bind</em> 가 없는 모나드라 생각하면 쉽다. 예를 들어 <em>integer</em> 는 모노이드다</p>

<pre><code>(x + y) + z = x + (y + z)
</code></pre>

<p><em>monad laws</em> 를 확인하기 위해 <code>Option</code> 을 좀 보자.</p>

<pre><code class="scala">abstract class Option[+T] {  
  def flatMap[U](f: T =&gt; Option[U]): Option[U] = this match {
    case Some(x) =&gt; f(x)
    case None =&gt; None
  }
}
</code></pre>

<p><em>left unit</em> 을 보이려면 <code>return x &gt;&gt;&gt; f   =   f x</code>, 즉</p>

<pre><code class="scala">Some(x) flatMap f == f(x)

// ==
Some(x) match {  
  case Some(x) =&gt; f(x)
  case None =&gt; None
}

// == 
f(x)  
</code></pre>

<p><em>right unit</em> 을 보이려면 <code>m &gt;&gt; return     =    m</code> 임을 보이면 된다.</p>

<pre><code class="scala">opt flatMap Some // == opt

// == 
opt match {  
  case Some(x) =&gt; Some(x)
  case None =&gt; None
}
</code></pre>

<p><em>associative law</em> 를 보이려면 </p>

<pre><code class="haskell">(m &gt;&gt;= f) &gt;&gt;= g     =     m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)
</code></pre>

<p>따라서 스칼라에선</p>

<pre><code class="scala">opt flatMap f flatMap g  
// == opt flatMap (x =&gt; f(x) flatMap g)

opt flatMap f flatMap g

// ==
opt match { case Some(x) =&gt; f(x) case None =&gt; None }  
    match { case Some(y) =&gt; g(y) case None =&gt; None }

// ==
opt match {  
  case Some(x) =&gt;
    f(x) match { case Some(y) =&gt; g(y) case None =&gt; None }
  case None =&gt;
    None match { case Some(y) =&gt; g(y) case None =&gt; None }
}

// ==
opt match {  
  case Some(x) =&gt; f(x) match {
    case Some(y) =&gt; g(y) case None =&gt; None
  }
  case None =&gt; None
}

// ==
opt match{  
  case Some(x) =&gt; f(x) flatMap g
  case None =&gt; None
}

// ==
opt flatMap (x =&gt; f(x) flatMap g)  
</code></pre>

<p>결국 <code>Option</code> 은 모나드다. 근데 이런 <em>monad laws</em> 를 지키면 얻는게 뭘까? </p>

<p><em>associativity</em> 가 지켜지면, 중첩된 <em>for-loop</em> 를 <em>inline</em> 할 수 있다.</p>

<pre><code class="scala">for (y &lt;- for (x &lt;- m; y &lt;- f(x)) yield y  
     z &lt;- g(y)) yield z

// ==
for (x &lt;- m;  
     y &lt;- f(x)
     z &lt;- g(y)) yield z
</code></pre>

<p><em>right unit</em> 은 </p>

<pre><code class="scala">for (x &lt;- m) yield x

== m
</code></pre>

<p>애석하게도 <em>left unit</em> 은 마땅한 <em>for-loop</em> 가 없다.</p>

<blockquote>
  <p>Left unit does not have an analogue for <em>for-expression</em></p>
</blockquote>

<h3 id="anothertypetry">Another type: Try</h3>

<p>강의 후반부에서 <code>Try</code> 라는 타입을 다룰건데, 이 타입은 <code>Option</code> 과 비슷하다. 서브타입이 <code>Success, Failure</code> 로 <em>exception</em> 이 발생할 경우와 아닐 경우를 처리하는데 쓸 수 있다.</p>

<pre><code class="scala">abstract class Try[+T]  
case class Success[T](x: T)         extends Try[T]  
case class Failure[T](e: Exception) extends Try[Nothing]  
</code></pre>

<p>이 <code>Try</code> 를 예외가 발생할 수 있는 <em>computation (연산)</em> 을 <em>thread, computer</em> 간 넘겨주는데 사용할 수 있다. 참고로 스칼라에서 <code>Nothing</code> 은 <em>bottom type</em> 이다.</p>

<p>이 <code>Try</code> 를 이용해 <em>computation</em> 을 감쌀 수 있다. <code>Try(expr)</code> 처럼</p>

<pre><code class="scala">object Try {  
  def apply[T](expr: =&gt; T): Try[T] =
    try Success(expr)
    catch {
      case NonFatal(e) =&gt; Failure(e)
    }
}
</code></pre>

<p>여기서 <code>=&gt; T</code> 로 <code>expr</code> 를 <em>by name</em> 으로 받는 이유는 연산을 나중에 하기 위해서다.</p>

<p><code>Try</code> 를 <em>for-loop</em> 에 활용하면</p>

<pre><code class="scala">for {  
  x &lt;- computeX
  y &lt;- computeY
} yield f(x, y)
</code></pre>

<p>이 구문이 하는 일은, <code>computeX</code>, <code>computeY</code> 가 모두 성공할 경우에만 <code>Success(f(x, y))</code> 를 돌려준다. 둘 중 하나라도 실패하면 <code>Failure(e)</code> 를 반환할 것이다.</p>

<p><code>Try</code> 를 위한 <code>map</code>, <code>flatMap</code> 은</p>

<pre><code class="scala">abstract class Try[T] {  
  def flatMap[U](f: T =&gt; Try[U]): Try[U] = this match {
    case Success(x) = try f(x) 
                      catch { case NonFatal(e) =&gt; Failure(ex)
    case fail: Failure =&gt; fail
  }

  def flatMap[U](f: T =&gt; U): Try[U] = this match {
    case Success(x) =&gt; Try(f(x))
    case fail: Failure =&gt; fail
  }
}


// t map f
// == t flatMap (f andThen Try)
</code></pre>

<p><code>Try</code> 를 모나드라 생각해 보자. <em>monad law</em> 중 실패하는 것이 있을까? 다시 한번 보면</p>

<pre><code class="haskell">return x &gt;&gt;= f     =    f x    -- left unit  
m &gt;&gt;= return       =    m      -- right unit  
-- associativity
(m &gt;&gt;= f) &gt;&gt;= g    =    m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g) 
</code></pre>

<p>아까 <em>for-expression</em> 에 사용했으니 <em>right unit, associativity</em> 는 맞을 거고 <em>left unit</em> 을 살펴보자.</p>

<pre><code class="scala">// return x &gt;&gt;= f     =    f x
Try(x) flatmap f

// ==
this match {  
  Success(x) =&gt; try f(x) 
                catch { case NonFatal(e) =&gt; Failure(ex)
  case fail: Failure =&gt; fail
}
</code></pre>

<p>보면 알겠지만, 예외가 발생하지 않을 경우에만 <em>left unit</em> 이 성립한다.</p>

<pre><code class="scala">Try(expr) flatMap f != f(expr)  
</code></pre>

<p>좌변은 예외를 그냥 던지지않고, 감싸서 준다. 반면 우측은 예외를 던질 수 있다. 즉 예외를 던지지 않는 <em>law</em> 를 얻기 위해 <em>left unit</em> 을 희생했다고 보면 된다.</p>

<blockquote>
  <p>An expression composed from <code>Try</code>, <code>map</code>, <code>flatMap</code> will never throw a non-fatal exception</p>
</blockquote>

<p>이거 <em>bullet-proof principle</em> 이라 부른다.</p>

<h3 id="summary">Summary</h3>

<p>이제까지 <em>collection</em> 뿐만 아니라 다양한 타입에 대해 <em>for-expression</em> 을 쓸 수 있음을 배웠다. <code>map</code>, <code>flatMap</code>, <code>withFilter</code> 등을 구현하면 된다.</p>

<p><code>flatMap</code> 을 구현한 많은 타입이 <em>monad</em> 다. 만약에 <code>withFilter</code> 를 구현하면 <em>monad with zero</em> 라 부른다.</p>

<p>모나드 법칙은 <em>API</em> 를 구현할때 가이드라인이 되지만, <code>Try</code> 의 예에서 봤듯이 모나드 법칙을 버려서 다른 이득을 얻을 수도 있다. <del>만만한 left unit</del></p>

<h3 id="references">References</h3>

<p>(1) <a href='http://stackoverflow.com/questions/1722137/scala-2-8-collections-design-tutoria$l' >Scala 2.8 Collection</a> <br />
(2) <a href='http://en.wikibooks.org/wiki/Haskell/Understanding_monads' #Monad_Laws">Haskell Wiki: Monad</a>  </p>]]></description><link>http://1ambda.github.io/reactive-programming-1/</link><guid isPermaLink="false">c49814fa-24c5-4f5f-83c4-d1a196a8b687</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[variance]]></category><category><![CDATA[monad]]></category><category><![CDATA[reactive programming]]></category><category><![CDATA[generator]]></category><category><![CDATA[scala check]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 17 Dec 2014 07:30:37 GMT</pubDate></item><item><title><![CDATA[Process Mining, Week4]]></title><description><![CDATA[<h3 id="twophaseprocessdiscoverylimitations">Two-Phase Process Discovery, Limitations</h3>

<p>지난시간에 두 단계를 거치는 프로세스 마이닝 알고리즘을 봤었다.</p>

<p>하나는 <em>heuristic mining</em> 으로 <em>dependency graph</em> 를 만들고, 이것을 <em>C-nets</em> 으로 변환했었다.</p>

<p>다른 하나는 <em>transition system</em> 을 학습하는 것으로 먼저 <em>state abstraction</em> 을 이용해 <em>transition system</em> 을 만들고 여기에 숨어있는 <em>state-based region</em> 을 이용해 <em>Petri-nets</em> 을 만들었다.</p>

<p>그런데, <em>state-based region</em> 접근 방법에는 문제점이 있다.</p>

<p>(1) Inability to discover particular <strong>process construct</strong>s <br />
(2) Inability to balance the four forces (<em>fitness</em>, <em>precision</em>, <em>generalization</em>, simplicity)</p>

<p>예를 하나 보자. <code>&lt;a, a&gt;^55</code> 란 로그가 있을때 만들어지는 트랜지션 시스템으로 <code>s1 -&gt; s2 -&gt; s3</code> 가 있다. 여기엔 몇개의 <em>non-trivial region</em> 이 있을까?</p>

<p>없다. <em>empty set</em>, <code>{s1, s2, s3}</code> 가 있는데, <em>trivial region</em> 이므로</p>

<p>따라서 이걸 이용해 <em>petri-net</em> 을 만들면 <em>place</em> 가 없는 <em>petri-net</em> 이 만들어 지고, <code>&lt;a, a, a&gt;</code> 등의 로그를 허용하므로 에러가 있다.</p>

<p><code>&lt;a, c&gt;, &lt;a, b, c&gt;, &lt;a, b, b, c&gt; ...</code> 의 로그를 훈련시켜 만든 트랜지션 시스템은 대략 이런 모양이다</p>

<p><code>s1 -&gt; s2 &gt; s3</code> (<code>s2</code> 는 자기 자신으로의 액션 <code>b</code> 가 있음) </p>

<p>이 때 여기에는 <em>non-trivial region</em> 이 3개가 생기는데, 이걸 이용해 <em>petri-net</em> 을 만들면 <code>b</code> 만 붕 떠 있어, <code>b</code> 가 가운데 실행되지 않고 먼저나, 나중에 실행되는 <em>petri-net</em> 이 만들어 진다. <em>underfit</em> 이다.</p>

<blockquote>
  <p>Petri net can simulate the behavior of the transition system, but not the other way around (no bisimulation)</p>
</blockquote>

<p>첫 번째 문제같은 경우는 <em>forward closure</em> 속성을 검사해서, 문제가 발견되면 <em>label</em> 을 <em>spliting</em> 하는걸로 해결할 수 있다. (이미지를 첨부하고 싶은데 찾을 수가 없다.) 두 번째 문제도 같은 방법으로 해결할 수 있다. <em>ProM</em> 에는 <em>bisimulation</em> 을 위한 플러그인이 있다.</p>

<p>이제 특정 프로세스 패턴을 발견하지 못하는 문제를 해결했다. 이제 문제 (2) 를 해결해 보자.</p>

<blockquote>
  <p>(2) Inability to balance the four forces (<em>fitness</em>, <em>precision</em>, <em>generalization</em>, simplicity)</p>
</blockquote>

<p>먼저 <em>step 1</em> 에서 트랜지션 시스템을 학습할때는 <em>fitness, generalization</em>, <em>precision</em>, <em>simplicity</em> 의 <em>trade-off</em> 를 봐가면서 해야한다.</p>

<p><em>step 2</em> 에서는 <em>region</em> 을 이용해서 <em>concurrency</em> 를 발견하는데 사실 잘 생각해 보면 <em>Petri-nets</em> 은 트랜지션시스템에서의 변환이므로 이 단계에서는 <em>simplicity</em> 나 <em>generalization</em> 의 개선 여지가 없다. 트랜지션 시스템이 이미 복잡한데 어떻게 페트리넷을 간단하게 할까? 마찬가지로 트랜지션 시스템이 이미 <em>overfit</em> 되어있는데, 어떻게 이 문제를 풀까? 이 두 가지 문제를 해결하려면 (1) 로 돌아가야 한다.</p>

<p>정리하자면 <em>Region-based techniques</em> 은 </p>

<ul>
<li><strong>Overfitting</strong> may be a problem</li>
<li>Inability to leave out <strong>infrequent</strong> behavior (but can be done in the transtion system)</li>
<li><strong>Noise</strong> and <strong>incompleteness</strong> connot be handled well</li>
</ul>

<h3 id="alternativeprocessdiscoverytechniques">Alternative Process Discovery Techniques</h3>

<p>이전까지는 모델의 퍼포먼스를 기준으로 삼았지만 사실 </p>

<ul>
<li>speed</li>
<li>memory usage</li>
<li>representational bias</li>
<li>flexibility(related problems),</li>
<li>implementation vs apporach</li>
</ul>

<p>등을 고려해야 한다. </p>

<p><em>petri net</em> 에서 무엇을 해야 <em>behavior</em> 를 추가할 수 있을까? <em>place</em> 는 일종의 <em>constraint</em> 라 보면 된다. 그리고 <em>place</em> 에 토큰이 많아지면 다 더 다양한 로그가 생길 수 있다.</p>

<ul>
<li>Add a transition</li>
<li>Remove a place</li>
<li>Add an arc from a transition to a place</li>
<li>Remove an arc from a place to a transtion</li>
</ul>

<p>반대로 <em>behavior</em> 를 제거하려면</p>

<ul>
<li>Remove a transition</li>
<li>Add a place</li>
<li>Add an arc from a place to transition</li>
<li>Remove an arc from a transition to a place</li>
</ul>

<p><em>process discovery</em> 가 <em>finding place</em> 라는 점을 고려하면 <em>alpha algorithm</em> 에서는 <em>constraint</em> 인 <em>place</em> 를 발견하는 과정이었다. <em>state-based region</em> 에서는 먼저 <em>transition</em> 을 만들고, 이걸 <em>place</em> 로 변환했었다.</p>

<p>이번엔 <em>language-based region</em> 이란 기법을 배워보자.</p>

<h3 id="languagebasedregion">Language-based Region</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-36-728.jpg?cb=1305062477'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-37-728.jpg?cb=1305062477'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-38-728.jpg?cb=1305062477'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-40-728.jpg?cb=1305062477'  alt="" /></p>

<p><br/></p>

<p><code>c * 1 + A' * x - A * y &gt;= 0</code> 등의 식으로 표현되는데, 이 말은 <em>place</em> 가 음수가 될 수 없다는 뜻이라 보면 된다. <del>이제 나도 뭔소린지 모르겠다 너무멀리 와버렸음 ㅠㅠ</del></p>

<p><img src='http://latex.codecogs.com/gif.latex?c%20' *%201%20&plus;%20A%27%20x%20-%20Ay%20%5Cgeq%200" alt="" /></p>

<p>여기서 <code>A', A</code> 는 <em>log</em>, <code>x, y</code> 는 <em>petri-nets</em>, <code>c</code> 는 초기에 <em>place</em> 내에 있는 토큰의 수다. 이 때 위 방정식을 만족하는 <code>x, y, c</code> 가 <em>region</em> 이다. </p>

<ul>
<li><code>c</code> is the initial number of tokens in the place</li>
</ul>

<p>예를 들어</p>

<p><code>&lt;a&gt;, &lt;b&gt;, &lt;a, b&gt;, &lt;b, a&gt;</code> 인 로그가 있다고 하자. 그러면 진리표처럼 로그 내에 <code>a, b</code> 쌍을 <code>0, 1</code> 로 표현할 수 있다. 이걸 <code>A</code> 라 하면</p>

<p><img src='http://latex.codecogs.com/gif.latex?A%20%3D%20%5Cbegin%7Bpmatrix%7D%201%20%26%200%5C%5C%200%20%26%201%5C%5C%201%20%26%201%5C%5C%201%20%26%201%20%5Cend%7Bpmatrix%7D'  alt="" /></p>

<p>그리고 <code>A'</code> 를 만들기 위해 마지막 <em>trace</em> 는 무시하도록 하자. 그러면 다음 식을 만들 수 있다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?c%20' *%20%5Cbegin%7Bpmatrix%7D%201%5C%5C%201%5C%5C%201%5C%5C%201%20%5Cend%7Bpmatrix%7D%20&plus;%20%5Cbegin%7Bpmatrix%7D%200%20%26%200%5C%5C%200%20%26%200%5C%5C%201%20%26%200%5C%5C%200%20%26%201%20%5Cend%7Bpmatrix%7D%20*%20%5Cbegin%7Bpmatrix%7D%20x_a%5C%5C%20x_b%20%5Cend%7Bpmatrix%7D%20-%20%5Cbegin%7Bpmatrix%7D%201%20%26%200%5C%5C%200%20%26%201%5C%5C%201%20%26%201%5C%5C%201%20%26%201%20%5Cend%7Bpmatrix%7D%20*%20%5Cbegin%7Bpmatrix%7D%20y_a%5C%5C%20b_b%20%5Cend%7Bpmatrix%7D%20%5Cgeq%20%5Cbegin%7Bpmatrix%7D%200%5C%5C%200%5C%5C%200%5C%5C%200%20%5Cend%7Bpmatrix%7D" alt="" /></p>

<ul>
<li><code>x_a</code> is the number of arcs from transition <code>a</code> to the place</li>
<li><code>x_b</code> is the number of arcs from transition <code>b</code> to the place</li>
<li><code>y_a</code> is the number of arcs from the place to transtion <code>a</code></li>
<li><code>y_b</code> is the number of arcs from the place to transtion <code>b</code></li>
</ul>

<p>식을 풀면</p>

<p><img src='http://latex.codecogs.com/gif.latex?%5C%20%5C%5C%20c%20-%20y_a%20%5Cgeq%200%20%5C%5C%20c%20-%20y_b%20%5Cgeq%200%20%5C%5C%20c%20&plus;%20x_a%20-%20y_a%20-%20y_b%20%5Cgeq%200%20%5C%5C%20c%20&plus;%20x_b%20-%20y_a%20-%20y_b%20%5Cgeq%200%20%5C%5C'  alt="" /></p>

<p>하나의 답으로 </p>

<ul>
<li><code>c=1, x_a=0, x_b=0, y_a=1, y_b=0</code></li>
<li><code>c=1, x_a=0, x_b=0, y_a=0, y_b=1</code></li>
</ul>

<p><em>language-based region</em> 에서는</p>

<ul>
<li>any solution is a feasible place</li>
<li>additional constraints can be added easily</li>
<li><strong>goal function</strong> can be used to select most interesting places</li>
<li>optimiazation problem (e.g ILP)</li>
</ul>

<h3 id="geneticprocessmining">Genetic Process Mining</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-22-728.jpg?cb=1305062477'  alt="" /></p>

<p>이번엔 <em>genetic process mining</em> 기법을 살펴보자.</p>

<p><em>event log</em> 로 부터 <em>initial population</em> 을 만들고, 이것에 대해 <em>conformance checking</em> 등을 이용해 얼마나 좋은 모델인가 본다. 이것을 다시 매 턴마다 랜덤하게 변이시키면서 계속 반복하는 것이다.</p>

<p>많은 <em>generation</em>, <em>mutation</em> 이 있을 수 있기 때문에 굉장히 느리지만 <em>very flexible</em> 할 수 있다. 왜냐하면 <em>qualty measure</em> 을 이용해서 4 품질(fitness 등) 을 조절할 수 있기 때문이다.</p>

<h3 id="inductiveprocessmining">Inductive Process Mining</h3>

<p>로그를 <em>trace</em> 를 기준으로 쪼개는 방법인데</p>

<pre><code>abdef  
acdef  
abdeg  
adceg  
</code></pre>

<p>가 있을때, <code>abcd</code>, <code>efg</code> 기준으로 쪼개면</p>

<pre><code>abd  
acd  
abd  
adc

ef  
ef  
eg  
eg  
</code></pre>

<p>로 분리할 수 있다. 여기서 <code>abcd</code> 부분을 또 쪼개면 <code>a</code> <code>seq</code> <code>bcd</code> 로 쪼갤 수 있다. 마찬가지로 뒷부분도 <code>e</code> <code>seq</code> <code>fg</code> 로 쪼갤 수 있다. 뒷부분의 경우 <code>f xor g</code> 로 다시 쪼갤 수 있고. 이렇게 반복하면서 쪼개는 방법이다. 이 결과로 만들어지는 것이 <em>process tree</em> 다. 이를 <em>petri-net</em> 이나 <em>BPMN</em> 으로 변경할 수 있다. </p>

<p><em>ProM</em> 에도 플러그인이 있다고 함.</p>

<h3 id="introtoconformancechecking">Intro to Conformance Checking</h3>

<p><img src='http://www.win.tue.nl/' ~mpechen/projects/edm/images/framework.jpg" alt="" /></p>

<p align="center">(<a href='http://www.win.tue.nl/' >http://www.win.tue.nl</a>)</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-4-728.jpg?cb=1305062420'  alt="" />
<br/></p>

<p>다른 품질도 중요하긴 한데, <em>replay fitness</em> 가 주된 관심사라고 한다. <em>conformance checking</em> 의 주된 용도는</p>

<ul>
<li>Auditing and compliance</li>
<li>Evaluating process discovery algorithm</li>
<li>Conformance to specification (software, service)</li>
</ul>

<p><em>conformance checking</em> 은 <em>runtime</em> 에 할수도 있다.</p>

<h3 id="footprintsbasedconformancechecking">Footprints-based Conformance Checking</h3>

<p>알파 알고리즘을 사용할때 <em>footprints</em> 를 봤었다. 테이블에 각 <em>trace</em> 사이의 <em>direct succession, causality, parallel, choice</em> 를 표시한 것이다. </p>

<p>로그로 부터 <em>footprint</em> 가 나왔기 때문에 로그의 <em>footprint-based conformance</em> 는 항상 <code>1</code> 이다. 다시 말해서</p>

<blockquote>
  <p>footprints of log and model coincide</p>
</blockquote>

<p>그런데, 모델을 만들고 보니 다음과 같이 로그와 모델의 <em>footprint</em> 를 작성했다고 하자.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-34-728.jpg?cb=1305062420'  alt="" /></p>

<p><code>a - d, b - d</code> 부분이 다르다. 따라서 다른 부분을 파악해서 값으로 매기면</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-35-728.jpg?cb=1305062420'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-36-728.jpg?cb=1305062420'  alt="" /></p>

<p><br/></p>

<p><em>flower model</em> 에서는 수 많은 조합이 가능하기 때문에 <em>footprint-based conformance</em> 가 떨어진다.</p>

<p><em>footprint-based conformance</em> 자체는 굉장히 유연하다. </p>

<ul>
<li><em>log to log</em></li>
<li><em>log to model</em></li>
<li><em>model to model</em></li>
</ul>

<p>모두 가능하다. 그러나</p>

<ul>
<li>frequencies are not used</li>
<li>behavior is only considered indiretcly (directly follows relation)</li>
<li>aims to capture fitness, precision and generalization in a single metric</li>
</ul>

<p>다양한 <em>metric</em> 으로 <em>fitness</em> 을 분류하고 싶을 수도 있는데, <em>footprint-based</em> 는 그러질 못한다. 이 때문에 <em>token-based conformance</em> 를 이용하기도 한다.</p>

<h3 id="tokenbasedreplay">Token-based Replay</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-12-728.jpg?cb=1305062420'  alt="" /></p>

<p><em>traces</em> 를 모델에 실제 <em>replay</em> 해 보면서 <em>missing token</em>, <em>remaining token</em> 을 기록한다.</p>

<ul>
<li><code>p</code>, <em>produced tokens</em></li>
<li><code>c</code>, <em>consumed tokens</em></li>
<li><code>m</code>, <em>missing tokens</em></li>
<li><code>r</code>, <em>remaining tokens</em></li>
</ul>

<p><img src='http://latex.codecogs.com/gif.latex?fitness%28%5Csigma%2C%20N%29%20%3D%20%5C%5C%20%5C%5C%20%7B1%20%5Cover%202%7D%20%281%20-%20%7Bm%20%5Cover%20c%7D%29%20&plus;%20%7B1%20%5Cover%202%7D%281%20-%20%7Br%20%5Cover%20p%7D%29'  alt="" /></p>

<p>그리고, 어느 <em>place</em> 에서든 <em>invariants</em> 는</p>

<p><img src='http://latex.codecogs.com/gif.latex?%5C%20%5C%5C%20p%20&plus;%20m%20%5Cgeq%20c%20%5Cgeq%20m%5C%20%5C%20%5Cmbox%7B%28at%5C%20any%5C%20time%29%7D%20%5C%5C%20r%20%3D%20p%20&plus;%20m%20-%20c%5C%20%5C%20%5Cmbox%7B%28at%5C%20the%5C%20end%29%7D'  alt="" /></p>

<p><em>replay</em> 의 시작과 끝을 생각해 보면</p>

<ul>
<li>In the beginning, a token is <strong>produced</strong> for the <em>source place</em> <code>p = 1</code></li>
<li>At the end, a token is <strong>consumed</strong> from the <em>sink place</em> (also if not there) <code>c' = c + 1</code></li>
</ul>

<p>뭔 소린가 했는데, <em>conformance checking</em> 을 위해 초기에 토큰을 하나 넣어주고, <em>replay</em> 가 끝났을 때 <em>sink place</em> 에서 <em>consume</em> 해서 <code>c</code> 값을 하나 증가시킨다는 이야기</p>

<p>왼쪽 위의 값을 주목하면서 따라가 보자.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-17-728.jpg?cb=1305062420'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-18-728.jpg?cb=1305062420'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-19-728.jpg?cb=1305062420'  alt="" /></p>

<p><br/></p>

<p>이번엔 좀 문제가 있는 <em>event log</em></p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-20-728.jpg?cb=1305062420'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-21-728.jpg?cb=1305062420'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-22-728.jpg?cb=1305062420'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-24-728.jpg?cb=1305062420'  alt="" /></p>

<p><br/></p>

<p>각 <em>log</em> 가 <em>transition</em> 에서 얼마나 실행되었는지 기록해서 모델에 어떤 문제가 있는지 파악할 수 있다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-30-728.jpg?cb=1305062420'  alt="" /></p>

<p><em>frequency</em> 는 <code>p, c, m, r</code> 에 곱해서 전체 <em>fitness</em> 값을 얻으면 된다. </p>

<p>만약 <em>consumed token</em> 이 모두 <em>missing token</em> 이고, <em>produced token</em> 이 모두 <em>remaining token</em> (미사용) 이면 <em>fitness</em> 는 <code>0</code> 이다.</p>

<h4 id="limitations">Limitations</h4>

<ul>
<li>Basic replay approache assumes <strong>visible, unique labeled</strong> transitions</li>
<li>ProM implementation uses <strong>heuristics</strong> to deal with slient transitions having same label</li>
<li>Conformance value is too optimistic due tu <strong>token flooding</strong></li>
<li>Local decision marking may misleading</li>
</ul>

<p>특히 마지막은 중요한데, 우리는 <em>value</em> 를 보고 싶은게 아니라 <em>closest path</em> 를 보고싶어 할수도 있다.</p>

<p>예를 들어 <code>&lt;a, c1, c2, c3, e1, e2, e3&gt;</code> 값이 <code>0.8</code> 로 나왔다 하면, "그럼 올바른 <em>path</em> 는 무얼까?" 하고 질문할 수 있다.</p>

<blockquote>
  <p>Replay technique does not provide corresponding path through model</p>
</blockquote>

<p>다음장에서 배울 <em>alignment</em> 를 이용하면 모델에서 가능한 <em>real path</em> 를 얻을 수 있다.</p>

<h3 id="alignmentbasedconformancechecking">Alignment-based Conformance Checking</h3>

<p>먼저 생각해 볼 거리는</p>

<blockquote>
  <p>Conformance checking <strong>should not impose restriction</strong> on the process notation e.g slient transitions and two transitions with same label should be possible</p>
  
  <p>Should provide <strong>closest maching path</strong> (required for <em>performance analysis</em>)</p>
</blockquote>

<p>특히 <em>closest maching path</em> 가 제공되면 <em>fitness</em> 를 넘어 <em>generalization</em>, <em>precision</em>, <em>bottle-neck</em> 등에 이용할 수 있다. 대략 이런 느낌이라고 보면 된다.</p>

<p><img src='http://image.slidesharecdn.com/alignmentbasedprecisionchecking-121013004859-phpapp01/95/alignment-based-precision-checking-5-728.jpg?cb=1350107718'  alt="" /></p>

<p>즉 <em>replay</em> 불가능한 로그에서 <em>replay</em> 가능한 로그와 차이점을 반영한 것이라 보면 된다. 그러면, 다음중 어떤 것이 더 <em>possible</em> 한 로그일까?</p>

<pre><code>a &gt;&gt; c1 c2 e1 e2 e3 // invalid path  
&gt;&gt; b c1 c2 e1 e2 e3 // valid path

a1 c1 c2 &gt;&gt; &gt;&gt; &gt;&gt; e1 e2 e3 // invalid  
a1 c1 c2 d1 d2 d3 &gt;&gt; &gt;&gt; &gt;&gt; // valid  
</code></pre>

<p>이건 <em>cost function</em> 에 따라 다르다. <em>standard cost function</em> 의 경우 <code>&gt;&gt;</code> (<em>move</em>) 의 수를 센다.</p>

<p>근데 몇 가지 생각해볼 거리가 있다. <code>-2</code> 와 <code>+2</code> 의 <em>cost</em> 가 있을 때 어떤 것을 택할건가 하는 문제들이다. 이 차이 때문에 루프가 있을수도 있다.    </p>

<h3 id="alignmentbasedfitness">Alignment-based Fitness</h3>

<p>1 에서 <em>optimal cost</em> / <em>worst cost</em> 를 빼면 된다. 강의에서 나오는 <em>log</em> 의 경우</p>

<pre><code>// optimal
a &gt;&gt; c1 c2 e1 e2 e3  
&gt;&gt; b c1 c2 e1 e2 e3

// worst
a1 c1 c2 e1 e2 e3 &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt;  
&gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; b1 c1 c2 d1 d2 d3
</code></pre>

<p>따라서 <code>1 - (2 / 12) = 0.83</code></p>

<p><em>alignment-based conformance checking</em> 의 장점으로는 </p>

<ul>
<li>observed behavior is directly related to modeled behavior</li>
<li>very <strong>flexible</strong> (any cost structure)</li>
<li>detailed diagnostics</li>
<li>after aligning log and model, other quality dimensions can be investigated</li>
</ul>

<p>다른 장점으로는 <em>drilling down</em> 도 있다. 즉 <em>replay</em> 되는 것과 아닌 것을 분리해서 분석할 수 있다는 뜻이다. 분리 된 것중 이상한 로그를 <em>새로운</em> 로그처럼 취급해서 다양한 기법들을 적용할 수 있다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-32-728.jpg?cb=1305062420'  alt="" /></p>

<p><br/></p>

<p>지금까지 <em>fitness</em> 만 좀 봤지만 다른 퀄리티에 대해서도 적용 가능하다. 그리고 지금까지는 <em>control flow</em> 관점으로 좀 봤는데, <em>cost, time</em> 등 다른 기준으로도 볼 수 있다. 이를 위한 기법으로 <em>data-aware alignments</em> 가 있다.</p>

<h3 id="exploringeventdata">Exploring Event Data</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-3http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-16-728.jpg?cb=13050623738-728.jpg?cb=1305062420'  alt="" /></p>

<p><del>멘탈이 터짐</del></p>

<p><em>model view</em>, <em>instance view</em>, <em>event view</em> 사이에 관계가 있다고 함.</p>

<p><br/></p>

<h4 id="dottedchart">Dotted Chart</h4>

<p>모든 이벤트를 볼 수 있는 일종의 <em>view</em> 인데 <em>dot</em> 과 <em>event</em> 사이에는 1:1 관계가 있다. 모든 <em>event</em> 에는 <em>timestamp</em> 가 있는데, 이것을 이용해 <code>X</code> 를 계산하고 다른 <em>attribute</em> 를 이용해서 <code>Y</code> 축을 잡는다. 액티비티나 리소스에 따라 다른 색을 가질 수 있다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-16-728.jpg?cb=1305062373'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-17-728.jpg?cb=1305062373'  alt="" /></p>

<p><br/></p>

<p>이게 중요한 이유가 <code>Y</code> 축과 컬러를 어떻게 하느냐에 따라 정말 다양한 <em>view</em> 를 얻을 수 있다. 그래서 강의에서 헬리콥터 뷰 라고 표현함. 심지어 <em>time</em> 을 <em>logical time</em> (step 1) 등으로 수정해서 볼 수도 있다. </p>

<p>다양한 뷰를 조절해 가면서 왜 <em>delayed</em> 되었는지, <em>decision</em> 이 없다면 이전 스텝이 무엇인지 등을 파악할 수 있다. </p>

<p><em>dotted chart</em> 를 이용하면 모델을 작업 하기 전에 <em>input</em> 만을 이용해 다양한 직관을 얻을 수 있다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://issuu.com/wmpvanderaalst/docs/procminbook?e=14081202/9829483' >Book: Process Mining</a> <br />
(2) <a href='https://d396qusza40orc.cloudfront.net/procmin/lecture_slides/22-Petri%20Nets%20%281%29.pdf' >Slide</a> <br />
(3) <strong>Process Mining: Data science in Action</strong> by Wil van der Aalst <br />
(4) <a href='http://1ambda.github.io/www.processmining.org' >www.processmining.org</a> <br />
(5) <a href='http://fluxicon.com/' >http://fluxicon.com</a> <br />
(6) <a href='http://www.win.tue.nl/' ~mpechen/projects/edm/">http://www.win.tue.nl</a> <br />
(7) <a href='http://www.slideshare.net/caise2013vlc/ramezani-taghiabadi-temporal-compliance-checking-2' >Temporal Compliance Checking</a> <br />
(9) <a href='http://www.slideshare.net/aryaadriansyah/alignment-based-precision-checking' >Alignment-based onformance Checking</a></p>]]></description><link>http://1ambda.github.io/process-mining-week4/</link><guid isPermaLink="false">c0ec136c-9e68-46bc-b21f-0cd5f8661eb9</guid><category><![CDATA[coursera]]></category><category><![CDATA[process mining]]></category><category><![CDATA[conformance checking]]></category><category><![CDATA[token-based]]></category><category><![CDATA[footprint-based]]></category><category><![CDATA[alignment-based]]></category><category><![CDATA[dotted chart]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 17 Dec 2014 00:59:53 GMT</pubDate></item><item><title><![CDATA[R-way, Ternary Search Tries]]></title><description><![CDATA[<h3 id="stringsymboltable">String Symbol Table</h3>

<p>지난 시간에 <em>symbol-table</em> 의 구현으로 <em>red-black tree, hash table</em> 의 성능을 살펴봤었다.</p>

<p><em>red black tree</em> 는 <em>search, insertion, delete</em> 에 <code>compareTo</code> 를 이용해 <code>log N</code>, <em>hash table</em> 은 <code>equals, hashCode</code> 를 이용해 <code>1</code> (under uniform hashing assumption) 의 성능을 확인했다. </p>

<p><em>red black tree</em> 의 경우에는 <em>rank</em> 같은 다른 연산도 하는것도 봤다. 그런데, 이보다 더 빠르게 만들 순 없을까?</p>

<p>가능하다. 스트링 정렬처럼, <em>entire key</em> 를 모두 검사하지 않으면 더 빠르게 만들 수 있다. 먼저 시작 전에 <em>String symbol table API</em> 를 좀 보고가면</p>

<pre><code class="java">public class StringST&lt;Value&gt; {  
  ...

  void put(String key, Value value)
  Value get(String key)
  void delete(String key)

  ...
}
</code></pre>

<h3 id="tries">Tries</h3>

<p><em>red black tree</em> 나 <em>hash table</em> 과는 다르게 한 노드에 <em>key</em> 가 아니라 <em>character</em> 를 저장한다. 아래 짤방을 보는게 이해가 더 빠를듯. 끝 초록색 노드에 붙어있는 숫자가 바로 <em>value</em> 다.</p>

<p><img src='http://t2.hhg.to/V12-d3.png'  alt="" /></p>

<p align="center">(<a href='http://t2.hhg.to/' >http://t2.hhg.to</a>)</p>

<p>이름은 re<strong>trie</strong>val 에서 왔다고 한다. <em>try</em> 랑 똑같이 발음함. 허프만 코드랑 비슷하게도 보인다.</p>

<ul>
<li>For now, store <em>char</em> in nodes (not keys)</li>
<li>Each node has <code>R</code> children, one or each possible chars</li>
<li>Store values in nodes corresponding to last chars in keys</li>
</ul>

<p><em>value</em> 는 항상 끝에만 있을 수 있는건 아니고 <code>shell</code>, <code>she</code> 둘 다 저장했을때 <code>e</code> 에도 <code>she</code> 를 위한 <em>value</em> 를     저장할 수 있다.</p>

<h4 id="trieperformance">Trie Performance</h4>

<ul>
<li>Search hit</li>
</ul>

<p><code>L</code> 개의 문자를 모두 탐색해야 한다. 그리 긴 시간은 아님.</p>

<ul>
<li>Search miss</li>
</ul>

<p>첫 번째 문자부터 탐색에 실패할 확률도 있다. 전형적인 경우는 몇 개의 문자를 탐색하다 실패하는 경우이므로 <em>sublinear</em> 한 퍼포먼스를 보여준다.</p>

<p>각 <code>leaf</code> 마다 <code>R</code> 개의 널 링크가 필요한데, 그래도 <em>sublinear</em> 라고 말할 수 있는 것이 짧은 문자열들은 <em>common prefix</em> 를 공유한다.</p>

<blockquote>
  <p>Fast search hit and evn faster search miss, but waste spaces.</p>
</blockquote>

<p><em>search miss</em> 의 성능이 <code>log_R N</code> 으로 빨라져서 좋긴 한데, <em>space</em> 가 <code>(R + 1) * N</code> 이라 좀 부담이다. (<em>search hit, insert</em> 는 해시 테이블처럼 <code>L</code>)</p>

<p>유니코드면 <em>65536-way trie</em> 를 만들어야 한다.</p>

<p>유명한 <em>job interview</em> 로 <em>efficient spell checking</em> 의 자료구조를 구현하는 것이 있는데. <em>26-way tries</em> 를 만들면 된다. <em>value</em> 는 <em>bit</em> 로</p>

<h4 id="deletioninanrwaytrie">Deletion in an R-way Trie</h4>

<p>만약 마지막 노드가 <em>all null links</em> 를 가지고 있으면 제거하면 된다. 그리고 백트래킹 하면서 <em>value</em> 를 만나기 전 까지 삭제되면 됨.</p>

<h4 id="rwaytriesimplementation">R-way Tries Implementation</h4>

<pre><code class="java">public class TrieST&lt;Value&gt; {

    private static final int R = 256; // extended ASCII
    private Node root = new Node();
    private int N;

    private static class Node {
        private Object val;
        private Node[] next = new Node[R];
    }

    public TrieST() { N = 0; }

    public int size() { return N; }

    public boolean isEmpty() { return size() == 0; }

    public Value get(String key) {
        Node x = get(root, key, 0);

        if (x == null) return null;
        return (Value) x.val;
    }

    public void delete(String key) {
        root = delete(root, key, 0);
    }

    private Node delete(Node x, String key, int d) {
        if (x == null) return null;

        if (d == key.length()) {
            if (x.val != null) N--;
            x.val = null;
        } else {
            char c = key.charAt(d);
            x.next[c] = delete(x.next[c], key, d + 1);
        }

        // remove subtrie rooted at x if it is completely empty
        if (x.val != null) return x;
        for (int c = 0; c &lt; R; c++)
            if (x.next[c] != null) return x;

        return null;
    }

    private Node get(Node x, String key, int d) {
        if (x == null) return null;
        if (d == key.length()) return x;
        char c = key.charAt(d);
        return get(x.next[c], key, d + 1);
    }

    public boolean contains(String key) {
        return get(key) != null;
    }

    public void put(String key, Value val) {
        if (val == null) delete(key);
        else root = put(root, key, val, 0);
    }

    private Node put(Node x, String key, Value val, int d) {
        if (x == null) x = new Node();
        if (d == key.length()) {
            if (x.val == null) N++;
            x.val = val;
            return x;
        }

        char c = key.charAt(d);
        x.next[c] = put(x.next[c], key, val, d + 1);
        return x;
    }
}
</code></pre>

<h3 id="ternarysearchtries">Ternary Search Tries</h3>

<p>이전의 <em>R-way</em> 는 <code>R</code> 개의 자식들을 가졌지만, <em>ternary</em> 에서는 <code>3</code> 개만 가진다. <del>이것도 교수님이 만듬</del></p>

<ul>
<li>Store chars and values in nodes (not keys)</li>
<li>Each node has 3 children; smaller, equal, larger</li>
</ul>

<p><em>binary search</em> 와 거의 유사하다. 그냥 <em>key</em> 를 <em>string</em> 로 사용하고 효율적인 검색을 위해 노드에 <em>character</em> 를 저장한다는 점만 다르고. 이 차이점을 그냥 교수님은 <em>tree</em> 가 아니라 <em>trie</em> 라 부르는 것 같다.</p>

<p>어쨌든 <em>ternary</em> 는 <em>r-way</em> 보다 <em>null link</em> 자체가 훨씬 적다. 따라서 메모리 사용량에 부담 없고, <em>hash table</em> 보다 상당히 빠른 <em>search miss</em> 를 보여준다. 구현은 <a href='http://algs4.cs.princeton.edu/52trie/TST.java.html' >여기로</a></p>

<h4 id="tstimpelementation">TST Impelementation</h4>

<pre><code class="java">public class TernaryST&lt;Value&gt; {

    private int N;
    private Node root;

    private class Node {
        private char c;
        private Value val;
        private Node left, mid, right;
    }

    public TernaryST() { N = 0; }

    public int size() { return N; }
    public boolean isEmpty() { return size() == 0; }

    public boolean contains(String key) {
        return get(key) != null;
    }

    public Value get(String key) {
        if (key == null) throw new NullPointerException();
        if (key.length() == 0) throw new IllegalArgumentException("key shouldn't be empty");

        Node x = get(root, key, 0);
        if (x == null) return null;
        return x.val;
    }

    private Node get(Node x, String key, int d) {
        if (key == null) throw new NullPointerException();
        if (key.length() == 0) throw new IllegalArgumentException("key shouldn't be empty");
        if (x == null) return null;

        char c = key.charAt(d);
        if      (c &lt; x.c)               return get(x.left, key, d);
        else if (c &gt; x.c)               return get(x.right, key, d);
        else if (d &lt; key.length() - 1)  return get(x.mid, key, d + 1);
        else                            return x;
    }

    public void put(String key, Value val) {
        if (!contains(key)) N++;
        root = put(root, key, val, 0);
    }

    private Node put(Node x, String key, Value val, int d) {
        char c = key.charAt(d);

        if (x == null) {
            x = new Node();
            x.c = c;
        }

        if      (c &lt; x.c)               x.left = put(x.left, key, val, d);
        else if (c &gt; x.c)               x.right = put(x.right, key, val, d);
        else if (d &lt; key.length() - 1)  x.mid = put(x.mid, key, val, d + 1);
        else                            x.val = val;

        return x;
    }   
}
</code></pre>

<p>항상 느끼는건데, <em>imperative</em> 언어에서의 재귀가 더 어려운 것 같다.</p>

<h4 id="tstperformance">TST Performance</h4>

<p>(1) <strong>R-way trie</strong></p>

<ul>
<li><strong>search hit:</strong> <code>L</code></li>
<li><strong>search miss:</strong> <code>log_R N</code></li>
<li><strong>insert:</strong> <code>L</code></li>
<li><strong>space:</strong> <code>(R + 1) * N</code></li>
</ul>

<p>(2) <strong>Ternary trie(TST)</strong></p>

<ul>
<li><strong>search hit:</strong> <code>L + ln N</code></li>
<li><strong>search miss:</strong> <code>ln N</code></li>
<li><strong>insert:</strong> <code>L + ln N</code></li>
<li><strong>space:</strong> <code>4N</code></li>
</ul>

<p>메모리가 <code>4N</code> 밖에 안든다! 해싱은 모든 연산이 <code>L</code> 이겠지만, 대신 메모리가 <code>4N ~ 16N</code> 이다.</p>

<p>따라서 <em>ternary symbol table</em> 은 <em>hash table</em> 만큼 빠르고, 메모리도 덜 든다.</p>

<p>참고로 <em>rotation</em> 연산을 이용해서 <em>balanced TST</em> 를 만들면 <em>worst case</em> 에도 <code>L + logN</code> 이 나온다.</p>

<h4 id="tstwithr2branchingatroot">TST with R2 Branching at root</h4>

<p>꼭대기엔 <code>R^2-way</code> 로 짓고, 자식은 <em>TST</em> 로 지을 수 있다. 분석 결과로는 일반 <em>TST</em> 보다 더 빠르다고 한다.</p>

<h4 id="tstvshashing">TST vs Hashing</h4>

<p>(1) Hashing</p>

<ul>
<li>Need to examine entier key</li>
<li>Search hits and misses cost about the same</li>
<li>Performance relies on hash function</li>
<li>Does not support ordered symbol table operations.</li>
</ul>

<p>(2) TST</p>

<ul>
<li>Works only for strings (or digital keys)</li>
<li>Only examines just enough key characters</li>
<li>Search miss may involve only a few characters</li>
<li>Supports ordered symbol table operations (plus others!).</li>
</ul>

<p>정리하면, <em>TST</em> 는 해싱만큼 빠르고 <em>search miss</em> 는 더 빠르다. 그리고 <em>red-black BST</em> 보다 유연하다. 그러나 자료의 형태에 제한이 있다.</p>

<h3 id="characterbasedoperations">Character-Based Operations</h3>

<p><em>string symbol table</em> 의 경우에는 유용한 <em>chars-based operation</em> 을 제공한다. </p>

<ul>
<li><em>prefix match</em> </li>
<li><em>wildcard match</em> </li>
<li><em>longest prefix</em></li>
</ul>

<p><em>API</em> 를 보면</p>

<pre><code class="java">public class SymbolST&lt;Value&gt; {

  ...
  ...

  Iterable&lt;String&gt; keys()
  Iterable&lt;String&gt; keysWithPrefix  (String s)
  Iterable&lt;String&gt; keysThatMatch   (String s)
  String           longestPrefixOf (String s) 

  ...
  ...
}
</code></pre>

<p>이 외에도 <em>ordered ST</em> 를 위한 <em>floor, rank</em> 등의 연산도 추가할 수 있다.</p>

<h4 id="inordertraverseoftrie">Inorder Traverse of Trie</h4>

<p>탐색이 이진트리하고 좀 다른게, 매 문자열마다 시작점부터 시작해야 된다. <em>leaf</em> 까지 방문하는건 같은데</p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/250px-Trie_example.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org/wiki/Trie' >http://en.wikipedia.org/wiki/Trie</a>)</p>

<pre><code class="java">public Iterable&lt;String&gt; keys() {  
  Queue&lt;String&gt; q = new Queue&lt;String&gt;();
  collect(root, "", q);
  return q;
}

public void collect(Node x, String prefix, Queue&lt;String&gt; q) {  
  if (x == null) return;
  if (x.val != null) q.enequeue(prefix);

  for (char c = 0; c &lt; R; c++)
    collect(x.next[c], prefix + c, q);
}
</code></pre>

<p><em>queue</em> 는 단순히 <code>she</code> 를 방문할때 <code>she</code> 를 저장하기 위한 용도다. <code>val != null</code> 일 때 저장하므로 <code>s, sh</code> 등은 저장하지 않는 다는 점에 유의하자.</p>

<p>그리고 여기서 큐는 <em>DFS, BFS</em> 처럼 로직에 쓰이지 않는다. 모든 노드를 방문하긴 하는데 <code>c = 0</code> 부터 시작하니 왼쪽부터 방문하는 재귀 순회라 보면 쉽다.</p>

<p>여기서 <code>collect</code> 함수는 인자로 받은 노드 <code>x</code> 를 기준으로 하위에 있는 <em>substring</em> 을 찾아낸다.</p>

<p>실제 구현에서는 <code>StringBuilder</code> 를 사용한다.</p>

<pre><code class="java">    private void collect(Node x, StringBuilder prefix, Queue&lt;String&gt; q) {
        // TODO Auto-generated method stub

        if (x == null) return;
        if (x.val != null) q.add(prefix.toString());

        for (char c = 0; c &lt; R; c++) {
            prefix.append(c);
            collect(x.next[c], prefix, q);
            prefix.deleteCharAt(prefix.length() - 1);
        }
    }

    public Iterable&lt;String&gt; keys() { return keysWithPrefix(""); }
</code></pre>

<h4 id="prefixmatchs">Prefix Matchs</h4>

<p>구글링 하면서 매일 사용하는 기능이다. 구현은 위의 <code>collect</code> 함수를 사용하면 쉽다. <code>keyWithPrefix("sh")</code> 라면, <code>sh</code> 까지 내려간 뒤 <code>collect</code> 를 호출하면 된다.</p>

<pre><code class="java">public Iterable&lt;String&gt; keysWithPrefix(String prefix) {  
  Queue&lt;String&gt; q = new Queue&lt;String&gt;();
  Node x = get(root, prefix, 0);
  collect(x, prefix, q);
  return q;
}
</code></pre>

<p>자바의 <code>Queue</code> 는 인터페이스이므로 실제 구현은</p>

<pre><code class="java">    public Iterable&lt;String&gt; keysWithPrefix(String prefix) {
        Queue&lt;String&gt; q = new LinkedList&lt;String&gt;();
        Node x = get(root, prefix, 0);
        collect(x, new StringBuilder(prefix), q);
        return q;
    }
</code></pre>

<h4 id="longestprefix">Longest Prefix</h4>

<p>라우터에서 자주 사용한다. 아이피를 문자열로 표현하고, 자기가 알고 있는 인접한 라우터중 어디로 보낼지를 결정하기 위해 <em>longest prefix</em> 를 알아내 보낸다. </p>

<pre><code class="java    ">longestPrefixOf("128.112.136.11")  
// 128.112.136
</code></pre>

<p>아이디어는 간단하다. <code>null</code> 이나 찾으려는 문자열의 마지막 문자를 만나기 전까지의 문자열을 모아 돌려주면 된다.</p>

<pre><code class="java">public String longestPrefixOf(String query) {  
  int length = search(root, query, 0, 0);
  return query.substring(0, length);
}

public int search(Node x, String query, int d, int length) {

  if (x == null) return length;
  if (x.val != null) length =  d;
  if (d == query.length) return length;

  char c = query.charAt(d);
  return search(x.next[c], query, d + 1, length);
}
</code></pre>

<h4 id="patriciatrie">Patricia Trie</h4>

<p><code>shells, shellfish</code> 를 넣으면 브랜칭이 길게 이루어진다. 메모리 낭비가 있을 수 있는데, <code>shell</code> 밑에 <code>s, fish</code> 를 자식으로 만들면 괜찮다.</p>

<p>그러나 이 강의의 범위를 넘어서는 것이라 안알려준다고 함 ㅠㅠ. 이미지를 구해서 첨부하면</p>

<p><img src='http://2.bp.blogspot.com/-0B8D2LHyQVc/USMklcwZnMI/AAAAAAAAAKc/UBmZnHflOa0/s640/radix_tries.png'  alt="" /></p>

<p><img src='http://3.bp.blogspot.com/-nQ0ZUeIpDrQ/USMkvNUKHBI/AAAAAAAAAKk/rrvVaYU4Pwo/s640/fractal+tries.png'  alt="" /></p>

<p align="center">(<a href='http://aketa.blogspot.kr/' >http://aketa.blogspot.kr</a>)</p>

<p>아마도 통짜로 삽입 후 이후에 비슷한 <em>suffix</em> 의 문자열이 들어오면 분리를 시키는 것 같다. </p>

<h4 id="suffixtree">Suffix Tree</h4>

<p><img src='http://marknelson.us/attachments/1996/suffix-trees/FIGURE2.gif'  alt="" /></p>

<p align="center">(<a href='http://marknelson.us/' >http://marknelson.us</a>)</p>

<p>문자열 <em>suffix</em> 의 <em>patricia trie</em> 인데 <em>linear time</em> 으로 만들 수 있다고 한다.</p>

<ul>
<li>longest repeated substring</li>
<li>longest common substring</li>
</ul>

<p>등에 쓸 수 있단다.</p>

<h3 id="summary">Summary</h3>

<p>(1) Red-Black BST</p>

<ul>
<li><strong>Performance guarantee:</strong> <code>lg N</code> key compares</li>
<li>Supports ordered symbol table API</li>
</ul>

<p>(2) Hash Table</p>

<ul>
<li><strong>Performance guarantee:</strong> <em>constant</em> number of probes</li>
<li>Requires good hash function for key type</li>
</ul>

<p>(3) R-way, TST</p>

<ul>
<li><strong>Performance guarantee:</strong> <code>lg N</code> <em>character</em> accessed </li>
<li>Supports <em>character-based</em> operations</li>
</ul>

<blockquote>
  <p>You can get at anything by examining 50-100 bits!</p>
</blockquote>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://t2.hhg.to/V12-lausn.html' >http://t2.hhg.to</a> <br />
(3) <a href='http://en.wikipedia.org/wiki/Trie' >Wikipedia: Trie</a> <br />
(4) <a href='http://aketa.blogspot.kr/2013/02/squeezed-tries-fractal-compression-for.html' >Squeezed Tries, Fractal Compression</a> <br />
(5) <a href='http://marknelson.us/1996/08/01/suffix-trees/' >Mark Nelson</a></p>]]></description><link>http://1ambda.github.io/r-way-ternary-search-tries/</link><guid isPermaLink="false">68259e58-854a-4a4f-a621-ee864f210992</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[r-way trie]]></category><category><![CDATA[ternary trie]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 16 Dec 2014 08:49:07 GMT</pubDate></item><item><title><![CDATA[Machine Learning, Week 10]]></title><description><![CDATA[<p>이번 주에는 <em>mini-batch, stochastic graident descent</em>, <em>online learning</em>, <em>map-reduce</em> 등의 개념에 대해 배운다.</p>

<h3 id="learningwithlargedatasets">Learning With Large Datasets</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361499744_2717.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>왜 그렇게 큰 데이터 셋이 필요할까? 좋은 퍼포먼스를 얻기 위한 한 가지 방법이, <em>low bias</em> 알고리즘에 <em>massive data</em> 를 활용해 훈련하는 것이기 때문이다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361499747_9327.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>그러나 커다란 데이터 셋을 연산하기 위해서는 연산비용이 정말 비싸다. 예를 들어 
<code>m = 100,000,000</code> 이라 하면 <em>gradient</em> 를 계산하기 위해 매번 <code>k * m</code> 의 연산이 필요하다.</p>

<p>따라서 모든 데이터를 이용해 알고리즘을 훈련하기 보다는, 랜덤하게 고른 작은 서브셋에 대해서 알고리즘을 개발하고, 이후에 전체 데이터에 대해서 훈련하는 방법을 쓰기도 한다.</p>

<p>그러면 <code>m</code> 이 작아도 알고리즘이 충분히 잘 훈련된다는 것을 어떻게 보장할까? 이는 <em>learning curve</em> 를 그려보면 된다.</p>

<p>위 슬라이드에서 우측 하단은 <em>high bias</em> 알고리즘인데 <code>m</code> 을 많이 투입해도 별다른 이득이 없으므로 적당한 수준에서 <code>m</code> 을 정하면 된다.</p>

<p>물론 만든 알고리즘이 우측처럼 <em>high bias</em> 로 나오면, 좀 더 자연스러운 생각은 <em>hidden layer</em> 를 추가한다거나, 새로운 <em>feature</em> 를 도입해서 <em>bias</em> 를 낮추는 것이다.</p>

<p><br/></p>

<h3 id="stochsticgradientdescent">Stochstic Gradient Descent</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361500908_4667.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>gradient descent</em> 를 이용하는 <em>linear regression</em> 에서</p>

<p><img src='http://latex.codecogs.com/gif.latex?h_%5Ctheta%28x%29%20%3D%20%5Csum_%7Bj%3D0%7D%5En%20%5C%20%5Ctheta_jx_j'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?J_%7Btrain%7D%28%5Ctheta%29%20%3D%20%7B1%20%5Cover%202m%7D%20%5Csum_%7Bi%3D1%7D%5Em%5C%20%28h_%5Ctheta%28x%29%5E%7B%28i%29%7D%20-%20y%5E%7B%28i%29%7D%29%5E2'  alt="" /></p>

<p>이미 언급했듯이 <em>batch gradient descent</em> 의 문제는, <code>m</code> 이 크면 <code>J</code> 의 연산이 어마어마하게 많아진다는 것이다. 매 스텝마다 <code>m</code> 을 읽고, 계산값을 저장하기 때문이다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361501694_2445.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>이 문제를 해결하기 위해 <em>stochastic gradient descent</em> 에서는 한 턴에 한 쌍의 <code>x, y</code> 에 대해서만 <em>gradient</em> 를 계산한다.</p>

<p><em>batch gradient decsent</em> 에서는 한 턴마다 모든 모든 쌍의 <code>x, y</code> 에 대해     <em>gradient</em> (= <code>theta_j</code>) 를 계산 했었다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?cost%28%5Ctheta%2C%20%28x%5E%7B%28i%29%7D%2C%20y%5E%7B%28i%29%7D%29%29%20%3D%20%7B1%20%5Cover%202%7D%5C%20%28h_%5Ctheta%28x%5E%7B%28i%29%7D%20-%20y%5E%7B%28i%29%7D%29%5E2'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?J_%7Btrain%7D%28%5Ctheta%29%20%3D%20%7B1%20%5Cover%20m%7D%20%5Csum_%7Bi%3D1%7D%5Em%20cost%28%5Ctheta%2C%20%28x%5E%7B%28i%29%7D%2C%20y%5E%7B%28i%29%7D%29%29'  alt="" /></p>

<p>라고 하면</p>

<pre><code>- Randomly shuffle dataset  
- Repeat for i = 1 to m
  - 0_j := 0_j - a * derivative of cost(0, (xi, yi)
</code></pre>

<p>즉 <code>J_train</code> 의 미분 대신에 <code>cost</code> 의 미분값을 이용해서 연산을 줄이는 방법이다. 이 때 데이터가 이미 랜덤하게 섞였다는 점을 기억하자. 기하학적으로 보면</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361502040_9252.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>batch</em> 에서는 올바른 방향을 향해 가지만, 보폭이 좀 좁다. <em>stochastic</em> 은 이리 갔다, 저리 갔다 하지만 결국에는 최저점을 향해 간다. 다만 <em>global optima</em> 에 도달하지 못하고 그 근처에 도착할 수 있다.</p>

<p><code>m</code> 이 굉장히 크면, <em>repeat</em> 부분의 루프를 1번만 돌려도 될 테지만, 작으면 여러번 돌려서 최대한 좋은 퍼포먼스를 내도록 훈련시킬 수 있다.</p>

<p><br/></p>

<h3 id="minbatchgradientdescent">Min-Batch Gradient Descent</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361503946_9357.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<ul>
<li><strong>Batch gradient descent:</strong> Use all <code>m</code> examples in each iteration</li>
<li><strong>Stochastic gradient descent:</strong> Use <code>1</code> example in each iteration</li>
<li><strong>Batch gradient descent:</strong> Use <code>b</code> examples in each iteration</li>
</ul>

<p><img src='http://latex.codecogs.com/gif.latex?%5Ctheta_j%20%3A%3D%20%5Ctheta-j%20-%20%7B%5Calpha%20%5Cover%20b%7D%20%5Csum_%7Bk%20%3D%20i%7D%5E%7Bi%20&plus;%20b%20-%201%7D%20%28h_%5Ctheta%28x%5E%7B%28k%29%7D%29%20-%20y%5E%7B%28k%29%7D%29%20x_j%5E%7B%28k%29%7D'  alt="" /></p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361504164_4561.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><code>b</code> 는 보통 <code>2 - 100</code> 사이의 값이기 때문에 <em>batch</em> 보다 훨씬 빠르다. 또한 <em>vectorization</em> 을 이용하면 <em>gradient computation</em> 을 <em>partially parallelize</em> 할 수 있기 때문에 <em>stochastic</em> 보다 더 빠를 수 있다. <del>병렬화의 미덕</del></p>

<p>단점으로는 추가적인 파라미터 <code>b</code> 가 필요하다는 점이다. 그러나 <em>vectorization</em> 을 잘 이용하면 더 빨라지므로 문제 없다.</p>

<p><br/></p>

<h3 id="stochasticgradientdescentconvergence">Stochastic Gradient Descent Convergence</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361519060_5993.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>convergence</em> 를 검증하는 방법으로, 훈련시키는 동안 얻은 <code>cost(0, (xi yi)</code> 평균값을 이용해 플롯을 그릴 수 있다.     </p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361519096_5186.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>stochastic</em> 은 <em>global optimum</em> 을 찾아내지 못할 수도 있기 때문에, 그 주변에서 알짱거릴 수도 있다.</p>

<p>더 많은 <code>m</code> 을 투입하면, 까끌거리는 선보다 좀 매끄러운 곡선을 얻을 수도 있다.</p>

<p>때때로 알고리즘이 전혀 학습하지 못하는 것 처럼 보일수도 있는데, 그럴 경우 <code>m</code> 을 더 투입하면 좀 경사가 낮은 커브로 조금씩 <em>decreasing</em> 할 수 있다. 이를 보면 결국 훈련되긴 하는데, 평균값을 플랏으로 그리니 들쭉날쭉 해 보이는 것이다. (물론 학습하지 못하는 경우도 있다. <code>m</code> 을 더 늘려서 확인해 보자.)</p>

<p><code>cost</code> 값이 증가한다면 더 작은 <em>learning late</em> 값을 이용하자.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361519184_7199.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>learning rate</em> 와 관련해서 위 슬라이드처럼 식을 만들면, 이터레이션 넘버가 천천히 증가하면서 <code>alpha</code> 가 감소해 <em>converge</em> 하는 결과를 얻을 수 있다.</p>

<blockquote>
  <p>If we reduce learning rate <code>alpha</code> (and run stochastic gradient descent long enough), it's possible that we may find a set of better parameters than with large <code>alpha</code></p>
</blockquote>

<p><br/></p>

<h3 id="onlinelearning">Online Learning</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361520551_7175.jpg'  alt="" /></p>

<p><em>online learning</em> 에서는 데이터를 얻어 <code>theta</code> 를 업데이트하는데 사용하고, 버린다. 큰 사이트라면 데이터가 지속적으로 들어오기 때문에, <em>trianing data</em> 를 볼 필요가 없다. 다시 말해 같은 데이터를 두번 이상 쓰지 않는다는 말이다.</p>

<p>또 다른 장점으로는 사용자의 취향 변화를 빠르게 반영할 수 있다는 점이다.</p>

<blockquote>
  <p>Can adopt to changing user preference</p>
</blockquote>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361520594_9988.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>product search</em> 에 <em>predicted CTR</em> 를 이용해, 검색어와 잘 매칭되는 상품을 결과로 돌려수 있다. 이때 매 검색마다 돌려주는 검색결과는 일종의 <em>training set</em> 이 된다.</p>

<ul>
<li>special offers</li>
<li>customized selection</li>
</ul>

<p>등에도 사용할 수 있다.</p>

<p><br/></p>

<h3 id="mapreduceanddataparallelism">Map Reduce and Data Parallelism</h3>

<p>데이터가 어마어마하게 많으면, 하나의 컴퓨터에서 머신러닝 알고리즘을 돌리기가 좀 힘들다. 어떻게 해결할까?</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361522176_1942.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/22/1361522180_7521.jpg'  alt="" /></p>

<p>쉽게 말하면, 분산해서 처리할 수 있는 결과는 <code>map</code> 으로 해결하고, 이 결과들을 이용해 전체적인 결과는 <code>reduce</code> 가 계산한다. (실제로는 <code>reduce</code> 도 여러개 일 수 있다)</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361522184_5033.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<blockquote>
  <p>Many lenaring algorithms can be expressed as computing sums of functions over the training set</p>
</blockquote>

<p>이렇기 때문에 <em>map-reduce</em> 가 큰 데이터셋에 대한 계산 처리 방법으로 좋은 해결책이 될 수 있다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361522188_9650.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>요즘엔 대부분의 프로세서가 멀티코어이기 때문에, 하나의 컴퓨터에서도 병렬화를 이용해 계산을 빠르게 해 낼 수 있다. 이 경우는 <em>network latency</em> 등에 대해 생각을 안해도 된다. 참고로 좋은 라이브러리들은 자동으로 연산을 병렬화한다. </p>

<p><br/></p>

<h3 id="photoocrandpipeline">Photo OCR and Pipeline</h3>

<p>머신러닝 예제로 <em>Photo OCR</em> 을 알아보자.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361935712_3407.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>Photo OCR pipeline</em> 은 </p>

<ul>
<li>Image</li>
<li>Text detection</li>
<li>Character segmentation</li>
<li>Character recognition</li>
</ul>

<p>의 단계를 거친다. 각 단계마다 머신러닝을 적용할 수 있다.</p>

<p><br/></p>

<h3 id="slidingwindows">Sliding Windows</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361936303_5994.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361936307_1350.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361937647_2708.jpg'  alt="" /></p>

<p>텍스트나, 보행자등 특정 패턴을 검색하기 위해 이동하는 <em>rectangle</em> 의 단위를 <em>step-size, slide</em> 라 부른다. <em>slide</em> 의 사이즈를 변경해 가면서 패턴을 파악하는 방법을 <em>sliding window</em> 라 부른다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361937654_3410.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361937664_2466.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>텍스트를 인식해서, 근처의 텍스트와 묶는 <em>expansion</em> 작업을 하고 <em>character segmentation</em> 단계로 넘어간다. </p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361937671_6657.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361937676_4874.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><br/></p>

<h3 id="artificialdata">Artificial Data</h3>

<p><em>low bias</em> 에 <em>massive data set</em> 을 조합하면 좋은 퍼포먼스가 나오긴 하는데, 어디서 커다란 데이터셋을 구할까? 작은 데이터 셋으로 커다란 데이터셋을 인위적으로 만들 수 있을까?</p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361948453_3756.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361948457_9107.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361948462_1113.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>스케일링, 로테이션, 디스토션, 백그라운드 수정 등 다양한 조합을 통해 진짜처럼 보이는 <em>synthetic data</em> 를 얻을 수 있다. 마찬가지로, <em>speech recognition</em> 에도 <em>synthetic data</em> 를 만들어 퍼포먼스를 높일 수 있다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361948466_5032.jpg'  alt="" /></p>

<ul>
<li><em>synthetic data</em> 를 만들기 전에 <em>low bias classifier</em> 인지 확인하자.</li>
<li>데이터를 조합하는데 들어가는 노력이 얼마나 들까 생각해보자</li>
<li><em>crowd source</em> 를 고려하자. (e.g. Amazon Mechanical Turk)</li>
</ul>

<p>10 초당 1개의 <em>example</em> 을 수동으로 얻는다면, 10000 개를 얻는데 대략 3.5일의 시간이 걸린다.</p>

<h3 id="ceilinganalysis">Ceiling Analysis</h3>

<p>이전의 <em>Photo OCR</em> 문제에서 퍼포먼스를 높이려면 파이프라인의 각 단계 중 어느 부분에 가장 많은 노력을 들여야할까? </p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361952527_2269.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>각 단계에서 수동으로 정확도 100% 를 만들었을때와, 전체적인 정확도를 비교해서 어느 부분을 향상 시켰을때 가장 효율적일지를 파악할수 있다.  </p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361952535_9451.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361952540_1528.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><br/></p>

<h3 id="summary">Summary</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361952938_3624.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><strong>supervised learning</strong> 의 종류로</p>

<ul>
<li>linear regresison</li>
<li>logistic regression</li>
<li>neural networks</li>
<li>SVM</li>
</ul>

<p><strong>unsupervised learning</strong> 으로</p>

<ul>
<li>k-means</li>
<li>PCA</li>
<li>anomaly detection</li>
</ul>

<p>또한 머신 러닝의 응용으로</p>

<ul>
<li>recommender system</li>
<li>large scale ML</li>
</ul>

<p>마지막으로 머신러닝에 도움이 되는 주제로</p>

<ul>
<li>bias vs variance</li>
<li>regularization</li>
<li>evaluation technique</li>
<li>learning curve</li>
<li>error analysis</li>
<li>ceiling analysis</li>
</ul>

<p>등을 배웠다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361953290_6926.jpg'  alt="" /></p>

<h3 id="references">References</h3>

<p>(1) <em>Machine Learning</em> by <strong>Andrew NG</strong> <br />
(2) <a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a> <br />
(3) <a href='http://blog.csdn.net/abcjennifer' >http://blog.csdn.net/abcjennifer</a>  </p>]]></description><link>http://1ambda.github.io/machine-learning-week-10/</link><guid isPermaLink="false">5ffe5848-c50e-42ff-84ab-153d47f0c7d3</guid><category><![CDATA[coursera]]></category><category><![CDATA[machine learning]]></category><category><![CDATA[stochastic gradient descent]]></category><category><![CDATA[mini-batch gradient descent]]></category><category><![CDATA[online learning]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 15 Dec 2014 03:14:52 GMT</pubDate></item><item><title><![CDATA[Radix Sort, Suffix Sort]]></title><description><![CDATA[<h3 id="stringsinjava">Strings in Java</h3>

<p>문자열은 <em>Character (문자)</em> 의 나열이다. C 에서 하나의 캐릭터는 <em>8-bit</em> 인데, 자바의 경우에는 <em>16-bit unsigned integer</em> 로 표시한다. </p>

<p>스트링의 길이를 얻기 위해 <code>length</code>, 인덱싱 하기 위해 <code>charAt</code>, 서브스트링을 얻기 위해 <code>substring</code> 의 메소드를 지원한다.</p>

<pre><code class="java">public final class String implements Comparable&lt;String&gt; {

  private char values;
  private int offset; // index of first char in array
  private int length;
  private int hash; // cache of hashCode()

  ...

  public char charAt(int i) {
    return value[i + offset];
  }

  ...
}
</code></pre>

<p>자바에서 문자열은 <em>immutable</em> 이다. 더 정확히는 <em>immutable</em> <code>char []</code> <em>array</em> 라 보면 된다. 길이 정보를 가지고 있고 배열이기 때문에 <code>length</code>, <code>charAt</code>, <code>substring</code> 등의 연산은 <code>O(1)</code> 임을 보장한다.</p>

<p><code>concat</code> 의 경우에는 새로운 문자열을 만들기 때문에 <code>O(N)</code> 이다. 메모리는 길이 <code>N</code> 의 문자열에 대해 <code>40 + 2N</code> 을 필요로 한다. 메모리를 아껴야 한다면 <em>byte, char</em> 을 이용할 수 있겠지만 여러 편리한 스트링의 메소드를 사용하지 못한다.</p>

<h3 id="stringbuilderstringbuffer">StringBuilder, StringBuffer</h3>

<p><code>StringBuilder</code> 는 <em>mutable</em> 이다. <code>char []</code> 배열을 <em>resizing</em> 하기 때문에 </p>

<ul>
<li><code>substirng</code> 의 경우 <code>O(N)</code> 이며 (새 스트링을 만든다)</li>
<li><code>concat</code> 은 <code>O(1*)</code> 이다. (<code>*</code> 는 amortized)</li>
</ul>

<p><code>length, charAt</code> 은 마찬가지로 <code>O(1)</code> 이다. 참고로 <code>StringBuffer</code> 는 <code>StringBuilder</code> 와 비슷하지만 <em>thread safe</em> 하고, 느리다.</p>

<p>그러면 <em>reverse</em> 를 구현 할 때 <code>String</code> 과 <code>StringBuilder</code> 중 어떤 것이 더 나을까?</p>

<pre><code class="java">// 1. use String
public static String reverse(String s) {  
  String rev = "";
  for (int i = s.length() - 1; i &gt;= 0; i--)
    rev += s.charAt(i);

  return rev;
}  

// 2. use StringBuilder
public static String reverse(String s) {  
  StringBuilder rev = new StringBuilder();
  for (int i = s.length() - 1; i &gt;= 0; i--)
    rev.append(s.charAt(i));

  return rev.toString();
}  
</code></pre>

<p><code>String</code> 을 이용한 버전은 <code>O(n^2)</code> 이고, <code>StringBuilder</code> 를 이용한 버전은 <code>O(n)</code> 이다. 이는 <code>+=</code> 와 <code>append</code> 의 차이 때문이다.</p>

<p><em>suffixes</em> 문제도 생각해 보자.</p>

<pre><code class="java">// input string
a a c a a g t t a c a a g c

// output
c     // suffixes 14  
g c   // suffixes 13  
a g c // suffixes 12  
...
...
a a c a a g t t a c a a g c // suffixes 0  
</code></pre>

<p><code>String</code> 과 <code>StringBuilder</code> 의 구현을 생각해 보면,</p>

<pre><code class="java">// 1. use String 
public static String[] suffixes(String s) {  
  int N = s.length();
  String[] suffixes = new String[N];

  for (int i = 0; i &lt; N; i ++)
    suffixes[i] = s.substring(i, N);

  return suffixes;
}

// 2. use StringBuilder 
public static String[] suffixes(String s) {  
  int N = s.length;
  stringBuilder sb = new StringBuilder(s);
  String suffixes = new String

  for (int i = 0; i &lt; N; i++)
    suffixes[i] = s.substring(i, N);

  return suffixes;
}
</code></pre>

<p>당연히 <code>substring</code> 은 <code>String</code> 이 메모리 사용량이 훨씬 더 적을꺼라 생각했는데 Java7 Update6 부터 좀 달라졌다고 한다.</p>

<p><em>Java 7 Update 6</em> 부터는 이전처럼 <code>String</code> 의 <code>char []</code> 가 공유되지 않는단다. 따라서 <code>String.substring</code> 은 더이상 <em>constance space, time</em> 이 아니라 <em>linear space, time</em> 의 비용이 든다. 자세한 내용은 <a href='http://java-performance.info/changes-to-string-java-1-7-0_06/' >Changes to String Java 1.7.0-06</a>로 </p>

<p>따라서 알고리즘 <code>1</code> 은 <em>linear time, space</em> <code>2</code> 는 <em>quadratic time, space</em> 의 알고리즘이다.</p>

<h4 id="longestcommonprefix">Longest common prefix</h4>

<pre><code class="java">public static int lcp(String s, String t) {  
  int n = Math.min(s.length(), t.length());

  for (int i = 0; i &lt; n; i++)
    if (s.charAt(i) != t.charAt(i))
      return i;

  return n;
}
</code></pre>

<p>러닝타임은 <code>s, t</code> 중 더 긴 문자열의 길이에 비례한다. 일반적으로는 <em>sublinear time</em> 이다. 따라서 <code>compareTo</code> 메소드를 <em>sublinear time</em> 으로 구현할 수 있다.</p>

<h4 id="radix">Radix</h4>

<p>알파벳을 다양한 형태로 표현할 수 있는데, <em>binary</em> 의 경우엔 <code>01</code> 이 될 것이다. 이때의 <em>radix</em> 는 2 다. <em>DNS</em> 는 <code>ACTG</code> 로 표현할 수 있으므로 <code>R = 4</code> 다.</p>

<h3 id="keyindexedcounting">Key-Indexed Counting</h3>

<p>정렬 알고리즘의 성능을 정리해 보면,</p>

<p>(1) <strong>Insertion Sort</strong></p>

<ul>
<li><strong>guarantee:</strong> <code>O(N^2 / 2)</code></li>
<li><strong>random:</strong> <code>O(N^2 / 4)</code></li>
<li><strong>extra space:</strong> <code>1</code></li>
<li><strong>stable:</strong> <code>yes</code></li>
</ul>

<p>(2) <strong>Merge Sort</strong></p>

<ul>
<li><strong>guarantee:</strong> <code>O(N log N)</code></li>
<li><strong>random:</strong> <code>O(N log N)</code></li>
<li><strong>extra space:</strong> <code>N</code></li>
<li><strong>stable:</strong> <code>yes</code></li>
</ul>

<p>(3) <strong>Quick Sort</strong></p>

<ul>
<li><strong>guarantee:</strong> <code>O(1.39 N log N)</code></li>
<li><strong>random:</strong> <code>O(1.39 N log N)</code></li>
<li><strong>extra space:</strong> <code>c log N</code></li>
<li><strong>stable:</strong> <code>no</code></li>
</ul>

<p>(4) <strong>Heap Sort</strong></p>

<ul>
<li><strong>guarantee:</strong> <code>O(2 N log N)</code></li>
<li><strong>random:</strong> <code>O(2 N log N)</code></li>
<li><strong>extra space:</strong> <code>1 log N</code></li>
<li><strong>stable:</strong> <code>no</code></li>
</ul>

<p>이런 <em>comparison based</em> 알고리즘은 <em>lower bound</em> 가 <code>N log N</code> 이다. 따라서 <em>key compare</em> 를 하지 않는다면 더 나은 성능을 낼 수 있다.</p>

<p><em>key-indexed counting</em> 에서는 <em>key</em> 가 <code>0</code> 부터 <code>R - 1</code> 사이의 정수라 가정한다. 따라서 키를 배열의 인덱스로 사용할 수 있다.</p>

<p>따라서 다음처럼 활용할 수 있다.</p>

<ul>
<li>Sort String by first letter</li>
<li>Sort class roster by section</li>
<li>Sort phone number by area code</li>
<li>Subroutine in a sorting algorithm</li>
</ul>

<p>알고리즘을 보자. </p>

<blockquote>
  <p><strong>Goal:</strong> Sort an array <code>a[]</code> of <code>N</code> integers between <code>0</code> and <code>R - 1</code></p>
</blockquote>

<p>(1) Count frequencies of each letter using key as index <br />
(2) Compute frequecy cumulates which specify destinations <br />
(3) Access cumulates using key as index to move items <br />
(4) Copy back into original array</p>

<pre><code class="java">int N = a.length();  
int[] count = new int[R + 1];

// step (1)
for (int i = 0; i &lt; N; i++)  
  count[a[i] + 1]++;

// step (2)
for (int r = 0; r &lt; R; r++)  
  count[r + 1] += count[r];

// step (3)
for (int i = 0; i &lt; N; i++)  
  aux[count[a[i]]++] = a[i];

// step (4)
for (int i = 0; i &lt; N; i++)  
  a[i] = aux[i];
</code></pre>

<ul>
<li><code>~11N + 4R</code> <em>array access</em></li>
<li><code>N + R</code> <em>extra space</em></li>
</ul>

<p><em>key-indexed counting</em> 은 <em>linear time, stable sorting</em> 이다.</p>

<h4 id="stable">Stable</h4>

<p>알고리즘이 <em>stable</em> 하다는 건 무슨 뜻일까? </p>

<blockquote>
  <p>A stable sort is one which preserves the original order of the input set while The unstable algorithm exhibits undefined behaviour when two elements are equal, it is perfectly possible that the order is sometimes preserved.</p>
</blockquote>

<p><img src='http://i.stack.imgur.com/hn6Rg.png'  alt="" /></p>

<p align="center">(<a href='http://programmers.stackexchange.com/' >http://programmers.stackexchange.com/</a>)</p>

<h3 id="lsdradixsort">LSD Radix Sort</h3>

<p><em>least-significant-digit-first string(radix) sort</em></p>

<p>아이디어는 간단하다. 우측부터 좌측으로 한 문자씩 <em>key-indexed couting</em> 을 하면 된다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTjVFR1ozVWpNaVJHTzVZV0x4QXpZNDBpWjNJMk10WW1ZeEVUTHlZak5pVkdOMWN6TDJnRE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<blockquote>
  <p>Which of the following is the most efficient algorithm to sort 1 million 32-bit integers?</p>
</blockquote>

<p>답은 <em>radix sort</em></p>

<h4 id="correctness">Correctness</h4>

<blockquote>
  <p>LSD sorts fixe-length strins in ascending order</p>
</blockquote>

<p>가설에 의해 <code>i</code> 번째 pass 후에는 뒤 부터 <code>i</code> 개의 문자들이 정렬되어 있다.  이 때 비교하려는 <code>i+1</code> 번째의 두 문자가 다르다면, <em>key-indexed sort</em> 가 두 개의 문자열을 정렬한다. 이 때 <em>key-indexed sort</em> 는 <em>stable</em> 하므로 이전 까지의 정렬했던 순서를 보존한다.</p>

<h4 id="implementation">Implementation</h4>

<pre><code class="java">    // W: fixed-length of strings
    public static void LSDsort(String[] a, int W) {
        int N = a.length;
        int R = 256;
        String[] aux = new String[N];

        // key indexed counting for each digit from right to left
        for (int d = W - 1; d &gt;= 0; d--) {
            int[] count = new int[R + 1];

            // count frequencies
            for (int i = 0; i &lt; N; i++) 
                count[a[i].charAt(d) + 1]++;

            for (int r = 0; r &lt; R; r++)     
                count[r + 1] += count[r];

            for (int i = 0; i &lt; N; i++)
                aux[count[a[i].charAt(d)]++] = a[i];

            for (int i = 0; i &lt; N; i++)
                a[i] = aux[i];
        }
    }
</code></pre>

<p><em>LSD sort</em> 퍼포먼스는 <code>2WN</code>, 랜덤하게 <code>2WN</code>, 공간은 <code>N + R</code>, <em>stable</em> 하다. 참고로, <code>4byte Int</code> 에 대해 <code>1Byte</code> 씩 <em>LSD sort</em> 를 적용하면 <code>Array.sort</code> 보다 2~3배 더 빠르다고 한다. <a href='http://algs4.cs.princeton.edu/51radix/LSD.java.html' >코드는 여기로</a></p>

<h3 id="msdradixsort">MSD Radix Sort</h3>

<p><em>most significant-digit-first string sort</em></p>

<ul>
<li>Partition array into <code>R</code> pieces according to first character</li>
<li>Recursively sort all strings that start with each character</li>
</ul>

<p>좌측 문자열 부터 시작하고, 현재 문자가 같은 문자열들 끼리 모아, 나머지 부분을 <em>sub-array</em> 취급해서 재귀적으로 정렬한다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWjNNV001VW1ZaWhETTRjVExoTldONDBpTTJVMk10RVdaeEFUTHpVRFptZHpNaEYyTDVFVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<p><em>LSD</em> 는 다루지 못하는 <em>variable-length string</em> 을 정렬할 수 있다.</p>

<h4 id="implementation">Implementation</h4>

<p>참고로 자바에서는 <code>\0</code> 이 없다. 그래서 문자열의 길이를 넘어서는 인덱스에 대해 <code>-1</code> 을 돌려주는 <code>charAt</code> 을 만들자. 추가적인 문자가 없다면, 정렬된 것으로 보고 끝내면 된다. </p>

<pre><code class="java">private static int charAt(String s, int d) {  
  if (d &lt; s.length()) return s.charAt(d);
  else return -1;
}

    private static void msdSort(String[] a, String[] aux, int l, int h, int d) {

        if (h &lt;= l) return;

        int R = 256;
        int[] count = new int[R + 2];

        // count frequencies
        for (int i = l; i &lt;= h; i++) {
            int c = charAt(a[i], d);
            count[c + 2]++;
        }

        // accumulate
        for (int r = 0; r &lt; R + 1; r++)
            count[r + 1] += count[r];

        // sort
        for (int i = l; i &lt;= h; i++) {
            int c = charAt(a[i], d);
            aux[count[c + 1]++] = a[i];
        }

        // copy
        for (int i = l; i &lt;= h; i++)
            a[i] = aux[i - l];

        // solve sub-arrays
        for (int r = 0; r &lt; R; r++)
            msdSort(a, aux, l + count[r], l + count[r + 1] - 1, d + 1);
    }

    public static void MSDsort(String[] a) {
        String[] aux = new String[a.length];
        msdSort(a, aux, 0, a.length - 1, 0);
    }
</code></pre>

<p>그런데 이 구현은 몇 가지 문제가 있다.</p>

<p>(1) 매 재귀마다 <code>count</code> 배열을 만들고, 그 크기는 <code>R</code> 에 비례하기 때문에 <code>~11R + N</code> 의 성능을 갖는 <em>key-indexed counting</em> 연산이 <em>small subarray</em> 가 많아지면서 급격히 느려진다. </p>

<p>(2) 조그마한 <em>sub-array</em> 에 대해 많은 수의 재귀가 호출된다.</p>

<p>이 문제를 해결하기 위해 적은 수의 <em>small array</em> 에 대해 <em>insertion sort</em> 를 사용하자. </p>

<pre><code class="java">    // substring comparison is much faster than charAt comparison
    private static boolean less(String v, String w, int d) {
        return v.substring(d).compareTo(w.substring(d)) &lt; 0;
    }

    private static void isort(String[] a, String[] aux, int l, int h, int d) {
        // insertion sort
        for (int i = l; i &lt;= h; i++)
            for (int j = i; j &gt; l &amp;&amp; less(a[j], a[j - 1], d); j--) {
                // swap a[j - 1], a[j]
                String temp = a[j - 1];
                a[j - 1] = a[j];
                a[j] = temp;
            }

    }

    private static void msdSort(String[] a, String[] aux, int l, int h, int d) {

        int CUTOFF = 15;
        if (h &lt;= l + CUTOFF) {
            isort(a, aux, l, h, d);
            return;
        }
    ...
    ...
    ...
</code></pre>

<h4 id="performance">Performance</h4>

<p><em>MSD string sort</em> 는 필요한만큼 <em>character</em> 를 확인하기 때문에, 데이터에 따라 성능이 다르다. 그러나 대부분의 경우 <em>sublinear</em> 하고, 운이 나쁜 경우 <em>linear</em> 의 성능이 나온다. <em>duplicated key</em> 가 있는 경우에는 <em>nearly linear</em> 다.</p>

<p>재밌는 사실은 <code>compareTo</code> 를 이용하지만 <em>sublinear</em> 하게 성능이 나올 수도 있다는 점이다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTWhkVFk0VXpZa2RqTmtaV0x3Z2paNTBpTTNZek10VWpNMFVUTGxSMlkxY1Raamx6TDRJVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<p><em>MSD string sort</em> 는 매 재귀마다 새로운 <code>count</code> 배열을 만들기 때문에 <code>N + DR</code> 만큼의 메모리가 필요하다., (<code>D</code> 는 재귀 호출의 수)</p>

<p><em>LSD</em> 에 비해서 가변길이 문자열을 정렬할 수 있고, <em>random</em> 데이터에 대해 <code>N log_R N</code> 의 성능을 보여준다. <em>LSD</em> 와 마찬가지로 <em>stable</em> 하다.</p>

<h4 id="msdvsquick">MSD vs quick</h4>

<p><em>MSD string sort</em> 는 <em>random access</em> 를 하기 때문에 <em>cache inefficient</em> 할 수 있고, <em>quicksort</em> 에 비해 <em>inner loop</em> 에 많은 명령어가 있다. 게다가 <code>count, aux</code> 등 추가적인 메모리가 필요하다.</p>

<p>반면 <em>quicksort</em> 는 <em>linear</em> 하지 않다. 그리고, 많은 수의 문자들을 다시 비교해야한다. 이 두가지를 합친 방법은 없을까?</p>

<h3 id="3wayradixquicksort">3-way Radix Quicksort</h3>

<p><del>무려 교수님이 만드신 알고리즘 1997년에 이 수업에서 만들었다고 함</del></p>

<p>기본적인 아이디어는</p>

<blockquote>
  <p>Do 3-way partitioning on the <code>d</code> th character</p>
</blockquote>

<ul>
<li>Less overhead than <code>R</code>-way partitioning in <em>MSD string sort</em></li>
<li>Does not re-examine characters equal to the partitioning char (but does re-examine characters not equal to the partitioning char)</li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTWhKVFpoTkRPMk1qWTRRV0xsTm1ZaTFDTjVFek10SVdNaVZUTHdZVFlsVldPbVoyTDBNVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<p>즉, 첫 문자열의 첫 번째 문자를 기준으로, 이것보다 큰 것, 작은 것, 같은 것 3개로 파티셔닝하면서 정렬하는 알고리즘이다. </p>

<h4 id="implementation">Implementation</h4>

<p>구현은 퀵소트랑 상당히 유사하다.</p>

<pre><code class="java">    // 3-Way Quicksort
    public static void Quicksort3way(String[] a) {
        qsort3way(a, 0, a.length - 1, 0);
    }

    // helper method for 3 way quicksort
    private static void swap(String[] a, int i, int j) {
        String temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

    private static void qsort3way(String[] a, int l, int h, int d) {
        if (h &lt;= l) return;

        int lt = l, gt = h;
        int v = charAt(a[l], d);
        int i = l + 1;

        // partition
        while (i &lt;= gt) {
            int t = charAt(a[i], d);

            if      (t &lt; v) swap(a, lt++, i++);
            else if (t &gt; v) swap(a, i, gt--);
            else            i++;
        }
        // a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]
        qsort3way(a, l, lt - 1, d);
        if (v &gt;= 0) qsort3way(a, lt, gt, d + 1);
        qsort3way(a, gt + 1, h, d);
    }
</code></pre>

<p><em>MSD string sort</em> 와 마찬가지로 <code>CUTOFF</code> 를 이용해서 작은 <em>sub-array</em> 를 <em>insetion sort</em> 로 정렬할 수 있다.</p>

<h4 id="3wayquicksortvsstandardquicksor">3-way quicksort vs standard quicksor</h4>

<p>일반적으로 <em>quicksort</em> 는 <code>compareTo</code> 를 기준으로 <code>~ 2N lnN</code> 의 성능을 보여주고, <em>long common prefixes</em> 가 있는 경우에 상당히 계산 비용이 비싸다. 이는 비교했던 문자열을 또 비교할 수 있기 때문이다.</p>

<p>그러나 <em>3-way string quicksort</em> 는 <code>charAt</code> 을 기준으로 <code>~ 2N lnN</code> 의 성능을 보인다. 그리고 같은 파티션에 대해 <code>d + 1</code> 로 재귀호출하기 때문에 같은 파티션 내에서는 비교했던 문자를 다시 계산하지 않는다. <del>갓 교수님</del></p>

<h4 id="3wayquicksortvsmsdsort">3-way quicksort vs MSD sort</h4>

<p>(1) <strong>MSD string sort</strong> 는</p>

<ul>
<li>같은 <code>count</code> 값을 가진 문자열에 뜬금없이 접근하기 때문에 <em>cache-inefficient</em></li>
<li>재귀마다 <code>count[]</code> 를 새로 만들어 너무 많은 메모리를 사용</li>
<li><code>count[], aux[]</code> 를 초기화하는데 너무 많은 오버헤드</li>
</ul>

<p>(2) <strong>3-way string quicksort</strong> 는</p>

<ul>
<li>더 짧은 <em>inner loop</em></li>
<li><code>while</code> 을 이용해 순차적으로 접근하므로 <em>cache-friendly</em></li>
<li><em>in-place</em></li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTTTJFV09tZFRPakoyTTVjVEwxWW1ZNDBDTWtoek10UVRZMUlXTDVVRE8wWUdNd1UyTHhRVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<h3 id="suffixarrays">Suffix Arrays</h3>

<p><em>keyword-in-context search</em> 란</p>

<blockquote>
  <p>Given a text of <code>N</code> chars, preprocess i to enable fast substring search (find all occurrences of query string ocntext)</p>
</blockquote>

<p>쉽게 말해서 구글 검색창에 <em>world</em> 라고 치면 <em>hello world</em> 등이 자동으로 검색목록에 나오는것.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWmtkVFozRW1ZbFZtTmlGVEx6RVRPNDBTWTFZek10UVRNeFFXTGlKVFpqbERNekkyTHpRVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<p><em>suffixes</em> 를 만든다음에 문자열 정렬을 해서 중복된 <em>suffix</em> 가 있는지 보면 된다. <code>String</code> 의 경우 <code>substring</code> 을 얻는데 <code>O(1)</code> 이이므로 <em>suffixes</em> 를 만드는데 <code>O(n)</code> 이다. </p>

<p>그 후에 <em>binary search</em> 를 하면, 일치하는 문자열을 검색할 수 있다.</p>

<p>(1) <strong>Preprocess:</strong> <em>suffix sort</em> the text. <br />
(2) <strong>Query:</strong> <em>binary search</em> for query; scan until mismatch.  </p>

<h3 id="longestrepeatedsubstring">Longest repeated substring</h3>

<blockquote>
  <p>Gien a string of <code>N</code> characters, find the longest repeated substring.</p>
</blockquote>

<p>유전자 지도 <code>a g t t a a t c g ~</code> 에서 일치하는 가장 긴 유전자 문자열을 찾아내는데 활용할 수 있다.</p>

<p><em>data compression</em> 에도 활용 가능하다. 자주 반복되는 긴 패턴을 발견해 짧게 줄이면 용량을 상당히 줄일 수 있다.</p>

<p>악보를 이용해서 음악을 <em>visualization</em> 하는데도 활용할 수 있다.</p>

<h4 id="bruteforce">Brute Force</h4>

<p>문자열의 길이가 <code>N</code>, 가장 긴 패턴의 길이가 <code>D</code> 라면 <em>worst case</em> <code>DN^2</code> 이다. </p>

<h4 id="sortingsolution">Sorting solution</h4>

<p>(1) form suffixes (<code>O(n)</code>) <br />
(2) sort suffixes (<code>O(n log n)</code>) <br />
(3) compute longest prefix between adjacent suffixes (<code>O(kn)</code>)  </p>

<pre><code class="java">    // longrest common prefix
    public static String lcp(String v, String w) {

        int n = Math.min(v.length(), w.length());

        for (int i = 0; i &lt; n; i++) {
            if (v.charAt(i) != w.charAt(i)) return v.substring(0, i);
        }

        return v.substring(0, n);
    }

    // longest repeated substring
    public static String lrs(String s) {

        int N = s.length();
        String[] suffixes = new String[N];

        // form suffixes
        for(int i = 0; i &lt; N; i++)
            suffixes[i] = s.substring(i, N);

        // sort
        Arrays.sort(suffixes);

        // find longest repeated substring using lcp
        String lrs = "";

        for (int i = 0; i &lt; N - 1; i++) {
            String x = lcp(suffixes[i], suffixes[i + 1]);

            if (x.length() &gt; lrs.length()) lrs = x;
        }

        return lrs;
    }
</code></pre>

<p><em>suffix soring</em> 에 <em>3-way string quicksort</em> 를 이용하면 어마어마하게 빠르다.</p>

<p>한 가지 문제는 <em>lrs</em> 의 길이가 길어지면 <em>suffix sort</em> 의 성능이 급격히 떨어진다. <code>D</code> 를 <em>lrs</em> 의 길이라 했을때 적어도 <code>1 + 2 + ... + D</code> 의  문자열 비교가 필요하다. (자신과 자신의 서브스트링과의 비교)</p>

<p>따라서 <code>D</code> 가 길면 길수록 성능이 나빠진다. </p>

<blockquote>
  <p>Quadratic (or worse) in <code>D</code> for <em>LRS</em></p>
</blockquote>

<p>성능이 떨어지는 입력 데이터로, 반복되는 인풋이 있다. <code>twinstwins</code> 를 예로 들면</p>

<pre><code>ins  
instwins  
ns  
nstwins  
s  
stwins  
twins  
twinstwins  
wins  
winstwins  
</code></pre>

<p>그러면 더 빠른 알고리즘이 없을까? <em>Manber-Myers algorithm</em> 이란게 있는데, 요건 <em>linearithmic</em></p>

<p><em>suffix trees</em> 란 것도 있다. 이건 <em>linear</em></p>

<h4 id="manbermyersmsdalgorithm">Manber-Myers MSD Algorithm</h4>

<p>(1) sort on first character using key-indexed counting sort <br />
(2) given array of suffixes sorted on first <code>2^(i-1)</code> characters (phase <code>i</code>)  </p>

<p><em>worse-case</em> 퍼포먼스는 <code>N lgN</code></p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWmtCVE9rZFRaMVFEWjVBVEwwY2paaTFTTjBjek10Z0RabU5XTGlSRE9qUkRNalIyTDNNak14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<p><em>key-indexed counting</em> 을 이용해 먼저 하나의 문자를 정렬하고, 그 이후에는 <code>2, 4, 6, 8, ...,</code> 개씩 정렬해 나간다. 이 과정에서 <code>inverse[]</code> 를 이용한 <em>index sort</em> 란걸 하는데, 아이디어는 이렇다.</p>

<p><em>suffixes</em> 에서 비교하려는 두 문자열의 뒷부분의 일부는 이미 이전 단계에 정렬 되었을 수 있다. (슬라이드의 빨간색 부분) 따라서 이미 정렬해 된 순서 <code>inverse[]</code> 를 이용해서 현재 비교하려는 두 문자열의 순서를 정할 수 있다. </p>

<h4 id="summary">Summary</h4>

<ul>
<li><em>linear-time</em> 문자열 정렬을 할 수 있다.</li>
</ul>

<p>왜냐하면 <em>key comparison</em> 이 아니라 <em>character comparison</em> 으로 해낼 수 있기 때문</p>

<ul>
<li><em>sublinear-time</em> 정렬도 만들 수 있다.</li>
</ul>

<p>모든 문자열을 비교할 필요가 없기 때문 (Input size is amount of data in keys, not number of keys.)</p>

<ul>
<li><em>3-way string quicksort is asymptotically optimal</em></li>
</ul>

<p><code>1.39 N lgN</code> 의 문자열 비교, <em>random data</em> 에 대해. 그러나 <em>suffix sort</em> 에 대해 <code>N lgN</code> 을 보장하려면(<em>worst case</em>) <em>Manber-Myer</em> 를 사용해야 한다.</p>

<ul>
<li>Long strings are rarely random in practice</li>
</ul>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://programmers.stackexchange.com/questions/247440/what-does-it-mean-for-a-sorting-algorithm-to-be-stable' >What is a stable sorting algorithm?</a> <br />
(3) <a href='http://www.programering.com/a/MTOyYjNwATM.html' >www.programering.com</a></p>]]></description><link>http://1ambda.github.io/radix-sort-suffix-sort/</link><guid isPermaLink="false">e649e1bf-a946-4414-a54a-e3f1be9c1d66</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[radix sort]]></category><category><![CDATA[String]]></category><category><![CDATA[3 way radix]]></category><category><![CDATA[MSD]]></category><category><![CDATA[LSD]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 11 Dec 2014 06:59:33 GMT</pubDate></item><item><title><![CDATA[Process Mining, Week3]]></title><description><![CDATA[<h3 id="fourqualitycriteriaforprocessdiscovery">Four Quality Criteria For Process Discovery</h3>

<p><em>real process</em> 로 부터 <em>event log</em> 를 얻고 이것으로 <em>process model</em> 을 만든다. </p>

<p><em>process model</em> 을 평가하기 위해 해야하는 질문은</p>

<blockquote>
  <p>Is the process model a correct reflection of the real process?</p>
</blockquote>

<p>그러나 <em>real process</em> 를 모르기 때문에 판단하기가 쉽지 않다. 일반적으로 데이터마이닝에서 사용하는 평가 지표인 <em>confusion matrix</em> 를 도입하면</p>

<p><img src='http://lh3.ggpht.com/_qIDcOEX659I/SzjW6wGbmyI/AAAAAAAAAtY/Nls9tSN6DgU/contingency_thumb%5B3%5D.png?imgmax=800'  alt="" /></p>

<p align="center">(<a href='http://crsouza.blogspot.kr/' >http://crsouza.blogspot.kr</a>)</p>

<ul>
<li><strong>True Positive:</strong> traces possible in model and also possible in real process</li>
<li><strong>True Negative:</strong> traces not possible in model and also not possible in real process</li>
<li><strong>False Positive:</strong> traces possible in model and but not possible in real process</li>
<li><strong>False Negative:</strong> traces not possible in model and but possible in real process</li>
</ul>

<p>보통은 평가 지표로 <em>recall</em>, <em>precision</em>, <em>F1 score</em> 등을 이용하는데 프로세스마이닝에서의 문제는 <em>real process</em> 에서 일어나는 <strong>FN, TP</strong> 를 알 수가 없다는 것이다.</p>

<p>따라서 <em>event log</em> 의 <strong>FN', TP'</strong> 를 이용해서 <em>replay fitness</em> 를 이용한다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?replay%5C%20fitness%20%5C%5C%5C%5C%20%3D%20%7BTP%27%20%5Cover%20TP%27%20&plus;%20FN%27%7D'  alt="" /></p>

<p>이 외에도 다양한 문제를 마주칠 수 있는데,</p>

<ul>
<li>보통 이벤트로그로 부터는 <strong>FN'</strong> 이 무엇인지 알 수 없다.</li>
<li>로그가 <em>possible traces</em> 의 일부분만 담고 있다.</li>
<li>Almost vs poorly fitting traces</li>
<li>루프가 있으면 무한히 많은 <em>possible traces</em> 가 있다.</li>
<li>Murphy's law for process mining: <strong>Anything is possible, so pobabilities matter</strong></li>
</ul>

<p>이런 문제점들은 다음의 기준들 사이에서 균형을 맞춰야 함을 알려준다.</p>

<ul>
<li><strong>fitness:</strong> observed behavior fits</li>
<li><strong>simplicity:</strong>  Occam's razor</li>
<li><strong>precision:</strong> avoiding underfitting</li>
<li><strong>generalization:</strong> avoiding overfitting</li>
</ul>

<p><img src='http://image.slidesharecdn.com/processminingchapter05processdiscovery-110510153220-phpapp01/95/process-mining-chapter-5-process-discovery-51-728.jpg?cb=1305062521'  alt="" /></p>

<p>여기서 <em>precision</em> 이 문제가 되는 경우라는 것은, <em>flower model</em> 처럼 필요 이상으로 가능한 모든 경우의 수를 도입한 모델이라 보면 된다. 다시 말해서 기존의 <em>log</em> 와는 완전히 다른 로그가 모델에 맞을 경우를 말한다. (<em>underfitting</em>) </p>

<p><br/> <br />
<img src='http://image.slidesharecdn.com/processminingchapter05processdiscovery-110510153220-phpapp01/95/process-mining-chapter-5-process-discovery-52-728.jpg?cb=1305062521'  alt="" /></p>

<p>반대로 <em>generalization</em> 이 낮은 모델은, 너무 <em>log</em> 에 맞추느라 복잡해진 경우를 말한다. (<em>overfitting</em>)</p>

<p>따라서 <em>traces</em> 의 수가 적은 경우에 너무 <em>overfitting</em> 하려고 하면 퍼포먼스가 낮아진다. 반대로 <em>traces</em> 수가 상당히 많다면, 다음에 들어올 <em>traces</em> 가 다른 형태일 확률이 낮아지므로 모델을 조금 더 <em>fitting</em> 하는 편이 낫다. (오히려 이 경우는 <em>overfitting</em> 이라 보기 어렵다.)</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter05processdiscovery-110510153220-phpapp01/95/process-mining-chapter-5-process-discovery-43-728.jpg?cb=1305062521'  alt="" /></p>

<p><br/></p>

<h3 id="representationalbias">Representational Bias</h3>

<blockquote>
  <p>Modeling language provides a bias</p>
</blockquote>

<p>예를 들어 <em>petri net</em> 같은 경우는 <em>concurrency</em> 를 모델링하는데 문제가 없는 반면 <em>transition system</em> 은 어렵다.</p>

<p><em>concurrency</em> 에 대해서도 생각해 볼 것이, <code>k = 10</code> 의 <em>parallel activities</em> 가 있다면 가능한 <em>traces</em> 는 <code>10! ~= 3600000</code> 이다.</p>

<p>반면 알파 알고리즘이 이 모델을 발견하려면 단지 <code>k(k-1</code> 의 <em>direct succession</em> 만 필요하다.</p>

<p>그러나 알파 알고리즘은 <em>optional(skip)</em> 이 있는 모델을 발견하지 못한다. 그리고, <em>silent transition(OR-joins)</em> 이 있는 모델에서의 가능한 <em>traces</em> 수는</p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Csum_%7Bi%20%3D%200%7D%5Ek%20%5Cbinom%7Bk%7D%7Bi%7D%20i%21'  alt="" /></p>

<p><em>WF-net</em> 같은 경우는 <em>unique label</em> 과 관련해서 문제가 있다.</p>

<p><code>L = [&lt;a, c, d&gt;^45, &lt;b, c, e&gt;^42, &lt;a, c, e&gt;^20]</code> </p>

<p>이 있을때, <em>WF-net</em> 은 <code>e</code> 두개인 모델을 발견할 것이다.</p>

<p>그리고 만약 <em>no indirected dependencies</em> 라면,</p>

<p><code>L = [&lt;a, c, d&gt;^45, &lt;b, c, e&gt;^42]</code> 에서 올바른 모델을 찾아내지 못할것이다.  (<code>a, b</code> 가 <code>d, e</code> 의 선택에 영향을 준다.)</p>

<blockquote>
  <p>Visualization of discovered model != representatoinal bias</p>
</blockquote>

<h4 id="whatisprocessdiscoverysodifficult">What is process discovery so difficult?</h4>

<ul>
<li>There are <strong>no negative examples</strong></li>
<li>Due to concurrency, loops, and choices the search space has a complex structure and the log typically contains only a fraction of all possible behaviors</li>
<li>There is no clear relation between the size of a model and its behavior</li>
</ul>

<p>특히 마지막 문제는, 일반적인 경우에선 작은 모델이 작은 로그를 만들어 내지만 프로세스 마이닝에선 작은 모델이라도 많은 로그를 만들 수 있다.</p>

<p>따라서 <em>representational bias</em> 를 잘 고려해서 모델을 선택해야 한다.</p>

<h3 id="businessprocessmodelandnotationbpmn">Business Process Model and Notation (BPMN)</h3>

<blockquote>
  <p>Representational bias impacts search space</p>
</blockquote>

<p><img src='http://upload.wikimedia.org/wikipedia/en/7/71/BPMN_gateway_types.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org/' >http://en.wikipedia.org/</a>)</p>

<p><em>exclusive OR</em> 은 둘 중 하나만 선택이고, <em>parallel</em> 은 모두로 분기한다. <em>inclusive OR</em> 은 하나 이상을 선택할 수 있다. 더 자세한 내용은 <a href='http://tynerblain.com/blog/2006/07/27/bpmn-gateways/' >BPMN Gateway</a> 를 참고하자.</p>

<p>보통 <em>inclusive OR join</em> 이 있으면 <em>synchronization</em> 이 된다. 그리고 앞쪽에 <em>inclusive OR split</em> 이 있고 뒤쪽에 <em>and join</em> 이 있으면 <em>deadlock</em> 이 있을 가능성이 높다.</p>

<p>일반적으로는 <em>OR join, split</em> 을 <em>AND join split</em> 을 결합해야 데드락이 없다.</p>

<p>참고로 <em>BPMN</em> 은 <em>UML</em> 이나 <em>Event-Driven Process Chains, EPCs</em> 와 비스무리하다. 아래는 <em>BPMN</em> 예제</p>

<p><img src='http://sehlhorst.smugmug.com/photos/84432593-M.jpg'  alt="" /></p>

<p align="center">(<a href='http://tynerblain.com/blog' >http://tynerblain.com/blog</a>)</p>

<p>보통은 <em>Petri net</em> 이나 <em>process tree</em> 로 작업하고 <em>BPMN</em> 으로 변환한다. <em>BPMN</em> 으로 바로 작업하는 경우는 흔하지 않다고 함.</p>

<h4 id="viciouscycleparadox">Vicious Cycle Paradox</h4>

<p>이부분은 당최 뭔 소린지 이해가.. 나중을 위해서 그림만 넣어놈.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter02processmodelingandanalysis-121219213500-phpapp02/95/process-mining-chapter02processmodelingandanalysis-14-638.jpg?cb=1355974557'  alt="" /></p>

<h3 id="dependencygraphs">Dependency Graphs</h3>

<p><img src='http://www.ijmijournal.com/cms/attachment/305569/1959182/gr6.gif'  alt="" /></p>

<p align="center">(<a href='http://www.ijmijournal.com/' >http://www.ijmijournal.com</a>)</p>

<p><em>footprint</em> 의 <em>casuality</em> 를 이용해서 <em>dependency graph</em> 를 만들 수 있다. <em>place</em> 가 없는 일종의 <em>Petri Net</em> 이라 볼 수 있다.</p>

<p>참고로 <em>casuality</em> 는</p>

<blockquote>
  <p>causality: <code>x -&gt; y</code>, iff <code>x &gt; y</code> and not <code>y &gt; x</code></p>
</blockquote>

<p><em>dependency graph</em> 는 의존성은 잘 보여주지만 <em>executable semantic</em> 이 없다. 각 노드는 <em>OR join, split</em> 의 <strong>fuzzy</strong> 로 볼 수 있다.</p>

<ul>
<li>Fuzzy models can be viewed as dependency graphs</li>
<li>No precise semantics  </li>
<li>Many ways to create dependency graphs often based on heuristics</li>
</ul>

<h3 id="casualnets">Casual Nets</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter02processmodelingandanalysis-121219213500-phpapp02/95/process-mining-chapter02processmodelingandanalysis-15-638.jpg?cb=1355974557'  alt="" /></p>

<p><em>Casual nets, C-nets</em> 은 <em>dependency graph</em> 에 <em>inpt, output</em> 을 붙여 <em>possible behavior</em> 를 보여준다.</p>

<p><br/></p>

<p>왜 <em>C-nets</em> 을 이야기 할까?</p>

<ul>
<li>Output of several mining techniques, e.g., the well-known huritics miner</li>
<li>Fits well with mainsteam languages (BPMN, EPCs, YAWL, etc.)</li>
<li>Able to model <strong>XOR, AND, OR</strong> but <strong>no sidlent steps or duplicate activities needed</strong></li>
<li>Loose interpretation. <strong>focus on replay semantics rather then executing semantics</strong></li>
</ul>

<p><em>C-nets</em> 에서는 <em>obligation</em> 이 <em>token</em> 의 역할을 한다. </p>

<blockquote>
  <p>Semantics are declarative <br />
  Only valid binding sequences are considered</p>
</blockquote>

<p><em>C-nets</em> 은 <em>WF-nets</em> 으로 쉽게 변환될 수 있다. <em>WF-nets</em> 에선 <em>deadlock</em> 이 있을 수 있는 반면 <em>C-nets</em> 에선 <em>valid seq</em> 만을 논하기 때문에 <em>deadlock</em> 은 이야기 하지 않는다.</p>

<blockquote>
  <p>Valid binding seqence of <em>C-net</em> is, Valid firing sequence of <em>WF-net</em></p>
</blockquote>

<p>그리고 <em>C-net</em> 이 <em>WF-nets</em> 보다 좀 더 표현적이다. 강의에서 나온 <em>C-nets</em> 같은 경우, 무한한 수의 <code>b, c, d</code> 를 표현하면서도 <em>order</em> 가 유지되고, <code>b, c, d</code> 가 같은 수로 반복된다.</p>

<h3 id="heuristicmining">Heuristic Mining</h3>

<p>(1) Learn a dependency graph by counting freq => <strong>dependency graph</strong> <br />
(2) Learn splits and joins => <strong>C-nets</strong> <br />
(3) visualize (and convert if needed) => <strong>BPMN, etc.</strong>  </p>

<h3 id="learningdependencygraphs">Learning Dependency Graphs</h3>

<p>알파 알고리즘을 이용하면 별별 문제가 다 생기는데, 휴리스틱하게 모델을 만들면 이런 문제는 좀 피할 수 있다.</p>

<p>그리고 한 가지 더 생각해 볼 문제는</p>

<blockquote>
  <p>Freqencies matter</p>
</blockquote>

<p>무슨 말인고 하니, 빈번한 로그만 <em>valid</em> 취급하면 <em>overfitting</em> 을 피할 수 있다. 알파 알고리즘에 적용하면, 좀 빈도수가 많은 것들만 <em>valid casuality</em> 로 취급할 수 있다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-12-728.jpg?cb=1305062477'  alt="" /></p>

<p><br/></p>

<h4 id="dependencymeasure">Dependency Measure</h4>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-15-728.jpg?cb=1305062477'  alt="" title="" />    </p>

<p><em>dependency measure</em> 값은 <code>-1 ~ 1</code> 인데, 1 에 가까울 수록 <em>casuality</em> 가 있다. 아래 그림은 <em>threshold</em> 를 넘는 <em>direct succession, casuality</em> 만 표시한 <em>dependency graph</em> 다. </p>

<p><em>threshold</em> 가 높아질 수록 그래프가 심플해진다.</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-17-728.jpg?cb=1305062477'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-18-728.jpg?cb=1305062477'  alt="" /></p>

<p><em>dependency measure</em> <code>a =&gt; b</code> <em>direct succession</em> <code>a &gt; b</code> 값을 이용해서 <em>sequence, AND split, join, XOR join, split</em> 등의 패턴을 파악할 수 있다.</p>

<p>게다가 <code>a =&gt; a</code> 도 값을 세기 때문에 <em>loop pattern</em> 도 발견할 수 있다</p>

<h3 id="learningcnets">Learning C-nets</h3>

<p>휴리스틱 마이닝의 두번째 단계는 <em>split, join</em> 등을 파악해서 <em>C-nets</em> 을 만드는 것이다.</p>

<p>어떻게 <em>split, join</em> 을 파악할까? 자주 사용하는 두 가지 접근 법이 있다.</p>

<p>(1) <strong>Heuristics approaches:</strong> using a <strong>time window</strong> before and after each activity. By counting sets of input and output acivities the bindings can be determinded (local decision)  </p>

<p>(2) <strong>Optimization approaches:</strong> based on replay, Given a set of possible input and ouput bindings one can see whether reality can be <strong>replayed property</strong>. The set of possible input and output bindings are finite, so a "best set bindings" can be determined using some goal function.</p>

<h4 id="approach1basedonheuristics">Approach 1: Based on heuristics</h4>

<p><em>dependency graph</em> 에서 볼 수 있듯이 각 <em>activity</em> 는 가능한 <em>input, output</em> 이 있다. 얼마나 자주 나오는지 세면 된다. 이 때 어느 범위까지 셀지를 <em>window size</em> 라 부른다.</p>

<p>예를 들어 <em>window size</em> <code>= 4</code> 면</p>

<pre><code>1 ... klbg[a]dhek ...  
2 ... lkgc[a]hedl ...  
3 ... kblg[a]ehdk ...  
4 ... klgb[a]dehk ...  
5 ... klkc[a]dkeh ...  
</code></pre>

<p>이 때 <code>b, c</code> 에 대해서 <code>{b} = 3, {c} = 2</code> 다. 요게 <em>input binding</em></p>

<p><code>{d, e} = 5</code> 다. 요게 <em>output binding</em>. 이 값들을 <em>depdency graph</em> 를 표시하면 된다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-19-728.jpg?cb=1305062477'  alt="" /></p>

<p><br/></p>

<p>이걸로 끝나는것은 아니고 <em>refinement</em> 가 필요하다.</p>

<ul>
<li>What if there are no corresponding acivities in the input or output window?</li>
<li>Noise filtering (remove infreq bindings)</li>
<li>Handling repeating activities (cut off window size)</li>
<li>Details are out of scope, but be aware of such complications when interpreting result</li>
</ul>

<h4 id="approache2optimizationproblem">Approache 2: Optimization problem</h4>

<ul>
<li>Evaluate all possible acivity bindings and take best one.</li>
<li>Based on the idea that ideally a trace can be <strong>replayed from the initial input state to the final state</strong></li>
<li>This <strong>can be checked</strong> precisely using various replay approaches</li>
<li>Hence, one can use approaches that simply <strong>try bindings exhaustively</strong></li>
</ul>

<p>간단히 말해서 가능한 모든 조합을 구하고, 말이 될 만한 <em>input, output</em> 을 <strong>replay</strong> 를 통해 골라내면 된다.</p>

<p>여기서 평가 기준은 <em>fitness simplicity, precision, generalization</em> 등이다. 시간이 너무 걸린다면 <em>randomize</em>, <em>genetic algorithm</em> 등을 이용할 수 있다. (generic 이 아니고 <em>genetic</em> 이다.)</p>

<h3 id="learningtransitionsystem">Learning Transition System</h3>

<p>지금까지 모델을 만들기 위해 다음의 방법을 배웠다.</p>

<ul>
<li>Alpha algorithm</li>
<li>Heuristic mining <em>dep graph, C-net</em></li>
</ul>

<p>이번시간엔 <em>state-based regions</em> 를 배워보자.</p>

<p>(1) Learning a transition system using a state abstraction => <em>transition system</em>  </p>

<p>(2) Transform the transition system into an equivalent Petri net => <em>Petri net</em>  </p>

<p>(3) visualize (and convert if needed) => <em>BPMN, etc.</em></p>

<p>트랜지션 시스템을 학습하는 방법은, 현재 <em>state</em> 를 기준으로 <em>past, future</em> 를 보고 이 두가지를 합치면 된다. <del>말은 언제나 쉽다.</del> </p>

<p>예를 들어 <code>a b c d c d c d e ^ f a g h h h i</code> 를 기준으로, 현재 상태가 <code>^</code> 라 하면 </p>

<ul>
<li><strong>past:</strong> <code>a b c d c d c d e</code></li>
<li><strong>future:</strong> <code>f a g h h i</code></li>
</ul>

<p>여기서 <em>order</em> 는 무시하고 <em>frequency</em> 만 고려하면 <em>past</em> 는 </p>

<p><code>[a, b, c^3, d^3, e]</code> 가 된다. 만약에, 여기서 <em>time window</em> (<strong>k-tail</strong>) 를 이용하면 <code>[c, d^2, e]</code> 가 된다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-121219213521-phpapp01/95/process-mining-chapter06advancedprocessdiscoverytechniques-29-638.jpg?cb=1355974629'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-121219213521-phpapp01/95/process-mining-chapter06advancedprocessdiscoverytechniques-30-638.jpg?cb=1355974629'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-121219213521-phpapp01/95/process-mining-chapter06advancedprocessdiscoverytechniques-31-638.jpg?cb=1355974629'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-121219213521-phpapp01/95/process-mining-chapter06advancedprocessdiscoverytechniques-32-638.jpg?cb=1355974629'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-33-728.jpg?cb=1305062477'  alt="" /></p>

<h4 id="postprocessing">Postprocessing</h4>

<ul>
<li>remove <em>self-loop</em></li>
<li>imporve <em>diamond structure</em> (for missing interleavings)</li>
<li>merge <em>similar states</em> based on inputs</li>
</ul>

<h3 id="usingregionstodiscoverconcurrency">Using Regions to Discover Concurrency</h3>

<p>이제 <em>transition system</em> 을 <em>Petri net</em> 으로 변경하면 된다. </p>

<p>기본적인 아이디어는 <em>transition system</em> 의 <em>subset</em> 이 <em>Petri net</em> 의 <em>place</em> 의 해당한다는 것이다. 이는 당연한데 트랜지션 시스템에서 어떤 상태는, 이 전까지의 상태의 반영이고, 이건 <em>place</em> 다.</p>

<blockquote>
  <p>State-based regions correspond to places</p>
</blockquote>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-34-728.jpg?cb=1305062477'  alt="" /></p>

<p>이 때 <em>state-based region</em> 의 <em>enter, exit</em> 를 확인 하면 쉽게 <em>place</em> 를 만들 수 있다.</p>

<blockquote>
  <p>All states need to be reachable</p>
  
  <p>A region is a set of states, such that, if a transition <strong>exits</strong> the region, then all equally labeled trasition <strong>exit</strong> the region</p>
  
  <p>and If a transition <strong>enters</strong> the region, then all equally labeled transitions <strong>enter</strong> the region</p>
  
  <p>All events not entering or exiting the region <strong>do not cross</strong> the region</p>
</blockquote>

<p><code>n</code> 개의 <em>concurrent activity</em> 가 있으면 <code>2^n</code> 개의 <em>state</em> 가 생긴다. 이 때 몇 개의 <em>region</em> 이 생길까? </p>

<p>아무리 많아봐야 1 개의 트랜지션 라벨만 <em>crossing</em> 할 수 있으므로, <code>n</code> <em>split</em> 을 만들 수 있고 여기에 <em>empty</em> 까지 더하면 <code>2(n + 1)</code> 이다.</p>

<p>직선인 <em>petri net</em> 의 경우는 더 심각하다. 모든 <em>transition</em> 의 <em>subset</em> 이 <em>region</em> 이므로 <code>2^(n+1)</code> 이 된다. 따라서 <em>non-trivial minimal region</em> 만 포함해야 한다.</p>

<p><em>Petri net</em> 을 만드는 알고리즘은</p>

<p>(1) For each transition label in the transition system, a <strong>transition</strong> is added to the Petri net <br />
(2) The <strong>minimal non-trivial regions</strong> are computed <br />
(3) For each minimal non-trivial region in the transition system, a <strong>place</strong> is added to the Petri net. <br />
(4) The coressponding arcs are generated <br />
(5) A <strong>token</strong> is aded to each place that corresponds to a region containing the initial state</p>

<p><code>L = [&lt;a, c, d&gt;^45, &lt;b, c, e&gt;^42]</code></p>

<p>의 경우 알파 알고리즘은 <em>non directed dependency</em> 를 발견하지 못하는데, 트랜지션 시스템을 만들고, <em>state-based region</em> 을 이용하면 올바른 <em>petri net</em> 을 만들 수 있다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://issuu.com/wmpvanderaalst/docs/procminbook?e=14081202/9829483' >Book: Process Mining</a> <br />
(2) <a href='https://d396qusza40orc.cloudfront.net/procmin/lecture_slides/22-Petri%20Nets%20%281%29.pdf' >Slide</a> <br />
(3) <strong>Process Mining: Data science in Action</strong> by Wil van der Aalst <br />
(4) <a href='http://1ambda.github.io/www.processmining.org' >www.processmining.org</a> <br />
(5) <a href='http://fluxicon.com/' >http://fluxicon.com</a> <br />
(6) <a href='http://crsouza.blogspot.kr/2009/12/performing-discriminant-power-analysis.html' >Confusion matrix</a> <br />
(7) <a href='http://en.wikipedia.org/wiki/Business_Process_Model_and_Notation' #mediaviewer/File:BPMN_gateway_types.png">Wikipedia - BPMN</a> <br />
(8) <a href='http://tynerblain.com/blog/2006/07/27/bpmn-gateways/' >BPMN Gateway</a> <br />
(9) <a href='http://www.ijmijournal.com/' >http://www.ijmijournal.com</a></p>]]></description><link>http://1ambda.github.io/process-mining-week3/</link><guid isPermaLink="false">43e49375-88bc-4ec0-aff0-93f098b34d10</guid><category><![CDATA[coursera]]></category><category><![CDATA[process mining]]></category><category><![CDATA[BPMN]]></category><category><![CDATA[dependency graph]]></category><category><![CDATA[C-nets]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 09 Dec 2014 10:44:29 GMT</pubDate></item><item><title><![CDATA[Intro to Computational Thinking and Data Science 4]]></title><description><![CDATA[<p>그래프는 네트워크를 표현하는 것 뿐만 아니라, <em>state</em> 를 표현할 수 있다.</p>

<ul>
<li>Nodes represent states of system</li>
<li>Edges represent actions that cause a change of state</li>
</ul>

<p>그러면 그래프 문제는 </p>

<ul>
<li>Finding sequence of actions to convert system to desired state</li>
</ul>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/8puzzle_example.svg/2000px-8puzzle_example.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org/' >http://en.wikipedia.org</a>)</p>

<p><em>8 puzzle</em> 도 이렇게 그래프 문제로 변환할 수 있다. 그런데, <code>9! = 362880</code> 의 <em>node</em> 와 노드당 <code>2~4</code> 개의 <em>edge</em> 를 가지고 있으므로 문제의 사이즈가 어마어마하게 커진다. 거의 백만개의 <em>edge</em> 를 가진다.</p>

<h3 id="animplicitgraph">An Implicit Graph</h3>

<p>그래서, 처음부터 모든 <em>state</em> 를 만들기 보다는 초기 상태로부터 <em>action</em> 을 취해가면서 <em>desired state</em> 를 찾는 방식으로 해결하자.</p>

<p>퍼즐의 상태를 문자열로 표현하면</p>

<pre><code class="python">class puzzle(object):  
    def __init__(self, order):
        self.label = order

        for i in range(9):
            if order[i] == '0':
                self.spot = i
                return None

    def transition(self, to):
        currentLabel = self.label
        blank = self.spot
        # current slot value which will be filled with blank
        current = str(currentLabel[to]) 
        nextLabel = ''

        for i in range(9):
            if i == to:
                nextLabel += '0'
            elif i == blank:
                nextLabel += current
            else:
                nextLabel += str(currentLabel[i])

        return puzzle(nextLabel)

    def __str__(self):
        return "{0} {1} {2}\n{3} {4} {5}\n{6} {7} {8}\n".format(self.label[0],
                                                                self.label[1],
                                                                self.label[2],
                                                                self.label[3],
                                                                self.label[4],
                                                                self.label[5],
                                                                self.label[6],
                                                                self.label[7],
                                                                self.label[8])
</code></pre>

<p>그리고 각 슬롯의 이동 가능한 방향을 딕셔너리로 만들면</p>

<pre><code class="python">shiftDict = {}  
shiftDict[0] = [1, 3]  
shiftDict[1] = [0, 2, 4]  
shiftDict[2] = [1, 5]  
shiftDict[3] = [0, 4, 6]  
shiftDict[4] = [1, 3, 5, 7]  
shiftDict[5] = [2, 4, 8]  
shiftDict[6] = [3, 7]  
shiftDict[7] = [4, 6, 8]  
shiftDict[8] = [5, 7]  
</code></pre>

<p>이제 <em>state</em> 를 변경해 나아가면서 그래프를 만들 수 있다 <em>state</em>, 즉 <em>node</em> 를 변경해 나아가면서 그래프를 탐색하는 방법은 2개가 있는데, <em>BFS, DFS</em> 다. 코드는 거의 유사하다. 스택을 쓰냐 큐를 쓰냐의 차이다.</p>

<pre><code class="python">def notInPath(state, path):  
    for s in path:
        if s.label == state.label:
            return False

    return True


def BFS(start, end, q=[]):  
    initPath = [start]
    q.append(initPath)

    while len(q) != 0:
        currentPath = q.pop(0)
        lastState = currentPath[len(currentPath) - 1]

        if lastState.label == end.label:
            return currentPath

        for s in shifts[lastState.spot]:
            nextState = lastState.transition(s)

            if notInPath(nextState, currentPath):
                nextPath = currentPath + [nextState]
                q.append(nextPath)

    return None


def DFS(start, end, stack=[]):  
    initPath = [start]
    stack.insert(0, initPath)

    while len(stack) != 0:
        currentPath = stack.pop(0)
        lastState = currentPath[len(currentPath) - 1]

        if lastState.label == end.label:
            return currentPath

        for s in shifts[lastState.spot]:
            nextState = lastState.transition(s)

            if notInPath(nextState, currentPath):
                nextPath = currentPath + [nextState]
                stack.insert(0, nextPath)

    return None
</code></pre>

<p>테스트는</p>

<pre><code class="python">def test():  
    goal = puzzle('012345678')
    test1 = puzzle('125638047')
    answer = BFS(test1, goal)

    for state in answer:
        print state
</code></pre>

<p>비교해 보면 <em>BFS</em> 가 훨씬 빠르다.</p>

<h3 id="maximumcliques">Maximum Cliques</h3>

<blockquote>
  <p>For some problems, finding sugraphs of a graph that are complete can be important</p>
</blockquote>

<p>여기서 <em>complete</em> 란 노드가 다른 노드 모두와 연결되어 있다는 뜻이다.</p>

<ul>
<li>Finding sets of people in a social network that all know each other</li>
<li>Finin subjects in an infected population that all have had contact with one another</li>
</ul>

<p>두 번째 예제는 <em>complete subgraph</em> 를 찾는 것의 중요성을 잘 보여준다.</p>

<p><em>clique</em> 는 communication networks, gene expression data 등에도 이용할 수 있다.</p>

<h4 id="bruteforce">Brute Force</h4>

<p><em>maximum clique</em> 문제를 <em>brute force</em> 로 풀려면, 가능한 모든 서브 그래프를 찾고, <em>clique</em> 인지 판별하면서 큰 사이즈의 <em>clique</em> 를 유지하면 된다.</p>

<p>모든 서브 그래프를 찾을려면, <a href='http://1ambda.github.io/edx-600-2x-3/' >지난시간</a> 에 <em>knapsack problem</em> 을 풀 때 이용했던 <em>power set</em> 을 도입하면 된다.</p>

<p><em>knapsack</em> 문제도 <em>brute force</em> 로 풀기 위해서 가능한 모든 집합을 구했었다. 후에는 <em>search space</em> 를 줄이기 위해 <em>decision tree</em> 를 도입하고, 반복 계산을 피하기 위해 <em>memoization</em> 이용했었다.</p>

<p><em>clique</em> 문제도 마찬가지로 각 노드를 숫자로 표현할 수 있으므로 <code>n</code> 자리의 이진수를 만들어 <em>power set</em> 을 생성할 수 있다. 지난 시간에 이용했었던 대강의 로직은 </p>

<pre><code class="python">count = 2 ** len(nodes)

binStrs = []

for i in range(count):  
  binStrs.append(int2bin(i, len(nodes))

powerSet = []

for bs in binStrs:  
  subGraph = []

  for i range(len(bs)):
    if bs[i] == '1':
      subGraph.append(nodes[i])

  powerSet.append(subGraph)

return powerSet  
</code></pre>

<p>이번시간엔 재귀를 이용해서 <em>power set</em> 을 구해보자. 하스켈로 로직을 표현하면,</p>

<pre><code class="haskell">powerset [] = [[]]  
powerset (x:xs) = xs' ++ map (x:) xs'  
  where xs' = powerset xs
</code></pre>

<p>따라서 파이선 코드는</p>

<pre><code class="python">def powerSet(xs):  
    if len(xs) == 0:
        return [[]]

    else:
        # xs = head:tail
        head = xs[0]
        tail = xs[1:]

        prev = powerSet(tail)
        incl = map(lambda sub: sub + [head], prev)
        return prev + incl
</code></pre>

<p>이걸 이용해 모든 <em>sub graph</em> 를 만들고, <em>clique</em> 인지 검사하는 함수를 만들면</p>

<pre><code class="python">def powerGraph(graph):  
    nodes = []

    for n in graph.nodes:
        nodes.append(n)

    pSet = powerSet(nodes)
    return pSet


def isClique(graph, subGraph):  
    for n in subGraph:
        for m in subGraph:
            if not m == n:
                if n not in graph.childrenOf(m):
                    return False

    return True


def maxClique(graph):  
    maximum = None
    maxLen = 0
    subGraphs = powerGraph(graph)

    for sub in subGraphs:
        if isClique(graph, sub):
            if len(sub) &gt; maxLen:
                maximum = sub
                maxLen = len(sub)

    return maximum
</code></pre>

<p><a href='https://courses.edx.org/c4x/MITx/6.00.2_2x/asset/clique.py' >지난시간에 작성했던 Graph 코드</a> 는 여기로, </p>

<p>테스트 코드는 </p>

<pre><code class="python">def testGraph():  
    nodes = []
    for name in range(5):
        nodes.append(Node(str(name)))
    g = Graph()
    for n in nodes:
        g.addNode(n)
    g.addEdge(Edge(nodes[0],nodes[1]))
    g.addEdge(Edge(nodes[1],nodes[2]))
    g.addEdge(Edge(nodes[2],nodes[0]))
    g.addEdge(Edge(nodes[2],nodes[4]))
    g.addEdge(Edge(nodes[4],nodes[3]))
    return g


trialGraph = testGraph()  
myClique = maxClique(trialGraph)  
</code></pre>

<p><code>myClique</code> 를 출력하면, <em>node</em> 가 3개 나와야 한다.</p>

<h3 id="machinelearning">Machine Learning</h3>

<blockquote>
  <p><strong>Automating automation</strong></p>
  
  <p>Computer programs can automatically follow rules. <br />
  How do we determine these rules automatically?</p>
  
  <p><strong>ML fources on getting computers to program themselves</strong></p>
  
  <p>Let the data do the work. <br />
  Automatically generate programs that create useful outputs from data</p>
</blockquote>

<p>전통적인 프로그래밍에선 <em>data</em> 와 <em>program</em> 을 넣고 <em>output</em> 을 기대했다면, </p>

<p><em>machine learning</em> 에서는 <em>data, output</em>  을 넣고 <em>program</em> 을 만든다. 이 프로그램은 다음번에 <em>data</em> 가 들어왔을 때 <em>output</em> 을 만들어 낸다. 다시 말해서 머신러닝은 일종의 <em>generalization</em> 이다.</p>

<blockquote>
  <p><strong>Supervised</strong></p>
  
  <p>Given a set of feature/label pairs, find a rule that predicts the label associated with a previously unseen input</p>
  
  <p><strong>Unsupervied</strong></p>
  
  <p>Given a set of feature vectors (without labels), group them into "natural clusters"</p>
</blockquote>

<p>예를 들어 다음은 <em>supervised learning</em> 이다.</p>

<blockquote>
  <p>A group of 1000 students are asked for a sample of their handwriting. Researchers make pairs of (handwritten text, typed text). Given a new handwriting sample from a new student, we want to determine what the typed version of the handwriting sample would be.</p>
</blockquote>

<h3 id="clustering">Clustering</h3>

<ul>
<li>Low intra-cluster dissimilarity</li>
<li>High inter-cluster dissimilarity</li>
</ul>

<p>간단하긴 한데, 연산 비용이 비싸다. <em>k-means</em> 와 <em>hierarchical clustering</em> 을 살펴보자.</p>

<h4 id="hierarchicalclustering">Hierarchical Clustering</h4>

<p>(1) Start by assigning each item to a cluster, so that if you have <code>N</code> items, you now have <code>N</code> clusters, each containing just one item.</p>

<p>(2) Find the closest (most similar) pair of clusters and merge them into a single cluster, so that now you have one cluster fewer.</p>

<p>(3) Continue the process until all items are clustered into a single cluster of size <code>N</code></p>

<p><img src='http://www.alanfielding.co.uk/multivar/images/dend5.gif'  alt="" /></p>

<p align="center">(<a href='http://www.alanfielding.co.uk/' >http://www.alanfielding.co.uk</a>)</p>

<blockquote>
  <p><strong>Linkage Criteria</strong></p>
  
  <p>in <strong>single-linkage</strong> clustering (also called the <em>connectedness</em> or <em>minimum</em> method), we consider the distance between one cluster and another cluster to be equal to the shortest distance from any member of one cluster to any member of th other cluster</p>
  
  <p>in <strong>complete-linkage</strong> clustering (also called the <em>diameter</em> or <em>maximum</em> method), we consider the distance between one cluster and another cluster to be equal to th greatest distance from any member of one cluster to any member of the other cluster</p>
  
  <p>in <strong>average-linkage</strong>, we consider the distance between one cluster and another cluster to be equal to th average distance from any member of one cluster to any member of the other cluster. A slight variant of this uses the median instead of the mean</p>
</blockquote>

<p><em>single-linkage</em> 클러스터 간 거리를 두 클러스터 사이의 최소 거리로, <em>complete-linkage</em> 는 최대 거리로, <em>average-linkage</em> 는 평균 거리로 본다.</p>

<pre><code class="python">    def singleLinkageDist(self, other):
        """ Returns the float distance between the points that 
        are closest to each other, where one point is from 
        self and the other point is from other. Uses the 
        Euclidean dist between 2 points, defined in Point."""
        minDist = float("inf")
        for p1 in self.points:
            for p2 in other.points:
                dist = p1.distance(p2)
                if dist &lt; minDist:
                    minDist = dist

        return minDist

    def maxLinkageDist(self, other):
        """ Returns the float distance between the points that 
        are farthest from each other, where one point is from 
        self and the other point is from other. Uses the 
        Euclidean dist between 2 points, defined in Point."""
        maxDist = float(0)
        for p1 in self.points:
            for p2 in other.points:
                dist = p1.distance(p2)
                if dist &gt; maxDist:
                    maxDist = dist

        return maxDist

    def averageLinkageDist(self, other):
        """ Returns the float average (mean) distance between all 
        pairs of points, where one point is from self and the 
        other point is from other. Uses the Euclidean dist 
        between 2 points, defined in Point."""
        dists = []
        for p1 in self.points:
            for p2 in other.points:
                dists.append(p2.distance(p1))

        return sum(dists) / float(len(dists))
</code></pre>

<h3 id="kmeansclustering">K-Means Clustering</h3>

<p><img src='http://latex.codecogs.com/gif.latex?%5Csum_%7Bc%3D1%7D%5EK%20%5Csum_%7Bx%5C%20%5Cin%5C%20c%7D%20%5Cleft%20%5C%7C%20x%20-%20%5Cmu_c%20%5Cright%20%5C%7C%5E2'  alt="" /></p>

<ul>
<li>Final result can depend upon initial centroids</li>
<li>Greedy algorihm can find different local optima</li>
<li>Choosing the <em>wrong</em> <code>K</code> can lead to nonsense</li>
</ul>

<p>따라서</p>

<ul>
<li>Use priori knowledge about application domain</li>
<li>Try multiple times</li>
</ul>

<p><em>hierarchical</em> 과 비교하면</p>

<blockquote>
  <p>Hierarchical looks at different numbers of clusters From 1 to n</p>
  
  <p>K-means looks at many ways of createing k clusters.</p>
</blockquote>

<p><em>hierarchical</em> 은 좀 느린편이고 <em>deterministic</em> 이다. 반면 <em>K-means</em> 는 비교적 빠르고, <em>stochastic</em> 이다.</p>

<p>아래는 <em>K-means</em> 로 분류하기 어려운 몇 가지 예제들</p>

<p><img src='https://courses.edx.org/c4x/MITx/6.00.2_2x/asset/k1.png'  alt="" /></p>

<p><img src='https://courses.edx.org/c4x/MITx/6.00.2_2x/asset/k3.png'  alt="" /></p>

<p align="center">(<a href='https://courses.edx.org/c4x/MITx/6.00.2_2x' >https://courses.edx.org/c4x/MITx/6.00.2_2x</a>)</p>

<h3 id="scaling">Scaling</h3>

<p><em>odd ratio</em> 는 <em>acutal / expected</em> 값인데, 1에 가까우면 클러스터링이 랜덤에 비해 별로 나을게 없다는 소리다. (좋은 클러스터링이 아니란 뜻)</p>

<p>강의에서 나온 환자 예제는 이 값이 1에 근접하는데, 이는 <em>HR, age</em> 값이 단위가 커서 이 <em>feature</em> 에 영향을 많이 받기 때문이다.</p>

<p>따라서 평균 0, 표준편차 1을 가지도록 모든 <em>feature</em> 를 스케일링 하고 다시 돌리면  <em>odd ratio</em> <code>0.18, 1.45</code> 의 두 클러스터를 얻을 수 있다. 하나는 <em>heart attack</em> 이 잘 안올 환자, 다른 하나는 위험한 환자.</p>

<p>아래 예제는 스케일링 하면 안되는 경우</p>

<blockquote>
  <p>The percent concentration of a virus in a random sampling of healthy and unhealthy people.</p>
  
  <p>The angle of refraction of light (degree that light bends) observed when entering water vs. glass vs a diamond.</p>
</blockquote>

<h3 id="statisticalfallacies">Statistical Fallacies</h3>

<p>세상에는 3 종류의 거짓말이 있다고 한다.</p>

<ul>
<li>LIES</li>
<li>DAMNED LIES</li>
<li><strong>STATISTICS</strong></li>
</ul>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Anscombe%27s_quartet_3.svg/638px-Anscombe%27s_quartet_3.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org/wiki/Anscombe' s_quartet'>http://en.wikipedia.org/wiki/Anscombe's_quartet</a>)</p>

<p>보면 데이터가 정말 다르게 분포해 있지만, <em>mean, variance, correlation, linear regression</em> 이 동일하다.</p>

<p>흔한 오류 중 하나로, <em>correlation => causation</em> 도 있다. </p>

<p>학교가 문을 여는 시즌에, 독감이 많이 유행한다고 해서 상관 관계가 있다고 단정짓긴 어렵다. 어쩌면 다른 요인이 있을지도 모른다.</p>

<p><em>non response bias</em> 도 생각해봐야 한다. 예를 들어 전화조사에서, 응답자와 비응답자의 정치 성향이 다를 수도 있다는 것이다.</p>

<h3 id="dataenhancement">Data Enhancement</h3>

<p><em>texas sharpshotter fallacy (텍사스 명사수의 오류)</em> 란 것도 있다. <a href='http://en.wikipedia.org/wiki/Texas_sharpshooter_fallacy' >위키</a> 에서 인용하면</p>

<blockquote>
  <p>The Texas sharpshooter fallacy is an informal fallacy which is committed when differences in data are ignored, but similarities are stressed.</p>
</blockquote>

<p>텍사스의 총잡이가 헛간에 총을 마구마구 쏜 후, 밀집한 지역 중심으로 원을 그리면! 그 총잡이는 명사수처럼 보이게 된다는 것에서 유래한 오류다.</p>

<p>바꿔 말하면, 우연도 필연으로 해석한다는 것이다. (존재하지도 않는 패턴을 찾으려고 하는것에 비유하기도 함)</p>

<h3 id="references">References</h3>

<p>(1) <em>MIT 6.00.2 2x</em> in <strong>edx</strong> <br />
(2) <a href='http://en.wikipedia.org/wiki/Heuristic_function' >Wikipedia: Huristic Function</a> <br />
(3) <a href='http://www.alanfielding.co.uk/multivar/dend.htm' >http://www.alanfielding.co.uk</a> <br />
(4) <a href='http://en.wikipedia.org/wiki/Anscombe' s_quartet">Wikipedia - Anscombe's quartet</a></p>]]></description><link>http://1ambda.github.io/edx-600-2x-4/</link><guid isPermaLink="false">a07909c0-49d7-4a0a-9dd8-5e52550b331f</guid><category><![CDATA[edx]]></category><category><![CDATA[python]]></category><category><![CDATA[graph]]></category><category><![CDATA[hierarchical clustering]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 09 Dec 2014 03:23:13 GMT</pubDate></item><item><title><![CDATA[Machine Learning, Week 9]]></title><description><![CDATA[<p>이번시간엔 <em>anomaly detection</em> 과 <em>recommender system</em> 을 배운다.</p>

<h3 id="anomalydectection">Anomaly Dectection</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361236753_7590.png'  alt="" /></p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361236757_2205.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p><em>anomaly</em> 는 정상집단에서 떨어진 데이터라 보면 된다. 공장에서 품질이 떨어지는 제품을 골라낼때 사용할 수 있는데, 위 그림은 비행기 엔진 공장을 예로 들어 설명한다.</p>

<p>데이터로부터 <code>p(x)</code> 를 만들어, 검사할 데이터가 <em>threshold</em> 를 넘는지 안넘는지 검사해 <em>anomaly</em> 로 판정할 수 있다.</p>

<p>참고로, <em>anomaly</em> 가 너무 많으면, <em>false positive</em> 가 높은 것인데 이 때는  <em>threshold</em> 를 줄이면 된다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361236761_2830.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p><em>anomaly detection</em> 은 <em>fraud detection</em> 에 많이 사용된다. 데이터로부터 모델 <code>p(x)</code> 를 만들고 <em>unusual user</em> 를 검사하기 위해 <code>p(x) &lt; e</code> 인지 검사하면 된다.</p>

<p>이외에도 항공기 엔진 예제처럼 제품의 품질 관리나, 데이터 센터에서의 노드 과부하 탐지등에 사용할 수 있다.</p>

<h3 id="gaussiandistribution">Gaussian Distribution</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361236829_8964.png'  alt="" /></p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361236829_8964.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p><em>gaussian density</em> 공식은</p>

<p><img src='http://latex.codecogs.com/gif.latex?P%28x%3B%20%5Cmu%2C%20%5Csigma%5E2%29%5C%5C%20%5C%5C%20%3D%20%7B1%20%5Cover%20%5Csqrt%7B2%5Cpi%5Csigma%5E2%7D%7D%20%5C%20%5Cexp%28-%20%7B%28x%20-%20%5Cmu%29%5E2%20%5Cover%202%5Csigma%5E2%7D%29'  alt="" /></p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361236839_1788.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p>평균과 분산은</p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Cmu%20%3D%20%7B1%20%5Cover%20m%7D%20%5C%20%5Csum_%7Bi%20%3D%201%7D%5Em%20x%5E%7B%28i%29%7D'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Csigma%5E2%20%3D%20%7B1%20%5Cover%20m%7D%20%5Csum_%7Bi%20%3D%201%7D%5Em%20%28x%5E%7B%28i%29%7D%20-%20%5Cmu%29'  alt="" /></p>

<p><br/></p>

<h3 id="anomalydetectionalgorithm">Anomaly Detection Algorithm</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361236899_7015.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p>각 <em>feature</em> 가 가우시안 분포를 따른다고 하면, </p>

<p><img src='http://latex.codecogs.com/gif.latex?p%28x%29%20%5C%5C%20%5C%5C%20%3D%20p%28x_1%3B%20%5Cmu_1%2C%20%5Csigma_1%5E2%29%5C%20p%28x_2%3B%20%5Cmu_2%2C%20%5Csigma_1%5E2%29%20%5Ccdots%5C%20p%28x_n%3B%20%5Cmu_n%2C%20%5Csigma_1%5En%29%20%5C%5C%20%5C%5C%20%3D%20%5Cprod_%7Bj%20%3D%201%7D%5En%20p%28x_j%3B%20%5Cmu_j%2C%20%5Csigma_j%5E2%29'  alt="" /></p>

<p>이렇게 가정하려면, 각 <em>feature</em> 가 독립적이어야 하지만 실제로는 독립적이지 않더라도 어느정도 동작한다. 이 때 </p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Cmu_j%20%3D%20%7B1%20%5Cover%20m%7D%20%5Csum_%7Bi%20%3D%201%7D%5Em%20x_j%5E%7B%28i%29%7D'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Csigma_j%5E2%20%3D%20%7B1%20%5Cover%20m%7D%20%5Csum_%7Bi%20%3D%201%7D%5Em%20%7B%28x_j%5E%7B%28i%29%7D%20-%20%5Cmu_j%29%5E2%7D'  alt="" /></p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361236904_6921.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p>따라서 <code>p(x)</code> 는 아래 식이 된다. <code>p(x)</code> 는 <em>feature</em> 가 나올 확률로 이해하면 된다. 이 때 <code>p(x)</code> 가 상당히 작으면, 평균에 가깝지 않은 <em>feature</em> 가 많이 나왔다는 뜻이므로 <em>anomaly</em> 라 볼 수 있다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?p%28x%29%20%5C%5C%20%5C%5C%20%3D%20%5Cprod_%7Bj%3D1%7D%5En%20%5C%20%7B1%20%5Cover%20%5Csqrt%7B2%5Cpi%5Csigma_j%5E2%7D%7D%20%5C%20%5Cexp%28-%7B%28x_j%20-%20%5Cmu_j%29%5E2%20%5Cover%202%5Csigma_j%5E2%7D%29'  alt="" /></p>

<p><br/></p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361236907_7102.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p>두 <em>feature</em> <code>x1, x2</code> 의 가우시안 분포를 3차원으로 조합하면 <code>p(x)</code> 가 좌측 하단 3차원 원뿔의 높이가 된다.</p>

<h3 id="evaluatinganomalydetection">Evaluating Anomaly Detection</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361236992_3664.png'  alt="" /></p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361236996_4034.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p><em>anomaly</em> 를 잘 나타낼거 같은 <em>feature</em> 를 골라내고, 이를 이용해 모델을 만든다. </p>

<p>우리가 가진 데이터가 <em>anomaly</em> 를 알려주는 <code>y</code> 가 있다면, 위 그림처럼 <em>training set</em> 으로 <em>non-anomalous</em> 을 이용하고, <em>CV, Test Set</em> 으로 나머지를 반반씩 분할하면 된다.</p>

<p>즉 <em>good example</em> 로 모델을 만들고, <em>anomaly</em> 가 섞여있는 <em>cv, test set</em> 으로 평가한다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361237001_5250.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p>이 때 <em>skewed classess</em> 이기 때문에 (<code>y = 0</code> 이 대다수, <code>y = 1</code> 은 희박) 단순히 정확도로 평가하긴 좀 무리가 있다. <em>precision, recall, f1 score</em> 등을 이용해 평가해야 한다.</p>

<p><em>threshold</em> 인 <code>e</code> (엡실론) 를 고르기 위해 <em>cross validation</em> 을 이용할 수 있다. <em>f1 score</em> 를 최대화 하는 <code>e</code> 를 고른다거나.</p>

<h3 id="anomalydectectionvssupervisedlearning">Anomaly Dectection vs Supervised Learning</h3>

<p><code>y</code> 값이 있는 데이터라면, 왜 <em>supervised learning</em> 을 이용하지 않을까? </p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361242897_8389.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<h4 id="anomalydetection">Anomaly Detection</h4>

<p><em>anomaly detection</em> <em>skewed class</em> 가 있을 때 사용한다.</p>

<blockquote>
  <p>Many different <strong>types</strong> of anomalies. Hard for any algorithm to learn from positive examples what the anomalies look like</p>
  
  <p>Future anomalies may look nothing like any of the anomalous examples we've seen so far</p>
</blockquote>

<p>보면 알겠지만 <em>anomaly</em> 가 굉장히 다양할 수 있기 때문에 <em>anomaly</em> 를 특정 형태로 구분짓는 알고리즘을 쓰긴 좀 힘들다.</p>

<p>게다가, 가지고 있는 데이터 셋에서 보지 못했던 새로운 종류의 <em>anomaly</em> 가 나올 수도 있다.</p>

<h4 id="supervisedlearning">Supervised Learning</h4>

<p><em>positive, negative example</em> 이 많을 때 사용한다.</p>

<blockquote>
  <p>Enough positive examples for algorithms to get a sense of what positive examples are like, futre positive example likly to be similar to ones in training set</p>
</blockquote>

<p><em>supervised learning</em> 에서 <em>positive example</em> 은 어떤 특정 형태기 때문에, 미래에 발견할 <em>positive example</em> 도 비슷한 형태라 생각될 때 사용한다.</p>

<p><em>SPAM filtering</em> 에서는 다양한 타입의 <em>positive example</em> 이 있어도, 우리가 충분한 양의 <em>positive example</em> 이 있기 때문에 커버할 수 있어 <em>supervised learning</em> 을 사용한다.</p>

<p><br/></p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361243087_2169.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p><br/></p>

<h3 id="choosingwhatfeaturestouse">Choosing What Features to Use</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361244210_3429.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p><em>feature</em> 의 분포가 가우시안이면 고맙지만, 아닐경우 변환이 필요하다. 왼쪽 아래 분포에 로그를 씌우면, 가우시안 분포 비슷하게 보인다.</p>

<p>다른 방법으로는 <code>log(x_2 + c)</code>, <code>sqrt(x_3)</code> 등등이 있다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361245473_5316.png'  alt="" /></p>

<p>흔한 에러는 <code>p(x)</code> 가 <em>normal, anomalous</em> 에 대해서 모두 높은 경우인데, 슬라이드의 아래쪽에서 볼 수 있듯이 <code>x2</code> 라는 <em>feature</em> 를 만들어서 <em>anomaly</em> 를 발견하는 알고리즘을 만들 수 있다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361246077_9679.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p><em>anomaly</em> 를 위한 <em>feature</em> 를 고를 때 특이하게 높거나, 낮을 수 있는 것을 고르면 된다. 데이터 센터 예제에서는 <em>CPU load / network traffic</em> 등이 있을 수 있다. 네트워크 트래픽이 낮은데 <em>CPU load</em> 가 높다면 확실히 <em>anomaly</em> 기 때문이다.</p>

<h3 id="multivariategaussiandistribution">Multivariate Gaussian Distribution</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361257865_7961.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p><em>feature</em> 를 <em>CPU laod, memory use</em> 로 했을 때 낮은 CPU 부하에도 메모리 사용량이 높으면 <em>anomaly</em> 라 볼 수 있다.</p>

<p>그런데, 슬라이드의 왼쪽 그림에서 녹색으로 표시한 <em>anomaly</em> 는 지금까지 설명했던 알고리즘으로 찾기가 힘들다. 적당한 수준의 <em>memory use</em> 와 그리 낮지 않은 <em>cpu load</em> 를 가지기 때문이다.</p>

<p>실제 <em>normal example</em> 이 타원형이기 때문에, 원으로 <em>anomaly</em> 를 찾기는 어렵다. </p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361258533_5107.png'  alt="" /></p>

<p>따라서 <code>p(x_1)p(x_2)...</code> 을 이용한 모델 말고 다른 방법으로 모델을 만들어야 한다. </p>

<p><code>u</code> 를 <code>n</code> 벡터라 하고, <code>Sigma</code> 를 <code>u</code> 의 <em>convariance matrix</em> 라 하자. 그러면</p>

<p><img src='http://latex.codecogs.com/gif.latex?p%28x%3B%20%5Cmu%2C%20%5CSigma%29%20%5C%5C%20%5C%5C%20%3D%20%7B1%20%5Cover%20%282%5Cpi%29%5E%7Bn/2%7D%20%5C%20%7C%5CSigma%7C%5E%7B1/2%7D%7D%20%5C%20%5Cexp%28-%7B1%5Cover%202%7D%28x%20-%20%5Cmu%29%5ET%20%5C%20%5CSigma%5E%7B-1%7D%28x%20-%20%5Cmu%29%29'  alt="" /></p>

<p>여기서 <code>|Sigma|</code> 는 <code>Sigma</code> 의 행렬식인데, 여기를 참고하자.</p>

<ul>
<li><a href='http://ghebook.blogspot.com/2011/06/matrix.html' >행렬</a></li>
<li><a href='http://ghebook.blogspot.com/2011/06/determinant.html' >행렬식</a></li>
<li><a href='http://ghebook.blogspot.kr/2011/06/geometric-meaning-of-determinant.html' >행렬식의 기하학적 의미</a></li>
<li><a href='http://darkpgmr.tistory.com/104' >행렬식과 기하학적 활용</a></li>
</ul>

<p>이제 위 식을 이용해서 나온 <code>p(x)</code> 를 3차원, 2차원으로 보면</p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361259228_7695.png'  alt="" /></p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361259243_2967.png'  alt="" /></p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361259236_1052.png'  alt="" /></p>

<p><br/></p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361259583_5151.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Cmu%20%3D%20%7B1%20%5Cover%20m%7D%20%5Csum_%7Bi%20%3D%201%7D%5Em%20x%5E%7B%28i%29%7D'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?%5CSigma%20%3D%20%7B1%20%5Cover%20m%7D%20%5Csum_%7Bi%3D1%7D%5Em%20%5C%20%28x%5E%7B%28i%29%7D%20-%20%5Cmu%29%28x%5E%7B%28i%29%7D%20-%20%5Cmu%29%5ET'  alt="" /></p>

<p><br/></p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361259728_6035.png'  alt="" /></p>

<p><code>u, Sigma</code> 를 찾아 <code>p(x)</code> 를 만들고, 테스트 데이터에 대해 <code>p(x) &lt; e</code> 인지 비교한다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361260300_1768.png'  alt="" /></p>

<p><em>original model</em> 은 <em>multivariate model</em> 에서 각 <em>feature</em> 간 상관 관계가 없는 (독립), 즉 <em>covariance matrix</em> 가 <em>diagonal matrix</em> 인 경우다. (</p>

<p><img src='http://img.my.csdn.net/uploads/201302/19/1361260755_3407.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<ul>
<li><strong>Original model</strong></li>
</ul>

<p>수동으로 <em>feature</em> 를 만들때 사용할 수 있다. 또는 적은 연산을 원할때, 다시 말해서 <code>n</code> 이 커서 연산이 무지막지하게 클 때 좋다.</p>

<p><code>m</code> 이 작아도 쓸 수 있다.</p>

<ul>
<li><strong>Multivariate Gaussian</strong></li>
</ul>

<p>계산 비용이 비싸지만, 자동으로 <em>feature</em> 간 상관관계를 모델에 포함시킨다.</p>

<p><code>Sigma</code> 가 <em>invertible</em> 이기 위해서는 <code>m &gt; n</code> 이어야 한다. 실제로는 <code>m</code> 이 <code>n</code> 보다 훨씬 클 때 사용하는 경우가 많다. (e.g. <code>m &gt;= 10n</code>)</p>

<p>만약에 <code>m &gt; n</code> 인데, <code>Sigma</code> 가 <em>non-invertible</em> 이면 <em>redundant feature</em> 가 있는 경우니 확인해 보자. (흔한 오류라고 함)</p>

<h3 id="recommendersystem">Recommender System</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/20/1361324993_7588.png'  alt="" /></p>

<h3 id="contentbasedrecommendations">Content Based Recommendations</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/20/1361325560_4034.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p>위 슬라이드는 유저 <code>j</code> 로 부터 <code>theta^(j)</code> 를 얻어, <em>feature</em> <code>x</code> 와 곱함으로써 <em>linear regression</em> 문제로 변경했다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/20/1361326084_2070.png'  alt="" /></p>

<p><code>theta^(j)</code> 는 어떻게 훈련시킬까?</p>

<p><img src='http://latex.codecogs.com/gif.latex?min_%7B%5Ctheta%5E%7B%28j%29%7D%7D%20%5C%20%5Csum_%7Bi%3A%20%5C%20%28ri%2C%20j%29%20%3D%201%20%7D%20%7B1%20%5Cover%202m%5E%7B%28j%29%7D%7D%5C%20%5B%28%5Ctheta%5E%7B%28j%29%7D%29%5ET%28x%5E%7B%28i%29%7D%29%20-%20y%5E%7B%28i%2C%20j%29%7D%5D%5E2%20%5C%20&plus;%20%7B%5Clambda%20%5Cover%202m%5E%7B%28j%29%7D%7D%5Csum_%7Bk%3D1%7D%5En%28%5Ctheta_k%5E%7B%28j%29%7D%29%5E2'  alt="" /></p>

<p>여기서 <code>m^(j)</code> 는 유저 <code>j</code> 에 의해 점수를 받은 영화의 수인데, 어차피 상수이므로 제거하면</p>

<p><img src='http://latex.codecogs.com/gif.latex?min_%7B%5Ctheta%5E%7B%28j%29%7D%7D%20%5C%20%5Csum_%7Bi%3A%20%5C%20%28ri%2C%20j%29%20%3D%201%20%7D%20%7B1%20%5Cover%202%7D%5C%20%5B%28%5Ctheta%5E%7B%28j%29%7D%29%5ET%28x%5E%7B%28i%29%7D%29%20-%20y%5E%7B%28i%2C%20j%29%7D%5D%5E2%20%5C%20&plus;%20%7B%5Clambda%20%5Cover%202%7D%5Csum_%7Bk%3D1%7D%5En%28%5Ctheta_k%5E%7B%28j%29%7D%29%5E2'  alt="" /></p>

<p><img src='http://img.my.csdn.net/uploads/201302/20/1361326247_4648.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p>이 때 각 유저마다의 <code>theta(j)</code> 를 합 해 최소화 시키는 방식으로 전체 <code>theta</code> 를 훈련시킬 수 있다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?min_%7B%5Ctheta%5E%7B%28j%29%7D%2C%20%5Ccdots%20%5Ctheta%5E%7B%28n_u%29%7D%7D%20%5C%5C%20%5C%5C%20%3D%20%7B1%20%5Cover%202%7D%5Csum_%7Bj%3D1%7D%5E%7Bn_u%7D%20%5Csum_%7Bi%3A%20%5C%20%28ri%2C%20j%29%20%3D%201%20%7D%20%5B%28%5Ctheta%5E%7B%28j%29%7D%29%5ET%28x%5E%7B%28i%29%7D%29%20-%20y%5E%7B%28i%2C%20j%29%7D%5D%5E2%20%5C%20&plus;%20%7B%5Clambda%20%5Cover%202%7D%5Csum_%7Bj%3D1%7D%5E%7Bn_u%7D%5Csum_%7Bk%3D1%7D%5En%28%5Ctheta_k%5E%7B%28j%29%7D%29%5E2'  alt="" /></p>

<p><img src='http://img.my.csdn.net/uploads/201302/20/1361326573_9477.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p><em>gradient descent</em> 는</p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Ctheta_k%5E%7B%28j%29%7D%20%3A%3D%20%5Ctheta_k%5E%7B%28j%29%7D%20-%20%5Calpha%5Csum_%7Bi%3A%5C%20r%28i%2C%20j%29%20%3D%201%7D%20%28%28%5Ctheta%5E%7B%28j%29%7D%29%5ET%28x%5E%7B%28i%29%7D%29%20-%20y%5E%7B%28i%2C%20j%29%7D%29x_k%5E%7B%28i%29%7D%20%5C%20%28for%5C%20k%20%3D%200%29'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Ctheta_k%5E%7B%28j%29%7D%20%3A%3D%20%5Ctheta_k%5E%7B%28j%29%7D%20-%20%5Calpha%5Csum_%7Bi%3A%5C%20r%28i%2C%20j%29%20%3D%201%7D%20%28%28%5Ctheta%5E%7B%28j%29%7D%29%5ET%28x%5E%7B%28i%29%7D%29%20-%20y%5E%7B%28i%2C%20j%29%7D%29x_k%5E%7B%28i%29%7D%20&plus;%20%5Clambda%5Ctheta_k%5E%7B%28j%29%7D%5C%20%28for%5C%20k%20%5Cneq%200%29'  alt="" /></p>

<h3 id="collaborativefiltering">Collaborative Filtering</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/20/1361327928_4438.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p><em>content-based recommendation</em> 에서 <em>feature</em> 를 구하긴 사실 어려운 일이다. 누가 이 영화가 얼마만큼 로맨스고, 아닌지를 판별해줄까? </p>

<p>문제를 좀 변경해서, 만약에 유저로부터 <code>theta(j)</code> 를 얻어낼 수 있다면 그 정보로 부터 <em>feature</em> <code>x(i)</code> 를 추출할 수 있다. 왜냐하면 <code>(\theta^(j))^T * x^(i) ~ y^(i, j)</code> 이기 때문이다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/20/1361328443_4320.png'  alt="" /></p>

<p><code>x^(i)</code> 를 얻기 위해, </p>

<p><img src='http://latex.codecogs.com/gif.latex?min_%7Bx%5E%7B%28j%29%7D%2C%20%5Ccdots%20x%5E%7B%28n_m%29%7D%7D%20%5C%5C%20%5C%5C%20%3D%20%7B1%20%5Cover%202%7D%5Csum_%7Bi%3D1%7D%5E%7Bn_m%7D%20%5Csum_%7Bi%3A%20%5C%20r%28i%2C%20j%29%20%3D%201%20%7D%20%5B%28%5Ctheta%5E%7B%28j%29%7D%29%5ET%28x%5E%7B%28i%29%7D%29%20-%20y%5E%7B%28i%2C%20j%29%7D%5D%5E2%20%5C%20&plus;%20%7B%5Clambda%20%5Cover%202%7D%5Csum_%7Bi%3D1%7D%5E%7Bn_m%7D%5Csum_%7Bk%3D1%7D%5En%28x_k%5E%7B%28i%29%7D%29%5E2'  alt="" /></p>

<p><img src='http://img.my.csdn.net/uploads/201302/20/1361330430_7394.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<ul>
<li><code>theta</code> 가 주어지면 <code>x</code> 를 훈련할 수 있고</li>
<li><code>x</code> 가 주어지면 <code>theta</code> 를 훈련할 수 있다.</li>
</ul>

<p>따라서 최초의 랜덤 <code>theta</code> 에 대해 <code>x</code> 를 훈련하고, 다시 <code>theta</code> 를 훈련하고, 반복하면 된다. </p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361495687_3476.jpg'  alt="" /></p>

<p><code>theta</code> 와 <code>x</code> 를 반복해서 훈련시키는 것보다, 동시에 훈련시키는 것이 좀 더 효율적이다. 따라서</p>

<p><img src='http://latex.codecogs.com/gif.latex?J%28%7Bx%5E%7B%28j%29%7D%2C%20%5Ccdots%20x%5E%7B%28n_m%29%7D%2C%20%5Ctheta%5E%7B%28i%29%7D%2C%20%5Ccdots%20%5Ctheta%5E%7B%28n_u%29%7D%7D%29%20%5C%5C%20%5C%5C%20%3D%20%7B1%20%5Cover%202%7D%5Csum_%7B%28i%2C%20j%29%3A%20%5C%20r%28i%2C%20j%29%20%3D%201%20%7D%20%5B%28%5Ctheta%5E%7B%28j%29%7D%29%5ET%28x%5E%7B%28i%29%7D%29%20-%20y%5E%7B%28i%2C%20j%29%7D%5D%5E2%20%5C%20&plus;%20%7B%5Clambda%20%5Cover%202%7D%5Csum_%7Bi%3D1%7D%5E%7Bn_m%7D%5Csum_%7Bk%3D1%7D%5En%28x_k%5E%7B%28i%29%7D%29%5E2%20&plus;%20%7B%5Clambda%20%5Cover%202%7D%5Csum_%7Bj%3D1%7D%5E%7Bn_u%7D%5Csum_%7Bk%3D1%7D%5En%28%5Ctheta_k%5E%7B%28j%29%7D%29%5E2'  alt="" /></p>

<p>를 최소화 시키면 된다. 참고로 <code>x_0</code> 은 <em>collaborative filtering</em> 에서 필요가 없다. 알고리즘 자체가 <em>feature</em> 를 직접 찾아내니 <em>hard coded</em> 된 <em>feature</em> 는 사용하지 않는다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361495692_7530.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p>(1) <code>x</code>, <code>theta</code> 를 작은 값으로 초기화 한다.</p>

<p>이는 <em>symmetry breaking</em> 을 하기 위함이다. 작은 랜덤값들로 초기화 하여 <code>x^(i)</code> 가 서로 다른 값들을 가지도록 도와준다.</p>

<p>(2) <em>cost function</em> <code>J</code> 를 <em>gradient descent</em> 등으로 최소화 시킨다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?x_k%5E%7B%28i%29%7D%20%3A%3D%20x_k%5E%7B%28i%29%7D%20-%20%5Calpha%20%5Csum_%7Bj%3A%5C%20r%28i%2C%20j%29%20%3D%201%7D%5B%28%5Ctheta%5E%7B%28j%29%7D%29%5ET%28x%5E%7B%28i%29%7D%29%20-%20y%5E%7B%28i%2C%20j%29%7D%5D%5Ctheta_k%5E%7B%28j%29%7D%20&plus;%20%5Clambda%20x_k%5E%7B%28i%29%7D'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Ctheta_k%5E%7B%28i%29%7D%20%3A%3D%20%5Ctheta_k%5E%7B%28i%29%7D%20-%20%5Calpha%20%5Csum_%7Bi%3A%5C%20r%28i%2C%20j%29%20%3D%201%7D%5B%28%5Ctheta%5E%7B%28j%29%7D%29%5ET%28x%5E%7B%28i%29%7D%29%20-%20y%5E%7B%28i%2C%20j%29%7D%5D%5Cx_k%5E%7B%28i%29%7D%20&plus;%20%5Clambda%20%5Ctheta_k%5E%7B%28j%29%7D'  alt="" /></p>

<p>(3) 유저의 <em>parameter</em> <code>theta</code> 와 영화의 <em>feature</em> <code>x</code> 에 대해 <code>theta^T * x</code> 를 이용해 예측하면 된다.</p>

<h3 id="vectorizationlowrankmatrixfactorization">Vectorization: Low Rank Matrix Factorization</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361496844_8727.jpg'  alt="" /></p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361496849_5252.jpg'  alt="" /></p>

<p><em>collaborative filtering</em> 은 <em>low rank matrix factoriazation</em> 이라 부르기도 한다. 위 슬라이드처럼 <code>X, THETA</code> 를 구성하고 <code>X * THETA^T</code> 를 구하면 된다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361496854_2443.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p><em>low rank matrix factorization</em> 을 이용해서 <em>feature</em> 를 찾으면, 두 영화 <code>i, j</code> 가 얼마나 유사한지 <code>||x^(i) - x^(j)||</code> 으로 판단할 수 있다.</p>

<h3 id="implementationdetailmeannormalization">Implementation Detail: Mean Normalization</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361497832_3797.jpg'  alt="" /></p>

<p>만약 위 슬라이드의 <code>Eve</code> 처럼 아무 영화도 평가 안한 사람에게는, <code>theta</code> 가 <code>0</code> 으로 나온다. (첫번째 <em>term</em> 이 <code>0</code> 이고, <em>regularization term</em> 은 <code>theta</code> 를 최소화한다.)</p>

<p>그렇게 되면, 어떤 영화도 높은 <em>rating</em> 을 받을 수 없으므로 (<code>theta^T * x</code>). 추천할 거리가 없다. 이건 별로 좋은 상황이 아닌데, <em>mean normalization</em> 을 이용하면 이 문제를 해결할 수 있다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361497813_3878.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt1' >http://blog.csdn.net/linuxcumt1</a>)</p>

<p><em>mean normalized</em> 데이터를 이용하면, 추천 안한 사람이 <code>theta = 0</code> 을 갖더라도, 남들이 추천한 선호도 <code>u</code> 에 따라서 영화를 추천받을 수 있다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?%28%5Ctheta%5E%7B%28j%29%7D%29%5ET%28x%5E%7B%28i%29%7D%29%20&plus;%20%5Cmu_i'  alt="" /></p>

<p>잘보면 <em>feature scaling</em> 과는 다르게 특정 <em>range</em> 로 나누질 않는데, 이건 이미 <em>rating</em> 자체가 일정 범위 <code>1-5</code> 를 갖기 때문이다.</p>

<h3 id="references">References</h3>

<p>(1) <em>Machine Learning</em> by <strong>Andrew NG</strong> <br />
(2) <a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a> <br />
(3) <a href='http://blog.csdn.net/abcjennifer' >http://blog.csdn.net/abcjennifer</a> <br />
(4) <a href='http://ghebook.blogspot.com/2011/06/matrix.html' >http://ghebook.blogspot.com</a> <br />
(5) <a href='http://darkpgmr.tistory.com/104' >http://darkpgmr.tistory.com</a>  </p>]]></description><link>http://1ambda.github.io/machine-learning-week-9/</link><guid isPermaLink="false">0247c02a-4927-4ae8-957c-adf6590fac09</guid><category><![CDATA[coursera]]></category><category><![CDATA[machine learning]]></category><category><![CDATA[anomaly detection]]></category><category><![CDATA[recommender system]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 07 Dec 2014 15:39:40 GMT</pubDate></item><item><title><![CDATA[A Poor Man's Concurrency Monad]]></title><description><![CDATA[<p><em>FP 101x</em> 의 최종 보스입니다. <del>Rose Tree 는 거들뿐</del> <em>Koen Claessen</em> 가 1999년에 발표한 <a href='http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.8039' ><em>Poor Man's Concurrenc Monad</em></a> 를 배경으로 하는 과제인데, 언어에 <em>primitive</em> 추가 없이 <em>concurrency</em> 를 모델링 하는 방법을 보여줍니다. </p>

<h3 id="continuation">Continuation</h3>

<p>먼저 용어부터 정의하고 가면, <em>continuation</em> 은 실행 가능한 <em>computation</em> 입니다. 필요할 때 사용할려고 미뤄둔 계산인데, 이게 프로세스를 모델링 하기에 적당합니다. 왜냐하면 프로세스도 멈추었다가, 나중에 다시 실행을 해야 하니까요!</p>

<p>나중에 쓰려고 미뤄둔 계산, 즉 <em>continuation</em> 을 지속적으로 넘겨가면서 사용하는 방식을 <em>continuation passing style</em> 이라 부릅니다. <em>CPS</em> 로 작성된 함수는 리턴하는 법이 없습니다. 다만 자신의 계산을 <em>continuation</em> 으로 만들어 넘겨줄 뿐이지요.</p>

<p>코드를 먼저 보시지요. 피타고라스 계산을 하스켈에서 <em>CPS</em> 로 작성하는 방법입니다. </p>

<pre><code class="haskell">square :: Int -&gt; Int  
square x = x * x

add :: Int -&gt; Int -&gt; Int  
add x y = x + y

square_cps :: Int -&gt; (Int -&gt; r) -&gt; r  
square_cps x = \cont -&gt; cont (square x)

add_cps :: Int -&gt; Int -&gt; (Int -&gt; r) -&gt; r  
add_cps x y = \cont -&gt; cont (add x y)

pythagoras_cps :: Int -&gt; Int -&gt; (Int -&gt; r) -&gt; r  
pythagoras_cps x y = \cont -&gt;  
  square_cps x $ \squared_x -&gt;
  square_cps y $ \squared_y -&gt;
  add_cps squared_x squared_y cont

&gt; square_cps 3 print
-- "9"

&gt; add_cps 3 4 print
-- "7"

&gt; pythagoras_cps 3 4 print
-- "25"
</code></pre>

<p>위 예제에서는 <code>print</code> 가 나중에 쓸려고 모셔둔 계산, 즉 <em>continuation</em> 입니다. 이 타입 <code>(Int -&gt; r) -&gt; r</code> 을 잘 기억해 두세요.</p>

<h3 id="processmodeling">Process Modeling</h3>

<p>프로세스를 모델링 하려면 상태와 작업 두 가지를 나타내야 합니다. 먼저 프로세스가 하는 작업에 대해서 모델링을 해 보겠습니다. 프로세스는 의 작업은 <code>Action</code> 이라 부르겠습니다. <code>Action</code> 은 <code>Atom</code> 이라 부르는 <code>IO</code> 연산일 수도 있고, 자식을 만드는 <code>Fork</code> 나, 프로세스를 멈추는 <code>Stop</code> 이 될 수 있습니다.</p>

<p><code>Atom</code> 은 <em>side-effect</em> 를 만드는 <em>atomic</em> 연산이라 보면 됩니다.</p>

<pre><code class="haskell">data Action =  
   = Atom (IO Action)
   | Fork Action Action
   | Stop
</code></pre>

<p>프로세스는 상태를 모델링 하기 위해 프로세스의 동작에 대해서 조금 논의해 봅시다. 프로세스는 자신의 작업이 있습니다. 우리는 <code>Action</code> 으로 표현했지요. 프로세스가 어떤 이유에서든지 중단된다면, 나중을 위해서 이 <code>Action</code> 을 기억해 둬야 합니다. 다시 작업을 해야하니까요!</p>

<p>아까 위에서 보았던 <code>(Int -&gt; r) -&gt; r</code> 기억 나시나요? <em>continuation</em> <code>Int - r</code> 을 이용해 결과 <code>r</code> 을 만들어 냈던 타입이지요. 이 타입을 잘 보면, <em>continuation</em> 이 공급될 때 <em>result <code>r</code></em>  을 얻을 수 있습니다. 여기서 결과인 <code>r</code> 은 다른 프로세스에게 밀려 중단된 작업 <code>Action</code> 이라 보시면 되고, 공급되는 <em>continuation</em> 은 <em>CPU</em> 와 같은 리소스라 보시면 됩니다. (그렇게 생각하는 편이 <del>정신건강에</del> 좋습니다.)</p>

<p>그러면, 비슷하게, 이런 타입을 생각해 볼 수 있습니다.</p>

<pre><code class="haskell">data Concurrent a = ((a -&gt; Action) -&gt; Action)  
</code></pre>

<p>이 타입은 <code>a -&gt; Action</code> <em>continuation</em> 을 받아, 결과 <code>Action</code> 을 돌려줍니다. </p>

<p>그러면 프로세스의 <strong>미뤄진 작업의 상태</strong>를 표현하는 <code>Concurrent</code> 에 <em>continuation</em> 을 공급해 <strong>미뤄진 작업</strong> <code>Action</code> 을 얻어내는 <code>action</code> 이란 함수를 만들 수 있습니다.</p>

<pre><code class="haskell">action :: Concurrent a -&gt; Action  
action (Concurrent concur) = concur (\a -&gt; Stop)  
</code></pre>

<p>또한 어떤 <em>continuation</em> 을 받던 무조건 멈추는 <code>Action</code> 을 돌려주는 <code>stop</code> 함수도 생각해 볼 수 있겠죠. 이건 <strong>멈춰진 작업의 상태</strong> 를 표현하는 <code>Concurrent</code> 라 보셔도 좋습니다.</p>

<pre><code>stop :: Concurrent  
stop = Concurrent (\cont -&gt; Stop)  
</code></pre>

<p>이제 <code>IO</code> 를 <code>Concurrent</code> 로 표현하기 위해 <code>IO a -&gt; Concurrent a</code> 로 변환해주는 <code>atom</code> 을 만들겁니다. 다시 말해서 이 함수는 <strong>멈춰진 <code>IO</code> 연산</strong> 을 돌려줘 하므로 <code>Concurrent</code> 내에 <code>Atom (IO Action)</code> 을 담아야 합니다. </p>

<p><code>cont a</code> 가 <code>Action</code> 이므로, <code>do</code> 내에서 <code>return (cont a)</code> 이면 <code>IO Action</code> 타입을 얻을 수 있겠죠? 쉽게 생각해서 <em>continuation</em> 인 <code>cont</code> 가 공급될 때 <code>IO</code> 를 수행한다 보면 되겠습니다.</p>

<pre><code class="haskell">atom :: IO a -&gt; Concurrent a  
atom \io -&gt; Concurrent $ \cont -&gt; Atom $ do a &lt;- io  
                                            return (cont a)
</code></pre>

<p>이제 프로세스를 분할하는 <code>Fork</code> 작업을 생각해 봅시다. 타입만 보면 <code>Fork Action Aciton</code>  입니다. 즉 두개의 <code>Action</code> 을 <code>Concurrent</code> 내에 담아야 합니다.</p>

<pre><code class="haskell">fork :: Concurrent a -&gt; Concurrent ()  
fork concur = Concurrent $ \cont -&gt; Fork (action concur) (cont ())  
</code></pre>

<p>보면, <code>action concur</code> 로 현재 미뤄진 작업에 대한 <code>Action</code> 을 추출하고, <em>continuation</em> 를 받아 <code>cont ()</code> 로 <em>continuation</em> 에 있는 다음 <code>Action</code> 을 뽑아냅니다. <em>continuation</em> 의 타입이 <code>a -&gt; Action</code> 인거 기억 나시죠?</p>

<p>비슷하게, 두개의 미루어진 작업을 받아 <code>Fork</code> 로 만드는 <code>par</code> 함수도 만들어 봅시다.</p>

<pre><code class="haskell">par :: Concurrent a -&gt; Concurrent a -&gt; Concurrent a  
par (Concurrent a) (Concurrent b) = Concurrent $ \cont -&gt; Fork (a cont) (b con))  
</code></pre>

<p>이제 <code>Concurrent</code> 간 <em>composition</em> 을 위해 <code>&gt;&gt;=</code>, <code>return</code> 을 구현하면</p>

<pre><code class="haskell">instance Monad Concurrent where  
    -- g :: \a -&gt; Concurrent b
    (Concurrent A) &gt;&gt;= g = 
      \contB -&gt; A (\contA -&gt; case g a of (Concurrent B) -&gt; B contB  
</code></pre>

<p>직관적인 이해는, <code>&gt;&gt;=</code> 자체는 두 <code>Concurrent</code> 간 연결입니다. 서로 다른 타입 <code>a, b</code> 에 대해서 <code>Concurrent</code> 가 어떻게 연결되야 하는지 생각해 보면 됩니다. </p>

<p><code>Concurrent a</code> 의 <code>Action</code> 을 얻기 위한  <em>continuation</em> 은, 다음 작업을 의미하는데 이 <em>continuation</em> <code>a' -&gt; Action</code> 에서의 <code>Action</code> 이 <code>Concurrent b</code> 의 <code>Action</code> 이라 보면 됩니다.</p>

<p>다시 말해서, <code>Concurrent a</code> 의 <code>Action</code> 의 다음 작업이 <code>Concurrent b</code> 의 <code>Action</code> 이란 뜻이지요. </p>

<p>마지막으로 <code>Action</code> 을 라운드 로빈 방식으로 스케쥴링하는 <code>roundRobin</code> 함수와, 실제로 <code>Concurrent a</code> 을 이용해 <code>roundRobin</code> 함수를 이용하는 <code>run</code> 함수를 보면,</p>

<pre><code class="haskell">roundRobin :: [Action] -&gt; IO ()  
roundRobin [] = return ()  
roundRobin (Atom x:xs) = x &gt;&gt;= \ac -&gt; roundRobin (xs ++ [ac])  
roundRobin (Fork x y : xs) = roundRobin (xs ++ [x, y])  
roundRobin (Stop : xs) = roundRobin xs

run :: Concurrent a -&gt; IO ()  
run x = roundRobin [action x]  
</code></pre>

<p>몇개의 헬퍼 함수와 테스트 코드도 좀 보겠습니다.</p>

<pre><code class="haskell">genRandom :: Int -&gt; [Int]  
genRandom 1337 = [1, 96, 36, 11, 42, 47, 9, 1, 62, 73]  
genRandom 7331 = [17, 73, 92, 36, 22, 72, 19, 35, 6, 74]  
genRandom 2600 = [83, 98, 35, 84, 44, 61, 54, 35, 83, 9]  
genRandom 42   = [71, 71, 17, 14, 16, 91, 18, 71, 58, 75]

loop :: [Int] -&gt; Concurrent ()  
loop xs = mapM_ (atom . putStr . show) xs

ex0 :: Concurrent ()  
ex0 = par (loop (genRandom 1337)) (loop (genRandom 2600) &gt;&gt; atom (putStrLn ""))

ex1 :: Concurrent ()  
ex1 = do atom (putStr "Haskell")  
         fork (loop $ genRandom 7331) 
         loop $ genRandom 42
         atom (putStrLn "")

myex0 = run $ (ho &gt;&gt; ho &gt;&gt; ho) &gt;&gt;  
              (hi &gt;&gt; hi &gt;&gt; hi) &gt;&gt; atom (putStr "\n")
  where ho = atom (putStr "ho")
        hi = atom (putStr "hi")

myex1 = run $ fork (ho &gt;&gt; ho &gt;&gt; ho) &gt;&gt;  
              (hi &gt;&gt; hi &gt;&gt; hi) &gt;&gt; atom (putStr "\n")
  where ho = atom (putStr "ho")
        hi = atom (putStr "hi")

myex2 = run $ fork (put3 "ba") &gt;&gt; fork (put3 "di") &gt;&gt;  
        put3 "bu" &gt;&gt; atom (putStr "\n")
  where put3 = sequence . take 3 . repeat . atom . putStr

myex3 = run $ par (put3 "ba") (put3 "di" &gt;&gt; stop) &gt;&gt;  
        atom (putStr "\n")
  where put3 = sequence . take 3 . repeat . atom . putStr

myex4 = run $ (par (put3 "ba") (put3 "di")) &gt;&gt;  
        atom (putStr "\n")
  where put3 = sequence . take 3 . repeat . atom . putStr

myex5 :: Concurrent ()  
myex5 = do fork (atom $ putStrLn "test")  
           atom $ putStrLn "hello"

myex6 :: Concurrent ()  
myex6 = do val &lt;- par (atom $ return "hi") (atom $ return "hello")  
           atom $ putStrLn val
</code></pre>

<h2 id="references">References</h2>

<p>(1) <strong>DelftX FP 101x</strong> <br />
(2) <em>Programming in Haskell</em> <br />
(3) <a href='http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.8039' >A Poor Man's Concurrency Monad</a></p>]]></description><link>http://1ambda.github.io/a-poor-mans-concurrency-monad/</link><guid isPermaLink="false">15feb78a-f5db-44ac-9bb6-acd63bdca8fd</guid><category><![CDATA[haskell]]></category><category><![CDATA[continuation]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 06 Dec 2014 15:35:51 GMT</pubDate></item><item><title><![CDATA[하스켈로 배우는 함수형 언어 8]]></title><description><![CDATA[<p>고차함수가 있는 다른언어와 비교했을 때 하스켈은 무슨 특징이 있을까요? 하스켈은 <em>expression</em> 을 평가하기 위해 디폴트로 <em>lazy evaluation</em> 을 사용한다는 점에서 다른 언어들과 다릅니다.</p>

<p>이번시간엔 <em>evaluation</em> 의 개념부터 시작해서, 다양한 종류의 <em>evaluation</em> 전략들을 살펴보겠습니다.</p>

<h3 id="evaluation">Evaluation</h3>

<ul>
<li>Avoid doing <strong>unnecessay evaluation</strong></li>
<li>Allows programs to be <strong>more modular</strong></li>
<li>Allows us to program with <strong>infinite lists</strong></li>
</ul>

<p>하스켈은 <em>lazy evaluation</em> 을 이용해 위에 나열한 것들을 제공합니다. <em>lazy evaluation</em> 을 이야기 하기 전에 먼저 <em>evaluation</em> 이 무엇인지 살펴봅시다.</p>

<blockquote>
  <p>Basically, expressions are evaluated or reduced by successively applying definitions until no further simplification is possible</p>
</blockquote>

<p>예를 들어서 <code>square n = n * n</code> 이란 <em>definition</em> 이 있을때, <em>expression</em> <code>square(3 + 4)</code> 는 이렇게 두 가지 방식으로 평가될 수 있습니다.</p>

<pre><code class="haskell">square (3 + 4)  
square 7  
7 * 7  
49

-- bad
square (3 + 4)  
(3 + 4) * (3 + 4)
7 * (3 + 4)  
7 * 7  
49  
</code></pre>

<p>만약에 아래 버전처럼 <code>(3 + 4) * (3 + 4)</code> 로 평가된다면, 똑같은 계산을 두번이나 하게 될 겁니다. 더 심각한 문제는 <em>side effect</em> 가 발생한다면 값이 달라질 수도 있다는 것이지요!</p>

<p>아래 예제를 한번 봅시다. <em>evaluation</em> 전략에 따라 값이 달라지는 것을 보여줍니다.</p>

<pre><code class="haskell">-- initially, n := 0

-- left first
n + (n := 1)  
0 + (n := 1)  
0 + 1  
1

-- right first
n + (n := 1)  
n + 1  
1 + 1  
2  
</code></pre>

<blockquote>
  <p><strong>FACT:</strong> In Haskell, two diffrent (but terminating) ways of evaluating the same expression will always give the same final result.</p>
</blockquote>

<p>다행히도 하스켈은 어떤 전략을 사용하든 <em>terminating expression</em> 에 대해서는 항상 같은 결과를 돌려줍니다. </p>

<h3 id="reductionstrategies">Reduction Strategies</h3>

<p>일반적으로 평가방법은 크게 두 가지로 나눌 수 있습니다. 어떤 <em>reducible subexpression (redex)</em> 를 선택하냐에 따라 </p>

<p>(1) <strong>Innermost reduction:</strong> An inner most redex is always reduced <br />
(2) <strong>Outermost reduction:</strong> An outermost redex is always reduced</p>

<pre><code class="haskell">loop = tail loop

// innermost reduction
fst (1, loop)  
fst (1, tail loop)  
fst (1, tail (tail loop))  
...

// outermost reduction
fst (1, lop)  
1  
</code></pre>

<p>위 결과를 보면 <em>innermost</em> 가 종료되지 않는 경우에도, <em>outermost</em> 는 결과를 돌려줄 수 있다는 사실을 알 수 있습니다. </p>

<p>또한 어느 하나의 <em>reduction sequence</em> 라도 종료된다면 <em>outermost reduction</em> 도 종료됩니다. 같은 결과를 돌려주면서요. 원문을 첨부하면,</p>

<blockquote>
  <p>For a given expression if there exists any reduction sequence that terminates, then outermost reduction <strong>also</strong> terminates, with the same result</p>
</blockquote>

<p><em>innermost</em> 에 비해 더 많은 경우에 종료되므로 <em>outermost</em> 가 좋다고 볼 수도 있겠습니다. 그러나, <em>outermost reduction</em> 은 좀 비효율적입니다.</p>

<pre><code class="haskell">// innermost
square (3 + 4)  
square 7  
7 * 7  
49

// outermost
square (3 + 4)  
(3 + 4) * (3 + 4)
7 * (3 + 4)  
7 * 7  
49  
</code></pre>

<p>따라서 하스켈에서는 <em>outermost</em> 에 <em>sharing</em> 을 더해 <em>lazy evalution</em> 이라 부르고 이 방법을 <em>evalution</em> 에 이용합니다.</p>

<pre><code class="haskell">square (3 + 4) -- sharing, n = (3 + 4)  
= n * n -- reduced shared expression `n` into 7
= 7 * 7
= 49
</code></pre>

<p><em>innermost, outermost</em> 예제를 좀 더 살펴봅시다.</p>

<pre><code class="haskell">mult :: (Int, Int) -&gt; Int  
mult (x, y) = x * y  
</code></pre>

<p>이제 <code>mult(1 + 2, 3 + 4)</code> 를 <em>innermost</em> 로 평가한다고 한다면,</p>

<pre><code class="haskell">mult(1 + 2, 3 + 4)  
mult(3, 3 + 4) -- conventionally, we select left innermost  
mult(3, 7)  
3 * 7 -- apply outermost  
24  
</code></pre>

<p><em>innermost</em> 는 <em>argument (인자)</em> 가 먼저 평가 되어야 하기 때문에, 인자가 <em>value</em> 인 경우 사용할 수 있습니다. 반대로 <em>outermost</em> 전략을 사용한다고 결정하려면 인자가 <em>name</em> 이어야 합니다. </p>

<p>어떤 함수들의 경우는 <em>outermost</em> 를 사용함에도 먼저 인자가 평가되어야 합니다. 예를 들어 <code>*, +</code> 같은 <em>built-in operator</em> 는 무조건 인자가 먼저 평가되야 합니다. 이런 함수들을 <em>strict</em> 하다고 말 합니다.</p>

<p>좀 더 엄밀한 정의는</p>

<blockquote>
  <p>A function f is said to be strict if, when applied to a nonterminating expression, it also fails to terminate.</p>
</blockquote>

<p><code>mult</code> 를 <em>curried function</em> 으로 재 작성해 봅시다.</p>

<pre><code class="haskell">mult :: Int -&gt; Int -&gt; Int  
mult x = \y -&gt; x * y

-- evaluation
mult (1 + 2) (3 + 4)  
mult 3 (3 + 4)  
(\y -&gt; 3 * y)(3 + 4)
(\y -&gt; 3 * y)(7)
3 * 7  
</code></pre>

<p>이제 인자가 한턴에 하나씩 계산됩니다. 이는 <code>mult 3 (3 + 4)</code> 에서 <em>left, innermost redex</em> 가 <code>mult 3</code> 이기 때문입니다. <code>mult (3, 3 + 4)</code> 에선 <code>3 + 4</code> 가 <em>left, innermost redex</em> 였지만요.</p>

<p>참고로 하스켈에서 <em>lambda expression</em> 내부의 <em>redex</em> 를 선택하는건 불가능합니다. 이는 람다도 함수이고, 함수 내부는 볼 수 없는 <em>black box</em> 이기 때문입니다.</p>

<blockquote>
  <p>Note that in Haskell, the selection of redexes within lambda expressions
  is prohibited. The rational for not “reducing under lambdas” is that functions are viewed as black boxes that we are not permitted to look inside.</p>
</blockquote>

<p>일반적으로 <em>innermost</em> 전략을 <em>call by value</em>, <em>outermost</em> 전략을 <em>call by name</em> 이라 부릅니다.</p>

<h3 id="infinitelist">Infinite List</h3>

<p>여기 <code>1</code> 의 무한한 나열을 표현하는 <code>ones</code> 에 대해 <em>expression</em> <code>head ones</code> 가 어떻게 평가되는지 <em>innermost</em> 와 <em>lazy evaluation</em> 의 두 가지 방법을 비교해 봅시다. </p>

<pre><code class="haskell">ones :: [Int]  
ones = 1 : ones

-- innermost
head one  
head (1 : one)  
head (1 : 1 : one)  
...

-- lazy evaluation
head one  
head (1: ones)  
1  
</code></pre>

<p><em>innermost</em> 의 경우에는 <em>evaluation</em> 이 끝나지 않습니다. 반면 <em>lazy evaluation</em> 은 식이 끝나면서 결과를 얻을 수 있죠.</p>

<blockquote>
  <p>Using <strong>lazy evaluation</strong>, expressions are only evaluated as much as required to produce the final result</p>
</blockquote>

<p>즉 필요한 만큼만 평가됩니다. 따라서 <em>lazy evaluation</em> 을 이용한 평가방법이 있으므로 <code>ones = 1 : ones</code> 처럼 무한할 <strong>가능성이 있는</strong> 데이터를 표현할 수 있습니다.</p>

<h3 id="modularprogramming">Modular Programming</h3>

<pre><code class="haskell">take 5 ones  
-- [1, 1, 1, 1, 1]
</code></pre>

<p>위의 예제에서 볼 수 있듯이 <em>lazy evaluation</em> 을 이용하면 <em>expression</em> 을 두 부분으로 나눕니다. </p>

<ul>
<li><strong>Control Part:</strong> <code>take 5</code></li>
<li><strong>Data:</strong> <code>ones</code></li>
</ul>

<p>인자를 받아 주어진 숫자만큼 복사하는 <code>replicate</code> 함수도 만들어 볼까요?</p>

<pre><code class="haskell">replicate' :: Int -&gt; a -&gt; [a]  
replicate' 0 _ = []  
replicate' n x = x : replicate' (n - 1) x  
</code></pre>

<h3 id="generateprimes">Generate Primes</h3>

<p>무한한 길이의 원소를 표현할 수 있다는 법을 배웠습니다. 이 방법을 이용해 존재하는 모든 소수의 집합을 표현하는 리스트를 만들어 볼까요? </p>

<p><em>Sieve of Eratosthenes (에라토스테네스의 체)</em> 란 방법을 사용하겠습니다. 알고리즘은 <a href='http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes' >여기</a> 를 참조하세요.</p>

<pre><code class="haskell">primes :: [Int]  
primes = seive [2..]

seive :: [Int] -&gt; [Int]  
seive (p : xs) = p : [x | x &lt;- xs, x `mod` p /= 0]

take 10 primes  
-- [2,3,5,7,9,11,13,15,17,19]

takeWhile (&lt;15) primes  
-- [2, 3, 5, 7, 11, 13]
</code></pre>

<h3 id="strictapplication">Strict Application</h3>

<p>하스켈에선 <em>lazy evaluation</em> 이 기본이지만, <em>strict</em> 버전으로 함수를 적용할 수 있는 방법도 제공합니다. <code>$!</code> 키워드를 이용하면 되는데요, <code>f $! x</code> 같은 경우 <code>f</code> 를 적용하기 전에 <code>x</code> 가 모두 평가되야 합니다.</p>

<p>더 엄밀히 말하면 <em>top-level of evaluation</em> 이 이루어지는데요, 인자 <code>x</code> 의 타입이 <code>Int</code> 나 <code>Bool</code> 같은 <em>basic type</em> 일 경우는 <em>complete evaluation</em> 이 이루어집니다.</p>

<p>반대로, <code>(Int, Bool)</code> 같은 복합타입이라면 <em>pair of expression</em> 이 얻어질 때 까지만 평가가 이루어집니다. 유사하게 타입이 리스트라면 <code>[]</code> 나 <code>a : b</code> 같은 컨싱이 얻어질때까지만 평가가 이루어집니다.</p>

<blockquote>
  <p>More formally, an expression of the form <code>f $! x</code> is only a redex once evaluation of the argument x, using lay evaluaion as normal, has reached the point where it is known that the result is not an undefined value, at which point the expression can be reduced to the normal application <code>f x</code></p>
</blockquote>

<p>예를 들어 <code>square $! (1 + 2)</code> 의 경우</p>

<pre><code class="haskell">square $! (1 + 2)  
square $! 3  
square 3  
3 * 3  
9  
</code></pre>

<p>다수개의 인자를 갖는 <em>curried function</em> 과 <code>$!</code> 가 쓰일 경우에는 다양한 형태가 될 수 있습니다.</p>

<pre><code class="haskell">(f $! x) y    -- forces top-level evaluation of x
(f x) $! y    -- forces top-level evaluation of y
(f $! x) $! y -- forces top-level evaluation of x and y
</code></pre>

<p>하스켈에서 <em>strict application</em> 은 주로 프로그램의 <em>space performance</em> 을 개선하기 위해 사용됩니다. 예를 들어 다음과 같은 <code>sumWith</code> 함수가 있다고 합시다. </p>

<pre><code class="haskell">sumWith :: Int -&gt; [Int] -&gt; Int  
sumWith v [] = v  
sumWith v (x:xs) sumWith (v + x) xs  
</code></pre>

<p><em>lazy evaluation</em> 에서는</p>

<pre><code class="haskell">sumWith 0 [1, 2, 3]  
sumWith (0 + 1) [2, 3]  
sumWith ((0 + 1) + 2) [3]  
sumWith (((0 + 1) + 2) + 3) []  
(((0 + 1) + 2) + 3)
...
...
6  
</code></pre>

<p>계산 전에 <code>(((0 + 1) + 2) + 3)</code> 가 만들어 지는걸 볼 수 있습니다. <code>sumWith 0 [1.. 10000]</code> 같은 큰 수의 계산일 경우 공간이 좀 아까울 수 있지요.</p>

<p>따라서 <code>sumWith</code> 에 <code>$!</code> 를 이용하면</p>

<pre><code class="haskell">sumWith v [] = v  
sumWith v (x:xs) = (sumWith $! (v + x)) xs

sumWith 0 [1, 2, 3]  
sumWtih $! (0 + 1) [2, 3]  
sumWith $! 1 [2, 3]  
sumWith 1 [2, 3]  
...
</code></pre>

<p><code>sumWith</code> 뿐만 아니라 고차함수인 <code>foldl</code> 등에도 적용해 볼 수 있습니다.</p>

<pre><code class="haskell">foldl' :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a  
foldl' f v [] = v  
foldl' f v (x:xs) ((foldl' f) $! (f v x)) xs  
</code></pre>

<p>이러면, <code>sumWith</code> 를 <code>foldl' (+)</code> 로 정의할 수 있습니다.</p>

<h2 id="references">References</h2>

<p>(1) <strong>DelftX FP 101x</strong> <br />
(2) <em>Programming in Haskell</em>  </p>]]></description><link>http://1ambda.github.io/haskell-intro8/</link><guid isPermaLink="false">d903754f-78ce-4128-8c4f-51567d031c97</guid><category><![CDATA[edx]]></category><category><![CDATA[haskell]]></category><category><![CDATA[lazy evaluation]]></category><category><![CDATA[call by value]]></category><category><![CDATA[call by name]]></category><category><![CDATA[strict]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 04 Dec 2014 08:46:14 GMT</pubDate></item><item><title><![CDATA[Graph Challenges, Minimum Spanning Trees, Shortest Paths]]></title><description><![CDATA[<h3 id="graphprocesschallenge1">Graph Process Challenge 1</h3>

<h4 id="isagraphbipartite">Is a graph bipartite?</h4>

<p>그래프가 <em>bipartite</em> 인가 하는 문제는, 그래프의 노드를 이렇게 두 그룹으로 나눌 수 있느냐 하는 문제다.</p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/e/e8/Simple-bipartite-graph.svg/330px-Simple-bipartite-graph.svg.png'  alt="" /></p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Biclique_K_3_5.svg/330px-Biclique_K_3_5.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org/' >http://en.wikipedia.org</a>)</p>

<p>알고리즘이 얼마나 어려운가는 이렇게 나눠볼 수 있겠는데</p>

<ol>
<li>Any programmer could do it  </li>
<li>Typical diligen algorithms student could do it  </li>
<li>Hire an expert  </li>
<li>Intractable  </li>
<li>No one knows  </li>
<li>Impossile</li>
</ol>

<p><em>biparting</em> 문제는 <em>DFS-based solution</em> 을 이용할 수 있으므로, 난이도 2정도에 해당한다 볼 수 있겠다. </p>

<p>생각해 볼 수 있는 응용은, 질병의 전파 경로를 그래프로 그리고 <em>biparting</em> 이 가능한지 보는 것이다.</p>

<h4 id="findacycle">Find a cycle</h4>

<p>이것도 난이도 (2) 정도. 마찬가지로 <em>simple DFS-based solution</em> 을 이용하자.</p>

<p>잘 알려진 응용으로, <em>euler tour</em> 가 있다. 각 <em>edge</em> 를 단 한번씩만 방문하는 <em>cycle</em> 이 있는지를 검사하는 문제다. 여기서 시작점과 끝 점이 같으면 <em>euler circuit</em> 이고, 다르면 <em>euler path</em> 라 부른다.</p>

<p><a href='http://ko.wikipedia.org/wiki/%EC%98%A4%EC%9D%BC%EB%9F%AC_%EA%B2%BD%EB%A1%9C' >여기</a>에 의하면 그래프에 오일러 회로가 존재하려면 </p>

<p>(1) 연결된 그래프여야 하고 <br />
(2) 모든 꼭지점의 차수가 짝수여야 한다.</p>

<p>반면 오일러 경로라면, 연결그래프에서 정확히 두 개의 꼭지점만 홀수 차수여야 한다.</p>

<p>각 <em>node</em> 를 정확히 한번씩만 지나는 <em>cycle</em> 을 <em>traveling salesman problem, TSP</em> 혹은 <em>hamiltonian path problem</em> 이라 부른다.</p>

<p>오일러 순회와 경로처럼 시작점과 끝점이 같은지, 아닌지에 따라 구분할 수 있다. <em>hamiltonian cycle</em> 은 전형적인 <em>NP-complete problem</em> 으로 알려져있다. 난이도로 구분하자면 <em>(4) intractable</em> 정도 되시겠다.</p>

<h4 id="graphisomorphismproblem">Graph Isomorphism Problem</h4>

<blockquote>
  <p>Are two graphs identical except for vertex names?</p>
</blockquote>

<p>그래프의 형태가 같은지 묻는 문제다. 예를 들어 다음의 두 그래프는 같은 형태다.</p>

<p><img src='http://www.biodatamining.org/content/figures/1756-0381-4-10-3-l.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.biodatamining.org/' >http://www.biodatamining.org/</a>)</p>

<p>두 그래프의 노드를 <code>n!</code> 으로 배열해 가면서 같은지 비교하는 단순한 방법은 그래프가 커지면 기하 급수적으로 성능이 느려진다. 더 나은 알고리즘이 있는지 연구자들이 노력하고 있지만, 아직 모른다. 난이도는 <em>(5) No one knows</em></p>

<h4 id="graphsplanarity">Graphs Planarity</h4>

<p>그래프를 <em>crossing edge</em> 가 없는 그래프로 그릴 수 있느냐 하는 문제다.</p>

<blockquote>
  <p>평면 그래프(planar graph)는 평면 상에 그래프를 그렸을 때, 두 변이 꼭지점 이외에 만나지 않도록 그릴 수 있는 그래프를 의미한다.</p>
</blockquote>

<p>이건 난이도 <em>(3) Hier an expert</em> 문제다. <em>DFS</em> 기반의 <em>linear time</em> 알고리즘이 1970년대에 발표되었다.</p>

<h3 id="minimumspanningtrees">Minimum Spanning Trees</h3>

<p><em>undirected, positive edge weights</em> 그래프에서 </p>

<p>(1) <em>connected, acyclic</em> <strong>(tree)</strong> <br />
(2) <em>includes all of the vertices</em> <strong>(spanning)</strong>   </p>

<p>인 서브 그래프를 <strong><em>spanning tree</em></strong> 라 부른다.</p>

<p><strong><em>minimum spanning tree</em></strong> 는 여기서 <em>min weight</em> 를 갖는 <em>spanning tree</em> 를 찾는 문제다.</p>

<h4 id="applications">Applications</h4>

<ul>
<li>dithering</li>
<li>cluster analysis</li>
<li>max bottleneck paths</li>
<li>network design</li>
</ul>

<p>등에 활용할 수 있다.</p>

<h3 id="mstgreedyalgorithm">MST: Greedy Algorithm</h3>

<p>간단한 설명을 위해서 그래프가 연결되어있고 <em>weight</em> 가 모두 다르다 하자. 그럼 <em>MST</em> 는 하나만 존재할 것이다.</p>

<p>먼저 <em>cut, crossing edge</em> 용어 정리를 하면</p>

<blockquote>
  <p><strong>Cut:</strong> A cut is a graph is a partition of its vertices into two (nonempty) sets</p>
  
  <p><strong>Crossing edge:</strong> A crossing edge connects a vertex in one set with a vertex in the other</p>
</blockquote>

<p>그러면, 이런 <em>cut property</em> 가 존재한다.</p>

<blockquote>
  <p>Given any <strong>cut</strong>, the crossing edge of min weight is in the MST</p>
</blockquote>

<p>증명은 <em>min-weight crossing edge</em> <code>e</code> 가 <em>MST</em> 내에 없다고 하자. <em>MST</em> 는 연결되야 하므로 다른 <em>crossing edge</em> <code>f</code> 가 대신 사용될 것이다. </p>

<p>(1) 다른 <em>crossing edge</em> <code>f</code> 가 없으면 <em>connected</em> 가 아니므로 <em>MST</em> 가 아니다. <br />
(2) 만약 <code>f</code> 가 있어서 <code>f</code> 를 대신 사용하는 <em>MST</em> 에 <code>e</code> 를 추가하면 사이클이 생긴다. 이 때 <code>f</code> 를 제거하면 <em>weight</em> 가 더 짧다. 따라서 <code>f</code> 가 포함되면 <em>MST</em> 가 아니다.</p>

<p>따라서 <em>min-weight crossing edge</em> 가 <em>MST</em> 내에 존재한다. 이 사실을 이용하면 <em>MST</em> 를 찾는 <em>greedy algorithm</em> 을 만들 수 있다.</p>

<pre><code>- Start with all edges colored gray
- Find cut with no black corssing edges; 
   color its min-weight edge black
- Repeat until V - 1 edges are colored black
</code></pre>

<p>즉 어떤 <em>cut</em> 에 대해서 <em>min-weight crossing edge</em> 가 <em>MST</em> 에 포함되므로, 이미 찾은 <em>MST edge</em> 를 포함하지 않는 <em>cut</em> 을 찾아, <em>min-weight crossing edge</em> 을 추가해 나가면 된다.</p>

<h4 id="correcteness">Correcteness</h4>

<p>(1) Any edge colored black is in the MST (vis cut property) <br />
(2) Fewer than <code>V - 1</code> black edges => cut with no black crossing edges</p>

<p>모든 <em>MST</em> 는 <code>V - 1</code> 개의 <em>edge</em> 로 구성된다. 따라서 <code>V - 1</code> 개의 <em>black edge</em>, 즉 <em>MST</em> 의 원소를 찾아내면 된다. </p>

<h3 id="edgeweightedgraphapi">Edge-Weighted Graph API</h3>

<pre><code class="java">public class Edge implements Comparable&lt;Edge&gt; {  
  Edge(int v, int w, double weight)
  int either()
  int other(int v)
  int compareTo(Edge that)
  ...
}

// allow self-loops and parallel edges
public class EdgeWeightedGraph {  
  EdgeWeightedGraph(int V) // V vertices
  void addEdge(Edge e)
  Iterable&lt;Edge&gt; adj(int v) // edges incident to v
  Iterable&lt;Edge&gt; edges() // all edges
  Int V() // # of vertices
  int E() // # of edges
}

public class MST {  
  MST(EdgeWeigtedGraph G)
  Iterable&lt;Edge&gt; edges()
  double totalWeight()
}
</code></pre>

<h4 id="removingassumptions">Removing assumptions</h4>

<ul>
<li>What if edge weights are not all distinct?</li>
</ul>

<blockquote>
  <p>Greedy MST algorithm still correct if equal weights are present. (our correctness proof fails, but that can be fixed)</p>
</blockquote>

<ul>
<li>What if graph is not connected?</li>
</ul>

<blockquote>
  <p>Compute MS forest = MST of each components</p>
</blockquote>

<h3 id="kruskalsalgorithm">Kruskal's Algorithm</h3>

<pre><code>- Sort edges in ascending order of weight. 
- Add next edge to tree T 
  unless doing so would create a cycle 
  (until V - 1 edges added) 
</code></pre>

<p><em>kruskal's algorithm</em> 은 <em>greedy MST</em> 의 일종이라 볼 수 있다.</p>

<p>선택된 <em>edge</em> <code>e = v &lt;-&gt; w</code> 라 하고 이것을 <em>crossing edge</em> (<em>cut</em> 이라 볼 수 있다), 하면 </p>

<p><em>black edge</em> 간 <em>no cycle</em> 인 <code>e</code> 를 선택한 것이므로 <code>v &lt;-&gt; w</code> 사이엔 <em>black crossing edge</em> 가 없다. </p>

<p>게다가 선택하는 <em>crossing edge</em> 는 가장 작은 <em>weight</em> 를 가진다. 이 전에 이미 더 작은 <em>weight</em> 의 <em>edge</em> 를 모두 선택했기 때문이다.</p>

<p>따라서 크루스칼 알고리즘은 <em>greedy MST</em> 의 일종이다.</p>

<h4 id="cyclecheck">Cycle Check</h4>

<p>어떻게 <em>Cycle check</em> 를 할까? 한 가지 방법은 <em>edge <code>e = v - w</code></em> 에 대해 <code>v - w</code> 가 연결되어있는지 <em>DFS</em> 를 돌리면 된다. 그러면 <code>O(V)</code> 로 사이클을 검사할 수 있다.</p>

<p>단순히 연결되어있는지만 검사하는 것이므로 <em>union find</em> 를 쓰면 <code>O(log* V)</code> 로도 가능하다. <a href='http://1ambda.github.io/union-find-algorithms-week-1/' >Union-find</a> 를 참고하자.</p>

<h4 id="kruskalmstimplementation">Kruskal MST Implementation</h4>

<pre><code class="java">EdgeWeightedGraph G;  
int V = G.V()  
UF uf = new UF(V);

Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;();  
MinPQ&lt;Edge&gt; pq = new MinQP&lt;Edge&gt;();

for (Edge e : G.edges())  
  pq.enqueue(e);

while (!pq.isEmpty() &amp;&amp; mst.size() &lt; V - 1) {  
  Edge e = pq.dequeue();
  int v = e.either();
  int w = e.other(v);

  if (!uf.connected(v, w)) {
    uf.union(v, w);
    mst.enqueue(e);
  }
}
</code></pre>

<p><em>running time</em> 은 <code>E log E</code> 다. </p>

<ul>
<li>build <code>pq</code>: <code>1 * E</code></li>
<li>dequeue: <code>E * log E</code></li>
<li>union: <code>V * log* V</code></li>
<li>connected: <code>E * log* V</code> </li>
</ul>

<h3 id="primsalgorithm">Prim's Algorithm</h3>

<pre><code>- start with vertex 0 and greedily grow tree T
- add to T the min weight edge with exactly one endpoint in T
- repate until V - 1 edge
</code></pre>

<h4 id="correctness">Correctness</h4>

<p>마찬가지로 <em>prim's algorithm</em> 도 <em>greedy MST</em> 의 일종이다.</p>

<p>방문한 노드와 방문하지 않은 노드를 <em>cut</em> 해 거기서 <em>min-weight edge</em> 를 선택한다. 따라서 <em>cut</em> 자체가 방문하지 않은 노드와 방문한 노드 두 집합을 만드므로 <em>crossing edge</em> 중에는 <em>black edge</em> 가 없다. </p>

<h4 id="primmstimplementation">Prim MST Implementation</h4>

<p><em>lazy implementation</em> 으로 현재 선택할 수 있는 <em>edge</em> 를 <em>weight</em> 기준으로 <em>priority queue</em> 에 유지하는 방법이 있다.</p>

<p><em>queue</em> 에 있는 <em>edge</em> <code>e = (v, w)</code> 를 꺼낸 뒤</p>

<p>(1) <code>v, w</code> 둘 다 이미 방문했으면 패스하고, <br />
(2) <code>v</code> 혹은 <code>w</code> 둘 중 하나만 방문했을 경우에만 <code>w or v</code> 의 <em>edge</em> 를 추가하고, <code>w or w</code> 를 방문 처리 한다. </p>

<pre><code class="java">// lazy Prim MST

boolean[] marked // MST vertices  
Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;();  
MinPQ&lt;Edge&gt; pq = new MinPQ&lt;Edge&gt;();  
WeightedGraph G;

visit(G, 0);

while (!pq.isEmpty()) {  
  Edge e = pq.dequeue();
  int v = e.either();
  int w = e.other(v);

  if (marked[v] &amp;&amp; marked[w]) continue;

  mst.enqueue(e);

  // add v or w
  if (!marked[v]) visit(G, v);
  if (!marked[w]) visit(G, w);
}

void visit(int v) {  
  marked[v] = true;
  for (Edge g : G.adj(v)) {
    if (!marked[e.other(v)]) pq.insert(e);
  }
}
</code></pre>

<p><em>running time</em> 은 <code>O(E log E)</code> 다.</p>

<p>좀 더 나은 알고리즘은 <em>MST</em> 에 <em>edge</em> <code>e = (v, w)</code> 를 추가할때, 이미 방문한 <code>w</code> 와 방문하지 않은 <code>v</code> 에 대해</p>

<p><code>v</code> 에서 갈 수 있는 모든 <em>edge</em> <code>e = (v, x)</code> 을 생각해 보면, </p>

<p>(1) <code>x</code> 가 이미 방문한 <em>vertex</em> 면 패스 <br />
(2) <em>queue</em> 에 <code>(k, x)</code> 가 없으면 추가 (<code>k</code> 는 이미 방문한 <em>vertex</em>) <br />
(3) <code>x</code> 까지의 거리가, <code>e = (v, x)</code> 가 더 짧으면 업데이트 (<em>decreaseKey operation</em>)</p>

<p>여기서 <code>decreaseKey</code> 연산을 빠르게 구현하기 위해 <em>indexed priority queue</em> 를 이용할 수 있다.</p>

<pre><code>void decreaseKey(int i, Key key)  
</code></pre>

<p>전체 러닝타임은 </p>

<ul>
<li><code>V</code> <em>insert</em></li>
<li><code>V</code> <em>delete min</em></li>
<li><code>E</code> <em>decrease key</em></li>
</ul>

<p>인데, <em>Priority Queue</em> 구현하는데 어떤 자료구조를 사용하느냐에 따라 각 연산의 시간이 달라진다.</p>

<p>(1) Array implementation optimal for dnse graph  </p>

<p>O(<code>V^2</code>)</p>

<p>(2) Binary heap much faser for sparse graphs  </p>

<p>O(<code>E log V</code>)</p>

<p>(3) 4-way heap worth the trouble in performance-critical situations  </p>

<p>O(<code>E log_(1/V) V</code>)</p>

<p>(4) Fibonacchi heap best in theor, but not worth implementing  </p>

<p>O(<code>E + V log V</code>)</p>

<h3 id="mstcontext">MST Context</h3>

<p><em>linear time MST</em> 알고리즘이 있을까? 1995년에 <em>linear time randomized MST</em> 가 발견 되었지만 <em>deterministic</em> 알고리즘은 여전히 연구중이다.</p>

<h3 id="shortestpathsapi">Shortest Paths API</h3>

<pre><code class="java">public class Directed Edge {

  DirectedEdge(int v, int w, deouble weight)
  int from()
  int to()
  double weight()
}

// allow self-loop, parallel
public class EdgeWeightedDigraph {

  EdgeWeightedDigraph(int V)
  void addEdge(DirectedEdge e)
  Iterable&lt;DirectedEdge&gt; adj(int v)
  int V() // # of vertices
}

// shortest path
public class SP {

  SP(EdgeWeightedDigraph G, int s)
  double distTo(int v)
  Iterable &lt;DirectedEdge&gt; pathTo(int v)
}
</code></pre>

<h3 id="shortestpathproperties">Shortest Path Properties</h3>

<p><em>directed, weighted graph</em> 에서 <em>shortest path tree, SPT</em> 가 존재하는데, 이는 <em>cycle</em> 이면 <em>shortest</em> 가 될 수 없기 때문이다.</p>

<p>위에서 본 <code>pathTo</code> 함수는 이렇게 구현할 수 있다.</p>

<pre><code class="java">// edgeTo[v] is last edge on shortest path from s to v
public Iterable&lt;DirectedEdge&gt; pathTo(int v) {  
  Stack&lt;DirectedEdge&gt; path = new Stack&lt;DirectedEdge&gt;();
  for (DirectedEdge e = edgeTo(v); e != null; e = edgeTo(e.from())
    path.push(e);

  return path;
}
</code></pre>

<h4 id="edgerelaxation">Edge relaxation</h4>

<p><em>relax edge <code>e = v -&gt; w</code></em>,</p>

<ul>
<li><code>distTo[v]</code> is length of shortest known path from <code>s</code> to <code>v</code></li>
<li><code>distTo[w]</code> is length of shortest known path from <code>s</code> to <code>w</code></li>
<li><code>edgeTo[w]</code> is last edge on shortest known path from <code>s</code> to <code>w</code></li>
</ul>

<p>여기서 만약 <code>e = v -&gt; w</code> 가 <code>w</code> 로의 더 짧은 거리라면, <code>distTo[w]</code> 와 <code>edgeTo[w]</code> 를 업데이트하면 된다.</p>

<p><img src='http://www.csupomona.edu/' ~ftang/courses/CS241/notes/images/graph/relax1.jpg" alt="" title="" />  </p>

<p><img src='http://faculty.ycp.edu/' ~dbabcock/PastCourses/cs360/lectures/images/lecture21/relaxation.png" alt="" /></p>

<p align="center">(<a href='http://www.csupomona.edu/' ~ftang'>http://www.csupomona.edu/~ftang</a>)</p>

<pre><code class="java">void relax(DirectedEdge e) {  
  int v = e.from();
  int w = e.to();

  if (distTo(w) &gt; distTo(v) + e.weight()) {
    distTo[w] = distTo[v] + e.weight();
    edgeTo[w] = e;
  }
}
</code></pre>

<h4 id="shortestpathsoptimalityconditions">Shortest-paths optimality conditions</h4>

<blockquote>
  <p>Let <code>G</code> be an edge-weighted digraph, then <code>distTo[]</code> are the shortest path distance from s iff:</p>
</blockquote>

<ul>
<li><code>distTo[s]</code> = 0</li>
<li>For each vertex <code>v</code>, <code>distTo[v]</code> is the length of some path from <code>s</code> to <code>v</code></li>
<li>For each edge <code>e = v -&gt; w</code>, <code>distTo[w] &lt;= distTo[v] + e.weight()</code></li>
</ul>

<p><strong>necessary condition</strong> </p>

<p>만약 어떤 <code>e = v -&gt; w</code>에 대해 <code>distTo[w] &gt; distTo[v] + e.weight()</code> 이면, <code>e</code> 를 이용한 <code>w</code> 까지의 거리가 <code>distTo[w]</code> 보다 더 짧다. 그러면 <code>distTo[w]</code> 는 <em>shortest path</em> 가 아니다.</p>

<p><strong>sufficient condition</strong></p>

<ul>
<li>Suppose <code>s = v0 -&gt; v1, ... -&gt; vk = w</code> is a shortest path from <code>s</code> to <code>v</code></li>
</ul>

<p>그러면</p>

<pre><code>distTo[v1] &lt;= distTo[v0] + e1.weight();  
...
distTo[vk] &lt;= distTo[v_k-1] + ek.weight(); 

// e_i is, i th edge on shortest path from s to w
</code></pre>

<p>이제 <code>distTo[v] = 0</code> 이라 하면</p>

<p><code>distTo[w] &lt;= e1.weight + ..., + ek.weight()</code></p>

<p>이 때 우변이 <em>shortest path</em> 위에 있는 <em>edge</em> 의 <em>weight</em> 값이므로, <code>distTo[w]</code> 는 <code>w</code> 까지의 <em>shortest path</em> 다.</p>

<p>(여기서는 필요충분조건 <code>p &lt;=&gt; q</code> 를 증명하기 위해 <code>p -&gt; q</code>, <code>q -&gt; p</code> 를 증명했다.)</p>

<h4 id="genericshortestpathsalgorithm">Generic Shortest-paths Algorithm</h4>

<pre><code>initialize distTo[s] = 0 and distTo[v] = infinity for all other vertices

Repeat until optimality conditions are satisfied,  
  Relax any edge
</code></pre>

<p>어떤 <em>edge</em> 를 고를까 하는 문제로 발전할 수 있다.</p>

<p>(1) <em>Dijkstra's algorithm</em>: <strong>non-negative weights</strong> <br />
(2) <em>Topological sort</em>: <strong>no directed cycles</strong> <br />
(3) <em>Bllman-Ford algorithm</em>: <strong>no negative cycles</strong></p>

<h3 id="dijkstrasalgorithm">Dijkstra's Algorithm</h3>

<pre><code>- Consider vertices in increasing order of dinstance from s
  (non-tree vertex with the lowest distTo[] value)

- Add vertex to tree and relax all edges pointing from that vertex
</code></pre>

<h4 id="correctness">Correctness</h4>

<blockquote>
  <p>Dijkstra's algorithm computes a SPT in any edge-weighted digraph with non-negative weights</p>
</blockquote>

<p>모든 <code>e = v -&gt; w</code> 는 단 한번씩만 <em>relaxed</em> 되기 때문에 알고리즘은 언젠간 종료된다. (<code>v</code> 가 <code>T</code> 에 추가되었을 때) </p>

<p>그리고 이 과정에서 <code>distTo[w] &lt;= distTo[v] + e.weight()</code> 가 유지된다. 왜냐하면 <code>distTo[w]</code> 는 줄어들기만 하고, <em>weight</em> 가 음수인 <em>edge</em> 가 없기 때문에 <code>distTo[v]</code> 는 변함이 없기 때문이다. </p>

<pre><code class="java">DirectedEdge[] edgeTo;  
double[] distTo;  
IndexMinPQ&lt;Double&gt; pq;

void DijkstraSP(EdgeWeightedDigraph G, int s) {  
  int V = G.V();
  edgeTo = new DirectedEdge[V];
  distTo = new double[V];
  pq = new IndexMinPQ&lt;Double&gt;(V);

  for(int v = 0; v &lt; V; v++) {
    distTo[v] = Double.POSITIVE_INFINITY;
  }

  distTo[s] = 0.0;
  pq.insert(s, 0.0);

  while (!ps.isEmpty()) {
    int v = pq.dequeue();
    for(DirectedEdge e: G.adj(v))
      relax(e);
  }
}

void relax(DirectedEdge e) {  
  int v = e.from();
  int w = e.to();

  if (distTo[w] &gt; distTo[v] + e.weight()) {
    distTo[w] = distTo[v] + e.weight();
    edgeTo[w] = e;

    if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
    else pq.insert(w, distTo[w]);
  }
}
</code></pre>

<p>프림 알고리즘과 마찬가지로 </p>

<p><code>T(n) = V insert + V delete-min + E decrease key</code> 인데, 이 연산들은 <em>Priority Queue</em> 구현에 따라 다를 수 있다. </p>

<p><em>undordered array</em> 라면 <code>V^2</code>, <em>binary heap</em> 이라면 <code>E log V</code> </p>

<p>따라서 <em>dense graph</em> 에서는 <em>array</em> 를, <em>sparse graph</em> 라면 <em>binary heap</em> 이 낫다.</p>

<h4 id="dijkstraandprim">Dijkstra and Prim</h4>

<p>둘 다 <em>spanning tree</em> 를 만들어 낸다. </p>

<ul>
<li>다익스트라는 <em>directed path</em> 에서 <em>source</em> 에서 가장 가까운 <em>vertex</em> 를 선택한다면, </li>
<li>프림 알고리즘은 <em>undirected edge</em> 내 에서 <em>tree</em> 에서 가장 가까운 <em>vertex</em> 를 선택한다.</li>
</ul>

<h3 id="edgeweighteddags">Edge-Weighted DAGs</h3>

<p><em>cycle</em> 이 없는 그래프는 <em>shortest path</em> 를 찾기 더 쉽다.</p>

<p><em>toplogical order</em> 순서로 <em>relaxing</em> 해 가면 된다. 어차피 방문 자체는 <em>topological order</em> 로 해야만 모든 <em>vertex</em> 를 방문할 수 있기 때문이다. </p>

<p>이 알고리즘에서 재미난 점은 음수 <em>weight</em> 가 있던 말던 상관이 없다는 것이다.</p>

<blockquote>
  <p>Topological sort algorithm computes SPT in <strong>any</strong> edge-weighted DAG in time proprotional to <code>E + V</code></p>
</blockquote>

<p>다익스트라와 마찬가지로 모든 <em>edge <code>e = v -&gt; w</code></em> 는 단 한번만 <em>relaxed</em> 되고, 이 과정에서 <code>distTo[w] &lt;= distTo[v] + e.weight()</code> 다.</p>

<p>(1) <code>distTo[w]</code> 는 줄어들기만 하고, <br />
(2) <em>topological order</em> 이기 때문에 한번 방문된 <code>v</code> 에 대해 이후의 <em>vertex</em> 에서 <code>v</code> 로 갈 수 없다. 있다면 <em>cycle</em> 이고 그럼 <em>toplogical order</em> 가 안된다. 따라서 <code>distTo[v]</code> 는 변하지 않는다. 따라서 <em>weight</em> 가 음수든 양수든 상관이 없다.</p>

<pre><code class="java">DirectedEdge[] edgeTo;  
double[] distTo;

public AcyclicSP(EdgeWeightedDigraph G, int s) {  
  int V = G.V();
  edgeTo = new DirectedEdge[V];
  distTo = new double[V];

  for(int v = 0; v &lt; V; v++) {
    distTo[v] = Double.POSITIVE_INFINITY;
  }

  distTo[s] = 0.0;

  Topological t = new Topological(G);

  for (int v : t.order()) {
    for (DirectedEdge e : G.adj(v)) {
      relax(e);
    }
  }
}
</code></pre>

<p>응용으로 <em>seam carving</em> 이 있다. 수직이나 수평으로 <em>shortest path</em> 를 찾아서 제거하면 된다.</p>

<p><img src='http://rahuldotgarg.appspot.com/data/SeamCarvingWeb/evaluation_files/image002.jpg'  alt="" /></p>

<p align="center">(<a href='http://rahuldotgarg.appspot.com/' >http://rahuldotgarg.appspot.com</a>)</p>

<p><em>longest path</em> 를 찾는법은 모든 <em>weight</em> 를 <em>negate</em> 하고, 찾고, 다시 결과의 <em>weight</em> 에 마이너스를 붙이면 된다. 이게 가능한 이유는 <em>no cycle</em> 이기 때문에 <em>weight</em> 가 음수든, 양수든 상관이 없기 때문이다.</p>

<p>응용해서 <em>Critical path method, CPM</em> 에 활용할 수 있다.</p>

<p>작업간 의존관계가 있으므로 이를 이용해서 <em>DAG</em> 를 그리면 된다. 각 <em>job</em> 당 <em>start vertex, finish vertex</em> 가 되며, 그 <em>weight</em> 는 <em>duration</em> 으로 하고 한 작업과 다음 작업의 <em>weight</em> 는 <code>0</code> 으로 했을때의 <em>longest path</em> 를 찾으면 된다. </p>

<p><img src='http://algs4.cs.princeton.edu/44sp/images/scheduling-critical-path.png'  alt="" /></p>

<p align="center">(<a href='http://algs4.cs.princeton.edu/44sp/' >http://algs4.cs.princeton.edu/44sp/</a>)</p>

<h3 id="negativeweights">Negative Weights</h3>

<p>다익스트라 알고리즘은 <em>negative weight</em> 에 대해서 작동하지 않는다. 모든 <em>weight</em> 에 일정 수 <code>n</code> 을 더해 모두 양수로 만들어도 똑같다. 심지어 이 경우는  <em>shortest path</em> 자체가 바뀐다. 따라서 다른 알고리즘이 필요하다.</p>

<p>진도를 빼기 전에 용어를 좀 정의하고 가면</p>

<p><em>negative cycle</em> 은, <em>directed cycle</em> 내의 모든 <em>weight</em> 를 더했을 때 음수인 경우를 말한다. 이 경우 <em>SPT</em> 는 없다. 이는 쉽게 보일 수 있는데</p>

<p><em>negative cycle</em> 이 존재하면 한번 이 사이클을 돌면, 전체 값이 음수이므로 어느 경로를 택해도 이전보다 더 짧아진다.</p>

<p>따라서 이 사이클을 돌면 내부 <em>vertex</em> 를 무한정 <em>relaxing</em> 할 수 있다.  </p>

<h4 id="bellmanfordalgorihm">Bellman-Ford Algorihm</h4>

<p><em>Bellman-Ford Algorihm</em> 은 <em>negative cycle</em> 이 있는지 검사할 수 있다.</p>

<ul>
<li>Initialize <code>distTo[s] = 0</code> and <code>distTo[v] = inf</code> 
for all other vertice</li>
<li>Repeat V times, relax each Edge</li>
</ul>

<pre><code>for (int i = 0; i &lt; G.V(); i++)  
  for(int v = 0; v &lt; G.V(); v++)
    for(DirectedEdge e: G.adj(v)) // pass i
      relax(e);     
</code></pre>

<p>벨만 포드 알고리즘은 <em>negative cycle</em> 이 없을때 <code>O(E * V)</code> 로 <em>shortest path</em> 를 찾아낸다. </p>

<p>증명은 <a href='http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm' #Proof_of_correctness">여기</a>를 참조하도록 하자.</p>

<p>알고리즘을 잘 보면, 한 <em>pass</em> 에서 <code>distTo[v]</code> 가 변하지 않으면 그 이후에도 안 변한다. </p>

<blockquote>
  <p>If <code>distTo[v]</code> does not change during pass <code>i</code>, no need to relax any edge pointing from <code>v</code> in pass <code>i + 1</code></p>
</blockquote>

<p>따라서 <code>distTo[]</code> 가 변화한 <code>v</code> 의 리스트를 유지해서, 이것 대상으로 <em>relax</em> 하면 성능을 더 개선할 수 있다.</p>

<h4 id="findinganegativecycle">Finding a negative cycle</h4>

<p>벨만 포드 알고리즘은 <em>negative cycle</em> 을 찾아내는데 사용할 수도 있다. <em>negative cycle</em> 이 있을 경우 무한히 <em>relax</em> 를 해 내기 때문이다.</p>

<p>따라서 <code>V - 1</code> 까지 진행 한 후 <code>V</code> 번째에서 어느 <em>vertex</em> <code>v</code> 라도 업데이트 된다면, <em>negative</em> 사이클이 있다.</p>

<p><em>negative cycle</em> 은 <em>arbitrage detection</em> 에 사용할 수 있다.</p>

<h3 id="shortestpathcostsummary">Shortest Path Cost Summary</h3>

<p>(1) <strong>Topological Sort:</strong> No directed cycles</p>

<p>다익스트보다 더 빠르고, <em>negative weight</em> 도 문제 없다.</p>

<ul>
<li>typical: <code>E + V</code></li>
<li>worst: <code>E + V</code></li>
<li>extra space: <code>V</code></li>
</ul>

<p>(2) <strong>Dijkstra(binary heap):</strong> No negative weights</p>

<p>거의 <em>linear time</em> 이다.</p>

<ul>
<li>typical: <code>E logV</code></li>
<li>worst: <code>E logV</code></li>
<li>extra space: <code>V</code></li>
</ul>

<p>(3) <strong>Bellman Ford:</strong> No negative cycles</p>

<ul>
<li>typical: <code>E * V</code></li>
<li>worst: <code>E * V</code></li>
<li>extra space: <code>V</code></li>
</ul>

<p>(4) <strong>Bellman Ford(queue):</strong> No directed Cycles</p>

<ul>
<li>typical: <code>E + V</code></li>
<li>worst: <code>E * V</code></li>
<li>extra space: <code>V</code></li>
</ul>

<p><em>SPT</em> 를 정리하면</p>

<p><em>directed cycle</em> 은 문제를 더 어렵게 만들고,
<em>negative weight</em> 도 문제를 더 어렵게 만들고,
<em>negative cycles</em> 는 문제를 풀 수 없게 만든다. (내가 배운 한도 내에서는)</p>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://en.wikipedia.org/wiki/Bipartite_graph' >Wikipedia: Bipartite Graph</a> <br />
(3) <a href='http://www.biodatamining.org/content/4/1/10/figure/F3?highres=y' >http://www.biodatamining.org/</a> <br />
(4) <a href='http://ko.wikipedia.org/wiki/%ED%8F%89%EB%A9%B4_%EA%B7%B8%EB%9E%98%ED%94%84' >Wikipedia: 평면그래프</a> <br />
(5) <a href='http://www.csupomona.edu/' ~ftang">CS241 Lecture Notes: Graph Algorithms</a> <br />
(6) <a href='http://rahuldotgarg.appspot.com/data/SeamCarvingWeb/evaluation.htm' >Seam Carving for Content-Aware Image Resizing</a> <br />
(7) <a href='http://algs4.cs.princeton.edu/44sp/' >Algorithms: Shortest Path</a> <br />
(8) <a href='http://stackoverflow.com/questions/19760077/what-does-bellman-ford-algorithm-detects-negative-weight-or-negative-cycle' >What does bellman ford algorithm</a></p>]]></description><link>http://1ambda.github.io/graph-challenges-minimum-spanning-trees/</link><guid isPermaLink="false">22c06085-7f5c-45eb-8efc-31870d3ed425</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[graph]]></category><category><![CDATA[minimum spanning tree]]></category><category><![CDATA[shortest-path]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 03 Dec 2014 06:01:51 GMT</pubDate></item></channel></rss>