<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Old Lisper]]></title><description><![CDATA[Lisp, Emacs, Scala]]></description><link>http://1ambda.github.io/</link><generator>Ghost 0.5</generator><lastBuildDate>Sat, 08 Nov 2014 10:14:27 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Graphs, The Contraction Algorithm]]></title><description><![CDATA[<p>이번엔 지난시간에 배운 <em>randomized algorithm</em> 을 새로운 <em>domain</em> 인 그래프에 적용해 보고, <em>contraction algorithm</em> 이 무엇인지 알아본다.</p>

<h3 id="graphs">Graphs</h3>

<p>용어 정리부터 시작하자. <em>edge</em> <code>(E)</code> 는 <em>pair of vertices</em> 와 같은 말이다. <code>(E)</code> 는 <em>directed or undirected</em> 일 수 있으므로 <em>unordered pair</em> 또는 <em>ordered pair</em> 일 수 있다. <em>directed edges</em> 는 다른말로 <em>arcs</em> 라 부르기도 한다.</p>

<p><em>cut</em> 은 그래프를 비어있지 않은 두개의 그룹으로 분리하는 것을 말한다.</p>

<blockquote>
  <p>A cut of a graph <code>(V, E)</code> is a partition of <code>V</code> into two non-empty sets <code>A</code> and <code>B</code></p>
</blockquote>

<p>따라서 <em>vertice</em> 가 <code>n</code> 개라면 <code>2^n - 2</code> 개의 <em>cut</em> 을 만들 수 있다.</p>

<h3 id="minimumcutproblem">Minimum Cut Problem</h3>

<p><em>crossing edge</em> 를 최소로 하는 <em>cut</em> 을 찾는 문제다. 이걸 어디다 쓸 수 있을까?</p>

<p>(1) identify network bottlenecks / weaknesses <br />
(2) community detection in social network  </p>

<p>두 사람 혹은 집단간 강하게 결합되고 나머지와는 약하게 결합된 부분(<em>mimimum cut</em>) 을 찾으면 두 개체간 관련성이 있다고 볼 수 있다.    </p>

<p>(3) image segmentation  </p>

<p>이미지를 <em>2D grid</em> 라 <em>grid edge</em> 를 만들어 <em>same object</em> 에서 왔을 가능성을 나타내는 가중치를 부여해 <em>min cut</em> 을 하면 쓸모 없는 부분이 잘려나간다.</p>

<h3 id="graphrepresentation">Graph representation</h3>

<p>그래프가 <em>sparse graphs</em>, <em>dense graphs</em> 냐에 따라 알고리즘이 성능이 잘 나올수도 있고 아닐수도 있기 때문에 이 두 가지를 구분해 보자.</p>

<p><code>n</code> 을 <em>the number of vetices</em>, <code>m</code> 을 <em>the number of edges</em> 라 하자. 대부분의 경우에 <code>m</code> 은 <code>Omega(n)</code>, <code>O(n^2)</code> 이다.</p>

<p><em>sparse graph</em> 는 <code>m</code> 이 <code>O(n)</code> 에 가깝고 <em>dense graphs</em> 는 <code>m</code> 이 <code>O(n^2)</code> 에 가깝다.</p>

<h3 id="adjacencymatrix">Adjacency Matrix</h3>

<p>그래프를 자료구조로 표현하는 몇 가지 방법이 있는데 <em>Adjacency matrix (인접행렬)</em> 의 경우에는 노드 수, <code>n</code> 에 대해 <code>n x n</code> 의 행렬 <code>A</code> 를 만들어서 <code>A_ij</code> 를 <code>i</code> 노드와 <code>j</code> 노드가 연결되었다면 값을 <code>1</code> 채운다</p>

<p>몇 가지 변형이 있을 수 있는데 <em>parallel edges</em> 가 허용된다면 <code>A_ij</code> 는 연결된 엣지 수 일 수 있고, <code>A_ij</code> 에 가중치를 담는 경우도 있다. <em>directed graph</em> 면 <code>i -&gt; j</code> 냐 <code>j -&gt; i</code> 냐에 따라 <code>-1 or +1</code> 을 값으로 사용할 수 있다.</p>

<p>어떤 경우든 <em>adjacency matrix</em> 방식 자체는 <em>edge</em> 수와는 관계 없이 <em>vertice</em> 수의 제곱에 비례하는 공간이 필요하다. 따라서 <em>sparse graphs</em> 에서는 사용하지 않는 편이 낫다.</p>

<h3 id="adjacencylist">Adjacency List</h3>

<p><em>Adjacency list (인접 리스트)</em> 로 그래프를 표현할 경우엔 </p>

<p>(1) array (or list) of vertices (<code>theta(n)</code>) <br />
(2) array (or list) of edges (<code>theta(m)</code>) <br />
(3) each edge points to its endpoint (<code>theta(m)</code>) <br />
(4) each vertex points edges (<code>theta(m)</code>)</p>

<p>(4) 의 경우 <em>undirected graph</em> 라면 명확한데, <em>directed graph</em> 의 경우에는 <em>tail</em> 만 저장 한다던지 몇가지 방법을 쓸 수 있다. </p>

<p>그럼 <em>adjacency list</em> 는 얼마의 공간을 차지할까? (3) 의 경우는 위에 표시했듯이 (<code>theta(m)</code>) 인데, 각각의 <em>edge</em> 는 2 개의 <em>vertex</em> 를 저장하지만 <code>2</code> 는 상수 취급한다.</p>

<p>(4) 가 노드마다 간선 수가 달라 계산이 어려울 수 있는데, (3) 과 1:1 대응이라 보면 된다. 노드가 가리키는 간선이나, 간선이 가리키는 노드나 수는 같다. 따라서 (<code>theta(m)</code>) 이므로 전체 메모리 사용은 (<code>theta(m + n)</code>) 이다. </p>

<p>그러면 인접 행렬과 인접 행렬중 어떤게 더 나을까? 둘 다 장단이 있지만 <em>graph search</em> 는 단연 인접 행렬이 더 낫고, 요즘엔 <em>node</em> 는 정말 많은 반면 <em>edge</em> 는 좀 적기 때문에 인접 리스트가 더 낫다.</p>

<p>간단히 웹만 생각해봐도 노드 자체는 엄청나게 많은 반면 간선은 적다. 만약 인접 행렬로 그래프를 표현하면 노드 수의 제곱에 비례하는 메모리가 필요한데, 이건 리소스 문제를 겪을 수 있다.</p>

<h3 id="randomcontractionalgorithm">Random Contraction Algorithm</h3>

<p><em>min cut</em> 을 해결하기 위해 <em>quick sort</em>, <em>randomized selection</em> 에서 보았던 랜덤 샘플링을 이용할건데, 이 문제는 랜덤 샘플링이 그래프 문제에도 얼마나 효과적인지 보여준다. 알고리즘은 이렇다.</p>

<p>(1) while there are more than 2 vertices <br />
(2) pick a remaining edge <code>(u, v)</code> uniformly at random <br />
(3) merge (or "contract") <code>u</code> and <code>v</code> into a single vertex <br />
(4) remove self-loops <br />
(5) return cut represented by final 2 vertices  </p>

<p>해보면 알겠지만 이 알고리즘은 <em>min cut</em> 을 답으로 제공할 수도, 아닐 수도 있다. 따라서 문제는, <em>What is prob of success?</em> 를 계산하는 것으로 바뀐다.</p>

<h3 id="analysiscontractionalgorithm">Analysis: Contraction Algorithm</h3>

<p>분석 전에 몇 가지 용어를 정의하고 가자. <em>graph</em> <code>G = (V, E)</code> 에 대해 <code>n</code> 개의 <em>vertices</em>, <code>m</code> 개의 <em>edges</em> 가 있다. 그리고 <em>minimum cut</em> <code>(A, B)</code> 는 <code>G</code> 를 두개의 비어있지 않은 그룹 <code>A</code>, <code>B</code> 로 나눈다. 그리고 <code>k</code> 를 <code>(A, B)</code> 의 <em>crossing edges</em> 숫자라 하자. 그리고 이들 <em>crossing edges</em> 를 <code>F</code> 라 부르자.</p>

<p>만약에 <code>F</code> 중 하나의 <em>edge</em> 가 <em>contraction</em> 알고리즘 중에 선택 된다면 <code>(A, B)</code> 는 섞여버린다. </p>

<p>따라서 이터레이션 동안 <code>A</code> 내부에 있는 <em>vertex</em> 끼리만, 그리고 <code>B</code> 내부에 있는 <em>vertex</em> 끼리만 <em>contraction</em> 이 일어나야 한다. 그래야만 <em>minimum cut</em> 을 찾을 수 있다.</p>

<p>따라서 올바른 <code>(A, B)</code> 를 아웃풋으로 얻을 확률은 <code>F</code> 중 어느 <em>edge</em>도 선택되지 않을 확률과 같다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?P_r%5Boutput%20%5C%20is%20%5C%20%28A%2C%20B%29%5D%20%3D%20P_r%5Bnever%5C%20contracts%5C%20an%5C%20edge%5C%20of%20F%5D'  alt="" /></p>

<p><del>Tex 에 맛들려서 이미지를 추가한건 아니요!</del></p>

<p><code>S_i</code> 를 <code>F</code> 에 있는 <em>edge</em> 가 이터레이션 <code>i</code> 에서 <em>contracted</em> 되는 <em>event (사건)</em> 이라 하자. 그럼 우리의 목표는 다음의 확률을 계산하는 것이다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20S_1%20%5Ccap%20%5Cneg%20S_2%20%5Ccap%20%5Ccdots%20%5Ccap%20%5Cneg%20S_%7Bn-2%7D%5D'  alt="" /></p>

<p>증명에 사용할 재미난 그래프의 특징이 하나 있다. 모든 <em>vertex</em> 의 <em>incident edges, degree</em> 의 값은 <code>k</code> 보다 크거나 같다. 왜냐하면 모든 <em>vertex</em> 는 그 자신과 나머지를 분리하는 <em>cut</em> 을 가지는데, 이게 <code>k</code> 라면 <em>min cut</em> 이고 아니라면 <code>k</code> 보다 크기 때문이다.    </p>

<blockquote>
  <p>degree of each vertex is at least <code>k</code></p>
</blockquote>

<p>그리고 모든 <em>vertex</em> 의 <em>degree</em> 는 <code>2m</code>, 즉 모든 <em>edge</em> 수의 2배이기 때문에 아래 식은 참이고, </p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Csum_%7Bv%7Ddegree%28v%29%20%3D%202m'  alt="" /></p>

<p>위 식과 각 <em>degree</em> 합은 <code>kn</code> 보다 크거나 같으므로 <code>2m</code> 도 <code>kn</code> 보다 크거나 같다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?2m%20%5Cgeq%20kn'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?m%20%5Cgeq%20%28kn/2%29'  alt="" /></p>

<p>여기서 처음 이터레이션에서 <code>F</code> 내에 있는 <em>edge</em> 가 선택될 확률인 <code>P(S_1) = k / m</code> 이기 때문에 </p>

<p><img src='http://latex.codecogs.com/gif.latex?%7B2%20%5Cover%20n%7D%20%5Cgeq%20%7Bk%20%5Cover%20m%7D'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?P_r%5BS_1%5D%20%5Cleq%20%7B2%20%5Cover%20n%7D'  alt="" /></p>

<p>이제 <code>P(S_1)</code> 을 구했으니, 두번째 이터레이션에서 <code>F</code> 내에 있는 <em>edge</em> 가 선택되지 않을 확률을 구해보자. 조건부 확률 공식을 이용하면, </p>

<p><img src='http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20S_1%20%5Ccap%20%5Cneg%20S_2%5D%20%3D%20P_r%5B%5Cneg%20S_2%20%7C%20%5Cneg%20S_1%5D%20' *%20P_r%5B%5Cneg%20S_1%5D" alt="" /></p>

<p>이때 <code>P(~S_1)</code> 이 <code>n/2</code> 보다 작거나 같으므로</p>

<p><img src='http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20S_1%5D%20%5Cgeq%20%281%20-%20%7B2%20%5Cover%20n%7D%29'  alt="" /></p>

<p>나머지 <code>P(~S_2 | ~S_1)</code> 을 구하려다 보니 남아있는 <em>edge</em> 가 얼만지 알 수가 없다. </p>

<p><img src='http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20S_2%20%7C%20%5Cneg%20S_1%5D%20%3D%201%20-%7Bk%20%5Cover%20number%20%5C%20of%5C%20remaining%20%5C%20edges%7D'  alt="" /></p>

<p>그런데, 본래의 그래프가 모든 <em>vertex</em> 에 대해 <em>at least</em> <code>k</code> 개의 <em>edge</em> 를 가졌으면 <em>contracted</em> 된 그래프도 모든 <em>vertex</em> 에 대해 <em>at least</em> <code>k</code> 개의 <em>edge</em> 를 가져야 한다. (우리는 <code>F</code> 내의 <em>edge</em> 를 선택하지 않았기 때문)</p>

<p>따라서 <em>remaining edge</em> 는 <code>1/2 * k * (n-1)</code> 보다 크다. (1/2 은 <code>n</code> 으로 <em>edge</em> 수를 세면 두번씩 카운팅하기 때문에 필요)</p>

<p><img src='http://latex.codecogs.com/gif.latex?%7Bnumber%20%5C%20of%5C%20remaining%20%5C%20edges%7D%20%5Cgeq%201/2%20' *%20k%20*%20%28n-1%29" alt="" /></p>

<p><em>denominator</em> 의 <em>lower bound</em> 를 구했기 때문에 <em>fraction</em> 의 <em>upper bound</em> 를 구한셈이 된다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20S_2%20%7C%20%5Cneg%20S_1%5D%20%5Cgeq%201%20-%7B2%20%5Cover%20n%20-%201%7D'  alt="" /></p>

<p>이제 규칙성이 보인다. 우리가 구하려는 값은 </p>

<p><img src='http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20S_1%20%5Ccap%20%5Cneg%20S_2%20%5Ccap%20%5Ccdots%20%5Ccap%20%5Cneg%20S_%7Bn-2%7D%5D'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?%3D%20P_r%5B%5Cneg%20S_1%5D%20' *%20P_r%5B%5Cneg%20S_2%20%7C%20S_1%5D%20*%20P_r%5B%5Cneg%20S_3%20%7C%20%5Cneg%20S_2%20%5Ccap%20%5Cneg%20S_1%5D%20*%20%5Ccdots%20*%20P_r%5B%5Cneg%20S_%7Bn-2%7D%20%7C%20%5Cneg%20S_1%20%5Ccap%20%5Ccdots%20%5Ccap%20%5Cneg%20S_%7Bn-3%7D%5D" alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Cgeq%20%281%20-%20%7B2%20%5Cover%20n%7D%29' *%281%20-%20%7B2%20%5Cover%20%28n%20-%201%29%7D%29*%281%20-%20%7B2%20%5Cover%20%28n%20-%202%29%7D%29*%5Ccdots*%20%281%20-%20%7B2%20%5Cover%20%28n%20-%20%28n-4%29%29%7D%29%20*%20%281%20-%20%7B2%20%5Cover%20%28n%20-%20%28n-3%29%29%7D%29" alt="" /></p>

<p>정리하면</p>

<p><img src='http://latex.codecogs.com/gif.latex?%3D%20%7B2%20%5Cover%20n%20%5C%20%28n-1%29%7D%20%5Cgeq%20%7B1%20%5Cover%20n%5E2%7D'  alt="" /></p>

<p>따라서 <em>contraction</em> 알고리즘이 성공할 확률은 <code>n</code> 이 크면 굉장히 낮다. 근데 이게 <em>brute-force</em> 에 비하면 놀랍게도 굉장히 높은 성공률이다. </p>

<p>본래 <code>n</code> 개의 <em>vertex</em> 가 있으면 모든 <em>cut</em> 을 다 해 보려면 <code>2^n</code> 의 시도가 필요하다. 따라서 <em>contraction</em> 알고리즘은 꽤 높은 확률을 보장하는 알고리즘이다. </p>

<p><code>T_i</code> 를 <code>i</code> 번째 <em>trial</em> 에서 <em>min cut</em> 을 찾아낼 확률이라 하자. <code>N</code> 번의 <em>trial</em> 동안 <em>min cut</em> 을 찾지 못할 확률은, 매 <em>trial</em> 이 독립적이기 때문에 </p>

<p><img src='http://latex.codecogs.com/gif.latex?P_r%5B%5Cneg%20T_1%20%5Ccap%20%5Cneg%20T_2%20%5Ccap%20%5Ccdots%20%5Ccap%20%5Cneg%20T_N%20%5Ccap%20%5D%20%3D%20%5Cprod_%7Bi%20%3D%201%7D%5EN%20P_r%5B%5Cneg%20T_i%5D'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Cprod_%7Bi%20%3D%201%7D%5EN%20P_r%5B%5Cneg%20T_i%5D%20%5Cleq%20%281%20-%20%7B1%20%5Cover%20n%5E2%20%7D%29%5EN'  alt="" /></p>

<p>이 때 <code>1 + x &lt;= e^x</code> 란 사실을 이용하면 좀 더 간단한 <em>upper bound</em> 를 찾으 수 있다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?%281%20-%20%7B1%20%5Cover%20n%5E2%20%7D%29%5EN%20%5Cleq%20%28e%5E%7B-1%20%5Cover%20n%5E2%7D%29%5EN'  alt="" /></p>

<p>이때 <code>N = n^2</code> 이라면 <code>N</code> 번째까지 실패할 확률은 <code>1/e</code> 보다 작거나 같다. 만약에 <code>N = n^2 lnn</code> 이면 <code>1/n</code> 까지 내려간다.</p>

<p>따라서 단순히 계산을 반복하는 것만으로도 성공 확률을 <code>1/n^2</code> 에서 <code>1 - 1/n</code> 까지 올릴 수 있다.</p>

<p><em>running time</em> 은 <code>Omega(n^2 * m)</code> 쯤 된다. <code>n^2</code> 정도의 <em>trial</em> 이 필요하고 매 <em>trial</em> 마다 <code>m</code> 의 <em>edge</em> 를 살펴봐야 한다.</p>

<p>여전히 느리다. 이후에는 단순히 <em>trial</em> 을 늘리는 것 뿐만 아니라 다양한 옵티마이제이션 기법을 활용하는법을 배워보자. 거의 <code>O(n^2)</code> 까지 줄일 수 있다.</p>

<h3 id="countingminimumcuts">Counting Minimum Cuts</h3>

<p>그래프를 그려보면 알겠지만 <em>min cut</em> 은 한개가 아니라 여러개 일 수 있다. 그러면 <code>n</code> 개의 <em>vertice</em> 를 가진 그래프에서 최대로 가질 수 있는 <em>min cut</em> 은 몇개 일까? </p>

<p>그래프에서 각 노드마다 <em>edge</em> 가 하나밖에 없을땐 <code>n-1</code> 이고, 아무리 <em>cut</em> 이 많아봐야 <code>2^n - 2</code> 보다 적으니까 이 사이에 있는건 분명하다.</p>

<p>답은 <em>n choose 2</em>, <code>(n * (n - 1)) / 2</code> 다.</p>

<p>먼저 <em>lower bound</em> 부터 보자. <em>n-cycle</em> 그래프를 보면 2개를 끊으면 되므로 <code>nC2</code> 다. </p>

<p>따라서 <code>n</code> 개의 <em>vectice</em> 를 가진 모든 그래프 중에서 가장 많은 <em>min-cut</em> 을 가진 그래프들은 적어도 이것보다는 많은 <em>min-cut</em> 을 가져야 한다.</p>

<p><em>upper bound</em> 를 보자. <code>(A1, B1), (A2, B2), ..., (At, Bt)</code> 만큼의 <em>min cut</em> 이 있다 하자. 이 때 특정 <em>min cut</em> 인 <code>(Ai, Bi)</code> 가 나올 확률은 위의 증명을 다시 보면 <code>1/n^2</code> 보다 큰 <code>2/(n(n-1))</code> 이다. 이건 <code>nC2</code> 를 뒤집은 수다.</p>

<p>다시 말해서 <em>min cut</em> 을 뽑아낼 확률이</p>

<p><img src='http://latex.codecogs.com/gif.latex?P%5Boutput%5C%20%3D%5C%20%28A_i%2C%20B_i%29%5D%20%5Cgeq%20%7B2%20%5Cover%20n%28n-1%29%7D%20%3D%20%7B1%20%5Cover%20%5Cbinom%7Bn%7D%7B2%7D%7D'  alt="" /></p>

<p>이 때 <code>S_i</code> 를 <code>(A_i, B_i)</code> 가 나오는 사건이라 하면 <code>S_i</code> 각각은 <em>disjoint</em> 다.</p>

<p>중요하니까 다시 한번 반복하면, <code>S_i</code> 는 <em>disjoin</em> 고 이로인해 모든 <code>S_i</code> 를 합하면 <code>1</code> 이다. 따라서 </p>

<p><img src='http://latex.codecogs.com/gif.latex?%7Bt%20%5Cover%20%5Cbinom%7Bn%7D%7B2%7D%7D%20%5Cleq%201'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?%7Bt%7D%20%5Cleq%20%5Cbinom%7Bn%7D%7B2%7D'  alt="" /></p>

<p>이건 <em>upper bound</em> 다. <em>lower bound</em> 와 같으므로 모든 <code>n</code> 개의 <em>vertice</em> 를 가진 그래프는 최대 <code>nC2</code> 의 <em>min cut</em> 을 가진다.</p>

<h3 id="conditionalprob">Conditional Prob</h3>

<p>중간에 잠깐 조건 부 확률과 독립성, 그리고 기대값에 대해 나오는데 반-직관적인 예제를 교수님이 소개해 주셔서 적어볼까 한다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?X_1%2C%20X_2%20%5Cin%20%5C%7B%200%2C%201%20%5C%7D%20%5C%20and%20%5C%20X_3%20%3D%20X_1%20%5Coplus%20X_3'  alt="" /></p>

<p>일때 <code>X_1</code> 과 <code>X_3</code> 는 독립이고, <code>X_1, X_3</code> 와 <code>X_2</code> 는 독립이 아니다. 기대값을 이용하면 쉽게 증명이 가능하다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?E%5BX_1%2C%20X_2%2C%20X_3%5D%20%5Cneq%20E%5BX_1%2C%20X_2%5D%20' *%20E%5BX_3%5D" alt="" /></p>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Design and Analysis, Part 1</em> by <strong>Tim Roughgarden</strong>  </p>]]></description><link>http://1ambda.github.io/graphs-the-contraction-algorithm/</link><guid isPermaLink="false">29f4c654-dc5f-4724-b30c-760a534e17c2</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[randomization]]></category><category><![CDATA[graph]]></category><category><![CDATA[contraction]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 08 Nov 2014 05:00:35 GMT</pubDate></item><item><title><![CDATA[Randomized Selection]]></title><description><![CDATA[<h3 id="intuition">Intuition</h3>

<p>중복이 없는 <code>n</code> 개의 원소를 가진 배열에서 <code>i</code> 번째로 큰 원소를 얻고 싶다고 하자. 간단한 방법은 먼저 정렬을 한 뒤 거기서 <code>i</code> 번째 원소를 고르면 된다. 이 방법을 <em>reduction</em> 이라 부르는데 <em>selection</em> 문제를 <em>sorting</em> 문제로 바꾸어 푼 것이다. 이 경우 정렬에 머지소트를 사용한다면 <code>O(n logn)</code> 만큼의 시간이 걸릴 것이다.</p>

<p><em>selection</em> 문제는 <code>O(n)</code> 시간 안에 <em>deterministic</em> 하게 해결할 수 있다. 지난시간에 잠깐 논의했던 <em>randomization</em> 을 이용하면 된다. 어떻게 그럴 수 있을까? 저기서 정렬을 더 개선할 수 없다는건 모두가 알고 있는 사실인데</p>

<p><em>quick sort</em> 를 수정해서 <em>pivot</em> 을 <em>median of medians</em> 로 고르면 된다. <del>아니 의사양반 이게 무슨 개소리요!</del></p>

<p>더 정확히 말해서 이 문제는 <strong>정렬 문제가 아니기 때문에</strong> 더 개선할 여지가 있다. <em>pivot</em> <code>P</code> 를 기준으로 좌측이나 우측 한쪽만 선택하면 되는 <em>selection</em> 문제다.</p>

<p><em>worst case</em> 는 당연히 매 재귀호출마다 문제 수가 1씩 줄어드는 경우이므로 <code>O(n^2)</code> 일테다. 만약에, <em>bast case</em> 로 문제가 절반씩 줄어든다면? <em>master method</em> 를 이용하면 <code>a = 1, b = 2, d = 1</code> 에서 <code>T(n) = O(n^1)</code> 이다.</p>

<p><img src='https://acrocontext.files.wordpress.com/2014/01/master-method.png?w=300&amp;h=160'  alt="" /></p>

<p>그럼 이제 문제는 어떻게 사이즈를 <code>1/2</code> 로, 더 정확히는 <em>median</em> 을 <em>pivot</em> 으로 삼느냐다.</p>

<h3 id="analysis">Analysis</h3>

<p><em>randomized selection</em> 문제를 풀기 위해 구현한 함수를 <code>rSelect</code> 라 하자. 매 재귀마다 문제 사이즈가 <code>n</code> 이라고 하면, 각 재귀에서의 <code>rSelect</code> 의 연산은 <code>c * n</code> 보다 작거나 같다. (<code>c</code> 는 상수)</p>

<p>이제 본격적인 분석전에  잠깐 <em>notation</em> 을 하나 만들고 가면 <code>phase j</code> 는 문제의 사이즈가 <code>(3/4)^j+1 * n</code> 과 <code>(3/4)^j * n</code> 사이에 있는 <code>rSelect</code> 다. 따라서 문제의 사이즈가 <code>n</code> 부터 <code>3/4</code> 가 되기 전까지의 모든 <code>rSelect</code> 는 <code>phase 0</code> 에 있다.</p>

<p>그리고 <code>Xj</code> 를 <code>phase j</code> 에 있는 <code>rSelect</code> 호출의 수라 정의하면</p>

<p><img src='http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20%5Csum_%7Bphase%20j%7D%20X_j%20' *%20c%20*%20%28%7B3%20%5Cover%204%7D%29%5Ej%20*%20n" alt="" /></p>

<p>이렇게 정의해 놓으면 재밌는 조건을 하나 쓸 수 있다. 바로 <em>pivot</em> 이 <code>25%-75%</code> 사이로 분할만 해주면, 다시 말해서 반으로 갈린 문제 중 작은 한쪽이 적어도 <code>25%</code> 가 넘으면 현재 <em>phase</em> 가 끝난다. 그럼 이제 전체 알고리즘의 기대값을 구하기 위해 <em>linearity of expectation</em> 을 이용해서 <code>E(Xj)</code> 를 구하면 된다. </p>

<p><code>25-75%</code> 로 피벗이 걸릴 확률 <code>P(25-75%) = 1/2</code> 이고 그럴때의 <code>Xj = 1</code> 이다. 반면 두번째에 피벗이 제대로 걸릴 확률은 <code>1/4</code> 이고, 세번째에 피벗이 제대로 걸릴 확률은 <code>1/2^3</code> 이다.</p>

<p>기대값은 이 모든 각각 확률변수값과 그 확률의 곱이므로 계산하면</p>

<p><img src='http://latex.codecogs.com/gif.latex?%7B1%20%5Cover%202%7D%20&plus;%20%7B1%20%5Cover%202%5E2%7D%20&plus;%20%7B1%20%5Cover%202%5E3%7D%20&plus;%20%5Ccdots%20%5Cleq%202'  alt="" /></p>

<p>이것 말고 더 재밌는 계산법도 있다. 자세한 건 강의 내용을 참조 </p>

<p><img src='http://latex.codecogs.com/gif.latex?E%28X_j%29%20%3D%201%20&plus;%20%7B1%20%5Cover%202%7D%20' *%20E%28X_j%29" alt="" /></p>

<p>이제 <em>average running</em> 타임을 구하기 위해 <code>T(n)</code> 의 평균을 구하면</p>

<p><img src='http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20E%5Bc%20' *%20n%20*%20%5Csum_%7Bphase%20j%7D%20%28%7B3%20%5Cover%204%7D%29%5Ej%20*%20X_j%5D" alt="" /></p>

<p>여기서 <em>linearity of expectation (기대값의 선형성)</em> 을 이용하면</p>

<p><img src='http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20c%20' *%20n%20*%20%5Csum_%7Bphase%20j%7D%20%28%7B3%20%5Cover%204%7D%29%5Ej%20*%20E%28X_j%29" alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20c%20' *%20n%20*%20%5Csum_%7Bphase%20j%7D%202%20*%20%28%7B3%20%5Cover%204%7D%29%5Ej" alt="" /></p>

<p>무한급수 공식을 적용하면,</p>

<p><img src='http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20c%20' *%20n%20*%204" alt="" /></p>

<p><del>얼마나 멋진가?</del></p>

<h3 id="deterministicselection">Deterministic Selection</h3>

<p>만약에 <em>randomization</em> 을 이용할 수 없다면? 그럼 이제 문제는 <em>good pivot</em>, 즉 <code>50/50</code> 에 최대한 가깝게 잘라내는 <em>pivot</em> 을 찾아야 한다. <em>median of medians</em> 를 이용하면 해낼 수 있다.</p>

<p><em>deterministic selection</em> 알고리즘을 구현한 함수를 <code>dSelect</code> 라 부르면</p>

<pre><code>dSelect(array A, length n, order statistic i)  
</code></pre>

<p>(1) Break <code>A</code> into groups of 5, sort each group <br />
(2) C = the <code>n/5</code> "middle elements" <br />
(3) p = <code>dSelect(C, n/5, n/10)</code>, recursivly computes median of C <br />
(4) Partition <code>A</code> around <code>p</code> <br />
(5) if <code>j = i</code> return <code>p</code> <br />
(6) if <code>j &lt; i</code> return <code>dSelect(1st part of A, j-1, i)</code> <br />
(7) if <code>j &gt; i</code> return <code>dSelect(2nd part of A, j-j, i-j)</code>  </p>

<p><code>4-7</code> 스텝은 <em>randomized selection</em> 과 똑같다. 더 복잡해진 부분은 앞의 <code>1-3</code> 스텝에서 피벗을 고르는 일이다.</p>

<p>퍼포먼스를 다시 이야기 해 보자 <em>randomized selection</em> 은 <em>pivot</em> 이 정말 나쁘게 선택되면 <code>O(n^2)</code> 이 될 수 있다. </p>

<p>반면 <em>deterministic selection</em> 은 모든 경우에 <code>O(n)</code> 을 보장한다. 그러나 실제로는 <em>randomized</em> 보다 성능이 나쁜데, 이유는 알고리즘에서 볼 수 있듯이 새로운 배열 <code>C</code> 가 필요하고 (<em>not in-place</em>), 표기법에는 상수가 생략되는데 <em>deterministic selection</em> 은 이 상수가 꽤나 커질 수 있다.</p>

<h3 id="analysis">Analysis</h3>

<p>이제 좀 더 자세히 살펴보자.</p>

<p>(1) Break <code>A</code> into groups of 5, sort each group  </p>

<p>이건 얼마의 시간이 걸릴까? 주어진 배열을 5개씩 짜르고, 각각의 그룹을 정렬하는데 걸리는 시간은? <code>O(n)</code> 이다.</p>

<p>먼저 <code>n = 120</code> 이라 하자. 정렬에 <em>merge sort</em> 를 사용하면 <em>merge sort</em> 연산 수 공식은</p>

<p><img src='http://latex.codecogs.com/gif.latex?6n%20' *%20log_2%28n&plus;1%29" alt="" /></p>

<p>따라서 잘려진 5개짜리를 정렬하는데 걸리는 시간은 <code>30 * log_2(6)</code> 에서, 이 값은 적어도 120 보다는 작음을 알 수 있다. 따라서 전체 그룹의개수 <code>n/5</code> 를 곱하면, <code>24n</code> 으로 <code>O(n)</code> 임을 알 수 있다. 비록 상수가 좀 크긴 하지만</p>

<p>(2) C = the <code>n/5</code> "middle elements" <br />
(3) p = <code>dSelect(C, n/5, n/10)</code>, recursivly computes median of C <br />
(4) Partition <code>A</code> around <code>p</code> <br />
(5) if <code>j = i</code> return <code>p</code> <br />
(6) if <code>j &lt; i</code> return <code>dSelect(1st part of A, j-1, i)</code> <br />
(7) if <code>j &gt; i</code> return <code>dSelect(2nd part of A, j-j, i-j)</code>  </p>

<p>(2), (4) 는 <code>O(n)</code> 임을 알 수 있고, (3) 은 <code>T(n/5)</code> 다. 문제는 (6), (7) 이다. 둘 중에 하나만 호출되긴 하지만 선택되는 <em>pivot</em> <code>p</code> 에 따라서 문제의 사이즈가 달라진다. 모르니까 <code>T(?)</code> 라 두자 그러면 <em>determinitic selection</em> 의 <em>running time</em> 은</p>

<p><img src='http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&plus;%20T%28n/5%29%20&plus;%20T%28%3F%29'  alt="" /></p>

<p>간단한 가설을 세워보자. </p>

<blockquote>
  <p><strong>두번째 <code>dSelect</code> 호출의 input size 는 <code>7/10 * n</code> 보다 작거나 같다</strong></p>
</blockquote>

<p>그러면 수식을 이렇게 바꿀 수 있다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&plus;%20T%28n/5%29%20&plus;%20T%287n/10%29'  alt="" /></p>

<p>(2) 에서 <em>medians</em> 를 찾고, 이걸 (3)에서 재귀에 한번 더 넘기면 <em>median of medians</em> 을 찾게된다. 이게 어떤 효과가 있냐면, 모든 원소를 5개씩 짤라 아래에서 위로 정렬, <em>medians</em> 는 좌에서 우로 정렬하면 다음과 같은 행렬이 나오는데</p>

<p><img src='http://i.imgur.com/gaOxb1A.jpg?1'  alt="" title="" /><p align="center">(<a href='http://functionspace.org/articles/19' >http://functionspace.org/articles/19</a>)</p></p>

<p>모든 원소 중 좌측 하단에 있는 <code>30%</code> 는 <em>median of medians</em> 보다 분명히 작다. 그리고 우측 상단 <code>30%</code> 는 <em>medians of medians</em> 보다 분명히 크다. 따라서 나머지 40% 값이 어쨌던건 간에 적어도 <code>30-70%</code> 분할은 해주므로 문제의 사이즈가 (6) 스텝에서 <code>7n/10</code> 보다 작거나 같다는 것을 분명히 보장해준다. 따라서 아래 식은 참이다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&plus;%20T%28n/5%29%20&plus;%20T%287n/10%29'  alt="" /></p>

<p>쉽게 <em>master method</em> 를 이용하고 싶은데 문제가 서로 다른 사이즈로 분할되니까 사용할 수 없다. <em>induction</em> 을 이용하자. 아래가 참임을 보이면 된다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20an'  alt="" /></p>

<p>우선 <em>base case</em> 는 <code>T(1) = 1</code> 이므로 <code>T(1) &lt;= a (where a &gt;= 1)</code> 에서 참이다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&plus;%20T%28n/5%29%20&plus;%20T%287n/10%29'  alt="" /></p>

<p>이제 위 식에서 <em>induction hypothesis</em> 를 이용하고, 정리하면</p>

<p><img src='http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&plus;%20a%28n/5%29%20&plus;%20a%287n/10%29'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20n%20' *%20%289a/10%29" alt="" /></p>

<p>이 때 <code>c</code> 는 상수이므로 <code>c = a / 10</code> 이라 하면 </p>

<p><img src='http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20an'  alt="" /></p>

<p>따라서 <em>deterministic selection</em> 의 성능은 <code>O(n)</code> 이다.</p>

<h3 id="lowerboundforsorting">lower bound for sorting</h3>

<p><em>comparison-based sorting</em> 의 <em>lower bound</em> 는 </p>

<p><img src='http://latex.codecogs.com/gif.latex?%0A%5COmega%20' (n*log%20n)" alt="" /></p>

<p>여기 해당되는 정렬들은 <em>merge sort, quick sort, heap sort</em> 등이 있다. 이런 정렬들은 데이터가 어떠할 것이라는 가정 없이 정렬을 해낸다. </p>

<p>반면 데이터의 분포를 안다면 <em>bucket sort</em> 같은 경우 <em>linear time</em> 으로 해결할 수 있다. <em>counting sort</em> 나 <em>radix sort</em> 같은 정렬도 데이터에 대한 정보(정수)라는 것을 이미 알고 있는 경우이므로 <code>O(n)</code> 으로 정렬 가능하다.</p>

<p>데이터에 대한 정보를 모른다고 해 보자. <code>1, 2, ..., n</code> 까지의 데이터를 가지고 있다면 이 데이터들이 배열 안에 담겨있을 수 있는 경우의 수는 <code>n!</code> 이다.</p>

<p><code>n!</code> 개의 모든 종류의 인풋에 대해서 <code>k</code> 번만큼, 혹은 그보다 더 적게 비교가 일어난다고 하자. 그럼 모든 <code>n!</code> 종류의 인풋에 대해서 <code>2^k</code> 개의 서로 다른 <em>execution</em> 이 생긴다.</p>

<blockquote>
  <p>Suppose algorithm always makes &lt;= k comparisons to correctly sort these <code>n!</code> inputs. Across all <code>n!</code> possile inputs algorithms exhibits &lt;= <code>2^k</code> distinct executions</p>
</blockquote>

<p>쉽게 생각해서 <code>k-bit</code> 문자열이 있을때 이걸로 얻을 수 있는 문자열은 <code>2^k</code> 개수다. 즉 어떤 문자는 없을수도 있다.</p>

<p>비둘기 집 원리를 생각해 보자. 우리는 <code>n!</code> 비둘기가 있고, <code>2^k</code> 개의 비둘기 집이 있다. 만약에 <code>k</code> 가 작아 <code>2^k &lt; n!</code> 이면 서로 다른 두개의 인풋에 대해서 같은 종류의 <em>execution</em> 을 공유 한다는 뜻이다. 따라서 둘 중 하나는 제대로 정렬되고, 나머지 하나는 제대로 정렬되지 않는다. </p>

<p>따라서 <code>2^k &gt;= n!</code> 이다. 이때 </p>

<p><img src='http://latex.codecogs.com/gif.latex?n%21%20%5Cgeq%20n%20' *%20%28n-1%29%20*%20%28n-2%29%20%5Ccdots%20%28n/2%29%20%5Cgeq%20%28n/2%29%5E%7B%28n/2%29%7D" alt="" /></p>

<p>이므로 </p>

<p><img src='http://latex.codecogs.com/gif.latex?2%5Ek%20%5Cgeq%20%28n/2%29%5E%7Bn/2%7D'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?k%20%5Cgeq%20%28n/2%29' *%20log_2%28n/2%29" alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?k%20%5Cgeq%20%5COmega%28n' *logn%29" alt="" /></p>

<p><code>k</code> 가 연산 수 이므로 <em>comparison-based sorting</em> 의 <em>lower bound</em> 는 <code>Omega(n logn)</code> 이다.</p>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Design and Analysis, Part 1</em> by <strong>Tim Roughgarden</strong> <br />
(2) <a href='http://functionspace.org/articles/19' >http://functionspace.org/articles/19</a></p>]]></description><link>http://1ambda.github.io/randomized-selection/</link><guid isPermaLink="false">fa03e2ba-fcfe-46a0-987a-4a8137bba43f</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[quick sort]]></category><category><![CDATA[selection]]></category><category><![CDATA[randomization]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 07 Nov 2014 08:17:47 GMT</pubDate></item><item><title><![CDATA[Machine Learning, Week 5]]></title><description><![CDATA[<p>지난시간엔 왜 <em>neural network</em> 를 사용하는지 알아보았다. 데이터의 차수가 매우 클 때 <em>logistic regression</em> 으로는 성능이 떨어지거나 <em>overfitting</em> 의 문제가 발생할 수 있다는 사실을 알게 되었고, 마지막엔 <em>multi class</em> 문제를 어떻게 해결할지도 잠깐 논의 해봤다.</p>

<p>이번에는 <em>back propagation</em>, <em>gradient checking</em> 에 대해서 배워보자.</p>

<h3 id="costfunction">Cost Function</h3>

<p>시작하기 전에 몇 가지 표기법을 정의하자.</p>

<p><code>L</code> 을 레이어의 수, <code>s_l</code> 을 해당 레이어의 유닛 수라 하자. 그러면 <em>bianry classification</em> 에서 <code>S_L = 1</code> 이다. 아웃풋 레이어의 유닛 수를 더 간단히 <code>K</code> 라 하자. </p>

<p>이제 <em>neural network</em> 에 대한 <em>cost function</em> 을 볼건데 먼저 <em>binary classification</em> 의 <em>regularized cost function</em> 식을 다시 보자.</p>

<p><img src='http://3.bp.blogspot.com/-qNym-oCdMIg/Trd03YeslWI/AAAAAAAAApQ/GUfXiJ3vpUE/s400/Screen+shot+2011-11-07+at+3.03.55+AM.png'  alt="http://aimotion.blogspot.kr/" /></p>

<p>지난 시간에 언급했듯이 신경망에서 각 단계는 <em>logistic regression</em> 과 같이 때문에 <code>L</code> 의 신경망은 <code>L-1</code> 의 <em>logistic regression</em> 의 식으로 변환할 수 있다.</p>

<p><img src='http://www.holehouse.org/mlclass/09_Neural_Networks_Learning_files/Image%20' [3].png" align="center" /></p>

<p><del>이 식의 가장 큰 문제점은 이 식을 보면 당황스럽다는 것이다.</del></p>

<p>뒷 부분 <em>regularization term</em> 은 이해하기 어렵지 않다. 신경망에선 <code>weight</code> (<em>theta</em>) 의 행렬이 이전 레이어와 다음 레이어의 유닛 수로 구성되므로 <code>(theta_ji^l)^2</code> 으로 모든 <code>theta^2</code> 를 구할 수 있다.</p>

<p>여기서 <code>i = 1</code> 부터 시작하는 이유는 <em>logistic regression</em> 의 <em>regularization term</em> 에서 <code>theta_0</code> 을 포함하지 않는것과 같다.</p>

<p>문제는 시그마 <code>K</code> 부분인데, <code>K</code> 가 이 신경망에서 클래스의 개수 라는 점을 고려하면 <code>y_k</code> 는 <code>[0; 0; 1; 0; ...]</code> 에서 <code>k</code> 번째 값, <code>(h0)_k</code> 또한 <code>k</code> 번째 <em>output unit</em> 의 값 이라 보면 된다.</p>

<p>원래 <em>cost function</em> 정의 자체가 우리가 가진 <em>hypothesis</em> 로 구한 값과 본래의 값 <code>y</code> 와의 차이를 알려주는 것이므로 <code>K</code> 개의 클래스가 있을때는 모든 클래스 값의 합과, 본래의 <em>k-dimensional vector</em> <code>y</code> 값의 합을 최소화 하는 것으로 <em>neural network</em> 의 <em>cost function</em> 을 정의할 수 있다.</p>

<h3 id="backpropagationalgorithm">Backpropagation: Algorithm</h3>

<p><em>gradient computation</em> 을 위해서는 <em>cost function</em> 과 각 <code>l</code> 의 <code>i</code>, <code>j</code> 위치의 <code>theta</code> 에 대해서 <em>cost function</em> 의 <em>partial derivative</em> 를 구해야 한다. <del>네?</del></p>

<p><img src='http://www.holehouse.org/mlclass/09_Neural_Networks_Learning_files/Image%20' [7].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p><img src='http://www.holehouse.org/mlclass/09_Neural_Networks_Learning_files/Image%20' [8].png" alt="http://www.holehouse.org/mlclass/09<em>Neural</em>Networks<em>Learning</em>files/Image%20[8].png" title="" /></p>

<p>다음과 같은 신경망이 있다고 하자, 그리고 <em>training set</em> 이 <code>(x, y)</code> 만 있다고 한다면 <em>cost function</em> 을 얻기 위해 다음의 <em>forward propagation</em> 을 진행하면 된다.</p>

<p><img src='http://www.holehouse.org/mlclass/09_Neural_Networks_Learning_files/Image%20' [9].png" alt="http://www.holehouse.org/mlclass/09<em>Neural</em>Networks<em>Learning</em>files/Image%20[9].png" title="" /></p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>그럼 <code>i, j, l</code> 에 대한 <em>cost function</em> 의 <em>partial derivative</em> 는 어떻게 구할까?</p>

<p><strong>back propagation</strong> 을 이용하면 된다. 개요는 이렇다. 마지막 단계에서 신경망을 이용해 얻은 값 <code>a4</code> 와 실제 값인 <code>y</code> 의 차이를 <code>d4</code>(<em>delta</em>) 라 하자. 보면 알겠지만 이건 <em>error</em> 다. 이 에러값을 이용해 <code>d3</code> 즉 레이어 3 에서의 에러값을 구하고, 반복하면서 <code>d2</code> 까지 구한다. (<code>d1</code> 은 없다. <code>a1</code> 이 <em>input</em> 이기때문) </p>

<p><em>forward propagation</em> 과 다르게 뒤에서 앞쪽으로 <em>error</em> 가 전파되기 때문에 <em>back propagation, BP</em> 라 부른다. BP 로 찾은 <code>d</code> 값을 이용하면 <em>partial derivative</em> 를 쉽게 구할 수 있다. <code>d3, d2</code> 를 구하는 방법은 아래와 같다. </p>

<p><img src='http://www.holehouse.org/mlclass/09_Neural_Networks_Learning_files/Image%20' [10].png" alt="http://www.holehouse.org/mlclass/09<em>Neural</em>Networks<em>Learning</em>files/Image%20[10].png" title="" /></p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>식에 대한 <em>intuition</em> 은 이전 레이어의 유닛의 <code>d</code> 를 얻기 위해서 다음 레이어의 모든 <code>d</code> 와 <code>theta</code> 의 곱을 이용한다는 사실이다. 이건 <em>FP</em> 에서 다음 단계의 유닛 <code>a</code> 를 얻기 위해 이전 단계의 모든 유닛과 <code>theta</code> 를 이용한다는 사실을 거꾸로 생각해보면 이해할 수 있다.</p>

<p>이때 <em>sigmoid function</em> <code>g</code> 의 미분은 <code>g' = g(1-g)</code> 이고, <code>g'(z3)</code> 는 <code>a3 * (1 - a3)</code> 으로 고쳐쓸 수 있다.</p>

<p>만약에 <em>regularization term</em> 을 무시한다면 다시 말해 <code>lambda = 0</code> 이면, <em>partial derivative</em> 는 <code>d</code> 를 이용해 쉽게 작성할 수 있다.  </p>

<p>알고리즘을 좀 자세히 살펴보면 </p>

<p><img src='http://my.csdn.net/uploads/201207/18/1342599882_9006.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/abcjennifer' >http://blog.csdn.net/abcjennifer</a>)</p>

<p>지금까지의 설명과 같이 먼저 <em>FP</em> 를 진행해서 각 레이어의 유닛 <code>a</code> 을 구하고, <em>BP</em> 를 진행한다.</p>

<p>이 때 마지막 단계에서 삼각형(<em>large delta</em>, <code>Delta</code>) 에 이전 단계의 <code>DELTA</code> 와 <code>aj^(l)di(l+1)</code> 를 더하는데, 사실 <code>aj^(l)di(l+1)</code> 가 바로 <em>reulgarization term</em> 을 무시했을 때의 <em>partial derivative</em> 다.</p>

<p>이렇게 모든 <code>DELTA</code> 를 구하고 나서 이제 <code>D</code> 에 <em>regularization term</em> 을 추가한다.</p>

<p><img src='http://my.csdn.net/uploads/201207/19/1342669084_1797.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/abcjennifer' >http://blog.csdn.net/abcjennifer</a>)</p>

<p>이제 <em>regularization term</em> 까지 더한 <code>D</code> 가 바로 <em>partial derivative</em> 다. <del>너무 난해하다</del></p>

<h3 id="backpropagationintuition">Back propagation: Intuition</h3>

<p>조금 더 <em>Back propagation, BP</em> 를 살펴보자. <code>dj^(l-1)</code> 를 얻기 위해 <code>d^(l)</code> 과 <code>theta</code> 를 이용한다는 사실은 알겠다. 근데 <code>g'</code> 이라던지 이런건 도대체 어디서 나온걸까?</p>

<p>처음으로 다시 돌아가면 <em>cost function</em> 에서 <em>training set</em> 이 1개라면 다시 말해 <code>m=1</code> 이고, <code>lambda=0</code> 이라면 <em>cost function</em> 은 <code>h(x), y</code> 에 의해 좌우된다. 결국 <em>squared error</em> 와 다를바 없다는 소리다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/08/1360304035_3064.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>결국 <code>dj^(l)</code> 은 <code>aj^(l)</code> 의 <em>error of cost</em> 다. 더 엄밀히 수학적으로 말하자면 <code>dj^(l)</code> 은 <code>cost(i)</code> 에 대한 <code>zj^(l)</code> 의 <em>partial derivative</em> 다. <code>zj^(l)</code> 이 변할때 <code>i</code> 에 대한 <em>cost</em> 가 얼마나 변하는지가 바로 <code>d</code> 란 이야기다. </p>

<p><img src='http://img.my.csdn.net/uploads/201302/08/1360304589_4715.png'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><code>d</code> 에 대한 더 엄밀한 수학적 증명은 </p>

<p><img src='http://latex.codecogs.com/gif.latex?' \delta_k%20=%20\frac{\partial%20J(\Theta)}{\partial%20z_k}%20=%20\frac{\partial%20J(\Theta)}{\partial%20a_k}\frac{\partial%20a_k}{\partial%20z_k}%20=%20\Theta_{k}\delta_{k+1}\cdot%20g%27(z_k)%20\\%20\Delta%20w_{ij}%20=%20\Delta%20w_{ij}%20+%20\frac{\partial%20J(\Theta)}{\partial%20w_{ij}}%20=%20\Delta%20w_{ij}%20+%20a_j^l%20\cdot%20\delta_k^(l+1)\\%20\frac{\partial%20J(\Theta)}{\partial%20w_{ij}}%20=%20\frac{\partial%20J(\Theta)}{\partial%20z_k}%20\cdot%20\frac{\partial%20z_k}{\partial%20w_{ij}}" alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/abcjennifer' >http://blog.csdn.net/abcjennifer</a>)</p>

<h3 id="unrollingparameters">Unrolling Parameters</h3>

<p><em>octave</em> 에서 <code>reshape</code> 함수를 이용해서 벡터를 매트릭스로 변환하는 방법을 알려준다. </p>

<p><img src='http://img.my.csdn.net/uploads/201302/08/1360306972_1270.png'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/08/1360307271_1026.png'  alt="" title="" /><p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p></p>

<h3 id="gradientchecking">Gradient Checking</h3>

<p><em>BP</em> 를 이용해서 <em>neural network</em> 의 <em>cost function</em> 을 위한 <em>partial derivative</em> 를 구하는 방법을 배웠는데, 안타깝게도 이게 쉽게 구현할 수 있는것이 아니라서 버그가 생길 수 있다.</p>

<p><em>gradient checking</em> 이란 방법을 이용하면 <em>FP, BP</em> 의 구현이 완벽함을 보일 수 있다. 배워보자.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/08/1360308451_8919.png'  alt="" title="" /><p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p></p>

<p>말 그대로 기울기에 대한 근사치를 구해서 비교하여 검증하는 방법이다. <code>e</code>(엡실론) 이 매우 작다 하고, <code>0-e</code> 와 <code>0+e</code> 두 점 사이의 기울기를 구해 <em>gradient</em> 와 근사한 값을 구한다.</p>

<p>우리는 <code>0</code> 가 하나가 아니기 때문에, 각각의 <code>0</code>(<code>theta</code>) 에 대해 모두 <em>gradient</em> 의 근사치를 구해야 한다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/08/1360308632_9597.png'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/08/1360308843_4503.png'  alt="" title="" /><p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p></p>

<p>마지막에서 <em>gradient checking</em> 을 이용해 구한 <code>gradApprox</code> 와 실제 <em>BP 를 이용해 구한 *graident</em> 인 <code>Dvec</code> 과 비슷한지 검사한다.</p>

<p>그러나, 한가지 알아야할 사실이 있다. <em>gradient checking</em> 은 굉장히 비싸기 때문에 <code>Dvec</code> 과 비슷한 값을 구했는지 검사한 후에는 <em>gradient checking</em> 를 꺼야한다. </p>

<p><img src='http://img.my.csdn.net/uploads/201302/08/1360310625_8308.png'  alt="" title="" /><p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p></p>

<h3 id="randominitialization">Random Initialization</h3>

<p><em>gradient desecnt</em> 를 위한 함수를 사용할때 <code>initialTheta</code> 를 줘야한다. 그냥 <code>zeros</code> 로 만들까? <em>neural network</em> 에서 모든 <code>theta</code> 가 <code>0</code> 으로 시작하면 모든 유닛의 값이 같아진다. 오류(<code>d</code>) 도 같고, <em>partial derivative</em> 의 값도 같으므로  다음 이터레이션에서도 같은 유닛은 같은 값을 가지고 이게 반복된다. </p>

<p>결국 내가 가진 모든 히든 유닛이 같은 계산을 해 내고 있으므로, 하나의 <em>feature</em> 에 대한 극도로 중복된 연산을 볼 수 있다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/08/1360312970_4725.png'  alt="" title="" /><p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p></p>

<p><code>theta</code> 가 대칭이기 때문에 발생하는 문제인데 <em>symmetry breaking</em> 을 위해 <code>[-e, e]</code> 사이의 <code>theta</code> 를 랜덤으로 골라보자. 물론 이 <code>e</code> 는 <em>gradient checking</em> 에서의 <code>e</code> 와 관련이 없다.</p>

<p><img src='http://my.csdn.net/uploads/201207/20/1342765672_2379.jpg'  alt="" title="" /><p align="center">(<a href='http://blog.csdn.net/abcjennifer' >http://blog.csdn.net/abcjennifer</a>)</p></p>

<h3 id="puttingittoghther">Putting It Toghther</h3>

<p>(1) <em>neural network</em> 를 훈련시킬 때 먼저 해야 할 일은 아키텍쳐를 고르는 일이다. </p>

<p><em>output unit</em> 과 <em>input unit</em> 은 <em>class</em> 와 <em>feature</em> 수로 결정된다. 문제는 <em>hidden unit</em> 과 <em>hidden layer</em> 의 수다.</p>

<p>기본적으로는 1개의 히든 레이어를 사용하거나, 1개 이상을 사용한다면 같은 수의 히든 유닛을 모든 히든 레이어에서 사용하는것이 대부분 계산 비용 면에서 낫다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/09/1360373142_6515.png'  alt="" title="" /><p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p></p>

<p>(2) <em>weights</em> 를 랜덤하게 초기화 한다. <br />
(3) <em>forward propagation</em> <br />
(4) <em>cost function</em> 을 구한다. <br />
(5)  <em>partial derivatives</em> 구하기 위해 <em>back propagation</em>  </p>

<p><em>BP</em> 를 할때는 <em>traning set</em> 의 수 <code>m</code> 번 만큼 루프를 돌면서 각 <code>(xi, yi)</code> 를 이용해 <em>FP</em>, <em>BP</em> 를 한다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/09/1360373729_4414.png'  alt="" title="" /><p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p></p>

<p>(6) <em>gradient checking</em> 을 이용해 얻은 근사치와 <em>partial derivatives</em> 를 비교한다. 값이 적당히 비슷하면 <em>gradient checking</em> 코드를 제거한다. <br />
(7) <em>cost function</em> 을 최소화 하기 위해 <em>gradient descent</em> 나 <em>advanced optimization method</em> 를 사용한다.</p>

<p>한 가지 알아야 할 사실은 <em>neural network</em> 의 <em>cost function</em> 은 <em>non-convex</em> 이기 때문에 <em>local optimum</em> 에서 멈출 수 있다. </p>

<p>그런덷 문제가 굉장히 크다면 <em>gradient descent</em> 로 찾은 <em>local optimum</em> 도 충분히 좋은 값이라고 한다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/09/1360374039_7863.png'  alt="" title="" /><p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p></p>

<p>처음에 1장에서 봤던 언덕 그림이다.</p>

<p><img src='http://cfile28.uf.tistory.com/image/2401353E52D618322EDFB5'  alt="" title="" /><p align="center">(<a href='http://mapository.tistory.com/59' >http://mapository.tistory.com/59</a>)</p></p>

<p>여기서 <em>gradient descent</em> 가 하는 일은 언덕을 내려가는거고, <em>back propagation</em> 이 하는 일은 방향을 잡아주는 일이다.(<code>z</code> 가 변했을 때 <em>cost function</em> 값이 변하는 양인 오차 <code>d</code> 의 값이 적어지도록 방향을 잡아줌)</p>

<p>그래서 신경망에서 <em>gradient descent</em> 를 사용한다 하더라도 적당히 좋은 로컬 옵티멈을 찾아준다는 훈훈한 이야기</p>

<h3 id="autonomousdriving">Autonomous Driving</h3>

<p>무인 운전을 신경망으로 어떻게 해결하는지를 보여준다. 미리 사람이 한번 운전한 경로(<code>y</code>) 를 바탕으로 학습하는데, 생각도 못해본 분야들에 이미  이런 기술들이 적용되어 있구나 싶다. <del>무려 1992년에 했던 실험이다</del></p>

<h3 id="references">References</h3>

<p>(1) <a href='http://aimotion.blogspot.kr/' >http://aimotion.blogspot.kr/</a> <br />
(2) <a href='http://www.holehouse.org/mlclass/09_Neural_Networks_Learning.html' >http://www.holehouse.org/mlclass/</a> <br />
(3) <a href='http://blog.csdn.net/abcjennifer/article/details/7758797' >http://blog.csdn.net/abcjennifer/</a> <br />
(4) <a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>  </p>]]></description><link>http://1ambda.github.io/machine-learning-week-5/</link><guid isPermaLink="false">b96b67f2-7881-4413-ac1c-b11177f200d2</guid><category><![CDATA[coursera]]></category><category><![CDATA[machine lerning]]></category><category><![CDATA[neural network]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 06 Nov 2014 10:10:59 GMT</pubDate></item><item><title><![CDATA[Functional Programming in Scala, Chapter 7]]></title><description><![CDATA[<p>7주차에 걸친 대장정의 마지막이다. 이번시간에는 <em>stream</em>, <em>lazy evaluation</em> 에 대해 배우고 이걸 이용해 길이가 무한인 컬렉션을 만들어 보기도 하고 계산을 늦추는 것을 다양한 예제에 적용해 본다.</p>

<h3 id="structuralinductionontrees">Structural Induction on Trees</h3>

<p>지난번엔 함수가 올바르게 동작함을 증명하기 위해 <em>induction</em> 을 사용했었는데 이번시간엔 <em>tree</em> 에 대해 <em>induction</em> 을 사용한다.</p>

<p>모든 트리 <code>t</code> 에 대해서 속성 <code>P(t)</code> 가 참임을 증명하려면 </p>

<p>(1) 먼저 트리의 모든 <em>leave</em> 에 대해 <code>P(1)</code> 임을 보인다. <br />
(2) 서브트리 <code>s1, ..., s</code> 을 가진 <em>internal node</em> 에 대해 <code>P(s1) ^ ... ^ P(sn)</code> 임을 보인다.</p>

<p>이제 몇 주 전에 만들었던 <code>IntSet</code> 을 증명해 보자.</p>

<pre><code class="scala">  abstract class IntSet {
    def incl(x: Int): IntSet
    def contains(x: Int): Boolean
  }

  object Empty extends IntSet {
    def contains(x: Int): Boolean = false
    def incl(x: Int): IntSet = NonEmpty(x, Empty, Empty)
  }

  case class NonEmpty(elem: Int, left: IntSet, right: IntSet) extends IntSet {
    def contains(x: Int): Boolean =
      if (x &lt; elem) left contains x
      else if (x &gt; elem) right contains x
      else true

    def incl(x: Int): IntSet =
      if (x &lt; elem) NonEmpty(elem, left incl x, right)
      else if (x &gt; elem) NonEmpty(elem, left, right incl x)
      else this
  }
</code></pre>

<p>구현에 대한 증명을 한다는건 구현이 포함하는 <em>law</em> 를 증명한다는 것을 의미한다. 예를들면</p>

<pre><code class="scala">Empty contains x == false  
(s incl x) contains x == true
(s incl x) contains y == s contains y (if x != y)
</code></pre>

<p><code>(s incl x) contains x == true</code> 부터 증명하자. <del>쉬우니까</del></p>

<p>(1) <em>base case (<code>P(1)</code>)</em> 은 <code>Empty</code> 를 <code>s</code> 에 집어넣으면 된다.   </p>

<p><code>NonEmpty(x, Empty, Empty) contains x</code> 이므로 <code>true</code> 다.</p>

<p>(2) <em>induction step: <code>s</code> 가 <code>NonEmpty(z, l, r)</code></em> 에 대해서 증명하자.</p>

<p><code>NonEmpty(z, l, r) incl x contains x</code> 인데, <code>z == x</code>, <code>z &lt; x</code>, <code>z &gt; x</code> 인 3 가지 경우로 나눠서 참임을 보이면 된다. 뒤의 두개는 같은 증명이며 각각의 마지막 단계에서 <em>induction hypothesis</em> 를 사용하면 된다.</p>

<pre><code class="scala">(NonEmpty(z, l, r) incl x) contians x // z &lt; x
(NonEmpty(z, l, r incl x) contains x
(r incl x) contians x // by def of NonEmpty.contains
true // by induction hypothesis  
</code></pre>

<p><code>(xs incl y) contains x == xs contians x</code>, <code>(if x != y)</code> 를 증명해 보자.</p>

<p>마찬가지로 <em>base case</em> 는 <code>Empty</code> 를 이용하면 된다. <code>y &lt; x</code>, <code>y &gt; x</code> 인 두 가지 경우로 나누어 참임을 보이자.</p>

<p>다음으로 <em>inductive step</em> 인데, <code>xs</code> 가 <code>NonEmpty(z, l, r)</code> 일때다. 아래의 5가지 경우를 고려해야 한다. </p>

<pre><code class="scala">z = x  
z = y  
z &lt; y &lt; x  
y &lt; z &lt; x  
y &lt; x &lt; z  
</code></pre>

<p>마찬가지로 <code>z = x, z = y</code> 도 <code>y &lt; x, y &gt; x</code> 로 나누어 풀자. 나머지 증명은</p>

<pre><code class="scala">// z &lt; y &lt; x, to show NonEmpty(z, l, r) contains x
NonEmpty(z, l, r incl y) contains x  
(r incl y) contains x
r contains x  // by induction hypothesis  
NonEmpty(z, l, r) contains x // by def of NonEmpty.contains

// y &lt; z &lt; x
NonEmpty(z, l incl y, r) contains x  
r contains x  
NonEmpty(z, l, r) contains x // by def of NonEmpty.contains

// y &lt; x &lt; z
(NonEmpty(z, l, r) incl y) contains x
NonEmpty(z, l incl y, r) contains x  
(l incl y) contains x
l contains x // by induction hypothesis  
NonEmpty(z, l, r) contains x  
</code></pre>

<p>조금 더 어려운 증명으로 <code>union</code> 이 참임을 보일 수 있다.</p>

<pre><code class="scala">(xs union ys) contains x = xs contains x || ys contains x
</code></pre>

<p>마찬가지로 <code>xs</code> 에 대해 <em>structural induction</em> 을 이용하면 된다.</p>

<h3 id="streams">Streams</h3>

<p>1000 부터 10000 사이에 있는 소수 중 두번 째 것을 찾는다 하자.</p>

<pre><code class="scala">((1000 to 10000) filter isPrime)(1)
</code></pre>

<p>짧고 엘레강스 하지만 문제가 하나 있다. 1000 부터 10000 까지의 소수를 모두 찾은 뒤 2번째 원소에 접근하므로 성능 문제가 생긴다. 필요없는 나머지 소수도 같이 찾아버리는 것이다.</p>

<p>그래서 스칼라에서는 <em>stream</em> 을 지원한다.</p>

<blockquote>
  <p>Avoid computing the tail of a sequence until it is needed for the evaluation result which might be never</p>
</blockquote>

<p>다시 말해서 <em>sequence</em> 에서 각 부분이 <em>evaluation (평가)</em> 되기 전까지 계산을 미루는 클래스를 스칼라에서는 <em>stream</em> 이란 이름으로 만들어 놨다.</p>

<p>스트림은 리스트와 유사하지만 <em>tail</em> 부분이 <em>on-demand</em> 로 <em>evaluation</em> 된다.</p>

<pre><code class="scala">&gt; Stream(1, 2, 3)
scala.collection.immutable.Stream[Int] = Stream(1, ?)

&gt; Stream.empty
res1: scala.collection.immutable.Stream[Nothing] = Stream()

&gt; (1 to 1000).toStream
scala.collection.immutable.Stream[Int] = Stream(1, ?)

&gt; val xs = Stream(1, Stream.cons(2,  Stream.empty))
xs: scala.collection.immutable.Stream[Any] = Stream(1, ?)  
</code></pre>

<p>보면 알겠지만 진짜로 <em>tail</em> 부분이 <code>?</code> 로 되어있다.</p>

<pre><code class="scala">  def streamRange(l: Int, h: Int): Stream[Int] = {
    if (l &gt;= h) Stream.empty 
    else Stream.cons(l, streamRange(l + 1, h))
  }

  def listRange(l:Int, h: Int): List[Int] = {
    if (l &gt;= h) Nil
    else l :: listRange(l + 1, h)
  }
</code></pre>

<p>스트림을 만드는 <code>streamRange</code> 와 리스트를 만드는 <code>listRange</code> 를 보면 하는 생긴건 비슷하지만 실제로는 완전히 다른 일을 한다.</p>

<p><code>listRange</code> 는 마지막 원소가 <code>Nil</code> 인 리스트를 만들지만 <code>streamRange</code> 는 두번 째 원소가 <code>?</code> 인 스트림을 만든다. </p>

<p>다시 처음의 예제로 돌아와서 </p>

<pre><code class="scala">((1000 to 10000).toStream filter isPrime)(1)
</code></pre>

<p><em>stream</em> 은 리스트와 관련된 메소드를 모두 사용할 수 있다. 하나만 빼고, 바로 <code>cons ::</code> 다.<code>Stream.cons</code> 는 <code>#::</code> 다.</p>

<p>마찬가지로 <code>#::</code> 도 패턴으로 사용할 수 있다.</p>

<p>스트림의 구현은 대부분 리스트와 비슷한데, <code>empty</code> 가 좀 다르다.  <code>Stream.empty</code> 처럼 스트림 내부에 정의되어있다.</p>

<p>그리고 가장 중요한 차이점은 <code>Stream.cons</code> 의 파라미터다.</p>

<pre><code class="scala">object Stream {  
  def cons[T](hd: T, tl: =&gt; Stream[T]) = new Stream[T] {
    def isEmpty = false
    def head = hd
    def tail = tl
  }
}
</code></pre>

<p><code>tl: =&gt; Stream[T]</code> 를 보면 알 수 있듯이 <code>tl</code> 은 <em>call-by-name</em> 이다. 따라서 바로 평가되지 않으며 사용하는 시점에 평가된다.</p>

<p>이제 <code>filter</code> 의 구현을 좀 보자.</p>

<pre><code class="scala">def filter(p: T =&gt; Boolean): Stream[T] =  
  if (isEmpty) this
  else if (p(head)) cons(head, tail.filter(p))
  else tail.filter(p)
}
</code></pre>

<p>여기서 중요한 부분이 <code>cons(head, tail.filter(p))</code> 다. 스트림의 <code>cons</code> 의 두번째 인자로 <code>tail.filter(p)</code> 를 넘겨주기 때문에 이 식의 평가는 나중에 호출될 때 이루어진다. 다시 말해 지금 당장은 <code>head</code> 만 <em>predicate <code>p</code></em> 가 적용된다는 뜻이다.</p>

<p>따라서 <code>streamRange</code> 를 이렇게 수정하면 어떤 값이 출력될까?</p>

<pre><code class="scala">  def streamRange(l: Int, h: Int): Stream[Int] = {
    println("l: " + l)
    if (l &gt;= h) Stream.empty 
    else Stream.cons(l, streamRange(l + 1, h))
  }

streamRange(1, 10).take(3).toList  
</code></pre>

<p>답은 <code>1 2 3</code> 이다. <code>take(3)</code> 가 아니라 <code>toList</code> 때문에 그렇다. <code>take(3)</code> 는 여전히 <em>stream</em> 이다. 따라서 첫 번째 원소인 <code>1</code> 만 평가된 상태이며 리스트로 바꾸는 순간 <code>1, 2, 3</code> 이 모두 평가되어야 하므로 그때 출력된다.</p>

<h3 id="lazyevaluation">Lazy Evaluation</h3>

<p>이제 까지 본 <em>stream</em> 구현은 필요 없는 <code>tail</code> 부분을 계산하지 않게 해 주었지만 심각한 결함이 있다. <code>tail</code> 이 여러번 호출된다면 어떻게 될까? 매번 다시 계산되야 한다.</p>

<p>그래서 첫 번째 <code>tail</code> 을 계산할 때 결과를 저장해 놓고, 그 다음부터는 재활용 하는 방법으로 이 문제를 해결해 보자. </p>

<p>사실 이건 함수형 프로그래밍에서 함수는 매번 같은 결과를 반환한다는 원칙에도 부합한다.</p>

<p>이걸 <em>lazy evaluation</em> 이라 부른다. 우리가 이제 까지 보아왔던 것은 <em>by-name evaluation</em> 이다. 필요할 때 평가하긴 하지만 매번 다시 계산해야하기 때문에 성능이 떨어진다. 그리고 <em>strict evaluation</em> 은 바로 평가되는 일반 <code>val</code> 변수라 보면 된다.</p>

<p>하스켈은 <em>lazy evaluation</em> 이 디폴트지만 스칼라는 <em>strict evaluation</em> 이 기본이다.</p>

<pre><code class="scala">lazy val x = expr  
def x expr  
</code></pre>

<p>다음 두 식의 차이는 무엇일까? 둘 다 <em>on-demand</em> 로 평가되지만 <code>def</code> 는 매번 다시 계산되고 <code>lazy val</code> 은 처음의 계산을 재활용한다.</p>

<p>그런 이유로 다음의 코드를 실행시키면</p>

<pre><code class="scala">  def expr = {
    val x = { println("x"); 1 }
    lazy val y = { println("y"); 2 }
    def z = { println("z"); 3 }
    z + y + x + z + y + x
  }

  expr
  // x
  // z
  // y
  // z
</code></pre>

<p><code>xzyz</code> 가 출력된다.</p>

<p>이제 <em>lazy evaluation</em> 을 <em>stream</em> 구현에 적용하자</p>

<pre><code class="scala">object Stream {  
  def cons[T](hd: T, tl: =&gt; Stream[T]) = new Stream[T] {
    def isEmpty = false
    def head = hd
    lazy val tail = tl
  }
}
</code></pre>

<p>근데 이렇게 작성한 코드가 실제로 <em>on-demand</em> 로 평가되는지 어떻게 알까? <em>substitution model</em> 에 적용해보자.</p>

<pre><code class="scala">(streamRange(1000, 10000) filter isPrime) apply 1

// will be expanded 

cons(1000, streamRange(1000 + 1, 10000)).filter(isPrime).apply(1)  
</code></pre>

<p>이제 <code>cons(1000, streamRange(1000 + 1, 10000))</code> 를 <code>C1</code> 이라 하자. </p>

<pre><code class="scala">C1.filter(isPrime).apply(1)

// same as
(if (isPrirme(C1.head)) 
  cons(C1.head, C1.tail.filter(isPrime))
else C1.tail.filter(isPrime))  
apply(1)  
</code></pre>

<p>이 때 <code>C1.head == 1000</code> 이므로 소수가 아니다. 따라서 이 식은</p>

<pre><code class="scala">C1.tail.filter(isPrime).apply(1)

// same as
streamRange(1001, 10000).filter(isPrime).apply(1)  
</code></pre>

<p>이렇게 첫 번째 소수를 찾을 때 까지 반복된다. <code>cons(1009, streamRange(1009 + 1, 10000)</code> 을 <code>C2</code> 라 부르면 </p>

<pre><code class="scala">C2.filter(isPrime).apply(1)

// same as
cons(1009, C2.tail.filter(isPrime)).apply(1)  
</code></pre>

<p>이 된다 스트림의 <code>apply</code> 가 다음과 같이 구현되어 있다고 하자.</p>

<pre><code class="scala">def apply(n: Int): T =  
  if (n == 0) head
  else tail.apply(n - 1)
</code></pre>

<p>그럼 위 식은 이렇게 확장된다.</p>

<pre><code class="scala">cons(1009, C2.tail.filter(isPrime)).tail.apply(0)


// same as
C2.tail.filter(isPrime).apply(0)

// same as
streamRange(1010, 10000)).filter(isPrime).apply(0)  
</code></pre>

<p>마찬가지로 다음 번 소수 <code>1013</code> 을 찾을 때 까지 <code>streamRange.tail</code> 와 <code>filter</code> 가 반복되며 식이 확장된다.</p>

<pre><code class="scala">cons(1013, streamRange(1013 + 1, 10000)).filter(isPrime).apply(0)  
</code></pre>

<p>여기서 <code>cons(1013, streamRange(1013 + 1, 10000))</code> 를 <code>C3</code> 라 하자.</p>

<pre><code class="scala">C3.filter(isPrime).apply(0)

// same as
cons(1013, C3.tail.filter(isPrime)).apply(0)  
</code></pre>

<p>따라서 <code>1013</code> 이 나온다. 결국 모든 과정에서 <em>stream</em> 의 <code>cons</code> 내부의 <code>tail</code> 은 <code>apply</code> 나 <code>filter</code> 이후에 호출됨을 알 수 있다.</p>

<h3 id="computingwithinfinitesequences">Computing with Infinite Sequences</h3>

<p>스트림에서 <em>tail</em> 이 필요할 때만 평가되기 때문에 <em>infinite stream</em> 을 만드는 것도 가능하다!</p>

<pre><code class="scala">def from(n: Int): Stream[Int] = n #:: from(n + 1)


val nats = from(0) // natural number  
val m4s = nats map (_ * 4)

(m4s take 3).toList // List(0, 4, 8)
</code></pre>

<p>이제 무한한 길이의 스트림을 만드는 방법을 배웠으니 이걸 이용해 우주에 존재하는 모든 소수를 포함하는 스트림을 만들어보자.</p>

<p>고대의 소수 계산 방법인 <em>The Sieve of Eratosthenes</em> 를 이용한다. 2 부터 시작해서 하나씩 숫자를 증가 시키며 해당 숫자의 배수를 모두 제거하는 방식으로 소수를 찾는다. <del>무려 몇천년 뒤의 컴퓨터 기술을 고려하고  알고리즘을 구현한 갓 고대인들</del></p>

<pre><code class="scala">def sieve(s: Stream[Int]): Stream[Int] =  
  s.head #:: sieve(s.tail filter (_ % s.head != 0))

val primes = sieve(from(2))  
primes.take(4).toList  
// List(2, 3, 5, 7)
</code></pre>

<p>다른 곳에도 좀 활용 해보자. 오래전에 <a href='http://1ambda.github.io/functional-programming-in-scala-chapter-1/' >1강</a> 에서 <em>뉴튼-랩슨</em> 법으로 제곱근을 구하는 함수를 작성한 적이 있었다. 그 때 제곱근의 값이 한 재귀 호출마다 특정 값 미만으로 변하는지 검사하는 <code>isGoodEnough</code> 함수를 작성했었고 이를 이용해서 제곱근 구하는 함수가 무한 재귀에 빠지지 않도록 했었다.</p>

<p><em>lazy evaluation</em> 을 이용하면 계산을 미룰 수 있기 때문에 무한 재귀에 빠지는걸 막을 수 있다.</p>

<pre><code class="scala">  def sqrtStream(x: Double): Stream[Double] = {
    def improve(guess: Double) = (guess + x / guess) / 2
    lazy val guesses: Stream[Double] = 1 #:: (guesses map improve)
    guesses
  }

  sqrt(4).take(10).toList  
</code></pre>

<p>참고로 원리가 알고싶다면 <a href='https://www.google.co.kr/search?q=y+%3D+1%2Fx&amp;oq=y+%3D+1%2Fx&amp;aqs=chrome..69i57j69i65l2j69i64l2.3051j0j1&amp;sourceid=chrome&amp;es_sm=122&amp;ie=UTF-8' #newwindow=1&amp;q=y+%3D+(4%2Fx+%2B+x)+%2F+2">여기</a> 그래프를 한번 보라.</p>

<p>물론 <code>sqrtStream</code> 은 <em>stream</em> 을 리턴하므로 좀 더 세밀한 값을 얻기 위해 <code>isGoodEnough</code> 를 활용할 수도 있다.</p>

<pre><code class="scala">def isGoodEnough(x: Double, guess: Double) =  
  math.abs((guess * guess - x ) / x) &lt; 0.0001

sqrtStream(4).filter(isGoodEnough(_, 4)).take(10).toList  
</code></pre>

<p>그럼 이제 무한한 길이를 가진 컬렉션을 <code>map</code> 과 <code>filter</code> 두 가지 방법으로 구현할 수 있다는 사실을 알게 되었을 텐데, 어느게 더 빠를까?</p>

<pre><code class="scala">val xs = from(1) map (_ * N)  
val ys = from(1) filter (_ % N == 0)  
</code></pre>

<p>당연히 <code>map</code> 이 더 빠르다. 필터는 원소를 돌면서 필터링 하는거고, 맵은 바로 곱해서 값을 구한다. </p>

<h3 id="thewaterpouringproblem">The Water Pouring Problem</h3>

<p>기본적인 아이디어는 물컵에 대한 액션(<code>Move</code>)을 <code>Empty, Fill, Pour</code> 로, 액션을 수행할 상태를 <code>type State = Vector[Int]</code> 모델링한다.</p>

<p>최초 상태 <code>initialState</code> 에 대해 가능한 모든 종류의 <code>Move</code> 를 미리 <code>moves</code> 에 만들어 놓고 (쉽게 만들 수 있다) 한번 씩 수행해 가면서 답이 있는지 검사한다. </p>

<p>이 과정에서 만들어지는 <code>List[Move]</code> 를 <code>Path</code> 라 볼 수 있다. 쉽게 연산하기 위해(리스트의 컨싱을 이용) <code>Path</code> 의 <code>head</code> 가 제일 마지막 <code>Move</code> 라 하자. </p>

<p>이러면 하나의 <code>Path</code> 는 우리가 가진 <code>initialState</code> 에 대해 <code>List[Move]</code> 를 적용해 마지막 상태를 알 수 있다. 이 것을 <code>endState</code> 함수로 구현한다. 이 때 마지막 <code>Move</code> 가 먼저 적용되야 하므로 <code>foldRight</code> 를 이용하면 <em>one-liner</em> 로 구현할 수 있다.</p>

<p><code>Path</code> 가 가진 <code>List[Move]</code> 에 새로운 <code>Move</code> 를 컨싱으로 연결하는 <code>extend</code> 메소드를 만들고, 우리가 풀어야 할 문제의 답은 하나의 <code>Path</code> 이므로 출력을 위해 <code>toString</code> 도 오버라이드 하자.  </p>

<p>하나의 <code>Path</code> 에서 <code>moves</code> 를 적용하면 다수의 <code>Path</code> 가 나온다. 이걸 <code>Paths: Set[Path]</code> 라 부르면 한 단계 한 단계 액션을 적용할 때마다 <code>Set[Path]</code> 가 생기는것이다. </p>

<p>그런데, 재귀를 이용해 구현한다 해도 무한정 계산할 수 없으므로 스트림을 이용해 다음단계의 계산은 필요할때로 미룰 수 있다. <code>Set[Path]</code> 를 받아 <code>Stream[Set[Path]]</code> 를 돌려주는 <code>from</code> 함수를 만들자.</p>

<pre><code class="scala">class Pouring(capacity: Vector[Int]) {

  // State
  type State = Vector[Int]
  val initialState = capacity map { _ =&gt; 0 }

  // Move
  trait Move {
    def change(s: State): State
  }
  case class Empty(glass: Int) extends Move {
    def change(s: State) = s updated(glass, 0)
  }
  case class Fill(glass: Int) extends Move {
    def change(s: State) = s updated(glass, capacity(glass))
  }
  case class Pour(from: Int, to: Int) extends Move {
    def change(s: State) = {
      val amount = s(from) min (capacity(to) - s(to))
      s updated (from, s(from) - amount) updated (to, s(to) + amount)
    }
  }

  val glasses = 0 until capacity.length

  val moves =
    (for (glass &lt;- glasses) yield Empty(glass)) ++
    (for (glass &lt;- glasses) yield Fill(glass)) ++
    (for (from &lt;- glasses; to &lt;- glasses if from != to) yield Pour(from, to))

  // Path

  class Path(history: List[Move]) {
    def endState: State = (history foldRight initialState)(_ change _)
    def extend(move: Move): Path = new Path(move :: history)
    override def toString = "\n" + (history.reverse mkString " ") + "--&gt;" + endState
  }

  val initialPath = new Path(Nil)

  def from(paths: Set[Path]): Stream[Set[Path]] = {
    if (paths.isEmpty) Stream.empty
    else {
      val more = for {
        path &lt;- paths
        next &lt;- moves map path.extend
      } yield next

      paths #:: from(more)
    }
  }

  val pathSets = from(Set(initialPath))

  def solutions(target: Int): Stream[Path] = {
    for {
      pathSet &lt;- pathSets
      path &lt;- pathSet
      if path.endState contains target
    } yield path
  }
}
</code></pre>

<p>그런데, 실제로 코드를 돌려보면 상당히 느리다.</p>

<pre><code class="scala">val problem = new Pouring(Vector(4, 7, 8))  
println(problem.solutions(6))  
</code></pre>

<p>이는 <code>from</code> 함수에서 <code>path</code> 를 <code>extend</code> 할 때 기존에 있던 <code>path</code>  도 포함하기 때문이다. 따라서 각 <code>path</code> 에서 <code>endState</code> 를 담은 <code>explored</code> 를 인자에 넘겨주고, 다시 넘겨 받으면</p>

<pre><code class="scala">  def from(paths: Set[Path], explored: Set[State]): Stream[Set[Path]] = {
    if (paths.isEmpty) Stream.empty
    else {
      val more = for {
        path &lt;- paths
        next &lt;- moves map path.extend
      } yield next

      paths #:: from(more, explored ++ (more map (_.endState)))
    }
  }

  val pathSets = from(Set(initialPath), Set(initialState))
</code></pre>

<p>그리고 <code>endState</code> 도 재귀함수로서 자주 호출되는데 매번 다시 계산되야 하므로 변수로 저장하면</p>

<pre><code class="scala">  class Path(history: List[Move], val endState: State) {
    def extend(move: Move): Path = new Path(move :: history, move change endState)
    override def toString = "\n" + (history.reverse mkString " ") + "--&gt;" + endState
  }

  val initialPath = new Path(Nil, initialState)
</code></pre>

<p><del>내 경우는 옵티마이징 한 결과가 더 느렸다;;</del></p>

<p>여기서 중요한 아이디어 두개를 짚어보면</p>

<p>(1) <code>List[Move]</code> 에서 앞쪽 <code>Move</code> 가 더 나중에 적용되는 것을 통해 매 <code>extend</code> 마다 전체 리스트를 순회할 필요가 없도록 하고 계산은 <code>foldRight</code> 를 이용해 쉽게 구현 <br />
(2) 무한한 재귀를 <em>stream</em> 을 이용해 계산을 미룬 <code>solution</code> 이나 <code>from</code> 함수. </p>

<p>특히 <code>solution</code> 은 <code>Stream[Path]</code> 를 리턴하도록 하여 첫번째 답까지 찾는 계산만 수행하는데, 이는 스트림에 <code>for-loop</code> 을 돌려도 스트림을 돌려준다는 사실을 알려준다. (<em>filter</em> 와 같다고 생각하면 편하다.*)</p>

<pre><code class="scala">def ex =  
  for(i &lt;- (1 to 10).toStream if i % 2 == 0)

ex.take(3).toList // List(2, 4, 6)  
</code></pre>

<h3 id="coursesummary">Course Summary</h3>

<p>이제 까지 우리가 다뤄 온 것들은</p>

<ul>
<li>higher-order functions</li>
<li>case classes and pattern matching</li>
<li>immutable collections</li>
<li>absence of mutable state</li>
<li>flexible evaluation strategies: <em>strict / lazy / by-name</em></li>
</ul>

<p>앞으로 다룰 것들은 (아마 <em>reactive programming</em> 에서)</p>

<ul>
<li><p><strong>functional programming and state</strong> <br />
<em>what does it mean to have mutable state?</em> <br />
<em>what changes if we add it?</em>  </p></li>
<li><p><strong>parallelism</strong> <br />
<em>how to exploit immutablility for parallel execution</em>  </p></li>
<li><p><strong>DSL</strong> <br />
<em>high-level libraries as embedded DSLs</em> <br />
<em>interpretation techniques for external DSLs</em></p></li>
</ul>

<h3 id="references">References</h3>

<p>2014-11-04, <strong>Functional Programming in Scala</strong>, Coursera</p>]]></description><link>http://1ambda.github.io/functional-programming-in-scala-chapter-7/</link><guid isPermaLink="false">2074b056-743c-46be-b701-5cda683aa29e</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[functional programming]]></category><category><![CDATA[lazy evaluation]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 05 Nov 2014 11:52:10 GMT</pubDate></item><item><title><![CDATA[하스켈로 배우는 함수형 언어 2]]></title><description><![CDATA[<p>이번시간엔 <em>list comprehension</em> 을 배웁니다. 수학에서는 집합의 원소를 이용해 새로운 집합을 만들 때 사용하는데요,</p>

<blockquote>
  <p>In mathematics, the <em>comprehension</em> notion can be used to construct new sets from old sets.</p>
</blockquote>

<p>비슷하게 하스켈에선 컬렉션에다 사용 할 수 있죠.</p>

<blockquote>
  <p>In Haskell, a similar comprehension notion can be used to construct new lists from old lists</p>
</blockquote>

<pre><code class="haskell">[x^2 | x &lt;- [1..3]] -- [1, 4, 9]
</code></pre>

<p>여기서 <code>x &lt;- [1..5]</code> 같은 <em>expression</em> 을 <strong>generator</strong> 라 부릅니다. <em>comprehension</em> 은 한 개 이상의 <em>generator</em> 를 가질 수 있습니다.</p>

<pre><code class="haskell">[(x, y) | x &lt;- [1..3], y &lt;- [4..5]]
-- [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
</code></pre>

<p><em>generator</em> 의 순서를 바꿈으로써 생성되는 원소들의 순서도 바꿀 수 있습니다.</p>

<pre><code class="haskell">[(x, y) | y &lt;- [4..5], x &lt;- [1..3]]
-- [(1,4),(2,4),(3,4),(1,5),(2,5),(3,5)]
</code></pre>

<p>보면 알겠지만 <em>multiple generators</em> 는 <em>nested loop</em> 와 비슷합니다. 뒤에 오는 <em>generator</em> 가 <em>inner-loop</em> 처럼 동작하죠.</p>

<p>그럼 <code>j = i + 1</code> 과 같은 변수도 <em>generator</em> 로 표현 가능할까요? 그럼요!</p>

<pre><code class="haskell">[(x, y) | x &lt;- [1..3], y &lt;- [x + 1]]
-- [(1,2),(2,3),(3,4)]
</code></pre>

<p>앞에 오는 <em>generator</em> 의 변수를 뒤에 오는 <em>generator</em> 에서 사용 할 수 있습니다. <em>dependant generator</em> 라 부릅니다.</p>

<p>이제 <em>dependant generator</em> 를 이용해서 <code>concat</code> 함수를 만들어 봅시다.</p>

<pre><code class="haskell">concat :: [[a]] -&gt; [a]  
concat xss = [x | xs &lt;- xss, x &lt;- xs]

concat [[1, 2, 3], [4, 5], [6]]  
-- [1,2,3,4,5,6]
</code></pre>

<h3 id="guards">Guards</h3>

<p><em>generator</em> 에서 변수를 걸러내기 위해 <em>guards</em> 를 사용할 수 있습니다.</p>

<pre><code class="haskell">[x | x &lt;- [1..10], even x]
-- [2, 4, 6, 8, 10]
</code></pre>

<p>약수를 골라내는 <code>factors</code> 함수도 만들어 볼 수 있겠죠? 그리고 소수를 판별하는 <code>prime</code> 도 같이 작성합시다.</p>

<pre><code class="haskell">factors :: Int -&gt; [Int]  
factors n = [x | x &lt;- [1..n], n `mod` x == 0]

factors 17 -- [1,17]  
factors 15 -- [1,3,5,15]

prime :: Int -&gt; Bool  
prime n = factors n == [1, n]  
</code></pre>

<p>소수를 찾아주는 <code>primes</code> 도 만들어볼까요?</p>

<pre><code class="haskell">primes :: Int -&gt; [Int]  
primes n = [x | x &lt;- [2..n], prime x]

primes 40  
-- [2,3,5,7,11,13,17,19,23,29,31,37]
</code></pre>

<h3 id="zip">zip</h3>

<p><code>zip</code> 함수는 두 개의 리스트를 받아 하나의 리스트를 만듭니다. </p>

<pre><code class="haskell">-- zip :: [a] -&gt; [b] -&gt; [(a, b)]

zip [1, 2, 3]  ['a', 'b', 'c', 'd']  
[(1,'a'),(2,'b'),(3,'c')]
</code></pre>

<p><code>pairs</code> 와 같은 함수도 만들어 볼 수 있겠죠?</p>

<pre><code class="haskell">pairs :: [a] -&gt; [(a, a)]  
pairs xs = zip xs (tail xs)

pairs [1, 2, 3, 4]  
-- [(1,2),(2,3),(3,4)]
</code></pre>

<p><code>pairs</code> 함수를 이용하면 하나의 리스트에 있는 한 원소와 그 다음 원소의 <em>pair</em> 를 구할 수 있으므로 리스트가 정렬되었는지를 검사하는 <code>sorted</code> 함수에 사용할 수 있습니다.</p>

<pre><code class="haskell">sorted :: Ord a =&gt; [a] -&gt; Bool  
sorted =  
  and [x &lt;= y | (x, y) &lt;- paris xs]

sorted [1, 2, 3, 4] --True  
sorted [1, 2, 5, 3, 4] --False  
</code></pre>

<p>하스켈 리스트은 배열과는 달라서 인덱스가 없습니다. 리스트에서 주어진 값과 같은 값을 가지는 원소들의 리스트를 구하는 <code>positions</code> 함수를 <code>zip</code> 을 이용해 만들어봅시다.</p>

<pre><code class="haskell">positions :: Eq a =&gt; a -&gt; [a] =&gt; [Int]  
positions x xs =  
  [i | (x', i) &lt;- zip xs [0..n], x == x']
  where n = (length xs) - 1

positions 0 [0, 1, 0, 1, 1, 1, 1, 0]  
-- [0,2,7]  
</code></pre>

<h3 id="stringcomprehensions">String comprehensions</h3>

<p>하스켈에선 <em>스트링 (문자열)</em> 이 <em>캐릭터</em> 의 리스트라는 걸 지난시간에 이야기 했습니다. 따라서 리스트를 인자로 받는 <em>polymorphic</em> 함수에 스트링을 적용할 수 있습니다.</p>

<pre><code class="haskell">zip "abc" [1, 2, 3] -- [('a',1),('b',2),('c',3)]  
*Main&gt; take 3 "asdasd" -- "asd"
length "adasd" -- 5  
</code></pre>

<p>그런 이유에서 <em>list comprehension</em> 을 이용해 스트링을 조작할 수 있습니다.</p>

<pre><code class="haskell">import Data.Char

lowers :: String -&gt; Int  
lowers xs = length [x | x &lt;- xs, isLower x]  
</code></pre>

<h3 id="thecaesarcipher">The Caesar cipher</h3>

<p><em>Caesar cipher (시저 암호)</em> 는 간단한 치환 암호입니다. 알파벳을 특정 자리수 만큼 밀어 인코딩된 새로운 문자열을 만들어 내지요.</p>

<p>간단하게 구현하기 위해 모든 문자가 소문자라 가정하겠습니다. 알파벳은 26개이니 <code>a</code> 를 <code>0</code> 에 매핑하지요.</p>

<pre><code class="haskell">import Data.Char

let2int :: Char -&gt; Int  
let2int c = ord c - ord 'a'

int2let :: Int -&gt; Char  
int2let n = chr(n + ord 'a')  
</code></pre>

<p><code>ord</code> 함수는 캐릭터를 받아 아스키 숫자로 변환하고 <code>chr</code> 함수는 그 반대의 역할을 합니다. 위 코드에서 <code>let2int</code> 는 캐릭터를 받아 <code>0</code> 부터 <code>25</code> 사이의 숫자로 변환합니다. 물론 <code>c</code> 가 소문자임을 가정합니다. <code>int2let</code> 은 반대의 역할을 하고요.</p>

<p>이제 주어진 소문자 알파벳을 <code>n</code> 번 만큼 이동시키는 <code>shift</code> 함수를 만들어 봅시다.</p>

<pre><code class="haskell">shift :: Int -&gt; Char -&gt; Char  
shift n c | isLower c = int2let((let2int c + n) `mod` 26)  
          | otherwise = c

shift (-1) 'a' -- 'z'  
shift (3) 'a' -- 'd'  
</code></pre>

<p>이제 <em>list comprehension</em> 을 이용해 <code>encode</code> 함수를 만들어 봅시다.</p>

<pre><code class="haskell">encode :: Int -&gt; String -&gt; String  
encode n cs = [shift n c | c &lt;- cs]

encode 1 "abc"  
-- "bcd"
encode 3 "haskell is fun"  
-- "kdvnhoo lv ixq"
encode (-3) "kdvnhoo lv ixq"  
-- "haskell is fun"
</code></pre>

<h3 id="crackingtheciper">Cracking the Ciper</h3>

<p>시저 암호를 깨는 방법은 다음과 같습니다.</p>

<p>(1) 대량의 텍스트를 분석해 각 알파벳이 문장속에서 나올 확률을 가지고 있는 <em>frequency table</em> 을 준비합니다. <br />
(2) 인코딩된 암호를 0 부터 25 까지 시프팅 해 가면서 우리가 준비한 <em>frequency table</em> 과 같은 비율을 가지고 있는지 검사합니다.</p>

<p>물론 이 방법은 텍스트가 너무 짧거나, 아니면 우리가 가지고 있는 <em>frequency table</em> 과 다른 분포를 가지고 있는 텍스트를 복호화 하지 못합니다. </p>

<p>일단 한번 해 봅시다.</p>

<pre><code class="haskell">table :: [Float]  
table = [8.2, 1.5, 2.8, 4.3, 12.7, 2.2, 2.0, 6.1, 7.0, 0.2, 0.8, 4.0, 2.4,  
        6.7, 7.5, 1.9, 0.1, 6.0, 6.3, 9.1, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1]

count :: Eq a =&gt; a -&gt; [a] -&gt; Int  
count x xs = length [x' | x' &lt;- xs, x == x']

lowers :: String -&gt; Int  
lowers cs = length [c | c &lt;- cs, isLower c]

percent :: Int -&gt; Int -&gt; Float  
percent n m = (fromIntegral n / fromIntegral m) * 100

freqs :: String -&gt; [Float]  
freqs xs = [percent (count x xs) n | x &lt;- ['a'..'z']]  
           where n = lowers xs
</code></pre>

<p><code>freqs</code> 함수는 주어진 문자열에 대해 <em>frequency table</em> 을 돌려줍니다. <code>count</code> 와 <code>percent</code>, <code>lowers</code> 함수를 이용해서 만들었습니다. </p>

<p>이제 우리가 가지고 있는 <code>table</code> (<code>es</code>, <em>expected</em>) 과 인코딩된 텍스트를 시프팅 해서 얻은 <code>os</code> (<em>observed</em>) 테이블과의 차를 구하는 <code>chisqr</code> 함수를 만들겠습니다. 이 차이가 가장 작으면 <code>os</code> 가 우리가 가진 테이블에 가장 근접한 <em>frequency table</em> 을 가지는 테이블이라는 뜻이죠. </p>

<p>카이 제곱 분포를 이용할 건데, 공식은 다음과 같습니다.</p>

<p><img src='http://www.maritzresearch.com/maritzstats/HelpFiles/images/ChiSquareFormula-ChiSquareValue.bmp'  alt="http://www.maritzresearch.com/maritzstats/HelpFiles/Formula_ChiSquareTest.htm" /></p>

<pre><code class="haskell">chisqr :: [Float] -&gt; [Float] -&gt; Float  
chisqr os es = sum [(o- e)^2 / e | (o, e) &lt;- zip os es]  
</code></pre>

<p>하스켈 참 쉽죠? 이제 본래 인코딩 된 텍스트를 왼쪽으로 시프팅 하는 함수를 만들겁니다. <code>rotate</code> 라고 부릅시다. <code>take</code>, <code>drop</code> 을 이용하면</p>

<pre><code class="haskell">rotate :: Int -&gt; [a] -&gt; [a]  
rotate n xs = drop n xs ++ take n xs  
</code></pre>

<p>이제 인코딩된 텍스트에 대해 <code>[0..25]</code> 번 <code>rotate</code> 해 가며 <code>chisqr</code> 을 호출한 결과 중 가장 작은 값을 가지는 <code>factor</code> 를 찾아 <code>encode</code> 에  <code>-factor</code> 로 입력하면 암호가 깨집니다. 이런 일을 하는 함수를 <code>crack</code> 이라 부르고 작성해 봅시다.</p>

<pre><code class="haskell">positions :: Eq a =&gt; a -&gt; [a] -&gt; [Int]  
positions x xs = [i | (x', i) &lt;- zip xs [0..n], x' == x]  
  where n = (length xs) - 1

crack :: String -&gt; String  
crack xs = encode (-factor) xs  
  where
    factor = head (positions (minimum chiTab) chiTab)
    chiTab = [chisqr (rotate n table') table | n &lt;- [0..25]]
    table' = freqs xs
</code></pre>

<p>이제 이 함수를 사용해 봅시다.</p>

<pre><code class="haskell">crack "kdvnhoo lv ixq"  
-- "haskell is fun"
crack "vscd mywzboroxcsyxs kbo esopev"  
-- "list comprehensioni are uieful"
crack "vscd mywzboroxcsyxs kbo ecopev"  
-- "list comprehensioni are useful"

crack (encode 3 "haskell")  
-- "piasmtt"
crack (encode 3 "boxing wizards jump quickly")  
-- "wjsdib rduvmyn ephk lpdxfgt"
</code></pre>

<p>아래 두개의 예제는 복호화의 실패한 경우를 보여줍니다. 인코딩된 텍스트의 테이블이 우리가 가진 테이블과 많이 다르기 때문이지요.</p>

<h3 id="exercise">Exercise</h3>

<p>두개의 <em>generator</em> 를 가진 하나의 <em>comprehension</em> 은 하나의 <em>generator</em> 를 가진 두개 이상의 <em>comprehension</em> 으로 작성할 수 있습니다. 다음의 두 라인은 동일합니다.</p>

<pre><code class="haskell">[(x, y) | x &lt;- [1, 2, 3], y &lt;- [4, 5, 6]]

concat [[(x, y) | y &lt;- [4, 5, 6]] | x &lt;- [1, 2, 3]]  
</code></pre>

<h3 id="references">References</h3>

<p>(1) <strong>DelftX FP 101x</strong> in <em>edx</em> <br />
(2) Chapter 5, Programming in haskell <br />
(3) <a href='http://ko.wikipedia.org/wiki/%EC%B9%B4%EC%9D%B4%EC%82%AC%EB%A5%B4_%EC%95%94%ED%98%B8' ><em>Caesar cipher</em></a> <br />
(4) <a href='http://www.maritzresearch.com/maritzstats/HelpFiles/Formula_ChiSquareTest.htm' >http://www.maritzresearch.com</a></p>]]></description><link>http://1ambda.github.io/haskell-intro2/</link><guid isPermaLink="false">6893f28c-dffc-4c58-8195-730189d88711</guid><category><![CDATA[programming language]]></category><category><![CDATA[functional programming]]></category><category><![CDATA[edx]]></category><category><![CDATA[haskell]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 04 Nov 2014 16:26:11 GMT</pubDate></item><item><title><![CDATA[Intro to Computational Thinking and Data Science 1]]></title><description><![CDATA[<h3 id="simulationmodels">Simulation Models</h3>

<p>Simulation attempts to build an <strong>experimental device</strong> called <em>model</em></p>

<p>Simulation model is <em>descriptive, not prescriptive</em></p>

<p>직역하자면 시뮬레이션은 실험가능한 도구인 모델을 만들어낸다. 모든 모델이 정확하진 않지만, 다시 말해 현상을 완벽하게 설명하진 못하지만, 어떤 모델들은 대략 비슷하게 사실을 예측해 낸다. 그런점에서 모델은 유용하다.</p>

<p>(1) <strong>Deterministic simulations</strong> are completely defined by the model <em>rerunning the simulation will not change the result</em> <br />
(2) <strong>Stochastic simulations</strong> include randomness. <em>Difference runs can generate different results</em>  </p>

<h3 id="nondeterminism">Nondeterminism</h3>

<p>*Casual nondeterminism: * Not every event is caused by previous events</p>

<p>*Predictive nondeterminism: * Lack of knowledge about the world makes it impossible make accurate predictions about future states</p>

<p>*Stachastic Processes: * An ongoing process where the next state might depend on both the previous states and <strong>some random element</strong></p>

<pre><code class="python">def rollDie():  
   """returns an int between 1 and 6"""

def rollDie():  
   """returns a random int between 1 and 6 """
</code></pre>

<p>위쪽 <code>rollDie</code> 는 <em>underdetermined</em> 인 반면 아래쪽은 <em>non-deterministric</em></p>

<h3 id="hashtable">Hash Table</h3>

<p><em>Many to One</em> 이기 때문에 <em>Collision</em> 이 생긴다. <strong>bucket</strong> 을 이용해서 같은 키값을 가진 것들을 같은 버켓에 저장하도록 하면 충돌을 어느정도는 예방할 수 있다. </p>

<p>물론, 테이블이 커지면 충돌이 적어지고 탐색시간이 빨라지지만 메모리가 많이 들고, 테이블이 작아지면 충돌이 많아지고 탐색시간이 <em>linear search</em> 에 가깝게 느려지지만 메모리는 적게든다. <em>Time / Space trade off</em></p>

<p>그리고 좋은 해쉬 함수는 <em>uniform distribution</em> 을 생성한다. 다시 말해서 모든 버킷은 같은 수의 데이터를 담고 있어야 한다.</p>

<p>해시 테이블은 <em>time / space trade off</em> 를 극명하게 보여주는데, <em>collision</em> 이 하나도 없을 때 개당 <em>1 byte</em> 인 10^9 개의 원소를 담고자 한다면, 1GB 가 필요하다.</p>

<p>그래서 해시 테이블을 만들 때는 가능한한 메모리가 허락하는 한도 내에서 최적화 할 필요가 있다. 다시 말하면 <em>table size</em> 와 <em>lookup time</em> 을 동시에 고려해야 한다는 뜻이다.</p>

<p>버킷 내부에 <code>a</code> 개를 저장하면 원소를 검색하는데 <code>O(a)</code> 시간이 걸리지만 메모리는 <code>1/a</code> 배 만큼 줄어든다.</p>

<p>이제 해쉬 함수의 성능을 <em>적어도 한번 충돌이 일어날 수 있는 확률</em> 로 표현해 보자. 한번도 충돌이 나지 않을 경우를 1 에서 빼면 된다.</p>

<p>입력 원소 <code>K</code> 개에 대해, 해쉬함수가 <code>range(n)</code> 의 <em>uniform distribution</em> 을 만들때 <code>hash(k) = 1/n</code> 이다. 이 때 충돌이 한번도 일어나지 않을 확률은 <code>1 * (n-1)/n * (n-2)/n  * .. (n-(k-1))/n</code> 이다. 이 값을 1에서 빼면 <em>적어도 한번 충돌이 일어날 수 있는 확률</em>을 구할수 있다.</p>

<h3 id="birthdayattack">Birthday Attack</h3>

<p>일년이 365일 이라 하면, 얼핏 생각하기에 365명 정도는 모여야 생일이 같은 사람 있을 것 같은데 사실 그렇지 않다. 실제로는 23명만 모여도 생일이 같은 두사람이 있을 확률이 50%를 넘고, 57명이 모이면 99%를 넘는다.</p>

<p>생일이 같은 두 사람을 찾는 것과 비슷하게, 암호학적 해시 결과가 같은 두 입력값을 자는 것 역시 모든 입력값을 계산하지 않앋 충분히 높은 확률로 해시 충돌을 찾을 수 있다. 이러한 암호 공격을 <em>birthday attack</em> 이라 부른다.</p>

<p>바꿔 말하면 <em>birth day problem</em> 은 해시 버켓이 365개인 해시 테이블이라 봐도 무방하다.</p>

<p><code>atLeastTwoSameBirthday</code> 함수는 <code>n + 1</code> 명이 있는 방 안에서 적어도 두명은 생일이 같을 확률을, <code>minNumOfPeopleProb</code> 는 인자로 받은 <code>p</code> 보다 큰, 생일이 같을 확률을 얻기 위한 최소한의 인원을 돌려준다.</p>

<pre><code class="python">import operator


def atLeastTwoSameBirthday(n):  
    xs = range(365 - n, 365)
    ys = map((lambda x: float(x) / 365), xs)
    return 1 - reduce(operator.mul, ys)


def minNumOfPeopleProb(p):  
    for n in range(1, 365):
        if atLeastTwoSameBirthday(n) &gt;= p:
            return n

    return n


print atLeastTwoSameBirthday(29)  
print atLeastTwoSameBirthday(249)  
print minNumOfPeopleProb(0.99)  
</code></pre>

<h3 id="lowoflargenumbers">Low of Large Numbers</h3>

<blockquote>
  <p>In repeated <strong>independent tests</strong> with the same actual probabilty <em>p</em> of a particular outcome in each test, the chance of that the <em>fraction of times</em> that outcome occurs differs from p converges to zero as the number of trials goes to infinity</p>
</blockquote>

<p><em>low of large numbers</em> 는 <strong><code>|head - tail|</code> 이 0에 수렴한다</strong> 를 의미하지 않는다. 오히려 <code>|head - tail|</code> 는 특정 비율이다(<em>ratio</em>)</p>

<p>이제 실제로 그러한지 시뮬레이션을 하기 위해 코드를 작성하면</p>

<pre><code class="python">import pylab  
import random


def flipPlot(minExp, maxExp):  
    ratios = []
    diffs = []
    xAxis = []

    for exp in range(minExp, maxExp + 1):
        xAxis.append(2 ** exp)

    for flips in xAxis:
        heads = 0
        for n in range(flips):
            if random.random() &lt; 0.5:
                heads += 1

        tails = flips - heads
        ratios.append(heads / float(tails))
        diffs.append(abs(heads - tails))

    pylab.title('Diff between Heads and Tails')
    pylab.xlabel("# of Flips")
    pylab.ylabel("Abs(#Heads - #Tails)")
    pylab.plot(xAxis, diffs)
    pylab.figure()
    pylab.title("Heads / Tails Ratios")
    pylab.xlabel("# of Flips")
    pylab.ylabel("Heads / Tails")
    pylab.plot(xAxis, ratios)

random.seed(0)  
flipPlot(4, 20)  
pylab.show()  
</code></pre>

<p>돌려서 나온 <code>|head - tail|</code> 의 그래프에서 선형 관계가 있다고 느낄 수 있는데 사실이 아니다. 우리는 x 축 값을 지수로 증가시켰기 때문에 우측에는 데이터가 별로 없는 반면 왼쪽에는 압축되어있다.</p>

<p>선 대신에 점 형태로 그래프를 그리고 축에 로그를 씌우는 코드로 바꾸자.</p>

<pre><code class="python">    #...

    pylab.title('Diff between Heads and Tails')
    pylab.xlabel("# of Flips")
    pylab.ylabel('Abs(#Heads - #Tails)')
    pylab.plot(xAxis, diffs, 'bo')
    pylab.semilogx()
    pylab.semilogy()
    pylab.figure()
    pylab.title('Heads / Tails Ratios')
    pylab.xlabel('# of Flips')
    pylab.ylabel('Heads / Tails')
    pylab.semilogx()
    pylab.plot(xAxis, ratios, 'ro')

    #...
</code></pre>

<p><code>heads / tails</code> 는 1에 수렴하는걸 알 수 있다. 반면 <code>|heads - tails|</code> 는 완벽하진 않지만 선형의 그래프를 그리는걸 알 수 있다.</p>

<p>여기서 한 가지 사실을 알 수 있다.</p>

<blockquote>
  <p>Never possible to be assured of perfec accuracy through samplings, unless you sample the entire population</p>
</blockquote>

<p>그렇다면 <em>sample</em> 에 대한 경향이 참일때, <em>population</em> 에 대한 경향이 참임을 증명하기 위해서 얼마나 많은 <em>sample</em> 을 살펴봐야 할까?</p>

<blockquote>
  <p>Depends upon the variance in the underlying distribution</p>
</blockquote>

<p>물론 우리는 <em>distribution</em> 을 볼 수 없다. 샘플만 가지고 있기 때문에. 그럼 샘플로 <em>variance</em> 를 얻어보자.</p>

<blockquote>
  <p>We measure the amount of variance in the outcomes of multiple trials</p>
</blockquote>

<p><em>standard deviation</em> 을 이용하자. 표준편차는 우리가 가진 샘플이 평균에 모여있는지, 아닌지를 알려주는 지표다. </p>

<p>다시 말해서 <em>standard deviation</em> 이 작으면, 그래서 샘플의 평균에 샘플들이 대부분 모여있다는걸 알 수 있다면 작은 샘플에 대해서 얻은 어떤 경향이 <em>population</em> 에도 적용된다는 걸 알 수 있다.</p>

<pre><code class="python">def flipPlot(minExp, maxExp, trials):  
    meanRatios = []
    meanDiffs = []
    sdRatios = []
    sdDiffs = []
    xAxis = []

    for exp in range(minExp, maxExp + 1):
        xAxis.append(2 ** exp)

    for flips in xAxis:
        ratios = []
        diffs = []

        for t in range(trials):
            heads, tails = runTrial(flips)
            ratios.append(heads / float(tails))
            diffs.append(abs(heads - tails))
        meanRatios.append(sum(ratios) / trials)
        meanDiffs.append(sum(diffs) / trials)
        sdRatios.append(stdDev(ratios))
        sdDiffs.append(stdDev(diffs))

    pylab.title('Mean of Diff bet Heads and Tails ('+str(trials)+' Trials)')
    pylab.xlabel("# of Flips")
    pylab.ylabel('mean Abs(#Heads - #Tails)')
    pylab.plot(xAxis, meanDiffs, 'bo')
    pylab.semilogx()
    pylab.semilogy()

    pylab.figure()
    pylab.title('SD of Diff bet Heads and Tails ('+str(trials)+' Trials)')
    pylab.xlabel('# of Flips')
    pylab.ylabel('SD Abs(#Heads - #Tails)')
    pylab.plot(xAxis, sdDiffs, 'bo')
    pylab.semilogx()
    pylab.semilogy()

    pylab.figure()
    pylab.title('Mean Heads / Tails Ratios')
    pylab.xlabel('# of Flips')
    pylab.ylabel('mean Heads / Tails')
    pylab.semilogx()
    pylab.plot(xAxis, meanRatios, 'ro')

    pylab.figure()
    pylab.title('SD Heads / Tails Ratios')
    pylab.xlabel('# of Flips')
    pylab.ylabel('SD Heads / Tails')
    pylab.semilogx()
    pylab.semilogy()
    pylab.plot(xAxis, sdRatios, 'ro')

random.seed(0)  
flipPlot(4, 20, 20)  
pylab.show()  
</code></pre>

<p>이제 코드를 돌려보면, <code>heads / tails</code> 의 평균은 1로 수렴하는 것을, 표준편차는 <code>n</code> 이 커질수록 급격히 <code>0</code> 에 가까워지는걸 알 수 있다.</p>

<p>반면 <code>|heads - tails|</code> 의 평균은 <code>n</code> 이 증가할수록 여전히 커지고, 표준편차도 증가한다. </p>

<p>그럼, <code>n</code> 이 클수록 <code>|heads - tails|</code> 의 표준편차가 증가하므로 우리가 얻은 어떤 경향성이 <code>n</code> 이 클수록 더 믿지 못한다는 뜻일까?. </p>

<p>당연히 그렇지 않다! <strong>표준편차는 그 자체로만 보아서는 안되고 평균과 연관지어 생각해야 한다.</strong> 평균이 100억일때, 표준편차가 100이라면 그건 데이터가 모여있음을 의미한다.</p>

<p>결국 <em>평균</em> 이 매우 달라지는 테스트를 할 경우엔 <em>표준편차</em> 를 사용하는건 적절하지 못하다는 사실을 알 수 있다.</p>

<h3 id="coefficientofvariation">coefficient of variation</h3>

<p>그럼 평균이 달라지는경우 표준편차가 의미가 없다면, 어떤 값을 사용해야 <em>population</em> 의 <em>variance</em> 를 알 수 있을까? 표준편차를 평균으로 나눈 <em>coefficient of variance</em> 를 이용하면 된다. 일반적으로 이 값이 1 보다 작은지 아닌지를 기준으로 삼는다.</p>

<p><img src='https://courses.edx.org/c4x/MITx/6.00.2_2x/asset/files_finger_exercises_pythonland.png'  alt="" />
<img src='https://courses.edx.org/c4x/MITx/6.00.2_2x/asset/files_finger_exercises_montyland.png'  alt="" /></p>

<p align="center">(<a href='http://courses.edx.org/courses/MITx/600.2_2x' >http://courses.edx.org/courses/MITx/600.2_2x</a>)</p>

<p>위 두 도시의 스카이라인중 어떤 도시의 <em>coefficient of variance</em> 가 더 클까?</p>

<p>한가지 더 생각해볼 문제가 있다. 다음의 두 변수는 CoV 를 계산하는 것이 의미가 있을까?</p>

<p>(1) <em>Daily Temperature in Celsius for the city of Boston</em> <br />
(2) <em>The X coordinate of a drunk in the random walk</em>  </p>

<p>의미가 없다. <em>CoV</em> 가 의미있으려면, <em>true zero</em> 가 있어야 한다. 바꿔 말하면 <em>ratio scale</em> 에 대해서만 <em>CoV</em> 가 의미가 있다. 위 두 수치들은 양수 또는 음수값이 있기 때문에 <em>ratio scale</em> 이 아니다.</p>

<h3 id="histogram">Histogram</h3>

<p><em>pylab</em> 에서는 히스토그램을 어떻게 그릴까?</p>

<pre><code class="python">import pylab  
import random


def exampleHist(n):  
    xs = []
    for x in range(n):
        xs.append(random.random())

    pylab.hist(xs, bins=11)
    pylab.show()

exampleHist(10000)  
</code></pre>

<h3 id="references">References</h3>

<p>(1) <a href='http://ko.wikipedia.org/wiki/%EC%83%9D%EC%9D%BC_%EB%AC%B8%EC%A0%9C' >http://ko.wikipedia.org</a> <br />
(2) <em>MIT 6.00.2 2x</em> in <strong>edx</strong></p>]]></description><link>http://1ambda.github.io/edx-600-2x-1/</link><guid isPermaLink="false">ea5cceae-c2b4-4745-9127-5cc8d042a92a</guid><category><![CDATA[edx]]></category><category><![CDATA[python]]></category><category><![CDATA[histograms]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 04 Nov 2014 09:19:14 GMT</pubDate></item><item><title><![CDATA[Divide and Conquer]]></title><description><![CDATA[<p><em>Divide and Conquer (분할 정복)</em> 을 배운다. <em>merge, quick sort</em> 를 배우고 이 과정에서 왜 <em>combine</em> 단계가 <code>O(n)</code> 이 되어야 하는지 알아본다. 뒷부분에서는 <em>Big O</em> 뿐만 아니라 <em>master method</em>, <em>decomposition approach</em> 를 이용해 성능을 분석한다.</p>

<h3 id="divideandconquer">Divide and Conquer</h3>

<p>각 level 의 문제 갯수는 <code>2^j (j = 0, 1, 2, ... , log2n)</code> 이고 문제의 사이즈는 <code>n / 2^j</code> 이므로 연산수를 <code>k</code> 라 하면, 각 레벨에서 연산 수는 <code>k * n</code>, 레벨의 <em>depth</em> 가 <code>log2n + 1</code> 이므로, </p>

<p><em>merge sort</em> 같은 경우는 연산수 <code>k = 6</code> 에서 <code>6n (log2n + 1)</code></p>

<p>Big O 는 <code>O(f(n))</code> 이라 했을때 <em>at most</em>, <code>f(n)</code> 에 proportional 하므로 upper 바운드. <br />
반면 Omega 는 <code>omega(f(n))</code> 이라 했을 때 <em>at least</em> <code>f(n)</code> 에 proportional 하므로 lower 바운드.</p>

<p>분할 정복의 핵심은 각 sub-problem 에서 연산 수를 o(n) 으로 맞출 수 있느냐 없느냐, 맞춘다면 nlogn 알고리즘이 되는 것이다. </p>

<p>알고리즘은 3단계로 구성된다.</p>

<p>(1) Divide <br />
(2) Conquer sub problems <br />
(3) combine (merge)  </p>

<p>여기서 중요한건, combine 단계인데 이게 O(n) 이기만 하면 전체 알고리즘의 성능을 O(nlogn) 으로 보장할 수 있음.</p>

<h3 id="mastermethodmotivation">Master Method: Motivation</h3>

<p>T(n) 을 O(n) 으로 upper bound 를 구하긴 했지만 O(n) 연산 수 구하는게 좀 힘들다. 재귀 호출의 갯수나, 문제의 분할 사이즈로 O(n) 을 쉽게 구해보자.</p>

<p>가우스 곱셈? 의 경우에 T(n) &lt;= 4 * T(n/2) + O(n)</p>

<p>그러나 더 작아질 수 있음. (a+b)(c+d) 에서 ad+bc = (a+b)(c+d) - ad - bd 로 구할 수 있음</p>

<p>즉 3개의 부분식만 구해도 됌.</p>

<p>T(n) &lt;= 3 * T(n/2) + O(n)</p>

<p>머지소트는 2 * T(n/2) + O(n) 쯤 되니까 가우스보다 더 낫긴 함. 그럼 가우스의 그것은 얼마일까?</p>

<h4 id="mastermethod">Master Method</h4>

<p><em>Master method</em> 는 재귀 문제의 러닝타임을 구하는데 <em>black box</em> 같은 역할을 한다. 대강의 코드만으로도 러닝타임을 추측할 수 있다.</p>

<p>그러나 <em>master method</em> 는 가정을 하나 하는데, 바로 모든 문제가 같은 사이즈로 분할 된다는 것.</p>

<blockquote>
  <p>All sub priblems have equal size</p>
</blockquote>

<p><code>n</code> 이 충분히 작다면, <code>T(n)</code> 은 상수라 볼 수 있고 만약 <code>n</code> 이 충분히 크다면 <em>master method</em> 는 다음의 포맷을 가진다.</p>

<p><img src='https://acrocontext.files.wordpress.com/2014/01/master-method.png?w=300&amp;h=160'  align="center" />  </p>

<p align="center">(<a href='https://acrocontext.wordpress.com/' >https://acrocontext.wordpress.com</a>)</p>

<p>여기서 <code>a</code> 는 재귀 함수 호출의 수고, <code>b</code> 는 분할된 문제의 사이즈다. <code>d</code> 는 <em>combine</em> 스텝에서 사용하는 함수의 러닝타임의 지수다. (<em>merge-sort</em> 에서 머징하는 함수라 보면 된다.)</p>

<ul>
<li><code>a</code>: number of recursive calls (<code>&gt;= 1</code>)  </li>
<li><code>b</code>: input size shrinkage factor (<code>&gt; 1</code>)  </li>
<li><code>d</code>: exponent in running time of <em>combine step</em> (<code>&gt;= 0</code>)</li>
</ul>

<p>이제 몇 가지 예제를 좀 살펴보자.</p>

<p><em>merge sort</em> 의 경우는 <code>a = 2, b = 2, d = 1</code> 이므로 <code>2 = 2^1</code> 이어서 <code>O(n^1 * logn)</code> 즉 <code>O(nlogn)</code> 의 러닝타임을 가진다.</p>

<p><em>binary search</em> 는 문제 수가 절반으로 줄긴 하나 반쪽만 사용하고, 매 재귀호출 마다 한번의 비교만 하므로 <code>a = 1, b = 2, d = 0</code> 이므로 <code>a = b^d</code> 는 <code>1 = 1^1</code> 이 되어 <code>O(nlogn)</code> 이 된다. </p>

<p>가우스 곱셈은 <code>a = 3, b = 2, d = 1</code> 이므로 <code>O(n^log2_3)</code> 이 된다. 더 정확히는 <code>O(n^1.59)</code> <em>merge-sort</em> 보다 빠르진 않지만 <em>quadratic</em> 보단 빠르다.</p>

<p><em>strassen</em> 행렬 곱셈은 어떨까? <code>a = 7, b = 2, d = 2</code> 에서 마찬가지로 <em>case 3</em> 이므로 <code>O(n^log2_7)</code> 이다. <code>O(n^2.81)</code> 쯤 되므로 <code>O(n^3)</code> 보다는 훨씬 낫다.</p>

<p><em>merge-sort</em> 에서 <code>d = 2</code> 라면 <code>O(n^2)</code> 이 나온다. 사실 일반적으로 생각하기에는 <code>O(n^2 * logn)</code> 이 나올거 같은데, 사실 이건 <em>upper bound</em> 이므로 <code>O(n^2)</code> 이 좀 더 나은 <em>upper bound</em> 임을 알 수 있다. 이 사실은  <em>master method</em> 를 이용하면 수학적으로 더 근사한 값을 찾아낼 수 있다는걸 알려준다.</p>

<h4 id="proofmastermethod">Proof: Master Method</h4>

<p>재귀의 각 단계를 <code>j = 0, 1, 2, ... , logb_n (base b)</code> 라 하면 각 단계에서는 <code>a^j</code> 사이즈의 <em>sub-problem</em> 수와 <code>n / b^j</code> 사이즈의 문제가 있다. </p>

<p>단계 <code>j</code> 에서의 연산은 <code>a^j * c * (n / b^j)^d</code> 즉 <em>문제의 수 x 각 문제의 사이즈와 일어나는 거기서 일어나는 연산 수</em> 로 정의할 수 있다. 수식을 <code>j</code> 로 다시 정리하면</p>

<p>각 단계의 <em>sub problem</em> 에서 일어나는 연산은 <code>c * n ^d * (a / b^d)^j</code> 다. 따라서 전체 단계를 구하려면 여기에 시그마를 씌우면 된다.</p>

<p>식을 좀 더 자세히 보면</p>

<ul>
<li><em><code>a</code>:</em> rate of sub problem proliferation <em>(RSP)</em> </li>
<li><em><code>b^d</code>:</em> rate of work shirinkage <em>(RWS)</em></li>
</ul>

<p><code>d</code> 가 <code>n^d</code> 에도 섞여있어 좀 복잡하긴 한데 느낌만 알아보자면 <code>b = 2, d = 1</code> 일때는 <em>sub-problem</em> 당 문제가 1/2 씩 줄어든다. 하지만 <code>b = 2, d  = 2</code> 라면 문제의 수가 2배가 될때 문제 사이즈는 4배가 되고, <code>b^d = 4</code> 가 되어 1/4 만큼의 연산만 줄어든다. 따라서 <code>d</code> 가 커지는 건 생각보다 영향이 큰 걸 알 수 있다.</p>

<p>위 식으로부터 다음의 관계를 이끌어 낼 수 있다.</p>

<p>(1) if <em>RSP &lt; RWS</em>, then the amount of work is decreasing with the recursion level <code>j</code> <br />
(2) if <em>RSP > RWS</em>, then the amount of work is increasing with the recursion level <code>j</code> <br />
(3) if <em>RSP = RWS</em>, then the amount of work is same at every recursion level <code>j</code>  </p>

<p>따라서 <code>(3)</code> 의 경우 각 단계에서의 연산이 <code>c* n^d * 1^j</code> 이므로 깊이 <code>logb_n (base b)</code> 을 곱하면 <code>O(n^d * logn)</code> 이다. <em>(<code>a</code>, <code>b</code> 는 문제의 사이즈와 관계가 없다 그리고 더 정확히는 시그마를 더하면 <code>O(n^d * (1 + logb_n)</code> 이다)</em> </p>

<p><code>(2)</code> 의 경우 깊이가 깊어질 수록 각 단계에서의 연산이 급격하게 줄어들고, 루트에서의 (<code>j = 0</code>) 연산이 가장 크므로 루트에서의 연산을 <em>upper bound</em> 로 보면 <code>O(n^d)</code> 라 볼 수 있다. </p>

<p>마지막으로 <code>(1)</code> 의 경우 깊이가 깊어질수록 연산이 늘어나고, 대충 생각하면 마지막 노드의 개수에 비례하는 <em>Big O</em> 를 가지리라는 생각을 해볼 수 있다. </p>

<p>좀 더 수식에 대한 이해를 얻기 위해 수학적으로 접근해 보자.</p>

<p><code>1 + r + r^2 + ... + r^k</code> 를 귀납법으로 풀면 <code>r^(k+1) - 1 / r - 1</code> 이란 값이 나온다. <code>(r != 1)</code> 이 때 </p>

<p><code>r &lt; 1</code> 이고 <code>k</code> 가 충분히 크다면 이 식은 <code>1 / (1 - r)</code> 이라 보아도 된다. 다시 말해서 <code>k</code> 와는 관련 없는 상수라 보아도 된다는 뜻이다. 그리고 첫번 째 항이 다른 것들의 합보다 크다고 볼 수 있다.</p>

<p><code>r &gt; 1</code> 이라 했을때, 우측 식 <code>r^(k+1) - 1 / r - 1</code> 은 <code>r^k * (1 + 1 / r - 1)</code> 보다 항상 작거나 같다는 사실을 알 수 있다 <em>(upper bound)</em> 다시 말해서 마지막 항 <code>r^k</code> 의 2배보다 작거나 같다는 사실을 알 수 있다. 이것도 <code>r = 2</code> 일때나 맥시멈 두배다. </p>

<p>1 부터 256까지 더해봐도 512 보다 작거나 같다는 사실을 알 수 있다. 다시 말해서 마지막 항이 그 전 모든 항을 합한 것 보다 크다.</p>

<p>이제 다시 <em>master method</em> 로 다시 돌아오자.</p>

<p><code>c* n^d * sigma(j) (a / b^d)^j</code> (<code>j = 0 to logb_n</code>) 에서 <code>a / b^d</code> 를 <code>r</code> 이라 두자.</p>

<p><em>RSP &lt; RWS (case 2)</em> 이면 <code>r &lt; 1</code> 이므로 시그마를 합해봐야 특정 상수다. <code>O(n^d)</code></p>

<p>반대로 <em>RSP > RSW (case 3)</em> 이면 <code>r &gt; 1</code> 이므로 시그마를 합해봐야 <code>r^k * 상수</code> 보다 작거나 같으므로 가장 큰 항 <code>r^k</code> 는 <code>(a / b^d)^logb_n</code> 이다. 여기서 <code>b^(-dlogb_n)</code> 이 <code>n^-d</code> 라는 사실을 이용하면 <code>O(a^logb_n)</code>만 남는다.</p>

<p>그런데, 재미있는 사실은 <code>logb_n</code> 이 마지막 단계이고, <code>a</code> 는 각 단계에서 분할되는 노드의 갯수이므로 <code>a^(logb_n)</code> 은 <em>recursion tree</em> 에서 <em>leave</em> 의 갯수다. </p>

<p>다시 말해서 마지막 단계에서의 노드의 갯수에 연산이 비례한다. 근데 처음에 우리가 봤던건 <code>n^(logb_n)</code> 아니었던가? 사실 로그를 배우면 위 두 식은 같다는걸 알 수 있다.</p>

<h3 id="quicksort">Quick Sort</h3>

<p>퀵소트는 평균적으로 <code>O(n logn)</code> 성능을 보여주며 <em>in-place</em> 로 작동하는 인기있는 정렬 알고리즘이다.</p>

<p><em>key idea</em> 는 <em>pivot</em> 을 중심으로 문제를 좌우로 분할하는 것이다.   <em>less than pivot</em> 들은 왼쪽에, <em>greater than pivot</em> 들은 우측에 놓음으로써 최소한 한번의 분할당 하나의 원소 <em>(pivot)</em> 은 자리를 잡는 다는 것을 보장한다.</p>

<p>퀵소트의 매 호출당 일어나는 <em>partition (분할)</em> 은 다음의 두 특징을 가진다.</p>

<p>(1) linear time, <code>O(n)</code> <br />
(2) no extra memory</p>

<p>대강의 로직은 이렇다. <code>Quicksort(array A, length n)</code> 에 대해서</p>

<p>(1) if <code>n = 1</code> return <code>A</code> <br />
(2) <code>p</code> = choose <code>Pivot(A, n)</code> <br />
(3) partition <code>A</code> round <code>p</code> => <code>L, R</code> <br />
(4) recursively solve <code>L</code>, <code>R</code></p>

<p>보면 알겠지만 <em>combine</em> 혹은 <em>merge</em> 스텝이 전혀 없다. </p>

<h4 id="partitioninplace">Partition: In-place</h4>

<p><code>O(n)</code> 의 추가 메모리를 사용하면 연산시간 <code>O(n)</code> 을 구현하기 쉽다. 추가 메모리 없이 어떻게 <code>O(n)</code> 으로 <em>partitioning</em> 을 구현할 수 있을까?</p>

<p>(1) 첫 번째 원소를 <em>pivot</em> 이라 놓고 <br />
(2) <em>pivot</em> 다음의 원소를 <code>i</code>, <code>j</code> 가 가리키게 한다. <br />
(3) <code>j</code> 보다 작은 원소들은 <em>partitioned</em> , 큰 원소는 <em>unpartitioned</em> 라 보고 <br />
(4) <code>i</code> 보다 작은 원소들은 <em>pivot</em> 보다 작은 값, 큰 원소들은 <em>pivot</em> 보다 큰 값이다. <br />
(5) <code>i &lt;= j</code> 이며, <code>i == j</code> 일때는 <code>j</code> 값을 증가시켜 원소를 비교 한뒤 <code>j</code> 에 있는 원소가 <code>i</code> 가 가리키는 원소보다 크면 <em>swap</em> 하고 <code>i += 1, j +=1</code> 아니면 <code>j += 1</code> 한다.</p>

<p>이해가 쉽게 그림을 첨부하면</p>

<p><img src='http://sadakurapati.files.wordpress.com/2013/10/qsort_1.png'  align="center" /> <br />
<img src='http://sadakurapati.files.wordpress.com/2013/10/qsort_2.png'  align="center" />  </p>

<p align="center">(<a href='http://sadakurapati.wordpress.com/' >http://sadakurapati.wordpress.com</a>)</p>

<p>이런 로직으로 <code>n</code> 개의 원소를 순회하면, <code>n-1</code> 번 만큼 <code>j</code> 순회를 하고 최악의 경우 <code>n-1</code> 번의 <em>swap</em> 과 <em>i += 1</em> 연산이 일어난다.  다시 말해 각 원소마다 <code>O(1)</code> 연산이므로, <em>partition</em> 연산은 <code>O(n)</code> 이라 보장할 수 있다.</p>

<p><em>quick-sort</em> 는 귀납법으로 증명하기도 쉬운데, <code>P(n)</code> 이 1부터 <code>n</code> 까지의 정렬된 원소를 가지고 있는 배열이라고 하면, </p>

<p><code>P(1)</code> 임은 자명하고, 문제의 수 <code>k</code> 에 대해 퀵소트가 <code>P(k)</code> 일때  <code>P(k+1)</code> 임을 보이면 <code>P(n)</code> 에 대해서도 참임을 알 수 있다.</p>

<p>그런데, <code>P(k+1)</code> 에서 <em>pivot</em> 을 제외한 좌측과 우측의 사이즈를 <code>k1</code>, <code>k2</code> 라 하면 <code>k1, k2 &lt; k</code> 이다. 좌측 또는 우측이 없을 때라야 <code>k1 or k2 = k</code> 다. 이때 <code>P(k)</code> 가 참이므로 이보다 작거나 같은 <code>k1, k2</code> 의 문제 사이즈에 대해서도 참이다. 따라서 <code>P(k+1)</code> 도 참이다.</p>

<h4 id="choosingagoodpivot">Choosing a good pivot</h4>

<p>그럼 <em>pivot</em> 은 무엇을 기준으로 잡는게 좋을까? 어차피 비교에서 <code>i != p and j != p</code> 라면 구현에는 어느 위치에 잡던 문제가 없을것 같은데..</p>

<p>만약에 <em>pivot</em> 이 첫 번째 원소이고, 입력이 이미 정렬이 된 배열이라면 성능이 어떻게 될까? 바로 <code>O(n^2)</code> 이다. 왜냐하면 이미 정렬이 되어있으므로 문제가 1/2 로 분할되지 않기 때문이다. 배열 사이즈만 1씩 줄어들면서 재귀호출이 반복된다.</p>

<p>그럼 만약에, <em>pivot</em> 을 원소들의 <em>median (중앙값)</em> 으로 고른다면? 매 재귀마다 문제가 좌우로 분할되므로 <code>O(nlogn)</code> 이라 볼 수 있다.</p>

<p>근데 생각해 볼 거리가 있다. <em>pivot</em> 을 구하는 함수의 비용은 어떻게 되는걸까? 이것 또한 <code>O(n)</code> 이므로 전체 <em>partition</em> 의 비용은 <code>O(n)</code> 이라 보아도 된다.</p>

<h4 id="randomizedpivots">Randomized pivots</h4>

<p>그럼 만약에 <em>pivot</em> 을 무작위로 고르면 어떻게 될까 생각해 보자. <em>pivot</em> 을 무작위로 선택했을 때 한쪽이 <code>25-75%</code> 로 분할될 확률은 1/2 이다. </p>

<p>그리고 무작위로 <em>pivot</em> 을 선택했을때 첫번째 다음 재귀 호출에 넘겨질 배열의 길이의 기대값을 구하면, 다시 말해 <code>X</code> 를 <em>subproblem size</em> 라 했을때 <code>E(X)</code> 를 구하면</p>

<p><code>1/n * (0 + 1 + ... + (n - 1)) = (n - 1) / 2</code> 다.</p>

<p>여기서 잠깐 중요한 속성인 <em>linearity of expection</em> 을 설명하면 </p>

<blockquote>
  <p>모든 <em>random variable</em> <code>X</code> 의 합의 기대값은, 각 <code>X</code>의 기대값의 합과 같다.</p>
</blockquote>

<p><img src='http://www.opendatastructures.org/ods-java/img333.png'  align="center" />  </p>

<p align="center">(<a href='http://www.opendatastructures.org/' >http://www.opendatastructures.org</a>)</p>

<p><code>Xj(i)P(i)</code> 를 컬럼의 개수가 <code>j</code>, 행의 개수가 <code>i</code> 인 행렬의 원소로 보면 이 <em>linearity of expectation</em> 은 쉽게 이해할 수 있다. 이 속성은 꽤나 유용하다.</p>

<p>예를 들어 두개의 주사위를 독립적으로 굴린다고 할 때 나오는 값인 <em>random variable</em> <code>X1, X2</code> 에 대한 기대값을 직접 구하려면 36개의 <em>sample space</em> 를 살펴봐야 하는데, 그러지 말고 하나를 굴렸을때의 값을 구해 이걸 2배 하면 된다. 하나를 굴렸을때는 6개의 <em>sample space</em> 만 살피면 되니 금방 구한다.</p>

<p>로드 밸런싱문제에 <em>linearity of expectation</em> 을 적용해보자. <code>n</code>개의 서버가 있고 여기에 <code>n</code> 개의 프로세스를 랜덤하게 할당할때 한개의 서버에 할당될 프로세스의 기대값은 얼마일까? 다시 말해 평균적으로 몇개의 프로세스가 서버에 할당될까?</p>

<p><em>sample space</em> 는 <code>n</code> 개의 항끼리의 곱에서 항의 개수를 구하는 문제와 같으므로 <code>n^n</code> 이다.</p>

<p>이때 <code>Y</code> 를 첫 번째 서버에 할당된 프로세스 수의 합이라 하면 이때 <code>Y</code> 는 <code>sigma Xj (j = 1 to n, Xj = 1 or 0)</code>이다.</p>

<p><code>E[Y]</code> 를 구하는 것이 본래의 문제인데 가능한 <code>Y</code> 값을 모두 구한 뒤에 각각의 확률을 곱해서 더하느니, <code>Y</code> 를 분해해 각각의 기대값을 구한 후 더하는게 훨씬 빠르다. (주사위 굴리기 문제처럼)</p>

<p>다시 말해서, <code>Y</code> 가 여러개의 항으로 구성될때는 각각의 기대값을 구하는게 더 계산이 빠르다는것이 <em>lineariry of expectation</em> 의 본질이다.</p>

<p>따라서 기대값을 시그마 뒤쪽으로 빼서 계산하면 <code>1</code> 이 나온다. 다시 말해 서버 하나당 평균적으로 1개의 프로세스를 가진다는 이야기.</p>

<p>다시 이 확률 테크닉을 <em>randomized pivot</em> 을 선택하는 <em>merge sort</em> 에 적용하러 가 보자.</p>

<h3 id="decompositionprinciple">Decomposition Principle</h3>

<p>일단 랜덤 피벗을 가지는 퀵소트를 <em>master method</em> 로는 <em>Big O</em> 를 찾을 수가 없다는 사실을 알아 두자. 이는 입력한 배열이 일정하게 분할되지 않고 피벗때문에 랜덤하게 분할되지 때문이다.</p>

<p>이제, 퀵 소트의 각 재귀에서 일어나는 연산 중 <em>comparison (비교)</em> 가 다른 연산보다 <em>dominant</em> 하다고 하면, 다시 말해서 비교하는 숫자에 의해 연산 수가 결정된다고 하자. 이건 생각해보면 사실인데, <em>partition</em> 과정에서 일어나는 비교가 각 <em>sub-problem</em> 에서의 연산 수를 결정한다.</p>

<p>이렇게 하면 연산수의 기대값, 다시 말해서 <em>비교가 일어나는 회수의 평균으로</em>, 퀵소트의 평균 성능을 찾아낼 수 있다.</p>

<p>그런데 입력 배열에 대한 전체 비교 수를 <code>C</code> 라 두면 <code>E(C)</code> 는 사실 구하기가 굉장히 어렵다. 그런데, <code>E(C)</code> 를 시그마 두번으로 분해할 수 있고, 심지어 가장 내부의 항은 <code>1</code> 또는 <code>0</code> 을 가지는 원소이다. 따라서 <em>linearity of expectation</em> 을 이용할 수 있다 <del>할렐루야</del> </p>

<p>참고로 가장 내부의 항에 대해서 설명하자면, 전체 입력에서 두개의 원소를 골랐을 때 이 두개의 원소가 비교 되는 수다. 이 두개의 원소는 <code>i</code>, <code>j</code> 를 기준으로 구할 수 있으므로 <code>X_ij</code> 라 두면 <code>i, j</code> 에 각각에 대해 시그마를 씌울 수 있다. 이것이 <code>C</code> 이므로 <code>E(C)</code> 를 구하기는 상당히 복잡함을 알 수 있다. 그런데 <code>X_ij</code> 자체는 <code>0</code> 또는 <code>1</code> 만 가지는 값이니 이것에 대해 <code>E(X_ij)</code> 를 구하면 심플해진다. (수식을 적기 힘드니 자세한 내용은 강의 <em>Analysis I: A Decomposition Principle</em> 을 참조)</p>

<p>따라서 <code>E(C)</code> 는 <code>sigma i &lt;- 1 to n-1, sigma j &lt;- i+1 to n P(X_ij = 1)</code> 이다. </p>

<p>여기서 잠깐 이제 까지 나온 <em>decompositio principle</em> 을 설명하자면</p>

<p>(1) 구하고자 하는 랜덤 변수 <code>Y</code> 를 정의하고 <br />
(2) <code>Y</code> 를 더 간단한 랜덤 변수 <code>X</code> 의 합으로 정의하자. <code>X</code> 가 0 또는 1만 가지는 값이면 더 좋다. 
(3) <em>linearity of expectation</em> 을 적용  </p>

<p>다시 말해 알고리즘의 성능을 결정하는 <em>dominant operation</em> 을 확률변수로 표현할 수 있고, 더 간단한 확률 변수의 합으로 표현할 수 있다면 해해 여기에 <em>기대값의 선형성</em> 을 이용해 알고리즘의 평균적인 성능을 구할 수 있다는 뜻이다.</p>

<p><code>sigma i &lt;- 1 to n-1, sigma j &lt;- i+1 to n P(X_ij = 1)</code> 다시 이 식으로 돌아오자. 여기에 적용할 수 있는 퀵소트의 특징이 있다. 여기서 <code>z_i</code> 를 정렬된 배열의 <code>i</code> 번쨰 원소라 했을때 <em>pivot</em> 이 될 수 있는 것은 <code>z_i, z_i+1, ... z_j-1, z_j</code> 다. 이때</p>

<p>(1) <code>z_i</code> 또는 <code>z_j</code> 가 <em>pivot</em> 이 되면, 즉 가장 작은 수나 가장 큰 수가 <em>pivot</em> 이 되면 <code>z_i</code> 와 <code>z_j</code> 는 한번만 비교된다. (이후에는 다른 재귀로 넘어가 둘 중 하나의 수만 남음) <br />
(2) <code>z_i+1</code>, ..., <code>z_j-1</code> 이 <em>pivot</em> 이 되면 <code>z_i</code> 와 <code>z_j</code> 는 절대로 비교되지 않는다. <em>pivot</em> 기준으로 큰 수와 작은수는 서로 비교되지 않으며 둘 다 피벗과만 비교된다. 이후에도 다른 파티션으로 나누어져 비교되지 않는다.</p>

<p>따라서 각 <em>sub-problem</em> 에서 일어나는 비교가 일어날 확률은 <code>2 / (j - i + 1)</code> 이다. 다시 말해서 전체 원소 중에서 <code>z_i</code> 와 <code>z_j</code> 를 피벗으로 삼는 경우에만 비교가 일어난다.</p>

<p>따라서 평균 연산 수 <code>E(C)</code> 는 <code>sigma i &lt;- 1 to n-1, sigma j &lt;- i+1 to n [2 / (j -i + 1)]</code> 이다.</p>

<p>이때 <code>j = i +1</code> 부터 시작하므로 내부 시그마는 <code>1/2 + 1/3 + ... 1/n</code> 이다. 그리고 내부 시그마에서 <code>i</code> 가 사라졌으므로 외부 시그마 <code>i &lt;- 1 to n-1</code> 을 <code>n-1</code> 대신 대략 <code>n</code> 이라고 놓으면,</p>

<p><code>E(C) &lt;= 2 * n * [sigma k &lt;- 2 to n (1/k)]</code> 다. </p>

<p>이때 <code>sigma k &lt;- 2 to n (1/k)</code> &lt;= <code>ln n</code> 인데, 본래 식의 <code>k</code> 1 부터의 시그마보다 작으므로 이걸 적분으로 넓이를 구하면 <code>ln n - ln 1 =  ln n</code> 이다. </p>

<p>따라서 <code>E(C) &lt;= 2 * n * ln n</code></p>

<h3 id="notes">Notes</h3>

<p>이하는 필기 노트입니다. </p>

<h4 id="matrixmultiplication">matrix multiplication</h4>

<p>단순히 brute force 로 3 for-loop 로 구현하면 당연히 o(n^3) -_-;</p>

<p>스트라센 매트릭스 곱셈으로 구현하면 놀랍게도 n^2 </p>

<h4 id="multiplication">Multiplication</h4>

<ol>
<li>define Input, output  </li>
<li>assess performance</li>
</ol>

<p>can we do better strait forard?</p>

<p>일반적인 곱셈(초등3학년)은 2n * n</p>

<h4 id="karatsubamultiplication">Karatsuba Multiplication</h4>

<p>a * c <br />
b * d = 2652 <br />
(a + b)(c + d) = 6164
(a+b)(c+d) - a*c - b * d = 2840</p>

<p>ad bc </p>

<p>6164 + * 10000 <br />
+ 2652
+ 2840 * 100</p>

<p>x = 10^n/2 a + b <br />
y = 10^n/2 c + d</p>

<p>x * y => 10^n ac + 10 n/2 (ad+bc) + bd <br />
따라서 <em>Karatsuba multiplication</em> 은 <em>product</em> 문제를 ac, ad, bc, bd 의 곱으로 쪼갬.</p>

<p>여기서도, ac, ad, bc, bd 를 모두 구하는 대신에</p>

<p>(a+b)(c+d) - ac bd 를 빼면,  ac bd (a+b)(c+d) 3개만 구하면 된다.</p>

<p>따라서 3개의 recursive multiplication 만 필요</p>

<h4 id="closestpairs">Closest Pairs</h4>

<p>brute force 는 n^2 인데, </p>

<p>1D 의 closest pair 에서 sorting 하면 n^2 가 아니라 nlogn 이다.</p>

<p>로직은 다음과 같다.</p>

<p>문제를 반으로 잘라가면서 왼쪽에서 거리가 가장 짧은것 좌표 쌍, 오른쪽에서 가장 짧은것을 찾고, 각 영역에 좌표가 하나씩 있는 쌍도 검사 한다.</p>

<p>(1) 주어진 배열을 P 라 하고 반으로 각각 좌우 Q, R 자른다. O(n) Q를 x 정렬한것을 Qx, y 축 기준으로 Qy, R도 Rx, Ry. 이건 전체 인풋 n 에 대해서 n logn <br />
(2) ClosestPair(Qx, Qy), Closest(Rx, Ry) 해서 각각 좌 우에서 가장 짧은 거리를 가진 pair 쌍을 찾는다.  이걸 (p1, q1), (p2, q2)  라 하면 <br />
(3) (p1, q1), (p2, q2) 의 거리를 구해 최소값인 d 를 찾는다 <br />
(4) Closest(Px, Py, d) 해서 (p3 , q3) 가 있으면 찾아낸다. 여기서 찾은건 하나는 Q 하나는 R 에 있는 d 보다 작은 거리를 가진 점의 쌍 <br />
(5) p1, p2, p3 쌍중 가장 작은 d 를 가진 것을 리턴 </p>

<p>ClosestSplitPair</p>

<p>(1) Px 의 가운데 점을 xBar 라 하면 이것 기준으로 -d, +d 의 x 값을 가진 점들을 Py 에서 찾아낸다. 정의에 의해서 x1 - x2 &lt;= d 이기 때문에 아무리 커봐야 xBar 기준으로 좌우 d 까지밖에 존재하지 못함. 이걸 Sy 라 부르자. 이건 Py 가 이미 정렬되어 있기 때문에 O(n) 시간. <br />
(2) Sy 는 y 축 기준으로 이미 정렬되어 있는데, 여기서 Sy 의 원소를 루프로 돌면서 이것 기준으로 +7개 원소를 검사하면서 거리가 d 보다 작은것이 있는지 검사. 이것 또한 마찬가지로 d 의 정의와 두 점이 Q, R 에 있다는 점을 이용해서 증명이 가능함. </p>

<p>y1 - y2 도 d 보다 작거나 같이 때문에 y 기준으로 정렬된 점을 기준으로 잡았을때, </p>

<p>p 와 같은 왼편에 있는 것들은 p와의 거리가 d 보다 작을 수 없다. 왜냐하면 d 자체가 같은 사이드에 있는 것들의 최소 거리이기 때문. <br />
이런점들을 아무리 많이 왼쪽에 구겨 넣어도 3개. p 포함하면 4개다. 마찬가지로 q 와 같은 편에 있는것들도 3개.</p>

<p>따라서 운이 나쁠 경우 Sy 에서 p, q + 6개를 더 검사해야. </p>

<p>직사각형을 그려보면 이해가 쉬움.</p>

<p>Input 은 (x1, y1) ... (xn, yn) 의 pair n개 편의상 p1, p2, ... pn</p>

<p>d(p<em>i, p</em>j) 는 두 point 사이 거리</p>

<p>(1) 모든 점들을 x 기준으로 정렬했을때 가운데에 있는 점을 xBar 라 하면 S<em>y 는 xBard - d, xBar + d 사이에 있는 모든 점이다. 만약에 왼쪽에 있는 p, 오른쪽에 있는 q 가 존재한다면 이 둘은 S</em>y 사이에 있고 아래 증명에 에해서 x1, x2 사이 거리는 d 보다 작다.</p>

<p>왜냐하면, p(x1, y1), q(x2, y2) 사이의 거리가 d 보다 작기 때문에 x1 - x2 &lt;= d 이다. </p>

<p>(2) S_y 에서 p, q 가 존재한다면 그건 y 기준으로 7 원소 이내에 인접해 있다. </p>

<h3 id="references">References</h3>

<p>(1) <a href='https://acrocontext.wordpress.com/' >https://acrocontext.wordpress.com</a> <br />
(2) <a href='http://sadakurapati.wordpress.com/2013/10/25/quicksort-a-practical-and-efficient-sorting-algorithm/' >http://sadakurapati.wordpress.com</a> <br />
(3) <a href='http://www.opendatastructures.org/ods-java/1_3_Mathematical_Background.html' >http://www.opendatastructures.org</a></p>]]></description><link>http://1ambda.github.io/divide-and-conquer/</link><guid isPermaLink="false">30db0108-971b-46ea-8793-427ecb229117</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[divide and conquer]]></category><category><![CDATA[master method]]></category><category><![CDATA[merge sort]]></category><category><![CDATA[quick sort]]></category><category><![CDATA[decomposition principle]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 29 Oct 2014 13:02:22 GMT</pubDate></item><item><title><![CDATA[하스켈로 배우는 함수형 언어 1]]></title><description><![CDATA[<p>먼저 이 글은 <strong>edx</strong> 의 <em>FP101.x (Introduction to Functional Programming)</em> 수업을 기반으로 작성되었음을 알려드립니다.</p>

<p>시작에 앞서서, 하스켈을 설치하려면 <a href='http://www.haskell.org/platform/linux.html' >Haskell Platform</a> 을 설치하신 후 터미널에서 <code>ghci</code> 를 입력하면 됩니다. 하스켈 플랫폼은 하스켈 구현체로 <a href='http://www.haskell.org/ghc/' >Glasgow Haskell Compiler, <em>GHC</em></a> 를 포함하고 있습니다. <code>ghci</code> 를 입력하면 하스켈 인터프리터를 사용할 수 있습니다.</p>

<p>깔기 귀찮으시다면 <a href='https://www.fpcomplete.com/' >https://www.fpcomplete.com/</a> 여기서 웹으로 코드를 작성하고 컴파일 할 수 있습니다.</p>

<h3 id="basics">Basics</h3>

<p>먼저 <code>sum [1..10]</code> 을 인터프리터에 입력하면 1부터 10 까지의 합, <code>55</code> 을 돌려줍니다. <code>sum</code> 은 리스트의 원소를 모두 합한 값을 구하는 함수고 <code>[1..10]</code> 은 1-10 을 포함하는 리스트를 생성합니다.</p>

<p>이제 인터프리터를 잠깐 끈 후에 <em>quick-sort</em> 함수를 파일에 작성한 뒤 로드해 봅시다. 아참, <code>ghci</code> 를 종료하려면 <code>ctrl + d</code> 를 입력합니다.</p>

<pre><code class="haskell">-- quicksort.hs

f [] = []  
f (x:xs) = f ys ++ [x] ++ zs  
           where
             ys = [a | a &lt;- xs, a &lt;= x]
             zs = [b | b &lt;- xs, b &gt; x]
</code></pre>

<p>수학 표기법 같은데, 놀랍게도 잘 동작합니다. 다시 <code>ghci</code> 실행하고 <code>:load quicksort.hs</code> 를 입력합니다. 그러면 우리가 작성한 <code>f</code> 함수가 인터프리터에 로드 됩니다. <em>퀵-소트</em> 를 사용할 수 있다는 뜻이죠.</p>

<pre><code>ghci &gt; f [3, 2, 9, 5, 4]  
[2, 3, 4, 5, 9]
</code></pre>

<p>제대로 정렬 되는걸 확인할 수 있습니다. 매번 인터프리터를 종료했다가 다시 실행시키긴 귀찮으니 파일을 다시 수정했을때 <code>:reload</code> 명령어를 사용해서 다시 로드합니다. 이외에도 다른 명령어를 보고싶다면 <code>ghci</code> 에 <code>:help</code> 를 입력해보세요.</p>

<p>이제 대충 어떻게 돌아가는지 알았으니 기본적인 함수를 좀 알아볼까요? 다른 함수형 언어처럼 하스켈도 <code>List</code> 에 대한 기본적인 연산들이 있습니다.</p>

<pre><code class="haskell">head [2, 3, 4] -- 2  
tail [2, 3, 4] -- [3, 4]

head [2] -- []  
tail [2] -- []

init [2, 3, 4] -- [2, 3]  
last [2, 3, 4] -- 4

take 2 [2, 3, 4] -- [2, 3]  
drop 2 [2, 3, 4] -- [4]  
</code></pre>

<p>리스트 원소에 접근하려면 <code>!!</code> 를 이용합니다. 다른 언어와 마찬가지로 <code>0</code> 부터 인덱스가 시작합니다. </p>

<pre><code class="haskell">[1, 2, 3, 4] !! 1 -- 2
[1, 2, 3, 4] !! 2 -- 3
[1, 2, 3, 4, 5] !! 2 -- 3
[1, 2, 3, 4, 5] !! 0 -- 1
</code></pre>

<p>하스켈의 리스트는 자료구조의 그것처럼, <code>n</code> 번째 원소에 접근하려면 <code>O(n)</code> 의 비용이 듭니다. 그런 이유에서 리스트의 원소를 구하는 <code>length</code> 도 <code>O(n)</code> 의 비용이 듭니다. 자바의 배열과는 좀 다르죠? </p>

<p>이제 리스트에 대한 몇 가지 연산을 더 알아봅시다.</p>

<pre><code class="haskell">product [1, 2, 3, 4, 5] -- 120  
[1, 2, 3] ++ [4, 5] -- [1, 2, 3, 4, 5]
reverse [1, 2, 3, 4] -- [4, 3, 2, 1]  
</code></pre>

<p><code>++</code> 는 <em>append</em> 연산입니다. 앞에 온 리스트에, 뒤에 온 리스트를 붙여줍니다. </p>

<h3 id="functionapplication">Function Application</h3>

<p>이제 함수를 사용하는 법을 좀 알아볼까요? 일반적으로 <code>f</code> 라는 함수에 파라미터 <code>a</code> 를 적용하려면 <code>f(a)</code> 이렇게 쓸 텐데요. 하스켈에선 <code>f a</code> 라고 작성해도 됩니다. 왜냐하면 함수의 우선순위가 다른 연산자들보다 높거든요</p>

<blockquote>
  <p>Function application is assumed to have higer priority than all other operators</p>
</blockquote>

<p>이런 이유에서 <code>f a + b</code> 는 <code>f(a) + b</code> 입니다. <code>f(a + b)</code> 를 의도했다면 <code>f(a + b)</code> 라고 쓰셔야 합니다.</p>

<pre><code class="haskell">f x -- f(x)  
f x y -- f(x, y)  
f (g x) -- f(g(x))  
f x (g y) -- f(x g(y))  
f x * g y -- f(x) * g(y)  
</code></pre>

<p>이제 좀 스크립트에 다른 함수를 작성해 볼까요?</p>

<pre><code class="haskell">-- test.hs

double x = x + x  
quadruple x = double (double x)  
</code></pre>

<p><code>double</code> 은 <em>function</em> 이고 왼쪽에 오는 <code>x</code> 는 <em>argument</em> 입니다. <code>=</code> 뒤에 오는건 함수의 <em>body</em> 로 함수가 무슨일을 하는지 기록한 것이죠.</p>

<p>이제 <code>:load test.hs</code> 후 <code>take (double 2) [1, 2, 3, 4, 5, 6]</code>을 입력하면 <code>[1, 2, 3, 4]]</code> 를 돌려줄겁니다. 다른 함수를 좀 더 만들어 봅시다.</p>

<pre><code class="haskell">-- test.hs

factorial n = product [1..n]  
avg ns = sum ns `div` length ns  
</code></pre>

<p><code>factorial</code> 은 별로 놀랍지 않죠? 그런데 평균을 구하는 <code>avg</code> 는 문법이 좀 신기합니다. <code>ns</code> 는 리스트입니다. <code>sum</code> 을 적용해야 하니까요. 그리고 끝에 <code>s</code> 를 붙이는건 관례인데, 일반적으로 변수 끝에 <code>s</code> 를 붙이면 리스트란 뜻입니다. <code>ns</code> 란 이름은 <em>정수 리스트</em> 라고 알려주는 것이지요. </p>

<p><code>sum ns</code> 는 <code>ns</code> 의 합을 구하고, <code>length ns</code> 는 <code>ns</code> 의 길이를 구합니다. <code>div</code> 함수를 <em>back-quote</em> 감싼 것은 함수가 두개의 파라미터를 가질때 가운데 위치할 수 있도록 해 줍니다. </p>

<p>그래서 <em>back quote</em> 로 감싼  함수를 만나면 하스켈 컴파일러는 <strong>"왼쪽과 오른쪽에 있는 것들을 파라미터로 가지는 함수"</strong> 임을 깨닫죠. 이런 문법은 <code>3 / 5</code> 처럼 함수를 <em>operator (연산자)</em> 쓰듯이 사용할 수 있게 해줍니다. 따라서 위에 나온 코드의 본래 모양은 이렇습니다.</p>

<pre><code class="haskell">avg ns = div (sum ns) (length ns)  
</code></pre>

<blockquote>
  <p><em>x <code>f</code> y</em> is just <strong>syntatic sugar</strong> for <em><code>f</code> x y</em></p>
</blockquote>

<p>아참 그리고 함수의 이름은 소문자로 시작해야 합니다. <code>Avg</code> 는 함수 이름으로 쓸 수 없어요. 그리고 <code>nss</code> 처럼 변수 이름이 <code>s</code> 두개로 끝나면, 그건 리스트의 리스트라는 것을 뜻합니다. 물론 관례죠. 필수는 아닙니다. 그러나 우리가 작성하는건 남들이 볼 수도 있으니 따라주는 편이 좋습니다.</p>

<p>그리고 변수의 정의에 대해 <em>layout</em> 을 지키면 <code>{}</code> 블럭을 안 사용해도 됩니다. 예를 들어 다음의 두 코드는 똑같은 코드입니다.</p>

<pre><code class="haskell">a = b + c  
    where
      b = 1
      c = 2
d = a * 2

a = b + c  
    where
      { b = 1
      c = 2 }
d = a * 2  
</code></pre>

<h3 id="booleantuple">Boolean, Tuple</h3>

<p>하스켈은 대 소문자를 구분하기 때문에 <em>Boolean false</em> 를 얻을려면 <code>False</code> 를 입력해야 합니다.</p>

<pre><code class="haskell">False || True -- True  
</code></pre>

<p>괄호로 감싼 두개의 값들을 <em>tuple</em> 이라 부릅니다. <em>list</em> 는 같은 종류만 담을 수 있지만 <em>tuple</em> 은 달라도 상관 없지요. <code>fst</code>, <code>snd</code> 는 <em>tuple</em> 에서 첫 번째 와 두 번째 값을 돌려주는 함수입니다.</p>

<pre><code class="haskell">fst (1, "Hello") -- 1  
snd (1, "Hello") -- "Hello"  
fst (snd (1, (2, 3))) -- 2  
</code></pre>

<p>아참, <code>ghci</code> 에서 <code>:t</code> 을 입력하면 <em>expression</em> 의 타입을 알 수 있습니다. <code>:t False</code>, <code>:t length</code>, <code>:t head</code>, <code>:t (1, "Hello")</code> 등을 입력해보세요.</p>

<h3 id="types">Types</h3>

<p>다른 언어처럼 하스켈도 타입이 있습니다. <code>False</code> 와 <code>True</code> 은 <code>Bool</code> 타입이죠. <code>ghci</code> 에서 <code>:t False</code> 를 입력하면 <code>False :: Bool</code> 이란 결과를 돌려줍니다. <code>e :: t</code> 는 <code>e</code> 가 <code>t</code> 타입을 가지고 있다는 뜻입니다.</p>

<p>모든 <em>expression (식)</em> 은 타입을 가지고 있습니다. 하스켈 컴파일러는 컴파일 타임에 <em>type inference (타입 추론)</em> 을 통해서 타입을 찾아냅니다. 만약 함수의 타입과 불일치하는 인자가 파라미터로 넘겨진다면 타입 에러가 발생하는 것이지요.</p>

<p>하스켈에서 문자열을 나타내는 타입인 <code>String</code> 은 사실 문자 하나를 의미하는 <code>Char</code> 의 리스트입니다. </p>

<p>그리고 <em>fixed-precision integer</em> 를 의미하는 <code>Int</code> 이외에도  파이썬 처럼 <em>arbitrary-precision integer</em> 를 위한 <code>Integer</code> 타입이 있습니다. 실수는 <code>Float</code> 타입을 이용해 나타냅니다.</p>

<p>앞서 언급했듯이 <em>Tuple</em> 과 달리 <em>List</em> 는 같은 타입만 가질 수 있습니다. 그래서  <code>[False, False, True]</code> 의 경우  <code>[Bool]</code> 타입입니다. 문자열은 문자의 리스트이므로 <code>String</code> 타입은 <code>[Char]</code> 입니다. 스트링의 리스트는 <code>[String]</code> 이고 더 정확히는 <code>[[Char]]</code> 입니다.</p>

<p>그리고 아까는 <em>Tuple</em> 을 두개의 원소만 가질 수 있다고 했지만 사실은 두개 이상의 원소를 가질 수 있습니다 <code>n</code> 개의 원소를 가진 <em>tuple</em> 을 <em>n-tuple</em> 이라 부릅니다. 예를 들어 이런 <em>tuple</em> 도 있을 수 있습니다.</p>

<pre><code class="haskell">(False, 'a', True) :: (Bool, Char, Bool)
(True, ['a', 'b']) :: (Bool, [Char])
</code></pre>

<h3 id="functiontype">Function Type</h3>

<p>함수는 한 타입의 값을 다른 타입의 값으로 매핑합니다.</p>

<blockquote>
  <p>A <em>function</em> is a mapping from values of one type to values of another types</p>
</blockquote>

<p>예를 들어 <code>:t not</code> 을 <code>ghci</code> 에서 입력하면 아래처럼 출력됩니다. 
<code>not</code> 함수는 <code>Bool</code> 타입을 받아 <code>Bool</code> 타입을 돌려준다는 뜻입니다.</p>

<pre><code class="haskell">not :: Bool -&gt; Bool  
</code></pre>

<p>이제 파일에 타입까지 같이 명시해서 함수를 작성해 봅시다.</p>

<pre><code class="haskell">add :: (Int, Int) -&gt; Int  
add (x, y) = x + y

zeroto :: Int -&gt; [Int]  
zeroto n :: [0..n]  
</code></pre>

<p>함수가 만약 <em>tuple</em> 을 인자로 받으면 괄호가 필요합니다.</p>

<h3 id="curriedfunction">Curried Function</h3>

<p>여기서 잠깐 <em>Currying</em> 을 설명할 텐데요, 하스켈에서 빠질 수 없는 부분이니 이해가 어렵다면 다른 글을 찾아서라도 이해를 하시는 편이 좋습니다.</p>

<p><em>Currying</em> 의 기본 개념은 이렇습니다. 함수가 <code>(Int, Int) -&gt; Int</code> 타입이라면 <strong>계산을 끝내기 위해 두개의 정수를 받아</strong> 하나의 <code>Int</code> 를 돌려줄겁니다. </p>

<p>다시 한번 반복하자면, 계산을 끝내기 위해서는 두개의 정수가 필요합니다. 그렇다면 하나의 정수만 받고, 나머지는 계산이 필요한 시점에 받으면 안될까요?</p>

<pre><code class="haskell">Int -&gt; (Int -&gt; Int)  
</code></pre>

<p>바꿔 말해서, 인자 하나를 받아서 계산을 일정부분 해 내고, 나머지는 <strong>인자를 하나 더 받아 계산을 마무리 해 돌려주는 함수</strong> 를 리턴해도 괜찮지 않을까요? 나머지 계산은 그 함수에서 할거니까, 결국 인자 2개로 계산을 해 내는 건 똑같으니까요.</p>

<p>이게 <em>Currying</em> 의 기본 개념입니다. 다시 말해서 다음의 두 타입은 같은 일을 한다는 거죠.</p>

<pre><code class="haskell">(Int, Int) -&gt; (Int)

-- same as
Int -&gt; (Int -&gt; Int)  
</code></pre>

<p>이게 언제 유용할까요? 인자를 부분적으로 채운 함수가 필요할 때를 생각 해 봅시다. </p>

<pre><code class="haskell">add :: Int -&gt; (Int -&gt; Int)  
add x y = (x + y)

add3 = add 3  
add3 4 -- 7  
</code></pre>

<p>3을 미리 더 해놓은 <code>add3</code> 이란걸 만들어서 써먹었습니다. 이렇게 <em>Currying</em> 을 활용할 수 있죠. <code>:t</code> 를 입력하면 <code>Int -&gt; Int</code> 를 확인할 수 있습니다. <code>:take 5</code> 도 <em>curried function</em> 이죠.</p>

<p><strong>결국 <em>Currying</em> 은 <code>n</code> 개의 인자를 가진 함수를 <code>n-1</code> 개의 부분적으로 계산된 함수로 바꿀 때</strong> 쓸 수 있습니다. 단지 <code>n</code> 개의 파라미터만 가진 <strong>하나의 함수</strong> 보다 <strong>여러 개의 부분적인 함수</strong>를 만들어 놓으면 재활용 할 수 있으므로 훨씬 좋죠. 인자에 함수를 넘길 수 있는 함수형 언어에서는 함수를 재활용 할 수 있다는 건 정말 좋은 일입니다..</p>

<p>하스켈에서는 <em>Currying</em> 을 아주 중요하게 여깁니다. 얼마나 중요하게 생각하는지, 함수 타입에 괄호가 없으면 자동으로 <em>curried function</em> 이 되게끔 해 놓았지요. 아래의 두 함수는 같습니다.</p>

<pre><code class="haskell">add :: Int -&gt; (Int -&gt; Int)

-- same as

add :: Int -&gt; Int -&gt; Int  
</code></pre>

<p>다시 말해 함수의 타입은 <em>right-associative (우측 결합)</em> 입니다. 반대로 함수의 호출은 <em>left-associative (좌측 결합)</em> 이죠.</p>

<pre><code class="haskell">add 3 4

-- same as

(add 3) 4
</code></pre>

<p>그래서 그냥 함수 타입에 괄호를 안쓰시고 인자의 갯수가 <code>n</code> 개라면 이 함수를 호출 할 때 <code>n-1</code> 개의 <em>curried function</em> 을 호출하신다고 생각하면 됩니다.</p>

<h3 id="generics">Generics</h3>

<p><em>polymorphic</em> 은 <em>of many form (다양한 형태의)</em> 라는 뜻입니다. 프로그래밍에선 주로 다양한 타입을 이야기 할때 사용한 용어인데요, <code>length</code> 같은 경우 타입을 보면 이렇습니다.</p>

<pre><code class="haskell">length :: [a] -&gt; Int  
</code></pre>

<p><code>a</code> 라는 타입은 없으므로 여기선 <strong>아무 타입이나</strong> 와도 된다는 뜻입니다. 다시 말해 <code>length</code> 는 <em>polymorphic function</em> 입니다. 다양한 타입을 취할 수 있는 함수죠. <code>length</code> 는 사실 무슨 타입이 오든 관심이 없습니다. 갯수를 세는데만 정신이 팔려있는 함수지요.</p>

<p>여기서 <code>a</code>는 <em>type variable</em> 이라 부릅니다. <code>a</code> 가 아니라 <code>b</code>, <code>c</code> 등 소문자이기만 하면 됩니다.</p>

<p>참고로 프로그래밍에서 <em>polymorphism</em> 은 <em>generics</em> 와 <em>sub-typing</em> 의 두 가지 개념을 모두 포함하는 용어입니다. <em>generics</em> 는 <em>type parameterization</em> 을, <em>sub-typing</em> 은 <em>type-hierarchy</em> 를 의미하지요.</p>

<p>이제 몇 가지 <em>polymorphic function</em> 을 살펴봅시다.</p>

<pre><code class="haskell">*Main&gt; :t fst
fst :: (a, b) -&gt; a  
*Main&gt; :t head
head :: [a] -&gt; a  
*Main&gt; :t take
take :: Int -&gt; [a] -&gt; [a]  
*Main&gt; :t zip
zip :: [a] -&gt; [b] -&gt; [(a, b)]

*Main&gt; [1, 2, 3] `zip` ['a', 'b', 'c']
[(1,'a'),(2,'b'),(3,'c')]
</code></pre>

<p><em>polymorphic function</em> 이 특정 타입에 대해 제한 되었는 것을 하스켈에서는 <em>overloaded</em> 되었다고 부릅니다. 다시 말해 특정타입에만 해당 함수를 사용할 수 있다는 거죠. 이게 <em>C++</em> 에서의 <em>오버로딩</em> 과는 좀 의미가 다릅니다. </p>

<blockquote>
  <p>It really means that you're restricting the types of the parameters.</p>
</blockquote>

<p>숫자에 대해서만 사용할 수 있는 <code>sum</code> 을 좀 살펴볼까요?</p>

<pre><code class="haskell">sum :: Num =&gt; [a] -&gt; a  
</code></pre>

<p><code>sum</code> 은 정수나 실수에 대해 모두 사용할 수 있지만 문자열에 대해서는 불가능합니다. 이게 바로 <em>overloaded</em> 된 것이죠. 그 부분이 바로 <code>Num =&gt;</code> 이 의미하는 바입니다.</p>

<p>하스켈은 <em>overloading</em> 에 사용할 수 있는 다양한 타입 클래스가 있습니다. <code>Num</code>, <code>Eq</code>, <code>Ord</code> 등이 그것이죠. <code>ghci</code> 에서 <code>==</code> 를 타입 검사 해볼까요? 아참, <code>==</code> 은 <code>:t (==)</code> 로 검사해야합니다.</p>

<pre><code class="haskell">*Main&gt; :t (&lt;) -- Ordered types
(&lt;) :: Ord a =&gt; a -&gt; a -&gt; Bool
*Main&gt; :t (==) -- Equality types
(==) :: Eq a =&gt; a -&gt; a -&gt; Bool
*Main&gt; :t (+) -- Numeric types
(+) :: Num a =&gt; a -&gt; a -&gt; a
</code></pre>

<p>예를 들어 다음의 <code>palindrome</code> 함수 타입을 잘 보세요.</p>

<pre><code class="haskell">palindrome xs = reverse xs == xs

:t palindrome -- Eq [a] =&gt; [a] -&gt; Bool
</code></pre>

<p>다시 말해서 <code>[a]</code> 가 비교가 가능한 <code>Eq</code> 타입이어야 한다는 뜻입니다.</p>

<h3 id="basicclasses">Basic Classes</h3>

<p><code>Eq</code> 는 해당 클래스가 비교할 수 있음을, <code>Ord</code> 는 순서가 있음을 나타냅니다. 기본 타입인 <code>Bool</code>, <code>Char</code>, <code>String</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code> 와 <code>Tuple</code>, <code>List</code> 는 모두 <code>Ord</code> 와 <code>Eq</code> 클래스의 인스턴스입니다. 참고로 하스켈에서 <em>Not equal</em> 은 <code>/=</code> 입니다.</p>

<p><code>(&gt;)</code>, <code>(&gt;=)</code>, <code>(&lt;)</code>, <code>(&lt;=)</code>, <code>max</code>, <code>min</code> 등이 <code>Ord</code> 클래스에 대해 적용할 수 있는 함수입니다. 그리고 <code>String</code>, <code>Tuple</code>, <code>List</code> 는 <em>사전 편찬 순서 (lexicographically)</em> 를 기준으로 비교됩니다. </p>

<h3 id="showabletype">Showable Type</h3>

<p>다른 언어의 <code>toString</code> 이 그렇듯이, <code>Show</code> 클래스의 인스턴스들은 <code>show</code> 함수를 이용하면 <code>String</code> 형태로 출력됩니다.</p>

<pre><code class="haskell">:t show -- Show a =&gt; a -&gt; String
show False -- "False"  
show [1, 2, 3] -- "[1, 2, 3]"  
</code></pre>

<h3 id="readabletype">Readable Type</h3>

<p><code>Read</code> 타입 인스턴스들은 <code>read</code> 함수를 이용해 <code>String</code> 으로부터 얻어질 수 있습니다. </p>

<pre><code class="haskell">:t read -- Read a =&gt; String -&gt; a

read "False" :: Bool  
read "[1, 2, 3]" :: [Int] -- [1, 2, 3]  
</code></pre>

<h3 id="integralfractionalrational">Integral, Fractional, Rational</h3>

<p>단순히 숫자 클래스로 <code>Num</code> 만 있는건 아니고 정수나, 분수, 유리수 등을 나타내는 다양한 클래스가 있고 여기에 적용할 수 있는 함수가 있고, 불가능한 함수가 있습니다. 예를 들어 <code>mod</code> 나 <code>div</code> 는 <code>Integral</code> 에만 적용 가능합니다. <code>(/)</code> 는 <code>Fractional</code> 에만 적용 가능합니다.</p>

<h3 id="guardedequations">Guarded Equations</h3>

<p><code>if</code> 대신에 더 좀 편하게 사용할 수 있는 <em>guarded equation</em> 이 있습니다. <strong>다른 계산 없이</strong> <code>if</code> 만 바로 사용한다면 다음과 같이 바꿔 쓸 수 있죠.</p>

<pre><code class="haskell">abs n = if n &gt;= 0 then n else -n  
signum n = if n &gt; 0 then 1 else  
             if n &lt; 0 then -1 else 0

-- same as

abs n | n &gt;= 0 = n  
      | otherwise = -n 

signum n | n &gt; 0 = 1  
         | n &lt; 0 = -1
         | otherwise = 0 
</code></pre>

<h3 id="patternmatching">Pattern Matching</h3>

<p><em>Scala</em> 나 <em>C#</em> 과는 다르게 하스켈은 패턴매칭을 바로 이용합니다. <code>case</code> 나 <code>switch</code> 없이요! 예를 들어</p>

<pre><code class="haskell">not :: Bool -&gt; Bool  
not False = True  
not True = False  
</code></pre>

<p>패턴 매칭은 위에서 부터 순서대로 적용됩니다. 예를 들어 <code>not False = False</code> 가 코드에 제일 위에 있다면 항상 <code>False</code> 만 돌려줄거에요. 우울한 일이 될겁니다.</p>

<p>이제 2개의 피 연산자를 갖는 연산자 <code>&amp;&amp;</code> 를 패턴매칭을 이용해 만들어 볼까요? 좌 우에 피 연산자를 가지는 함수를 만들기 위해서는 <code>(*)</code> 처럼 괄호로 감싸면 됩니다. </p>

<pre><code class="haskell">(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool

True &amp;&amp; True = True  
False &amp;&amp; False = False  
False &amp;&amp; True = False  
True &amp;&amp; False = False  
</code></pre>

<p>더 간단히는 <code>_</code> 를 이용할 수 있죠. <em>wild card pattern</em> 이라고 부릅니다. <code>_</code> 는 <em>아무거나 (Anything)</em> 이라고 생각하시면 됩니다. 스칼라를 배우셨다면 익숙하신 기호죠! $</p>

<pre><code class="haskell">(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool
True &amp;&amp; True = True  
_ &amp;&amp; _ = False  
</code></pre>

<p>그러나 위 정의보다 더 효율적인 <code>(&amp;&amp;)</code> 를 만드는 방법이 있습니다. 위 패턴매칭에서 둘 다 <code>True</code> 일 경우 우측 <code>True</code> 는 사실 평가할 필요가 없습니다. 매칭 시켜봤자 어차피 <code>True</code> 니까요.</p>

<pre><code class="haskell">True &amp;&amp; b = b  
False &amp;&amp; _ = False  
</code></pre>

<p>이 경우 패턴매칭에서 <code>b</code> 는 변수입니다. 왼쪽 피연산자가 <code>False</code> 일 경우도 우측 피 연산자 <code>_</code> 를 <em>evaluation (평가)</em> 하지 않고 바로 <code>False</code> 를 줍니다. 다시 말해 더 효율적이란 뜻이지요.</p>

<p>아참 그리고 패턴매칭에서 동일한 변수를 두번 사용할수 없습니다. <code>b &amp;&amp; b = b</code> 는 에러를 내뿜습니다. 주의하세요</p>

<h3 id="listpatterns">List Patterns</h3>

<p>함수형 언어에서는 리스트가 주된 자료구조 이기 때문에 패턴매칭에 리스트를 사용할 수 있다면 프로그래머의 삶을 편하게 만들 수 있습니다. </p>

<p><code>:</code> 는 <em>Cons</em> 라 부르는 연산자인데요, <code>[1, 2, 3, 4]</code> 는 <code>1 : 2 : 3 : 4 : []</code> 더 정확히는 <code>1 : (2 : ( 3: (4 : []))))</code> 입니다. 즉 원소와 뒤에오는 리스트를 연결해주는 것이죠. 요로코롬 패턴매칭에 활용할 수 있습니다.</p>

<pre><code class="haskell">head (x : _) = x  
tail (_ : xs) = xs  
</code></pre>

<p><code>head</code> 나 <code>tail</code> 모두 패턴이 <em>비어있지 않은 리스트</em> 이므로 빈 리스트가 인자로 올때는 에러가 납니다. 그리고, 함수 적용의 우선순위가 다른 연산자들 보다 높기 때문에 <code>head x:_</code> 는 <code>(head x) : _</code> 가 되어 에러가 납니다. 괄호를 잊지마세요.</p>

<h3 id="lambdaexpression">Lambda Expression</h3>

<p><em>lambda (람다)</em> 는 이제 유명합니다. <em>Java 8</em> 에도 추가되었으니 인기있는 대부분의 언어는 람다를 가지고 있죠. 익명함수라고 불리기도 하는데, 하스켈에선 <code>\</code> 를 이용해 람다를 표시합니다. 이를테면, <code>\x -&gt; x + 1</code> 처럼요. 람다가 왜 유용하나면</p>

<p>(1) <em>currying</em> 을 이용해 정의된 함수를 좀더 의미있게 표현할 수 있습니다.</p>

<blockquote>
  <p>Lambda expressions can be used to give a formal meaning to functions defined using <em>currying</em></p>
</blockquote>

<p>이를테면 다음의 두 함수는 동일합니다. 아래 람다를 이용해 정의한 식이 함수를 리턴하는 함수라는 의미가 더 강하죠.</p>

<pre><code class="haskell">add x y = x + y

-- same as

add = \x -&gt; (\y -&gt; x + y)

const :: a -&gt; b -&gt; a  
const x _ = x

-- same as

const :: a -&gt; (b -&gt; a)  
const x  
</code></pre>

<p>(2) 람다를 이용하면 컴퓨터 과학의 가장 큰 난제중 하나인 <em>naming (명명)</em> 을 피할 수 있습니다!</p>

<pre><code class="haskell">odds n = map f [0..n]  
          where
        f x = x `mod` 2 /= 0

odds1 n = map (\x -&gt; x `mod` 2 /= 0) [0..n]  
</code></pre>

<h3 id="sections">Sections</h3>

<p><em>in-fix operator</em> 는 괄호를 더해 맨 앞으로 끌어올 수 있습니다.</p>

<blockquote>
  <p>An operator written between its two arguments can be converted int a curried function written before its two arguments by using parentheses.</p>
</blockquote>

<pre><code class="haskell">1 + 2 -- 3

-- same as

(+) 1 2 -- 3
</code></pre>

<p>이렇게 연산자를 앞으로 옮길 수 있게 되면 피 연산자 하나와 괄호를 엮을 수 있습니다. <code>(x+)</code> 또는 <code>(+x)</code> 처럼요. 이렇게 피연산와 연산자가 괄호로 묶인 것을 <em>section</em> 이라 부릅니다. <code>x + y</code> 를 이용하면 두개의 섹션을 만들 수 있습니다. <code>(x+)</code> 와 <code>(+y)</code> 입니다.</p>

<p><em>section (섹션)</em> 은 언제 유용할까요? 우리는 섹션을 이용하면 람다를 만들어 주는 대신에 좀 더 의미있는 <em>partiall applied function (부분 함수)</em> 를 만들 수 있습니다.</p>

<p>이를테면 <code>double (k (/2))</code> 처럼요</p>

<p>이외에도 섹션은 연산자의 타입을 기술하거나 <code>(&amp;&amp;) ::</code>, 연산자가 다른 함수의 인자로 들어갈때 필요합니다.</p>

<h3 id="references">References</h3>

<p>(1) <em>Programming Haskell</em></p>]]></description><link>http://1ambda.github.io/haskell-intro1/</link><guid isPermaLink="false">f011324c-e0cc-44ef-97ae-7aa23d60adc6</guid><category><![CDATA[programming language]]></category><category><![CDATA[functional programming]]></category><category><![CDATA[edx]]></category><category><![CDATA[haskell]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 27 Oct 2014 09:18:37 GMT</pubDate></item><item><title><![CDATA[Functional Programming in Scala, Chapter 6]]></title><description><![CDATA[<p>지난 시간에는 <em>referential transparency (참조투명성)</em> 과 함수형 언어에서의 귀납법인 <em>structural induction</em> 에 대해서 배우고, 몇 개의 예제를 증명했었다. </p>

<p>이번 시간에는 스칼라의 컬렉션인 <code>Seq</code>, <code>Set</code>, <code>Map</code> 을 알아보고 마지막 챕터에서는 여기에 <em>higher-order function</em> 을 더해 미친듯한 표현력을 가진 코드를 작성해 본다. <del>one-liner 의 절정을 보여주시는 교수님</del></p>

<p>(번역이 서툴러 어중간한 의역을 하느니 단어를 그대로 사용하고 필요할 경우 원문을 첨부한다)</p>

<h3 id="othercollections">Other Collections</h3>

<h4 id="vector">Vector</h4>

<p><code>List</code> 는 처음 원소는 <code>O(1)</code> 로 빠르게 접근하지만, 중간이나 마지막 원소에 대해서는 조금 느린편이다. 만약에 중간이나 마지막 원소에 대한 탐색을 빠르게 하고싶다면 다른 <em>sequence implementation</em> 인 <code>Vector</code> 를 사용하면 된다. <code>Vector</code> 는 다른 원소들에 대한 접근이 <em>evenly balanced</em> 하다. </p>

<blockquote>
  <p>This one has more evenly balanced access pattern then <code>List</code>.</p>
</blockquote>

<p><code>Vector</code> 는 <code>2^5 = 32</code> 개의 원소를 가진 리스트의 트리로 구현된다. 따라서 처음 단계에서는 <code>2^5</code> 개를 저장할 수 있고, 그 다음 단계에서는 <code>2^5 * 2^5 = 2^10</code>, 그 다음 단계에서는 <code>2^15</code> 를 저장할 수 있다. <code>2^5</code> 의 배수만큼 증가하는 것이다. <em>binary tree</em> 에서 자식의 갯수가 <code>2</code> 개가 아니라 <code>32</code> 개라고 생각하면 된다.</p>

<p>이런 이유로, 원소를 탐색하는데 걸리는 시간은 <code>log_32 (N)</code> (<em>32 based-log</em>) 라 보면 된다. <em>random access</em> 에 대해서는 <code>List</code> 보다 훨씬 낫다.</p>

<p><code>Vector</code> 의 또 다른 장점은 <code>map</code>, <code>for</code> 같은 <em>bulk operator</em> 에 대해서 빠른 연산이 가능하다는 것이다. 이것은 원소들이 32개씩 뭉쳐있기 때문에 <em>single cache line</em> 에 있을 확률이 높아진다. 리스트의 경우에는 콘셀이 같은 <em>cache line</em> 에 있으리라는 보장이 없기 때문에 <code>Vector</code> 보다 <em>locality</em> 가 떨어진다.</p>

<p>그럼 <code>List</code> 가 필요없을까? 그렇지 않다. <code>head</code>, <code>tail</code> 과 같은 연산을 할때 빠르다. 깊이가 깊은 <code>Vector</code> 구조에서, <code>head</code> 나 <code>tail</code> 의 경우 몇 번의 연산이 필요한지 생각해보면 쉽게 이해할 수 있다.</p>

<p>(1) <code>map</code>, <code>for</code> 과 같은 <em>bulk operation</em> 은 <code>Vector</code> 가 <br />
(2) <code>tail</code>, <code>head</code> 는 <code>List</code> 가 더 빠르다.  </p>

<p><code>Vector</code> 는 대부분의 <code>List</code> 연산을 사용할 수 있는데 예외가 하나 있다. 바로 <code>::</code> 콘싱은 <code>List</code> 를 위한 연산이기 때문이다.</p>

<p>따라서 <code>Vector</code> 에서는 원소 추가나, 패턴 매칭을 위해 <code>x +: xs</code>, <code>x :+ x</code> 를 사용하면 된다.</p>

<p><code>Vector</code> 는 <code>List</code> 처럼 <em>immutable</em> 이기 때문에 원소를 추가하면 기존의 데이터는 변경되지 않는다. 따라서 가장 깊은 깊이에 새로운 <code>Vector</code> 를 추가하고 그 벡터를 가리키는 상위 벡터, ..., 루트 벡터까지 만드는 비용은 <code>log32(N)</code> 이 된다. 물론 이건 <em>object creation</em> 비용이다.</p>

<h4 id="sequence">Sequence</h4>

<p><code>Vector</code>, <code>List</code>, <code>Range</code> 는 <code>Seq</code> 의 <em>sub-type</em> 다. <code>Seq</code> 이외에도 <code>Set</code>, <code>Map</code> 등이 있으며 <code>Seq, Set, Map</code> 은 <code>Iterable</code> 의 <em>sub-type</em> 이다. <em>hierarchy</em> 를 살펴보면,</p>

<p><a href='http://docs.scala-lang.org/resources/images/collections.png' > <br />
<img src='http://docs.scala-lang.org/resources/images/collections.png'  align="center" /></a>  </p>

<p align="center">(<a href='http://docs.scala-lang.org/' >http://docs.scala-lang.org</a>)</p>

<p><a href='http://docs.scala-lang.org/resources/images/collections.immutable.png' > <br />
<img src='http://docs.scala-lang.org/resources/images/collections.immutable.png'   align="center" /> <br />
</a>  </p>

<p align="center">(<a href='http://docs.scala-lang.org/' >http://docs.scala-lang.org</a>)</p>

<p><code>Array</code> 와 <code>String</code> 은 점선으로 연결된 걸 볼 수 있는데 이건 두 클래스가 <code>Java</code> 에서 왔기 때문이다. 스칼라 클래스는 아니지만 스칼라의 <code>Seq</code> 로 볼 수 있다. (<em>View</em>) 따라서 다음과 같은 코드는 정상 동작한다.</p>

<pre><code class="scala">"Hello World" filter { c =&gt; c.isUpper }  
</code></pre>

<h4 id="range">Range</h4>

<p>다른 <code>Seq</code> 구현체로는 <code>Range</code> 가 있다. <code>Range</code> 는 <em>evenly spaced intergers</em> 를 나타낸다. </p>

<pre><code class="scala">val r: Range = 1 until 5 // Range(1, 2, 3, 4)  
val s: Range = 1 to 5 // Range(1, 2, 3, 4)  
1 to 10 by 3  
6 to 1 by -2  
</code></pre>

<p>그렇기에 <code>Range</code> 는 <em>upper bound, lower bound, step value</em> 를 클래스의 멤버로 가지고 있다.</p>

<h4 id="sequenceoperations">Sequence Operations</h4>

<p><code>Seq</code> 에 대해서 <code>exists</code>, <code>forall</code>, <code>zip</code>, <code>unzip</code>, <code>flatMap</code>, <code>sum</code>, <code>product</code>, <code>max</code> 등을 사용할 수 있다.</p>

<p><code>zip</code> 은 두개의 <code>Seq</code> 의 각 원소를 <code>pair</code> 로 묶는거고, <code>unzip</code> 은 각 <code>pair</code> 를 푼다.</p>

<pre><code class="scala">scala&gt; a  
res13: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5)

scala&gt; b  
res14: List[Char] = List(h, e, l, l, o)

scala&gt; a zip b  
res15: scala.collection.immutable.IndexedSeq[(Int, Char)] = Vector((1,h), (2,e), (3,l), (4,l), (5,o))

scala&gt; a zip b unzip  
res16: (scala.collection.immutable.IndexedSeq[Int], scala.collection.immutable.IndexedSeq[Char]) = (Vector(1, 2, 3, 4, 5),Vector(h, e, l, l, o))  
</code></pre>

<p><br/></p>

<p><code>flatMap</code> 은 각 원소에 <code>map</code> 을 적용한 뒤, 풀어 헤친다. 예를 들어</p>

<pre><code class="scala">scala&gt; "HelloWorld" flatMap { c =&gt; List('.', c) }  
res17: String = .H.e.l.l.o.W.o.r.l.d  
</code></pre>

<p><code>flatMap</code> 은 맵을 두번하면 할 때 자주 쓰인다. 예를 들어  <code>n</code>, <code>m</code> 에 대해 <em>combinator (조합)</em> 을 찾을때 <code>flatMap</code> 을 사용하면 <code>Vector</code> 의 <code>Vector</code> 가 아니라 <code>Vector</code> 만 얻는다.</p>

<pre><code class="scala">1 to m flatMap { x =&gt; 1 to n map { y =&gt; (x, y) } }  
</code></pre>

<p>벡터에 대해 스칼라 곱을 하고 싶다면, <code>zip</code> 을 이용할 수 있다. <code>zip</code> 을 이용하면 두 <code>Seq</code> 의 <code>pair</code> 가 나오므로, 곱한 후 <code>sum</code> 하자.</p>

<pre><code class="scala">(xs zip ys).map(xy =&gt; xy._1 * xy._2).sum
</code></pre>

<p>그런데, <code>zip</code> 해서 나오는 <code>pair</code> 에 패턴매칭을 적용할 수 있으므로</p>

<pre><code class="scala">(xs zip ys).map { case(x, y) =&gt; x * y }.sum
</code></pre>

<p>참고로, <code>x =&gt; match { case ... }</code> 은 <code>{ case ... }</code> 으로 바로 줄여쓸 수 있다. </p>

<h3 id="combinatorialsearchandforexpression">Combinatorial Search and For-Expression</h3>

<h4 id="handlingnestedsequences">Handling Nested Sequences</h4>

<p>보다 작은 두 수 <code>i, j (1 &lt;= j &lt; i &lt; n)</code> 에 대해서 <code>i + j</code> 가 소수인 <code>i, j</code> 를 찾는다고 하자. </p>

<blockquote>
  <p>Given a positive integer <code>n</code>, find all pairs of positive integers <code>i</code> and <code>j</code> with <code>1 &lt;= j &lt; i &lt; n</code> such that <code>i + j</code> is prime</p>
</blockquote>

<p>이렇게 코드를 작성해 볼 수 있다.</p>

<pre><code class="scala">1 until 5 flatMap { i =&gt; 1 until i map { j =&gt; (i, j) }}

res36: scala.collection.immutable.IndexedSeq[(Int, Int)] = Vector((2,1), (3,1), (3,2), (4,1), (4,2), (4,3))  
</code></pre>

<p>재밌는 사실은 <code>Range</code> 를 사용했음에도 <code>Vector</code> 가 나온다는 점이다. 더 정확히는 <code>IndexedSeq</code> 다. 무슨 일이 일어난 걸까? <code>Range</code> 는 <code>Pair</code> 를 원소로 가질 수 없기 때문에 상위 타입인 <code>IndexedSeq</code> 를 가지게 되고, 이것의 구체적 타입인 <code>Vector</code> 가 된다.</p>

<p><a href='http://docs.scala-lang.org/resources/images/collections.immutable.png' > <br />
<img src='http://docs.scala-lang.org/resources/images/collections.immutable.png'   align="center" /> <br />
</a>  </p>

<p align="center">(<a href='http://docs.scala-lang.org/' >http://docs.scala-lang.org</a>)</p>

<p><code>flatMap</code> 을 안쓰면 <code>Vector</code> 의 <code>Vector</code> 가 나오는데, 여기에 <code>foldRight Seq[Int]() (_ ++ _)</code> 을 사용하거나 아니면 <code>flatten</code> 을 사용할 수도 있다.</p>

<pre><code class="scala">(1 until 5 { i =&gt; 1 until i map { j =&gt; (i, j) }}).flatten
</code></pre>

<p>결국 <code>flatMap</code> 은 <code>map</code> 후 <code>flatten</code> 을 적용한 결과를 돌려줌을 알 수 있다. 이제 여기에 <code>filter</code> 를 적용하면 처음에 주어졌던 문제를 해결할 수 있다.</p>

<pre><code class="scala">    1 until n flatMap { i =&gt; 1 until i map {j =&gt; (i, j)} } filter { case (i, j) =&gt; isPrime(i + j)}
</code></pre>

<h4 id="forexpression">For-Expression</h4>

<p><code>map</code> 과 같은 <em>higher-order function</em> 은 <em>expressive</em> 한데 읽기가 좀 힘들때가 있다. 스칼라에서는 이를 위해 <code>for</code> 을 제공한다. 다음의 두 문자을 보자. 완전히 동일하다.</p>

<pre><code class="scala">case class Person(name: String, age: Int)

for (p &lt;- persons if p.age &gt; 20) yield p.name  
persons filter (p =&gt; p.age &gt; 20) map (p =&gt; p.name)  
</code></pre>

<p><code>for</code> 는 <em>imperative language</em> 의 그것과 비슷하긴 한데, 스칼라의 <code>for</code> 은 무언갈 변경하지 않고 새로운 <code>List</code> 를 <code>yield</code> 를 통해 생성한다.</p>

<p><code>for (s) yield e</code> 문법을 좀 자세히 살펴보자.</p>

<blockquote>
  <p>where <code>s</code> is a sequence of <em>generators</em> and <em>filters</em>, and <code>e</code> is an expression whose value is returned by an iteration</p>
</blockquote>

<p><em>generator</em> 는 <code>p &lt;- e</code> 형태의 <em>form</em> 인데 <code>p</code> 는 <em>pattern</em> 이고 <code>e</code> 는 <em>value</em> 로 <em>collection</em> 을 가진 <em>expression</em> 이다.</p>

<p><em>filter</em> 는 <code>Boolean</code> <em>expression</em> 을 가지는 <em>form</em> 이다.</p>

<p><code>for</code> 루프 여러개 중첩하는 것처럼 <em>generator</em> 가 여러개 일 수 있는데, 이 경우 마지막에 오는 <em>generator</em> 가 여러번 돈다. </p>

<blockquote>
  <p>If there are several generators in the sequence, the last generators vary faster than the first.</p>
</blockquote>

<p>그리고 <code>( s )</code> 대신에 <code>{ s }</code> 를 사용할 수도 있는데, 이러면 세미콜론 없이 <em>filter</em> 와 <em>generator</em> 를 여러줄에 걸쳐서 작성할 수 있다.</p>

<p>이제 처음에 나왔던 문제를 <code>for</code> 로 작성해 보자.</p>

<pre><code class="scala">for {  
  i &lt;- 1 until n
  j &lt;- 1 until i
  if isPrime(i + j)
} yield (i, j)
</code></pre>

<p>읽기도 쉬워졌다. <del>flatMap 따위</del> </p>

<p>이제 아까 나왔던 벡터간 스칼라 곱을 하는 함수를 다시 작성해 보면</p>

<pre><code class="scala">def scalaProduct(xs: List[Double], ys: List[Double] =  
    (for ((x, y) &lt;- xs zip ys) yield (x * y)).sum
</code></pre>

<p>해보면 알겠지만 <code>for { x &lt;- xs; y &lt;- ys } yield x * y sum</code> 은 안된다. 루프가 중첩되기 때문이다.</p>

<h3 id="combinatorialsearchexample">Combinatorial Search Example</h3>

<p>자 이제 <code>Seq</code> 말고 <code>Set</code> 에 대해서 알아보자. <code>Seq</code> 의 대부분의 연산도 사용할 수 있고, 비슷비슷허다. <code>Seq</code> 와 <code>Set</code> 은 <code>Iterable</code> 의 <em>sub-type</em> 이므로 <code>Iterable</code> 스칼라독을 보면 어떤 연산을 사용할 수 있는지 확인 할 수 있다.</p>

<p><code>Seq</code> 와의 차이점은 다음과 같다.</p>

<p>(1) <code>Set</code> 은 순서가 없다. <br />
(2) <code>Set</code> 은 중복된 원소를 가질 수 없다. <br />
(3) <code>contain</code> 이 <em>fundamental operation</em> 이다.  </p>

<pre><code class="scala">val a = 1 to 4 toSet

scala&gt; a  
res53: scala.collection.immutable.Set[Int] = Set(1, 2, 3, 4)

scala&gt; a map (_ / 2)  
res54: scala.collection.immutable.Set[Int] = Set(0, 1, 2)  
</code></pre>

<h4 id="nqueensproblem">N-Queens Problem</h4>

<p>이제 <code>Set</code> 을 이용해 좀 문제를 풀어보자.</p>

<blockquote>
  <p>The n-queens problem is to place <code>n</code> queens on a chess board so that no queen is threatened by another <br/></p>
  
  <p>In other words, there can't be two queens in the same row, column, or diagonal</p>
</blockquote>

<p>모든 조합을 뽑아내고, 열을 <code>List</code> 로 표현하고, 그 순서를 행이라 한 뒤 모든 조합을 뽑아내 <code>Set</code> 에 넣으면 자동으로 중복된 결과가 제거된다. 로직은 다음과 같다.</p>

<p>(1) 내게 <code>placeQueens</code> 라는 1 개의 퀸을 위치시킬 수 있는 함수가 있다. <br />
(2) <code>n = 1, 2, ... , n</code> 으로 <code>placeQueens</code> 를 재귀적으로 호출해 가며 이전 단계에서 얻은 퀸들을 이용하여 하나의 퀸을 새롭게 배치한다. <br />
(3) 각 단계에서는 새 퀸을 배치할 수 있는지 없는지 검사할 <code>isSafe</code> 함수가 필요하다.  </p>

<p>이게 <em>Recursion</em> 에서 문제를 풀 때 기본적으로 필요한 생각인 것 같다. <strong>문제를 작게 잘라 매번 <code>1/n</code> 씩 해결할 수 있다면</strong> 이라 가정 한 뒤 <code>1/n</code> 문제를 풀기 위한 함수와 <code>1/n</code> 문제의 종료조건을 정의하는 것. 우리의 경우엔 그 함수가 <code>isSafe</code> 였다.</p>

<pre><code class="scala">  def nQueens(n: Int): Set[List[Int]] = {

    def isSafe(col: Int, queens: List[Int]): Boolean = {
      val row = queens.length // where new queen will be placed
      val queensWithRow = (row - 1 to 0 by -1) zip queens
      queensWithRow forall {
        case (r, c) =&gt; col != c &amp;&amp; math.abs(col - c) != row - r
      }
    }

    def placeQueens(k: Int): Set[List[Int]] =
      if (k == 0) Set(List())
      else
        for {
          queens &lt;- placeQueens(k - 1)
          col &lt;- 0 until n
          if isSafe(col, queens)
        } yield col :: queens

    placeQueens(n)
  }
</code></pre>

<p><em>diagonal</em> 을 어떻게 검사할까가 고민이 될 수 있겠는데, 사실 생각해보면 쉽다. 컬럼의 차이와 행의 차이가 같으면 <em>diagonal</em> 인 것.</p>

<p>여기에 출력하기 위한 함수를 요로코롬 만들고 출력하면</p>

<pre><code class="scala">  def showQueens(queens: List[Int]) = {
    val lines =
      for {
        col &lt;- queens.reverse
      } yield Vector.fill(queens.length)("[ ]").updated(col, "[*]").mkString

    "\n\n" + (lines.mkString("\n"))
  }


[ ][ ][*][ ]
[*][ ][ ][ ]
[ ][ ][ ][*]
[ ][*][ ][ ],

[ ][*][ ][ ]
[ ][ ][ ][*]
[*][ ][ ][ ]
[ ][ ][*][ ]
</code></pre>

<p><code>nQueens(8) take 3 map show</code> 처럼 응용도 가능하다.</p>

<h3 id="querieswithfor">Queries with For</h3>

<p>지난 시간에 배운 <code>for</code> 는 <code>SQL</code> 과 비슷한데 좀 더 자세히 살펴보자. 다음과 같은 <em>case class</em> 가 있다고 하자.</p>

<pre><code class="scala">case class Book(title: String, authors: List[String])  
</code></pre>

<p>이제 다음과 같은 코드를 이용해 쿼리처럼 질의할 수 있다.</p>

<pre><code class="scala">for {  
  b &lt;- books
  a &lt;- b.authros
  if a startWith "Bird")
} yield b.title

for {  
  b &lt;- books
  if b.title indexOf "Programming" &gt;= 0
} yield b.title

for {  
  b1 &lt;- books
  b2 &lt;- books
  if b1 != b2
  a1 &lt;- b1.authors
  a2 &lt;- b2.authors
  if a1 == a2
} yield a1
</code></pre>

<p>세번째 <code>for</code> 문은 약간 문제가 있는데 내용이 똑같고 순서만 다른 <code>List</code> 를 만들 수 있다 따라서 중복을 피하기 위해 <code>&lt;</code> 를 비교로 사용하자.</p>

<pre><code class="scala">for {  
  b1 &lt;- books
  b2 &lt;- books
  if b1.title &lt; b2.title
  a1 &lt;- b1.authors
  a2 &lt;- b2.authors
  if a1 == a2
} yield a1
</code></pre>

<p>근데 만약에 같은 작가가 3개의 책을 출판했다면? <code>title</code> 이 <code>a &lt; b &lt; c</code> 와 같은 순서를 가지므로 <code>(a, b), (a, c), (b, c)</code> 처럼 비교되어 3번 출력된다. </p>

<p>중복을 제거하기 위해 <code>distint</code> 를 사용할 수 있다. 더 좋은 방법은 <code>Set</code> 을 사용하면 된다.</p>

<h3 id="translationoffor">Translation of For</h3>

<p><code>for</code> 을 이용하면 <code>map, flatMap, filter</code> 를 쉽게 구현할 수 있는데</p>

<pre><code class="scala">def mapFun[T, U](xs: List[T], f: T =&gt; U): List[U] =  
  for (x &lt;- xs) yield f(x)

def flatMap[T, U](xs: List[T], f: T =&gt; Iterable[U]): List[U] =  
  for (x &lt;- xs; y &lt;- f(x)) yield y

def filter[T](xs: List[T], p: T =&gt; Boolean): List[T] =  
  for (x &lt;- xs; if (p(x)) yield x  
</code></pre>

<p>사실 스칼라 컴파일러는 <code>for</code> 을 <code>map</code>, <code>flatMap</code>, <em>lazy variant of <code>filter</code></em> 로 바꿔치기한다.</p>

<blockquote>
  <p>Scala compiler expresses <code>for</code> expressions in terms of <code>map</code>, <code>flatMap</code> and a <em>lazy variant of <code>filter</code></em></p>
</blockquote>

<p>예를 들어 <code>for (x &lt;- e1) yield e2</code> 는 <code>e1.map(x =&gt; e2)</code> 로 바꾼다</p>

<pre><code class="scala">for (x &lt;- e1 if f; s) yield e2  
</code></pre>

<p><code>f</code> 가 <em>filter</em> 고 <code>s</code> 가 <em>sequence of generators and filters</em> 라면 다음과 같이 번역된다.</p>

<pre><code class="scala">for (x &lt;- e1.withFilter(x =&gt; f); s) yield e2  
</code></pre>

<p>여기서 <code>withFilter</code> 는 바로 적용되는 것이 아니라, 뒤 따라오는 <code>map</code> 또는 <code>flatMap</code> 등에 적용된다고 보면 된다. 원문을 첨부하면</p>

<blockquote>
  <p>You can think of <code>withFilter</code> as a variant of <code>filter</code> that does not produce an intermediate list, but instead filters the following <code>map</code> or <code>flatMap</code> function application</p>
</blockquote>

<pre><code class="scala">for (x &lt;- e1; y &lt;- e2; s) yield e3  
</code></pre>

<p>이건 다음처럼 번역된다.</p>

<pre><code class="scala">e1.flatMap(x =&gt; for (y &lt;- e2; s) yield e3)  
</code></pre>

<p>그리고 내부의 <code>for</code> 가 다시 한번 더 번역된다.</p>

<pre><code class="scala">for {  
  i &lt;- 1 until n
  j &lt;- 1 until i
  if isPrime(i + j)
} yield (i, j)
</code></pre>

<p>이것은</p>

<pre><code class="scala">(1 until n) flatMap(i =&gt;
  (1 until i).withFilter(j =&gt; isPrime(i + j))
  .map(j =&gt; (i, j)))
</code></pre>

<p>이제 아까 <em>lazy variant of <code>filter</code></em> 어쩌구 하던 내용을 이해할 수 있는데, 중간에 <code>withFilter</code> 는 <code>1 until i</code> 에 적용 되는것이 아니라 <code>map</code> 이 만들어낸 <em>pair</em> <code>(i, j)</code> 에 대해 적용된다.</p>

<p>다시 말해 <code>for</code> 문에서 <code>if</code> <em>guard</em> 는 나중에 적용되는 <code>withFilter</code> 다.</p>

<pre><code class="scala">for (b &lt;- books; a &lt;- b.authros if a startsWith "Bird") yield b.title  
</code></pre>

<p>요건 이렇게 번역된다.</p>

<pre><code class="scala">b.flatMap(b =&gt; b.authors.withFilter(a =&gt; a.startsWith "Bird").map(x =&gt; x.title)  
</code></pre>

<p><code>for</code> 는 다양한 컬렉션에도 적용할 수 있는데 이는 <code>for</code> 가 <code>map</code>, <code>flatMap</code>, <code>withFilter</code> 이 3개의 함수를 기반으로 만들어졌기 때문이다. 따라서 커스텀 타입에도 이 3개의 함수를 만들면 <code>for</code> 를 사용할 수 있다.</p>

<p>이런 이유로 데이터베이스 클라이언트가 <code>map</code>, <code>flatMap</code>, <code>withFilter</code> 같은 메소드를 정의하면 <code>for</code> 을 이용해 쿼리할 수 있다.</p>

<p>이것이 바로 <em>ScalaQuery</em> 나 <em>Slick</em> 같은 스칼라 데이터베이스 프레임워크가 사용하는 방법이다. <em>LINQ</em> 도 비슷한 개념이다.</p>

<h3 id="maps">Maps</h3>

<p>자 이제 <code>Seq</code>, <code>Set</code> 을 살펴보았으니 <code>Map</code> 을 알아보자. </p>

<p><code>Map</code> 은 <code>Iterable</code> 일뿐만 아니라 <code>Function</code> 이다. 그래서 함수 호출하듯이 <em>Key</em> 를 인자로 주어 호출하면 <em>Value</em> 를 얻을 수 있다. 그러나 없는 <em>Key</em> 에 대해서 호출하면 <code>NoSuchElementException</code> 이 발생한다.</p>

<p>예외 대신에 있는지 없는지 알려면 <code>get</code> 을 이용하면 된다. 없으면 <code>None</code> 있으면 <code>Option[Value]</code> 를 돌려준다.</p>

<h4 id="optiontype">Option Type</h4>

<p><code>Option</code> 은 <em>Trait</em> 인데</p>

<pre><code class="scala">trait Option[+A]  
case class Some[+A](value: A) extend Option[A]  
object None extend Option[Nothing]  
</code></pre>

<p><em>covaraint</em> 기 때문에 <code>Option[Type]</code> 에 <code>None</code> 을 넣을 수 있다. <code>None</code> 은 <code>Option[Nothing]</code> 이므로 모든 <code>Option</code> 의 하위타입이다.  참고로 <code>get</code> 의 결과에 패턴매칭을 이용할 수 있다.</p>

<h4 id="sortedandgroupby">Sorted and GroupBy</h4>

<p><em>SQL Query</em> 처럼 <code>sorted</code> 와 <code>groupBy</code> 를 이용할 수 있다.</p>

<pre><code class="scala">scala&gt; fruit  
res70: List[String] = List(apple, pear, orange, pineapple)

scala&gt; fruit.sorted  
res71: List[String] = List(apple, orange, pear, pineapple)

scala&gt; fruit.sortWith(_.length &lt; _.length)  
res72: List[String] = List(pear, apple, orange, pineapple)

scala&gt; fruit.groupBy(_.head)  
res73: scala.collection.immutable.Map[Char,List[String]] = Map(p -&gt; List(pear, pineapple), a -&gt; List(apple), o -&gt; List(orange))  
</code></pre>

<p><code>groupBy</code> 는 컬렉션을 <em>discriminator</em> 를 이용해 <code>Map</code> 으로 파티셔닝한다.</p>

<p><em>Ploynomials (다항식)</em> 을 <code>Map</code> 을 이용해 표현해 보자. 다항식은 각 차수가 한개씩 있고, 상수도 하나씩 붙어 있으므로 <code>Map</code> 으로 표현하기에 적합하다.</p>

<pre><code class="scala">  class Poly(val terms: Map[Int, Double]) {
    def + (other: Poly): Poly = new Poly(terms ++ other.terms)
    override def toString = {
      (for((exp, coeff) &lt;- terms.toList.sorted.reverse) yield  coeff + "x^" + exp) mkString " + "
    }
  }
</code></pre>

<p>이렇게 만들면 제대로 된 계산이 안된다. 왜냐하면 <code>Map</code> 의 <code>++</code> 오른쪽에 오는 <code>Map</code> 에 똑같은 <em>key</em> 를 가지고 있는 원소가 있으면 덮어 쓰기 때문이다. 다항식에서 차수가 같으면 <em>coefficient (계수)</em> 를 덧셈해야 하는데 덮어씌우면 올바른 계산이 아니다. 따라서 <code>other.terms</code> 에 같은 <em>Key</em> 를 가진 원소가 있나 없나 계산해서 있으면 현재 <code>terms</code> 와 계수를 더한 새로운 <code>pair</code> 를 돌려줘야 한다. (<code>Map</code> 의 원소는 <code>pair</code> 다) </p>

<pre><code class="scala">  class Poly(val terms: Map[Int, Double]) {
    def + (other: Poly): Poly = 
    new Poly(terms ++ (other.terms map adjust))

    def adjust(term: (Int, Double)): (Int, Double) = {

      val (exp, coeff) = term

      terms.get(exp) match {
        case None =&gt; term
        case Some(coeff1) =&gt; (exp, coeff + coeff1)
      }
    }

    override def toString = {
      (for{
        (exp, coeff) &lt;- terms.toList.sorted.reverse
      } yield  coeff + "x^" + exp) mkString " + "
    }
  }
</code></pre>

<h4 id="defaultvalues">Default Values</h4>

<p><code>Map</code> 은 <em>partial function</em> 이기 때문에 없는 <em>Key</em> 에 대해 <code>Map</code> 을 호출하면 예외가 발생한다.</p>

<p><code>Map</code> 에 <code>withDefaultValue</code> 를 적용하면 <em>total function</em> 으로 바꿀 수 있다. <code>Poly</code> 에 적용해 보자.</p>

<pre><code class="scala">  class Poly(val terms0: Map[Int, Double]) {
    val terms = terms0 withDefaultValue 0.0
    def + (other: Poly): Poly = new Poly(terms ++ (other.terms map adjust))
    def adjust(term: (Int, Double)): (Int, Double) = {

      val (exp, coeff) = term
      (exp, coeff + terms(exp))
    }
    override def toString = {
      (for{
        (exp, coeff) &lt;- terms.toList.sorted.reverse)}
      yield coeff + "x^" + exp) mkString " + "
    }
  }
</code></pre>

<p>음. 다 좋은데 생성할 때 <code>Map</code> 을 주는 대신 여러개의 <code>Pair</code> 를 주고 <code>Map</code> 으로 바꾸면 좀 더 나을것 같다. 다음의 생성자를 추가하자.
    def + (other:Poly): Poly = 
    new Poly((other.terms foldLeft terms)(addTerm))
    def addTerm(ts: Map[Int, Double], t: (Int, Double)): Map[Int, Double] = {
      val (exp, coeff) = t
      ts + (exp -> (coeff + terms(exp)))
    }</p>

<pre><code class="scala">def this(arg: (Int, Double)*) = this(arg.toMap)  
</code></pre>

<p>그리고 <code>++</code> 대신 <code>fold</code> 를 이용하면 <code>Map</code> 을 생성하지 않고 바로 기존의 <code>terms</code> 에 원소를 추가하기 때문에 더 효율적이다.</p>

<pre><code class="scala">    def + (other:Poly): Poly = 
    new Poly((other.terms foldLeft terms)(addTerm))
    def addTerm(ts: Map[Int, Double], t: (Int, Double)): Map[Int, Double] = {
      val (exp, coeff) = t
      ts + (exp -&gt; (coeff + terms(exp)))
    }
</code></pre>

<p>아래는 테스트 케이스</p>

<pre><code class="scala">  "(x^2 + 3x) + (-2x + 7)" should "be x^2 + x + 7" in {
    val p1 = new Poly(2-&gt;1, 1-&gt;3)
    val p2 = new Poly(1-&gt;(-2), 0-&gt;7)
    val p3 = new Poly(2-&gt;1, 1-&gt;1, 0-&gt;7)

    assert((p1 + p2).terms == p3.terms)
  }
</code></pre>

<h3 id="puttingthepiecestogether">Putting the Pieces Together</h3>

<p>이번엔 전화번호를 알파벳으로 바꾸는 예제를 통해서 스칼라의 컬렉션과 고차함수가 얼마나 <em>expressive</em> 한지 알아본다.</p>

<p>여기 나온 예제는 7 가지 언어로 이미 실험이 되었는데 스크립트 언어는 대략 100 라인, C 나 C++ 같은 언어는 대략 200-300 라인정도가 나왔다고 한다. (2000년)</p>

<pre><code class="scala">  val mnem = Map(
    '2' -&gt; "ABC",
    '3' -&gt; "DEF",
    '4' -&gt; "GHI",
    '5' -&gt; "JKL",
    '6' -&gt; "MNO",
    '7' -&gt; "PQRS",
    '8' -&gt; "TUV",
    '9' -&gt; "WXYZ")
</code></pre>

<p>이런 맵이 있다고 하자. <code>7225247386</code> 을 인코딩 하면 여러가지 경우가 나오겠지만, 그 중 하나는 <code>SCALA IS FUN</code> 이어야 한다. <del>교수님 센스보소</del></p>

<pre><code class="scala">  val path = "/home/anster/github/coursera-scala/src/main/scala/coursera/chapter6/linux.words"
  val in = Source.fromFile(path)
  // java's iterator doesn't have groupBy
  val words = in.getLines.toList filter { _ forall { _.isLetter }}

  val mnem = Map(
    '2' -&gt; "ABC",
    '3' -&gt; "DEF",
    '4' -&gt; "GHI",
    '5' -&gt; "JKL",
    '6' -&gt; "MNO",
    '7' -&gt; "PQRS",
    '8' -&gt; "TUV",
    '9' -&gt; "WXYZ")

  // A to Z -&gt; 2 to 9
  val charCode = mnem flatMap { case(k, v) =&gt; v map { c =&gt; (c, k) } }
  // or for ((digit, str) &lt;- mnem; ltr &lt;- str) yield ltr -&gt; digit

  // "Java" -&gt; "5282"
  def wordCode(word: String): String = word.toUpperCase map charCode

  // "5282" -&gt; List("Java", "Kava", ...), "1111" -&gt; List()
  val wordsForNum: Map[String, Seq[String]] =
    words groupBy wordCode withDefaultValue Seq()

  // return all ways to encode a number as a list of words
  def encode(number: String): Set[List[String]] =
    if (number.isEmpty) Set(List())
    else {
      (for {
        split &lt;- 1 to number.length
        word &lt;- wordsForNum(number take split)
        rest &lt;- encode(number drop split)
      } yield word :: rest).toSet
    }

  def printEncoded(number: String) = {
    encode(number) map { _ mkString " "} map println
  }

  def translate(number: String): Set[String] = {
    encode(number) map { _ mkString " " }
  }

  translate("7225247386") foreach { println _ }
</code></pre>

<p>군더더기 없이 깔끔하다. <del>스칼라는 넉넉하게 50라인에서 끝납니다요</del></p>

<p><code>encode</code> 가 좀 난해하긴 한데, 경우의 수를 모두 찾아내야 하므로 길이를 모두 짤라 <code>wordForNum</code> 에 넣고 각 길이마다 인코딩을 할 수 있는지 검사한 후 나머지도 <code>encode</code> 함수에 넣어 모든 경우의 수를 찾는다. 주의할 부분은 <code>wordsForNum(number take split)</code> 에서 없는 경우가 나올 수 있으니 <code>withDefaultValue Seq()</code> 로 처리하면 된다. 그리고 <code>1 to number.length</code> 가 <code>Range</code> 이기 때문에 리턴 타입이 <code>IndexedSeq</code> 다. 타입 에러를 해결하기 위해 <code>toSet</code> 을 사용한다. </p>

<h3 id="summary">Summary</h3>

<p>마지막 <em>6.7 Putting the Pieces Toghther</em> 챕터를 보면서 스칼라는 정말 <em>expressive</em> 하다는걸 느낀다. 교수님 말로는 <em>immutable collection</em> 은</p>

<p>(1) <em>easy to use:</em> <strong>few steps to do the job</strong> <br />
(2) <em>concise:</em> <strong>one word replaces a whole loop</strong> <br />
(3) <em>safe:</em> <strong>type checker is really good at catching erros</strong> <br />
(4) <em>fast:</em> <strong>collection ops are tuned, can be parallelized</strong> <br />
(5) <em>universal:</em> <strong>one vocabulary to work on all kinds of collections</strong></p>

<p><del>내 컴퓨터에서 돌아가는 <em>SBT</em> 를 보면 스칼라가 빠른지는 의문이지만</del></p>

<p>그리고 항상 느끼는 점이지만, <em>Problem</em> = <em>Algorithm</em> + <em>Data Structure</em> 다. 자료구조를 잘 선택하면 알고리즘이 간단해진다. <del>그래서 둘 다 배워야 하는거고 크흑</del>  </p>

<h3 id="references">References</h3>

<p>(1) <a href='http://docs.scala-lang.org/overviews/collections/overview.html' >http://docs.scala-lang.org</a></p>

<p>2014-10-25, <strong>Functional Programming in Scala</strong>, Coursera</p>]]></description><link>http://1ambda.github.io/functional-programming-in-scala-chapter-6/</link><guid isPermaLink="false">d4f41772-52eb-4a9c-a778-d73f962245b5</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[functional programming]]></category><category><![CDATA[collection]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 24 Oct 2014 14:07:21 GMT</pubDate></item><item><title><![CDATA[Machine Learning, Week 4]]></title><description><![CDATA[<p>지난 시간에는 실리콘 밸리의 머신러닝 개발자들이 귀한대접을 받는다는 훈훈한 덕담으로 강의가 끝났다. 이번시간에는 뜬금없이 <em>Neural Network (신경망)</em> 을 건들다가 놀랍게도 그것이 <em>logistic regression</em> 과 연관이 있으며 <code>n</code> 이 매우 클 경우의 <em>classification</em> 문제를 해결할 수 있다는 것을 배운다.</p>

<h3 id="nonlinearhypotheses">Non-Linear Hypotheses</h3>

<p>다음과 같은 트레이닝 셋이 있을때, 두 집단을 <em>classification</em> 하는 <em>hypothesis</em> 를 찾는다고 하자. </p>

<p><img src='http://www.holehouse.org/mlclass/08_Neural_Networks_Representation_files/Image.png'  align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org</a>)</p>

<p><code>x1</code> 과 <code>x2</code> 만으로는 찾을 수 없으니, 더 많은 <em>feature</em>  <code>x1^2, x1x2, x2^2</code> 를 도입한다 하자. 트레이닝 셋에 적합한 가설을 찾을수는 있겠지만, 항상 좋은건 아니다.</p>

<p>(1) 우선 지난 시간에 언급했듯이 <em>Overfitting</em> 이 발생할 수 있고 <br />
(2) <em>feature</em> 수가 <code>n</code> 이라 할때, 모든 <em>quadratic feature</em> 를 도입하면 <em>feature</em> 수가 <code>O(n^2)</code> (<code>n^2/2</code>)만큼 늘어난다. (아래 그림 참조) 다시 말해서 계산 비용이 엄청나게 비싸진다.</p>

<p><img src='http://img.blog.csdn.net/20140507021224421'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/feliciafay' >http://blog.csdn.net/feliciafay</a>)</p>

<p>그리고 <em>feature</em> 수를 줄이기 위해 <code>x1^2, x2^2, x3^2 ...</code> 등 <em>quadratic feature</em> 만을 도입하고 나머지 <em>parameter</em> 를 버리면, <em>hypothesis</em> 가 <em>underfit</em> 할 수 있다.</p>

<p>만약 <em>feature</em> 를 <em>cubic</em> 까지 도입하면 <em>feature</em> 수가 <code>O(n^3)</code> 으로 늘어나 계산시간은 어마어마하게 걸린다. 따라서 차수를 늘려 문제를 해결하려는 방법은 <code>n</code> 이 클때 좋은 방법이 아니다. 게다가 일반적으로 대부분의 문제들은 <code>n</code> 이 큰편이다.</p>

<p>자동차 이미지 인식 문제를 고려해 보자. 이미지는 픽셀이므로, 50 * 50 픽셀로 구성된 경우 <code>n = 2500</code> 이다.</p>

<p><img src='http://img.blog.csdn.net/20140507021231812'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/feliciafay' >http://blog.csdn.net/feliciafay</a>)</p>

<p>이건 그레이스케일의 경우고 만약 RGB 라면 여기에 3을 곱해서 <code>n = 7500</code> 이 된다. <em>quadratic</em> 이면 <code>7500^2 / 2</code>, 대략 3 millions 개의 <em>feature</em> 를 가지게 된다. 이쯤되면 답이 없다. <code>n</code> 이 큰 <em>classification</em> 에 대해 사용할 수 있는 다른 방법은 없을까?</p>

<h3 id="modelrepresentation">Model Representation</h3>

<p>잠깐 눈을 돌려 <em>Neural Networks</em> 에 대해 이야기 해 보자. 다양한 알고리즘을 개발하는 대신  스스로 학습하는 뇌를 모방한 알고리즘을 개발할 수 있다면 진짜 AI 를 구현할 수 있지 않을까? 라는 질문에서 <em>Neural networks</em> 는 출발한다.</p>

<p>뇌를 모방한 알고리즘을 만들려면, 인간의 뇌가 어떻게 작동하는지 알아야한다. 뇌는 <em>Neuron</em> 이라는 단위의 집합으로 구성되었는데, 요로코롬 생겼다.</p>

<p><img src='http://home.agh.edu.pl/' ~vlsi/AI/intro/neuron.png" align="center" />  </p>

<p align="center">(<a href='http://home.agh.edu.pl/' ~vlsi/AI/intro/'>http://home.agh.edu.pl/~vlsi/AI/intro/</a>)</p>  

<p><br/></p>

<p>여기서 <em>Dendrite</em> 라는 부분이 <strong>input</strong> 이고, <em>Axon</em> 이 <strong>output</strong> 이다. 이걸 모델링하면,</p>

<p><img src='http://img.blog.csdn.net/20140507021238515'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/feliciafay' >http://blog.csdn.net/feliciafay</a>)</p>

<p>위 그림에서 좌측에 있는 <code>x1, x2, x3</code> 가 <em>input</em> 이라 보면 되고, <code>h0(x)</code> 는 이전처럼 <code>0^T * x</code> 에 <em>sigmoid function</em> 을 적용한 것이다. 그리고 <em>neural network</em> 에서 <em>parameter</em> 대신 <code>0(theta)</code> 를 <strong>weights</strong> 라 부르기도 한다. <code>x0</code> 은 값이 <code>1</code> 이고, <em>bias unit</em> 이라 부르는데 편의상 그리기도 하고 안그리기도 한다. <del>교수님 뜻대로 하소서</del>
<br/><br/></p>

<p>여기까지는 단일 <em>neuron</em> 을 모델링 한것이고, <em>neural network</em> 는 여러개의 <em>neuron</em> 들이 합쳐진 것이다. 간단히 그려보면, </p>

<p><img src='http://img.blog.csdn.net/20140507021247656'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/feliciafay' >http://blog.csdn.net/feliciafay</a>)</p>

<p>여기서 <em>layer 1</em> 은 <em>input layer</em>, 마지막인 <em>layer 3</em>은 <em>output layer</em> 다. 그리고 가운데 있는 레이어들, 여기서는 <em>layer2</em>, <strong>hidden layer</strong> 라 부른다. 디버깅이 아니라면 <em>hidden layer</em> 에서 산출되는 값들을 관측하려고 할 필요는 없다. <em>hidden layer</em> 는 하나 이상일 수 있다. 실제 계산 과정을 보면</p>

<p><img src='http://img.blog.csdn.net/20140507021254640'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/feliciafay' >http://blog.csdn.net/feliciafay</a>)</p>

<p><code>ai^j</code> 는, <code>j</code> 번째 <em>hidden layer</em> 에서 <code>i</code> 번째 <em>unit</em> 이다. <code>0(theta)^j</code> 는 <em>layer j</em> 와 <em>layer j+1</em> 사이에서 사용되는 <em>weights</em> 다. 이때 <em>hidden layer</em> 의 각 <em>unit</em> 마다 <em>input</em> 을 위한 <em>weight</em> 를 가지고 있다고 하면 위의 그림에서 <code>0</code> 의 <em>dimension</em> 은 <code>3 * 4</code> 다. (<em>bias unit</em> <code>x0</code> 포함)</p>

<blockquote>
  <p>If network has <code>s_j</code> units in layer <code>j</code>, <code>s_j+1</code> units in layer <code>j+1</code>, then <code>0^j</code> will be dimension <code>s_j+1 * (s_j + 1)</code></p>
</blockquote>

<p>이제 <em>output layer</em> 를 잘 보면 이 레이어의 <em>input</em> 은 <code>a^(2)</code> 고, <em>weight</em> 로 <code>0^2</code> 를 가지고 있다. 따라서 <code>h0(x)</code> 는 위의 식처럼 된다.</p>

<h3 id="forwardpropagation">Forward Propagation</h3>

<p>위 그림처럼 <code>x</code> 를 받아, <code>h0(x)</code> 를 계산하는 방법을 <em>forward propagation</em> 이라 부르는데 <em>vectorization</em> 을 이용해서 간단히 해 보자.</p>

<p><img src='http://www.try2go.com/wp-content/uploads/2014/08/forward-propogation.jpg'  align="center" />  </p>

<p align="center">(<a href='http://www.try2go.com/201408/neural-networks-1/' >http://www.try2go.com/201408/neural-networks-1/</a>)</p>

<p><em>sigmoid fucntion</em> <code>g</code> 내부의 수식을 <code>z</code> 라 부르고 <code>a^(1) = x</code> 라 두면, 우측처럼 수식이 심플해진다. <code>z^(2) = 0^(1) * a^(1)</code> 이고, 여기에 <em>sigmoid function</em> 을 적용하면 <code>a^(2)</code> 가 나온다. 여기에 <em>bias unit</em> <code>a_0^(2) = 1</code> 을 더해 <code>a^(2)</code> 를 4차원 벡터로 만들면 다시 <code>z^(3)</code> 를 계산할 수 있다. 
<br/><br/></p>

<p>자, 이제 왜 <em>neural network</em> 를 뜬금없이 공부하다가 <em>forward propagation</em> 의 <em>vectorization</em> 까지 고려했는지를 밝힐 시간이다! 위 그림에서 <code>a^(1)</code> 즉, <em>layer 1</em> 을 가려버리면 아래와 같은데</p>

<p><img src='http://www.try2go.com/wp-content/uploads/2014/08/learn-features.jpg'  align="center" />  </p>

<p align="center">(<a href='http://www.try2go.com/201408/neural-networks-1/' >http://www.try2go.com/201408/neural-networks-1/</a>)</p>

<p>이때 <code>h0(x)</code> 를 계산하는 식을 구해보면, <em>logistic regression</em> 과 똑같다. <del>오오 머신러닝 오오</del> </p>

<p><strong>결국, <em>neural network</em> 가 하는 일은 <em>logistic regression</em> 이다.</strong> 단지  <em>hidden layer</em> 에서 <code>x1, x2, x3</code> 를 적당한 <em>weight</em> 로 훈련시켜 새로운 <em>feature</em> <code>a1^(2),  a2^(2), a3^(2)</code> 를 만들어 내고, 그걸로 <em>logistic regression</em> 을 할 뿐이다. </p>

<p>다시 한번 정리하자면 <em>neural network</em> 는 <em>feature</em> 를 훈련시켜 다른 값을 가진  <em>feature</em> 로 바꾸는 과정을 통해 <em>hypothesis</em> 를 매우 고차의 다항식으로 만들지 않고도 <code>n</code> 이 매우 큰 경우의 <em>classification</em> 을 풀 수 있도록 한다. 항상 같은 개수의 <em>feature</em> 만 나오는건 아니고, 더 줄이거나 좀 더 늘릴 수도 있다. 아래의 그림을 보자.</p>

<p><img src='http://alphaism.files.wordpress.com/2012/11/selection_001.png?w=630'  align="center" />  </p>

<p align="center">(<a href='http://alphaism.wordpress.com/' >http://alphaism.wordpress.com/</a>)</p>

<h3 id="examples">Examples</h3>

<p>먼저 간단히 <em>AND</em> 연산을 <em>neural network</em> 로 구현한다 하자. </p>

<p><img src='http://www.try2go.com/wp-content/uploads/2014/08/and.jpg'  align="center" />  </p>

<p align="center">(<a href='http://www.try2go.com/201408/neural-networks-1/' >http://www.try2go.com/201408/neural-networks-1/</a>)</p>

<p>위 그림처럼 <code>z^(2) = -30 + 20x1 + 20x2</code> 라면, 우측 표 처럼 각각 <code>h0(x)</code> 값이 나오고, <em>sigmoid function</em> 은 <code>4.6</code> 정도일때 <code>y ~= 0.99</code> 이므로 <code>g(+10)</code> 은 거의 <code>1</code>, <code>g(-10)</code> 은 거의 <code>0</code> 이라 볼 수 있다.</p>

<p><em>XNOR</em> 은 <em>AND</em> <em>~ AND ~</em> 그리고 <em>OR</em> 을 조합하면 만들 수 있다. 아래 그림을 보자.</p>

<p><img src='http://www.holehouse.org/mlclass/08_Neural_Networks_Representation_files/Image%20' [17].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org</a>)</p>

<p>결국 <em>neural network</em> 는 각 <em>hidden layer</em> 에서 함수를 이용해 이전 단계의 결과에 어떤 처리를 가해 복잡한 일들을 해낼 수 있는 것이다.</p>

<h3 id="multiclassclassification">Multiclass Classification</h3>

<p>이제 <em>multi-class</em> 를 고려해 보자.</p>

<p><img src='http://www.try2go.com/wp-content/uploads/2014/08/one-vs-all.jpg'  align="center" />  </p>

<p align="center">(<a href='http://www.try2go.com/201408/neural-networks-1/' >http://www.try2go.com/201408/neural-networks-1/</a>)</p>

<p>위 그림처럼 4개의 클래스가 있을 때, <em>output</em> 인 <code>h(x)</code> 를 <code>4 * 1</code> vector 로 만들도록 하고, 각 클래스에 대해서 <code>[1; 0; 0; 0], [0; 1; 0; 0], [0; 0; 1; 0], [0; 0; 0; 1]</code> 이 되도록 훈련시키면 된다. 기본적인 아이디어는 <em>one vs all method</em> 와 같다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://blog.csdn.net/feliciafay/article/details/25171147' >http://blog.csdn.net/feliciafay</a> <br />
(2) <a href='http://www.holehouse.org/mlclass/08_Neural_Networks_Representation.html' >http://www.holehouse.org</a> <br />
(3) <a href='http://home.agh.edu.pl/' ~vlsi/AI/intro/">http://home.agh.edu.pl/~vlsi/AI/intro/</a> <br />
(4) <a href='http://www.try2go.com/201408/neural-networks-1/' >http://www.try2go.com/201408/neural-networks-1/</a> <br />
(5) <a href='http://alphaism.wordpress.com/2012/11/13/neural-network-algorithm/' >http://alphaism.wordpress.com/</a></p>]]></description><link>http://1ambda.github.io/machine-learning-week-4/</link><guid isPermaLink="false">02903e2d-5c8c-4abf-9635-da5747fd9c01</guid><category><![CDATA[coursera]]></category><category><![CDATA[machine lerning]]></category><category><![CDATA[classification]]></category><category><![CDATA[neural network]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 23 Oct 2014 07:11:31 GMT</pubDate></item><item><title><![CDATA[Machine Learning, Week 3]]></title><description><![CDATA[<p>지난 시간엔 <em>Regression</em> 을 해결하기 위해 <em>graident descent</em> 알고리즘을 도입했었다. <em>learning rate</em>, <em>vectorization</em> 등에 대해서 알아 보기도 했고. 이번시간엔 <em>classification</em> 과 <em>regulrzation</em> 에 대해서 배워 본다. </p>

<p>이 수업이 재밌는 이유는 수식을 증명하는 것보다 수식속에 숨겨진 내용들을 직관적으로 이해할 수 있게 설명하기 때문이다. <del>그러나 교수님 과제는 제발 그만</del></p>

<h3 id="classification">Classification</h3>

<p><em>regression</em> 이 <em>continuous value</em> 를 다룬다면 <strong>Classification</strong> 은 <strong>discrete value</strong> 를 다룬다. 따라서 <em>Classification (분류)</em> 의 예는,</p>

<ul>
<li>이메일이 스팸인지 / 아닌지  </li>
<li>온라인 거래가 사기인지 / 아닌지 (Online Transaction: Fraudulent)  </li>
<li>악성 종양인지 / 아닌지  </li>
</ul>

<p><img src='http://i.stack.imgur.com/VVtRW.png'  align="center" />  </p>

<p align="center">(<a href='http://stats.stackexchange.com/' >http://stats.stackexchange.com</a>)</p>

<p>위와 같은 경우, <em>Regression</em> 으로 문제를 풀면 당장은 맞아 보이나, 종양이 이상한 위치에 생겼을 경우 아래와 같이 직선이 크게 변한다.</p>

<p><img src='http://i.stack.imgur.com/nEC4H.png'  align="center" />  </p>

<p align="center">(<a href='http://stats.stackexchange.com/' >http://stats.stackexchange.com</a>)</p>

<p>따라서 이렇게 <em>discrete value</em> 에 대해서는 <em>Regression</em> 보다는 <em>Threshold</em> 에 기반을 두어, <code>h(x)</code> 가 일정 값 이상이면 <code>y=1</code> 로 예측하는 편이 더 정확도가 높아진다. 게다가 <em>regression</em> 은 직선이기 때문에, <code>0 &lt;= y &lt;= 1</code> 인 <code>y</code> 에 대해서 0보다 작거나, 1보다 더 큰 <code>y</code> 를 만들어낼 수 있다.</p>

<p>이런 이유 때문에 <em>Classification</em> 문제에 <em>Regression</em> 을 잘 사용하지 않는다. 그러나 <code>y</code> 의 범위가 <code>0 &lt;= h(x) &lt;= 1</code> 을 가지는 <em>Logistic Regression</em> 도 있다. 이건 <em>Classification</em> 에 사용되기도 한다.</p>

<h3 id="logisticregression">Logistic Regression</h3>

<p>이전에 언급했듯이 <em>classification</em> 에선 예측된 값, 즉 <code>h(x)</code> 값이 0 과 1사이에 있길 바란다. 이를 위해 <em>logistic function</em>, 혹은 <strong>sigmoid function</strong> 이라 불리는 아래 식을 <em>hypothesis</em> <code>h(x)</code> 에 적용하면 아래와 같은 그림이 나온다.</p>

<p><img src='http://www.saedsayad.com/images/ANN_Sigmoid.png'  align="center" />  </p>

<p align="center">(<a href='http://www.saedsayad.com/' >http://www.saedsayad.com</a>)</p>

<p>이 때 <em>sigmoid function</em> 이 적용된 <code>h(x)</code> 는 최대값이 1이므로, 이건 입력값 <code>x</code> 에 대해서 <code>y</code> 가 1이 나올 확률이라 보아도 된다. 따라서</p>

<p><code>h(x) = P(y = 1 | x ; 0)</code></p>

<blockquote>
  <p>Probability that <code>y = 1</code>, given <code>x</code>, parameterized by <code>0(theta)</code></p>
</blockquote>

<p>이 때 <em>sigmoid function</em> 을 보면, X 축이 0보다 큰 점에선 <code>y</code> 값이 0.5 보다 크므로, 이 점 이후부터는 <code>y</code> 를 1 이라 <em>예측 (predict)</em> 하고, 반대로 X 축 값이 0보다 작은 지점에선 <code>y</code> 를 0이라 예측할 수 있다.</p>

<p>그런데 <code>h(x) = g(0^T * x)</code> 이므로, 본래의 <em>hypothesis</em> <code>0^T * x</code> 가 0이 되는 지점을 찾으면 된다.</p>

<p><img src='http://my.csdn.net/uploads/201207/04/1341403634_5914.jpg'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/abcjennifer/' >http://blog.csdn.net/abcjennifer/</a>)</p>

<h3 id="decisionboundary">Decision Boundary</h3>

<p>이제 실제로 문제에 적용해 보자. 다음과 같이 두개의 집단이 있을때, 이 두 집단을 가르는 식을 찾기 위한 <code>h(x) = g(01 + 01x1 + 02x2)</code> 가 있다고 해 보자. </p>

<p><img src='http://my.csdn.net/uploads/201207/05/1341470683_7505.jpg'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/abcjennifer/' >http://blog.csdn.net/abcjennifer/</a>)</p>

<p>이때 <code>0(theta)</code> 를 <code>[-3; 1; 1]</code> 로 잡으면 <code>y</code> 가 <code>1</code> 이 되는 지점은 <code>0^T * x &gt;= 0</code> 인 지점, 즉 <code>-3 + x1 + x2 &gt;= 0</code> 인지점을 찾으면 된다. 이 식을 풀어서 쓰면</p>

<p><code>x1 + x2 =&gt; 3</code> 이므로, 위 그림에서 분홍색 선을 찾을 수 있다. 이 선을 <strong>Decision Boundary</strong> 라 부른다. 그리고 이 <em>Decision Boundary</em> 는 <code>g(z) = 0</code> 즉,  <code>h(x) = 0.5</code> 인 지점이다.</p>

<p><em>Non-linear dicision boundary</em> 는 어떨까?</p>

<p><img src='http://my.csdn.net/uploads/201207/05/1341471338_7289.jpg'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/abcjennifer/' >http://blog.csdn.net/abcjennifer/</a>)</p>

<p>이 경우  <code>x1^2</code>, <code>x2^2</code> 이라는 새로운 <em>feature</em> 를 도입하고, <em>parameter</em> 인 <code>theta</code> 를 <code>[-1; 0; 0; 1; 1;]</code> 로 잡았다. 식을 풀면, 위와 같은 원 형태의 <em>Decision Boundary</em> 가 나온다.</p>

<p><em>feature</em> 만 잘 조합하면, 즉 <em>polynomial</em> 만 잘 만들면 땅콩이나 하트모양 등의 <em>Decision boundary</em> 도 만들 수 있다.</p>

<h3 id="costfunction">Cost Function</h3>

<p>이제 문제는 <code>theta</code> 를 어떻게 고르느냐 하는건데, 식을 좀 다시 살펴보자.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [9].png" align="center" /> <br />
<img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [11].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p><em>Linear regression</em> 에서 사용하는 <em>cost function</em> 에 지금의 <code>h(x)</code>, 즉 <em>sigmoid function</em> 이 적용된 <code>h(x)</code> 를 제곱한 <code>J(0)</code> 는 <em>non-convex</em> 형태가 된다. 따라서 <em>global optimum</em> 보다는 <em>local optimum</em> 을 찾게 된다. </p>

<p>이를 방지하기 위해서, <em>convex</em> 형태의 <em>cost function</em> 을 사용해야 하는데, </p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [12].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>이 <em>cost function</em> 을 사용하면, <code>y = 1</code> 일때 다음과 같은 그래프를 얻게 된다. <code>0 &lt;= h(x) &lt;= 1</code> 임을 참고하자. <code>y = 1</code> 일때, <code>h(x) = 0</code> 으로 가면, <em>cost function</em> 의 값, 즉 <em>cost</em> 자체가 높아지므로, <em>Cost</em> 를 낮추는 반대 방향으로 움직이게 된다. </p>

<p>직관적으로 보면, <code>h(x)</code> 자체는 <code>y = 1</code> 일 확률인데, <code>y = 1</code> 일때, <code>h(x) = 0</code> 이라는 것은 말이 안 되므로 비용이 무한대로 증가하는 것이 말이 된다.  </p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [13].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>반대로 <code>y = 0</code> 일때의 그래프를 보면 <code>h(x) = 0</code> 즉, <code>y = 0</code> 일 확률이 <code>0</code> 으로 갈때 <em>cost</em> 가 감소한다.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [14].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>결국 아래의 새로운 <em>logistric regression cost function</em> 을 이용하면, <code>J(0)</code> 를 <em>convex function</em> 으로 만들 수 있다.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [12].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<h3 id="simplifiedcostfunctionandgradientdescent">Simplified Cost Function and Gradient Descent</h3>

<p>이제 <code>y = 0</code>, <code>y = 1</code> 로 나누어져 있던 <em>cost function</em> 을 좀 더 간단히 표현해 보자.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [15].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>다음과 동일하다. <code>y = 0</code>, <code>y = 1</code> 을 직접 넣어보면 금방 알 수 있다.</p>

<p><code>cost(hθ(x),y) = -y * log(hθ(x)) - (1-y) * log(1 - hθ(x))</code></p>

<p><br/> <br />
자 이제 다시 본론으로 돌아와서, 우리는 처음에 <code>theta</code> 를 찾길 원했고, 그래서 <em>gradient descent</em> 를 쓰려고 했는데, 마침 보니 <code>h(x)</code> 가 <em>sigmoid function</em> 이 적용된 형태라서 <em>non-convex function</em> 이므로, <code>h(x)</code> 를 포함한 <em>cost-function</em> 이 <em>convex function</em> 이 되는 식을 찾아냈다. 이제 그 식을 <em>gradient descent</em> 에 적용하면,</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [16].png" align="center" /></p>

<p>이고, 이제 이걸 <em>batch gradient descent</em> 에 적용하면 아래와 같은데, 여기에 <em>partial derivative</em> 를 적용하면</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [20].png" align="center" /></p>

<p>놀랍게도 <em>linear regression</em> 과 같은 식이 나온다. <del>오오 머신러닝 오오</del></p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [18].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>다만 다른점은 <em>hypothesis</em> 가 <em>sigmoid function</em> 을 적용한 형태라는 것,</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [17].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<h3 id="advancedoptimization">Advanced Optimization</h3>

<p>위에서 보았겠지만, <code>J(0)</code> 의 최소값을 찾기 위해서는 아래 두개의 값을 구해야 한다.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [19].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>이 값들을 이용해서 <em>gradient descent</em> 대신 다음의 알고리즘을 사용할 수 있다.</p>

<p>(1) Conjugate gradient <br />
(2) BFGS <br />
(3) L-BFGS  </p>

<p>이 알고리즘들의 장점은, <em>leanring rate</em> 를 고를 필요가 없고, 대부분 <em>gradient decsent</em> 보다 빠르다. </p>

<p>그러나 더 복잡하고, 라이브러리마다 구현이 다를 수 있으며, 디버깅이 힘들수 있다. 자 이제 <em>advanced optimization</em> 을 이용해 보자.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [21].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>위와 같은 식에 대해서 <em>cost function</em> 을 <code>octave</code> 에서 이렇게 만들 수 있다.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [22].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>  

<p><br/></p>

<p>이제, <code>octave</code> 에서 제공해 주는 <code>fminunc</code> 에 우리가 만든 <code>costFunction</code> 과 초기 <code>theta</code> 값, 그리고 옵션을 집어 넣으면</p>

<pre><code class="matlab">% define the options data structure
options= optimset('GradObj', 'on', 'MaxIter', '100'); 

% set the initial dimensions for theta % initialize the theta values
initialTheta= zeros(2,1); 

% run the algorithm
[optTheta, funtionVal, exitFlag]= fminunc(@costFunction, initialTheta, options); 
</code></pre>

<p><code>optTheta</code> 는 우리 찾길 원했던 <code>theta</code> 값이고, <code>functionVal</code> 은 최종 <em>cost</em> 를 돌려준다. <code>exstFlag</code> 는 알고리즘이 수렴했는지, 아닌지 알려준다.</p>

<p>만약 <em>logistic regression</em> 에 대한 <code>theta</code> 값을 찾고 싶으면, <em>cost function</em> 을 <em>logistic regression</em> 에 맞게 작성하면 된다.</p>

<h3 id="multiclassclassification">Multiclass Classification</h3>

<p>이제 단순히 <code>y = 0 or 1</code>(<em>binary classification</em>) 이 아닌, 다양한 <em>class</em> 가 있는 <em>classification</em> 을 고려해보자, 예를 들면 날씨는 <code>sunny</code>, <code>cloudy</code>, <code>hot</code>, <code>cold</code> 등으로 분류될 수 있다.</p>

<h4 id="onevsallonevsrest">one-vs-all (One-vs-rest)</h4>

<p><em>multi class</em> 를 분류할 수 있는 한가지 방법은, 하나를 정하고, 그 나머지와 분류하는것이다. 이걸 <em>class</em> 갯수만큼 진행하면,</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [23].png" align="center" /> <br />
<img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [24].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>위 그림과 같은 경우, <em>class</em> 가 3개기 때문에 <code>(i = 1, 2, 3)</code> 으로 놓으면 <code>i</code> 마다 각각의 <code>hθ^(i)(x)</code> 값, 즉 예측 값을 얻을 수 있다. 따라서 새로운 무언가가 input 으로 들어왔을때, <code>hθ^(i)(x)</code> 값을 최대로 해주는 <code>i</code> 을 선택하면 분류가 된다. <del>참 쉽죠?</del></p>

<h3 id="overfitting">Overfitting</h3>

<p><strong>Overfitting</strong> 은 너무나 많은 <em>feature</em> 가 있을 때는 <em>cost function</em> 이 트레이닝 셋에 잘 맞아 <code>0</code> 에 수렴 하지만, 새로운 데이터가 들어왔을때는 예측을 잘 하지 못하는 경우를 말한다. 다시 말해 <em>hypothesis</em> 가 너무 고차원의 다항식이어서 그렇다. <em>(too many parameters)</em> 즉 아래 그림에서 좌측은 경향을 나타내긴 하지만 모든 트레이닝셋을 경유하는 직선은 만들어내지 못했다. (<em>under fit</em>) 반면 가장 우측은, 트레이닝셋을 모두 경유하는 <em>hypothesis</em> 를 만들어 냈지만, 다항식의 차수가 너무 높아 새로운 데이터가 들어왔을 때 예측하지 못할 수가 있다. <em>can't apply, unable to generalize</em> 교수님은 다음과 같이 슬라이드에 적으셨다.</p>

<blockquote>
  <p>It makes accurate predictions for examples in the training set, but it does not generalize well to make accurate prediction on new, previously unseen examples</p>
</blockquote>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image.png'  align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p><em>logistic regression</em> 에서도 <em>Overfitting</em> 이 발생할 수 있다.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [1].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>주로 <em>training set</em> 이 부족하고 <em>feature</em> 가 많을때 발생하는데 해결책은</p>

<p>(1) <em>feature</em> 를 줄일 수 있다. 수동으로 사용할 <em>feature</em> 를 선택하는 방법과 <em>Model selection algorithm</em> 을 사용할 수도 있다. <br />
(2)  <em>regularization</em> 을 이용한다. 모든 <em>feature</em> 를 유지하지만, 얼마나 각 <em>feature</em> 가 <em>prediction</em> 에 기여할지를 변경한다.</p>

<h3 id="regularizationcostfunction">Regularization, Cost function</h3>

<p><em>Regularization</em> 은 원하는 파라미터가 <em>hypothesis</em> 에 기여하는 바를 조절하는 것이다. 우리가 만약에 <code>0_3</code> 과 <code>0_4</code> 를 최소화 하고 싶다고 하자.  그럼 다음과 같은 식을 만들면 된다. 전체 식의 최소값을 찾는 것이기 때문에, 상수가 <code>1000</code> 인 <code>0_3</code>, <code>0_4</code> 는 <em>0(zero)</em> 에 가까운 수가 나온다. 다시 말해서 이들 두 파라미터가 기여하는 바를 줄인 것이다.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [2].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p><em>parameters</em> 가 작은 값을 가질수록 간단한 <em>hypothesis</em> 가 나오고, <em>overfitting</em> 하지 않는다. 이를 위해 <code>λ</code> 라는 <em>regularization parameter</em> 를 가진 식을 <em>cost function</em> 에 더 붙여 <em>parameter</em> 가 기여하는 바를 조절하면, 아래와 같은 식을 구할 수 있다. 참고로 뒷 부분의 식은  <em>regularization term</em> 이라 부르는데, <code>j</code> 가 1부터 시작하는 것에 주목하자. 이는 <code>0_0</code> 은 <em>regularization</em> 하지 않는다는 의미이다.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [5].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p><code>λ</code> 가 매우 크면 어떻게 될까? <code>0_0</code> 이외의 다른 파라미터는 0에 수렴 하므로, <em>hypothesis</em> 는 상수가 되어 트레이닝 셋에 <em>under fit</em> 할 것이다.</p>

<h3 id="regularizedlinearregression">Regularized Linear Regression</h3>

<p><em>regularization term</em> 으 <code>j</code> 가 1부터 시작하므로, <em>cost function</em> 을 쉽게 계산하기 위해 분리하면 <em>gradient descent</em> 식은 다음과 같이 적을 수 있다.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [6].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>이제 위 두 식에서 아래 식을 정리하면, 다음과 같고</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [8].png" align="center" /> <br />
&lt;면 된다. 이때 이 매트릭스의 <code>(0, 0)</code> <br />
위 식에서 앞부분은 아래와 같다. 보통 <code>m</code> 이 매우 크고, <code>a</code> 가 매우 작으므로 위 값은 1보다 작다. 예를 들면 <code>0.99 * 0_j</code> 처럼. </p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [9].png" align="center" /></p>

<p>이제 <em>Normal equation</em> 에 어떻게 적용할지 고려해 보자, 본래 <em>normal equation</em> 식은 아래와 같은데, </p>

<p><img src='http://www.holehouse.org/mlclass/04_Linear_Regression_with_multiple_variables_files/Image%20' [13].png" align="center" /></p>

<p><code>X^T * X</code> 부분에 <code>λ</code> 가 곱해지는 <code>n+1 * n+1</code> 의 <em>matrix</em> 를 곱하면 된다. 이때 이 매트릭스의 <code>(0, 0)</code> 부분이 <code>0</code> 인 것은 <code>0_0</code> 에 <em>regularization</em> 을 적용하지 않기 위한 것.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [10].png" align="center" /></p>

<p>그럼 만약에 <code>X^T * X</code> 가 <em>non-invertible</em> 이라면 어떻게 될까? 이건 지난 시간에 언급했듯이 <em>redundant feature</em> 가 너무 많거나, <code>m &lt;= n</code>, 즉 트레이닝 셋에 비해 <em>feature</em> 가 너무 많을 때 발생한다고 말했다.</p>

<p>놀랍게도, <code>λ &gt; 0</code> 이면, 아래 식에서 <code>X^T * X + λ</code> (λ's (0, 0) = 0) 은 제대로 <em>invertible</em> 함을 증명할 수 있다. 다시 말해서 <em>regularzation</em> 을 통해서 <em>non-invertible</em> 문제도 해결할 수 있다는 것.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [10].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<h3 id="regularizedlogisticregression">Regularized Logistic Regression</h3>

<p><em>linear regression</em> 과 마찬가지로 <code>0(theta)</code> 를 0과 1로 분리해 <em>regularization term</em> 을 추가하면 된다. 다른점은 <code>h(x)</code> 가 <em>sigmoid function</em> 의 형태라는 것.</p>

<p>그리고 <em>gradient descent</em> 를 풀기 위해 <em>octave</em> 에서 제공하는 알고리즘들을(<em>conjugate</em>, <em>BFGS</em>, <em>L-BFGS</em> 등) 을 <code>fminunc</code> 이용해서 사용할 수 있다. 이를 위해 언급 했듯이 <code>jval</code> 과 <code>0(theta)</code> 에 대한 <code>graident</code> 를 돌려주는 <em>cost function</em> 을 만들어야 하는데, <em>regularzation term</em> 이 추가되었으므로 해당하는 값을 더해서 각 <code>0</code> 에 대한 <em>gradient</em> 를 계산하는 식을 만들어주면 된다.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [16].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>  

<p><br/></p>

<h3 id="summary">Summary</h3>

<p>3주째에는 <em>Classification</em> 과 <em>Regularization</em> 에 대해서 배웠다. 수업은 어렵지 않다. 과제가 문제지 ㅠㅠ 교수님. 파이썬으로 과제를 내주셨으면 좀 더 배우는 맛이 있었을텐데요!</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://stats.stackexchange.com/questions/22381/why-not-approach-classification-through-regression' >why-not-approach-classification-through-regression</a> <br />
(2) <a href='http://www.saedsayad.com/artificial_neural_network.htm' >http://www.saedsayad.com</a> <br />
(3) <a href='http://blog.csdn.net/abcjennifer/' >http://blog.csdn.net/abcjennifer/</a> <br />
(4) <a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>  </p>

<p><strong>Machine Learning</strong> by Andrew Ng, <em>Coursera</em></p>]]></description><link>http://1ambda.github.io/machine-learning-week-3/</link><guid isPermaLink="false">a123e443-ef68-426f-81a1-2af9b381d733</guid><category><![CDATA[coursera]]></category><category><![CDATA[machine lerning]]></category><category><![CDATA[regularization]]></category><category><![CDATA[classification]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 15 Oct 2014 13:18:03 GMT</pubDate></item><item><title><![CDATA[Functional Programming in Scala, Chapter 5]]></title><description><![CDATA[<p>지난주엔 Scala 가 <em>리스코프 치환 원칙</em> 을 지키기 위해 어떻게 <em>Variance(공변성)</em> 을 문법적으로 지원하는지 알아보았다. 직접 <code>List</code> 컨테이너를 구현해 보면서 함수의 인자는 <em>Covariant</em>, 리턴타입은 <em>Contravariant</em> 란 것도 알게 되었고, <code>Nil</code> 을 만들기 위해 <code>Nothing</code> 을 어떻게 엮을 수 있는지도 직접 확인해 보았다. 마지막으로, 프로그래머가 가장 많이 작성하는 로직인 <em>Decomposition</em> 을 <em>Pattern Matching</em> 을 이용해 더 우아하게 작성하는법도 배웠다. <del>오오 추상화 오오</del></p>

<p>이번시간에도 <code>List</code> 를 가지고 놀면서 <em>Reduce</em> 의 개념과 Scala 의 <em>Implicit</em> 키워드가 어떤 역할을 하는지 배워본다. </p>

<h3 id="morefunctionsonlists">More Functions on Lists</h3>

<p><code>List.last</code> 는 마지막 원소를 돌려준다. <code>head</code> 나 <code>tail</code> 같은 경우는 상수 시간 내에 리턴되지만, <code>last</code> 는 어떨까? </p>

<pre><code class="scala">def last[T](l: List[T]): T = xs match {  
  case List() =&gt; throw new Error('last of empty list')
  case List(x) =&gt; x
  case y :: ys =&gt; last(ys)
}
</code></pre>

<p>그러므로 길이 <code>n</code> 에 비례하는 성능을 보여준다.</p>

<blockquote>
  <p><code>last</code> takes steps proportional to the length of the list</p>
</blockquote>

<p>마찬가지로 마지막 원소를 제외하고 나머지를 돌려주는 <code>Last.init</code> 경우도 같은 성능을 보여준다. 이렇게 구현할 수 있다.</p>

<pre><code class="scala">  def init[T](xs: List[T]): List[T] = xs match {
    case List() =&gt; throw new Error("init of empty list")
    case List(x) =&gt; List()
    case y :: ys =&gt; y :: init(ys)
  }
</code></pre>

<p><code>concat</code> 은 어떨까? <code>xs</code> 를 받아서 <code>ys</code> 앞에 붙이는 함수다. <code>prepend</code> 함수라 보면 되겠는데, 지난 시간에 논의했었던 <code>:::</code> 랑 같다. </p>

<p>지난 시간에 언급 했듯이 <code>xs ::: ys</code> 처럼 <code>:</code> 로 끝나는 연산자는 우측에 오는것이 실제 좌측 피연산자다. <code>ys .::: (xs)</code> 와 같다.</p>

<pre><code class="scala">  def concat[T](xs: List[T], ys: List[T]): List[T] = xs match {
    case List() =&gt; ys
    case z :: zs =&gt; z :: concat(zs, ys)
  }
</code></pre>

<p>이제, <code>reverse</code> 를 구현 해 보자.</p>

<pre><code class="scala">  def reverse[T](xs: List[T]): List[T] = xs match {
    case List() =&gt; xs
    case y :: ys =&gt; reverse(ys) ++ List(y)
  }
</code></pre>

<p><code>reverse</code> 도 마찬가지로 길이 <code>n</code> 에 <em>quadratic</em> 한 성능을 보여준다. 이는 <code>reverse</code> 내부에서 <code>++</code> 을 사용하기 때문이다. 이는 더 개선할 수 있는데, 후에 논의하겠다.</p>

<p>참고로, <code>++</code> 와 <code>:::</code> 는 하는일은 같으나, <code>:::</code> 는 <code>List</code> 에만 적용 가능하고 <code>++</code> 는 다른 <em>Traversal</em> 에도 적용 가능하다. <a href='http://stackoverflow.com/questions/6559996/scala-list-concatenation-vs' >여기</a> 참조</p>

<p>이제 <code>removeAt</code> 을 구현 해 보자.</p>

<pre><code class="scala">  def removeAt[T](n: Int, xs: List[T]): List[T] = 
    (xs take n) ::: (xs drop n + 1)
</code></pre>

<p><code>flatten</code> 은 다음과 같이 작성할 수 있다.</p>

<pre><code class="scala">  def flatten(xs: List[Any]): List[Any] = xs match {
    case List() =&gt; xs
    case List(y :: ys) =&gt; y :: flatten(ys) 
    case y :: ys =&gt; y :: flatten(ys)
  }
</code></pre>

<h3 id="pairsandtuples">Pairs and Tuples</h3>

<p><code>(3, "example")</code> 과 같은 형태를 <em>Pair</em> 라 부르는데, 이건 사실 <em>Tuple</em> 의 특별한 형태다.</p>

<p><code>(T1, ..., Tn)</code> 은 <code>scala.Tuplen[T1, ..., Tn]</code> 의 <em>parameterized type</em> 이고, <em>expression</em>  <code>(e1, ..., en)</code> 은 사실 <code>scala.Tuplen(e1, ..., en)</code> 과 동일하다.</p>

<p>그리고 <em>tuple</em> 의 패턴 <code>(p1, ..., pn)</code> 은 <em>constructor pattern</em> <code>scala.Tuplen(p1, ..., pn)</code> 과 같다. <code>TupleN</code> 클래스를 구경 해 보자.</p>

<pre><code class="scala">case class Tuple2[T1, T2](_: +T1, _2: +T2) {  
  override def toString = "(" + _1 + "," + _2 + ")"
}
</code></pre>

<p>멤버를 접근할 때 <code>_1</code>, <code>_2</code> 와 같은 식으로 접근하므로, 패턴 매칭에서</p>

<p><code>val (label, value) = pair</code> 는 사실 다음과 같다.</p>

<pre><code class="scala">val label = pair._1  
val value = pair._2  
</code></pre>

<p><em>Tuple</em> 의 패턴 매칭을 이용하면, 다음과 같이 중첩된 <em>case</em> 를 사용하는 <em>merge sort</em> 함수를</p>

<pre><code class="scala">  def msort(xs: List[Int]): List[Int] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[Int], ys: List[Int]): List[Int] = xs match {
        case Nil =&gt; ys
        case x :: xs1 =&gt; ys match {
          case Nil =&gt; xs
          case y :: ys1 =&gt; {
            if (x &gt; y) y :: merge(xs, ys1)
            else x :: merge(xs1, ys)
          }
        }
      }

      val (left, right) = xs splitAt n
      merge(msort(left), msort(right))
    }
  }
</code></pre>

<p>요로코롬 바꿀 수 있다. <del>오오 패턴매칭 오오</del></p>

<pre><code class="scala">  def msort(xs: List[Int]): List[Int] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[Int], ys: List[Int]): List[Int] =
        (xs, ys) match {
          case (xs, Nil) =&gt; xs
          case (Nil, ys) =&gt; ys
          case (x :: xs1, y :: ys1) =&gt;
            if (x &gt; y) y :: merge(xs, ys1)
            else x :: merge(xs1, ys)
        }

      val (left, right) = xs splitAt n
      merge(msort(left), msort(right))
    }
  }
</code></pre>

<h3 id="implicitparameters">Implicit Parameters</h3>

<p><code>Int</code> 뿐만 아니라 우리가 만든 <code>msort</code> 함수를 더 범용적으로 활용할 수 있도록, <em>Currying</em> 을 이용하자.</p>

<pre><code class="scala">  def msort[T](xs: List[T])(lt: (T, T) =&gt; Boolean): List[T] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[T], ys: List[T]): List[T] =
        (xs, ys) match {
          case (xs, Nil) =&gt; xs
          case (Nil, ys) =&gt; ys
          case (x :: xs1, y :: ys1) =&gt;
            if (lt(x, y)) x :: merge(xs1, ys)
            else y :: merge(xs, ys1)
        }

      val (left, right) = xs splitAt n
      merge(msort(left)(lt), msort(right)(lt))
    }
  }
</code></pre>

<p>아래는 테스트코드</p>

<pre><code class="scala">  "msort" should "return an ordered list" in {
    val xs = List(4, 2, 7, 1, 11, 9, 3)
    val ys = List(10, 9, 8, 7, 6)

    assert(msort(xs)((x: Int, y: Int) =&gt; x &lt; y) == List(1, 2, 3, 4, 7, 9, 11))
    assert(msort(ys)((x: Int, y: Int) =&gt; x &lt; y) == List(6, 7, 8, 9, 10))
  }
</code></pre>

<p>참고로 <code>msort</code> 에 <code>Int</code> 인자를 주는 경우, <code>x: Int, y: Int</code> 처럼 타입을 명시하지 않아도 알아서 <code>xs</code> 를 보고 추론한다.</p>

<h4 id="parameterizationwithordered">Parameterization with Ordered</h4>

<p>사실은 <code>scala.math.Othering[T]</code> 에 <em>ordering</em> 을 나타낼 수 있는 클래스가 있다. 이를 활용하면 <code>msort</code> 를 다음과 같이 리팩토링 할 수 있다. </p>

<pre><code class="scala">  def msort[T](xs: List[T])(ord: Ordering[T]): List[T] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[T], ys: List[T]): List[T] =
        (xs, ys) match {
          case (xs, Nil) =&gt; xs
          case (Nil, ys) =&gt; ys
          case (x :: xs1, y :: ys1) =&gt;
            if (ord.lt(x, y)) x :: merge(xs1, ys)
            else y :: merge(xs, ys1)
        }

      val (left, right) = xs splitAt n
      merge(msort(left)(ord), msort(right)(ord))
    }
  }
</code></pre>

<p>테스트 코드는,</p>

<pre><code class="scala">  "msort" should "return an ordered list" in {
    val xs = List(4, 2, 7, 1, 11, 9, 3)
    val ys = List(10, 9, 8, 7, 6)
    val zs = List("pineapple", "apple", "banana", "watermelon")

    assert(msort(xs)(Ordering.Int) == List(1, 2, 3, 4, 7, 9, 11))
    assert(msort(ys)(Ordering.Int) == List(6, 7, 8, 9, 10))
    assert(msort(zs)(Ordering.String) == List("apple", "banana", "pineapple", "watermelon"))
  }
</code></pre>

<p>다 좋은데, <code>Ordering.Int</code> 인자 자체를 숨겨버렸으면 좋겠다. <code>msort</code> 의 <code>ord</code> 파라미터를 다음과 같이 변경하자. <code>(implicit ord: Ordering[T])</code></p>

<pre><code class="scala">  def msort[T](xs: List[T])(implicit ord: Ordering[T]): List[T] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[T], ys: List[T]): List[T] =
        (xs, ys) match {
          case (xs, Nil) =&gt; xs
          case (Nil, ys) =&gt; ys
          case (x :: xs1, y :: ys1) =&gt;
            if (ord.lt(x, y)) x :: merge(xs1, ys)
            else y :: merge(xs, ys1)
        }

      val (left, right) = xs splitAt n
      merge(msort(left), msort(right))
    }
  }
</code></pre>

<p>테스트 코드는 아래와 같다.</p>

<pre><code class="scala">  "msort" should "return an ordered list" in {
    val xs = List(4, 2, 7, 1, 11, 9, 3)
    val ys = List(10, 9, 8, 7, 6)
    val zs = List("pineapple", "apple", "banana", "watermelon")

    assert(msort(xs) == List(1, 2, 3, 4, 7, 9, 11))
    assert(msort(ys) == List(6, 7, 8, 9, 10))
    assert(msort(zs) == List("apple", "banana", "pineapple", "watermelon"))
  }
</code></pre>

<p>놀랍게도, 파라미터가 사라져버렸다. ~오오 스칼라 오오~ <code>implicit</code> 하나만 추가했을 뿐인데! <code>implicit</code> 를 파라미터 타입에 추가하면 아래처럼 해석된다.</p>

<p>타입 <code>T</code> 인 <code>implicit</code> 파라미터에 대해서,</p>

<p>(1) <code>implicit</code> 이며 <br />
(2) <code>T</code> 와 호환 가능한 타입을 가지고 있고 <br />
(3) <em>function call</em> 내에서 찾을 수 있거나 <br />
(4) 혹은 <code>T</code> 와 관련된 <em>companion object</em> 내에 있는</p>

<p><em>single definition (most specific)</em> 이 있는지 컴파일러가 찾는다. 파라미터로 사용하고 아니면, 에러를 뿜는다. </p>

<p>즉 위의 코드의 경우 <code>Ordering[String]</code> 와 <code>Ordering[Int]</code> 는 어딘가에 <code>implicit</code> 로 처리되어 이미 존재한다. </p>

<h3 id="higherorderlistfunctions">Higher-Order List Functions</h3>

<p><code>List</code> 에 사용하는 메소드들은 종종 <em>반복된 패턴 (recurring patterns)</em> 을 가지는데, 3가지로 요약해 보면 아래와 같다.</p>

<blockquote>
  <p>(1) transformaing each element in a list ina certain way <br />
  (2) retrieving a list of all elements satisfying a criterion <br />
  (3) combining the elements of a list using an operator</p>
</blockquote>

<p>함수형 언어는, <em>higher-order function</em> 이용해서 <em>generic function</em> 을 만들 수 있다.</p>

<h4 id="map">Map</h4>

<p>리스트의 모든 원소에 함수 <code>f</code> 를 <em>적용 (Applying)</em> 하는 <em>고차 함수 (Higher-Order Function)</em> 은 <code>map</code> 이다.</p>

<pre><code class="scala">abstract class List[T] {  
  ...
  def map[T](f: T =&gt; U): List[U] = this match {
    case Nil =&gt; this
    csae x :: xs =&gt; f(x) :: xs.map(f)
  }
  ...
}
</code></pre>

<p>실제로 <code>map</code> 은 좀 더 복잡한데, <em>tail-recursion</em> 과 다양한 종류의 <em>collection</em> 을 지원하기 위함이다.</p>

<h4 id="filter">Filter</h4>

<pre><code class="scala">abstract class List[T] {  
  ...
  def filter(p: T =&gt; Boolean): List[T] = this match {
    case Nil =&gt; this
    case x :: xs =&gt; if (p(x)) x :: xs.filter(p) else xs.filter(p)
  }
  ...
}
</code></pre>

<p>이외에도 <code>filterNot</code> 과 <code>partition</code>이 있다. <code>partition</code> 은 <code>filter</code> 와  <code>filterNot</code> 의 결과를 둘 다 돌려준다.</p>

<p><code>takeWhile</code> 은 일치하지 않는 곳에서 <em>filtering</em> 을 멈추고, 그 전까지의 결과를 돌려준다. 반대로 <code>dropWhile</code> 은 <code>takeWhile</code> 에서 취해진 결과 이외의 나머지를 돌려준다. </p>

<pre><code class="scala">scala&gt; val zs = List(2, -4, 1, 4, 7)  
zs: List[Int] = List(2, -4, 1, 4, 7)

scala&gt; zs partition(x =&gt; x &gt; 0)  
res38: (List[Int], List[Int]) = (List(2, 1, 4, 7),List(-4))

scala&gt; zs dropWhile(x =&gt; x &gt; 0)  
res39: List[Int] = List(-4, 1, 4, 7)

scala&gt; zs takeWhile(x =&gt; x &gt; 0)  
res40: List[Int] = List(2)

scala&gt; zs span(x =&gt; x &gt; 0)  
res41: (List[Int], List[Int]) = (List(2),List(-4, 1, 4, 7))  
</code></pre>

<p><code>takeWhile</code>, <code>dropWhile</code> 을 이용하면 다음과 같은 <code>pack</code> 함수도 만들 수 있다.</p>

<pre><code class="scala">  def pack[T](xs: List[T]): List[List[T]] = xs match {
    case Nil =&gt; Nil
    case x :: xs1 =&gt; 
      xs.takeWhile(y =&gt; y == x) :: pack(xs.dropWhile(y =&gt; y == x))
  }
</code></pre>

<p>아래는 테스트코드</p>

<pre><code class="scala">  val ts = List("a", "a", "b", "c", "c", "a")
  val ss = List(List("a", "a"), List("b"), List("c", "c"), List("a"))

  "pack" should "return a packed list" in {
    assert(pack(ts) == ss)
  }
</code></pre>

<h3 id="reductionoflists">Reduction of Lists</h3>

<p><code>reduce</code> 는 리스트의 모든 원소에 특정 연산을 수행해 하나의 결과를 만들어 내고 싶을 때 사용한다.</p>

<pre><code class="scala">  def sum(xs: List[Int]) = (0 :: xs) reduceLeft((x, y) =&gt; x + y)
  def product(xs: List[Int]) = (1 :: xs) reduceLeft((x, y) =&gt; x * y)
</code></pre>

<p>사실 <code>reduceLeft</code>, <code>reduceRight</code> 를 기억하는 쉬운 방법은, <em>왼쪽으로 / 오른쪽으로 기운 트리</em> 를 기억하는 것이다. </p>

<p><img src='https://joelneely.files.wordpress.com/2011/03/foldleftplain.jpg?w=219&amp;h=325'  align="center" />  </p>

<p align="center"><a href='https://joelneely.wordpress.com/' >https://joelneely.wordpress.com/</a></p>

<p><code>reduce</code> 와 비슷하지만 초기 인자를 받아 <em>empty-list</em> 에 대해서도 호출될 수 있는 <code>fold</code> 가 있다.</p>

<pre><code class="scala">abstract class List[T] {  
  ...
  def reduceLeft(op (T, T) =&gt; T): T = this match {
    case Nil =&gt; throw new Error("Nil.reduceLeft")
    case x :: xs =&gt; (xs foldLeft x)(op)
  }

  def foldLeft[U](z: U)(op: (U, T) =&gt; U): U = this match {
    case Nil =&gt; z
    case x :: xs =&gt; (xs foldLeft op(z, x))(op)
  }
  ...
}
</code></pre>

<p><br/> <br />
<code>foldRight</code> 는 <em>오른쪽으로 기운 트리</em> 를 생각하면 된다.</p>

<p><img src='https://joelneely.files.wordpress.com/2011/03/foldrightplain.jpg?w=219&amp;h=325'  align="center" />  </p>

<p align="center"><a href='https://joelneely.wordpress.com/' >https://joelneely.wordpress.com/</a></p>

<pre><code class="scala">def reduceRight(op: (T, T) =&gt; T): T = this match {  
  case Nil =&gt; throw new Error("Nil.reduceRight")
  case x :: Nil =&gt; x
  case x :: xs =&gt; op(x, xs.reduceRight(op))
}

def foldRight[U](z: U)(op: (T, U) =&gt; U): U = this match {  
  case Nil =&gt; z
  case x :: xs =&gt; op(x, (xs foldRight z)(op))
}
</code></pre>

<p><code>foldLeft</code> 와 <code>foldRight</code> 는 같은 일을 하긴 하는데, 때때로는 둘 중 하나만 적절한 경우도 있다. 예를 들어</p>

<pre><code class="scala">def concat[T](xs: List[T], ys: List[T]): List[T] =  
  (xs foldRight ys)(_ :: _)
</code></pre>

<p><code>foldRight</code> 대신에 <code>foldLeft</code> 가 오면 어떻게 될까? <em>타입 에러</em> 가 발생한다. <code>3 :: List(4)</code> 는 가능해도 <code>List(3) :: 4</code> 는 불가능하기 때문이다. </p>

<h3 id="reasoningaboutconcat">Reasoning About Concat</h3>

<blockquote>
  <p>We would like to verify that concatenation is associative, and that it admits the empty list <code>Nil</code> as neutral element to the left and to the right</p>
</blockquote>

<p>이번장에서는 <em>natural indction</em> 과 비슷한 <em>structural induction</em> 을 이용해 함수형 프로그래밍에서 어떻게 함수의 정확성을 증명할 수 있는지 배운다.</p>

<p>함수형 프로그래밍에선 <em>side-effect</em> 가 없기 때문에, <em>reduction step</em> 이 전체나, 부분이나 동일하게 적용된다. 이걸 다른말로 <em>참조 투명성 (referential transparency)</em> 라고 부른다. 혹시 몰라 원문을 첨부 하자면,</p>

<blockquote>
  <p>Note that a proof can freely apply reduction steps as equalities to some part of a term <br/></p>
  
  <p>That works because pure functional programs don't have side effects so that a term is equivalent to the terms to the term to which it reduces.</p>
  
  <p>This principle is called referential transparency.</p>
</blockquote>

<h4 id="structuralinduction">Structural Induction</h4>

<p><em>property</em> <code>P(xs)</code> 를 모든 <code>xs</code> 에 대해 증명하기 위해</p>

<p>(1) show that <code>P(Nil)</code> holds (Base case) <br />
(2) for a list <code>xs</code> and some element <code>x</code>, show the <em>induction step:</em> <br />
if <code>P(xs)</code> holds, then <code>P(x :: xs)</code> also holds</p>

<p>우리는 <code>(xs ++ ys) ++ zs = xs ++ (ys ++ zs)</code> 를 증명하고 싶다. 이를 위한 <code>concat</code> 함수는</p>

<pre><code class="scala">def concat[T](xs: List[T], ys: List[T]) = xs match {  
  case List() =&gt; ys
  case x :: xs1 =&gt; x :: concat(xs1, ys)
}
</code></pre>

<p>이 <code>concat</code> 의 정의로 부터 두 가지 사실을 뽑아낼 수 있다. (distill two defining clauses)</p>

<p>(1) <code>Nil ++ ys = ys</code> <br />
(2) <code>(x :: xs1) ++ ys = x :: (xs1 ++ ys)</code></p>

<p>이제 먼저 <em>Base-case</em> 인 <code>Nil</code> 에 대해 먼저 참임을 보이면 된다.</p>

<p><code>(Nil ++ ys) ++ zs = Nil ++ (ys ++ zs)</code> </p>

<blockquote>
  <p>좌변은 (1) 에 의해 <code>ys ++ zs</code> 이고
  우변도 (1) 에 의해 <code>ys ++ zs</code> 이다.</p>
</blockquote>

<p>이제 <code>P(xs)</code> 가 참일때 <code>P(x :: xs)</code> 임을 보이면 된다. 먼저 좌변부터 하면</p>

<p>= <code>((x :: xs) ++ ys) ++ zs</code> by (2) <br />
= <code>(x :: (xs ++ ys)) ++ zs</code> by (2) <br />
= <code>x :: ((xs ++ ys) ++ zs)</code> by (2) <br />
= <code>x :: (xs ++ (ys ++ zs))</code> by <em>induction hypothesis</em> (<code>P(xs)</code>) </p>

<p>우변을 정리하면,</p>

<p>= <code>(x :: xs) ++ (ys ++ zs)</code> by (2) <br />
= <code>x :: (xs ++ (ys ++ zs))</code>  </p>

<p>우변과 좌변이 같으므로, <code>P</code> 는 성립한다.</p>

<h3 id="alargerequationalproofonlists">A Larger Equational Proof on Lists</h3>

<p>이제 <code>reverse</code> 의 <code>xs.reverse.reverse = xs</code> 라는 속성을 증명해 보자. 다음 2개의 <em>clause</em> 를 알고 있다. (교수님이, 좀 더 <em>amenable</em> 하기 때문에 비 효율적인 정의를 골랐다고 하심.)</p>

<p>(1) <code>Nil.reverse</code> = <code>Nil</code> <br />
(2) <code>(x :: xs).reverse</code> = <code>xs.reverse</code> ++ <code>List(x)</code>  </p>

<p><em>Base-case</em> 는 패스하고, 바로 <code>x :: xs</code> 에 대한 것 부터 들어가면 좌변은  </p>

<p><code>(x :: xs).reverse.reverse</code> <br />
= <code>(xs.reverse ++ List(x)).reverse</code></p>

<p>우변은</p>

<p><code>x :: xs</code> <br />
= <code>x :: xs.reverse.reverse</code>  </p>

<p>이걸로는 할 수 있는게 없으므로 <code>xs.reverse</code> 를 <code>ys</code> 라 놓으면</p>

<p><code>(ys ++ List(x)).reverse</code> = <code>x :: ys.reverse</code> 를 증명하면 된다. <em>Auxiliary Equation</em> 인데, 먼저 <em>Base-case</em> 부터 참임을 보이면 </p>

<p>좌변은</p>

<p><code>(Nil ++ List(x)).reverse</code> <br />
= <code>List(x).reverse</code> // ++ clause 1 <br />
= <code>(x :: Nil).reverse</code> // List Definition <br />
= <code>Nll.reverse ++ List(x)</code> // reverse clause 2 <br />
= <code>Nil ++ List(x)</code> // reverse clause 1 <br />
= <code>x :: Nil</code> // List Definition  </p>

<p>우변은</p>

<p><code>x :: Nil.reverse</code> <br />
= <code>x :: Nil</code> // reverse clause 1  </p>

<p>이제 <code>((y :: ys) ++ List(x)).reverse</code> 와 <code>x :: (y :: ys).reverse</code> 가 같음을 보이면 된다.</p>

<p><code>((y :: ys) ++ List(x)).reverse</code> <br />
= <code>(y :: (ys ++ List(x)).reverse</code> // ++ clause 2 <br />
= <code>(ys ++ List(x)).reverse ++ List(y)</code>  // reverse clause 2 <br />
= <code>(x :: ys.reverse) ++ List(y)</code>  // <em>induction hypothesis</em> <br />
= <code>x :: (ys.reverse ++ List(y)</code>  // reverse clause 2 <br />
= <code>x :: (y : ys).reverse</code> </p>

<p>이것은 우변 <code>x :: (y :: ys).reverse</code> 와 동일하므로 <em>Auxiliary equation</em> 이 성립하고, 본래의 성질 <code>xs = xs.reverse.reverse</code> 도 성립한다.</p>

<h4 id="exercise">Exercise</h4>

<p><code>map</code> 을 증명하라고 주시는데, 못해먹겠다 -_-; 패쓰!</p>

<h3 id="summary">Summary</h3>

<p><em>Reduction</em>, <em>Fold</em>, <em>referential transparency</em> 그리고 <em>structural induction</em> 에 대해서 배웠다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://stackoverflow.com/questions/6559996/scala-list-concatenation-vs' >scala-list-concatenation-vs</a></p>

<p>2014-10-14, <strong>Functional Programming in Scala</strong>, Coursera</p>]]></description><link>http://1ambda.github.io/functional-programming-in-scala-chapter-5/</link><guid isPermaLink="false">a94afb0b-63a0-4cd9-8a0e-2224ff29fea2</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[functional programming]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 14 Oct 2014 10:48:03 GMT</pubDate></item><item><title><![CDATA[Analysis of Algorithms]]></title><description><![CDATA[<p><strong>Analysis of Algorithms</strong>, by <em>Kevin Wayne</em>, <em>Robert Sedgewick</em> in Coursera </p>

<p>알고리즘을 분석해야 하는 이유는 </p>

<p>(1) Predict performance <br />
(2) Compare algorithms <br />
(3) Provide guarantees <br />
(4) Understand theoretical basis  </p>

<p>그 중에서도 <em>performance bug</em> 를 피하는 것이 무엇보다 중요하다. 이를 통해 내 알고리즘이 <em>practical large input</em> 에 적용할 수 있을까? 고민하는 것이, 알고리즘 분석의 주된 동기다.</p>

<h3 id="observations">Observations</h3>

<p>주어진 배열에서 3개를 골라 더했을때 0이 나오는 <em>3-Sum</em> 문제를 고려해 보자. </p>

<pre><code class="java">for (int i = 0; i &lt; N; i++)  
  for(int j = i + 1; j &lt; N; j++)
    for(int k = j + 1; k &lt; N; k++) 
      if (array[i] + array[j] + array[k] == 0)
        count++;        
</code></pre>

<p>입력 대비 출력 시간을 <em>log-log plot</em> 으로 만들어, <code>y = a * N^b</code> 를 얻을 수 있다. 이것 보다 더 빠르게 찾는 방법은 <em>input</em> 을 두배씩 늘려가면서 로그 비율을 찾는 방법인데, <em>Doubling hypothesis</em> 라 부른다. 이 경우 <code>b</code> 가 3이 나오는걸 확인할 수 있다.</p>

<p>샘플 데이터가 다음과 같다고 하자. (Matlab format)</p>

<pre><code class="matlab">x = [  
1000;  
2000;  
4000;  
8000;  
16000;  
32000;  
64000]

y = [  
0.0;  
0.0;  
0.1;  
0.3;  
1.3;  
5.1;  
20.5]  
</code></pre>

<p>이 경우 수가 클때, 4배씩 증가하므로 <em>2-based log ratio</em> 는 <code>2</code> 다. 따라서 <code>a * N^b</code> 에서 <code>b</code> 를 2로 가정하면, <code>5.1 / 32000^2</code> 하면, 대략 <code>5.0 * 10^-9</code></p>

<h3 id="mathematicalmodels">Mathematical Models</h3>

<p>사실 <em>Running time</em> 에 있어서 연산의 수행 시간은 컴퓨터마다, 또 연산마다 다르므로 이것을 제하고 <em>operation number</em>, <em>frequency</em> 의 곱을 <em>input number</em> <code>N</code> 을 이용하여 표현한 모델을 이용할 수 있다. 예를 들어 <em>1-Sum</em> 코드의 경우</p>

<pre><code class="java">int count = 0;  
for (int i = 0; i &lt; N; i++)  
  if (array[i] == 0)
    count++;
</code></pre>

<blockquote>
  <p>variable declaration = 2 <br />
  assignment = 2 <br />
  less then compare = N + 1 <br />
  equal to compare = N <br />
  array access = N <br />
  increment = N to 2N</p>
</blockquote>

<p><em>2-Sum</em> 코드의 경우 </p>

<pre><code class="java">int count = 0;  
for (int i = 0; i &lt; N; i++)  
  for(int j = i + 1; j &lt; N; j++)
    if (array[i] + array[j] == 0)
      count++;
</code></pre>

<blockquote>
  <p>variable declaration = 2 + N 
  assignment = 2 + N
  less then compare = 1/2 * (N + 1) * (N + 2) <br />
  equal to compare = 1/2 * N * (N - 1) <br />
  array access = N * (N - 1) <br />
  increment = 1/2 * N * (N - 1) to N * (N - 1)</p>
</blockquote>

<p>세 보면 알겠지만 정말 귀찮다. 세야할 연산의 종류도 많고. 그렇기 때문에, <em>running-time</em> 을 간단히 추정하기 위해</p>

<p>(1) Use some basic operation as a proxy for running time <br />
(2) tilde notation: ignore lower order terms  </p>

<p>따라서 <em>2-Sum</em> 의 경우 유효한 연산을 배열 접근으로 잡으면, 연산 회수는 <code>~N^2</code> 이고 <em>3-Sum</em> 은 <code>~ 1/6 * N^3</code> 이다.</p>

<p><em>discrete sum</em> 을 편하게 계산하는 법이 있는데, 시그마를 적분으로 바꿔, 계산하면 된다. 따라서 <code>1 + 2 + ... + N</code> 은 <code>1/2 * N</code>, <code>1 + 1/2 + 1/3 + ... + 1/N</code> 은 <code>ln N</code>, </p>

<p><em>3-Sum</em> 의 <em>triple loop</em> 는 <code>N * 1/2 N* 1/3 N</code> 이므로, <code>~1/6 N</code> 이다. 여기에 3번의 Array Access 가 일어나므로 곱하면 <em>3-Sum</em> 은 <code>~1/2 N</code>이다.</p>

<pre><code class="java">int sum = 0;  
for (int i = 0; i &lt; N; i++)  
  for (int j = i; j &lt; N; j++)
    for (int k = 1; k &lt; N; k = k * 2)
      if (a[i] + a[j] &gt;= a[k]) sum++;
</code></pre>

<p>모든 <em>triple loop</em> 가 <code>~n^3</code> 을 가지는건 아니다. 위의 코드의 경우 <code>~ 1/2 N^2 * 3 lg  N</code> 이다.</p>

<h3 id="orderofgrowthclassification">Order of Growth Classification</h3>

<p><code>1</code> &lt; <code>lg N</code> &lt; <code>N</code> &lt; <code>N lg N</code> &lt; <code>N^2</code> &lt; <code>N^3</code> &lt; <code>2^N</code> 우측으로 갈 수록 알고리즘의 성능이 나쁘다. 일반적으로는 <code>N lg N</code> 이 쓸 수 있는 알고리즘이다. 좀 더 알아보자면, </p>

<blockquote>
  <p><strong>log N:</strong> N 이 절반으로 나누어지는 <em>binary search</em> 등 <br />
  <strong>N log N:</strong>, <em>divide and conquer: merge sort</em> 등 <br />
  <strong>2^N:</strong> 서브트리를 모두 검사하는 <em>exhaustive search</em> 등  </p>
</blockquote>

<p>알고리즘의 성능을 비교하기 위해 <code>T(2N) / T(N)</code> 을 구할 수 있는데, </p>

<p>(1) <code>N</code> 은 <code>2</code> (따라서 lg 2 = 1 이므로, <code>N^1</code> 이다.) <br />
(2) <code>N^2</code> 은 <code>4</code> <br />
(3) <code>N^3</code> 같은 경우 <code>8</code> 이다. 
(4) <code>2^N</code> 은 <code>T(N)</code> 이다.</p>

<p>잠깐 <code>~lg N</code> 의 복잡도를 가지는 <em>Binary Search</em> 에 대해 이야기 해 보자.</p>

<h4 id="binarysearch">Binary Search</h4>

<p>이진트리에 대해 재밌는 사실이 하나 있다. 이진트리가 나온건 1946년인데, 놀랍게도 버그가 없는 버전은 1962년에 처음 나왔다. 그리고 자바의 <code>Arrays.binarySerach()</code> 도 2006년에 버그가 발견되었다. 아래의 코드에서 만약 <code>arr</code> 에 <code>[1]</code> 을 넣고, <code>key</code> 에 <code>1</code> 을 주면 어떻게 될지 한번 생각 해 보자.</p>

<pre><code class="java">public static int binarySearch(int[] arr, int key) {  
  int low = 0, high = arr.length - 1;

  while (low &lt;= high) {
    int mid = low + (high - low) / 2;

    if (key &lt; arr[mid]) high = mid - 1; // 3-way compares
    else if (key &gt; arr[mid]) low = mid + 1;
    else return mid
  }

  return -1;
}
</code></pre>

<p><em>binary search</em> 를 <em>2-way compare</em> 로 구현하면, 다시 말해 <code>if-else</code> 만 이용하면 <code>1 + lg N</code> 의 복잡도를 가지게 된다. 이는 <code>T(N) &lt;= 1 + T(N/2)</code> , <code>T(N) &lt;= 1 + 1 + T(N/4)</code>, ... <code>T(N) = 1 + 1 + ... + T(N/N)</code> 이기 때문이다.</p>

<p><em>binary search</em> 가 <code>1 + lg N</code> 이라는 사실을 이용하면 <em>3-Sum</em> 을 <code>N^2 lg N</code> 으로 개선할 수 있다.</p>

<p>(1) sorting: <code>N^2</code> <br />
(2) binary search for <code>-(arr[i] + arr[j])</code>  : <code>N^2 log N</code>  </p>

<p>두번째 스탭에서 <code>i</code>, <code>j</code> 에 대해 이진탐색을 시도하므로 <code>N^2 * log N</code> 이다.</p>

<h3 id="theoryofalgorithms">Theory of Algorithms</h3>

<p>이제 <strong>Best case(lower bound on cost)</strong>, <strong>Worst case(upper bound on cost)</strong>, <strong>Average case(expected cost)</strong> 를 고려 해 보자</p>

<p>이를 위해 새로운 <em>notation</em> 을 도입할 수 있다. 교수님이 해주시는 설명을 솔직히 못 알아 듣겠다. 그냥 <em>big theta</em>, <em>big omega</em>, <em>big oh</em> 에 대해 구글링 해서 나오는 <a href='http://stackoverflow.com/questions/471199/what-is-the-difference-between-%CE%98n-and-on' >SO 답변</a> 을 참조했다.</p>

<p>먼저 <strong>asymptotic</strong> 이란 말을 이해해야 하는데 한국어로 표현하면 <em>점근적</em> 정도가 된다. <del>m 은 묵음</del></p>

<blockquote>
  <p>If an algorithm is of Θ(g(n)), it means that the running time of the algorithm as n (input size) gets larger is proportional to g(n).</p>
  
  <p>If an algorithm is of O(g(n)), it means that the running time of the algorithm as n gets larger is at most proportional to g(n).</p>
  
  <p>More technically, O(n) represents upper bound. Θ(n) means tight bound. Ω(n) represents lower bound.</p>
</blockquote>

<p>우리가 어떤 알고리즘이 <code>O(n)</code> 이라고 할 때 <code>O(n^2)</code>, 혹은 <code>O(n^3)</code> 이라고 말할 수 있다. <em>upper bound</em> 니까. 하지만 어떤 알고리즘(<code>f(n)</code>) 이 <code>Θ(n)</code> 일때, <code>Θ(n^2)</code> 이라 말할 순 없다. 그리고 <em>Big-Oh</em> 와 <em>Big-theta</em> 가 존재 해야 <em>Big-omega</em> 가 존재한다.</p>

<blockquote>
  <p>f(x) = Θ(g(x)) iff f(x) = O(g(x)) and f(x) = Ω(g(x))</p>
</blockquote>

<p>이런 표기법을 이용하는 이유는, 다시 말해서 <em>Theory of algorithm</em> 의 목적은 <em>optimal algorithm</em> 을 찾는데 있다. </p>

<p><em>1-sum</em> 을 예로 들어 보자. <em>upper bound</em> 는, 모든 원소를 찾는 것이다. 따라서 <code>O(n)</code>.  적어도 모든 원소를 한번씩은 다 뒤져봐야 하므로, <em>lower bound</em> 는 <code>Ω(n)</code> 이다. 따라서 두개가 <em>constant factor</em> 내에서 같으므로 <code>Θ(n)</code> 이다.</p>

<p><em>3-sum</em> 을 고려해 보자. <em>upper bound</em> 는 <code>O(n^2 * lg n)</code> 이다. <em>lower bound</em> 는 확실힌 모르겠지만 적어도 모든 원소를 한번씩은 훑어야 하므로 <code>Ω(n)</code> 다. <a href='http://cstheory.stackexchange.com/questions/14585/lower-bounds-for-3sum-with-a-free-cache' >여기</a> 보면 <em>3-sum</em> 의 <em>lower bound</em> 에 관한 논의가 있다.</p>

<p>따라서 <em>3-sum</em> 에 대한 확실한 <em>lower bound</em> 를 모르므로, <em>upper bound</em> 와의 갭이 있고, 아직까진 <em>optimal algorithm</em> 이 무엇인지 알 수 없다.</p>

<p>따라서 알고리즘을 디자인하는 접근 방법은,</p>

<p>(1) Develop an algorithm <br />
(2) Prove a lower bound</p>

<p>그리하여, <em>lower bound</em> 와 <em>upper bound</em> 사이의 갭이 있다면 <em>lower bound</em> 를 증가시키는 새로운 알고리즘이 여지가 있다. 그걸 찾아내면서 <em>lower bound</em> 를 올려가면 <em>optimal algorithm</em> 을 찾을 수 있다. </p>

<p>1970년대에는 <em>upper bound</em> 를 줄여왔지만, </p>

<p>(1) 너무 <em>worst case</em> 에만 집중헀고 <br />
(2) 이제 더 정확한 성능 측정을 위해서 <em>to within a constant factor</em> 보다 더 좋은 무언가가 필요하다.</p>

<p>그리고 많은 사람들이 <em>Big o</em> 를 <em>approximate model of running time</em> 으로 번역하는 실수를 저질렀는데, 이 수업에서는 <em>Big o</em> 대신 <em>tilde(~)</em> 를 사용하겠다.</p>

<p><img src='http://qlx.is.quoracdn.net/main-ce94d194dc6a85d3.png'  align="center" /></p>

<p align="center">If</p>

<p><img src='http://qlx.is.quoracdn.net/main-30ac99d6624fcf8c.png'  align="center" /></p>

<h3 id="memory">Memory</h3>

<p>자바에서는 다음과 같은 오버헤드가 있다.</p>

<p>(1) <code>N</code> 개의 1차원 배열을 만들때는 <em>Type * N + 24 Bytes</em> <br />
(2) <em>Object</em> 는 <em>16 Bytes</em> <br />
(3) <em>Reference</em> 는 <em>8 Bytes</em> <br />
(4) 각 오브젝트는 <em>8 Bytes</em> 단위로 패딩된다.</p>

<p><strong>String</strong> 은 조금 더 복잡한데,</p>

<p>오브젝트 오버헤드, <code>char</code> 배열 오버헤드(<code>2N + 24</code>)와 함께 <code>offset</code>, <code>count</code>, <code>hash</code> 를 <code>int</code> 타입으로 가지므로 <em>12 Bytes</em> 와 패딩이 포함된다.</p>

<p><em>inner class</em> 가 있다면 <em>Object</em> 에 <em>8 bytes</em> 의 메모리가 더 필요하다.</p>

<pre><code class="java">public class WeightedQuickUnionUF {  
  private int[] id;
  private int[] sz;
  private int count;

  ...
}
</code></pre>

<p>위 클래스를 인스턴스로 가지고 있을 경우엔 <code>N</code> 에 대해서</p>

<p>(1) 16 bytes <em>object overhead</em> <br />
(2) 8 + (4N + 24) for each <em>int[] array</em> <br />
(3) 4 bytes for <code>count</code> <br />
(4) 4 bytes padding</p>

<p>따라서 <code>8N + 88</code> 이므로 <code>~8 N</code> 이다.</p>

<h3 id="summary">Summary</h3>

<p><strong>Empirical analysis</strong> 은 실제로 프로그램을 돌려 성능을 얻은 다음 가설을 새워 예측하는 방법이다. 반면 <strong>Mathematical analysis</strong> 는 알고리즘을 분석해 연산 횟수에 기반한 모델을 새우는 방법이다. </p>

<blockquote>
  <p>Emplirical analysis model enables us to <strong>make predictions</strong> and necessary to validate mathematical models</p>
  
  <p>Mathematical analysis model enables us to <strong>explain behavior</strong> and is independent of a particular system. </p>
</blockquote>]]></description><link>http://1ambda.github.io/analysis-of-algorithms/</link><guid isPermaLink="false">3e2611a4-8600-4397-bef5-ea6d0245d660</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 11 Oct 2014 06:35:32 GMT</pubDate></item><item><title><![CDATA[Programming Language, Week1]]></title><description><![CDATA[<p><strong>Programming Language</strong> by <em>Dan Grossman</em>, Coursera</p>

<p><em>Coursera</em> PL 클래스인데 과제 마감기한도 까다롭고, 동료평가도 있고, 여러모로 조금 빡세다. 유일한 낙은 언어의 다양한 특징들을 탐구하기 위해 <strong>ML</strong> 을 사용하고 <del>오오 갓 ML</del> , emacs 를 사용한다는 건데.. 잘 버틸수 있을까 의심스럽다. 무려 첫 강의부터 대략 300분이 넘는 동영상을 올려주시는 교수님 -_-;</p>

<p>미국 CS 전공자들은 모두 이렇게 빡세게 배우는가요 ㅠㅠ?</p>

<p><code>SML/nj</code> 와 Emacs 에 <code>sml-mode</code> 설치 후 시작한다. <code>c-c, c-s</code> 는 <code>REPL</code> 을 켠다. </p>

<h3 id="mlvariablebindingsandexpressions">ML Variable Bindings and Expressions</h3>

<pre><code class="sml">(* This is a comment. *)

val x = 34;  
(*: static env: x : int *)
(*: dynamic env: x --&gt; 34 *)
val y = 35 : int;  
val z = (x + y) + (y + 2);  
</code></pre>

<p>각 라인마다, <em>dynamic environment</em> 에 바인딩을 하나씩 추가한다. 따라서 세번 째 라인에서 <code>x</code> 와 <code>y</code> 를 <code>z</code> 를 바인딩하기 위해 사용할 수 있다.</p>

<p>그리고, <em>dynamic env</em> 에 바인딩을 추가하기 전에 <em>static enviornment</em> 에 <em>Type</em> 을 추가한다. 맨 처음엔 <code>x: int</code> 가 추가되고 <code>y</code> 와 값이 바인딩 되기 전에는 <code>x: int, y: int</code> 가 <em>static env</em> 에 추가된다.</p>

<p>따라서 매 라인마다 <em>type checking</em> 이 먼저 일어나고 그 후에야 프로그램이 <em>evaluated (excuted)</em> 된다. </p>

<p><em>ML</em> 에서 <code>if</code> 는 다음과 같이 작성할 수 있다. 다르 언어와 비슷하다.</p>

<pre><code class="sml">val abs_of_z = if z &lt; 0 then 0 - z else z;  
</code></pre>

<p>여기서 잠깐 <em>Syntax</em> 와 <em>Semantics</em> 를 정리하자면</p>

<blockquote>
  <p><strong>Syntax</strong> is just how you write something<br/></p>
  
  <p><strong>Semantics</strong> is what that something means<br/>
  - <em>Type-checking</em> (before program runs)<br/>
  - <em>Evaluation</em> (as program runs)  </p>
</blockquote>

<p><em>variable binding</em> 에서는, <em>type checking</em> 은 <em>static environment</em> 를 확장하고, <em>evaluation</em> 은 <em>dynamic environment</em> 를 확장한다.</p>

<h3 id="rulesforexpressions">Rules for Expressions</h3>

<p><em>expression</em> 은 <em>sub-expression</em> 을 가질 수 있기 때문에, <em>expression</em> 을 해석 하는데 있어서 3가지가 꼭 필요하다.</p>

<p>(1) <strong>Syntax</strong> <br />
(2) <strong>Type-checking rules:</strong> produces a type of fails <br />
(2) <strong>Evaluation rules:</strong> produces a value</p>

<p>다시 말하면 <em>Syntax</em> 와 <em>Semantics</em> 가 필요하단 이야기다.</p>

<h4 id="variables">Variables</h4>

<blockquote>
  <p><strong>Syntax:</strong> sequence of letters, digits, _, not starting with digit</p>
  
  <p><strong>Type-checking:</strong> look up type in current statix env if
  non there, fail</p>
  
  <p><strong>Evaluation:</strong> look up value in current dynamic env</p>
</blockquote>

<h4 id="addition">Addition</h4>

<p>Addition 의 경우에는 <em>sub-exp</em> 가 있을 수 있다.</p>

<blockquote>
  <p><strong>Syntax:</strong> <code>e1</code> + <code>e2</code> where <code>e1</code> and <code>e2</code> are expressions</p>
  
  <p><strong>Type-checking:</strong> if <code>e1</code> and <code>e2</code> have type <em>int</em> then <em>int</em></p>
  
  <p><strong>Evaluation:</strong> if <code>e1</code> evaluates to <code>v1</code> and <code>e2</code> evaluates to <code>v2</code>, then sum of <code>v1</code> and <code>v2</code></p>
</blockquote>

<h4 id="values">Values</h4>

<p>모든 <em>value</em> 는 <em>expression</em> 이다. 그러나 모든 <em>expression</em> 이 <em>value</em> 인 것은 아니다. 그리고,</p>

<blockquote>
  <p>Every value evaluates to itself in <strong>zero steps</strong></p>
</blockquote>

<p>참고로, <code>()</code> 는 <code>unit</code> 타입을 가진다.</p>

<h4 id="conditional">Conditional</h4>

<blockquote>
  <p><strong>Syntax:</strong> if <code>e1</code> then <code>e2</code> else <code>e3</code> where if, then, and else are keywords and <code>e1</code> <code>e2</code> and <code>e3</code> are sub-expressions</p>
  
  <p><strong>Type-checking:</strong> <code>e1</code> must have type <code>bool</code>. <code>e2</code> and <code>e3</code> can have any type, but they must have the same type</p>
  
  <p><strong>Evaluation:</strong> first evaluate <code>e1</code> to <code>v1</code>, if it's true evaluate <code>e2</code> and that resut is the whole expressions's result else evaluate <code>e3</code></p>
</blockquote>

<h3 id="replanderrors">REPL and Errors</h3>

<h4 id="use">use</h4>

<p><code>use</code> 는 특정 파일을 읽어 <em>binding</em> 하고 <code>it: unit</code> 을 돌려주는데, 이건 무시해도 된다. 그리고 같은 파일을 <code>use</code> 할때는 항상 <code>REPL</code> 을 다시 시작하자. <code>C-d</code>, <code>C-c, C-s</code></p>

<h4 id="error">Error</h4>

<p>대부분의 에러는 <em>syntax</em>, <em>type-checking</em>, <em>evaluation</em> 의 문제다.</p>

<h3 id="shadowing">Shadowing</h3>

<p>같은 변수에 대한 <em>multiple binding</em> 은 <em>poor style</em> 이다. 그러나 이를 통해 <em>environment</em> 와 <em>binding</em> 이 어떻게 동작하는지 알 수 있다.</p>

<pre><code class="sml">val a = 10;  
val b = a * 2  
val a = 5; (* this is not an assignment statement *)  
(* a -&gt; 5, b -&gt; 20 *)
val c = 2;  
(* a -&gt; 5, b -&gt; 20, c -&gt; 20 *)
</code></pre>

<p><code>val a = 5</code> 문장은, 할당하는게 아니라 <code>a</code> 를 <em>shadowing</em> 한다. <em>ML</em> 에서는 <em>mutate</em> 할 수 없다. 매번 새롭게 <em>dynamic env</em> 를 만든다.</p>

<pre><code class="sml">val d = a  
(* ..., d -&gt; 5 *)
val a =  a + 1  
(* ..., a -&gt; 6 *)
val f = a * 2  
</code></pre>

<p><code>use</code> 를 이용하면, 기존의 <code>a</code> 의 값이 <code>&lt;hidden-value&gt;</code> 로 나오는 것을 확인 할수 있다.</p>

<pre><code class="sml">val a = 1;  
val b = a;  
val a = 2;  
</code></pre>

<p>다음과 같은 예제가 있을 때, <code>b</code> 는 <code>1</code> 이다. <em>eagerly evaluated</em> 되어 바인딩 후에는 <code>value</code> 를 만든 <em>expression</em> 과는 관련이 없어진다. 다시 말해  바인딩 후에는 <code>a</code> 와 <code>b</code>는 상관이 없다.</p>

<p>그리고 위에서 언급 했듯이 <strong>ML</strong> 에서는 <em>assign to</em> 가 없고, 앞의 <code>a</code> 는 뒤의 <code>a</code> 에가 있는 <em>dynamic env</em> 에 의해서 가려질 뿐이다.</p>

<p>그렇기 때문에 <em>REPL</em> 을 재시작 하지 않고서 같은 파일을 여러번 <code>use</code> 하면 문제가 생길 수 있다고 교수님이 누차 말한 것</p>

<h3 id="functionsinformally">Functions Informally</h3>

<pre><code class="sml">fun pow (x: int, y: int) =  
  if y = 0
  then 1
  else x * pow(x, y-1)

fun cube(x: int)  
  pow(x, 3)
</code></pre>

<p>이 경우 두 함수 모두 타입은 <code>fn: int -&gt; int</code> 다. 타입을 이름 뒤에 사용하는것도 그렇고, 함수 타입도 그렇고 스칼라와 문법이 비슷한 것 같다.</p>

<p><code>*</code> 가 타입에 있을때는 곱셈이 아니라 <code>,</code> 같은 역할을 한다. 따라서 다음과 같이 <code>pow</code> 를 호출할 수 있다.</p>

<pre><code class="sml">val x : int * int = (2, 3)  
val y = pow x  
</code></pre>

<p>참고로, 함수를 사용한 후 정의하는 것은 불가능하다. 따라서 사용하는 <em>expression</em> 위에 함수를 정의해야 한다.</p>

<h4 id="recursion">Recursion</h4>

<p>재귀에 대해서도 간단히 언급을 하는데, 문제를 간단한 방법으로 나누어 푸는 좋은 기술이라고..</p>

<h3 id="functionsformally">Functions Formally</h3>

<p>우리가 <strong>Function</strong> 이 무엇인지 PL 에서 정의하려면 위에서 언급했듯이 <em>syntax</em> 와 <em>semantics</em> 가 필요하다. </p>

<blockquote>
  <p><strong>Syntax:</strong> <code>fun x0 (x1: t1, ... , xn: tn) = e</code></p>
  
  <p><strong>Evaluation:</strong> A function is a value. <code>x0</code> is added to <em>dynamic env</em></p>
  
  <p><strong>Type-checking:</strong> <code>(t1 *, ..., * tn) -&gt; t</code></p>
</blockquote>

<p>타입체킹이 조금 복잡한데, <code>e</code> 가 <code>t</code> 타입을 가지는지 검사하고, 파라미터도 마찬가지로 올바른 타입을 가지는지 검사한다.</p>

<p>다른 언어와 마찬가지로 <code>t1</code> 등의 파라미터는 <code>e</code> 를 위한 <em>environment</em> 에만 추가된다.</p>

<p><code>x0</code> 이 <em>dynamic</em>, <em>static env</em> 에 추가되므로 이후의 코드에서 <em>recursion</em> 을 사용할 수 있다.</p>

<h4 id="functioncalls">Function calls</h4>

<p><em>Function calls</em> 의 <em>syntax</em> 는 <code>e0 (e1, ..., en)</code> 이다. 만약에 인자가 하나라면 괄호(parentheses) 는 없어도 된다.</p>

<p>참고로 <strong>ML</strong> 에서는 <strong>variable numbers of arguments</strong> 를 함수에서 받을 수 없다. 인자의 개수가 정해져야 한다.</p>

<p><em>type-checking</em> 의 경우에는 , <code>e0</code> 이 <code>(t1 * ... * tn) -&gt; t</code> 인지 검사하고 <code>en</code> 이 <code>tn</code> 타입을 가지면, <code>e0</code> 은 <code>t</code> 타입이다. </p>

<p><em>Evaluation</em> 스텝은 다음과 같다.</p>

<p>(1) evaluate <code>e0</code> to <code>fun x0(x1: t1, ... , x: tn) = e</code> <br />
(2) evaluate arguments <code>e1</code>, ... , <code>en</code> to <code>v1</code>, ..., <code>vn</code> <br />
(3) extend <em>dynamic env</em> mapping <code>x1</code> to <code>v1</code> , ... , <code>xn</code> to <code>vn</code></p>

<p>두 번째 스텝에서는 <em>eager evaluation</em> 이 사용되는데 <code>pow(2, 2+2)</code> 같은 경우 인자가 <code>2, 4</code> 가 된다. </p>

<p>세 번째 스텝에서는 <em>dynamic environment</em> 를 확장하는데, 현재 함수인 <code>x0</code> 과 인자들인 <code>xn</code> 을 포함하도록 한다. 따라서 <em>recursion</em> 이 가능하다.</p>

<p>사실은 스칼라의 그것과 같은데 교재에 나온 설명이 너무 함축적이어서 이해하기가 어렵다.</p>

<h3 id="pairsandothertuples">Pairs and Other Tuples</h3>

<p>위에서 잠깐 보았던 <code>t1 * t2</code> 같은 것들이 <em>Pair</em> 다. 다른말로 <em>2-tuples</em> 라 부른다. </p>

<p><em>Syntax</em> 는 <code>(e1, e2)</code> 로 <em>Type-checking</em> 은 <code>e1</code> 과 <code>e2</code> 가 올바른 타입을 가졌는지 검사한다.</p>

<p><em>Pair</em> 에 접근할때는 <code>#1 e</code> 또는 <code>#2 e</code> 와 같은 <em>Syntax</em> 를 사용하고, <code>e</code>가 <code>t1 * t2</code> 타입인지, 그 후에 <code>#1 e</code> 가 <code>t1</code> 또는 <code>#2 e</code> 가 <code>t2</code> 타입을 가졌는지 검사한다.</p>

<pre><code class="sml">fun su_two_pairs (pr1: int * int, pr2: int* int) =  
  (#1 pr1) + (#2 pr1) + (#1 pr2) + (#2 pr2)
</code></pre>

<p>의 경우에는 타입이 <code>(int * int) * (int * int) -&gt; int</code> 된다. 그리고 다른 언어와 마찬가지로 <em>tuple</em> 도 겹칠 수 있다.</p>

<pre><code class="sml">val x1 = (7, (true, 9)) // int * (bool * int )  
val x2 = #1 (#2 x1) // true  
</code></pre>

<h3 id="introducinglists">Introducing Lists</h3>

<p><em>Tuple</em> 은 여러 타입을 가질 수 있지만, 정해진 갯수만큼의 element 만 저장할 수 있다. 반면 <em>List</em> 는 하나의 타입만 가져야 하지만, 원소의 갯수가 변할 수 이다.</p>

<p>빈 리스트는 <code>[]</code> 와 같이 만든다. <code>[3, 4, 5]</code> 는 <code>int list</code> 다. <code>[(1+2), 3, 7]</code> 과 같이 초기화하면 <code>[3, 3, 7]</code> 이 나온다. 리스트는 그 자체로 <em>value</em> 다.</p>

<p><code>::</code> 는 <em>cons</em> 라 발음하고, 다음과 같이 쓸 수 있다.</p>

<pre><code class="sml">val x = [3, 4, 5]  
val y = 2 :: x  
</code></pre>

<p><em>cons</em> 뒤에 오는것은 <code>List</code> 여야 한다. 리스트가 비었는지 검사하기 위해 <code>null</code> 을, <em>head</em> 를 얻기 위해 <code>hd</code> 를, <em>tail</em> 을 얻기 위해 <em>tl</em> 을 이용한다. 따라서 <code>tl [3, 4, 5]</code> 는 <code>[4, 5]</code> 를 돌려준다.</p>

<p>그리고 다른 함수형 언어와 마찬가지로 <code>tl [9]</code> 는 <code>[]</code>(<em>nil</em>) 이다.</p>

<p>리스트는 다양한 타입을 가질 수 있기 때문에 <code>(int * int) list</code> 같은 것도 타입이 될 수 있다. <code>[(3, 4), (5, 6)]</code> 처럼.</p>

<p><code>null</code> 은 <code>fn: a list -&gt; bool</code> 타입이고, 
<code>hd</code> 는 <code>fn: a list -&gt; a</code>, 
<code>tl</code> 은 <code>fn: a list -&gt; a list</code></p>

<p><code>[]: a list</code> 는 좀 특이한데, 다양한 타입이 될 수 있다. <code>3 :: []</code>, <code>false :: []</code> 이라던지.</p>

<h3 id="listfunctions">List Functions</h3>

<p>리스트를 조작하는 간단한 함수를 <em>ML</em> 로 몇 개 짜보자.</p>

<pre><code class="sml">fun pow(x: int, y: int) =  
    if y = 0 then 1 else x * pow(x, y - 1);

fun cube(x: int) =  
    pow(x, 3);

fun sum_list(xs: int list) =  
    if null xs
    then 0
    else hd xs + sum_list(tl xs)

fun product_list(xs: int list) =  
    if null xs
    then 1
    else hd xs * product_list(tl xs)

fun countdown(x: int) =  
    if x = 0
    then []
    else x :: countdown(x - 1)

fun append(xs: int list, ys: int list) =  
    if null xs
    then ys
    else (hd xs) :: append(tl xs, ys)

fun sum_pair_list(xs: (int * int) list) =  
    if null xs
    then 0
    else (#1 (hd xs)) + (#2 (hd xs)) + sum_pair_list(tl xs)

fun firsts(xs: (int * int) list) =  
    if null xs
    then []
    else #1 (hd xs) :: firsts(tl xs)

fun seconds(xs: (int * int) list) =  
    if null xs
    then []
    else #2 (hd xs) :: seconds(tl xs)

fun sum_pair_list(xs: (int * int) list) =  
    if null xs
    then 0
    else sum_list(firsts xs) + sum_list(seconds xs)

fun factorial(n : int) =  
    product_list(countdown(n))
</code></pre>

<p>참고로 <code>#</code> 이 <code>+</code> 이나 <code>::</code> 보다 우선순위가 높다.</p>

<h4 id="listrecursion">List Recursion</h4>

<p>재귀에 대해 생각할땐, 항상 명심해야 하는게 있는데 <strong>탈출 조건</strong> 이다. 따라서 empty-list 에 대해선 어떤걸 돌려줄지, non-empty-list 에 대해서는 무엇을 처리해야 할지 항상 생각해야 한다.</p>

<h3 id="letexpressions">Let Expressions</h3>

<p><code>let</code> 은 <em>local variable</em> 을 바인딩하는 법이다.</p>

<blockquote>
  <p><strong>Syntax:</strong> <code>let b1 b2 ... bn in e end</code>. Each <code>b1</code> is any <em>binding</em> and <code>e</code> is any expression</p>
  
  <p><strong>Type-checking:</strong> Type of whole let-expression is the type of e. Type-check each <code>b1</code> and <code>e</code> in a staic env that includes the previous bindings</p>
  
  <p><em>*Evaluation: *</em> evaluate each <code>b1</code> and <code>e</code> in a dynamic env that includes the previous bindings. Result of whole expression is result of evaluating <code>e</code></p>
</blockquote>

<pre><code class="sml">fun silly () =  
    let
      val x = 3
    in
      (let val x = 2 in x + 1 end) + (let val y = x + 1 in y + 1 end)
    end
</code></pre>

<p>여기서 <em>Scope</em> 의 개념이 나온다.</p>

<blockquote>
  <p><strong>Scope:</strong> Where a binding is in the environment</p>
</blockquote>

<h4 id="nestedfunctions">Nested Functions</h4>

<p><em>Function</em> 은 <em>binding</em> 이다. 따라서 <code>let</code> 내부에서 <em>local binding</em> 할 수 있다.</p>

<pre><code class="sml">fun count_from_1 (x: int) =  
    let
    fun count (from: int, to: int) =
        if from == to
        then []
        else from :: count(from + 1, to)
    in
    count(1, x)
    end
</code></pre>

<p>이렇게 하면 <em>top-level</em> 에서 <code>count</code> 는 사라진다. 그리고 엄밀히 말해서 <code>count</code> 가 가진 <em>environment</em> 에는 <code>to</code> 가 있기 때문에, <code>to</code> 를 인자로 가질 필요가 없다.</p>

<pre><code class="sml">fun count_from_1 (x: int) =  
    let
    fun count (from: int) =
        if from = x
        then []
        else from :: count(from + 1)
    in
    count(1)
    end
</code></pre>

<h3 id="letandefficiency">Let and Efficiency</h3>

<p>가장 큰 숫자를 찾는 다음의 함수를 고려 해 보자</p>

<pre><code class="sml">fun bad_max (xs : int list) =  
  if null xs
  then 0
  else if null (tl xs)
  then hd xs
  else if hd sx &gt; bad_max(tl xs)
  then hd xs
  else bad_max(tl xs)
</code></pre>

<p>이 함수는 <code>[1, 2, ... , 30]</code> 과 같은 리스트에 굉장히 나쁜 성능 <em>exponentially (2^30)</em> 을 보여준다. <code>bad_max(tl xs)</code> 를 두번 호출하기 때문이다. 따라서 <code>max(tl xs)</code> 를 변수로 놓아 캐싱하면</p>

<pre><code class="sml">fun good_max (xs: int list) =  
    if null xs then 0
    else if null (tl xs) then hd xs
    else
    let
        val res = good_max(tl xs)
    in
        if hd xs &gt; res then hd xs
        else res

    end
</code></pre>

<p><code>bad_max</code> 의 <code>if-then-else</code> 가 10^-7 정도의 시간이 든다고 하면, <code>[1, 2, ..., 55]</code> 는 100년이 넘게 걸린다. 따라서 재귀를 구현하는데 있어서 <em>local binding</em> 은 필수다.</p>

<h3 id="options">Options</h3>

<p>참고로, <code>good_max</code> 는 리스트가 모두 음수일때 <code>0</code> 을 돌려준다. 이건 리스트가 비었을때 <code>0</code> 을 돌려주기 때문에 생기는 문제인데, <code>0</code> 말고 다른 무언갈 돌려줄 수 없을까?</p>

<p><em>SML</em> 도 <em>Scala</em> 처럼 <em>Option</em> 을 지원한다.(물론 <em>SML</em> 이 먼저..) <code>NONE</code> 은 <code>a option</code> 타입이고, <code>SOME e</code> 는 <code>t option</code> 이다. <code>t</code> 는 <code>e</code> 의 타입.</p>

<p><em>Option</em> 을 이용해 <code>max</code> 를 리팩토링 해 보면,</p>

<pre><code class="sml">fun max1 (xs: int list) =  
  if null xs NONE
  else 
    let val res = max(tl xs)    
    in if isSome res andalso isVal res &gt; hd xs then res
       else Some(hd xs) 
    end
</code></pre>

<p>그런데, 이 <code>max1</code> 또한 문제가 있다. 사실 <code>[]</code> 는 리스트가 오름차순으로 구성되어있을때 (<code>[1, 2, 3, 4]</code>) 맨 마지막 호출에서만 오는데, 매번 <code>isSome</code> 으로 검사하니까 비효율적이다. 다시 리팩토링하면</p>

<pre><code class="sml">fun max2 (xs: int list) =  
    if null xs then NONE
    else
    let
        fun max_non_empty(ys: int list) =
        if null (tl ys) then hd ys
        else
            let val res = max_non_empty(tl ys)
            in if hd xs &gt; res then hd ys
               else res
            end
    in
        SOME (max_non_empty xs)
    end
</code></pre>

<p><del>교수님 <code>let in end</code> 는 제발그만 가..가독성이</del></p>

<h3 id="booleansandcomparisonoperations">Booleans and Comparison Operations</h3>

<p>다른 언어의 <em>&amp;&amp; (and)</em> 와 <em>|| (or)</em> <em>! (not)</em> 은 <em>SML</em> 에서는 <code>ansalso</code>, <code>orelse</code>, <code>not</code> 이다.</p>

<p>그리고 <code>andalso</code>, <code>orelse</code> 연산자는 다른 언어처럼 <em>Short circuiting</em> 을 제공한다. 함수가 아니다.   </p>

<p><code>andalso</code> 와 <code>orelse</code>, <code>not</code> 은 다음처럼 쓸 수도 있다.</p>

<pre><code class="sml">(* andalso *)
if e1  
then e2  
else false

(* orelse *)
if e1  
then true  
else e2

(* not *)
if e1  
then false  
else true  
</code></pre>

<p><code>if-then-else</code> 만 가지고도 할 수 있으나, 그냥 <code>andalso</code> 와 <code>orelse</code>, <code>not</code> 을 쓰는게 코드를 읽는 사람의 정신 건강에 좋다. </p>

<h4 id="comparisons">Comparisons</h4>

<p>비교의 경우엔 <code>==</code> 가 아니라 <code>=</code> 를 쓴다. <code>!=</code> 가 아니라 <code>&lt;&gt;</code> 를 쓴다. </p>

<p>그리고 <code>3.0 &gt; 2</code> 와 같은 비교는 안된다.<code>3.0</code> 은 <code>real</code> 이고, <code>2</code> 는 <code>int</code> 다 <code>Real.fromInt</code> 를 이용하자.</p>

<h3 id="nomutation">No Mutation</h3>

<p>교수님이 <em>A valuable non-feature</em> 라고 이야기 하시는데, 기능이 없는게 장점이라고.. <em>SML</em> 에서는 아래의 두 코드가 같다. (<em>inditinguishable</em>)</p>

<pre><code class="sml">fun sort_pair(pr: int * int) =  
  if #1 pr &lt; #2 pr then pr
  else (#2 pr, #1 pr)

fun sort_pair(pr: int * int) =  
  if #1 pr &lt; #2 pr then (#1 pr, #2pr)
  else (#2 pr, #1 pr)
</code></pre>

<p>위가 더 나은 <em>style</em> 이라고 주장할 순 있지만, 다르다고 말할 순 없다. 그러나 <em>mutable compound data</em> 를 다루는 다른 언어에서는 위 두 함수는 다르다</p>

<p>예를 들어서 <em>mutable data</em> 를 다루는 언어라 가정하고 다음의 코드를 고려 해 보자.</p>

<pre><code class="sml">val x = (3, 4)  
val y = sort_pair x

(* somehow mutate #1 x to hold 5 *)

val z = #1 y  
</code></pre>

<p>이제 <code>z</code> 의 값은 무엇일까? <code>sort_pair</code> 구현에 따라 다르다. <code>then</code> 에서 <code>pr</code> 을 돌려줬다면, <code>5</code> 일거고, <code>(#1 pr, #2 pr)</code> 을 돌려줬다면 <code>3</code> 일거다. 그러나 <em>ML</em> 에선 문제가 안된다. <em>immutable</em> 하니까. <del>오오 immutable 오오</del></p>

<blockquote>
  <p>But <strong>without mutation</strong>, we can implement either way <br/><br/>
  - No code can ever distinguishe aliasing vs identical copies <br />
  - No need to think about aliasing: focus on other things <br />
  - Can use aliasing, which saves space, without danger</p>
</blockquote>

<p><em>ML</em> 에서는 <code>tl</code> 이 상수 시간내에 이뤄진다. 첫번째 원소를 제외한 나머지를 가리키기만 하면 되니까. 어차피 그 데이터는 <em>immutable</em> 이니까 그냥 쓰기만 하면 된다. 변경이 필요하면, 그 때 새로 만들면 된다.</p>

<h3 id="javamutation">Java Mutation</h3>

<pre><code class="java">public String[] getAllowedUsers() {  
  // return a references of allowedUsers
}
</code></pre>

<p><code>allowedUsers</code> 자체가 <code>private</code> 여도, 다음과 같은 코드에 취약하다.</p>

<pre><code class="java">p.getAllowedUsers()[0] = p.currentUser();  
p.useTheResource();  
</code></pre>

<p>따라서 위의 <code>getAllowedUsers</code> 는 <em>copy</em> 를 돌려줘야한다. </p>

<p><em>ML</em> 같은 <em>immutable</em> 한 언어에서는 <em>Reference (Alias)</em> vs <em>Copy</em> 는 문제가 안된다.</p>

<h3 id="piecesofalanguage">Pieces of a Language</h3>

<p>언어를 배울때는 다음의 다섯가지를 고려해야한다.</p>

<p>(1) <strong>Syntax:</strong> How do you write language constructs? <br />
(2) <strong>Semantics:</strong> What do programs mean? (Evaluation rules) <br />
(3) <strong>Idioms:</strong> What are typical patterns for using language features to express your computation <br />
(4) <strong>Libraries:</strong> What facilities does the language provide <strong>standard</strong>? <br />
(5) <strong>Tools:</strong> What do language implementations provide to make your job easier? (REPL debugger..)  </p>

<p>다시 말하면 다섯가지를 모두 배워야 한다. 언어의 코어부터 그 확장인 라이브러리와 툴까지. 그러나 이 코스에서는 <em>Semantics</em> 와 <em>Idioms</em> 에 집중한다. <em>ML</em> 을 고른것도 그 이유고, 이걸 잘 이해하게 되면 <em>Libraries</em> 가 어떻게 구성되었는지 더 잘 이해할 수 있다.</p>

<h3 id="summary">Summary</h3>

<p>처음엔 재귀가 어려웠는데, 시간이 지날수록 재귀가 얼마나 재밌고 강력한지 알게 된다. 함수를 <em>building block</em> 처럼 조립하는것도 너무 재밌고</p>

<p>Lisp 을 이용했으면 개인적 취향에 맞아 더 재밌게 배울 수 있었을텐데. 나중에 수업이 모두 끝났을때 <em>ML</em> 을 고른 이유를 느낄 수 있었으면 좋겠다.</p>

<p>그리고 Emacs <em>sml-mode</em> 가 좀.. 음.. 빈약한데 더 좋은걸 찾아야겠다. <em>MELPA</em> 엔 없던데.. 테스팅 프레임워크도 좀 찾아서 해보고. </p>]]></description><link>http://1ambda.github.io/programming-language-week1/</link><guid isPermaLink="false">30e30421-f55b-48df-b96b-a19a661c143f</guid><category><![CDATA[coursera]]></category><category><![CDATA[programming language]]></category><category><![CDATA[ml]]></category><category><![CDATA[emacs]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 10 Oct 2014 06:26:00 GMT</pubDate></item><item><title><![CDATA[Machine Learning, Week 2]]></title><description><![CDATA[<p><strong>Machine Learning</strong> by Andrew Ng, <em>Coursera</em></p>

<h2 id="linearregressionwithmultiplevariables">Linear Regression with Multiple Variables</h2>

<h3 id="mutiplefeatures">Mutiple Features</h3>

<p>변수가 적을때는 <em>Hypothesis</em> 가 간단하다. 많으면 어떻게 될까? <em>Feature</em> 가 <code>N+1</code> 개라면,</p>

<p><img src='http://bt22dr.files.wordpress.com/2013/05/04_2.png?w=300&amp;h=19'  align="center" />  </p>

<p align="center"><a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com</a></p>

<p>편의상 <code>x_0 = 1</code> 이라 두면, <em>Hypothesis</em> 는 <em>Zero-based index</em> 인 <code>n+1</code> 벡터 <code>h</code> 와 <code>x</code> 의 곱이다. 따라서 <code>h(x) = h_t * x</code> 로 표기할 수 있다. 이걸 <strong>Mutivariate linear regression</strong> 이라 부른다.</p>

<h3 id="gradientdescentformultiplevariables">Gradient Descent for Multiple Variables</h3>

<p><em>Cost function</em> 은 다음과 같다. 변수의 subscript 는 <code>j</code> 번째 <em>Feature</em> 를, superscript 는 <code>i</code> 번째 데이터임을 말한다.</p>

<p><img src='http://bt22dr.files.wordpress.com/2013/05/04_6.png'  align="center" />  </p>

<p align="center">(<a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com/</a>)</p>  

<p><br/></p>

<p>다음은 <em>Gradient Descent</em> 알고리즘을 구하는 정의다.</p>

<p><img src='http://bt22dr.files.wordpress.com/2013/05/04_7.png?w=300&amp;h=104'  align="center" />  </p>

<p align="center">(<a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com/</a>)</p>  

<p><br/></p>

<p>따라서</p>

<p><img src='http://bt22dr.files.wordpress.com/2013/05/04_8.png?w=630&amp;h=354'  align="center" />  </p>

<p align="center">(<a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com/</a>)</p>

<h3 id="featurescaling">Feature Scaling</h3>

<p><em>Feature</em> 간 데이터 크기가 많이 차이가 나면, <em>Gradient Descent</em> 에서 등고선 간 간격이 좁으므로, <em>Global optima</em> 를 찾는데 오래걸릴 수 있다. 따라서 <em>Feature</em> 값을 <code>m</code> 으로 나누거나  -1 과 1 사이로 <em>scaliing</em> 할 수 있다. 거꾸로 말하면, <em>Feature scaling</em> 을 이용하면 <em>Gradient descent</em> 가 결과값을 더 빠르게 찾는다.</p>

<p><img src='http://i.stack.imgur.com/4RBjR.png'  align="center" /></p>

<p>또한 <strong>Mean normalization</strong> 을 이용할 수 있는데, 모든 <em>feature</em> 에서 평균을 빼서, 평균을 0 으로 만드는 방법이다.</p>

<p>더 일반적인 방법은 <em>mean normalization</em> 을 하고, 거기에 <code>max-min</code> 또는 <em>standard deviation</em> 으로 나누는 방법이다.</p>

<h3 id="learningrate">Learning Rate</h3>

<p>디버깅 팁 중 하나는, 우리가 작성한 <em>Gradient descent</em> 알고리즘이 매 <em>interation</em> 마다 줄어들어야 한다는 것이다.</p>

<p><img src='http://d37rcl8t6g8sj5.cloudfront.net/wp-content/uploads/gradient_descent_error_by_iteration.png'  align="center" />  </p>

<p align="center">(<a href='http://spin.atomicobject.com/' >http://spin.atomicobject.com</a>)</p>

<p>그리고, 어느 지점에선가 <em>converged</em> 되는지 검사하기 위해 <em>automatic convergence test</em> 를 사용할 수 있다. 예를 들어 한 이터레이션에서, 10^-3 보다 적게 줄어드는지 검사한다거나.</p>

<p>만약에 <em>gradient descent</em> 값이 증가하면, 더 작은 <em>learning rate</em> 를 사용해라. 그렇다고 너무 작은 값을 사용하면 <em>gradient descent</em> 가 느리게 수렴할 수 있다. <em>learning rate</em> 가 너무 크면, 심지어 수렴하지 않을 수도 있다.</p>

<p>따라서 <em>learning rate</em> 를 <code>0.001</code>, <code>0.003</code>, <code>0.01</code>, <code>0.03</code>, <code>0.1</code>, <code>0.3</code>, <code>1</code> 처럼 작은 것부터 선택하되, 천천히 늘려가는 것이 좋다.</p>

<h3 id="polynomialregression">Polynomial Regression</h3>

<p>집값을 예측하기 위해 두개의 <em>feature</em>, <code>frontage</code> 와 <code>depth</code> 가 있다고 하자. 두 값을 곱해 <code>area</code> 라는 새로운 <em>feature</em> 를 만들면, <em>Hypothesis</em> 가 간단해진다. 따라서 기존의 <em>feature</em> 를 이용 할 수 있는지도 잘 알아보는 게 좋다.</p>

<p>자 이제, 집 값(Housing prices) 을 예측하기 위해 <em>Size(Area)</em> 라는 <em>feature</em> 를 이용한다 하자. <em>training set</em> 이 다음과 같을때, </p>

<p><img src='http://www.holehouse.org/mlclass/01_02_Introduction_regression_analysis_and_gr_files/Image.png'  align="center" />  </p>

<p align="center"><a href='http://www.holehouse.org/mlclass' >http://www.holehouse.org/mlclass</a></p>  

<p><br/></p>

<p><em>hypothesis</em> 를 <em>quadratic</em> 로 세우면 어느 지점부터는 예측된 값이 감소하므로 <em>traning set</em> 과 일치하지 않는다. 따라서 <em>cubic</em> 다항식을 이용해 볼 수 있겠는데, <em>feature</em> 가 <code>size</code> 하나 뿐이므로, <em>hypothesis</em> 는 <code>size</code> 를 이용한 삼차식이 되겠다.</p>

<p><img src='http://www.holehouse.org/mlclass/04_Linear_Regression_with_multiple_variables_files/Image%20' [10].png" align="center" />  </p>

<p align="center"><a href='http://www.holehouse.org/mlclass' >http://www.holehouse.org/mlclass</a></p>

<p>이 경우 <code>size</code> 하나로 3개의 <em>feature</em> 를 만들었으니, <em>scaling</em> 이 문제가 될 수 있다.</p>

<p>이 전에 앞서서 <em>feature</em> 가 두개인 <em>hypothesis</em> (quadratic) 은 말이 안된다고 했는데, 두개지만 <em>square</em> 모델을 사용하면 우리가 가진 <em>training set</em> 과 얼추 맞아 떨어지는 모델을 찾을 수 있다. 그림이 없어서 대충 식을 첨부하면,</p>

<p><code>h(x) = y0 + y1(size) + y2 * square(size)</code></p>

<p>여기서 <code>y</code> 는 강의에서 말하는 <code>0(theta)</code> 라 보면 된다.</p>

<h3 id="nomalequation">Nomal Equation</h3>

<p><em>gradient descent</em> 는 반복하면서 특정 값에 수렴해 가는 알고리즘 이었지만 <strong>normal equation</strong> 은 그냥 <code>J(0)</code> 식을 풀어버려 값을 찾아낸다.</p>

<p>예를 들어서 <code>J(0)</code> 가 <code>0(theta)</code> 에 대해  <em>quadratic</em> 이면, <code>0</code> 에 대해 미분해서 최저점을 찾아내면 된다. 문제는, <code>0</code> 가 여러개 일때, 모든 <code>0_j</code> 에 대해 <em>cost function</em> 을 풀어야 한다는 것이다. <em>partial derivative</em> 를 이용해서 해를 찾으면 된다.</p>

<p><img src='http://www.longhaiqiang.com/wp-content/uploads/2013/08/Snip20130817_44.png'  align="center" />  </p>

<p align="center">(<a href='http://www.longhaiqiang.com/' >http://www.longhaiqiang.com/</a>)</p>  

<p><br/></p>

<p>행렬을 이용할 수도 있다. 자세한 건 강의 내용을 보자, <em>design matrix</em> 라고 부르는 <code>X</code> 를 만들어서 아래의 식을 구하면 된다. 사실 <code>X</code> 는 그냥 <em>feature</em> 들을 있는 그대로 행렬로 만들면 된다. 맨 앞에 <code>x0</code> 만 추가해서. </p>

<p><img src='http://www.longhaiqiang.com/wp-content/uploads/2013/08/Snip20130817_41.png'  align="center" />  </p>

<p align="center">(<a href='http://www.longhaiqiang.com/' >http://www.longhaiqiang.com/</a>)</p>

<p>참고로, 저 식을 <em>Octave</em> 에서는 다음과 같이 계산한다.</p>

<pre><code class="octave">pinv(X`*X)*X`*y  
</code></pre>

<p><br/></p>

<p><em>normal equation</em> 을 이용할때는 <em>feature scaling</em> 을 하지 않아도 괜찮다. <em>gradient descent</em> 와 비교해 보자면,</p>

<blockquote>
  <p><strong>Gradient Descent:</strong> <br/>
  (1) <em>learning rate</em> 를 골라야 한다. 
  (2) <em>feature scaling</em> 을 해야할 필요가 있다. <br />
  (3) <em>interation</em> 을 해야하므로 알고리즘이 제대로 돌아가는지 체크해야할 필요가 있다. <br />
  (4) 대신 <code>n</code> 이 커도 잘 돌아간다.</p>
  
  <p><strong>Normal Equation:</strong> <br/>
  (1) <em>learning rate</em> 를 고를 필요가 없다. <br />
  (2) <em>feature scaling</em> 을 해야할 필요가 없다. <br />
  (3) <em>interation</em> 을 하지 않는다. <br />
  (4) <code>n</code> 이 커질경우 굉장히 느려지고 <code>(X^TX)^-1)</code> 을 계산해야 한다.</p>
</blockquote>

<p>따라서 <code>n</code> 이 너무 크지 않으면, 100~1000 정도까지는, <em>normal equation</em> 을 쓰는편이 낫다.</p>

<h3 id="nomalequationnoninvertibility">Nomal Equation Noninvertibility</h3>

<p>만약에, 우리가 가진 <code>X</code> 가 <em>non-invertible</em> 하다면 어떻게 될까? <em>invertible matrix</em> 란, 아래를 만족시키는 <code>B</code> 가 존재하는 행렬이다. <code>I</code> 는 <em>identity matrix</em> 다.</p>

<p><img src='http://upload.wikimedia.org/math/7/3/3/7334597613ae1773c19e1ed1289349db.png'  align="center" />  </p>

<p align="center">(<a href='http://en.wikipedia.org/wiki/Invertible_matrix' >http://en.wikipedia.org/wiki/Invertible_matrix</a>)</p>

<p>만약 저런 <code>B</code> 가 존재하지 않아 <em>non-invertible</em> 한 행렬을 <strong>sigular matrix</strong>, <strong>degenerate matrix</strong> 라 부른다.</p>

<p>우리가 계산해야 할 행렬이 <em>non-invertible</em> 이라면, 두 가지 경우가 있을 수 있는데, </p>

<p>(1) Redundant features(linearly dependent) e.g <code>x1 = (3.28) * x2</code> <br />
(2) too many features e.g <code>m &lt;= n</code></p>

<p>이럴 때는 몇몇 <em>feature</em> 를 삭제하고, <em>regulaization</em> 을 하면 된다. </p>

<h3 id="costfunctionoctave">Cost Function: Octave</h3>

<p><em>cost function</em> 을 구현 해 보면</p>

<pre><code class="matlab">function J = costFunctionJ(X, y, theta)

m = size(X, 1) % number of training examples  
predictions= X * theta; % predictions of hypothesis on all m examples  
sqrErros = (predictions-y).^2;

J = 1 / (2*m) * sum(sqrErros);  
</code></pre>

<p><em>R</em> 이나 이런것들은 행렬연산이 참 쉬운것 같다.</p>

<h3 id="vectorization">Vectorization</h3>

<p><em>Vectorization</em> 을 이용하면, <code>for loop</code> 을 제거할 수 있는데, 예를 들어</p>

<p><img src='http://i.ytimg.com/vi/jRr2XuZOWB8/hqdefault.jpg'  align="center" /></p>

<p>이건 행렬 곱셈이 한번에 이루어진다는 것을 이용한 방법이다. 따라서 <em>gradient descent</em> 알고리즘에서 <code>theta</code> 를 <code>for-loop</code> 으로 구하는 것이 아니라, <em>vectorization</em> 을 이용하면 한번에 계산할 수 있다.</p>

<p>이게 그림을 구하기가 어려운데, 아래첨자(sub-script) 를 이렇게 기술한다고 하자. <code>x_0</code> 그럼, <em>grandient descent</em> 알고리즘 식에서 <em>learning rate</em> 뒷부분이 <em>vector</em> 가 되는데 그 이유는 <code>theta</code> 와 마찬가지로 <code>j</code> 에 대한 나열이기 때문이다.</p>

<p><img src='http://2.bp.blogspot.com/-ZxJ87cWjPJ8/TtLtwqv0hCI/AAAAAAAAAV0/9FYqcxJ6dNY/s1600/gradient+descent+algorithm+OLS.png'  align="center" /></p>

<p>구글에 검색하니까 1번으로 뜨는게 <em>vectorization(parallel computing)</em> 이더라. 병렬 연산에 많이 사용되나보다.</p>

<h3 id="refenrences">Refenrences</h3>

<p>(1) <a href='http://stats.stackexchange.com/questions/111467/is-it-necessary-to-scale-the-target-value-in-addition-to-scaling-features-for-re' >StackExchange</a> <br />
(2) <a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com/</a> <br />
(3) <a href='http://spin.atomicobject.com/2014/06/24/gradient-descent-linear-regression/' >http://spin.atomicobject.com</a> <br />
(4) <a href='http://www.holehouse.org/mlclass/01_02_Introduction_regression_analysis_and_gr.html' >http://www.holehouse.org/mlclass/</a> <br />
(5) <a href='http://www.longhaiqiang.com/' >http://www.longhaiqiang.com/</a>  </p>]]></description><link>http://1ambda.github.io/machine-learning-week-2/</link><guid isPermaLink="false">78e8635f-a298-477a-8823-0c2738c21251</guid><category><![CDATA[coursera]]></category><category><![CDATA[machine lerning]]></category><category><![CDATA[gradient descent]]></category><category><![CDATA[normal equation]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 08 Oct 2014 10:50:00 GMT</pubDate></item></channel></rss>