<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Old Lisper]]></title><description><![CDATA[Functional Programming World]]></description><link>http://1ambda.github.io/</link><generator>Ghost 0.7</generator><lastBuildDate>Fri, 15 Apr 2016 00:09:43 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Redux 와 Webpack 을 사용할 때 알아두면 도움이 될 9 가지]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/redux/redux_logo.png" alt=""></p>

<p>지난 한달 동안 자그마한 웹앱 프로젝트를 Redux 를 이용해서 진행했습니다. 그 과정에서 배운 몇 가지를 적었습니다.</p>

<p><a href="http://1ambda.github.io/tips-redux-and-webpack/#1combinereducersreducer">Redux: 1. combineReducers 를 이용해 Reducer 를 잘게 분해하기</a> <br>
<a href="http://1ambda.github.io/tips-redux-and-webpack/#2reduceractionactiontype">Redux: 2. Reducer 에서는 관련있는 Action 만 처리하기</a> <br>
<a href="http://1ambda.github.io/tips-redux-and-webpack/#3reduxinternal">Redux: 3. redux internal 이해하기</a> <br>
<a href="http://1ambda.github.io/tips-redux-and-webpack/#4reduxsaga">Redux: 4. redux-saga 사용하기</a> <br>
<a href="http://1ambda.github.io/tips-redux-and-webpack/#5api">Redux: 5. API 호출 실패에 대한 액션을 여러개</a></p>]]></description><link>http://1ambda.github.io/tips-redux-and-webpack/</link><guid isPermaLink="false">1877a1e2-c38b-4f1f-88ec-28d4e3edcd13</guid><category><![CDATA[redux]]></category><category><![CDATA[redux-saga]]></category><category><![CDATA[webpack]]></category><category><![CDATA[js]]></category><category><![CDATA[es6]]></category><category><![CDATA[babel]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 14 Apr 2016 04:36:24 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/redux/redux_logo.png" alt=""></p>

<p>지난 한달 동안 자그마한 웹앱 프로젝트를 Redux 를 이용해서 진행했습니다. 그 과정에서 배운 몇 가지를 적었습니다.</p>

<p><a href="http://1ambda.github.io/tips-redux-and-webpack/#1combinereducersreducer">Redux: 1. combineReducers 를 이용해 Reducer 를 잘게 분해하기</a> <br>
<a href="http://1ambda.github.io/tips-redux-and-webpack/#2reduceractionactiontype">Redux: 2. Reducer 에서는 관련있는 Action 만 처리하기</a> <br>
<a href="http://1ambda.github.io/tips-redux-and-webpack/#3reduxinternal">Redux: 3. redux internal 이해하기</a> <br>
<a href="http://1ambda.github.io/tips-redux-and-webpack/#4reduxsaga">Redux: 4. redux-saga 사용하기</a> <br>
<a href="http://1ambda.github.io/tips-redux-and-webpack/#5api">Redux: 5. API 호출 실패에 대한 액션을 여러개 만들지 않기</a> <br>
<a href="http://1ambda.github.io/tips-redux-and-webpack/#6jestmocha">Webpack: 6. 테스팅 프레임워크로 jest 대신 mocha 사용하기</a> <br>
<a href="http://1ambda.github.io/tips-redux-and-webpack/#7postcss">Webpack: 7. postcss 를 사용할 경우, 테스팅 환경에서 스타일파일 무시하기</a> <br>
<a href="http://1ambda.github.io/tips-redux-and-webpack/#8defineplugin">Webpack: 8. DefinePlugin 을 이용해 클라이언트 파일에 환경변수 주입하기</a> <br>
<a href="http://1ambda.github.io/tips-redux-and-webpack/#9jsonserver">Etc: 9. json-server 사용하기</a>  </p>

<h2 id="redux">Redux</h2>

<h3 id="1combinereducersreducer">1. combineReducers 를 이용해 Reducer 를 잘게 분해하기</h3>

<p>Root Reducer 가 <code>JobReducer</code> 를 포함하고 있고, <code>JobReducer</code> 는 Job 과 관련된 모든 상태를 다룬다고 할 때 다음처럼 <code>combineReducers</code> 를 이용해서 <code>JobReducer</code> 를 분해하면, 개별 컴포넌트의 상태(<em>State</em>) 는 각각의 서브 리듀서 (이하 핸들러) 에서 다루면 됩니다.</p>

<pre><code class="language-javascript">// https://github.com/1ambda/slott/blob/master/src/reducers/JobReducer/index.js

import { combineReducers, } from 'redux'

import * as JobItemState from './JobItemState'  
import * as PaginatorState from './PaginatorState'  
import * as FilterState from './FilterState'  
import * as SorterState from './SorterState'  
...

export const JOB_STATE_PROPERTY = {  
  JOB_ITEMS: 'items',
  PAGINATOR: 'paginator',
  FILTER: 'filterKeyword',
  SORTER: 'sortingStrategy',
  ...
}

export default combineReducers({  
  [JOB_STATE_PROPERTY.CONTAINER_SELECTOR]: ContainerSelectorState.handler,
  [JOB_STATE_PROPERTY.JOB_ITEMS]: JobItemState.handler,
  [JOB_STATE_PROPERTY.PAGINATOR]: PaginatorState.handler,
  [JOB_STATE_PROPERTY.FILTER]: FilterState.handler,
  [JOB_STATE_PROPERTY.SORTER]: SorterState.handler,
  ...
})
</code></pre>

<pre><code class="language-javascript">// https://github.com/1ambda/slott/blob/master/src/reducers/JobReducer/FilterState.js

import { createAction, handleActions, } from 'redux-actions'

const INITIAL_STATE = '' /** initial state of FilterState */

export const ActionType = {  
  FILTER: 'JOB_FILTER',
  INITIALIZE_FILTER: 'JOB_INITIALIZE_FILTER',
}

export const Action = {  
  filterJob: createAction(ActionType.FILTER),
  initializeFilter: createAction(ActionType.INITIALIZE_FILTER),
}

export const handler = handleActions({  
  [ActionType.FILTER]: (state, { payload, }) =&gt;
    payload.filterKeyword, /** since string is immutable. we don't need to copy old state */

  [ActionType.INITIALIZE_FILTER]: (state, { payload, }) =&gt;
    INITIAL_STATE,
}, INITIAL_STATE)
</code></pre>

<h3 id="2reduceractionactiontype">2. Reducer, Action, ActionType 을 한 파일로 모으기</h3>

<p><a href="http://1ambda.github.io/tips-redux-and-webpack/">Redux Github</a> 에 나와있는 예제에서는 <code>ActionType</code> 과 <code>Action</code> 을 하나의 파일에 모아놓는데, 프로젝트가 커질수록 부담스럽습니다.</p>

<p><code>Action</code>, <code>ActionType</code>, <code>Handler</code> 를 한 파일에 모아놓으면 이 핸들러가 어떤 일들을 하는지, 페이로드는 무엇인지 한 눈에 파악할 수 있습니다. </p>

<pre><code class="language-javascript">// https://github.com/1ambda/slott/blob/master/src/reducers/JobReducer/PaginatorState.js

import { createAction, handleActions, } from 'redux-actions'

import { PAGINATOR_ITEM_COUNT_PER_PAGE, } from '../../constants/config'

import * as FilterState from './FilterState'  
import * as SorterState from './SorterState'

const INITIAL_PAGINATOR_STATE = {  
  currentPageOffset: 0,
  currentItemOffset: 0,
  itemCountPerPage: PAGINATOR_ITEM_COUNT_PER_PAGE,
}

export const ActionType = {  
  CHANGE_PAGE_OFFSET: 'JOB_CHANGE_PAGE_OFFSET',
}

export const Action = {  
  changePageOffset: createAction(ActionType.CHANGE_PAGE_OFFSET),
}

export const handler = handleActions({  
  [ActionType.CHANGE_PAGE_OFFSET]: (state, { payload, }) =&gt; {
    const { newPageOffset, } = payload
    const currentItemOffset = newPageOffset * state.itemCountPerPage
    return Object.assign({}, state, {currentPageOffset: newPageOffset, currentItemOffset,})
  },

  /** reset paginator if filter or sorter action is occurred */
  [SorterState.ActionType.SORT]: (state) =&gt; INITIAL_PAGINATOR_STATE,
  [FilterState.ActionType.FILTER]: (state) =&gt; INITIAL_PAGINATOR_STATE,
}, INITIAL_PAGINATOR_STATE)
</code></pre>

<p><code>Paginator</code> 가 어떤 액션을 처리하고, 페이로드는 무엇인지 하나의 파일에서 확인할 수 있습니다.</p>

<h3 id="3reduxinternal">3. redux internal 이해하기</h3>

<p><a href="https://github.com/reactjs/redux">redux</a> 의 놀라운 점중 하나는 소스코드가 길지 않다는 점입니다. 따라서 내부 구조를 이해하기도 어렵지 않은데요,</p>

<p><a href="http://briantroncone.com/?p=529">Redux Middleware: Behind the Scenes</a> 를 참고하면, <em>enhancer</em> 가 어떻게 조합되고, <em>store</em> 가 어떻게 생성되는지 쉽게 알 수 있습니다.</p>

<h3 id="4reduxsaga">4. redux-saga 사용하기</h3>

<p><a href="https://github.com/yelouafi/redux-saga">redux-saga</a> 를 이용하면 <code>Promise</code> 가 들어가는 비동기 로직을 <a href="https://tc39.github.io/ecmascript-asyncawait/">ES7 async</a> 를 이용하는것처럼 작성할 수 있습니다. 추가적으로 사이드이펙트 (e.g API call) 의 선언과 실행 시점을 분리해 테스트를 쉽게 할 수 있도록 도와줍니다.</p>

<p>예를 들어, 초기화 시점에 서버로부터 전체 Job 을 가져오는 로직을 <a href="https://github.com/yelouafi/redux-saga">redux-saga</a> 를 이용해 다음처럼 작성할 수 있습니다.</p>

<pre><code class="language-javascript">// https://github.com/1ambda/slott/blob/master/src/middlewares/sagas.js#L12

import { fork, call, put, } from 'redux-saga/effects'

import * as SnackbarState from '../reducers/JobReducer/ClosableSnackbarState'  
import * as Handler from './handler'

export function* initialize() {  
  try {
    yield call(Handler.callFetchContainerJobs)
  } catch (error) {
    yield put(
      SnackbarState.Action.openErrorSnackbar(
        { message: 'Failed to fetch jobs', error, }
      )
    )
  }
}
</code></pre>

<p>위 코드는 서버로부터 모든 Job 을 가져오고, 그 과정에서 예외가 발생하면 Snackbar 에 예외메세지를 출력하는 Action 을 Reducer 로 보내는 코드입니다. (여기서 <code>Handler.callFetchContainerJobs</code> 가 <code>Promise</code> 를 돌려준다고 보고)</p>

<p>이 때 다음처럼 테스트를 작성할 수 있습니다.</p>

<pre><code class="language-javascript">// https://github.com/1ambda/slott/blob/master/src/middlewares/__tests__/sagas.spec.js#L87

  describe('initialize', () =&gt; {
    it('should callFetchContainerJobs', () =&gt; {
      const gen = Sagas.initialize()
      expect(gen.next().value).to.deep.equal(
        call(Handler.callFetchContainerJobs)
      )

      expect(gen.next().done).to.deep.equal(true)
    })

    it(`should callFetchJobs
        - if exception is occurred,
          put(openErrorSnackbar with { message, error }`, () =&gt; {
      const gen = Sagas.initialize()

      expect(gen.next().value).to.deep.equal(
        call(Handler.callFetchContainerJobs)
      )

      const error = new Error('error')
      expect(gen.throw(error).value).to.deep.equal(
        put(ClosableSnackBarState.Action.openErrorSnackbar({ message: 'Failed to fetch jobs', error, }))
      )
    })
  })
</code></pre>

<p>위 테스트 코드에서 알 수 있듯이, <code>redux-saga/effects</code> 의 <code>call</code> 을 호출하는 시점에서 AJAX 이 실행되지 않습니다. 실제로는 <code>call</code> 은 AJAX 실행할것임을 <strong>선언</strong> 만 합니다. AJAX 은 <code>call</code> 로 부터 생성된 redux 액션이 <code>redux-saga</code> 미들웨어에서 처리되는 순간에 <strong>실행</strong> 됩니다. <code>call</code> 의 리턴값은, 어떤 redux 액션이 실행될 것인지 알려주는 자바스크립트 객체입니다. 위에서는 이 리턴값을 이용해 테스트를 작성한 것입니다.</p>

<pre><code>// https://github.com/yelouafi/redux-saga/blob/master/docs/basics/DeclarativeEffects.md


{
  CALL: {
    fn: Handler.callFetchContainerJobs,
    args: []  
  }
}
</code></pre>

<h3 id="5api">5. API 호출 실패에 대한 액션을 여러개 만들지 않기</h3>

<p>redux 나 <a href="https://github.com/yelouafi/redux-saga/blob/ce1d701467d2ec4e8c5c40288d9a41254c6f3583/examples/real-world/actions/index.js">redux-saga 예제</a> 를 보면, API 실패에 대한 액션을 여러 종류로 만드는 것을 알 수 있습니다.</p>

<p>그러나 일반적으로 예외는 단일화된 방식으로 (e.g 에러 다이어로그, 팝업, 페이지 등) 처리되기 때문에 에러를 다룰 UI 컴포넌트에 대한 1개의 액션만 만드는 것이 더 바람직 합니다. 예를 들어 Snackbar 에서 예외 메세지를 보여준다고 할 때 다음처럼 액션 핸들러를 작성할 수 있습니다.</p>

<pre><code class="language-javascript">// https://github.com/1ambda/slott/blob/e2fc9c1260a5c8202ad747c31f5907ff29ab9a94/src/reducers/JobReducer/ClosableSnackbarState.js#L27

export const handler = handleActions({  
  /** snackbar related */
  [ActionType.CLOSE_SNACKBAR]: (state) =&gt;
    Object.assign({}, state, { snackbarMode: CLOSABLE_SNACKBAR_MODE.CLOSE, }),

  [ActionType.OPEN_ERROR_SNACKBAR]: (state, { payload, }) =&gt;
    Object.assign({}, state, {
      snackbarMode: CLOSABLE_SNACKBAR_MODE.OPEN,
      message: `[ERROR] ${payload.message} (${payload.error.message})`,
    }),

  [ActionType.OPEN_INFO_SNACKBAR]: (state, { payload, }) =&gt;
    Object.assign({}, state, {
      snackbarMode: CLOSABLE_SNACKBAR_MODE.OPEN,
      message: `[INFO] ${payload.message}`,
    }),

}, INITIAL_SNACKBAR_STATE)
</code></pre>

<p>만약 여러 종류의 API 실패에 대한 액션을 처리하도록 작성했다면, 이런 코드가 되었을 거고 API_FAILED 액션 타입이 삭제되고 추가될 때 마다 수정해야 하므로 변경에 취약했을 것입니다.</p>

<pre><code class="language-javascript">const FAILED_API_ACTION_TYPES = [  
  ActionType.LOAD_ALL_JOBS_FAILED,
  ActionType.CREATE_JOB_FAILED,
  ActionType.REMOVE_JOB_FAILED,
  ...
]

const FailureHandlers = FAILED_API_ACTION_TYPES.map(actionType =&gt; {  
  return { [actionType]: (state, { payload, }) =&gt;
    Object.assign({}, state, {
      snackbarMode: CLOSABLE_SNACKBAR_MODE.OPEN,
      message: `[ERROR] ${payload.message} (${payload.error.message})`,
    })
  }
})

export const handler = handleActions({  
  /** snackbar related */
  [ActionType.CLOSE_SNACKBAR]: (state) =&gt;
    Object.assign({}, state, { snackbarMode: CLOSABLE_SNACKBAR_MODE.CLOSE, }),

  ...FailureHandlers,

}, INITIAL_SNACKBAR_STATE)
</code></pre>

<h2 id="webpack">Webpack</h2>

<h3 id="6jestmocha">6. 테스팅 프레임워크로 jest 대신 mocha 사용하기</h3>

<p><a href="https://facebook.github.io/jest/">jest</a> 는 Facebook 에서 만든 테스팅 프레임워크입니다. 모든 <code>import</code> 는 기본적으로 mocking 됩니다. 따라서 테스트할 <code>.js</code> 파일에서 사용되는 모든 라이브러리도 mocking 됩니다. 이런식으로 테스트 대상만 unmocking 해서 사용할 수 있습니다.</p>

<pre><code class="language-javascript">// https://github.com/facebook/jest

jest.unmock('../sum'); // unmock to use the actual implementation of sum

describe('sum', () =&gt; {  
  it('adds 1 + 2 to equal 3', () =&gt; {
    const sum = require('../sum');
    expect(sum(1, 2)).toBe(3);
  });
});
</code></pre>

<p><a href="https://github.com/facebook/jest">jest</a> 사용시 주의 할 사항이 두 가지 있습니다.</p>

<p>jest 0.9.0 기준으로 아직 모든 라이브러리가 mocking 되진 않습니다. (e.g redux-saga) <br>
babel 을 사용할 경우 babel-jest 로 테스트 실행이 가능하지만 여기에 postcss 까지 같이 쓸 경우, <code>import (‘*.css)</code> 구문 때문에 테스팅이 불가능합니다. 커스텀 jest 로더를 등록하면, babel-runtime 로딩이 제대로 안되며 <a href="https://github.com/atecarlos/webpack-babel-jest">webpack-babel-jest</a> 란것도 있으나 제대로 동작하지 않습니다. (관련이슈 <a href="https://github.com/facebook/jest/issues/334">jest issue: 334 - How to test with Jest when I'm using webpack</a>)</p>

<h3 id="7postcss">7. postcss 를 사용할 경우, 테스팅 환경에서 스타일파일 무시하기</h3>

<p><a href="https://github.com/postcss/postcss">postcss</a> 를 이용하면 <a href="https://github.com/postcss/autoprefixer">autoprefixer</a> 등의 각종 플러그인을 사용 가능합니다. 특히 <a href="https://github.com/postcss/postcss-loader">postcss-loader</a> 를 이용하면
 지엽적인 css 클래스 생성과 적용이 가능하므로 모듈, 컴포넌트 단위로 관리되는 React 와 같이 쓰기 좋습니다.</p>

<p>그런데, 테스팅 환경에서는 <a href="https://webpack.github.io/">webpack</a> 이 돌지 않으므로 css 파일 임포트가 불가능 하고, 테스트 실행이 안됩니다. 이 경우 <a href="https://www.npmjs.com/package/ignore-styles">ignore-styles</a> 를 이용하거나 mocha 설정을 이용해 css 파일 임포트 문장을 무시할 수 있습니다.</p>

<pre><code class="language-javascript">// https://github.com/1ambda/slott/blob/f1e94a9e693c30f466d92a4d3c988b75d5db4118/package.json#L28

"test": "cross-env NODE_ENV=test mocha --reporter progress --compilers js:babel-core/register --recursive \"./src/**/*.spec.js\" --require ignore-styles"
</code></pre>

<p>아니면 <a href="https://github.com/coryhouse/react-slingshot">react-slingshot</a> 처럼 셋업 파일을 분리해서 mocha 설정으로 이용할 수 있습니다.</p>

<pre><code class="language-javascript">// https://github.com/coryhouse/react-slingshot/blob/16ec28c9029bf7e2b65b26c22a1c2daadab427a2/tools/testSetup.js

process.env.NODE_ENV = 'production';

// Disable webpack-specific features for tests since
// Mocha doesn't know what to do with them.
require.extensions['.css'] = function () {  
  return null;
};
require.extensions['.png'] = function () {  
  return null;
};
require.extensions['.jpg'] = function () {  
  return null;
};

// Register babel so that it will transpile ES6 to ES5
// before our tests run.
require('babel-register')();  
</code></pre>

<p>이후 <code>package.son</code> 에서 <code>"test": "mocha tools/testSetup.js src/**/*.spec.js --reporter</code> 처럼 사용할 수 있습니다.</p>

<h3 id="8defineplugin">8. DefinePlugin 을 이용해 클라이언트 파일에 환경변수 주입하기</h3>

<p><a href="https://webpack.github.io/docs/list-of-plugins.html#defineplugin">Webpack: DefinePlugin</a> 을 이용하면 Webpack 실행 시점에 존재하는 변수를 클라이언트에 주입할 수 있습니다. (e.g 환경변수, 별도 파일로 존재하는 설정값 등) 예를 들어</p>

<pre><code class="language-javascript">// https://github.com/1ambda/slott/blob/f1e94a9e693c30f466d92a4d3c988b75d5db4118/tools/config.js

import { ENV_DEV, ENV_PROD, ENV_TEST, } from './env'  
import * as DEV_CONFIG from '../config/development.config'  
import * as PROD_CONFIG from '../config/production.config'

const env = process.env.NODE_ENV

export const CONFIG = (env === ENV_DEV) ? DEV_CONFIG : PROD_CONFIG

export const GLOBAL_VARIABLES = { /** used by Webpack.DefinePlugin */  
  'process.env.ENV_DEV': JSON.stringify(ENV_DEV),
  'process.env.ENV_PROD': JSON.stringify(ENV_PROD),
  'process.env.NODE_ENV': JSON.stringify(env),

  /** variables defined in `CONFIG` file ares already stringified */
  'process.env.CONTAINERS': CONFIG.CONTAINERS,
  'process.env.TITLE': CONFIG.TITLE,
  'process.env.PAGINATOR_ITEM_COUNT': CONFIG.PAGINATOR_ITEM_COUNT,
}
</code></pre>

<p>좌측이 클라이언트에서 사용할 변수, 우측이 주입할 변수입니다. 이렇게 만든 후 Webpack 설정에서 다음처럼 사용할 수 있습니다.</p>

<pre><code class="language-javascript">// https://github.com/1ambda/slott/blob/f1e94a9e693c30f466d92a4d3c988b75d5db4118/webpack.config.js

const getPlugins = function (env) {  
  const plugins = [
    new webpack.optimize.OccurenceOrderPlugin(),
    new webpack.DefinePlugin(GLOBAL_VARIABLES),
    ...
  ]

  /* eslint-disable no-console */
  console.log('Injecting Global Variable'.green)
  console.log(GLOBAL_VARIABLES)
  /* eslint-enable no-console */

...
</code></pre>

<p>이 때 몇 가지 주의할 사항이 있습니다. </p>

<blockquote>
  <p>If the value is a string it will be used as a code fragment.
  If the value isn’t a string, it will be stringified (including functions).
  If the value is an object all keys are defined the same way.
  If you prefix typeof to the key, it’s only defined for typeof calls.</p>
</blockquote>

<p>따라서 우측 값이 문자열일 경우, 코드값으로 사용되므로 <code>undefined</code> 로 주입되거나, Webpack 실행시 예외가 발생할 경우는 확인해 보아야 합니다. 실제로 문자열을 주입하고 싶다면 한번 더 문자열로 감싸야 하구요. 이 부분은 문서에도 나와 있습니다.</p>

<pre><code class="language-javascript">// https://webpack.github.io/docs/list-of-plugins.html#defineplugin

new webpack.DefinePlugin({  
    VERSION: JSON.stringify("5fa3b9"),
    BROWSER_SUPPORTS_HTML5: true,
    TWO: "1+1",
    "typeof window": JSON.stringify("object")
})
</code></pre>

<h2 id="etc">Etc</h2>

<h3 id="9jsonserver">9. json-server 사용하기</h3>

<p>웹 클라이언트 개발 과정에서, API 연동을 하다보면 두 가지 문제점에 마주칩니다.</p>

<ul>
<li><strong>아직 백엔드가 개발되지 않았는데 연동이 필요할 경우</strong>: 테스팅은 mock 등을 어찌어찌 해서 짤 수 있으나, UI 시뮬레이션은 최소한 로컬호스트 개발용 서버라도 갖추어야 하므로 어려움</li>
<li><strong>RESTful API 구현</strong>: HTTP Status, Methods, URI 등에 대한 학습과 고민이 필요</li>
</ul>

<p>로컬에서 미리 정의된 리소스를 읽어 표준화된 REST API 서버를 제공하는 <a href="https://github.com/typicode/json-server">json-server</a> 를 이용하면 이 두 가지 문제를 해결할 수 있습니다. </p>

<p>예를 들어 Job 을 <code>/api/jobs</code> 에서 돌려준다고 하면 리소스 파일을 다음처럼 작성할 수 있습니다.</p>

<pre><code class="language-json">{
  "jobs": [
    {
      "id": "akka-cluster-A-1",
      "tags": [
        "cluster"
      ],
      "active": true,
      "enabled": true,
      "kafka": {
        "topic": "akka-A",
        "consumer-group": "cluster-consumers"
      },
      "hdfs": "/data/akka/cluster-A"
    }
  , ...
  ]
}
</code></pre>

<p>추가적으로 라우팅 세팅을 위해 <code>routes.json</code> 파일을 다음처럼 작성하면 됩니다.</p>

<pre><code class="language-json">{
  "/api/": "/",
</code></pre>

<p><a href="https://github.com/typicode/json-server">json-server</a> 를 사용할 때 두 가지 주의해야 할 점이 있습니다.</p>

<p><strong>1. <code>id</code> 값은 <em>immutable</em> 이고, 모든 리소스는 <code>id</code> 값을 가지고 있어야 합니다. (키 값은 <code>--id</code> 옵션으로 변경 가능함)</strong></p>

<p>따라서 각 Job 의 실행 상태와 설정값을 별개의 리소스가 아니라 (별개의 리소스라면 <code>jobId</code> 를 주어 <em>join</em> 을 해야함) <code>/api/jobs/:id/state</code>, <code>/api/jobs/:id/config</code> 처럼 nested 된 형태로 돌려주고 싶을 때는 <code>routes.json</code> 의 라우팅 트릭을 이용할 수 있습니다.</p>

<pre><code class="language-json">// https://github.com/1ambda/slott/blob/f1e94a9e693c30f466d92a4d3c988b75d5db4118/resource/routes.json

{
  "/api/": "/",
  "/:resource/:id/state": "/:resource/:id",
  "/:resource/:id/config": "/:resource/:id"
}
</code></pre>

<p>이 때, 이 리소스는 별개의 리소스가 아니라 URI 만 매핑된 것이므로 <code>config</code>, <code>state</code> 등에 대한 변경은 HTTP <em>PATCH</em> 메소드로 변경해야 합니다.</p>

<p><strong>2. 모든 리소스 변경은 즉시 파일에 변경됩니다.</strong></p>

<p>따라서 매 실행마다 동일한 리소스로 시작하려면, 리소스 파일을 복사 후 실행하는 간단한 스크립트를 작성하면 됩니다.</p>

<pre><code class="language-javascript">// https://github.com/1ambda/slott/blob/f1e94a9e693c30f466d92a4d3c988b75d5db4118/tools/remote.js

import fs from 'fs-extra'

/** initialize resource/remote/db.json */

const resourceDir = 'resource'

// 3개의 서버를 별개로 띄우므로 3벌 복사
const remotes = ['remote1', 'remote2', 'remote3',]

remotes.map(remote =&gt; {  
  fs.copySync(`${resourceDir}/${remote}/db.origin.json`, `${resourceDir}/${remote}/db.json`)
})
</code></pre>

<p>이후 <code>package.json</code> 에 다음의 스크립트를 작성하고, 사용하면 됩니다.</p>

<pre><code class="language-json">// https://github.com/1ambda/slott/blob/f1e94a9e693c30f466d92a4d3c988b75d5db4118/package.json#L9

...

 "start:mock-server1": "json-server resource/remote1/db.json --routes resource/routes.json --port 3002",
    "start:mock-server2": "json-server resource/remote2/db.json --routes resource/routes.json --port 3003",
    "start:mock-server3": "json-server resource/remote3/db.json --routes resource/routes.json --port 3004",
    "start:mock-server": "npm-run-all --parallel start:mock-server1 start:mock-server2 start:mock-server3",

...
</code></pre>

<h2 id="references">References</h2>

<ul>
<li><a href="https://github.com/reactjs/redux/issues/151">Redux Logo</a></li>
<li><a href="http://briantroncone.com/?p=529">Redux Middleware: Behind the Scenes</a></li>
<li><a href="https://tc39.github.io/ecmascript-asyncawait/">ES7 async</a></li>
<li><a href="https://github.com/yelouafi/redux-saga/blob/master/docs/basics/DeclarativeEffects.md">redux-saga: Declarative Effects</a></li>
<li><a href="https://webpack.github.io/docs/list-of-plugins.html#defineplugin">Webpack: DefinePlugin</a></li>
<li><a href="https://github.com/coryhouse/react-slingshot">react-slingshot</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[10분만에 Github Profile 만들기]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/oh-my-github/baracktocat-large.jpg" alt=""></p>

<p><br></p>

<p>Github 데이터를 이용해 프로필을 만들려면 </p>

<ol>
<li><strong><a href="https://developer.github.com/v3/">Github API</a></strong> 를 이용해 데이터를 긁어옵니다.  </li>
<li>데이터를 보여줄 웹 어플리케이션 (<em>static</em>) 을 만듭니다.  </li>
<li><strong><a href="https://pages.github.com/">Github Page (gh-pages)</a></strong> 를 이용해 남들에게 보여줍니다.</li>
</ol>

<p>이 때, (1) 에서 만든 데이터의 <strong>포맷을 정형화하면</strong>, 이것을 사용하는 (2) 의 웹 어플리케이션을 일종의 <em>viewer</em> 로 생각할 수 있습니다. 포맷이 고정되어 있으므로 데이터를 사용하는</p>]]></description><link>http://1ambda.github.io/create-github-profile-in-10-minutes/</link><guid isPermaLink="false">243afde3-5959-44c5-8dd6-35eefb670c2c</guid><category><![CDATA[Github]]></category><category><![CDATA[oh-my-github]]></category><category><![CDATA[nodejs]]></category><category><![CDATA[npm]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 29 Feb 2016 14:10:20 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/oh-my-github/baracktocat-large.jpg" alt=""></p>

<p><br></p>

<p>Github 데이터를 이용해 프로필을 만들려면 </p>

<ol>
<li><strong><a href="https://developer.github.com/v3/">Github API</a></strong> 를 이용해 데이터를 긁어옵니다.  </li>
<li>데이터를 보여줄 웹 어플리케이션 (<em>static</em>) 을 만듭니다.  </li>
<li><strong><a href="https://pages.github.com/">Github Page (gh-pages)</a></strong> 를 이용해 남들에게 보여줍니다.</li>
</ol>

<p>이 때, (1) 에서 만든 데이터의 <strong>포맷을 정형화하면</strong>, 이것을 사용하는 (2) 의 웹 어플리케이션을 일종의 <em>viewer</em> 로 생각할 수 있습니다. 포맷이 고정되어 있으므로 데이터를 사용하는 <em>viewer</em> 를 <strong>쉽게 교체하거나</strong>, 자신이 원하는대로 <strong>커스터마이징</strong> 할 수 있게 됩니다.</p>

<p><br></p>

<h3 id="demo">Demo</h3>

<p>시작 전에 오늘 만들 결과물의 데모를 보겠습니다.</p>

<p><a href="http://1ambda.github.io/oh-my-github/">Demo (Chrome, Firefox, Safari, IE11+)</a></p>

<ul>
<li><strong>Langauge</strong>: 즐겨 사용하는 프로그래밍 언어</li>
<li><strong>Repository</strong>: 레포지토리 정보 (<em>stargazer</em>, <em>fork count</em> 등)</li>
<li><strong>Contribution</strong>: 오픈소스 커밋 내역</li>
<li><strong>Activity</strong>: 최근 활동 내역 (<em>Push</em>, <em>PullRequest</em> 등)</li>
</ul>

<p>등의 정보를 확인할 수 있습니다. 커스터마이징 등은 아래에서 설명하겠습니다. </p>

<h3 id="prerequisites">Prerequisites</h3>

<p>이제 Github 프로필을 만들어 보겠습니다. 준비물을 먼저 확인하면,</p>

<ol>
<li><em>SSH Key</em> 가 Github 에 등록이 안되어있을 경우 <strong><a href="https://help.github.com/articles/generating-an-ssh-key/">Github: Generating an SSH key</a></strong> 를 참조해서 등록해주세요.  </li>
<li><strong>oh-my-github</strong> 란 이름의 <strong><a href="https://github.com/new">Github Repository</a></strong> 를 만들어주세요. <strong><a href="https://pages.github.com/">Github Page</a></strong> 를 이용해 배포시 사용할 저장소입니다. (이름은 반드시 <strong>oh-my-github</strong> 여야 합니다)  </li>
<li><strong><a href="https://github.com/settings/tokens/new">Github Access Token</a></strong> 을 만들어주세요. 50 개 이상의 Github API 호출을 위해선 Access Token 이 꼭 필요합니다. (Write Permission 은 필요 없습니다.)  </li>
</ol>

<p>데이터를 보여주는 정적 웹 어플리케이션인 <a href="https://github.com/oh-my-github/viewer">viewer</a> 와 Github API 를 호출해 데이터를 생성하는 <a href="https://github.com/oh-my-github/oh-my-github">oh-my-github</a> 설치법은 아래서 설명하겠습니다.</p>

<h3 id="installviewer">Install: Viewer</h3>

<p>먼저 <a href="https://github.com/oh-my-github/viewer">default viewer</a> 를 클론 받고, <code>upstream</code> 업데이트를 위해 remote 를 등록합니다.</p>

<pre><code>$ git clone git@github.com:oh-my-github/viewer.git oh-my-github
$ cd oh-my-github

$ git remote add upstream git@github.com:oh-my-github/viewer.git
</code></pre>

<p>그리고, 위에서 만든 자신의 레포지토리 url 을 <code>origin</code> 으로 등록합니다. <code>[GITHUB_ID]</code> 대신 자신의 아이디를 사용하면 됩니다.</p>

<pre><code>$ git remote remove origin
$ git remote add origin git@github.com:[GITHUB_ID]/oh-my-github
</code></pre>

<h3 id="installohmygithub">Install: oh-my-github</h3>

<p>먼저 <a href="https://github.com/oh-my-github/oh-my-github">oh-my-github</a> 를 설치하겠습니다. NodeJS 가 없다면, <a href="https://github.com/creationix/nvm">NVM</a> 설치 후 문서에 나와있는 대로 NodeJS 5.0.0 이상 버전을 설치해 주세요. 이 문서에서는 5.0.0 을 사용하겠습니다.</p>

<pre><code>$ nvm use 5.0.0
Now using node v5.0.0

$ nvm ls
   v0.12.9
-&gt;  v5.0.0
    v5.4.1
</code></pre>

<p>이제 <a href="https://github.com/oh-my-github/oh-my-github">oh-my-github</a> 를 설치합니다. 네트워크 상황에 따라 2분 ~ 4분정도 걸립니다.</p>

<pre><code>$ npm install oh-my-github -g
</code></pre>

<p>만약 Linux 를 사용하고 있고, 위 설치 과정에서 <code>LIBXXX</code> 등의 에러를 마주쳤을 경우 <a href="https://github.com/oh-my-github/oh-my-github/wiki/Installation-Guide-for-Linux">Linux Install Guide</a> 를 참조해주세요.</p>

<p>이제 <em>viewer</em> 를 클론 받은 디렉토리로 이동한 뒤 <em>oh-my-github</em> 를 실행합니다. 여기서 <code>[GITHUB_TOKEN]</code> 은 위에서 만든 <a href="https://github.com/settings/tokens/new">Github Access Token</a> 값이고, <code>[GITHUB_ID]</code> 는 자신의 Github ID 입니다.</p>

<pre><code>$ oh-my-github

$ omg init [GITHUB_ID] oh-my-github       # (e.g) omg init 1ambda oh-my-github
$ omg generate [GITHUB_TOKEN]             # (e.g) omg generate 394fbad49191aca
</code></pre>

<p><code>omg generate</code> 를 실행하면, 현재 디렉토리에 <code>oh-my-github.json</code> (프로필 데이터) 가 생성됩니다. <a href="https://pages.github.com/">Github Page</a> 에 배포하기 전에 먼저 로컬에 띄워 볼 수 있습니다.</p>

<pre><code>$ omg preview
</code></pre>

<p>이제 <code>gh-pages</code> 브랜치를 만들고 push 를 해야하는데, 아래의 명령어를 이용해 한번에 해결할 수 있습니다.</p>

<pre><code>$ omg publish
</code></pre>

<p>만약 <code>omg publish</code> 명령어가 동작하지 않는다면, 직접 Git 커맨드를 사용하면 됩니다.</p>

<pre><code>$ git add --all
$ git commit -m "feat: Update Profile"
$ git checkout -b gh-pages
$ git push origin HEAD
</code></pre>

<p>이제 30초 정도 기다리고, 자신의 oh-my-github 레포지토리 <a href="https://pages.github.com/">Github Page</a> URL 을 확인해 봅니다. 예를 들어 Github ID 가 <code>1ambda</code> 라면, <a href="http://1ambda.github.io/oh-my-github">http://1ambda.github.io/oh-my-github</a> 에 프로필이 생성됩니다.</p>

<p><br></p>

<h3 id="update">Update</h3>

<h4 id="profile">Profile</h4>

<p>프로필 데이터 <code>oh-my-github.json</code> 내용은 크게 분류하면 두가지로 나뉩니다.</p>

<ul>
<li><code>activities</code>: 사용자의 활동 정보로, 이전 정보에 새로운 값이 추가됨(<em>append</em>)</li>
<li><code>repositories</code>, <code>languages</code> 등: 최신 정보로 덮어 씌워짐 (<em>overwrite</em>)</li>
</ul>

<p><code>omg generate</code> 를 실행할 때 마다, 새로운 이벤트가 있다면 <code>activities</code> 값이 추가 (<em>append</em>) 됩니다.</p>

<blockquote>
  <p>더 정확히는, Github API 는 최대 10개월 혹은 최대 300개의 event 만 제공하기 때문에, 이것보다 더 많은 양의 event 를 프로필 데이터에 저장하고자 event id 값으로 중복 제거를 한 뒤 <em>append</em> 방식으로 데이터를 쌓습니다. </p>
</blockquote>

<p>따라서 프로필 데이터를 업데이트 하고, Github 에 푸시하려면 다음의 명령어를 실행하면 됩니다.</p>

<pre><code>$ cd oh-my-github         # oh-my-github.json 이 위치한 곳

$ omg generate [GITHUB_TOKEN]
$ omg publish
</code></pre>

<h4 id="viewer">Viewer</h4>

<p><em>viewer</em> 를 <a href="https://github.com/oh-my-github/viewer">upstream</a> 에서 다음처럼 업데이트 할 수 있습니다.</p>

<pre><code>$ cd oh-my-github         # oh-my-github.json 이 위치한 곳

$ git checkout master
$ git pull upstream master --rebase

$ git checkout gh-pages
$ git rebase master

$ git push origin HEAD
</code></pre>

<p><br></p>

<h3 id="customizing">Customizing</h3>

<p>만약 <a href="https://github.com/oh-my-github/viewer">default viewer</a> 가 맘에 들지 않는다거나, 새로운 기능 (e.g 그래프) 을 추가하고 싶다면 클론받아 <code>app/src</code> 아래의 코드를 수정할 수 있습니다.</p>

<pre><code>app  
├── LICENSE.md
├── package.json
├── src (웹 애플리케이션 소스)
│   ├── actions
│   ├── components
│   ├── constants
│   ├── containers
│   ├── reducers
│   ├── store
│   ├── theme
│   └── util
└── tools (빌드도구 관련)
</code></pre>

<p><code>app</code> 디렉토리로 이동 후 <code>npm start -s</code> 를 실행하고 코드를 수정한 뒤, <code>npm run build</code> 를 실행하면 루트 디렉토리에 <code>bundle.js</code> 와 <code>index.html</code> 이 업데이트 됩니다. 이 두 파일을 자신의 <strong>oh-my-github</strong> 에 업데이트 하면 됩니다.</p>

<p>추가로, 다른 사람들이 자신이 수정한 <em>viewer</em> 를 찾을 수 있게 <a href="https://www.npmjs.com/search?q=oh-my-github%2C+viewer">NPM</a> 에 등록하고 싶다면 <code>package.json</code> 을 수정 후 <code>app</code> 디렉토리에서 <code>npm publish</code> 명령을 실행하면 됩니다.</p>

<p>아래의 내용을 수정하고, 배포하면 NPM 에서 <code>oh-my-github, viewer</code> 키워드로 검색할 수 있습니다. <a href="https://www.npmjs.com/search?q=oh-my-github%2C+viewer">(NPM: oh-my-github, viewer)</a></p>

<pre><code class="language-json">{
  ...

  "name": "oh-my-github-viewer-default",
  "version": "0.0.1",
  "author": "1ambda",
  "description": "",
  "homepage": "https://github.com/oh-my-github/viewer#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/oh-my-github/viewer.git"
  },
  "bugs": {
    "url": "https://github.com/oh-my-github/viewer/issues"
  },

  ...
}
</code></pre>

<h3 id="references">References</h3>

<ul>
<li><a href="https://octodex.github.com/baracktocat">@baracktocat on octodex (Title Iamge)</a></li>
<li><a href="https://github.com/oh-my-github/oh-my-github">oh-my-github: generator</a></li>
<li><a href="https://github.com/oh-my-github/viewer">oh-my-github: viewer</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Easy Scalaz 5, Playing with Monoids]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p>이번 글에서는 모노이드를 가지고 놀면서, 아래 나열된 라이브러리 및 언어적 특성을 살펴보겠습니다.</p>

<ul>
<li>Boolean Monoid operations with <strong><a href="https://github.com/non/spire">Spire</a></strong></li>
<li>Algebraic Data Types using <strong><a href="http://docs.scala-lang.org/overviews/core/value-classes.html">Value Class</a></strong>, <strong><a href="https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Tag.scala">Scalaz.Tag</a></strong></li>
<li>Creating Monoid for all subclasses using <strong><a href="https://github.com/milessabin/shapeless">Shapeless</a></strong></li>
<li><strong><a href="http://docs.scala-lang.org/tutorials/FAQ/context-and-view-bounds.html">Context Bound</a></strong></li>
<li><strong><a href="http://danielwestheide.com/blog/2013/02/13/the-neophytes-guide-to-scala-part-13-path-dependent-types.html">Path Dependent Type</a></strong></li>
</ul>

<h2 id="monoid">Monoid</h2>

<p><a href="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/#monoid">Easy Scalaz 4 - Yoneda and Free Monad: Monoid</a> 부분에서 발췌하면,</p>

<p>어떤</p>]]></description><link>http://1ambda.github.io/easy-scalaz-5-playing-with-monoids/</link><guid isPermaLink="false">c86052aa-a361-4372-b3f2-00fc3e58e49b</guid><category><![CDATA[scala]]></category><category><![CDATA[monoid]]></category><category><![CDATA[scalaz]]></category><category><![CDATA[shapeless]]></category><category><![CDATA[spire]]></category><category><![CDATA[Tag]]></category><category><![CDATA[path dependent type]]></category><category><![CDATA[context bound]]></category><category><![CDATA[algebraic data type]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 18 Dec 2015 15:37:58 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p>이번 글에서는 모노이드를 가지고 놀면서, 아래 나열된 라이브러리 및 언어적 특성을 살펴보겠습니다.</p>

<ul>
<li>Boolean Monoid operations with <strong><a href="https://github.com/non/spire">Spire</a></strong></li>
<li>Algebraic Data Types using <strong><a href="http://docs.scala-lang.org/overviews/core/value-classes.html">Value Class</a></strong>, <strong><a href="https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Tag.scala">Scalaz.Tag</a></strong></li>
<li>Creating Monoid for all subclasses using <strong><a href="https://github.com/milessabin/shapeless">Shapeless</a></strong></li>
<li><strong><a href="http://docs.scala-lang.org/tutorials/FAQ/context-and-view-bounds.html">Context Bound</a></strong></li>
<li><strong><a href="http://danielwestheide.com/blog/2013/02/13/the-neophytes-guide-to-scala-part-13-path-dependent-types.html">Path Dependent Type</a></strong></li>
</ul>

<h2 id="monoid">Monoid</h2>

<p><a href="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/#monoid">Easy Scalaz 4 - Yoneda and Free Monad: Monoid</a> 부분에서 발췌하면,</p>

<p>어떤 집합 <code>S</code> 에 대한 닫힌 연산 <code>*</code>, 집합 내의 어떤 원소 <code>e</code> 가 다음을 만족할 경우 모노이드라 부릅니다.</p>

<ul>
<li><code>e * a = a = a * e</code> (<em>identity</em>)</li>
<li><code>(a * b) * c = a * (b * c)</code> (<em>associativity</em>)</li>
</ul>

<p>일반적으로 <code>e</code> 를 항등원이라 부릅니다. <code>Option[A]</code> 도 <code>None</code> 을 항등원으로 사용하고, <em>associativity</em> 를 만족하는 <code>A</code> 의 연산을 사용하면 모노이드입니다. 따라서 <code>A</code> 가 모노이드면 <code>Option[A]</code> 도 모노이드입니다. </p>

<p><em>Scalaz</em> 에서는 모노이드 연산 <code>*</code> 를, <code>|+|</code> 로 표시합니다. 우리가 알고 있는 <em>primitives</em> 대부분이 모노이드입니다. </p>

<pre><code class="language-scala">&gt; load.ivy("org.scalaz" % "scalaz-core_2.11" % "7.2.0-M5")

&gt; import scalaz._, Scalaz._
import scalaz._, Scalaz._  
&gt; implicitly[Monoid[String]]
res4: Monoid[String] = scalaz.std.StringInstances$stringInstance$@5590d10f  
&gt; implicitly[Monoid[Int]]
res5: Monoid[Int] = scalaz.std.AnyValInstances$$anon$5@4b9f2522  
&gt; implicitly[Monoid[Set[Int]]]
res6: Monoid[Set[Int]] = scalaz.std.SetInstances$$anon$3@5b1965ea

&gt; "1" |+| "2"
res7: String = "12"  
&gt; 1.0 |+| 2.0
Compilation Failed  
Main.scala:1459: value |+| is not a member of Double  
1.0 |+| 2.0  
    ^
&gt; 1 |+| 2
res8: Int = 3

&gt; 1.some |+| 2.some
res11: Option[Int] = Some(3)  
&gt; 1.some |+| none
res12: Option[Int] = Some(1)  
&gt; none[Int] |+| 1.some
res13: Option[Int] = Some(1)  
</code></pre>

<p><code>Map[A, B]</code> 는 <code>A</code> 를 <em>Key</em> 로 잡고, <code>B</code> 의 모노이드 연산과 항등원을 이용하는 모노이드입니다.</p>

<pre><code class="language-scala">&gt; val m1 = Map("a" -&gt; 1, "b" -&gt; 2)
m1: Map[String, Int] = Map("a" -&gt; 1, "b" -&gt; 2)  
&gt; val m2 = Map("a" -&gt; 1, "c" -&gt; 2)
m2: Map[String, Int] = Map("a" -&gt; 1, "c" -&gt; 2)  
&gt; m1 |+| m2
res16: Map[String, Int] = Map("a" -&gt; 2, "c" -&gt; 2, "b" -&gt; 2)  
</code></pre>

<h2 id="booleanmonoid">Boolean Monoid</h2>

<p><code>Boolean</code> 의 경우에는, 두 가지 모노이드가 존재할 수 있습니다. </p>

<ul>
<li><code>&amp;&amp;</code> 를 연산으로 사용하고, <code>true</code> 를 항등원으로 사용하는 경우</li>
<li><code>||</code> 를 연산으로 사용하고, <code>false</code> 를 항등원으로 사용하는 경우</li>
</ul>

<p>첫 번째를 <em>Conjunction</em> 이라 부르고 두 번째를 <em>Disjunction</em> 이라 부릅니다. 즉, <code>Boolean</code> 은 두 개의 모노이드가 존재할 수 있기 때문에 아래처럼 <em>scalaz</em> 의 <code>|+|</code> 를 바로 이용할 수 없습니다. <em>Disjunction</em> 인지 <em>Conjunction</em> 인지 골라야 하기 때문입니다.</p>

<pre><code class="language-scala">&gt; false |+| false
Compilation Failed  
Main.scala:1468: value |+| is not a member of Boolean  
false |+| false  
      ^

// import 를 하지 않으면, scalaz.Tags.Disjunction 이 아니라 scalaz.Disjunction 을 사용하므로 주의
&gt; import scalaz.Tags._
import scalaz.Tags._  
&gt; import scalaz.syntax.tag._
import scalaz.syntax.tag._  
&gt; Disjunction(false)
res22: Boolean @@ Disjunction = false  
&gt; Conjunction(false)
res23: Boolean @@ Conjunction = false

&gt; implicitly[Monoid[Boolean @@ Disjunction]]
res27: Monoid[Boolean @@ Disjunction] = scalaz.std.AnyValInstances$$anon$7@79a6c868  
&gt; implicitly[Monoid[Boolean @@ Conjunction]]
res28: Monoid[Boolean @@ Conjunction] = scalaz.std.AnyValInstances$$anon$8@6e49df4a

&gt; Disjunction(false) |+| Disjunction(true)
res29: Boolean @@ Disjunction = true  
&gt; Disjunction(true) |+| Disjunction(false)
res30: Boolean @@ Disjunction = true  
&gt; Conjunction(true) |+| Conjunction(true)
res31: Boolean @@ Conjunction = true  
&gt; Conjunction(true) |+| Conjunction(false)
res32: Boolean @@ Conjunction = false

&gt; List(false, false, true, false)
res37: List[Boolean] = List(false, false, true, false)  
&gt; Disjunction.subst(res37).suml
res38: Boolean @@ Disjunction = true  
&gt; Conjunction.subst(res37).suml
res39: Boolean @@ Conjunction = false  
</code></pre>

<p>실제로 <code>scalaz.std.AnyVal</code> 을 확인해 보면,</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/std/AnyVal.scala#L52

object conjunction extends Monoid[Boolean] {  
  def append(f1: Boolean, f2: =&gt; Boolean) = f1 &amp;&amp; f2
  def zero: Boolean = true
}

object disjunction extends Monoid[Boolean] {  
  def append(f1: Boolean, f2: =&gt; Boolean) = f1 || f2
  def zero = false
}
</code></pre>

<p>그렇다면 <code>Int</code> 의 경우에도 <code>*</code> 등 다른 모노이드가 있는데 왜 <code>+</code> 연산과 <code>0</code> 항등원만 <code>|+|</code> 에서 사용하는걸까요? 이는 <code>+</code> 가 너무 보편적이기 때문이며, <code>*</code> (곱셈) 등은 위에서 본 <code>Tag</code> 를 이용해 모노이드 연산으로 지정할 수 있습니다.</p>

<h2 id="tag">Tag</h2>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Tags.scala

object Tags {

  ...

  /** Type tag to choose a [[scalaz.Monoid]] instance that selects the lesser of two operands, ignoring `zero`. */
  sealed trait Min

  val Min = Tag.of[Min]

  /** Type tag to choose a [[scalaz.Monoid]] instance that selects the greater of two operands, ignoring `zero`. */
  sealed trait Max

  val Max = Tag.of[Max]

  /** Type tag to choose a [[scalaz.Monoid]] instance for a numeric type that performs multiplication,
   *  rather than the default monoid for these types which by convention performs addition. */
  sealed trait Multiplication

  val Multiplication = Tag.of[Multiplication]

  ...
}
</code></pre>

<p><code>Multiplication</code> 을 이용하면,</p>

<pre><code class="language-scala">&gt; Multiplication(2) |+| Multiplication(6)
res3: Int @@ Multiplication = 12

&gt; implicitly[Monoid[Int @@ Multiplication]]
res4: Monoid[Int @@ Multiplication] = scalaz.std.AnyValInstances$$anon$12@5910ca72  
</code></pre>

<p><code>AnyValInstances</code> 를 찾아보면 <code>byteMultiplicationNewType</code>, <code>intMultiplicationNewType</code> 등 <code>A @@ Multiplication</code> 을 위한 인스턴스들이 구현되어 있습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/std/AnyVal.scala#L253

trait AnyValInstances {

  implicit val shortMultiplicationNewType: Monoid[Short @@ Multiplication] with Enum[Short @@ Multiplication] = new Monoid[Short @@ Multiplication] with Enum[Short @@ Multiplication] {
    ...
  } 

  implicit val intMultiplicationNewType: Monoid[Int @@ Multiplication] with Enum[Int @@ Multiplication] = new Monoid[Int @@ Multiplication] with Enum[Int @@ Multiplication] {
    ...
  }
}
</code></pre>

<p><code>Tag</code> 는 이렇게 생겼습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/package.scala#L99

package object scalaz {  
  ...

  private[scalaz] type Tagged[A, T] = {type Tag = T; type Self = A}

  /**
   * Tag a type `T` with `Tag`.
   *
   * The resulting type is used to discriminate between type class instances.
   *
   * @see [[scalaz.Tag]] and [[scalaz.Tags]]
   *
   * Credit to Miles Sabin for the idea.
   */
  type @@[T, Tag] = Tagged[T, Tag]

  ...
}
</code></pre>

<p><code>@@[A, T]</code> 를 생성하기 위해 <code>Tag.apply</code> 를 값을 추출하기 위해 <code>unwrap</code> 을 이용할 수 있습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Tag.scala
object Tag {  
  /** `subst` specialized to `Id`.
    *
    * @todo According to Miles, @specialized doesn't help here. Maybe manually specialize.
    */
  @inline def apply[@specialized A, T](a: A): A @@ T = a.asInstanceOf[A @@ T]

  /** `unsubst` specialized to `Id`. */
  @inline def unwrap[@specialized A, T](a: A @@ T): A = unsubst[A, Id, T](a)

  /** Add a tag `T` to `A`.
    *
    * NB: It is unsafe to `subst` or `unsubst` a tag in an `F` that is
    * sensitive to the `A` type within.  For example, if `F` is a
    * GADT, rather than a normal ADT, it is probably unsafe.  For
    * "normal" types like `List` and function types, it is safe.  More
    * broadly, if it is possible to write a ''legal''
    * [[scalaz.InvariantFunctor]] over the parameter, `subst` of that
    * parameter is safe.
    * 
    * We do not have a
    * &lt;a href="https://ghc.haskell.org/trac/ghc/wiki/Roles"&gt;type role&lt;/a&gt;
    * system in Scala with which to declare the exact situations under
    * which `subst` is safe.  If we did, we would declare that `subst`
    * is safe if and only if the parameter has "representational" or
    * "phantom" role.
    */
  def subst[A, F[_], T](fa: F[A]): F[A @@ T] = fa.asInstanceOf[F[A @@ T]]

  ...
}
</code></pre>

<p><code>Tag</code> 는 <a href="http://docs.scala-lang.org/overviews/core/value-classes.html"><em>Value Class</em></a> 처럼 활용할 수도 있는데요,</p>

<pre><code class="language-scala">// http://eed3si9n.com/learning-scalaz/Tagged+type.html

sealed trait USD  
sealed trait EUR  
def USD[A](amount: A): A @@ USD = Tag[A, USD](amount)  
def EUR[A](amount: A): A @@ EUR = Tag[A, EUR](amount)

val oneUSD = USD(1)  
</code></pre>

<p>태깅된 타입을 이용하면 <em>implicit</em> 를 선택할 수 있습니다. 예를 들어 </p>

<pre><code class="language-scala">implicit val anonymousUserWriter = Writer[User @@ Anonymous] { ... }  
implicit val loggedInUserWriter  = Writer[User @@ LoggedIn]  { ... }  
</code></pre>

<p>그러나 <code>type B = A @@ T</code> 에서 <code>B</code> 는 <code>A</code> 의 서브타입으로 취급되므로 주의하여 사용해야 합니다. 예를 들어, <em>scalatest</em> 의 <code>===</code>, <code>shouldBe</code> 는 런타임값만 체크하므로 아래는 항상 참입니다.</p>

<pre><code class="language-scala">def convertUSDtoEUR[A](usd: A @@ USD, rate: A)  
                      (implicit M: Monoid[A @@ Multiplication]): A @@ EUR =
  EUR((Multiplication(usd.unwrap) |+| Multiplication(rate)).unwrap)

convertUSDtoEUR(USD(1), 2) === EUR(2) // true  
convertUSDtoEUR(USD(1), 2) === USD(2) // true

convertUSDtoEUR(USD(1), 2) shouldBe EUR(2) // true  
convertUSDtoEUR(USD(1), 2) shouldBe USD(2) // true

2 shouldBe USD(2) // true  
2 shouldBe EUR(2) // true  
</code></pre>

<p>따라서 <code>=:=</code> 를 만들어 사용하면 <code>EUR</code> 과 <code>USD</code> 비교시 컴파일 예외를 발생시킬 수 있습니다. (더 정확히는 <em>scalaz</em> 의 <code>===</code> 또는 <code>org.scalactic.TypeCheckedTripleEquals</code> 를 사용하면 되는데, <code>org.scalactic.TripleEqualSupports</code> 를 <code>FunSuite</code>  내에서 하이딩 시킬 방법을 찾지 못해서 아래처럼 구현했습니다.)</p>

<pre><code class="language-scala">// impilcit class 로 만들고 import 해서 사용해도 상관없음
trait TestImplicits {  
  final case class StrictEqualOps[A](val a: A) {
    def =:=(aa: A) = assert(a == aa)
    def =/=(aa: A) = assert(!(a == aa))
  }

  implicit def toStrictEqualOps[A](a: A) = StrictEqualOps(a)
}

// spec
convertUSDtoEUR(USD(1), 2) =:= EUR(2)  
convertUSDtoEUR(USD(1), 2) =:= EUR(3) // will fail  
convertUSDtoEUR(USD(1), 2) =:= USD(3) // compile error  
</code></pre>

<p><code>Tag</code> 을 이용하면 같은 <em>primitive type</em> 이어도 별도의 <em>wrapper</em> 를 만들지 않으면서 다른 타입으로 만들 수 있습니다. 예를 들어 <code>Job</code> 을 <code>Agent</code> 가 수행한다고 하면, 다음과 같이 간단한 모델을 만들어 볼 수 있는데</p>

<pre><code class="language-scala">// ref - http://www.slideshare.net/IainHull/improving-correctness-with-types

case class Agent(id: String, /* agent id */  
                 status: String, /* agent status */
                 jobType: String)

case class Job(id: String, /* job id */  
               maybeAgentId: Option[String], /* agent id */
               status: String, /* job status */
               jobType: String)
</code></pre>

<p>여기서 <em>Sum</em> 을 먼저 추출하면, (<em>Algebraic Data Type</em> 관련해서는 <a href="https://gleichmann.wordpress.com/2011/02/05/functional-scala-algebraic-datatypes-sum-and-product-types/">Sum and Product</a> 참조)</p>

<pre><code class="language-scala">sealed abstract class AgentStatus(val value: String)  
case object Waiting    extends AgentStatus("WAITING")  
case object Processing extends AgentStatus("PROCESSING")

sealed abstract class JobStatus(val value: String)  
case object Created   extends JobStatus("CREATED")  
case object Allocated extends JobStatus("ALLOCATED")  
case object Completed extends JobStatus("COMPLETED")

sealed abstract class JobType(val value: String)  
case object Small extends JobType("SMALL")  
case object Large extends JobType("LARGE")  
case object Batch extends JobType("BATCH")

case class Agent(id: String, /* agent id */  
                 status: AgentStatus,
                 jobType: JobType)

case class Job(id: String, /* job id */  
               maybeAgentId: Option[String], /* agent id */
               status: JobStatus,
               jobType: JobType)
</code></pre>

<p>여기서 오류의 소지가 다분한 <code>id</code> 에 태깅을 하면 다음과 같습니다.</p>

<pre><code class="language-scala">import scalaz._

case class Agent(id: String @@ Agent,  
                 status: AgentStatus,
                 jobType: JobType)

case class Job(id: String @@ Job,  
               maybeAgentId: Option[String @@ Agent],
               status: JobStatus,
               jobType: JobType)

Agent(Tag[String, Agent]("03"), Waiting, Small)  
Job(Tag[String, Job]("03"), None, Created, Small)  
</code></pre>

<p>조금 더 개선할 여지는, <code>maybeAgentId</code> 에 <code>Option</code> 을 이용하는 대신, <em>agent</em> 에 할당된 <em>job</em> 과 아닌 <em>job</em> 을 서브타입으로 분리하면, <code>Job</code> 을 다루는 함수에서 <code>Option</code> 처리를 피할 수 있습니다.</p>

<p>물론 이는 디자인적 결정입니다. <code>Option</code> 을 허용하되 수퍼클래스를 인자로 받을것인가, 아니면 허용하지 않을것인가의 문제죠. 개인적으로는 프로그래밍 과정에서 타입을 점점 좁혀가면 오류의 여지를 줄일 수 있기 때문에 후자를 선호합니다. 그렇지 않으면 강력한 타입시스템을 갖춘 언어를 굳이 사용할 필요가 없겠지요.</p>

<p>타입을 이용한 오류방지 방법 관련해서 <a href="http://www.slideshare.net/IainHull/improving-correctness-with-types">Improving Correctness with Types</a> 를 읽어보시길 권합니다.</p>

<h2 id="monoidexamplefilter">Monoid Example: Filter</h2>

<p>간단한 <code>Monoid</code> 예제를 하나 만들어 보겠습니다. <code>User</code> 클래스가 있고, 필터링을 하고 싶을 때</p>

<pre><code class="language-scala">// http://www.slideshare.net/oxbow_lakes/practical-scalaz

case class User(name: String, city: String)  
type Filter[A] = A =&gt; Boolean // Function1, same as Reader[A, Boolean]

val london: Filter[User] = _.city endsWith(".LONDON")  
val ny: Filter[User]     = _.city endsWith(".NY")

val inLondon = users filter london  
val inNY = users filter ny  
</code></pre>

<p>이 때 만약 <code>Filter[A]</code> 가 <code>OR (||)</code> 연산에 대한 모노이드라면, 이렇게 쓸 수 있지 않을까요?</p>

<pre><code class="language-scala">users filter (london |+| ny)  
</code></pre>

<p>그런데 <code>Filter[A]</code> 는 모노이드가 아니기 때문에 그럴 수 없습니다. 우린 모노이드를 배운 사람들이니까 <del>지성인</del> 한 번 만들어 보겠습니다.</p>

<pre><code class="language-scala">implicit def booleanMonoid[A] = new Monoid[Filter[A]] = {  
  override def zero: Filter[A] = 
    false
  override def append(f1: Filter[A], f2: =&gt; Filter[A]): Filter[A] = 
    a =&gt; f1(a) || f2(a)
}
</code></pre>

<p><em>disjunction</em> 이죠? <em>Scalaz</em> 어딘가에 구현되어 있을것 같습니다.</p>

<pre><code class="language-scala">impilcit def booleanMonoid[A] =  
  function1Monoid[A, Boolean](booleanInstance.disjunction)
</code></pre>

<p><code>function1Monoid[A, R]</code> 은 결과값 <code>R</code> 에 대한 모노이드 <code>Monoid[R]</code> 를 필요로 하고 여기에 위에서 봤던 <code>Monoid[Boolean]</code> 인 <code>booleanInstance.disjunction</code> 을 넣으면, 우리가 원했던 <code>Monoid[Filter[A]</code> 가 완성됩니다.</p>

<pre><code class="language-scala">implicit def function1Monoid[A, R](implicit R0: Monoid[R]): Monoid[A =&gt; R] = new Function1Monoid[A, R] {  
  implicit def R = R0
}

private trait Function1Monoid[A, R] extends Monoid[A =&gt; R] with Function1Semigroup[A, R] {  
  implicit def R: Monoid[R]
  def zero = a =&gt; R.zero
}

object disjunction extends Monoid[Boolean] {  
    def append(f1: Boolean, f2: =&gt; Boolean) = f1 || f2
    def zero = false
}
</code></pre>

<p>그러면 이제 요구사항을 좀 더 까다롭게 해서, <strong>런던에 사는 켈리 또는 뉴욕에 사는 켈리</strong> 만 뽑아내려면 어떻게 해야할까요?</p>

<pre><code class="language-scala">// if we have `|*|` representing `Conjunction`

val kelly: Filter[User] = _.name.endsWith("Kelly")  
val myFriendKelly = (london |*| kelly) |+| (ny |*| kelly)  
users filter myFriendKelly  
</code></pre>

<p>그런데, <em>scalaz</em> 에서 할당한 모노이드 연산자는 <code>|+|</code> 하나뿐입니다. 따라서 <em>Implicit Class</em> 를 추가하면 </p>

<pre><code class="language-scala">implicit class FilterOps[A](fa: Function1[A, Boolean]) {  
  def |*|(other: Function1[A, Boolean]): Function1[A, Boolean] =
    function1Monoid[A, Boolean](booleanInstance.conjunction).append(fa, other)
}

val users = List(  
  User("Kelly", ".LONDON"),
  User("John", ".NY"),
  User("Cark", ".SEOUL"),
  User("Kelly", ".NY"),
  User("Kelly", ".SEOUL")
)

val ks1 = users filter ((london |*| isKelly) |+| (ny |*| isKelly))  
val ks1.size shouldBe 2

// 더 짧게 줄이면, 
val ks2 = users filter ((london |+| ny) |*| isKelly)  
</code></pre>

<p><code>scalaz.Monoid</code> 가 <code>|+|</code> 만을 지원하는 반면, 대수타입에 특화된 <em>Spire</em> 는 <code>Boolean</code> 에 대해 <code>*, +</code> 두 가지 연산을 모두 지원합니다. </p>

<pre><code class="language-scala">import spire.algebra.Rig

implicit def filterRig[A] = new Rig[Filter[A]] {  
  def plus(x: Filter[A], y: Filter[A]): Filter[A] = v =&gt; x(v) || y(v)
  def one: Filter[A] = Function.const(true)
  def times(x: Filter[A], y: Filter[A]): Filter[A] = v =&gt; x(v) &amp;&amp; y(v)
  def zero: Filter[A] = Function.const(false)
} 

import spire.syntax.rig._

users filter ((london + ny) * kelly)  
</code></pre>

<h2 id="monoidwithbooleanwoptionwandendo">Monoid with BooleanW, OptionW and Endo</h2>

<p><code>Boolean</code> 과 <code>Option</code> 은, 연산에 <code>if-else</code>, <code>getOrElse</code> 처럼  <strong>다른 경우</strong> 를 내포하기 때문에, <code>Monoid.zero</code> 와 엮으면 쏠쏠하게 써먹을 수 있습니다.</p>

<pre><code class="language-scala">&gt; load.ivy("org.scalaz" % "scalaz-core_2.11" % "7.2.0-M5")

&gt; import scalaz._, Scalaz._
import scalaz._, Scalaz._

&gt; ~ 1.some      // Some(1).getOrElse(Monoid[Int].zero)
res5: Int = 1  
&gt; ~ none[Int]   // None.getOrElse(Monoid[Int].zero)
res6: Int = 0  
&gt; none[Int] | 3 // None.getOrElse(3)
res7: Int = 3  
</code></pre>

<p><code>Boolean</code> 연산도 살펴보면,</p>

<pre><code class="language-scala">(true  ? 1 | 2) shouldBe 1
(false ? 1 | 2) shouldBe 2
(true  ?? 1) shouldBe 1
(false ?? 1) shouldBe 0 /* raise into zero */
(true  !? 1) shouldBe 0 /* reversed `??` */
(false !? 1) shouldBe 1
</code></pre>

<p><code>??</code> 는 조건이 참일경우, <code>A</code> 를 아닐 경우 <code>Monoid[A].zero</code> 를 돌려줍니다.</p>

<pre><code class="language-scala">final class BooleanOps(self: Boolean) {  
  ...
  final def ??[A](a: =&gt; A)(implicit z: Monoid[A]): A = b.valueOrZero(self)(a)
  final def !?[A](a: =&gt; A)(implicit z: Monoid[A]): A = b.zeroOrValue(self)(a)
  ...
}

trait BooleanFunctions {  
  ...
  final def valueOrZero[A](cond: Boolean)(value: =&gt; A)(implicit z: Monoid[A]): A = 
    if (cond) value else z.zero
  final def zeroOrValue[A](cond: Boolean)(value: =&gt; A)(implicit z: Monoid[A]): A = 
    if (!cond) value else z.zero
  ...
}
</code></pre>

<p><a href="http://www.slideshare.net/oxbow_lakes/practical-scalaz">Practical Scalaz</a> 에서는 <code>Endo</code> 와 엮어 다음처럼 사용하는걸 보여줍니다. (<code>new Filter</code> 부분을 추출하는것이 더 나은것 같습니다만, 그냥 이렇게도 사용할 수 있다 정도로 알고만 계시면 될 것 같습니다.)</p>

<pre><code class="language-xml">// http://www.slideshare.net/oxbow_lakes/practical-scalaz

&lt;instruments filter="incl"&gt;  
  &lt;symbol value="VOD.L" /&gt;
  &lt;symbol value="MSFT.O" /&gt; 
&lt;/instruments&gt;  
</code></pre>

<pre><code class="language-scala">// before
for {  
  e &lt;- xml \ "instrument"
  f &lt;- e.attribute("filter")
} yield
  (if f == "incl") new Filter(instr(e)) else new Filter(instr(e)).neg)

// after
val reverseFilter = Endo[Filter](_.neg)

for {  
  e &lt;- xml \ "instrument"
  f &lt;- e.attribute("filter")
} yield
  (f == "incl") !? reverseFilter apply new Filter(instr(e))
</code></pre>

<p>참고로 <code>Endo</code> 는 <code>Function1[A, A]</code> 입니다. 따라서 <code>Monoid[Endo[A]]</code> 는 <em>identity function</em> 입니다. </p>

<pre><code class="language-scala">final case class Endo[A](run: A =&gt; A) {  
  final def apply(a: A): A = run(a)

  /** Do `other`, than call myself with its result. */
  final def compose(other: Endo[A]): Endo[A] = Endo.endo(run compose other.run)

  /** Call `other` with my result. */
  final def andThen(other: Endo[A]): Endo[A] = other compose this
}

trait EndoFunctions {  
  /** Alias for `Endo.apply`. */
  final def endo[A](f: A =&gt; A): Endo[A] = Endo(f)

  /** Alias for `Monoid[Endo[A]].zero`. */
  final def idEndo[A]: Endo[A] = endo[A](a =&gt; a)

  ...
}
</code></pre>

<h2 id="examplecurrency">Example: Currency</h2>

<p>이제까지 배워왔던 바를 적용해서, 통화를 나타내는 <code>Currency</code> 모델을 만들어 보겠습니다. 위에선 <code>Tag</code> 를 이용했었으니, 이번엔 <em><a href="http://docs.scala-lang.org/overviews/core/value-classes.html">Value Class</a></em> 로 만들어 보겠습니다.</p>

<pre><code class="language-scala">object Currency {  
  sealed trait Currency extends Any
  final case class EUR[A](amount: A) extends AnyVal with Currency
  final case class USD[A](amount: A) extends AnyVal with Currency
}

// spec
USD(1) =:= USD(1)  
USD(3) =:= EUR(2) // compile error  
</code></pre>

<p>이제 <code>1.USD</code> 등 의 문법을 위해 <em>implicit class</em> 를 추가하면,</p>

<pre><code class="language-scala">Object Currency {  
  ...

  implicit class CurrencyOps[A](amount: A) {
    def EUR = Currency3.EUR(amount)
    def USD = Currency3.USD(amount)
  }
}

// spec
10.USD =:= 10.USD  
</code></pre>

<p>이제 같은 통화간 덧셈을 위해, <code>Monoid[USD[A]]</code> 등을 추가할 수 있습니다. <code>|+|</code> 는 기존의 <code>Monoid[A]</code> 를 이용하면 됩니다.</p>

<pre><code class="language-scala">object Currency {  
  import scalaz._, Scalaz._

  ...
  implicit def usdMonoid[A](implicit M: Monoid[A]) = new Monoid[USD[A]] {
    override def zero: USD[A] =
      USD(M.zero)

    override def append(u1: USD[A], u2: =&gt; USD[A]): USD[A] =
      USD(M.append(u1.amount, u2.amount))
  }
}

// spec
(10.USD |+| 10.USD) =:= 20.USD
</code></pre>

<p>이제 <code>EUR</code> 를 위한 모노이드를 만들어 보겠습니다. 재미삼아 <em><a href="http://docs.scala-lang.org/tutorials/FAQ/context-and-view-bounds.html">context bound</a></em> 를 이용해 보면,</p>

<pre><code class="language-scala">object Currency {  
  ...

  implicit def eurMonoid[A : Monoid] = new Monoid[EUR[A]] {
    override def zero: EUR[A] =
      EUR(implicitly[Monoid[A]].zero)

    override def append(e1: EUR[A], e2: =&gt; EUR[A]): EUR[A] =
      EUR(implicitly[Monoid[A]].append(e1.amount, e2.amount))
  }
}
</code></pre>

<p>통화가 추가될때 마다 매번 반복적으로 모노이드를 추가해야된다는 것이 귀찮으므로, <code>Currency</code> 용 모노이드를 만들겠습니다. <em><a href="https://github.com/milessabin/shapeless">Shapeless</a></em> 를 이용하면, (<em>Shapeless</em> 의 <code>Generic</code>, <code>Aux</code> 는 아래에서 설명하겠습니다)</p>

<pre><code class="language-scala">object Currency {  
  import scalaz._, Scalaz._
  import shapeless._

  ...
  implicit def currencyMonoid[A : Monoid, C[_] &lt;: Currency]
  (implicit G: Generic.Aux[C[A], A :: HNil]) = new Monoid[C[A]] {
    override def zero: C[A] =
      G.from(implicitly[Monoid[A]].zero :: HNil)

    override def append(c1: C[A], c2: =&gt; C[A]): C[A] = {
      val a1: A = G.to(c1).head
      val a2: A = G.to(c2).head

      G.from(implicitly[Monoid[A]].append(a1, a2) :: HNil)
    }
  }
}
</code></pre>

<p>이제 통화간 변환을 위한 함수를 추가해보도록 하겠습니다. 이런 문법은 어떨까요?</p>

<pre><code class="language-scala">12.USD to EUR  
</code></pre>

<p>그런데, 현재 우리가 가진 디자인에서 <code>EUR</code> 은 <em>case class</em> 이므로 <code>EUR</code> 생성없이 타입만 지정하려면 이정도 문법으로 타협할 수 있겠네요.</p>

<pre><code class="language-scala">24.USD to[EUR]  
</code></pre>

<p><code>Currency</code> 에서 <code>to</code> 구현을 하려면, <code>to[C[_] &lt;: Currency[_]]</code> 정도로 하위 클래스는 퉁친다 해도, 하위 클래스 인스턴스 생성시에 <code>A</code> 가 필요하므로 <code>Currency</code> 를 <code>Currency[A]</code> 로 변경해야 합니다.</p>

<pre><code class="language-scala">object Currency {  
  sealed trait Currency[A] extends Any {
    def amount: A
  }

  final case class EUR[A](amount: A) extends AnyVal with Currency[A]
  final case class USD[A](amount: A) extends AnyVal with Currency[A]

  implicit class CurrencyOps[A](amount: A) {
    def EUR = Currency3.EUR(amount)
    def USD = Currency3.USD(amount)
  }

  implicit def currencyMonoid[A : Monoid, C[A] &lt;: Currency[A]]
  (implicit G: Generic.Aux[C[A], A :: HNil]) = new Monoid[C[A]] {
    override def zero: C[A] =
      G.from(implicitly[Monoid[A]].zero :: HNil)

    override def append(c1: C[A], c2: =&gt; C[A]): C[A] = {
      val a1: A = G.to(c1).head
      val a2: A = G.to(c2).head

      G.from(implicitly[Monoid[A]].append(a1, a2) :: HNil)
    }
  }
}
</code></pre>

<p>이제 <code>Currency</code> 에 <code>to</code> 를 추가하면,</p>

<pre><code class="language-scala">object Currency {  
  ...

  sealed trait Currency[A] extends Any {
    def amount: A
    def to[C[A] &lt;: Currency[A]](implicit G: Generic.Aux[C[A], A :: HNil]): C[A] =
      G.from(amount :: HNil)
  }

  ...
}

// spec
(10.USD.to[EUR]) =:= 10.EUR
</code></pre>

<p><code>to</code> 에 <code>implicit</code> 로 통화간 환율을 담고있는 <code>R: Rate</code> 등을 추가하고 <code>Rate</code> 내에서 <code>Monoid[A @@ Multiplcation</code> 을 이용하면 컴파일타임에 </p>

<ul>
<li><code>USD -&gt; EUR</code> 변환이 정의되어 있는지 (<a href="https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#heterogenous-maps">Shapeless Heterogenous Maps</a>)</li>
<li><code>A</code> 에 대한 곱셈 연산 <code>Monoid[A @@ Multiplication]</code> 이 정의 되어있는지를 검사할 수 있습니다.</li>
</ul>

<p><del>구현은 숙제로.. 제가 귀찮아서가 절대 아닙니다</del></p>

<p>디자인적인 결정이겠으나, <code>USD</code>, <code>EUR</code> 등을 <code>object</code> 로 만들고 <code>case class Money[A](amount: A, currency: Currency)</code> 로 구현할수도 있겠습니다. 관심 있으신 분은 <a href="https://github.com/lambdista/money">github.com/lambdista/money</a> 를 참조하시면 됩니다.</p>

<h2 id="shapeless">Shapeless</h2>

<p><em>Shapeless</em> 는 많은 기능을 가지고 있기 때문에 여기서 모든걸 설명하긴 어렵고, 위에서 사용한 <code>Generic</code>, <code>Aux</code> 에 대해 간단히 소개만 하겠습니다. (관심 있으신 분은 <a href="https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0">Shapeless - Feature 2.0.0</a> 를 참조하시면 됩니다.)</p>

<pre><code class="language-scala">// https://github.com/milessabin/shapeless/blob/master/core/src/main/scala/shapeless/generic.scala

&gt; load.ivy("com.chuusai" %% "shapeless" % "2.2.5")

&gt; import shapeless._
import shapeless._

&gt; case class Cat(name: String, catAge: Double)
defined class Cat  
&gt; Generic[Cat]
res4: Generic[Cat] {  
  type Repr = 
    shapeless.::[String,shapeless.::[Double,shapeless.HNil]]
} = ...
</code></pre>

<p><code>Generic[A]</code> 는 <a href="http://danielwestheide.com/blog/2013/02/13/the-neophytes-guide-to-scala-part-13-path-dependent-types.html">Path-Dependent Type</a> 으로 <code>Repr</code> 을 가지고 있습니다. 이는 <code>A</code> 에 따라 달라지는 값인데, 보통 <code>R</code> 로 표기합니다.</p>

<pre><code class="language-scala">// https://github.com/milessabin/shapeless/blob/master/core/src/main/scala/shapeless/generic.scala#L103

trait Generic[T] extends Serializable {  
  /** The generic representation type for {T}, which will be composed of {Coproduct} and {HList} types  */
  type Repr

  /** Convert an instance of the concrete type to the generic value representation */
  def to(t : T) : Repr

  /** Convert an instance of the generic representation to an instance of the concrete type */
  def from(r : Repr) : T
}
</code></pre>

<p><code>Generic.Aux[A, R]</code> 는 <code>Generic[A]</code> 의 <code>Repr</code> 에 <code>R</code> 을 사용하는것으로, <code>Generic[A] { type Repr = R }</code> 과 동일합니다.</p>

<pre><code class="language-scala">// https://github.com/milessabin/shapeless/blob/master/core/src/main/scala/shapeless/generic.scala#L148

object Generic {  
  ...

  type Aux[T, Repr0] = Generic[T] { type Repr = Repr0 }

  ...
}
</code></pre>

<p><code>Generic.Aux[A, R]</code> 을 이용하면, 타입수준의 표현 <code>R</code> 과 실제 타입 <code>A</code> 간<em>isomorphic</em> 변환을 수행할 수 있습니다. 위에서 봤던 <code>to</code> 와 <code>from</code> 기억 하시죠? </p>

<p>만약 <code>R</code> 이 기본적인 타입이어서, <code>Generic.Aux[A, R]</code> 이 Shapeless 에서 자동 생성해 줄 경우 <code>Currency</code> 예제에서 보았듯이 <code>implicit</code> 로 가져오면, 바로 이용할 수 있습니다. </p>

<p><em>primitive</em> 는 물론 <em>case class</em> 도 <code>Generic[Cat]</code> 처럼 자동생성되어 바로 가져다 쓸 수 있습니다. 중첩된것두 가능하구요.</p>

<pre><code class="language-scala">&gt; case class EnhancedCat(catType: String, cat: Cat)
defined class EnhancedCat

&gt; Generic[EnhancedCat]
res6: Generic[EnhancedCat] {  
  type Repr = shapeless.::[String,shapeless.::[cmd3.Cat,shapeless.HNil]]
} = ...
</code></pre>

<p>여기서 <code>HList</code> 는 (<a href="https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#heterogenous-lists">Heterogenous List</a>) 여러 타입을 담을 수 있는 리스트입니다.</p>

<p>이제 <code>to</code> 와 <code>from</code> 예제를 보면</p>

<pre><code class="language-scala">&gt; val c1 = Cat("odie", 1.0)
c1: Cat = Cat("odie", 1.0)

&gt; Generic[Cat].to(c1)
res9: String :: Double :: HNil = ::("odie", ::(1.0, HNil))

&gt; val reconstructed = Generic[Cat].from(res9)
reconstructed: Cat = Cat("odie", 1.0)

&gt; case class Dog(name: String, dogAge: Double)
defined class Dog

&gt; val d1 = Dog("dog odie", 1.0)
d1: Dog = Dog("dog odie", 1.0)

&gt; Generic[Dog].to(d1)
res13: String :: Double :: HNil = ::("dog odie", ::(1.0, HNil))

&gt; val reconstructedFromDog = Generic[Cat].from(res13)
reconstructedFromDog: Cat = Cat("dog odie", 1.0)  
</code></pre>

<p><a href="https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/">metaplasm.us - Type Classes and Generic Derivation</a> 에서는 <em>Shapeless</em> 를 이용해서 문자열로부터 <em>case class</em> 를 자동생성하는 파서를 만드는 법을 보여줍니다.</p>

<p><code>CaseClassParser</code> 가 있을 때, 문자열 <code>"odie, 1.2"</code> 를 <code>Dog</code> 로 파싱하기 위해 <code>CaseClassParser[Dog]("odie, 1.2")</code> 처럼 쓰고싶다고 하면,</p>

<pre><code class="language-scala">// ref - https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/

object CaseClassParser {  
  import shapeless._

  trait Parser[A] {
    def apply(s: String): Option[A]
  }

  def apply[A](s: String)(implicit P: Parser[A]): Option[A] = P(s)
}
</code></pre>

<p>이 때 <code>shapeless.Generic[A]</code> 를 이용하면 위에서 보았듯이 <code>A</code> 를 <code>HList</code> 로 (<a href="https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#heterogenous-lists">Heterogenous List</a>) 로 변경할 수 있으므로 <code>Parser[HList]</code> 만 있으면 됩니다.</p>

<p><code>HList</code> 도 <code>List</code> 처럼 <code>cons</code> 와 <code>nil</code> 로 구성되어 있습니다. <code>HNil</code> 과 <code>HList</code> 파서를 만들면,</p>

<pre><code class="language-scala">// ref - https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/

object CaseClassParser {  
  ...

  implicit val hnilParser = new Parser[HNil] {
    override def apply(s: String): Option[HNil] =
      if (s.isEmpty) Some(HNil) else None
  }

  implicit def hlistParser[H : Parser, T &lt;: HList : Parser] = new Parser[H :: T] {
    override def apply(s: String): Option[H :: T] =
      s.split(",").toList match {
        case cell +: rest /* use `+:` instead of :: */ =&gt; for {
          head &lt;- implicitly[Parser[H]].apply(cell)
          tail &lt;- implicitly[Parser[T]].apply(rest.mkString(","))
        } yield head :: tail
      }
  }
}
</code></pre>

<p>그리고 <code>implicitly[Parser[H]]</code> 에서 사용할 개별 타입별 파서를 만들면</p>

<pre><code class="language-scala">// ref - https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/

object CaseClassParser {  
  ...

  implicit val intParser = new Parser[Int] {
    override def apply(s: String): Option[Int] = Try(s.toInt).toOption
  }

  implicit val stringParser = new Parser[String] {
    override def apply(s: String): Option[String] = Some(s)
  }

  implicit val doubleParser = new Parser[Double] {
    override def apply(s: String): Option[Double] = Try(s.toDouble).toOption
  }
}
</code></pre>

<p>마지막으로, <em>case class</em> 를 <code>HList</code> 로 만들어줄 <code>caseClassParser</code> 만 만들면 됩니다.</p>

<pre><code class="language-scala">// ref - https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/

object CaseClassParser {  
  ...

  implicit def caseClassParser[C, R &lt;: HList]
  (implicit G: Generic.Aux[C, R], reprParser: Parser[R]): Parser[C] = new Parser[C] {
    override def apply(s: String): Option[C] = reprParser.apply(s).map(G.from)
  } 
}
</code></pre>

<p><code>reprParser.apply(s)</code> 는 <code>Option[R]</code> 이므로 <code>G.from</code> 을 이용해 변환해주면 됩니다.</p>

<h2 id="previousposts">Previous Posts</h2>

<ul>
<li><a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1, State</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/">Easy Scalaz 2, Monad Transformer</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/">Easy Scalaz 3, ReaderWriterState with Kleisli</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/">Easy Scalaz 4, Yoneda and Free Monad</a> </li>
</ul>

<h2 id="references">References</h2>

<ul>
<li><a href="http://cs.lth.se/edan40">Haskell Image</a></li>
<li><a href="http://eed3si9n.com/learning-scalaz/Tagged+type.html">Learning Scalaz: Tagged Type</a></li>
<li><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Tag.scala">Scalaz 7.2: Tag.scala</a></li>
<li><a href="https://groups.google.com/forum/#!topic/scalaz/Py_IIfp9d2Q">Scalaz Google Groups: Value Class vs Tag</a></li>
<li><a href="http://docs.scala-lang.org/overviews/core/value-classes.html">Scala Docs: Value Classes</a></li>
<li><a href="http://docs.scala-lang.org/tutorials/FAQ/context-and-view-bounds.html">Scala Docs: Context Bound</a></li>
<li><a href="http://etorreborre.blogspot.kr/2011/11/practical-uses-for-unboxed-tagged-types.html">Practical uses for Unboxed Tagged Types</a></li>
<li><a href="http://www.slideshare.net/IainHull/improving-correctness-with-types">Improving Correctness with Types</a></li>
<li><a href="http://underscore.io/blog/posts/2014/01/29/unboxed-tagged-angst.html">Underscore: Unboxed Tagged Angst</a></li>
<li><a href="http://www.slideshare.net/oxbow_lakes/practical-scalaz">Slideshare: Practical Scalaz</a></li>
<li><a href="http://stackoverflow.com/questions/34266285/tagged-type-comparison-in-scalaz">Stackoverflow: Tagged Type Comprarison in Scalaz</a></li>
<li><a href="https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0">Shapeless: Feature 2.0.0</a></li>
<li><a href="http://danielwestheide.com/blog/2013/02/13/the-neophytes-guide-to-scala-part-13-path-dependent-types.html">The Neophyte's Guide to Scala Part 13: Path-Dependent Type</a></li>
<li><a href="https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/">metaplasm.us: Type classes and generic derivation</a></li>
<li><a href="http://stackoverflow.com/questions/33585441/constructing-simple-scala-case-classes-from-strings-strictly-without-boiler-pla/33586304#33586304">Stackoverflow: Constructing simple Scala case classes from Strings, strictly without boiler-plate</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Easy Scalaz 4, Yoneda and Free Monad]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p><code>Free[F, A]</code> 를 이용하면 Functor <code>F</code> 를 Monad 인스턴스로 만들 수 있습니다. 그런데, <code>Coyoneda[G, A]</code> 를 이용하면 아무 타입 <code>G</code> 나 Functor 인스턴스로 만들 수 있으므로 어떤 타입이든 (심지어 방금 만든 <em>case class</em> 조차) 모나드 인스턴스로 만들 수 있습니다.</p>

<p><code>Free</code> 를 이용하면 사용자는 자신만의 <em>Composable DSL</em> 을 구성하고,</p>]]></description><link>http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/</link><guid isPermaLink="false">4bdf7e2f-ba28-4630-80d2-b44b3953a5a8</guid><category><![CDATA[scala]]></category><category><![CDATA[monad]]></category><category><![CDATA[monoid]]></category><category><![CDATA[scalaz]]></category><category><![CDATA[free]]></category><category><![CDATA[trampoline]]></category><category><![CDATA[yoneda]]></category><category><![CDATA[coyoneda]]></category><category><![CDATA[free monoid]]></category><category><![CDATA[free monad]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 06 Dec 2015 08:34:34 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p><code>Free[F, A]</code> 를 이용하면 Functor <code>F</code> 를 Monad 인스턴스로 만들 수 있습니다. 그런데, <code>Coyoneda[G, A]</code> 를 이용하면 아무 타입 <code>G</code> 나 Functor 인스턴스로 만들 수 있으므로 어떤 타입이든 (심지어 방금 만든 <em>case class</em> 조차) 모나드 인스턴스로 만들 수 있습니다.</p>

<p><code>Free</code> 를 이용하면 사용자는 자신만의 <em>Composable DSL</em> 을 구성하고, 구성한 모나딕 연산을 실행하는 해석기를 작성하게 됩니다. 즉, <strong>연산의 생성</strong> 과 <strong>연산의 실행</strong> 을 분리하여 다루게 됩니다. 이는 <em>side-effect</em> 를 실행 시점으로 미룰 수 있다는 뜻입니다. (실행용 해석기와 별도로 테스트용 해석기를 작성하는 것도 가능합니다)</p>

<p>그러면, 제가 가장 좋아하는 <a href="http://tpolecat.github.io/assets/sbtb-slides.pdf">Programs as Values: Fure Functional JDBC Programming</a> 예제로 시작해보겠습니다.</p>

<h2 id="ifwehaveamonad">If We Have a Monad</h2>

<p>JDBC 를 쌩으로 사용한다면, 다음과 같은 코드를 작성해야 할텐데</p>

<pre><code class="language-scala">// ref - http://tpolecat.github.io/

case class Person(name: String, age: Int)

def getPerson(rs: ResultSet): Person {  
  val name = rs.getString(1)
  val age  = rs.getInt(2)
}
</code></pre>

<p>다음과 같은 문제점이 있습니다.</p>

<ul>
<li><em>managed resource</em> 인 <code>ResultSet</code> 을 프로그래머가 다룰 수 있습니다. 어디에 저장이라도 하고 나중에 사용한다면 문제가 될 수 있습니다.</li>
<li><code>rs.get*</code> 은 <em>side-effect</em> 를 만들어 내므로 테스트하기 쉽지 않습니다.</li>
</ul>

<p>접근 방식을 바꿔보는건 어떨까요? 프로그램을 실행해서 <em>side-effect</em> 를 즉시 만드는 대신</p>

<ul>
<li>어떤 연산을 수행할지를 <em>case class</em> 로 만들고 이것들을 조합해 어떤 연산을 수행할지 나타낸뒤에</li>
<li>연산의 조합을 번역해 실행하는 해석기(<em>interpreter</em>) 를 만들어 보겠습니다.</li>
</ul>

<p>먼저 연산부터 정의하면,</p>

<pre><code class="language-scala">sealed trait ResultSetOp[A]

final case class GetString(index: Int) extends ResultSetOp[String]  
final case class GetInt(index: Int)    extends ResultSetOp[Int]  
final case object Next                 extends ResultSetOp[Boolean]  
final case object Close                extends ResultSetOp[Unit]  
</code></pre>

<p>이 때 만약 <code>ResultSetOp[A]</code> 가 모나드라면 다음과 같이 작성할 수 있습니다.</p>

<pre><code class="language-scala">def getPerson: ResultSetOp[Person] = for {  
  name &lt;- GetString(1)
  age  &lt;- GetInt(2)
} yield Person(name, age)

// Application Operation `*&gt;`  (e.g `1.some *&gt; 2.some== 2.some)
// See, http://eed3si9n.com/learning-scalaz/Applicative.html
def getNextPerson: ResultSetOp[Person] =  
  Next *&gt; getPerson

def getPeople(n: Int): ResultSet[List[Person]] =  
  getNextPerson.repicateM(n) // List.fill(n)(getNextPerson).sequence

def getAllPeople: ResultSetIO[Vector[Person]] =  
  getPerson.whileM[Vector](Next)
</code></pre>

<p><code>ResultSetIO</code> 는 모나드가 아니므로 위와 같이 작성할 수 없습니다.</p>

<h3 id="writingyourowndsl">Writing Your own DSL</h3>

<p>놀랍게도, <code>ResultSetIO</code> 를 모나드로 만들 수 있습니다. <code>flatMap</code>, <code>unit</code> 구현 없이 얻을 수 있는 공짜 모나드입니다. 방법은 이렇습니다.</p>

<ul>
<li><code>Free[F[_], ?]</code> 는 <code>Functor</code> <code>F</code> 에 대해 <code>Monad</code> 입니다</li>
<li><code>Coyoneda[S[_], ?]</code> 는 아무 타입 <code>S</code> 에 대해 <code>Functor</code> 입니다. </li>
</ul>

<p>따라서 <code>Free[Coyoneda[S, A], A</code> 는 아무 타입 <code>S</code> 에 대해서 모나드입니다. </p>

<pre><code class="language-scala">import scalaz.{Free, Coyoneda}, Free._

// ResultSetOpCoyo is the Functor
type ResultSetOpCoyo[A] = Coyoneda[ResultSetOp, A] 

// ResultSetIO is the Monad
type ResultSetIO[A] = Free[ResultSetOpCoyo, A]

// same as
// type ResultSetIO2[A] = Free[({ type λ[α] = Coyoneda[ResultSetOp, α]})#λ, A]
</code></pre>

<p>따라서 다음처럼 작성할 수 있습니다.</p>

<pre><code class="language-scala">val next                 : ResultSetIO[Boolean] = Free.liftFC(Next)  
def getString(index: Int): ResultSetIO[String]  = Free.liftFC(GetString(index))  
def getInt(index: Int)   : ResultSetIO[Int]     = Free.liftFC(GetInt(index))  
def close                : ResultSetIO[Unit]    = Free.liftFC(Close)  
</code></pre>

<p>여기서 <code>Free.listFC</code> 는 타입 <code>ResultSetOp</code> 를 바로 <code>ResultSetIO</code> 로 리프팅 해주는 헬퍼 함수입니다. (<code>F</code> = <em>Free</em>, <code>C</code> = <em>Coyoneda</em>)</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Free.scala#L30

/** A version of `liftF` that infers the nested type constructor. */
def liftFU[MA](value: =&gt; MA)(implicit MA: Unapply[Functor, MA]): Free[MA.M, MA.A] =  
  liftF(MA(value))(MA.TC)

/** A free monad over a free functor of `S`. */
def liftFC[S[_], A](s: S[A]): FreeC[S, A] =  
    liftFU(Coyoneda lift s)
</code></pre>

<p><code>liftFU[MA]</code> 에서, <code>MA = Coyoneda[ResultSetOp, A]</code> 로 보면 <code>Free[MA.M, MA.A]</code> 는 <code>Free[Coyoneda[ResultSetOp, A], A]</code> 가 됩니다. (<a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Unapply.scala#L51">Unapply.scala</a>)</p>

<p>이를 이용해서 <code>get*</code> 를 작성해 보면</p>

<pre><code class="language-scala">import scalaz._, Scalaz._

def getPerson: ResultSetIO[Person] = for {  
  name &lt;- getString(1)
  age  &lt;- getInt(2)
} yield Person(name, age)

def getNextPerson: ResultSetIO[Person] =  
  next *&gt; getPerson

def getPeople(n: Int): ResultSetIO[List[Person]] =  
  getNextPerson.replicateM(n) // List.fill(n)(getNextPerson).sequence

def getPersonOpt: ResultSetIO[Option[Person]] =  
  next &gt;&gt;= {
    case true  =&gt; getPerson.map(_.some)
    case false =&gt; none.point[ResultSetIO]
  }

def getAllPeople: ResultSetIO[Vector[Person]] =  
  getPerson.whileM[Vector](next)
</code></pre>

<h3 id="dslinterpreter">DSL Interpreter</h3>

<p>이제 <code>RestSetOp</code> 로 작성한 연산 (일종의 프로그램) 을 실행하려면, <code>ResetSetOp</code> 명령(<em>case class</em>) 을, 로직(<em>side-effect</em> 를 유발할 수 있는) 으로 변경해야 합니다. </p>

<p><code>NaturalTransformation</code> 을 이용할건데, <code>F ~&gt; G</code> 는 <code>F</code> 를 <code>G</code> 로 변경하는 변환(<em>Transformation</em>) 을 의미합니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/package.scala#L113

/** A [[scalaz.NaturalTransformation]][F, G]. */
type ~&gt;[-F[_], +G[_]] = NaturalTransformation[F, G]

// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/NaturalTransformation.scala#L14
/** A universally quantified function, usually written as `F ~&gt; G`,
  * for symmetry with `A =&gt; B`.
  *
  * Can be used to encode first-class functor transformations in the
  * same way functions encode first-class concrete value morphisms;
  * for example, `sequence` from [[scalaz.Traverse]] and `cosequence`
  * from [[scalaz.Distributive]] give rise to `([a]T[A[a]]) ~&gt;
  * ([a]A[T[a]])`, for varying `A` and `T` constraints.
  */
trait NaturalTransformation[-F[_], +G[_]] {  
  self =&gt;
  def apply[A](fa: F[A]): G[A]

  def compose[E[_]](f: E ~&gt; F): E ~&gt; G = new (E ~&gt; G) {
    def apply[A](ea: E[A]) = self(f(ea))
  }

  def andThen[H[_]](f: G ~&gt; H): F ~&gt; H =
    f compose self
}
</code></pre>

<p>이제, <code>ResultSetOp</code> 를 <code>IO</code> 로 변경하는 해석기를 작성하면, (<a href="http://eed3si9n.com/learning-scalaz/IO+Monad.html">Learning Scalaz - IO</a>)</p>

<pre><code class="language-scala">import scalaz.effect._

private def interpret(rs: ResultSet) = new (ResultSetOp ~&gt; IO) {  
    def apply[A](fa: ResultSetOp[A]): IO[A] = fa match {
      case Next         =&gt; IO(rs.next)
      case GetString(i) =&gt; IO(rs.getString(i))
      case GetInt(i)    =&gt; IO(rs.getInt(i))
      case Close        =&gt; IO(rs.close)
      // more... 
    }
}

def run[A](a: ResultSetIO[A], rs: ResultSet): IO[A] =  
  Free.runFC(a)(interpret(rs))
</code></pre>

<h2 id="whyfree">Why Free?</h2>

<p><code>Free</code> 가 제공하는 가치는 다음과 같습니다. (Ref - <a href="http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern">StackExchange</a>)</p>

<ul>
<li>It is a lightweight way of <strong>creating a domain-specific language that gives you an AST</strong>, and then having <strong>one or more interpreters</strong> to <strong>execute the AST</strong> however you like</li>
<li>The free monad part is just a handy way to get an AST that you can assemble using Haskell's standard monad facilities (like do-notation) without having to write lots of custom code. This also ensures that your DSL is composable</li>
<li>You could then interpret this however you like: run it against a live database, run it against a mock, just log the commands for debugging or even try optimizing the queries</li>
</ul>

<p>즉, <code>Free</code> 는 우리는 자신만의 Composable 한 DSL 을 구축하고, 필요에 따라 이 DSL 다른 방식으로 해석할 수 있도록 도와주는 도구입니다. </p>

<h2 id="free">Free</h2>

<p>(<code>Free</code> 와 <code>Yoneda</code> 는 난해할 수 있으니, <code>Free</code> 를 어떻게 사용하는지만 알고 싶다면 <a href="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/#reasonablypricedmonad">Reasonably Priced Monad</a> 로 넘어가시면 됩니다.)</p>

<p>어떻게 <code>F</code> 가 <code>Functor</code> 이기만 하면 <code>Free[F[_], ?]</code> 가 모나드가 되는걸까요? 이를 알기 위해선, 모나드가 어떤 구조로 이루어져 있는지 알 필요가 있습니다.</p>

<h3 id="monad">Monad</h3>

<blockquote>
  <p>A monad is just a monoid in the category of endofunctors, what's the problem?</p>
</blockquote>

<p><del>의사양반 이게 무슨소리요!</del></p>

<p>이제 <code>Monoid</code> 와 <code>Functor</code> 가 무엇인지 알아봅시다.</p>

<h2 id="monoid">Monoid</h2>

<p>어떤 집합 <code>S</code> 에 대한 닫힌 연산 <code>*</code>, 집합 내의 어떤 원소 <code>e</code> 가 다음을 만족할 경우 모노이드라 부릅니다.</p>

<ul>
<li><code>e * a = a = a * e</code> (<em>identity</em>)</li>
<li><code>(a * b) * c = a * (b * c)</code> (<em>associativity</em>)</li>
</ul>

<p>일반적으로 <code>e</code> 를 항등원이라 부릅니다. <code>Option[A]</code> 도 <code>None</code> 을 항등원으로 사용하고, <em>associativity</em> 를 만족하는 <code>A</code> 의 연산을 사용하면 모노이드입니다. 따라서 <code>A</code> 가 모노이드면 <code>Option[A]</code> 도 모노이드입니다. (활용법은 <a href="http://www.slideshare.net/oxbow_lakes/practical-scalaz">Practical Scalaz</a> 참조)</p>

<pre><code class="language-scala">&gt; load.ivy("org.scalaz" % "scalaz-core_2.11" % "7.2.0-M5")
&gt; import scalaz._, Scalaz._


&gt; 1.some |+| 2.some
res11: Option[Int] = Some(3)  
&gt; 1.some |+| none
res12: Option[Int] = Some(1)  
&gt; none[Int] |+| 1.some
res13: Option[Int] = Some(1)  
</code></pre>

<h2 id="functor">Functor</h2>

<p><code>Functor</code> 는 일반적으로 다음처럼 정의되는데, 이는 <code>Functor F</code> 가 <code>F</code> 에서 값을 꺼내, 함수를 적용해 값을 변경할 수 있다는 것을 의미합니다.</p>

<blockquote>
  <p>A functor may go from one category to a different one</p>
</blockquote>

<pre><code class="language-scala">trait Functor[F[_]] {  
  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]
}
</code></pre>

<p>그리고 <code>Functor</code> 는 <em>identity function</em> 을 항등원으로 사용하면, 모노이드입니다.</p>

<ul>
<li><code>F.map(x =&gt; x) == F</code> </li>
<li><code>F map f map g == F map (f compose g)</code></li>
</ul>

<p>이 때, 변환의 인풋과 아웃풋이 같은 카테고리라면 이 <code>Functor</code> 를 <em>endo-functor</em> 라 부릅니다. </p>

<blockquote>
  <p>A functor may go from one category to a different one, an endofunctor is a functor for which start and target category are the same.</p>
</blockquote>

<h2 id="monad">Monad</h2>

<p>그럼 다시 처음 문장으로 다시 돌아가면, </p>

<blockquote>
  <p>Monads are just monoids in the category of endofunctors</p>
</blockquote>

<p>이 것의 의미를 이해하려면 모나드가 무엇인지 알아야 합니다.</p>

<pre><code class="language-scala">trait Monad[F[_]] {  
  def point[A](a: A): F[A]
  def join[A](ffa: F[F[A]): F[A]
  ...
}
</code></pre>

<p>일반적으로는 <code>point</code> (=<code>return</code>) 와 <code>bind</code> (= <code>flatMap</code>) 으로 모나드를 정의하나, <code>join</code>, <code>map</code> 으로도 <code>bind</code> 를 정의할 수 있습니다.</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

trait Monad[F[_]] {  
  def point[A](a: A): F[A]
  def bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]

  def map[A, B](fa: F[A])(f: A =&gt; B): F[B] = 
    bind(fa)(a =&gt; point(f(a))    
  def join[A](ffa: F[F[A]): F[A] = 
    bind(ffa)(fa =&gt; fa)
}

trait Monad[F[_]] {  
  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]
  def point[A](a: A): F[A]
  def join[A](ffa: F[F[A]): F[A] /* flatten*/

  def bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B] = 
    join(map(fa)(f))
}
</code></pre>

<p><code>map</code>, <code>point</code>, <code>join</code> 관점에서 모나드를 바라보면,</p>

<ul>
<li><strong>(endo)functor</strong> <code>T : X → X</code></li>
<li><strong>natural transformation</strong> <code>μ : T × T → T</code> (where <code>×</code> means functor composition (also known as <code>join</code> in Haskell)</li>
<li><strong>natural transformation</strong>  <code>η : I → T</code> (where <code>I</code> is the identity endofunctor on <code>X</code> also known as <code>return</code> in Haskell)</li>
</ul>

<p>이때 위 연산들이 모노이드 법칙을 만족합니다.</p>

<ul>
<li><code>e * a = a = a * e</code> (<em>identity</em>)</li>
<li><p><code>(a * b) * c = a * (b * c)</code> (<em>associativity</em>)</p></li>
<li><p><code>μ(η(T)) = T = μ(T(η))</code> (<em>identity</em>)</p></li>
<li><code>μ(μ(T × T) × T)) = μ(T × μ(T × T))</code> (<em>associativity</em>)</li>
</ul>

<p>스칼라 코드로 보면,</p>

<pre><code class="language-scala">&gt; import scalaz._, Scalaz._

&gt; val A = List(1, 2)
List[Int] = List(1, 2)

// identity left-side: μ(η(T)) = T
&gt; A.map(x =&gt; Monad[List].point(x)).flatten
List[Int] = List(1, 2)

// identity right-side: μ(T(η)) = T
&gt; Monad[List].point(A).flatten
List[Int] = List(1, 2)

// associativity
&gt; val T = List(1, 2, 3, 4)
T: List[Int] = List(1, 2, 3, 4)  
&gt; val TT = T.map(List(_))
TT: List[List[Int]] = List(List(1), List(2), List(3), List(4))

// associativity left-side: μ(μ(T × T) × T))
&gt; TT.flatten.map(List(_))
res30: List[List[Int]] = List(List(1), List(2), List(3), List(4))  
&gt; TT.flatten.map(List(_)).flatten
res31: List[Int] = List(1, 2, 3, 4)

// associativity right-side: μ(T × μ(T × T))
&gt; List(TT.flatten)
res34: List[List[Int]] = List(List(1, 2, 3, 4))  
&gt; List(TT.flatten).flatten
res35: List[Int] = List(1, 2, 3, 4)  
</code></pre>

<p>따라서 <em>Monad</em>는 <em>(endo)Functor</em> 카테고리에 대한 <em>Monoid</em> 입니다.</p>

<h2 id="freemonoid">Free Monoid</h2>

<p><em>Free Monad</em> 가 <code>bind</code>, <code>point</code> 에 대한 구현 없이, 모나드가 되듯이 <em>Free Monoid</em> 또한 연산과 항등원에 대한 구현 없이 <em>구조적</em> 으로 모노이드입니다. </p>

<p>항등원과 연산을 <code>Zero</code>, <code>Append</code> 라는 이름으로 <em>구조화</em> 하면,</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

sealed trait FreeMonoid[+A]  
final case object Zero extends FreeMonoid[Nothing]  
final case class Value[A](a: A) extends FreeMonoid[A]  
final case class Append[A](l: FreeMonoid[A], r: FreeMonoid[A]) extends FreeMonoid[A]  
</code></pre>

<p>모노이드는 <em>associativity</em> 를 만족하므로, <code>Append</code> 를 우측 결합으로 바꾸고, <code>Zero</code> 로 끝나도록 하면</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

sealed trait FreeMonoid[+A]  
final case object Zero extends FreeMonoid[Nothing]  
final case class Append[A](l: A, r: FreeMonoid[A]) extends FreeMonoid[A]  
</code></pre>

<p><code>List</code> 와 동일한 구조임을 알 수 있습니다. 실제로, 리스트는 <em>concatenation</em> 연산, <code>Nil</code> 항등원에 대해 모노이드입니다.</p>

<h2 id="freemonad">Free Monad</h2>

<p>이제까지의 내용을 정리하면</p>

<ul>
<li>Monad is a monoid of functors</li>
<li>Then, <strong>Free Monad is a free Monoid of functors</strong> </li>
</ul>

<p>따라서 <em>Free Monad</em> 는 <em>Functor</em> 의 <em>List</em> 라 볼 수 있습니다.</p>

<p>모나드의 <code>point</code>, <code>join</code> 을 <em>구조화</em> (<em>타입화</em>) 하면, </p>

<pre><code class="language-scala">def point[A](a: A): F[A]  
def join[A, B](ffa: F[F[A]): F[A]

sealed trait Free[F[_], A]  
case class Point[F[_], A](a: A) extends Free[F, A]             // == Return  
case class Join[F[_], A](ffa: F[Free[F, A]]) extends Free[F, A] // == Suspend  
</code></pre>

<p><code>map</code> 을 타입화 하는 대신, <code>F</code> 가 <code>Functor</code> 라면 다음처럼 <code>Free.point</code>, <code>Free.flatMap</code> 을 작성할 수 있습니다.</p>

<pre><code class="language-scala">sealed trait Free[F[_], A] {  
  def point[F[_]](a: A): Free[F, A] = Point(a)
  def flatMap[B](f: A =&gt; Free[F, B])(implicit functor: Functor[F]): Free[F, B] =
    this match {
      case Point(a)  =&gt; f(a)
      case Join(ffa) =&gt; Join(ffa.map(fa =&gt; fa.flatMap(f)))
    }
  def map[B](f: A =&gt; B)(implicit functor: Functor[F]): Free[F, B] =
    flatMap(a =&gt; Point(f(a)))
}

case class Point[F[_], A](a: A) extends Free[F, A]  
case class Join[F[_], A](ff: F[Free[F, A]]) extends Free[F, A]  
</code></pre>

<p><code>fa.flatMap(f)</code> 의 결과가 <code>Free[F, B]</code> 고 <code>ffa.map</code> 의 결과로 들어가므로, <code>ffa.map(_ flatMap f)</code> 의 결과는 <code>F[Free[F, B]</code> 입니다. 이걸 <code>Free[F, B]</code> 로 바꾸려면 <code>Join</code> 을 이용하면 됩니다.</p>

<p><strong>이런 이유에서, <code>F</code> 가 <code>Functor</code> 면 <code>Free[F, A]</code> 는 <code>Monad</code> 입니다.</strong></p>

<p>이제 리프팅과 실행을 위한 헬퍼 함수를 만들면,</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

import scalaz.{Functor, Monad, ~&gt;}

def liftF[F[_], A](a: =&gt; F[A])(implicit F: Functor[F]): Free[F, A] =  
  Join(F.map(a)(Point[F, A]))

def foldMap[F[_], M[_], A](fm: Free[F, A])(f: F ~&gt; M)  
                          (implicit FI: Functor[F], MI: Monad[M]): M[A] = 
  fm match {
    case Point(a) =&gt; MI.pure(a)
    case Join(ffa) =&gt; MI.bind(f(ffa))(fa =&gt; foldMap(fa)(f))
  }
</code></pre>

<p>여기서 <code>F ~&gt; M</code> 는 <code>F</code> 를 <code>M</code> 으로 변환해주는, <em>NaturalTransformation</em> 입니다.</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

type ~&gt;[-F[_], +G[_]] = NaturalTransformation[F, G] 

trait NaturalTransformation[-F[_], +G[_]] {  
  self =&gt;
  def apply[A](fa: F[A]): G[A]

  def compose[E[_]](f: E ~&gt; F): E ~&gt; G = new (E ~&gt; G) {
    def apply[A](ea: E[A]) = self(f(ea))
  }
}
</code></pre>

<p><code>MI.bind(f(ffa))</code> 의 결과는 <code>M[Free[F, A]]</code> 이므로 여기에서 <code>bind</code> (= <code>flatMap</code>) 로 <code>fa</code> 를 얻어, 재귀적으로 <code>foldMap</code> 을 호출합니다.</p>

<h3 id="scalazfreeimplementation">Scalaz Free Implementation</h3>

<pre><code class="language-scala">def flatMap[B](f: A =&gt; Free[F, B])(implicit functor: Functor[F]): Free[F, B] =  
    this match {
      case Point(a)  =&gt; f(a)
      case Join(ffa) =&gt; Join(ffa.map(fa =&gt; fa.flatMap(f)))
    }
</code></pre>

<p>Scalaz 에서는 <code>flatMap</code> 호출시 Stack 비용이 생각보다 크므로, <code>flatMap</code> 자체도 타입화하고 있습니다. 즉, Stack 대신에 Heap 을 사용합니다. </p>

<p><code>Point</code> 대신, <code>Return</code>, <code>Join</code> 대신 <code>Suspend</code>, <code>FlatMap</code> 대신 <code>GoSub</code> 라는 타입 이름으로 구현되어 있습니다. (이해를 돕기 위해 7.x 대신, 6.0.4 버전을 차용)</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/release/6.0.4/core/src/main/scala/scalaz/Free.scala

final case class Return[S[+_], +A](a: A) extends Free[S, A]  
final case class Suspend[S[+_], +A](a: S[Free[S, A]]) extends Free[S, A]  
final case class Gosub[S[+_], A, +B](a: Free[S, A],  
                                     f: A =&gt; Free[S, B]) extends Free[S, B]
sealed trait Free[S[+_], +A] {  
  final def map[B](f: A =&gt; B): Free[S, B] =
    flatMap(a =&gt; Return(f(a)))

  final def flatMap[B](f: A =&gt; Free[S, B]): Free[S, B] = this match {
    case Gosub(a, g) =&gt; Gosub(a, (x: Any) =&gt; Gosub(g(x), f))
    case a           =&gt; Gosub(a, f)
  }
}
</code></pre>

<h3 id="trampoline">Trampoline</h3>

<p><code>Free</code> 를 이용하면, Stackoverflow 를 피할 수 있습니다. 이는 <code>Free</code> 가 <code>flatMap</code> 체인에서 스택 대신 힙을 이용하는 것을 응용한 것인데요,</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/release/6.0.4/core/src/main/scala/scalaz/Free.scala

/** A computation that can be stepped through, suspended, and paused */
type Trampoline[+A] = Free[Function0, A]  
</code></pre>

<p>이때 <code>Function0</code> 도 <code>Functor</code> 이므로, </p>

<pre><code class="language-scala">implicit Function0Functor: Functor[Function0] = new Functor[Function0] {  
  def fmap[A, B](f: A =&gt; B)(fa: Function0[A]): Function0[B] = 
    () =&gt; f(fa)
}
</code></pre>

<p><code>Free[Function0, A]</code> 도 모나드입니다. </p>

<p>이제 스칼라에서 스택오버플로우가 발생하는 <em>mutual recursion</em> 코드를 만들어 보면,</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

def isOdd(n: Int): Boolean = {  
  if (0 == n) false
  else isEven(n -1)
}

def isEven(n: Int): Boolean = {  
  if (0 == n) true
  else isOdd(n -1)
}

isOdd(10000) // stackoverflow  
</code></pre>

<p>이제 <code>Trampoline</code> 을 이용하면</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

import scalaz._, Scalaz._, Free._

def isOddT(n: Int): Trampoline[Boolean] =  
  if (0 == n) return_(false)
  else suspend(isEvenT(n - 1))

def isEvenT(n: Int): Trampoline[Boolean] =  
  if (0 == n) return_(true)
  else suspend(isOddT(n - 1))

scala&gt; isOddT(2000000).run  
res7: Boolean = false

scala&gt; isOddT(2000001).run  
res8: Boolean = true  
</code></pre>

<p><code>return_</code> 과 <code>suspend</code> 는 다음처럼 정의되어 있습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Free.scala#L15

trait FreeFunctions {

  ...
  def return_[S[_], A](value: =&gt; A)(implicit S: Applicative[S]): Free[S, A] =
    Suspend[S, A](S.point(Return[S, A](value)))

  def suspend[S[_], A](value: =&gt; Free[S, A])(implicit S: Applicative[S]): Free[S, A] =
    Suspend[S, A](S.point(value))
</code></pre>

<h2 id="yonedacoyoneda">Yoneda, Coyoneda</h2>

<p>포스트의 시작 부분에서 <code>Coyoneda</code> 에 대한 언급을 기억하시나요?</p>

<ul>
<li><code>Free[F[_], ?]</code> 는 <code>Functor</code> <code>F</code> 에 대해 <code>Monad</code> 입니다</li>
<li><code>Coyoneda[S[_], ?]</code> 는 아무 타입에 대해 <code>Functor</code> 입니다. </li>
</ul>

<p><code>Coyoneda</code> 가 어떻게 <code>Functor</code> 를 만들어내는지 확인해 보겠습니다. 이 과정에서 <em>dual</em> 인 <code>Yoneda</code> 도 같이 살펴보겠습니다. (같은 <em>Category</em> 내에서, <em>morphism</em> 방향만 다른 경우)</p>

<p>먼저, <code>Yoneda</code>, <code>Coyoneda</code> 의 기본적인 내용을 훑고 가면</p>

<ul>
<li><code>Yoneda</code>, <code>Coyoneda</code> 는 <code>Functor</code> 입니다</li>
<li><code>Yoneda[F[_], A]</code>, <code>Coyoneda[F[_], A]</code> 는 <code>F[A]</code> 와 <em>isomorphic</em> 입니다 (<code>F</code> 가 <code>Functor</code> 일 경우)</li>
<li><code>Yoneda[F, A]</code> 에서 <code>F[A]</code> 로의 <em>homomorphism</em> 은 <code>F</code> 가 <code>Functor</code> 가 아닐 경우에도 존재합니다</li>
<li><code>F[A]</code> 에서 <code>Coyoneda[F, A]</code> 로의 <em>homomorphism</em> 은 <code>F</code> 가 <code>Functor</code> 가 아닐 경우에도 존재합니다 (중요)</li>
<li><code>Yoneda</code>, <code>Coyoneda</code> 모두 <code>Functor</code> 가 필요한 시점을 미루고, <code>Functor.map</code> 의 체인을, 일반 함수의 체인으로 표현합니다. 결국엔 <code>Functor</code> 가 필요합니다 (중요)</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/4-yoneda-and-free/iso_vs_homo_morphism.png" alt=""></p>

<p><br></p>

<p>(Image - <a href="http://evolvingthoughts.net/2010/08/homology-and-analogy/">http://evolvingthoughts.net/2010/08/homology-and-analogy/</a>)</p>

<p>즉 <code>Coyoneda[F[_], A]</code> 가  <code>F</code> 와 상관없이 <code>Functor</code> 인 이유는, <code>F[A] -&gt; Coyoenda[F[_], A]</code> 로의 변환이 <code>F</code> <code>Functor</code> 인 것과 상관이 없으며 <code>Coyoneda</code> 자체가 <code>Functor</code> 인스턴스이기 때문입니다.</p>

<p>추상은 간단합니다. <code>Functor[F]</code> 가 <code>F[A] -&gt; F[B]</code> 로의 변환을 <code>f: A =&gt; B</code> 만 가지고 해 낼 수 있다는 점을 역이용하면 됩니다. <code>F[A]</code> 에 <code>Functor.map(f)</code> 를 적용하는 것이 아니라, 값 <code>A</code> 가 있을 때 <code>f(a)</code> 를 적용한 뒤에, <code>F[B]</code> 를 만들면 됩니다. 다시 말해</p>

<ul>
<li><code>Functor[F]</code> 는 <code>F[A]</code> 와 <code>f: A =&gt; B</code>, <code>g: B = &gt; C</code> 가 가 있을 때 <code>Functor[F].map(f compose g)</code> 대신</li>
<li><code>f compose g</code> 를 먼저 하고, 이것의 결과값인 <code>C</code> 를 이용해 <code>F[C]</code> 를 만들면 됩니다. 그러면 <code>Functor[F].map</code> 연산을 함수의 컴포지션으로 해결할 수 있습니다.</li>
</ul>

<h3 id="yoneda">Yoneda</h3>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Yoneda.scala

abstract class Yoneda[F[_], A] { yo =&gt;  
  def apply[B](f: A =&gt; B): F[B]

  def run: F[A] = apply(a =&gt; a)

  def map[B](f: A =&gt; B): Yoneda[F, B] = new Yoneda[F, B] {
    override def apply[C](g: (B) =&gt; C): F[C] = yo(f andThen g)
  }
}

/** `F[A]` converts to `Yoneda[F, A]` for any functor `F` */
def apply[F[_]: Functor, A](fa: F[A]): Yoneda[F, A] = new Yoneda[F, A] {  
  override def apply[B](f: A =&gt; B): F[B] = Functor[F].map(fa)(f)
}

/** `Yoneda[F, A]` converts to `F[A` for any `F` */
def from[F[_], A](yo: Yoneda[F, A]): F[A] =  
  yo.run

/** `Yoneda[F, _]` is a functor for any `F` */
implicit def yonedaFunctor[F[_]]: Functor[({ type  λ[α] = Yoneda[F,α]})#λ] =  
  new Functor[({type λ[α] = Yoneda[F, α]})#λ] {
    override def map[A, B](ya: Yoneda[F, A])(f: A =&gt; B): Yoneda[F, B] =
      ya map f
  }
</code></pre>

<p><code>Yoneda[F[_], ?]</code> 는 그 자체로 <code>Functor</code> 이나 이를 만들기 위해선 <code>F</code> 가 <code>Functor</code> 여야 합니다. 반면 <code>Yoneda[F, A] -&gt; F[A]</code> 로의 변환은 <code>F</code> 가 <code>Functor</code> 이던 아니던 상관 없습니다.</p>

<h3 id="coyoneda">Coyoneda</h3>

<p>그렇다면, <em>dual</em> 인 <code>Coyoneda</code> 는 어떨까요? <code>Yoneda</code> <code>F[A]</code> 를 <code>Functor</code> 로 부터 얻는것이 아니라, <em>Identity</em> 를 이용해, 처음부터 <code>F[A]</code> 를 가지고 있습니다. 이로 부터 얻어지는 결론은 놀랍습니다.</p>

<pre><code class="language-scala">sealed abstract class Coyoneda[F[_], A] { coyo =&gt;  
  type I
  val fi: F[I]
  val k: I =&gt; A

  final def map[B](f: A =&gt; B): Aux[F, I, B] =
    apply(fi)(f compose k)

  final def run(implicit F: Functor[F]): F[A] =
    F.map(fi)(k)
}

type Aux[F[_], A, B] = Coyoneda[F, B] { type I = A }

def apply[F[_], A, B](fa: F[A])(_k: A =&gt; B): Aux[F, A, B] =  
  new Coyoneda[F, B] {
    type I = A
    val k = _k
    val fi = fa
  }

/** `F[A]` converts to `Coyoneda[F, A]` for any `F` */
def lift[F[_], A](fa: F[A]): Coyoneda[F, A] = apply(fa)(identity[A])

/** `Coyoneda[F, A]` converts to `F[A]` for any Functor `F` */
def from[F[_], A](coyo: Coyoneda[F, A])(implicit F: Functor[F]): F[A] =  
  F.map(coyo.fi)(coyo.k)

/** `CoyoYoneda[F, _]` is a functor for any `F` */
implicit def coyonedaFunctor[F[_]]: Functor[({ type  λ[α] = Coyoneda[F,α]})#λ] =  
  new Functor[({type λ[α] = Coyoneda[F, α]})#λ] {
    override def map[A, B](ca: Coyoneda[F, A])(f: A =&gt; B): Coyoneda[F, B] =
      ca.map(f)
  }
</code></pre>

<p>따라서 <code>Coyoneda[F[_], ?]</code> 를 만들기 위해서 <code>F</code> 가 <code>Functor</code> 일 필요가 없습니다. </p>

<p><a href="http://stackoverflow.com/questions/24000465/step-by-step-deep-explain-the-power-of-coyoneda-preferably-in-scala-throu">Stackoverflow - The Power of (Co)yoneda</a> 에선 다음처럼 설명합니다.</p>

<pre><code class="language-haskell">newtype Yoneda f a = Yoneda { runYoneda :: forall b . (a -&gt; b) -&gt; f b }

instance Functor (Yoneda f) where  
  fmap f y = Yoneda (\ab -&gt; runYoneda y (ab . f))

data CoYoneda f a = forall b . CoYoneda (b -&gt; a) (f b)

instance Functor (CoYoneda f) where  
  fmap f (CoYoneda mp fb) = CoYoneda (f . mp) fb
</code></pre>

<blockquote>
  <p>So instead of appealing to the <code>Functor</code> instance for <code>f</code> during definition of the <code>Functor</code> instance for <code>Yoneda</code>, it gets <strong>"defered"</strong> to the construction of the <code>Yoneda</code> itself. Computationally, it also has the nice property of turning all <code>fmaps</code> into compositions with the "continuation" function (<code>a -&gt; b</code>).</p>
  
  <p>The opposite occurs in <code>CoYoneda</code>. For instance, <code>CoYoneda f</code> is still a <code>Functor</code> whether or not <code>f</code> is. Also we again notice the property that <code>fmap</code> is nothing more than composition along the eventual continuation.</p>
  
  <p><strong>So both of these are a way of "ignoring" a <code>Functor</code> requirement for a little while, especially while performing <code>fmap</code>s.</strong></p>
</blockquote>

<h2 id="reasonablypricedmonad">Reasonably Priced Monad</h2>

<p><em>for comprehension</em> 내에서는 단 하나의 모나드 밖에 쓸 수 없습니다. <del>단칸방 세입자 모나드</del> <em>Monad Transformer</em> 등을 사용하긴 하는데 불편하기 짝이 없지요.</p>

<p><em>Rúnar Bjarnason</em> 은 <a href="https://www.parleys.com/tutorial/composable-application-architecture-reasonably-priced-monads">Composable application architecture with reasonably priced monads
</a> 에서 <code>Coproduct</code> 를 이용해 <code>Free</code> 를 조합하는 법을 소개합니다. (<strong>이 비디오는 꼭 보셔야합니다!</strong>)</p>

<p>요약하면 <code>Free</code> 를 이용해 생성한 서로 다른 두개의 모나드는 같은 <em>for comprehension</em> 내에서 사용할 수 없습니다. 이 때 <code>Coproduct</code> 를 이용해서 하나의 타입으로 묶고, 타입 자동 주입을 위해 <code>Inject</code> 를 이용하면 많은 코드 없이도, 편리하게 <code>Free</code> 를 이용할 수 있다는 것입니다.</p>

<p>예를 들어 다음과 처럼 두개의 프리 모나드 <code>Interact</code>, <code>Auth</code> 가 있을 때</p>

<pre><code class="language-scala">// Interact
trait InteractOp[A]  
final case class Ask(prompt: String) extends InteractOp[String]  
final case class Tell(msg: String)   extends InteractOp[Unit]

type CoyonedaInteract[A] = Coyoneda[InteractOp, A]  
type Interact[A] = Free[CoyonedaInteract, A]

def ask(prompt: String) = liftFC(Ask(prompt))  
def tell(msg: String) = liftFC(Tell(msg))  
</code></pre>

<pre><code class="language-scala">// Auth
case class User(userId: UserId, permissions: Set[Permission])

sealed trait AuthOp[A]  
final case class Login(userId: UserId, password: Password) extends AuthOp[Option[User]]  
final case class HasPermission(user: User, permission: Permission) extends AuthOp[Boolean]

type CoyonedaAuth[A] = Coyoneda[AuthOp, A]  
type Auth[A] = Free[CoyonedaAuth, A]

def login(userId: UserId, password: Password): FreeC[F, Option[User]] =  
  liftFC(Login(userId, password))

def hasPermission(user: User, permission: Permission): FreeC[F, Boolean] =  
  liftFC(HasPermission(user, permission))
</code></pre>

<pre><code class="language-scala">// Log

sealed trait LogOp[A]  
final case class Warn(message: String)  extends LogOp[Unit]  
final case class Error(message: String) extends LogOp[Unit]  
final case class Info(message: String)  extends LogOp[Unit]

type CoyonedaLog[A] = Coyoneda[LogOp, A]  
type Log[A] = Free[CoyonedaLog, A]

object Log {  
  def warn(message: String)  = liftFC(Warn(message))
  def info(message: String)  = liftFC(Info(message))
  def error(message: String) = liftFC(Error(message))
</code></pre>

<p>다음처럼 같은 <em>for comprehension</em> 구문에서 사용할 수 없습니다.</p>

<pre><code class="language-scala">// doesn't compile

for {  
  userId &lt;- ask("Insert User ID: ")
  password &lt;- ask("Password: ")
  user &lt;- login(userId, password)
  _ &lt;- info(s"user $userId logged in")
  hasPermission &lt;- user.cata(
    none = point(false),
    some = hasPermission(_, "scalaz repository")
  )
  _ &lt;- warn(s"$userId has no permission for scalaz repository")
} yield hasPermission
</code></pre>

<p>이 때 <code>Coproduct</code> 를 이용하면, 가능합니다.</p>

<pre><code class="language-scala">// combine free monads
type Language0[A] = Coproduct[InteractOp, AuthOp, A]  
type Language[A] = Coproduct[LogOp, Language0, A]  
type LanguageCoyo[A] = Coyoneda[Language, A]  
type LanguageMonad[A] = Free[LanguageCoyo, A]  
def point[A](a: =&gt; A): FreeC[Language, A] = Monad[LanguageMonad].point(a)

// combine interpreters
val interpreter0: Language0 ~&gt; Id = or(InteractInterpreter, AuthInterpreter)  
val interpreter: Language ~&gt; Id = or(LogInterpreter, interpreter0)

// run a program
def main(args: Array[String]) {  
  def program(implicit I: Interact[Language], A: Auth[Language], L: Log[Language]) = {
    import I._, A._, L._

    for {
      userId &lt;- ask("Insert User ID: ")
      password &lt;- ask("Password: ")
      user &lt;- login(userId, password)
      _ &lt;- info(s"user $userId logged in")
      hasPermission &lt;- user.cata(
        none = point(false),
        some = hasPermission(_, "scalaz repository")
      )
      _ &lt;- warn(s"$userId has no permission for scalaz repository")
    } yield hasPermission
  }

  program.mapSuspension(Coyoneda.liftTF(interpreter))
}
</code></pre>

<p>여기서 <code>or</code> 과 <code>lift</code> 는 라이브러리 코드라 생각하시면 됩니다. 이제 변화된 프리 모나드 부분을 보면,</p>

<pre><code class="language-scala">object Auth {  
  type UserId = String
  type Password = String
  type Permission = String

  implicit def instance[F[_]](implicit I: Inject[AuthOp, F]): Auth[F] =
    new Auth
}

class Auth[F[_]](implicit I: Inject[AuthOp, F]) {  
  import Common._
  def login(userId: UserId, password: Password): FreeC[F, Option[User]] =
    lift(Login(userId, password))

  def hasPermission(user: User, permission: Permission): FreeC[F, Boolean] =
    lift(HasPermission(user, permission))
}

class Interact[F[_]](implicit I: Inject[InteractOp, F]) {  
  import Common._

  def ask(prompt: String): FreeC[F, String] =
    lift(Ask(prompt))

  def tell(message: String): FreeC[F, Unit] =
    lift(Tell(message))
}

object Interact {  
  implicit def instance[F[_]](implicit I: Inject[InteractOp, F]): Interact[F] =
    new Interact
}

class Log[F[_]](implicit I: Inject[LogOp, F]) {  
  import Common._

  def warn(message: String)  = lift(Warn(message))
  def info(message: String)  = lift(Info(message))
  def error(message: String) = lift(Error(message))
}

object Log {  
  implicit def instant[F[_]](implicit I: Inject[LogOp ,F]) =
    new Log
}
</code></pre>

<p>이제, <code>Common</code> 을 보면</p>

<pre><code class="language-scala">object Common {  
  import scalaz.Coproduct, scalaz.~&gt;

  def or[F[_], G[_], H[_]](f: F ~&gt; H, g: G ~&gt; H): ({type cp[α] = Coproduct[F,G,α]})#cp ~&gt; H =
    new NaturalTransformation[({type cp[α] = Coproduct[F,G,α]})#cp,H] {
      def apply[A](fa: Coproduct[F,G,A]): H[A] = fa.run match {
        case -\/(ff) ⇒ f(ff)
        case \/-(gg) ⇒ g(gg)
      }
    }

  def lift[F[_], G[_], A](fa: F[A])(implicit I: Inject[F, G]): FreeC[G, A] =
    Free.liftFC(I.inj(fa))
}
</code></pre>

<p><code>Coproduct[F, G, A]</code> 는 <strong>둘 중 하나</strong> 를 의미하는 추상입니다. 결과로 <code>F[A] \/ G[A]</code> (<em>scalaz either</em>) 을 돌려줍니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Coproduct.scala

final case class Coproduct[F[_], G[_], A](run: F[A] \/ G[A]) {  
  ...
}

trait CoproductFunctions {  
  def leftc[F[_], G[_], A](x: F[A]): Coproduct[F, G, A] =
    Coproduct(-\/(x))

  def rightc[F[_], G[_], A](x: G[A]): Coproduct[F, G, A] =
    Coproduct(\/-(x))

  ...
}
</code></pre>

<p><code>Inject[F[_], G[_]]</code> 는 <code>F</code>, <code>G</code> 를 포함하는 더 큰 타입인 <code>Coproduct</code> 를 만들때 쓰입니다.</p>

<pre><code class="language-scala">def lift[F[_], G[_], A](fa: F[A])(implicit I: Inject[F, G]): FreeC[G, A] =  
  Free.liftFC(I.inj(fa))

// F == Langauge
class Log[F[_]](implicit I: Inject[LogOp, F]) {  
  def warn(message: String)  = lift(Warn(message))
  def info(message: String)  = lift(Info(message))
  def error(message: String) = lift(Error(message))
}
</code></pre>

<p><code>Inject</code> 는 이렇게 생겼습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Inject.scala

sealed abstract class Inject[F[_], G[_]] {  
  def inj[A](fa: F[A]): G[A]
  def prj[A](ga: G[A]): Option[F[A]]
}

sealed abstract class InjectInstances {  
  implicit def reflexiveInjectInstance[F[_]] =
    new Inject[F, F] {
      def inj[A](fa: F[A]) = fa
      def prj[A](ga: F[A]) = some(ga)
    }

  implicit def leftInjectInstance[F[_], G[_]] =
    new Inject[F, ({type λ[α] = Coproduct[F, G, α]})#λ] {
      def inj[A](fa: F[A]) = Coproduct.leftc(fa)
      def prj[A](ga: Coproduct[F, G, A]) = ga.run.fold(some(_), _ =&gt; none)
    }

  implicit def rightInjectInstance[F[_], G[_], H[_]](implicit I: Inject[F, G]) =
      new Inject[F, ({type λ[α] = Coproduct[H, G, α]})#λ] {
        def inj[A](fa: F[A]) = Coproduct.rightc(I.inj(fa))
        def prj[A](ga: Coproduct[H, G, A]) = ga.run.fold(_ =&gt; none, I.prj(_))
      }
}
</code></pre>

<p>따라서 <code>F</code>, <code>G</code> 타입만 맞추어 주면 <code>Inject</code> 인스턴스는 자동으로 생성됩니다.</p>

<p>다음시간에는 <em>side-effect</em> 의 세계로 넘어가 <code>ST</code>, <code>IO</code> 등을 살펴보겠습니다.</p>

<h2 id="previousposts">Previous Posts</h2>

<ul>
<li><a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1, State</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/">Easy Scalaz 2, Monad Transformer</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/">Easy Scalaz 3, ReaderWriterState with Kleisli</a></li>
</ul>

<h2 id="references">References</h2>

<ul>
<li><a href="http://cs.lth.se/edan40">Haskell Image</a></li>
<li><a href="http://tpolecat.github.io/assets/sbtb-slides.pdf">Programs as Values: Fure Functional JDBC Programming</a></li>
<li><a href="http://blog.higher-order.com/blog/2013/11/01/free-and-yoneda/">Free Monads and the Yoneda Lemma</a></li>
<li><a href="http://stackoverflow.com/questions/24000465/step-by-step-deep-explain-the-power-of-coyoneda-preferably-in-scala-throu">Stackoverflow - The Power of (Co) Yoneda</a></li>
<li><a href="http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern">Stack Exchange - What is the Free Monad + Interpreter Pattern?</a></li>
<li><a href="http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf">Free Monad is Free Monoid + Functor</a></li>
<li><a href="http://underscore.io/blog/posts/2015/04/23/deriving-the-free-monad.html">Underscore - Deriving the Free Monad</a></li>
<li><a href="http://underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html">Underscore - Free Monads Are Simple</a></li>
<li><a href="http://stackoverflow.com/questions/10342876/differences-between-functors-and-endofunctors">Stackoverflow - Difference between functors and endofuctors</a></li>
<li><a href="http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem/3870310#3870310">Stackoverflow - A monad is just monoid in the categy of endofuctors</a></li>
<li><a href="http://evolvingthoughts.net/2010/08/homology-and-analogy/">Isomorphism vs Homomorphism Image</a></li>
<li><a href="https://www.parleys.com/tutorial/composable-application-architecture-reasonably-priced-monads">Composable application architecture with reasonably priced monads
</a>(<a href="https://gist.github.com/runarorama/a8fab38e473fafa0921d">Gist: Code</a>)</li>
</ul>]]></content:encoded></item><item><title><![CDATA[Easy Scalaz 3, ReaderWriterState with Kleisli]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p><em>Composition</em> (합성) 은 함수형 언어에서 중요한 테마중 하나인데요, 이번 시간에는 <em>Kleisli</em> 를 이용해 어떻게 함수를 타입으로 표현하고, 합성할 수 있는지 살펴보겠습니다. 그리고 나서, <em>Reader</em>, <em>Writer</em> 에 대해 알아보고, 이것들과 <em>State</em> 를 같이 사용하는 <em>RWST</em> 에 대해 알아보겠습니다.</p>

<h2 id="kleisli">Kleisli</h2>

<p><em>State</em> 가 <code>(S) =&gt; (S, A)</code> 를 타입클래스로 표현한 것이라면, <code>A =&gt;</code></p>]]></description><link>http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/</link><guid isPermaLink="false">1be76d77-2344-4db8-b924-f9015146e001</guid><category><![CDATA[scala]]></category><category><![CDATA[scalaz]]></category><category><![CDATA[readerwriterstate]]></category><category><![CDATA[kleisli]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 17 Nov 2015 11:32:42 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p><em>Composition</em> (합성) 은 함수형 언어에서 중요한 테마중 하나인데요, 이번 시간에는 <em>Kleisli</em> 를 이용해 어떻게 함수를 타입으로 표현하고, 합성할 수 있는지 살펴보겠습니다. 그리고 나서, <em>Reader</em>, <em>Writer</em> 에 대해 알아보고, 이것들과 <em>State</em> 를 같이 사용하는 <em>RWST</em> 에 대해 알아보겠습니다.</p>

<h2 id="kleisli">Kleisli</h2>

<p><em>State</em> 가 <code>(S) =&gt; (S, A)</code> 를 타입클래스로 표현한 것이라면, <code>A =&gt; B</code> 를 타입클래스로 표현한 것도 있지 않을까요? 그렇게 되면, 스칼라에서 지원하는 <code>andThen</code>, <code>compose</code> 을 이용해서 함수를 조합하는 것처럼, 타입 클래스를 조합할 수 있을겁니다. <code>Kleisli</code> 가 바로, 그런 역할을 하는 타입 클래스입니다.</p>

<blockquote>
  <p>Kleisli represents a function <code>A =&gt; M[B]</code></p>
</blockquote>

<p>타입을 보면, 단순히 <code>A =&gt; B</code> 이 아니라 <code>A =&gt; M[B]</code> 를 나타냅니다. 이는 <code>Kleisli</code> 가 <code>M</code> 을 해석하고, 조합할 수 있는 방법을 제공한다는 것을 의미합니다. 실제 구현을 보면,</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Kleisli.scala#L8

final case class Kleisli[M[_], A, B](run: A =&gt; M[B]) { self =&gt;  
  ...

  def &gt;=&gt;[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] =  kleisli((a: A) =&gt; b.bind(this(a))(k.run))

  def andThen[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &gt;=&gt; k

  def &gt;==&gt;[C](k: B =&gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &gt;=&gt; kleisli(k)

  def andThenK[C](k: B =&gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &gt;==&gt; k

  /** alias for `compose` */
  def &lt;=&lt;[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &gt;=&gt; this

  def compose[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &gt;=&gt; this

  def &lt;==&lt;[C](k: C =&gt; M[A])(implicit b: Bind[M]): Kleisli[M, C, B] = kleisli(k) &gt;=&gt; this

  def composeK[C](k: C =&gt; M[A])(implicit b: Bind[M]): Kleisli[M, C, B] = this &lt;==&lt; k
  ...
}
</code></pre>

<p><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/KleisliUsage.scala">Kleisli Example</a> 에서 간단한 예제를 가져와서 사용법을 살펴보도록 하겠습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/KleisliUsage.scala

case class Continent(name: String, countries: List[Country] = List.empty)  
case class Country(name: String, cities: List[City] = List.empty)  
case class City(name: String, isCapital: Boolean = false, inhabitants: Int = 20)

val data: List[Continent] = List(  
  Continent("Europe"),
  Continent("America",
    List(
      Country("Canada",
        List(
          City("Ottawa"), City("Vancouver"))),
      Country("USA",
        List(
          City("Washington"), City("New York"))))),
  Continent("Asia",
    List(
      Country("India",
        List(City("New Dehli"), City("Calcutta"))))))
</code></pre>

<p>여기에 다음의 함수를 정의하면 </p>

<pre><code class="language-scala">def continents(name: String): List[Continent] =  
  data.filter(k =&gt; k.name.contains(name))

def countries(continent: Continent): List[Country] = continent.countries

def cities(country: Country): List[City] = country.cities

def save(cities: List[City]): Try[Unit] =  
  Try {
    // do IO or some side-effectful operations
    cities.foreach(c =&gt; println("Saving " + c.name))
  }

def inhabitants(c: City): Int = c.inhabitants  
</code></pre>

<p>이제 <code>A =&gt; M[B]</code> 형태의 여러 함수들을 만들었으므로 이를 <code>Kleisli</code> 를 이용해 조합할 수 있습니다. (이 예제에서 <code>M == List</code>)</p>

<pre><code class="language-scala">// Kleisli[List, String, City]
val allCities = kleisli(continents) &gt;==&gt; countries &gt;==&gt; cities

// Kleisli[List, String, Int]
val cityInhabitants = allCities map inhabitants  
</code></pre>

<p><code>allCities</code> 는 <code>String</code> 을 인자로 받기도 하고, <code>M == List</code> 의 <code>Kleisli</code> 기 때문에 <code>List</code> 를 인자로 받을 수도 있습니다. (<code>=&lt;&lt;</code>)</p>

<pre><code class="language-scala">allCities("America") map(println)

// output
City(Ottawa,false,20)  
City(Vancouver,false,20)  
City(Washington,false,20)  
City(New York,false,20)

(allCities =&lt;&lt; List("America", "Asia")).map(println)

// output
City(Ottawa,false,20)  
City(Vancouver,false,20)  
City(Washington,false,20)  
City(New York,false,20)  
City(New Dehli,false,20)  
City(Calcutta,false,20)  
</code></pre>

<p><code>Kleisli</code> 가 제공하는 함수를 다시 살펴보면,</p>

<pre><code class="language-scala">def =&lt;&lt;(a: M[A])(implicit m: Bind[M]): M[B] = m.bind(a)(run)

def map[C](f: B =&gt; C)(implicit M: Functor[M]): Kleisli[M, A, C] =  
  kleisli(a =&gt; M.map(run(a))(f))

def mapK[N[_], C](f: M[B] =&gt; N[C]): Kleisli[N, A, C] =  
  kleisli(run andThen f)

def flatMapK[C](f: B =&gt; M[C])(implicit M: Bind[M]): Kleisli[M, A, C] =  
  kleisli(a =&gt; M.bind(run(a))(f))

def flatMap[C](f: B =&gt; Kleisli[M, A, C])(implicit M: Bind[M]): Kleisli[M, A, C] =  
  kleisli((r: A) =&gt; M.bind[B, C](run(r))(((b: B) =&gt; f(b).run(r))))
</code></pre>

<p>여기서 <code>mapK :: M[B] =&gt; N[C]</code> 를 이용하면 현재 <code>Kleisli[M, _, _]</code> 를 <code>Kleisli[N, _, _]</code> 로 변경할 수 있습니다.</p>

<p>위에서 정의한 <code>save</code> 함수는 <code>List[A]</code> 를 받아 <code>Try[Unit]</code> 를 여기에 사용할 수 있습니다.</p>

<pre><code class="language-scala">// Kleisli[Try, String, Unit]
val getAndSaveCities = allCities mapK save  
</code></pre>

<p><code>local</code> 을 이용하면 함수를 <em>prepend</em> 할 수 있습니다.</p>

<pre><code class="language-scala">// def local[AA](f: AA =&gt; A): Kleisli[M, AA, B] =
//   kleisli(f andThen run)

def index(i: Int): String = data(i).name

// Kleisli[List, Int, City]
val allCitiesWithIndex = allCities local index

allCitiesWithIndex(1) map(println)

// output
City(Ottawa,false,20)  
City(Vancouver,false,20)  
City(Washington,false,20)  
City(New York,false,20)  
</code></pre>

<p><code>Kleisli</code> 에 대한 더 읽을거리는 아래 링크를 참조해주세요. </p>

<ul>
<li><a href="http://eed3si9n.com/learning-scalaz/Arrow.html">Scalaz Arrow</a></li>
<li><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Kleisli.scala#L209">Scalaz - Kleisli.scala#KleisliArrow</a></li>
</ul>

<h2 id="reader">Reader</h2>

<p><code>Kleisli</code> 가 <code>A =&gt; M[B]</code> 를 나타낸다면, <code>Reader</code> 는 <code>A =&gt; B</code> (<code>Function1</code>) 를 의미하는 타입클래스입니다. 얼핏 생각하기에 <code>Kleisli[Id, A, B]</code> 일것 같죠? 실제 구현을 보면 (<em>scalaz</em> 에서 타입 얼라이어스는 <code>package.scala</code> 에 정의되어 있습니다.)</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/package.scala

type ReaderT[F[_], E, A] = Kleisli[F, E, A]  
val ReaderT = Kleisli  
type Reader[E, A] = ReaderT[Id, E, A]

object Reader {  
    def apply[E, A](f: E =&gt; A): Reader[E, A] = Kleisli[Id, E, A](f)
  }
</code></pre>

<p><code>Reader</code> 도 <code>Klelsli</code> 이므로, <code>Reader[A, B] &gt;==&gt; Reader[B, C]</code> 는 <code>Reader[A, C]</code> 가 됩니다. 게다가 <code>Kleisli</code> 는 <code>flatMap</code> 을 정의하고 있으므로 <em>monadic composition</em> 을 작성할 수 있습니다.</p>

<blockquote>
  <p>The point of a <code>Reader</code> is to supply some configuration object without having to manually (or <em>implicitly</em>) pass i around all the functions.</p>
</blockquote>

<p>요는, 함수 사이의 체인을 엮어 새로운 함수를 만들수 있고 이로인해 직접 파라미터를 넘겨줄 필요가 없습니다. 예를 들어</p>

<pre><code class="language-scala">type URI = String  
type Key = String  
type Value = String

val uri: Reader[Get, URI]  
val queryString: Reader[URI, String]  
val body: Reader[String, Map[Key, Value]

// Get =&gt; Map[Key, Value]
val queryStringToBody = uri &gt;==&gt; queryString &gt;==&gt; body  
</code></pre>

<p>간단히 구현을 해보겠습니다. 예외 처리는 외부에서 <code>Try</code> 혹은 <code>\/.fromTryCatchThrowable</code> 등으로 한다 가정하고 로직에만 집중해보면,</p>

<pre><code class="language-scala">// model
trait HttpRequest {  
  def url: String
}
case class GET(url: String) extends HttpRequest  
case class POST(url: String, body: Map[String, String]) extends HttpRequest

val uri: Reader[GET, String] = Reader { req: GET =&gt; req.url }  
val queryString: Reader[String, String] = Reader { url: String =&gt; url.split("\\?")(1) }  
val body: Reader[String, Map[String, String]] = Reader { queries: String =&gt;  
  val qs = queries.split("&amp;").toList
  qs.foldLeft(Map.empty[String, String]) { (acc: Map[String, String], q) =&gt;
    val kv = q.split("=")
    acc.updated(kv(0), kv(1))
  }
}

val queryStringToBody: Reader[GET, Map[String, String]] = uri &gt;==&gt; queryString &gt;==&gt; body  
</code></pre>

<p><code>queryStringToBody</code> 를 사용해 보면,</p>

<pre><code class="language-scala">val get1 = GET("http://www.google.com/search?query=scalaz&amp;site=github")  
val post1 = POST("http://www.google.com/search", Map("query" -&gt; "scalaz", "site" -&gt; "github"))  
val post2 = POST("https://www.google.com/search", Map("query" -&gt; "scalaz", "site" -&gt; "github"))

queryStringToBody.run(get1) shouldBe Map("query" -&gt; "scalaz", "site" -&gt; "github")  
</code></pre>

<p>함수를 몇개 더 작성해보면,</p>

<pre><code class="language-scala">val toHttpsRequest = Reader { url: String =&gt; url.replaceAll("http://$", "https://") }  
val sslProxy: Reader[_ &gt;: readerwriterstate.HttpRequest, readerwriterstate.HttpRequest] = Reader { req: readerwriterstate.HttpRequest =&gt;  
  req match {
    case request if request.url.startsWith("https://") =&gt; request
    case request: POST =&gt; request.copy(url = toHttpsRequest(request.url))
    case request: GET  =&gt; request.copy(url = toHttpsRequest(request.url))
  }
}

val convertGetToPost: Reader[_ &gt;: readerwriterstate.HttpRequest, POST] = Reader { req : readerwriterstate.HttpRequest =&gt;  
  req match {
    case get: GET =&gt;
      val split = get.url.split("\\?")
      val (path, query) = (split(0), split(1))
      val postBody = body.run(query)

      POST(path, postBody)

    case post: POST =&gt; post
  }
}
</code></pre>

<p>이제 <code>HttpRequest</code> 서브타입을 받아, 프록시를 적용하고, <code>GET</code> 이면 <code>POST</code> 로 변경하는 함수를 조합해보면 아래와 같습니다.</p>

<p>(<code>:&gt;</code> 등 <em>Type Bound</em> 에 대해서는 <a href="http://twitter.github.io/scala_school/type-basics.html">Scala School - Type &amp; Polymorphism</a> 과 <a href="http://twitter.github.io/scala_school/advanced-types.html">Scala School - Advanced Types</a> 를 참조해주세요.) </p>

<pre><code class="language-scala">val proxiedPost: Reader[_ &gt;: HttpRequest, POST] = sslProxy &gt;==&gt; convertGetToPost

// spec
proxiedPost.run(get1) shouldBe post2  
</code></pre>

<h2 id="flatmapforreader">flatMap for Reader</h2>

<p><code>Reader</code> 는 <code>Kleisli</code> 고, 이것간의 합성은 <code>&gt;==&gt;</code> 을 이용한다는것을 확인했습니다. 그럼 <code>flatMap</code> 은 어디에 쓰는걸까요? </p>

<pre><code class="language-scala">type ReaderT[F[_], E, A] = Kleisli[F, E, A]  
type Reader[E, A] = ReaderT[Id, E, A]

final case class Kleisli[M[_], A, B](run: A =&gt; M[B]) { self =&gt;  
  ...

  // andThen
  def &gt;=&gt;[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] =  kleisli((a: A) =&gt; b.bind(this(a))(k.run))

  def &gt;==&gt;[C](k: B =&gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &gt;=&gt; kleisli(k)

  def flatMapK[C](f: B =&gt; M[C])(implicit M: Bind[M]): Kleisli[M, A, C] =
    kleisli(a =&gt; M.bind(run(a))(f))

  def flatMap[C](f: B =&gt; Kleisli[M, A, C])(implicit M: Bind[M]): Kleisli[M, A, C] =
    kleisli((r: A) =&gt; M.bind[B, C](run(r))(((b: B) =&gt; f(b).run(r))))

  ...
}
</code></pre>

<p><code>flatMap</code> 을 보면 재미난 점이 보입니다. <code>Kleisli[M, A, B]</code> 와 <code>Kleisli[M, A, C]</code> 를 <code>flatMap</code> 으로 엮는데, <code>r: A</code> 를 넣어서 <code>run(r)</code> 을 실행하는걸 보실 수 있습니다. <code>Kleisli[M, A, C]</code> 까지도요! </p>

<p>즉 <code>A</code> 자체가 일종의 설정(<em>Configuration</em>) 값으로써 모든 <code>Kleisli</code> 에서 사용됩니다. 그렇기에 </p>

<ul>
<li><code>Reader[A, B]</code> 와 <code>Reader[B, C]</code> 는 <code>&gt;==&gt;</code> 으로</li>
<li><code>Reader[A, B]</code> 와 <code>Reader[A, C]</code> 는 <code>flatMap</code> 으로 엮을 수 있습니다.</li>
</ul>

<h3 id="dependencyinjectionusingreader">Dependency Injection using Reader</h3>

<p><code>Reader</code> 를 이용하면 스칼라에서 별도의 라이브러리 없이 <em>Dependency Injection</em> (이하 <em>DI</em>) 를 구현할 수 있습니다. 이는 위에서 보았던 <code>flatMap</code> 의 특징을 이용하면 됩니다. 다음과 같은 모델이 있다고 할  때, </p>

<pre><code class="language-scala">case class User(id: Long,  
                name: String,
                age: Int,
                email: String,
                supervisorId: Long)

trait UserRepository {  
  def get(id: Long): User
  def find(name: String): User
}

trait UserService {  
  def getUser(id: Long): Reader[UserRepository, User] =
    Reader(repo =&gt; repo.get(id))

  def findUser(userName: String): Reader[UserRepository, User] =
    Reader(repo =&gt; repo.find(userName))

  def getUserInfo(userName: String): Reader[UserRepository, Map[String, String]] = for {
    user &lt;- findUser(userName)
    supervisor &lt;- getUser(user.supervisorId)
  } yield Map(
    "email" -&gt; s"${user.email}",
    "boss"  -&gt; s"${supervisor.name}"
  )
}
</code></pre>

<p>다음처럼 주입할 수 있습니다.</p>

<pre><code class="language-scala">object UserRepositoryDummyImpl extends UserRepository {  
  override def get(id: Long): User = ???
  override def find(name: String): User = ???
}

class UserApplication(userRepository: UserRepository) extends UserService  
object UserApplication extends UserApplication(UserRepositoryDummyImpl)  
</code></pre>

<p>이외에도 스칼라에서 언어 자체의 기능만으로 DI 를 구현하는 방법으로 <em>Cake Pattern</em> , <em>Implicit</em> 등이 있습니다. (<a href="http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/">Scala Dependency Injection using Reader</a> 참조)</p>

<p>위의 두 방법과 <code>Reader</code> 를 사용한 방법을 비교하면, </p>

<ul>
<li><em>Cake Pattern</em> 에 비해 코드가 짧고</li>
<li><em>Implicit</em> 를 이용하지 않으므로 함수 시그니쳐가 간단합니다.</li>
</ul>

<h2 id="writer">Writer</h2>

<p><code>Writer[W, A]</code> 는 <code>run: (W, A)</code> 을 값으로 가지는 <em>case class</em> 입니다. 재미난 점은, <code>flatMap</code> 을 이용해 두개의 <code>Writer</code> 를 엮으면 각각의 값인 <code>(w1, a1)</code>, <code>(w2, a2)</code> 에 대해서 사용자가 다루는 값인 <code>a1, a2</code> 를 제하고 <code>w1</code> 과 <code>w2</code> 가 일종의 <a href="http://1ambda.github.io/easy-scalaz-1-state/">State</a> 처럼 관리되어 자동으로 <em>append</em> 된다는 점입니다. 따라서 많은 튜토리얼들이 <em>logging</em> 을 예로 들어 <code>Writer</code> 를 설명하곤 합니다.</p>

<pre><code class="language-scala">test("WriterOps") {  
  val w1: Writer[String, Int] = 10.set("w1 created")
  val w2: Writer[String, Int] = 20.set("w2 created")

  val result: Writer[String, Int] = for {
    n1 &lt;- w1
    n2 &lt;- w2
  } yield n1 + n2

  // What if we use `List[String]` instead of `String`?
  result.run shouldBe ("w1 createdw2 created", 30)
}
</code></pre>

<p><em>Scalaz</em> 구현을 보면</p>

<pre><code class="language-scala">type Writer[W, A] = WriterT[Id, W, A]

final case class WriterT[F[_], W, A](run: F[(W, A)]) { self =&gt;  
  ...

  def flatMap[B](f: A =&gt; WriterT[F, W, B])(implicit F: Bind[F], s: Semigroup[W]): WriterT[F, W, B] =
    flatMapF(f.andThen(_.run))

  def flatMapF[B](f: A =&gt; F[(W, B)])(implicit F: Bind[F], s: Semigroup[W]): WriterT[F, W, B] =
    writerT(F.bind(run){wa =&gt;
      val z = f(wa._2)
      F.map(z)(wb =&gt; (s.append(wa._1, wb._1), wb._2))
    })

  ...
</code></pre>

<p><code>WriterT</code> 에서 <code>F</code> 를 <code>Id</code> 라 하면 <code>Writer</code> 가 되고 <code>flatMap</code> 로직은 다음처럼 단순화 할 수 있습니다.</p>

<pre><code class="language-scala">case class Writer[W, A](run: (W, A)) { self =&gt;  
  def flatMap[B](f: A =&gt; Writer[W, B])(implicit s: Semigroup[W]) {
    val (w1, a) = self.run
    val (w2, b) = f(a)
    (s.append(w1, w2), b)
  }
}
</code></pre>

<p>여기서 <a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Semigroup.scala">Semigroup.scala</a> 은, <em>Associativity</em> (결합법칙) 을 만족하는 <em>binary operator</em> 를 정의하는 타입 클래스입니다. (위에서 <code>append</code>)</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Semigroup.scala#L55

 /**
   * A semigroup in type F must satisfy two laws:
    *
    *  - '''closure''': `∀ a, b in F, append(a, b)` is also in `F`. This is enforced by the type system.
    *  - '''associativity''': `∀ a, b, c` in `F`, the equation `append(append(a, b), c) = append(a, append(b , c))` holds.
   */
  trait SemigroupLaw {
    def associative(f1: F, f2: F, f3: F)(implicit F: Equal[F]): Boolean =
      F.equal(append(f1, append(f2, f3)), append(append(f1, f2), f3))
  }
</code></pre>

<p><a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Monoid.scala">Monoid</a> 는 결합법칙을 만족하는 덧셈 연산과, 항등원 연산을 정의하는 타입 클래스인데, <em>Scalaz</em> 에서는 <code>Monoid</code> 가 <code>Semigroup</code> 을 상속받습니다.</p>

<pre><code class="language-scala">trait Monoid[F] extends Semigroup[F] { self =&gt;  
  ...
</code></pre>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png" alt="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png"></p>

<p><br></p>

<p>따라서 <code>Writer[W, A]</code> 의 <code>flatMap</code> 을 이용하기 위해서는 <code>W</code> 가 <code>Semigroup</code> 여야 하고 그래야만 <code>flatMap</code> 내부에서 자동으로 <code>W</code> 를 <em>append</em> 할 수 있습니다. </p>

<p>스칼라에서 제공하는 <code>List</code> 등의 기본 타입은 <em>Scalaz</em> 에서 <code>Monoid</code> 를 제공합니다. (<a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/std/List.scala#L109">scalaz.std.List</a>, <a href="https://github.com/scalaz/scalaz/tree/series/7.1.x/core/src/main/scala/scalaz/std">scalaz.std</a> 참조)</p>

<p>정리하면, <code>Writer[W, A]</code> 를 이용하면 값인 <code>A</code> 를 조작하면서 <code>W</code> 를 신경쓰지 않고, 자동으로 <code>append</code> 시킬 수 있습니다. (e.g <em>logging</em>)</p>

<h2 id="writerexample">Writer Example</h2>

<p>간단한 모델을 만들면,</p>

<pre><code class="language-scala">import scalaz._, Scalaz._

trait ThreadState  
case object Waiting    extends ThreadState  
case object Running    extends ThreadState  
case object Terminated extends ThreadState  
case class Thread(tid: String, name: String, state: ThreadState)  
case class Process(pid: String, threads: List[Thread])

object Process {  
  type Logger[A] = Writer[Vector[String], A]

  def genRandomID: String = java.util.UUID.randomUUID().toString.replace("-", "")

  def createThread(name: String): Logger[Thread] = {
    val tid = genRandomID
    Thread(tid, name, Waiting).set(Vector(s"Thread [$tid] was created"))
  }

  def createEmptyProcess: Logger[Process] = {
    val pid = genRandomID
    Process(pid, Nil).set(Vector(s"Empty Process [$pid] was created"))
  }

  def createNewProcess: Logger[Process] = for {
    mainThread &lt;- createThread("main")
    process &lt;- createEmptyProcess
    _ &lt;- Vector(s"Main Thread [${mainThread.tid}] was added to Process [${process.pid}").tell
  } yield process.copy(threads = mainThread.copy(state = Running) :: process.threads)
}
</code></pre>

<p>여기서 <code>W</code> 로 <code>List[String]</code> 대신 <code>Vector[String]</code> 을 사용하는 이유는, <em>append</em> 가 더 빠르기 때문입니다. (<a href="http://docs.scala-lang.org/overviews/collections/performance-characteristics.html">Scala Collection Performance Characteristics</a> 참조)</p>

<pre><code class="language-scala">test("Writer usage2") {  
  import readerwriterstate.Process._

  val (written, process) = createNewProcess.run

  process.threads.length shouldBe 1
  process.threads.head.name shouldBe "main"

  /* map lets you map over the value side */
  val ts: Logger[List[Thread]] = createNewProcess.map(p =&gt; p.threads)
  ts.value.length shouldBe 1

  /* with mapWritten you can map over the written side */
  val edited: Vector[String] = createNewProcess.mapWritten(_.map { log =&gt; "[LOG]" + log }).written
  println(edited.mkString("\n"))

  /** output
   * [LOG]Thread [557ad5bd0f3b4d49bac85b05ebedcd7b] was created
   * [LOG]Empty Process [710bd940ebdd4a82b949a32b585a12d9] was created
   * [LOG]Main Thread [557ad5bd0f3b4d49bac85b05ebedcd7b] was added to Process [710bd940ebdd4a82b949a32b585a12d9]
   */

  /* with mapValue, you can map over both sides */
  createNewProcess.mapValue { case (log, p) =&gt;
    (log :+ "Add an IO thread",
     p.copy(threads = Thread(genRandomID, "IO-1", Waiting) :: p.threads))
  }

  // `:++&gt;` `:++&gt;&gt;`, `&lt;++:`, `&lt;&lt;++:`
  createNewProcess :++&gt; Vector("add some log")
  val emptyWithLog = createEmptyProcess :++&gt;&gt; { process =&gt;
    Vector(s"${process.pid} is an empty process")
  }

   println(emptyWithLog.written)

  // output: Vector(Empty Process [cf211fc366ab4d20a0c25a27d173accd] was created, cf211fc366ab4d20a0c25a27d173accd is an empty process)

  // Writer is an applicative
  val emptyProcesses: Logger[List[readerwriterstate.Process]] =
    (createEmptyProcess |@| createEmptyProcess) { List(_) |+| List(_) }

  val ps = emptyProcesses.value
  ps.length shouldBe 2
}
</code></pre>

<p><a href="http://eed3si9n.com/learning-scalaz/Applicative+Builder.html">Applicative Builder</a>, <a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/WriterT.scala#L30">WriterT Functions</a> 를 참고하시면 이해가 더 쉽습니다.</p>

<h2 id="rwst">RWST</h2>

<p><a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala">ReaderWriterState</a> 는 다름이 아니라, 이제까지 보았던 <code>Reader</code>, <code>Writer</code>, <code>State</code> 를 모두 이용하는 타입 클래스입니다. <code>Reader</code> 로 설정값을 읽고, <code>Writer</code> 로 중간 과정을 기록하고, <code>State</code> 로 상태를 변경 또는 유지해 가며 연산을 수행할 수 있습니다. <em>Scalaz</em> 에서는 예제로 <a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/ReaderWriterStateTUsage.scala">ReaderWriterStateTUsage.scala</a> 를 제공하고 있습니다.</p>

<p>이제까지 늘 그래왔듯이, <code>ReaderWriterState[R, W, S, A]</code> 또한 <code>ReaderWriterStateT[Id, R, W, S, A]</code> 의 <em>type alias</em> 입니다. <code>Reader</code>, <code>Writer</code>, <code>State</code> 에서 사용했었던 함수들도 같이 제공됩니다.</p>

<pre><code class="language-scala">type ReaderWriterState[-R, W, S, A] = ReaderWriterStateT[Id, R, W, S, A]  
type ReaderWriterStateT[F[_], -R, W, S, A] = IndexedReaderWriterStateT[F, R, W, S, S, A]

object ReaderWriterState extends ReaderWriterStateTInstances with ReaderWriterStateTFunctions {  
  def apply[R, W, S, A](f: (R, S) =&gt; (W, A, S)): ReaderWriterState[R, W, S, A] = IndexedReaderWriterStateT[Id, R, W, S, S, A] { (r: R, s: S) =&gt; f(r, s) }
}
</code></pre>

<p><code>apply</code> 를 보면, <code>ReaderWriterState</code> 는 타입 <code>(R, S) =&gt; (W, A, S)</code> 함수를 넘겨주어 생성할 수 있습니다. <code>Reader</code>, <code>State</code> 를 받고, <code>Writer</code>, <code>A</code> (결과값), <code>State</code> 를 돌려주는 것으로 해석할 수 있습니다.</p>

<p><code>ReadwrWriterState.flatMap</code> 은 <code>State</code>, <code>Writer</code>, <code>Reader</code> 의 <code>flatMap</code> 을 모두 조합한것처럼 생겼습니다. 하는일도 그렇구요. </p>

<pre><code class="language-scala">/** A monad transformer stack yielding `(R, S1) =&gt; F[(W, A, S2)]`. */
sealed abstract class IndexedReaderWriterStateT[F[_], -R, W, -S1, S2, A] {

  ...

  def flatMap[B, RR &lt;: R, S3](f: A =&gt; IndexedReaderWriterStateT[F, RR, W, S2, S3, B])(implicit F: Bind[F], W: Semigroup[W]): IndexedReaderWriterStateT[F, RR, W, S1, S3, B] =
    new IndexedReaderWriterStateT[F, RR, W, S1, S3, B] {
      def run(r: RR, s1: S1): F[(W, B, S3)] = {
        F.bind(self.run(r, s1)) {
          case (w1, a, s2) =&gt; {
            F.map(f(a).run(r, s2)) {
              case (w2, b, s3) =&gt; (W.append(w1, w2), b, s3)
            }
          }
        }
      }
    }

  ...
</code></pre>

<ul>
<li><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala#L4">Scalaz - IndexedReaderWriterStateT</a></li>
<li><a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala#L179">Scalaz - ReaderWriterStateTMonad</a></li>
</ul>

<h2 id="rwstexample">RWST Example</h2>

<p>예제를 위해 간단한 모델을 만들어 보겠습니다. </p>

<ul>
<li><code>Reader</code> 로 <code>DatabaseConfig</code> 를</li>
<li><code>Writer</code> 로 <code>Vector[String]</code> 을</li>
<li><code>State</code> 로 <code>Connection</code> 을 이용하고</li>
</ul>

<p>결과값으로 타입 <code>A</code> 를 돌려주는 <code>Task[A]</code> 를 만들면 아래와 같습니다.</p>

<pre><code class="language-scala">object Database {  
  type Task[A] = ReaderWriterState[DatabaseConfig, Vector[String] /* log */, Connection, A]
  ...
</code></pre>

<p>여기에 몇 가지 제약조건을 걸어보겠습니다.</p>

<ul>
<li><code>DatabaseConfig.operationTimeoutMillis</code> 에 의해서 타임아웃(<code>OperationTimeoutException</code>) 발생</li>
<li><code>OperationTimeoutException</code> 발생시, 연산을 즉시 중단하고, 오류 없이 수행이 되었을 경우 <em>commit</em> </li>
<li><em>Post Commit Action</em> 등록을 할 수 있어야 하며, <em>commit</em> 후 순차대로 자동 실행</li>
</ul>

<p>이제 필요한 몇몇 클래스를 만들고</p>

<pre><code class="language-scala">type Action = () =&gt; Unit  
case class PostCommitAction(id: String, action: Action)  
case class DatabaseConfig(operationTimeoutMillis: Long)  
case class ResultSet() /* dummy */

case class Connection(id: String,  
                      actions: List[PostCommitAction] = Nil) {

  def commit = {}
  def executeAndReturn(query: String): ResultSet = ResultSet()
  def execute(query: String): Unit = {}
}

class OperationTimeoutException private(ex: RuntimeException) extends RuntimeException(ex) {  
  def this(message:String) = this(new RuntimeException(message))
  def this(message:String, throwable: Throwable) = this(new RuntimeException(message, throwable))
}

object OperationTimeoutException {  
  def apply(message:String) = new OperationTimeoutException(message)
  def apply(message:String, throwable: Throwable) = new OperationTimeoutException(message, throwable)
}
</code></pre>

<p>이제 사용자가 API 를 사용하는 것을 한번 상상해보겠습니다. <em>commit</em> 이 어쨌건, 사용자가 하고싶은 일은 쿼리를 실행해서 결과값을 받아오거나, 필요한 <em>post commit action</em> 을 등록하는 일일겁니다. 나머지는 다 알아서 해주겠거니 하고 기대하고 있겠지요. 아래와 같은 API 가 있다면,</p>

<pre><code class="language-scala">def createTask[A](f: Connection =&gt; A): Task[A]  
def addPostCommitAction(action: Action): Task[Unit]  
def run[A](task: Task[A]): Option[A]  
</code></pre>

<p>사용자들이 이런 방식으로 사용할 수 있습니다.</p>

<pre><code class="language-scala">case class Person(name: String, address: Address)  
case class Address(street: String)

def getPerson(name: String): Task[Person] = createTask { conn =&gt;  
  val rs: ResultSet = conn.executeAndReturn(s"SELECT * FROM USER WHERE name == '$name'")

  /* get a person using the result set */
  ...
}

def updateAddress(person : Person): Task[Unit] = createTask { conn =&gt;  
  /* do something */
  conn.execute(
    s"UPDATE ADDRESS SET street = '${person.address.street}' where person_name = '${person.name}'")
}

val getAndUpdatePersonTask: Task[Person] = for {  
  p &lt;- getPerson("1ambda")
  updatedP = p.copy(address = Address("BACON STREET 234"))
  _ &lt;- addPostCommitAction(() =&gt; println("post commit action1"))
  _ &lt;- updateAddress(updatedP)
  _ &lt;- addPostCommitAction(() =&gt; println("post commit action2"))
} yield updatedP

val person: Option[Person] = Database.run(getAndUpdatePersonTask)  
</code></pre>

<p>이제 상상했던 함수를 구현해 보면,</p>

<pre><code class="language-scala">// https://github.com/1ambda/scala/blob/master/learning-scalaz/src/main/scala/readerwriterstate/Database.scala

import java.util.UUID  
import scalaz._, Scalaz._  
import Database._  
import com.github.nscala_time.time.Imports._

object Database {

  ...
  object Implicit {
    implicit def defaultConnection: Connection = Connection(genRandomUUID)
    implicit def defaultConfig = DatabaseConfig(500)
  }

  private def genRandomUUID: String = UUID.randomUUID().toString

  private def execute[A](f: =&gt; A, conf: DatabaseConfig): A = {
    val start = DateTime.now

    val a = f

    val end = DateTime.now

    val time: Long = (start to end).millis

    if (time &gt; conf.operationTimeoutMillis)
      throw OperationTimeoutException(s"Operation timeout: $time millis")

    a
  }

  def createTask[A](f: Connection =&gt; A): Task[A] =
    ReaderWriterState { (conf, conn) =&gt;
      val a = execute(f(conn), conf)
      (Vector(s"Task was created with connection[${conn.id}]"), a, conn)
    }

  def addPostCommitAction(action: Action): Task[Unit] =
    ReaderWriterState { (conf, conn: Connection) =&gt;

      val postCommitAction = PostCommitAction(genRandomUUID, action)
      (Vector(s"Add PostCommitAction(${postCommitAction.id})"),
        Unit,
        conn.copy(actions = conn.actions :+ postCommitAction))
    }

  def run[A](task: Task[A])
            (implicit defaultConf: DatabaseConfig, defaultConn: Connection): Option[A] = {

    \/.fromTryCatchThrowable[(Vector[String], A, Connection), Throwable](
      task.run(defaultConf, defaultConn)
    ) match {
      case -\/(t) =&gt;
        println(s"Operation failed due to ${t.getMessage}") /* logging */
        none[A]

      case \/-((log: Vector[String], a: A, conn: Connection)) =&gt;
        conn.commit /* close connection */

        log.foreach { text =&gt; println(s"[LOG] $text")} /* logging */

        /* run post commit actions */
        conn.actions foreach { _.action() }

        a.some
    }
  }
</code></pre>

<p>이제 실제로 <em>500 ms</em> 를 초과하는 연산을 실행하면, 예외가 발생하는 것을 확인할 수 있습니다.</p>

<pre><code class="language-scala">  test("Database example") {

    val slowQuery: Task[Person] = createTask { conn =&gt;
      sleep(600)
      Person("Sherlock", Address("BACON ST 221-B"))
    }

    val getPeopleTask: Task[List[Person]] = for {
      p1 &lt;- getPerson("Mycroft")
      p2 &lt;- getPerson("Watson")
      p3 &lt;- slowQuery
      _ &lt;- addPostCommitAction(() =&gt; println("post commit1"))
    } yield p1 :: p2 :: p3 :: Nil

    import Database.Implicit._
    val people = Database.run(getPeopleTask)

    // log: Operation failed due to java.lang.RuntimeException: Operation timeout: 603 millis
    people shouldBe None
}
</code></pre>

<h2 id="previousposts">Previous Posts</h2>

<ul>
<li><a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1, State</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/">Easy Scalaz 2, Monad Transformer</a></li>
</ul>

<h2 id="references">References</h2>

<ul>
<li><a href="http://cs.lth.se/edan40">Haskell Image</a></li>
<li><a href="https://coderwall.com/p/ye_s_w/tooling-the-reader-monad">Tooling The Reader Monad</a></li>
<li><a href="http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/">Reader Monad For Dependency Injection</a></li>
<li><a href="http://slides.com/danielbedo/reader-monad">Slideshare: Reader Monad</a></li>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia Image</a></li>
<li><a href="http://docs.scala-lang.org/overviews/collections/performance-characteristics.html">Scala Collection Performance Characteristics</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[About Type Class]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png" alt=""></p>

<p>프로그래머가 하는 행위를 극도로 단순화해서 표현하면 <strong>저수준</strong> 의 데이터를 <strong>고수준</strong> 데이터로 변환하는 일입니다.</p>

<p>여기서 저수준이란, <em>Stream</em>, <em>Byte</em>, <em>JSON</em>, <em>String</em> 등 현실세계의 데이터를, 고수준이라 함은 비즈니스 로직, 제약조건 등이 추가된 도메인 객체, 모델 등 데이터를 말합니다. </p>

<p>이로 인해</p>

<ol>
<li><p>저수준을 고수준으로 변환하는건 조건이 충족되지 않은 데이터와 연산 과정에서 일어나는 시스템 오류를 처리해야하기</p></li></ol>]]></description><link>http://1ambda.github.io/about-type-class/</link><guid isPermaLink="false">40c5a8ff-eb1f-40a3-a8b6-38f5e97ced9f</guid><category><![CDATA[scala]]></category><category><![CDATA[scalaz]]></category><category><![CDATA[type class]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 20 Oct 2015 16:43:43 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png" alt=""></p>

<p>프로그래머가 하는 행위를 극도로 단순화해서 표현하면 <strong>저수준</strong> 의 데이터를 <strong>고수준</strong> 데이터로 변환하는 일입니다.</p>

<p>여기서 저수준이란, <em>Stream</em>, <em>Byte</em>, <em>JSON</em>, <em>String</em> 등 현실세계의 데이터를, 고수준이라 함은 비즈니스 로직, 제약조건 등이 추가된 도메인 객체, 모델 등 데이터를 말합니다. </p>

<p>이로 인해</p>

<ol>
<li><p>저수준을 고수준으로 변환하는건 조건이 충족되지 않은 데이터와 연산 과정에서 일어나는 시스템 오류를 처리해야하기 때문에 힘든일입니다</p></li>
<li><p>갖은 고생 끝에 데이터를 고수준으로 끌어올린 뒤에야, 그 데이터를 프로그래머 자신의 세상에서 마음껏 주무를 수 있습니다</p></li>
<li><p>프로그래머가 작업을 끝낼 시점이 되면, 데이터를 저수준으로 변환해서 저장 또는 전송해야 하는데, 이미 제약조건이 충족 되었기 때문에 이는 손쉬운 일입니다</p></li>
</ol>

<p>따라서 핵심은 다음의 두가지 입니다.</p>

<ul>
<li>쉽게 고수준으로 변환할 수 있는가 (<strong>연산</strong>)</li>
<li>변환된 고수준 데이터가 얼마나 다루기 편한가 (<strong>추상</strong>)</li>
</ul>

<p>프로그래머가 <em>적절한 연산</em> 을 선택하면 힘들이지 않고 변환을 해낼것이고, <em>적절한 추상 (혹은 모델링)</em> 을 한다면 직관적인 코드로 데이터를 주무를 수 있게 되는데, 이 것을 도와주는 것이 바로 <strong>타입 클래스</strong> 입니다.</p>

<p>타입 클래스를 이용하면, </p>

<ul>
<li><code>if null</code>  을 Option 으로,</li>
<li><code>S =&gt; (S, A)</code> 을 State[S, A] 로</li>
<li><code>if if if</code> 를 Applicative 로</li>
<li><em>fail-slow</em>, <em>fail-fast</em> 로직은 ValidationNel 과 Either 로</li>
<li><code>F[G[A]]</code> 을 <code>G[F[A]]</code> 로의 변경은 Traversal 로</li>
<li><code>setC{applyB{getA}}</code> 를 getA > applyB > setC 로(Kleisli)
표기할 수 있습니다.</li>
</ul>

<p>이렇게 연산을 각각의 타입으로 표시하기 때문에 로직을 파악하고, 분할하기 쉽습니다. 그리고 연산을 작성하는 과정이 타입을 조합하는 과정과 동일하기 때문에 컴파일러의 도움을 받을수 있구요.</p>

<p>타입클래스는 <strong>연산이 어떠해야 하는지</strong> 를 다루기 때문에 연산을 조합할 수 있는 다양한 함수들이 포함되어 있습니다. 이것을 이용하면 직관적인 방식으로 데이터를 다룰 수 있는데, 예를 들어 다음은 코드 실행과정에서 예외 발생 시에만 롤백을 수행하고, 예외를 돌려주는 코드입니다. (간략화 하였습니다.) </p>

<pre><code class="language-scala">\/.fromTryCatch { 
  val result = runQuery; 
  commit; 
  result 
} leftMap(err =&gt; rollback; err};
</code></pre>

<p>만약 <code>if null</code>  보다  <code>Option</code> 을 쓰는것이 더 편하고 익숙하다면, <code>Applicative</code> 부터 천천히 시작해보는건 어떨까요?</p>

<h3 id="reference">Reference</h3>

<ul>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia Image - Haskell Wiki</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Easy Scalaz 2, Monad Transformer]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p>지난 시간엔 <em>State Monad</em> 를 다루었습니다. 그러나 <em>State</em> 만 이용해서는 유용한 프로그램을 작성할 수 없습니다. 우리가 다루는 연산은 <em>Option</em>, <em>Future</em> 등 다양한 <em>side-effect</em> 가 필요하기 때문인데요, </p>

<p>서로 다른 <code>Monad</code> 를 조합할 수 있다면 좋겠지만, 아쉽게도  <code>Functor</code>, <code>Applicative</code> 와 달리 모나드는 <em>composing</em> 이 불가능합니다. <a href="http://tonymorris.github.io/blog/posts/monads-do-not-compose">Monad Do Not Compose</a></p>

<p>여러 모나드를 조합해서</p>]]></description><link>http://1ambda.github.io/easy-scalaz-2-monad-transformer/</link><guid isPermaLink="false">20ace812-f624-48ad-bfe9-9d1b707ed231</guid><category><![CDATA[scala]]></category><category><![CDATA[scalaz]]></category><category><![CDATA[monad transformer]]></category><category><![CDATA[EitherT]]></category><category><![CDATA[OptionT]]></category><category><![CDATA[StateT]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 16 Oct 2015 14:46:45 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p>지난 시간엔 <em>State Monad</em> 를 다루었습니다. 그러나 <em>State</em> 만 이용해서는 유용한 프로그램을 작성할 수 없습니다. 우리가 다루는 연산은 <em>Option</em>, <em>Future</em> 등 다양한 <em>side-effect</em> 가 필요하기 때문인데요, </p>

<p>서로 다른 <code>Monad</code> 를 조합할 수 있다면 좋겠지만, 아쉽게도  <code>Functor</code>, <code>Applicative</code> 와 달리 모나드는 <em>composing</em> 이 불가능합니다. <a href="http://tonymorris.github.io/blog/posts/monads-do-not-compose">Monad Do Not Compose</a></p>

<p>여러 모나드를 조합해서 사용하려면 <em>Monad Transformer</em> 가 필요합니다.</p>

<blockquote>
  <p>Monad transformers are useful for enabling interaction between different types of monads by "nesting" them into a higher-level monadic abstraction.</p>
</blockquote>

<p><em>Monad Transformer</em> 란 여러 모나드의 <em>effect</em> 를 엮어 새로운 모나드를 만들때 쓸 수 있습니다. 예를 들어</p>

<ul>
<li>어떤 임의의 모나드 M 을 사용하면서 <code>State</code> 효과를 주고 싶을 때 <code>StateT</code> 를 이용할 수 있습니다</li>
<li><code>State</code> 를 다루면서, <code>for</code> 내에서 <code>Option</code> 처럼 로직을 다루고 싶다면, <code>OptionT[State, A]</code> 를 이용할 수 있습니다</li>
</ul>

<p>대략 감이 오시죠? (<code>State</code> 에 대한 자세한 설명은 <a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1 - State</a> 을 참조)</p>

<p><em>scalaz</em> 에는 기본적으로 여러 모나드 트랜스포머가 정의되어 있습니다. (<a href="https://github.com/scalaz/scalaz/tree/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz">scalaz.core.*</a>) <code>ListT</code>, <code>MaybeT</code> 등등. 이번 글에서는 아래 3개의 모나드 트랜스포머만 다룰 예정입니다. </p>

<ul>
<li><a href="https://github.com/scalaz/scalaz/blob/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz/OptionT.scala">Scalaz - OptionT.scala</a></li>
<li><a href="https://github.com/scalaz/scalaz/blob/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz/EitherT.scala">Scalaz - EitherT.scala</a></li>
<li><a href="https://github.com/scalaz/scalaz/blob/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz/StateT.scala">Scalaz - StateT.scala</a></li>
</ul>

<h2 id="theproblem">The Problem</h2>

<p>모나드 트랜스포머를 설명하기 위해, 사용자의 Github Repository 에 어느 언어가 쓰였는지를 알려주는 <code>findLanguage</code> 함수를 작성해보겠습니다.</p>

<pre><code class="language-scala">// ref - https://softwarecorner.wordpress.com/2013/12/06/scalaz-optiont-monad-transformer/

import scalaz._, Scalaz._

case class User(name: String, repositories: List[Repository])  
case class Repository(name: String, languages: List[Language])  
case class Language(name: String, line: Long)

object GithubService {  
  def findLanguage(users: List[User],
                    userName: String,
                    repoName: String, 
                    langName: String): Option[Language] =
    for {
      u &lt;- users          find { _.name === userName }
      r &lt;- u.repositories find { _.name === repoName }
      l &lt;- r.languages    find { _.name === langName }
    } yield l
}
</code></pre>

<p><code>List[User]</code> 를 받아 해당 유저의 레포지토리에서 특정 언어가 있는지, 없는지를 검사하는 간단한 함수입니다.</p>

<pre><code class="language-scala">val u1 = User(  
  "1ambda", List(
    Repository("akka", List(
      Language("scala", 4990),
      Language("java",  12801)
    )),

    Repository("scalaz", List(
      Language("scala", 1451),
      Language("java",  291)
    ))
  )
)

val u2 = User(  
  "2ambda", List()
)

val users = List(u1, u2)

// spec
"findLanguage" in {
  val l1 = findLanguage(users, "1ambda", "akka", "scala")
  val l2 = findLanguage(users, "1ambda", "akka", "haskell")
  val l3 = findLanguage(users, "1ambda", "rx-scala", "scala")
  val l4 = findLanguage(users, "adbma1", "rx-scala", "scala")

  l1.isDefined shouldBe true
  l2.isDefined shouldBe false
  l3.isDefined shouldBe false
  l4.isDefined shouldBe false
  }
</code></pre>

<p>그런데, 요구사항이 갑자기 변경되어 많이 쓰이는 언어도 찾아내야 합니다. <strong>검사한 것 중 1000 줄이 넘는 언어리스트를 상태로 다루면</strong>,</p>

<pre><code class="language-scala">type LangState = State[List[Language], Option[Language]]  
</code></pre>

<p>이제 <code>findLanguage</code> 를 다시 작성하면,</p>

<pre><code class="language-scala">def findLanguage2(users: List[User],  
                  userName: String,
                  repoName: String,
                  langName: String): LangState =
  for {
    u &lt;- users.find(_.name === userName).point[LangState]
    r  &lt;- u.repositories.find(_.name === repoName).point[LangState]
    l &lt;- r.languages.find(_.name === langName).point[LangState]
    _ &lt;- modify(langs: List[Language] =&gt; if (l.line &gt;= 1000) l :: langs else langs)
  } yield song
</code></pre>

<p>당연히 컴파일이 되지 않습니다. 이는 <code>u</code>, <code>r</code>, <code>l</code> 이 각각 <code>User</code>, <code>Repository</code>, <code>Language</code> 가 아니라 <code>Option[User]</code>, <code>Option[Repository]</code>, <code>Option[Language]</code> 이기 때문입니다. 패턴 매칭을 적용하면 아래와 같은 코드가 만들어집니다.</p>

<pre><code class="language-scala">def findLanguage(users: List[User],  
                  userName: String,
                  repoName: String,
                  langName: String): LangState[Option[Language]] =
  for {
    optUser &lt;- (users.find { _.name === userName }).point[LangState]
    optRepository &lt;- (
      optUser match {
        case Some(u) =&gt; u.repositories.find(_.name === repoName)
        case None =&gt; none[Repository] // same as Option.empty[Repository]
      }).point[LangState]
    optLanguage &lt;- (optRepository match {
      case Some(r) =&gt; r.languages.find(_.name === langName)
      case None    =&gt; none[Language]
    }).point[LangState]
    _ &lt;- modify { langs: List[Language] =&gt; optLanguage match {
      case Some(l) if l.line =&gt; 1000 =&gt; l :: langs
      case _                         =&gt; langs
    }}
  } yield optLanguage
</code></pre>

<p>위 코드에서 중복되는 부분을 발견할 수 있는데요, 바로 <code>State[S, Option[A]]</code> 에 대해 매번 패턴 매칭을 수행하는 부분이 중복입니다. 이를 제거하기 위해 새로운 모나드 <code>LangStateOption</code> 을 만들면</p>

<pre><code class="language-sacla">case class LangStateOption[A](run: LangState[Option[A]])  
</code></pre>

<p>이제 모나드를 구현하면</p>

<pre><code class="language-scala">implicit val LangStateOptionMonad = new Monad[LangStateOption] {  
  override def point[A](a: =&gt; A): LangStateOption[A] =
    LangStateOption(a.point[Option].point[LangState])

  override def bind[A, B](fa: LangStateOption[A])(f: (A) =&gt; LangStateOption[B]): LangStateOption[B] =
    LangStateOption(fa.run.flatMap { (o: Option[A]) =&gt; o match {
      case Some(a) =&gt; f(a).run
      case None    =&gt; (none[B]).point[LangState] /* same as `(None: Option[B]).point[LangState]` */
    }})
}

// findLanguage impl
def findLanguage3(users: List[User],  
                  userName: String,
                  repoName: String,
                  langName: String): LangStateOption[Language] =
  for {
    u &lt;- LangStateOption((users.find { _.name === userName }).point[LangState])
    r &lt;- LangStateOption((u.repositories.find { _.name === repoName }).point[LangState])
    l &lt;- LangStateOption((r.languages.find { _.name === langName }).point[LangState])
    _ &lt;- LangStateOption((modify { langs: List[Language] =&gt;
      if (l.line &gt;= 1000) l :: langs else langs
    }) map (_ =&gt; none[Language]))
  } yield l
</code></pre>

<p>여기서 잘 보셔야 할 두 가지 부분이 있습니다</p>

<p>A. 우리가 임의의 모나드와 <code>Option</code> 을 엮은 새로운 모나드를 생성한다면, <code>LangStateOption</code> 타입만 다르고 모두 동일한 형태의 코드를 가지게 됩니다.</p>

<p>그런고로 <em>scalaz</em> 에서는 <code>Option</code> 과 임의의 모나드 <code>M</code> 을 조합한 타입을 <code>OptionT[M[_], A]</code> 로 제공합니다. </p>

<p>B. <code>State</code> 와 <code>Option</code> 을 엮어서 <code>State[S, Option[A]]</code> 를 엮을 경우 <code>State</code> 가 먼저 실행되고, 그 후에야 <code>Option</code> 이 효과를 발휘합니다. (<code>fa.run.flatMap { o =&gt; ...</code>}</p>

<p>따라서 어떤 모나드 트랜스포머와, 모나드를 엮냐에 따라서 의미가 달라집니다. 예를 들어 <em>scalaz</em> 에서 제공해주는 모나드 트랜스포머 <code>OptionT</code> 와 <code>StateT</code> 에 대해 </p>

<ul>
<li><code>OptionT[LangState, A]</code> 는 <code>run: LangState[Option[A]]</code> 이기 때문에 <em>optional value</em> 를 돌려주는 <em>state action</em> 을 의미하고</li>
<li>반면 <code>StateT[Option, List[Language], A]]</code> 는 <code>run: Option[State[List[Language], A]]</code> 기 때문에 존재하지 않을 수 있는 (<code>None</code>) 일 수 있는 <em>state action</em> 을 의미합니다</li>
</ul>

<h2 id="monadtrans">MonadTrans</h2>

<p>지금까지 우리가 했던 일을 살펴보면,</p>

<blockquote>
  <p><code>M[A]</code> -> <code>M[N[A]]</code> -> <code>NT[M[N[_]], A]</code></p>
</blockquote>

<p>즉 하나의 모나드 <code>M</code> 이 있을때 <code>A</code> 를 <code>N[A]</code> 로 <em>lifting</em> 하는 <code>N</code> 을 위한 모나드 트랜스포머를 <code>NT</code> 를 정의했습니다. <em>scalaz</em> 에서 사용된 모나드 트랜스포머 구현인 <code>MonadTrans</code>, <code>OptionT</code> 을 보면 다음과 같습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/MonadTrans.scala
trait MonadTrans[F[_[_], _]] {  
  def liftM[G[_]: Monad, A](g: G[A]): F[G, A]

  ...
}

// OptionT `liftM` implementation (F == Option)
// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/OptionT.scala#L213

def liftM[G[_], A](a: G[A])(implicit G: Monad[G]): OptionT[G, A]) =  
  OptionT[G, A](G.map[A, Option[A]](a) { (a: A) =&gt; 
    a.point[Option]
  }
</code></pre>

<p><strong>Monad Transformer</strong> 또한 <strong>Monad</strong> 기 때문에 또 다른 <strong>Monad Transformer</strong> 와 중첩이 가능합니다. 예를 들어</p>

<pre><code class="language-scala">// ref - http://www.slideshare.net/StackMob/monad-transformers-in-the-wild
type VIO[A] = ValidationT[IO, Throwable, A]  
def doIO: VIO[Option[String]  
val r = OptionT[VIO, String] = optionT[VIO](doIO)

// OptionT[ValidationT[IO, Throwable, A]
// == IO[Validation[Throwable, Option[A]]
</code></pre>

<h2 id="optiont">OptionT</h2>

<p>이제 모나드 트랜스포머가 무엇인지 알았으니, <code>OptionT</code> 를 사용해 볼까요?</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/OptionT.scala

final case class OptionT[F[_], A](run: F[Option[A]]) {  
  self =&gt;

  private def mapO[B](f: Option[A] =&gt; B)(implicit F: Functor[F]) = F.map(run)(f)

  def map[B](f: A =&gt; B)(implicit F: Functor[F]): OptionT[F, B] = new OptionT[F, B](mapO(_ map f))

  def flatMap[B](f: A =&gt; OptionT[F, B])(implicit F: Monad[F]): OptionT[F, B] = new OptionT[F, B](
    F.bind(self.run) {
      case None    =&gt; F.point(None: Option[B])
      case Some(z) =&gt; f(z).run
    }
  )

  def flatMapF[B](f: A =&gt; F[B])(implicit F: Monad[F]): OptionT[F, B] = new OptionT[F, B](
    F.bind(self.run) {
      case None    =&gt; F.point(none[B])
      case Some(z) =&gt; F.map(f(z))(b =&gt; some(b))
    }
  )
</code></pre>

<p><code>OptionT</code> 는 두 가지 방법으로 생성할 수 있습니다.</p>

<ul>
<li><code>val ma: M[A]</code> 가 있을 때 <code>ma.liftM[OptionT]</code></li>
<li><code>val oa: Option[A]</code> 가 있을 때 <code>OptionT(oa.point[M])</code></li>
</ul>

<pre><code class="language-scala">// type LangState[A] = State[List[Language], A]
val l = Language("lisp", 309)  
val os1: OptionT[LangState, Language] = l.point[LangState].liftM[OptionT]  
val os2: OptionT[LangState, Language] = OptionT(l.some.point[LangState])

os1 === os2  
os1.run === os2.run  
os1.run.runZero[List[Language]] === os2.run.runZero[List[Language]]  
</code></pre>

<p>이제 <code>findLanguage</code> 함수를 <code>OptionT</code> 로 작성할 수 있습니다. </p>

<pre><code class="language-scala">def findLanguage(users: List[User],  
                  userName: String,
                  repoName: String,
                  langName: String): OptionT[LangState, Language] =
  for {
    u &lt;- OptionT((users.find { _.name === userName }).point[LangState])
    r &lt;- OptionT((u.repositories.find { _.name === repoName }).point[LangState])
    l &lt;- OptionT((r.languages.find { _.name === langName }).point[LangState])
    _ &lt;- modify { langs: List[Language] =&gt;
      if (l.line &gt;= 1000) l :: langs else langs
    }.liftM[OptionT]
  } yield l
</code></pre>

<h3 id="sequencingoptiont">Sequencing OptionT</h3>

<p><code>findLanguage</code> 를 이용해서, findLanguage<strong>s</strong> 를 작성하는 것이 가능할까요?</p>

<pre><code class="language-scala">case class LanguageLookup(userName: String, repoName: String, langName: String)

// Option[List[Language]] 를 돌려주는 All or Nothing 버전
def findLanguages(users: List[User],  
                     lookups: List[LanguageLookup]): OptionT[LangState, List[Language]] = ???

// List[Option[Language]] 를 돌려주는 덜 엄격한 버전
def findLanguages(users: List[User],  
                     lookups: List[LanguageLookup]): LangState[List[Option[Language]]] = ???
</code></pre>

<p>일단 <code>OptionT[LangState, List[Language]]</code> 를 돌려주는 것 부터 작성해 보겠습니다.</p>

<pre><code class="language-scala">def findLanguages1(users: List[User],  
                   lookups: List[LanguageLookup]): OptionT[LangState, List[Language]] =
  lookups map { lookup =&gt;
    findLanguage(users, lookup.userName, lookup.repoName, lookup.langName)
  }

// compile error
Error:(87, 13) type mismatch;

 found   : List[scalaz.OptionT[LangState, Language]]
 required: scalaz.OptionT[LangState,List[Language]]
    lookups map { lookup =&gt;
            ^
</code></pre>

<p>우리는 <code>OptionT[LangState, List[Language]]</code> 를 돌려줘야 하는데, 단순히 <code>map</code> 만 적용해서는 <code>List[OptionT[LangState, Language]]</code> 밖에 못 얻습니다. 따라서 <code>Traversable.traverseU</code> 를 이용하면</p>

<pre><code class="language-scala">def findLanguages1(users: List[User],  
                   lookups: List[LanguageLookup]): OptionT[LangState, List[Language]] =
  lookups.traverseU { lookup =&gt;
    findLanguage(users, lookup.userName, lookup.repoName, lookup.langName)
  }
</code></pre>

<p>여기서 <code>traverseU(f)</code> 가 하는 일은 </p>

<ul>
<li><code>map(f)</code>: 함수 <code>f</code> 를 적용합니다.</li>
<li><code>List[OptionT[LangState, Language]]</code> 를 <code>OptionT[LangState, List[Language]]</code> 를 변환합니다. <strong>Option 모나드의 효과를 적용하면서요</strong> (<strong>sequence</strong>)</li>
</ul>

<p>일반적으로 <code>F[G[B]]</code> 를 <code>G[F[B]]</code> 로 변경하는 함수를 <code>sequence</code> 라 부릅니다. (<code>F</code> 는 <em>Monad</em>, <code>G</code> 는 <em>applicative</em>)</p>

<pre><code class="language-scala">final def sequence[G[_], B](implicit ev: A === G[B], G: Applicative[G]): G[F[B]] = {  
  ...
}
</code></pre>

<p><code>map</code> 후 <code>sequence</code> 를 호출하는 함수가 바로 위에서 보았던 <code>traverse</code> 입니다. 그런데, 더 높은 추상에서 보면 방금 말했던 것과는 반대로, <code>sequence</code> 가 <em>identity</em> 함수를 <code>map</code> 한 <code>traverse</code> 입니다. <strong>scalaz</strong> 에도 실제로 이렇게 구현되어 있습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/syntax/TraverseSyntax.scala#L25

  final def traverse[G[_], B](f: A =&gt; G[B])(implicit G: Applicative[G]): G[F[B]] =
    G.traverse(self)(f)

  /** Traverse with the identity function */
  final def sequence[G[_], B](implicit ev: A === G[B], G: Applicative[G]): G[F[B]] = {
    val fgb: F[G[B]] = ev.subst[F](self)
    F.sequence(fgb)
  }
</code></pre>

<p>위에서 <code>traverse</code> 가 아니라 <code>traverseU</code> 를 호출한 이유는 <code>OptionT</code> 에 대한 타입추론을 이용하기 위해서 입니다.</p>

<p><br></p>

<p>이제 덜 엄격한 <code>findLanguages</code> 함수를 작성해보겠습니다.</p>

<pre><code class="language-scala">def findLanguages2(users: List[User],  
                   lookups: List[LanguageLookup]): LangState[List[Option[Language]]] =
  lookups.traverseS { lookup =&gt;
    findLanguage(users, lookup.userName, lookup.repoName, lookup.langName).run
  }
</code></pre>

<p><code>traverseS</code> 는 <em>state</em> 버전의 <code>traverse</code> 입니다. <code>map</code> 을 적용한 <code>List[OptionT[LangState, Language]]</code> 에 대해 <code>LangState[List[Option[Language]]</code> 를 돌려줍니다.</p>

<pre><code class="language-scala">/** A version of `traverse` specialized for `State` */
final def traverseS[S, B](f: A =&gt; State[S, B]): State[S, F[B]] = F.traverseS[S, A, B](self)(f)  
</code></pre>

<p><code>State[S, A]</code> 에 대해서 </p>

<ul>
<li><code>State[S, Option[List[A]]</code> 를 얻고 싶다면 (<strong>all or nothing</strong>) <code>traverseU</code> 를</li>
<li><code>State[S, List[Option[A]]</code> 를 얻고 싶다면 <code>B = Option[A]</code> 를 <code>List</code> 로 감싸야 하므로 <code>State[S, F[B]]</code> 를 돌려주는 위해 <code>traverseS</code> 를 사용하면 됩니다.</li>
</ul>

<h3 id="eithert">EitherT</h3>

<p><code>EitherT</code> 는 <em>scalaz</em> 의 <code>Either</code> 에 대한 모나드 트랜스포머입니다. 참고로, <code>scalaz.Either</code> 은 <code>scala.Either</code> 과 달리 <em>right-biased</em> 입니다. <code>Option</code> 처럼요.</p>

<blockquote>
  <p><code>A \/ B</code> is isomorphic to <code>scala.Either[A, B]</code>, but <code>\/</code> is right-biased, so methods such as <code>map</code> and <code>flatMap</code> apply only in the context of the "right" case.</p>
</blockquote>

<p><code>scalaz.Either</code> 에 대한 기본적인 설명은 <a href="http://eed3si9n.com/learning-scalaz/Either.html">Learning Scalaz - Either</a> 에서 보실 수 있습니다.</p>

<p><br></p>

<p><code>EitherT</code> 를 위한 간단한 모델을 만들어 보겠습니다. </p>

<ul>
<li>쿼리를 파싱하고, 실행하는 과정에서 <em>상태</em> 인 <code>QueryState</code> 를 이용하고</li>
<li>쿼리 파싱에 실패하면 수행하지 않고 종료하기 위해 <code>scalaz.Either</code> 를 사용합니다 </li>
</ul>

<pre><code class="language-scala">// ref - https://speakerdeck.com/mpilquist/scalaz-state-monad

import scalaz._, Scalaz._

trait Model  
trait Query  
trait QueryResult

object QueryService {  
  def runQuery(s: String, model: Model): String \/ QueryResult = for {
    query &lt;- parseQuery(s)
    result &lt;- performQuery(query, model)
  } yield result

  def parseQuery(s: String): String \/ Query = "TODO".left
  def performQuery(q: Query, m: Model): String \/ QueryResult = "TODO".left
}
</code></pre>

<p>위 코드에 <em>State</em> 와 <code>EitherT</code> 를 추가하면 </p>

<pre><code class="language-scala">trait Model  
trait Query  
trait QueryResult  
trait Transaction 

object QueryService {  
  type TransactionState[A] = State[Transaction, A]
  type Transactional[A] = EitherT[TransactionState, String, A]

  def runQuery(s: String, model: Model): Transactional[QueryResult] = for {
    query &lt;- EitherT(parseQuery(s).point[TransactionState])
    result &lt;- EitherT(performQuery(query, model).point[TransactionState])
  } yield result

  def parseQuery(s: String): String \/ Query = ???
  def performQuery(q: Query, m: Model): String \/ QueryResult = ???
}
</code></pre>

<p>여기에 약간의 헬퍼 함수를 더하면,</p>

<pre><code class="language-scala">def runQuery(s: String, model: Model): Transactional[QueryResult] = for {  
  query &lt;- Transactional(parseQuery(s))
  result &lt;- Transactional(performQuery(query, model))
} yield result

object Transactional {  
  import QueryService._
  def apply[A](e: String \/ A): Transactional[A] = liftE(e)
  def liftE[A](e: String \/ A): Transactional[A] = 
    EitherT(e.point[TransactionState])
}
</code></pre>

<p>이제 <code>Transactional</code> 이 이름 그대로의 역할을 할 수 있게 간단한 커넥션도 모델링 해 보겠습니다.</p>

<pre><code class="language-scala">trait Transaction {  
  def closeConnection: Unit
  def commit: Unit = closeConnection
  def rollback: Unit = closeConnection
}

object QueryService {  
  type TransactionState[A] = State[Transaction, A]
  type EitherStringT[F[_], A] = EitherT[F, String, A]
  type Transactional[A] = EitherStringT[TransactionState, A]

  def parseQuery(s: String): String \/ Query =
    if (s.startsWith("SELECT")) s"Invalid Query: $s".left[Query]
    else (new Query {}).right[String]

  def performQuery(q: Query, m: Model): String \/ QueryResult =
    new QueryResult {}.right

  def runQuery(s: String, model: Model): Transactional[QueryResult] = for {
    query &lt;- Transactional(parseQuery(s))
    result &lt;- Transactional(performQuery(query, model))
    _ &lt;- (modify { t: Transaction =&gt; t.commit; t }).liftM[EitherStringT]
  } yield result
}
</code></pre>

<p>여기서 <code>EitherStringT</code> 타입을 새로 만든건, <code>liftM</code> 을 사용하기 위해서입니다. 만약 <code>liftM[EitherT]</code> 를 이용해 리프팅을 하면, 다음과 같은 예외가 발생합니다.</p>

<pre><code class="language-scala">Error:(37, 59) scalaz.EitherT takes three type parameters, expected: two  
    _ &lt;- (modify { t: Transaction =&gt; t.commit; t }).liftM[EitherT]
                                                          ^
</code></pre>

<p>이제 <code>parseQuery</code> 와 <code>performQuery</code> 실패시 <code>rollback</code> 을 호출하는것을 구현하고, <code>commit</code> 을 헬퍼 함수로 변경하겠습니다.</p>

<pre><code class="language-scala">def runQuery(s: String, model: Model): Transactional[QueryResult] = for {  
  query &lt;- Transactional(parseQuery(s))
  result &lt;- Transactional(performQuery(query, model))
  _ &lt;- commit
} yield result

def commit: Transactional[Unit] =  
  (modify { t: Transaction =&gt; t.commit; t }).liftM[EitherStringT]

object Transactional {  
  import QueryService._
  def apply[A](e: String \/ A): Transactional[A] = e match {
    case -\/(error) =&gt;
      /* logging error and... */
      liftTS(State[Transaction, String \/ A] { t =&gt; t.rollback; (t, e) })
    case \/-(a) =&gt; liftE(e)
  }

  def liftE[A](e: String \/ A): Transactional[A] =
    EitherT(e.point[TransactionState])

  def liftTS[A](tse: TransactionState[String \/ A]): Transactional[A] =
    EitherT(tse)
}
</code></pre>

<p>이제 다음처럼 실패시 롤백이 호출되고 <code>for</code> 자동으로 스탑되는것을 확인할 수 있습니다.</p>

<pre><code class="language-scala">val t = new Transaction {}  
val model = new Model {}  
val result1 = runQuery("qqq", model).run.eval(t)  
println(result)

// output
parseQuery  
rollback  
-\/(Invalid Query: qqq)

val result2 = runQuery("SELECT", model).run.eval(t)  
println(result2)

// output
parseQuery  
performQuery  
\/-(QueryService$$anon$2@36804139)
</code></pre>

<p>만약 <code>Transaction</code> 에 <code>committed</code>, <code>rollbacked</code> 등의 값을 추가하면 <code>eval</code> 대신 <code>exec</code> (<code>run</code> 도 가능) 으로 최종 상태인 <code>Transaction</code> 을 얻어 확인할 수 있습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/StateT.scala#L17

  /** An alias for `apply` */
  def run(initial: S1): F[(S2, A)] = apply(initial)

  /** Calls `run` using `Monoid[S].zero` as the initial state */
  def runZero[S &lt;: S1](implicit S: Monoid[S]): F[(S2, A)] =
    run(S.zero)

  /** Run, discard the final state, and return the final value in the context of `F` */
  def eval(initial: S1)(implicit F: Functor[F]): F[A] =
    F.map(apply(initial))(_._2)

  /** Calls `eval` using `Monoid[S].zero` as the initial state */
  def evalZero[S &lt;: S1](implicit F: Functor[F], S: Monoid[S]): F[A] =
    eval(S.zero)

  /** Run, discard the final value, and return the final state in the context of `F` */
  def exec(initial: S1)(implicit F: Functor[F]): F[S2] =
    F.map(apply(initial))(_._1)

  /** Calls `exec` using `Monoid[S].zero` as the initial state */
  def execZero[S &lt;: S1](implicit F: Functor[F], S: Monoid[S]): F[S2] =
    exec(S.zero)
</code></pre>

<h3 id="statet">StateT</h3>

<p><a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1 - State</a> 에서 언급했던 것 처럼</p>

<pre><code class="language-scala">type State[S, A] = StateT[Id, S, A]  
type Id[+X] = X

// 더 엄밀히는,

type StateT[F[_], S, A] = IndexedStateT[F, S, S, A]  
type IndexedState[-S1, S2, A] = IndexedStateT[Id, S1, S2, A]  
</code></pre>

<p><code>StateT</code> 에다가 혼합할 모나드 <code>F</code> 에 <code>Id</code> 를 준것이 <code>State</code> 입니다.</p>

<p>여기에 함수 <code>replicateM</code> 을 적용하면,</p>

<pre><code class="language-scala">// https://speakerdeck.com/mpilquist/scalaz-state-monad
  "replicateM(10)" in {

    // def replicateM(n: Int): F[List[A]]
    val getAndIncrement: State[Int, Int] = State { s =&gt; (s + 1, s) }
    getAndIncrement.replicateM(10).run(0) shouldBe (10, (0 until 10).toList)
  }
</code></pre>

<p>따라서 <code>State</code> 를 <code>F[_]</code> 라 보면 이걸 <code>F[List[_]]</code> 로 만들어 주므로 여러개의 <code>flatMap</code> 이 중첩된 형태가 됩니다.</p>

<p>따라서 <code>replicateM(100000)</code> 등의 코드는 <em>Stackoverflow</em> 가 발생합니다.</p>

<p>이 문제를 해결하기 위해 <code>Trampoline</code> 을 이용할 수 있습니다.</p>

<blockquote>
  <p>Scalaz provides the <code>Free</code> data type, which when used with Function0, trade heap for stack</p>
</blockquote>

<p>이럴때 <code>Trampoline</code> 을 사용하면, <em>stackoverflow</em> 를 피할 수 있습니다. (그만큼의 힙을 사용해서)</p>

<pre><code class="language-scala">// type Trampoline[+A] = Free[Function0, A]

"replicateM(1000)" in {

  import scalaz.Free._

  val getAndIncrement: State[Int, Int] = State { s =&gt; (s + 1, s) }
  getAndIncrement.lift[Trampoline].replicateM(1000).run(0).run shouldBe (1000, (0 until 1000).toList)
}
</code></pre>

<p><code>Trampoline</code> 은 후에 <code>Free</code> 를 살펴보면서 다시 보겠습니다.</p>

<h3 id="references">References</h3>

<ul>
<li><a href="http://tonymorris.github.io/blog/posts/monads-do-not-compose">Tony Morris - Monad Do Not Compose</a></li>
<li><a href="https://softwarecorner.wordpress.com/2013/12/06/scalaz-optiont-monad-transformer/">Scalaz OptionT Monad Transformer</a></li>
<li><a href="https://speakerdeck.com/mpilquist/scalaz-state-monad">State Monad in Scalaz</a></li>
<li><a href="https://github.com/earldouglas/scala-scratchpad/tree/master/category-theory/monad-transformers">scala-scratchpad: Monad Transformer in Scala</a></li>
<li><a href="http://tpolecat.github.io/assets/scalaz.svg">Scalaz Typeclass Hierarchy</a></li>
<li><a href="http://stackoverflow.com/questions/26602611/how-to-understand-traverse-traverseu-and-traversem">Stackoverflow - traverseU, traverseM</a></li>
<li><a href="http://cs.lth.se/edan40">Haskell Image</a></li>
<li><a href="https://wiki.haskell.org/All_About_Monads#The_IO_monad">Haskell Wiki - All About Monads</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Easy Scalaz 1, State]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<h3 id="state">State</h3>

<p><code>State</code> 를 설명하는 수많은 문구들이 있지만, 타입만큼 간단한건 없습니다.</p>

<pre><code class="language-scala">State[S, A] :: S =&gt; (S, A)  
</code></pre>

<blockquote>
  <p>A state transition, representing a <strong>function</strong> </p>
</blockquote>

<p>즉 <code>S</code> 를 받아 <code>(S, A)</code> 를 돌려주는 함수를, 타입클래스 <code>State[S, A]</code> 로 표현합니다. </p>

<p>더 엄밀히는, (<em>scalaz</em>  구현에서는) <code>type State[S, A] = StateT[Id, S, A]</code></p>]]></description><link>http://1ambda.github.io/easy-scalaz-1-state/</link><guid isPermaLink="false">f9bd7b24-522b-412b-8c4f-cd741c93bc28</guid><category><![CDATA[scala]]></category><category><![CDATA[state monad]]></category><category><![CDATA[scalaz]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 12 Oct 2015 14:14:00 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<h3 id="state">State</h3>

<p><code>State</code> 를 설명하는 수많은 문구들이 있지만, 타입만큼 간단한건 없습니다.</p>

<pre><code class="language-scala">State[S, A] :: S =&gt; (S, A)  
</code></pre>

<blockquote>
  <p>A state transition, representing a <strong>function</strong> </p>
</blockquote>

<p>즉 <code>S</code> 를 받아 <code>(S, A)</code> 를 돌려주는 함수를, 타입클래스 <code>State[S, A]</code> 로 표현합니다. </p>

<p>더 엄밀히는, (<em>scalaz</em>  구현에서는) <code>type State[S, A] = StateT[Id, S, A] where Id[+X] = X</code> 인데 이것은 나중에 <code>StateT</code> 에서 다시 보겠습니다.</p>

<p>우선 기억해둘 것은 <code>State</code> 가 <strong>함수</strong> 를 나타낸다는 사실입니다. 상태 <code>S</code> 를 변경하면서 <code>A</code> 를 만들어내는 함수를 말이지요. 즉, <code>State</code> 는 더도 말고 덜도 말고, 상태를 조작하는 <strong>함수</strong> 입니다. 여기에 모나드라고 하니, <code>flatMap</code> 같은 몇몇 함수가 추가된 것 뿐이지요.</p>

<h3 id="statebasics">State Basics</h3>

<p><code>State</code> 코드를 들춰보면, 아래와 같이 생겼습니다. </p>

<pre><code class="language-scala">object State extends StateFunctions {  
  def apply[S, A](f: S =&gt; (S, A)): State[S, A] = new StateT[Id, S, A] {
    def apply(s: S) = f(s)
  }
}

trait StateFunctions extends IndexedStateFunctions {  
  def constantState[S, A](a: A, s: =&gt; S): State[S, A] = State((_: S) =&gt; (s, a))
  def state[S, A](a: A): State[S, A] = State((_ : S, a))
  def init[S]: State[S, S] = State(s =&gt; (s, s))
  def get[S]: State[S, S] = init
  def gets[S, T](f: S =&gt; T): State[S, T] = State(s =&gt; (s, f(s)))
  def put[S](s: S): State[S, Unit] = State(_ =&gt; (s, ()))
  def modify[S](f: S =&gt; S): State[S, Unit] = State(s =&gt; {
    val r = f(s);
    (r, ())
  })
}
</code></pre>

<ul>
<li><code>State.apply</code> 에 상태 <code>S</code> 를 조작하는 함수 <code>f</code> 를 먹이면 <code>StateT</code> 가 나오고</li>
<li><code>StateT.apply</code> 에 초기 상태 <code>S</code> 를 먹이면 최종 결과물인 <code>(S, A)</code> 가 나옵니다</li>
</ul>

<p>그리고 코드를 조금 만 더 따라가다 보면 <code>apply</code> 의 <em>alias</em> 로 <code>run</code> 이라는 함수가 제공되는걸 알 수 있습니다. <a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/StateT.scala#L10">(Scalaz StateT.scala #L10)</a></p>

<p><code>flatMap</code> 으로 상태 조작함수 <code>f</code> 여러개를 엮다가 하다가 마지막에 <code>run</code> 으로 실행시킬것 같다는 느낌이 들죠? </p>

<p><br></p>

<p>이제 <code>StateFunctions</code> <em>trait</em> 로 제공되는 함수를 사용해 볼까요? 그냥 써보면 재미 없으니, Github 에서 각 Repository 마다 존재하는 <em>star</em> 를 가져오는 것을 간단히 모델링 해보겠습니다. 매번 네트워크 요청을 통해 가져오면 느리니까, <code>Map[String, Int]</code> 타입의 캐시도 포함시켜서요.</p>

<pre><code class="language-scala">import scalaz._, Scalaz._ /* import all */

type Cache = Map[String, Int]

"create, run State" in {
  val s: State[Cache, Int] = State { c =&gt; (c, c.getOrElse("1ambda/scala", 0))}
  val c: Cache = Map("1ambda/scala" -&gt; 1)

  // def run(s: S): (S, A)
  val (c1, star1) = s.run(c)
  val (c2, star2) = s.run(Map.empty)

  (c1, star1) shouldBe (Map("1ambda/scala" -&gt; 1), 1)
  (c2, star2) shouldBe (Map(), 0)
}
</code></pre>

<p>이 작은 코드에서 우리가 다루는 상태는 <code>Cache</code> 입니다. 아직은 <code>State { c =&gt; ... }</code> 에서 받은 <code>c: Cache</code> 를 수정하지 않기 때문에 <code>run</code> 에서 돌려주는 상태 (<em>State</em>) 는 <code>run</code> 에 넘긴 것과 동일합니다. 그런고로 <code>c == c1 == c2</code> 입니다. </p>

<p>이번엔 상태를 변경하는 함수를 만들어 보겠습니다. 캐시에서 데이터를 가져오면, 캐시를 그대로 돌려주고 미스가 발생하면 캐시에 레포지토리 URL 을 추가하겠습니다.</p>

<pre><code class="language-scala">def getStargazer(url: String): State[Cache, Int] = State { c =&gt;  
  c.get(url) match {
    case Some(count) =&gt; (c, count)
    case None        =&gt; (c.updated(url, 0), 0)
  }
}

"getStargazer" in {
  val c: Cache = Map("1ambda/scala" -&gt; 1)

  val s1 = getStargazer("1ambda/haskell")
  val (c1, star) = s1.run(c)

  (c1, star) shouldBe (c.updated("1ambda/haskell", 0), 0)
}
</code></pre>

<p><code>State</code> 는 모나드기 때문에, <code>for</code> 내에서 이용할 수 있습니다. 아래에서 더 자세히 살펴보겠습니다.</p>

<h3 id="statemonadapplicativeandfunctor">State Monad, Applicative and Functor</h3>

<p>모나드는 <code>return</code> 과 <code>bind</code> 를 가지고 특정한 규칙을 만족하는 타입 클래스를 말하는데요, <em>scala</em> 에서는 <code>bind</code> 는 <code>flatMap</code> 이란 이름으로 제공되는 것 아시죠? </p>

<pre><code class="language-scala">trait Monad[A] {  
  // sometimes called `unit`
  def return(a: A): M[A]
  def flatMap[B](f: A =&gt; M[B]): M[B]
}
</code></pre>

<p><em>scalaz</em> 에선 <code>Monad</code> 는 아래의 두 타입클래스를 상속받아 구현됩니다. </p>

<ul>
<li><code>Applicative.point</code> (= <code>return</code>)</li>
<li><code>Bind.bind</code> (= <code>bind</code>) </li>
</ul>

<pre><code class="language-scala">trait Bind[F[_]] extends Apply[F] { self =&gt;  
  ...
  def bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]
  ...
}

trait Applicative[F[_]] extends Apply[F] { self =&gt;  
  ...
  def point[A](a: =&gt; A): F[A]
  ...
}
</code></pre>

<p>게다가 <code>Apply</code> 가 <code>Functor</code> 를 상속받으므로 </p>

<pre><code class="language-scala">trait Apply[F[_]] extends Functor[F] { self =&gt;  
  def ap[A,B](fa: =&gt; F[A])(f: =&gt; F[A =&gt; B]): F[B]
  ...
</code></pre>

<p><em>scalaz</em> 에서 <code>State</code> 는 <code>Functor</code> 이면서, <code>Applicative</code> 이고, <code>Monad</code> 입니다.</p>

<p>아래는 <a href="https://github.com/tpolecat/doobie">doobie</a> 를 만든 <a href="https://github.com/tpolecat">@tpolecat</a> 의 블로그에서 가져온 <em>scalaz</em> 타입 클래스 계층인데, 이 그림을 보면 왜 그런지 알 수 있습니다. (<a href="http://tpolecat.github.io/assets/scalaz.svg">http://tpolecat.github.io/assets/scalaz.svg</a>)</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/scalaz.png" alt=""></p>

<p>이제 <code>State</code> 가 모나드라는 사실을 알았으니, 위에서 작성했던 <code>getStargazer</code> 함수를 다시 작성해보겠습니다. <em>for comprehension</em> 을 사용할건데요, </p>

<ul>
<li>먼저 <code>State[Cache, Int]</code> 의 상태인 <code>Cache</code> 를 얻어와야 하므로 <code>get</code> 을 이용하고</li>
<li>상태를 변경해야 하므로 <code>modify</code> 를 호출하겠습니다. </li>
</ul>

<pre><code class="language-scala">// State helper functions defined in `StateFunctions` trait
def state[S, A](a: A): State[S, A] = State((_ : S, a))  
def init[S]: State[S, S] = State(s =&gt; (s, s)) /* 상태 S 를 아웃풋 A 위치로 꺼냄 */  
def get[S]: State[S, S] = init  
def gets[S, T](f: S =&gt; T): State[S, T] = State(s =&gt; (s, f(s)))  
def put[S](s: S): State[S, Unit] = State(_ =&gt; (s, ()))  
def modify[S](f: S =&gt; S): State[S, Unit] = State(s =&gt; {  
  /* 상태 S 를 변경하는 함수를 받아, 적용하고 A 위치에 `()` 를 돌려줌 */
  val r = f(s);
  (r, ())
})

def getStargazer(url: String): State[Cache, Int] = State { c =&gt;  
  c.get(url) match {
    case Some(count) =&gt; (c, count)
    case None        =&gt; (c.updated(url, 0), 0)
  }
}

def getStargazerWithFor(url: String): State[Cache, Int] =  
  for {
    c &lt;- State.get[Cache]
    optCount = c.get(url)
    _ &lt;- modify { c: Cache =&gt;
      // same as `if (optCount.isDefined) c else c.updated(url, 0)`
      optCount match {
        case Some(count) =&gt; c
        case None        =&gt; c.updated(url, 0)
      }
    }
  } yield optCount.getOrElse(0)
</code></pre>

<h3 id="whentousestate">When to use State</h3>

<p>그러면, 언제 <code>State</code> 가 필요할까요? 하나의 <strong>상태</strong> (<em>State</em>) 를 지속적으로 변경, 공유하면서 연산을 실행할 때 사용할 수 있습니다.</p>

<blockquote>
  <p>Building computations from sequences of operations that require a shared state.</p>
</blockquote>

<p>예를 들어 HTTP 요청과 응답, 트랜잭션 등을 <code>State</code> 로 다루면서 연산을 조합해서 사용할 수 있습니다.</p>

<ul>
<li>HttpRequest, HttpResponse, HttpSession</li>
<li>Database Transaction</li>
<li>Random Number Generator</li>
</ul>

<h3 id="githubserviceexample">Github Service Example</h3>

<p>그러면 위에서 보았던 <code>Cache</code> 에 약간의 기능을 추가해 볼까요? 캐시 히트, 미스도 저장하고 캐시 히트는 최대 5분까지만 인정하기로 하지요. 오래된 캐시를 삭제하는 기능을 빼고 만들어 보면,</p>

<pre><code class="language-scala">type URL = String  
type StarCount = Int

case class Timestamped(count: StarCount, time: DateTime)

case class Cache(hits: Int, misses: Int, map: Map[URL, Timestamped]) {  
  def get(url: URL): Option[Timestamped] = map.get(url)
  def update(url: URL, timestamp: Timestamped): Cache = {
    val m = map + (url -&gt; timestamp)
    this.copy(map = m)
  }
}

object Cache {  
  def empty = Cache(0, 0, Map())
}
</code></pre>

<p>만약 <code>State</code> 가 없다면, 우리가 다루는 상태인 <code>Cache</code> 를 명시적으로 넘겨주고, 리턴받기 위해 이렇게 코드를 작성해야 할테지요. 여기서 <code>c1</code> 대신 <code>c</code> 를 쓰는 오타라도 발생한다면..</p>

<pre><code class="language-scala">def stargazerCount(url: URL, c: Cache): (Cache, StarCount) = {  
  val (c1, optCount) = checkCache(url, c)

  optCount match {
    case Some(count) =&gt; (c1, count)
    case None =&gt; retrieve(url, c1)
  }
}

def checkCache(url: URL, c: Cache): (Cache, Option[StarCount]) =  
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&gt;
      (c.copy(misses = c.misses + 1), None)
  }

def retrieve(url: URL, c: Cache): (Cache, StarCount) = {  
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def stale(then: DateTime): Boolean = DateTime.now &gt; then + 5.minutes  
def getStarCountFromWebService(url: URL): StarCount = ...  
</code></pre>

<p><br></p>

<p>여기에 <code>State</code> 를 하나씩 적용해 보겠습니다.</p>

<pre><code class="language-scala">def stargazerCount(url: URL, c: Cache): (Cache, StarCount) = {  
  val (c1, optCount) = checkCache(url, c)

  optCount match {
    case Some(count) =&gt; (c1, count)
    case None =&gt; retrieve(url, c1)
  }
}
</code></pre>

<p>먼저 <code>State</code> 타입을 적용하고, 그 후에 <code>for</code> 문을 적용한 뒤에, <code>State.state</code> 를 이용해서 조금 더 깔끔하게 바꾸면</p>

<pre><code class="language-scala">// applying State 
def stargazerCount(url: URL): State[Cache, StarCount] =  
  checkCache(url) flatMap { optCount =&gt;
    optCount match {
      case Some(count) =&gt; State { c =&gt; (c, count) }
      case None        =&gt; retrieve(url)
    }
  }

// use for-comprehension
def stargazerCount2(url: URL): State[Cache, StarCount] = for {  
  optCount &lt;- checkCache(url)
  count &lt;- optCount match {
    case Some(count) =&gt; State[Cache, StarCount] { c =&gt; (c, count) }
    case None        =&gt; retrieve(url)
  }
} yield count

// State.state
def stargazerCount(url: URL): State[Cache, StarCount] = for {  
  optCount &lt;- checkCache(url)
  count &lt;- optCount
    .map(State.state[Cache, StarCount])
    .getOrElse(retrieve(url))
} yield count
</code></pre>

<p><code>checkCache</code> 함수에도 적용해 보겠습니다.</p>

<pre><code class="language-scala">def checkCacheOrigin(url: URL, c: Cache): (Cache, Option[StarCount]) =  
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&gt;
      (c.copy(misses = c.misses + 1), None)
  }

def checkCache1(url: URL): State[Cache, Option[StarCount]] = State { c =&gt;  
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&gt;
      (c.copy(misses = c.misses + 1), None)
  }
}

/**
 *  Has potential bug.
 *  Always use `State.gets` and `State.modify`.
 */
def checkCache2(url: URL): State[Cache, Option[StarCount]] = for {  
  c &lt;- State.get[Cache]
  optCount &lt;- State.state {
    c.get(url) collect { case Timestamped(count, time) if !stale(time) =&gt; count }
  }
  _ &lt;- State.put(optCount ? c.copy(hits = c.hits + 1) | c.copy(misses = c.misses + 1))
} yield optCount

def checkCache(url: URL): State[Cache, Option[StarCount]] = for {  
  optCount &lt;- State.gets { c: Cache =&gt;
    c.get(url) collect { case Timestamped(count, time) if !stale(time) =&gt; count }
  }
  _ &lt;- State.modify { c: Cache =&gt;
    optCount ? c.copy(hits = c.hits + 1) | c.copy(misses = c.misses + 1)
  }
} yield optCount
</code></pre>

<p><code>checkCache2</code> 는 <code>State.get</code> <code>State.put</code> 때문에 버그가 발생할 수 있습니다. <code>get</code> 으로 꺼낸 뒤에 <code>put</code> 으로 넣으면, 이전에 어떤 상태가 있었든지, 덮어 씌우기 때문에 주의가 필요합니다. 일반적으로는 <code>put</code> 대신 <code>modify</code> 를 이용합니다.</p>

<pre><code class="language-scala">def init[S]: State[S, S] = State(s =&gt; (s, s))  
def get[S]: State[S, S] = init  
def put[S](s: S): State[S, Unit] = State(_ =&gt; (s, ()))

def gets[S, T](f: S =&gt; T): State[S, T] = State(s =&gt; (s, f(s)))  
def modify[S](f: S =&gt; S): State[S, Unit] = State(s =&gt; {  
</code></pre>

<p>마지막으로 <code>retrieve</code> 함수도 수정해볼까요</p>

<pre><code class="language-scala">def retrieveOrigin(url: URL, c: Cache): (Cache, StarCount) = {  
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def retrieve1(url: URL): State[Cache, StarCount] = State { c =&gt;  
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def retrieve(url: URL): State[Cache, StarCount] = for {  
  count &lt;- State.state { getStarCountFromWebService(url) }
  timestamp = Timestamped(count, DateTime.now)
  _ &lt;- State.modify[Cache] { _.update(url, timestamp) }
} yield count
</code></pre>

<h3 id="references">References</h3>

<ul>
<li><a href="https://speakerdeck.com/mpilquist/scalaz-state-monad">State Monad in Scalaz</a></li>
<li><a href="http://tpolecat.github.io/assets/scalaz.svg">Scalaz Typeclass Hierarchy</a></li>
<li><a href="http://cs.lth.se/edan40">Haskell Image</a></li>
<li><a href="https://github.com/fpinscala/fpinscala/wiki/Chapter-11:-Monads">fpinscala - Monad</a></li>
<li><a href="https://wiki.haskell.org/All_About_Monads#The_IO_monad">Haskell Monad</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Reactive Message Patterns w/ Actor Model, Chapter 1]]></title><description><![CDATA[<p><img src="http://berb.github.io/diploma-thesis/original/resources/actors.svg" alt=""></p>

<h2 id="whyenterprisesoftwaredevelopmentishard">Why Enterprise Software Development Is Hard</h2>

<p>엔터프라이즈 소프트웨어를 구현할 때 마주치는 문제점은, 고려해야할 것이 너무나 많다는 점입니다.</p>

<ul>
<li>Physical Tiers</li>
<li>Application Servers</li>
<li>Software layers</li>
<li>Frameworks and Patterns</li>
<li>Toolkits</li>
<li>Databases</li>
<li>Messaging Systems</li>
<li>Third-Party Applications</li>
<li>...</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/reactive-message-patterns/complexity_stack.png" alt=""></p>

<p>이런 요소들로 구성된 <strong>complexity stack</strong> 의 내부를 잘 살펴보면, 결국 관심사는 <strong>command</strong> 에 의해 생성된 <strong>domain event</strong> 를</p>]]></description><link>http://1ambda.github.io/reactive-message-patterns-w-actor-model-chapter-1/</link><guid isPermaLink="false">5c6d3ec5-2b23-462a-94da-f5df4ae0bdda</guid><category><![CDATA[scala]]></category><category><![CDATA[actor]]></category><category><![CDATA[akka]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 20 Sep 2015 16:33:22 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://berb.github.io/diploma-thesis/original/resources/actors.svg" alt=""></p>

<h2 id="whyenterprisesoftwaredevelopmentishard">Why Enterprise Software Development Is Hard</h2>

<p>엔터프라이즈 소프트웨어를 구현할 때 마주치는 문제점은, 고려해야할 것이 너무나 많다는 점입니다.</p>

<ul>
<li>Physical Tiers</li>
<li>Application Servers</li>
<li>Software layers</li>
<li>Frameworks and Patterns</li>
<li>Toolkits</li>
<li>Databases</li>
<li>Messaging Systems</li>
<li>Third-Party Applications</li>
<li>...</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/reactive-message-patterns/complexity_stack.png" alt=""></p>

<p>이런 요소들로 구성된 <strong>complexity stack</strong> 의 내부를 잘 살펴보면, 결국 관심사는 <strong>command</strong> 에 의해 생성된 <strong>domain event</strong> 를 저장하는 일임을 알 수 있습니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/reactive-message-patterns/simplicity_stack.png" alt=""></p>

<p><em>Actor Model</em> 은 여기에서 출발합니다. 불필요한 컴포넌트를 제외하고, <strong>command</strong> 와 <strong>event</strong> 에만 집중할 수 있도록 추상화를 제공합니다.</p>

<ul>
<li>What incoming messages (commands and/or events) do I accept?</li>
<li>What outgoing messages (commands and/or events) do I emit?</li>
<li>How can my state be mutated in reaction to incoming messages?</li>
<li>What is my supervision strategy for supervised actors?</li>
</ul>

<p><br></p>

<h2 id="originofactors">Origin Of Actors</h2>

<p>Actor Model 은 최근에 새롭게 만들어진 개념이 아니라, 1973년(<em>Dr. Carl Hewitt</em>) 부터 있었던 개념입니다. 다만 당시에는 컴퓨팅 파워가 부족했기 때문에 활용되지 않았을 뿐입니다. Actor Model 이 처음 만들어졌을 당시에는 CPU 클럭은 1MHz 남짓이었고 멀티코어 프로세서는 존재하지도 않았습니다. </p>

<p><br></p>

<h2 id="understandingactors">Understanding Actors</h2>

<p><em>Actor</em> 는 하나의 컴퓨팅 객체로서 메시지를 받아 다음의 일들을 수행할 수 있습니다.</p>

<ul>
<li>Send a finite number of messages to other actors</li>
<li>Create a finite number of new actors</li>
<li>Designate the behavior to be used for the next messages it receives</li>
</ul>

<p>Actor System 에서는 모든것이 Actor 입니다. 따라서 <code>Int</code>, <code>String</code> 처럼 일종의 <em>primitive type</em> 으로 생각하면 더 이해가 쉽습니다.</p>

<p>Actor System 과 Actor 는 다음의 특성을 가지고 있습니다. </p>

<ul>
<li>Communication via direct asynchronous message</li>
<li>State machines (FSM)</li>
<li>Share nothing</li>
<li>Lock-Free Concurrency</li>
<li>Parallelism</li>
</ul>

<p><strong>Akka</strong> 에서 추가적으로 제공하는 특성들은 다음과 같습니다.</p>

<ul>
<li>Location Transparency</li>
<li>Supervision</li>
<li>Future / Promises</li>
</ul>

<p><br></p>

<h2 id="concurrencyandparallelism">Concurrency and Parallelism</h2>

<blockquote>
  <p>Concurrency describes multiple computation occurring simultaneously. Parallelism is concurrency but applied to achieving a single goal. Parallelism is achieved by dividing a single complex process into smaller tasks and executing them concurrently. </p>
</blockquote>

<p><a href="https://en.wikipedia.org/wiki/Amdahl%27s_law?oldformat=true">Amdahl’s law</a> 에 의하면 <strong>병렬화해서 얻을 수 있는 최대 성능은, 병렬화 할 수 없는 부분에 의해서 제한됩니다.</strong> </p>

<p>따라서 시스템을 얼마나 병렬화 할 수 있도록 디자인하는가가 성능에 영향을 주게 됩니다. 이는 일반적으로 어려운 일이지만, Actor System 을 이용하면 atomic 연산 unit 인 Actor 를 기반으로 디자인할 수 있으므로 부가적인 계층(Tier) 보다는 로직(이 메시지를 받았을 때 어떤 일을 해야하는가)에 더 집중하게 되어 쉬운 일이 됩니다. </p>

<p>Akka 프로젝트 설명에서도 볼 수 있듯이, 분산 병렬 시스템을 만드는 것은 어려운 일이지만 대부분의 경우는 잘못된 추상(Abstaction), 도구(Tool) 을 이용하기 때문입니다. Actor Model 은 프로그래머가 더 쉬운 방법으로 분산 병렬 시스템을 디자인할 수 있도록 돕습니다.</p>

<blockquote>
  <p>We believe that writing correct concurrent &amp; distributed, resilient and elastic applications is too hard. Most of the time it's because we are using the wrong tools and the wrong level of abstraction.</p>
  
  <p>Akka is here to change that.</p>
  
  <p>Using the Actor Model we raise the abstraction level and provide a better platform to build correct concurrent and scalable applications. </p>
</blockquote>

<p><br></p>

<h2 id="nondeterminism">Non-determinism</h2>

<p>Actor Model 이 비결정적이라는 비판들이 있습니다. 그러나 실제로 내부를 잘 살펴보면 Actor 그 자체는 <em>deterministic atomic unit</em> 입니다. 따라서 시스템을 Reactive 하게 구성하는 과정에서 프로그래머가 다루어야 하는 <em>non-determinism</em> 을 Actor Model 을 이용하면 더 간단하게 다룰 수 있습니다.</p>

<p><br></p>

<h2 id="references">References</h2>

<ul>
<li>Title Image - <a href="http://berb.github.io/">http://berb.github.io/</a></li>
<li>Book - <a href="http://www.amazon.com/Reactive-Messaging-Patterns-Actor-Model/dp/0133846830/ref=sr_1_2?ie=UTF8&amp;qid=1442747296&amp;sr=8-2&amp;keywords=akka+in+action">Reactive Message Patterns with the Actor Model</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Angular, Providers]]></title><description><![CDATA[<p><img src="https://ga-core.s3.amazonaws.com/production/uploads/program/default_image/1444/Angularjs-Bootcamp-LONDON.jpg" alt=""></p>

<p>자그마한 프로젝트를 엇그제 시작했습니다. 오늘 해야 할 일은 Linkedin, Github API 를 붙이는 일인데, 그 전에 Angular 를 좀 보고 넘어가겠습니다. 아래는 <a href="https://github.com/DaftMonk/generator-angular-fullstack">angular-fullstack</a> 으로 만들면 생성되는 템플릿 코드인데, 어디서 부터 시작해야할지 감이 안잡히네요!</p>

<pre><code class="javascript">angular.module('app', [  
  'ngCookies',
  'ngResource',
  'ngSanitize',
  'ui.router',
  'ui.bootstrap'
])
  .config(function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider) {
    $urlRouterProvider</code></pre>]]></description><link>http://1ambda.github.io/angular-providers/</link><guid isPermaLink="false">fac918aa-4bc5-464c-ba73-2d2fad7e6a9d</guid><category><![CDATA[Angular]]></category><category><![CDATA[Trend Factory]]></category><category><![CDATA[factory]]></category><category><![CDATA[service]]></category><category><![CDATA[provider]]></category><category><![CDATA[injector]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 14 Mar 2015 16:42:33 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://ga-core.s3.amazonaws.com/production/uploads/program/default_image/1444/Angularjs-Bootcamp-LONDON.jpg" alt=""></p>

<p>자그마한 프로젝트를 엇그제 시작했습니다. 오늘 해야 할 일은 Linkedin, Github API 를 붙이는 일인데, 그 전에 Angular 를 좀 보고 넘어가겠습니다. 아래는 <a href="https://github.com/DaftMonk/generator-angular-fullstack">angular-fullstack</a> 으로 만들면 생성되는 템플릿 코드인데, 어디서 부터 시작해야할지 감이 안잡히네요!</p>

<pre><code class="javascript">angular.module('app', [  
  'ngCookies',
  'ngResource',
  'ngSanitize',
  'ui.router',
  'ui.bootstrap'
])
  .config(function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider) {
    $urlRouterProvider
      .otherwise('/');

    $locationProvider.html5Mode(true);
    $httpProvider.interceptors.push('authInterceptor');
  })

  .factory('authInterceptor', function ($rootScope, $q, $cookieStore, $location) {
    return {
      // Add authorization token to headers
      request: function (config) {
        config.headers = config.headers || {};
        if ($cookieStore.get('token')) {
          config.headers.Authorization = 'Bearer ' + $cookieStore.get('token');
        }
        return config;
      },

      // Intercept 401s and redirect you to login
      responseError: function(response) {
        if(response.status === 401) {
          $location.path('/login');
          // remove any stale tokens
          $cookieStore.remove('token');
          return $q.reject(response);
        }
        else {
          return $q.reject(response);
        }
      }
    };
  })

  .run(function ($rootScope, $location, Auth) {
    // Redirect to login if route requires auth and you're not logged in
    $rootScope.$on('$stateChangeStart', function (event, next) {
      Auth.isLoggedInAsync(function(loggedIn) {
        if (next.authenticate &amp;&amp; !loggedIn) {
          $location.path('/login');
        }
      });
    });
  });
</code></pre>

<h3 id="configrun">config, run</h3>

<p>원문은 <a href="https://docs.angularjs.org/guide/module#module-loading-dependencies">Angular Document: Module Loading &amp; Dependencies</a></p>

<p><em>configuration</em> 과 <em>run block</em> 은 <em>bootstrap</em> 과정에서 실행되는데</p>

<ul>
<li><em>configuration block</em> 에서는 <strong>provider</strong>, <strong>constant</strong> 만 <em>injected</em> 될 수 있고</li>
<li><em>run block</em> 은 <em>injector</em> 가 생성되고, 어플리케이션을 구동하기 위해 사용된 후에 실행됩니다. <strong>instance</strong> 와 <strong>constant</strong> 만 <em>injected</em> 될 수 있습니다.</li>
</ul>

<pre><code class="javascript">angular.module('myModule', []).

  config(function(injectable) { // provider-injector
    // you can only inject Providers (not instances)
    // into config block
  }).

  run(function(injectable) {    // instance-injector
    // you can only inject instances (not Providers)
    // into run blocks
  });
</code></pre>

<p>아래는 동일한 코드를 다른 메소드를 이용해 작성한 애플리케이션 초기화 코드입니다.</p>

<pre><code class="javascript">angular.module('myModule', []).  
  value('a', 123).
  factory('a', function() { return 123; }).
  directive('directiveName', ...).
  filter('filterName', ...);

// is same as

angular.module('myModule', []).  
  config(function($provide, $compileProvider, $filterProvider) {
    $provide.value('a', 123);
    $provide.factory('a', function() { retrun 123; });
    $compileProvider.directive('directiveName', ...);
    $filterProvider.register('filterName', ...);
  });  
</code></pre>

<p>배운것보다 모르는게 더 많이 생겼습니다. <code>Provider</code>, <code>$provide</code>, <em>injectable</em>  이 뭘까요?</p>

<p><br></p>

<h3 id="providers">Providers</h3>

<p>원문은 <a href="https://docs.angularjs.org/guide/providers">Angular Document: Providers</a></p>

<p><em>angular app</em> 에서 쓰이는 오브젝트들은 <a href="https://docs.angularjs.org/api/auto/service/$injector"><em>intector service</em></a> 에 의해서 인스턴스화(<em>instantiated</em>) 됩니다. <em>injector</em> 는 두 타입의 오브젝트를 만드는데, </p>

<p>(1) <strong>Services:</strong> are objects whose API is defined by the developer writing the service <br>
(2) <strong>Specialized objects:</strong> conform to a specific angular framework API. These objects are one of controllers, directives, filters or animations</p>

<p><em>injector</em> 가 이러한 서비스를 만들기 위해서는 <em>recipe</em> 를 알려줘야 하는데, 크게 5가지 <em>recipe</em> 가 있습니다. </p>

<p>가장 유명한건 <strong>Provider</strong> 입니다. 그 외에 <em>Provider</em> 를 이용해 만든 <strong>Value</strong>, <strong>Factory</strong>, <strong>Service</strong>, <strong>Constant</strong> 가 있습니다. </p>

<p><em>angular module</em> 은 하나 이상의 <em>Provider</em> 를 포함할 수 있습니다. 애플리케이션이 시작될때 <em>Angular</em> 는 <em>injector</em> 의 새로운 인스턴스를 만들고, <code>ng</code> 모듈, 애플리케이션 모듈, 그리고 그 <em>dependencies</em> 에 있는 모든 <em>recipe</em> 를 하나의 레지스트리에 등록합니다. 그리고 이후에 필요할때마다 <em>injector</em> 는 이 레지스트리에 새로운 인스턴스를 만들어야 할지, 아니면 존재하는 것을 사용할지 질의합니다.</p>

<p><em>Value recipe</em> 를 이용한 간단한 <a href="https://docs.angularjs.org/guide/providers#value-recipe">예제</a> 를 보겠습니다.</p>

<pre><code class="javascript">var myApp = angular.module('myApp', []).  
              value('clientId', 'a12345654321x');

myApp.controller('myController', ['clientId',  
                                  function(clientId) {
  this.clientId = clientId;
}]);                              
</code></pre>

<p><code>myApp</code> 모듈에 정의되어 있는 <code>clientId</code> <em>Value recipe</em> 를 등록하고 컨트롤러에서 사용했습니다.</p>

<p><br></p>

<h3 id="factory">Factory</h3>

<pre><code class="javascript">myApp.factory('apiToken', ['clientId', function apiTokenFactory(clientId) {

  var encrypt = function(data1, data2) {
  // encryption algorithm:
    return (data + ':' + data2).toUpperCase();
  };

  var secret = window.localStorage.getItem('myApp.secret');
  var apiToken = encrypt(clientId, secret);

  return apiToken;
}]);
</code></pre>

<p><em>Factory recipe</em> 를 이용해서 <code>apiToken</code> 서비스를 정의했습니다. 이 서비스는 <em>Value recipe</em> 를 이용해 만든 <code>clientId</code> 서비스에 의존합니다.</p>

<p><br></p>

<h3 id="service">Service</h3>

<p><code>apiToken</code> 서비스를 이용하는 다른 서비스를 <em>Service recipe</em> 를 이용해서 만들어 볼텐데, 동시에 <em>Service recipe</em> 가 어떤 역할을 하는지 비교하기 위해 <em>Factory recipe</em> 로도 만들어 보겠습니다.</p>

<pre><code class="javascript">function UnicornLauncher(apiToken) {

  this.launchedCount = 0;
  this.launch = function() {
    // Make a request to the remote API and include the apiToken
    ...
    this.launchedCount++;
  }
}

myApp.factory('unicornLauncher', ["apiToken", function(apiToken) {  
  return new UnicornLauncher(apiToken);
}]);

// is same as
myApp.service('unicornLauncher', ["apiToken", UnicornLauncher]);  
</code></pre>

<p><em>Factory recipe</em> 로도 만들 수 있지만, 일반적으로 <em>Service recipe</em> 는 <code>new</code> 와 함께 호출되는 서비스를 정의하기 위해 사용합니다. <a href="http://stackoverflow.com/questions/14324451/angular-service-vs-angular-factory">Stackoverflow: Factory vs Service</a> 에서도 그 답변을 찾을 수 있습니다.</p>

<p>예를 들어서 위에서 우리가 정의한 <code>unicornLauncher</code> 서비스는, <code>UnicornLauncher</code> 생성자를 <code>new</code> 로 호출됩니다.</p>

<p><br></p>

<p>아래는 대략적인 두 함수의 구성입니다.</p>

<pre><code class="javascript">function factory(name, factoryFn) {  
    return provider(name, { $get: factoryFn }); 
}

function service(name, constructor) {  
    return factory(name, ['$injector', function($injector) {
      return $injector.instantiate(constructor);
    }]);
}
</code></pre>

<p><code>$injector</code> 는 <em>provider</em> 에 의해 정의된 인스턴스를 <em>angular app</em> 내에서 조회하고, 생성할 수 있습니다. 이외에도 메소드를 호출하거나, 모듈을 로드할 수 있습니다.</p>

<p><br></p>

<h3 id="provider">Provider</h3>

<p><em>Provider recipe</em> 는 <em>Service</em> 나 <em>Factory</em> 등 다른 <em>recipe</em> 를 구성하는 코어 컴포넌트입니다. 문법적으로는 <code>$get</code> 을 구현한 커스텀 타입입니다. 이 <code>$get</code> 메소드는 <em>Factory recipe</em> 에서 사용했던 것과 같은 <em>factory function</em> 입니다. </p>

<p>다시 말해서, <em>Factory recipe</em> 만들때 하는 일은 <em>empty Provider</em> 에 <code>$get</code> 을 이용해 정의된 <em>factory function</em> 을 가져오는 일입니다.</p>

<p><em>Provider recipe</em>  는 반드시 애플리케이션이 시작 되기 전에 생성되야 하는 <em>application-wide configuration</em> 을 위한 <em>API</em> 를 정의할때만 사용해야 합니다.</p>

<pre><code class="javascript">myApp.provider('unicornLauncher', funtion UnicornLauncherProvider() {  
  var useTinfoilShielding = false;

  this.useTinfoilShielding = function(vaue) {
    useTinfoilShielding = !!value;
  };

  this.$get = ["apiToken", function unicornLauncherFactory(apiToken) {
    return new UnicornLauncher(apiToken, useTinfoilShielding);
  }];
});

myApp.config(["unicornLauncherProvider", function(unicornLauncherProvider) {  
  unicornLauncherProvider.useTinfoilShielding(true);
}]);
</code></pre>

<p>처음에 <em>configuration block</em> <code>config</code> 를 언급하면서 <strong>provider</strong>, <strong>constant</strong> 만 <em>injected</em> 될 수 있다고 말했었는데, 이런 이유에서입니다.</p>

<p><em>regular instance injector</em> 와는 달리 <em>provider injector</em> 에 의해 실행되는 이런 <em>injection</em> 을 통해 모든 <em>provider</em> 가 인스턴스화 (<em>instantiated</em>) 됩니다.</p>

<p><em>angular</em> 애플리케이션이 부트스트랩되는 동안, <em>provider</em> 가 구성되고, 생성되는 동안에는 <em>service</em> 에 접근할 수 없습니다. 이는 <em>service</em> 가 아직 생성되지 않았기 때문입니다.</p>

<p><em>configuration phase</em> 가 지난 후에야 <em>services</em> 가 생성되고, 이 단계를 <em>run phase</em> 라 부릅니다. 이 때문에 <em>run block</em> 에서 <strong>instance</strong> 와 <strong>constant</strong> 만 <em>injected</em> 될 수 있다고 위에서 언급한 것입니다.</p>

<p><br></p>

<h3 id="specialpurposeobjects">Special Purpose Objects</h3>

<p>앞서 <em>Angular</em> 에서 쓰이는 모든 오브젝트는 <em>intector service</em> <code>$injector</code>  에 의해서 초기화 된다고 했었습니다. 일반적인 서비스 오브젝트와, 특별한 목적을 가진 오브젝트들이 있다고 언급하기도 했지요.</p>

<p>이런 특별한 오브젝트들은 프레임워크를 확장하는 플러그인으로서 <em>Angular</em> 에서 정의한 <em>interface</em> 를 구현해야 하는데, 이 인터페이스는 <code>Controller</code>, <code>Directive</code>, <code>Filter</code>, <code>Animation</code> 입니다. </p>

<p><code>Controller</code> 오브젝트를 제외하고는 이러한 <em>special object</em> 를 생성하기 위해 <em>injector</em> 는 <em>Factory recipe</em> 를 이용합니다. 따라서 인자로 넣어준 팩토리 함수가 디렉티브를 만들기 위해 호출됩니다.</p>

<pre><code class="javascript">myApp.directive('myPlanet', ['planetName', function myPlanetDirectiveFactory(planetName) {  
  // directive definition object
  return {
    restrict: 'E',
    scope: {},
    link: function($scope, $element) { $element.text('Planet: ' + planetName); }
  }
}]);
</code></pre>

<p><br></p>

<h3 id="controller">Controller</h3>

<pre><code class="javascript">myApp.controller('DemoController', ['clientId', function DemoController(clientId) {  
  this.clientId = clientId;
}]);
</code></pre>

<p><code>Controller</code> 는 조금 다르게, <em>Factory recipe</em> 를 이용하지 않습니다. 인자로 정의한 <em>constructor function</em> 함수가 <strong>모듈과 함께 등록</strong>됩니다. </p>

<p>애플리케이션이 <code>DemoController</code> 가 필요할때마다 매번 <em>constructor</em> 를 통해서 인스턴스화(<em>instantiated</em>) 합니다. 일반적인 <em>service</em> 와는 다르게, <strong>컨트롤러는 싱글턴이 아닙니다</strong>. </p>

<p>지금까지 배운 내용을 정리하면</p>

<ul>
<li>The injector uses recipes to create two type of objects: <strong>services</strong> and <strong>special purpose objects</strong></li>
<li>There are five recipe types that define how to create objects: <strong>Value</strong>, <strong>Factory</strong>, <strong>Service</strong>, <strong>Provide</strong>, and <strong>Constant</strong></li>
<li>Factory and Service are the most commonly used recipes. The only differences between them is that the <em>Service recipe</em> works better <strong>for objects of a custom type</strong>, while the <em>Factory</em> can produce <strong>primitives and functions</strong></li>
<li>The <em>Provider recipe</em> is the core recipe type and all the other ones are just syntactic sugar on it</li>
<li><em>Provider</em> is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration</li>
<li>All special purpose objects except for the <strong>Controller</strong> are defined via <em>Factory recipes</em></li>
</ul>

<p><br></p>

<h3 id="dependencyinjection">Dependency Injection</h3>

<p><img src="https://docs.angularjs.org/img/guide/concepts-module-injector.png" alt=""></p>

<p><em>service</em> 는 <code>$injector</code> 에 의해서 싱글턴 인스턴스가 만들어지고, <code>$injector.get()</code> 을 통해 얻을 수 있습니다. 만약 캐시된 인스턴스가 있다면 가져오고 없으면 새로 만듭니다. 아래는 외부에서 <code>injector</code> 를 통해 내부 서비스를 접근하는 방법입니다.</p>

<pre><code class="javascript">var injector = angular.injector(['myModule', 'ng']);  
var greeter = injector.get('greeter');  
</code></pre>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) [http://galleryhip.com/angular-js-icon.html) <br>
(2) <a href="https://docs.angularjs.org/guide/providers#value-recipe">Angular Document</a> <br>
(3) <a href="http://www.webdeveasy.com/javascript-promises-and-angularjs-q-service/">Webdeveasy: AngularJS Q</a> <br>
(4) <a href="http://www.webdeveasy.com/interceptors-in-angularjs-and-useful-examples/">Webdeveasy: AngularJS Interceptor</a>  </p>]]></content:encoded></item><item><title><![CDATA[Coding The Matrix 3]]></title><description><![CDATA[<p><img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/column_row_space.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_as_vector.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_impl.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/null_space_of_matrix.jpg" alt=""></p>

<p>Null space of a matrix is a vector space</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/vector_space.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions_proof.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/use_standard_generator.jpg" alt=""></p>

<p><em>standard geneartor</em> 를 이용해서 <code>f(x) = M * x</code> 에서의 <code>M</code> 의 컬럼을 알아낼 수 있다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_function_def.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_def_2.jpg" alt=""></p>

<p>어떤 함수 <code>f</code> 가 <code>M * x</code> 형태로 정의되면, <code>f</code> 는 <em>linear function</em> 이다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/def_kernel.jpg" alt=""></p>

<p>어떤 함수 <code>f</code> 의 <em>kernel</em> 은 <em>image</em> 를 <code>0</code> 으로 하는 집합이다. 다시</p>]]></description><link>http://1ambda.github.io/coding-the-matrix-3/</link><guid isPermaLink="false">715b3e8b-1821-4204-98cf-48f2a029e11b</guid><category><![CDATA[coursera]]></category><category><![CDATA[linear algebra]]></category><category><![CDATA[matrix]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 14 Mar 2015 16:41:34 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/column_row_space.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_as_vector.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_impl.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/null_space_of_matrix.jpg" alt=""></p>

<p>Null space of a matrix is a vector space</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/vector_space.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions_proof.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/use_standard_generator.jpg" alt=""></p>

<p><em>standard geneartor</em> 를 이용해서 <code>f(x) = M * x</code> 에서의 <code>M</code> 의 컬럼을 알아낼 수 있다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_function_def.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_def_2.jpg" alt=""></p>

<p>어떤 함수 <code>f</code> 가 <code>M * x</code> 형태로 정의되면, <code>f</code> 는 <em>linear function</em> 이다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/def_kernel.jpg" alt=""></p>

<p>어떤 함수 <code>f</code> 의 <em>kernel</em> 은 <em>image</em> 를 <code>0</code> 으로 하는 집합이다. 다시 말해서 <code>f(x) = M * x</code> 에 대해 <em>null matrix</em> <code>x</code> 이 <em>kernel</em></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/kernel_one_to_one1.jpg" alt=""></p>

<p><em>linear function</em> <code>f</code> is <strong>one-to-one</strong> iff its kernel is a <em>trivial vector space</em></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/kernel_one_to_one2.jpg" alt=""></p>

<p>위에 나온 속성은 상당히 중요하다. 왜냐하면 <em>trivial kernel</em> 이면, 다시 말해서 <em>null matrix</em> 가 <em>trivial</em> 이면, <code>f</code> 의 <em>image</em> <code>b</code> 는 아무리 많아봐야 하나이기 때문이다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/def_onto.jpg" alt=""></p>

<p><em>image</em> 가 <em>entire co-domain</em> 과 같으면 <strong>onto</strong> 다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/inner_product.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/outer_product.jpg" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/function_composition.jpg" alt=""></p>

<p>두 <em>matrix-vector function</em> 의 <em>composition</em> 은 위처럼 쉽게 증명 가능하다. <code>AB * x</code> 로</p>

<p>이걸 이용하면 <em>matrix-matrix multiplication</em> 의 <em>associativity</em> 도 쉽게 증명 가능하다. <code>(AB)C = A(BC)</code></p>

<p><br></p>

<h3 id="invertible">Invertible</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible2.jpg" alt=""></p>

<p>두 함수가 <em>inverse</em> 관계면 두 매트릭스도 <em>inverse</em> 관계다. 그리고 한 매트릭스의 <em>inverse matrix</em> 가 존재하면 <em>invertible</em> 또는 <em>singular</em> 라 부르며, 아무리 많아봐야 하나의 <em>inverse</em> 만 가진다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way2.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way3.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way4.jpg" alt=""></p>

<p><em>invertible matrix</em> 가 중요한 이유는, <em>invertible matrix</em> 가 존재하면 <code>f</code> 도 <em>invertible</em> 이고, 그 말은 <code>f</code> 가 <strong>one-to-one, onto</strong> 라는 소리다. 따라서 <code>f(u) = b</code> 에 대해 적어도 하나의 솔루션이 존재하고 (<em>onto</em>), 아무리 많아봐야 하나의 솔루션이 존재한다는 뜻이다 (<em>one-to-one</em>)</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_product_matrix1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_product_matrix2.jpg" alt=""></p>

<p>함수처럼 매트릭스도 <code>A</code>, <code>B</code> 가 <em>invertible</em> 일때만 <code>AB</code> 도 그러하다. </p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/identity_invertible1.jpg" alt=""></p>

<p><code>AB</code> 에 대해 <code>A</code>, <code>B</code> 가 서로의 <em>inverse</em> 면 <code>AB</code> 는 <em>identity matrix</em> 지만 그 역은 성립하지 않는다.</p>

<p>위 그림의 <code>A</code> 에서 볼 수 있듯이 <em>null space</em> 가 <em>trivial</em> 하지 않기 때문에 <em>one to one</em> 이 아니어서 <code>A</code> 는 <em>invertible</em> 이 아니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/identity_invertible2.jpg" alt=""></p>

<p><code>AB</code>, <code>BA</code> 가 모두 <em>identity matrix</em> 여야 <code>A</code>, <code>B</code> 가 서로 <em>inverse</em> 다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/identity_invertible3.jpg" alt=""></p>

<p>매트릭스 <code>M</code> 이 <em>one-to-one</em> 인지는 <em>trivial kernel</em> 인지를 판별하면 된다. <code>f(x) = M * x</code> 는 <em>linear function</em> 이기 때문에 <em>trivial kernel</em> 이면 <code>M</code> 도 <em>one-to-one</em> 이다.</p>

<p><em>onto</em> 인지는 어떻게 알 수 있을까?</p>

<p><br></p>

<h3 id="summary">Summary</h3>

<p>지금 까지의 내용을 정리하면</p>

<ol>
<li><code>u1</code> 이 <code>a * x = b</code> 의 솔루션일때, <code>V</code> 를 <code>a * x = 0</code> 의 솔루션 셋이라 하면, <code>u1 + V</code> 는 <code>a * x = b</code> 의 솔루션 셋이다. 다시 말해서 <code>V</code> 는 <em>null matrix</em>  </li>
<li><code>f(x)</code> 가 <code>M * x</code> 형태로 나타낼 수 있으면 <em>linear function</em> 이다.  </li>
<li><em>trivial kernel</em> 이면 <em>linear function</em> <code>f</code> 는 <em>one-to-one</em> 이고, <em>linear function</em> <code>f</code> 가 <em>one-to-one</em> 이면 <em>trivial kernel</em> 을 가진다.  </li>
</ol>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://colorsark.deviantart.com/art/3D-Cube-342632998">Title image</a> <br>
(2) <strong>Coding the Matrix</strong> by <em>Philip Klein</em>  </p>]]></content:encoded></item><item><title><![CDATA[Cloud Computing, Paxos]]></title><description><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>대부분의 분산 서버 벤더들은 <code>99.99999%</code> 의 <em>reliability</em> 를 보장하지만, <code>100%</code>는 아닙니다. 왜그럴까요? 그들이 못해서가 아니라 <em>consensus</em> 문제 때문입니다.</p>

<blockquote>
  <p>The fault lies in the impossibility of consensus</p>
</blockquote>

<p><em>Consensus</em> 문제가 중요한 이유는, 많은 분산 시스템이 <em>consensus</em> 문제이기 때문입니다. </p>

<ul>
<li>Perfect Failure Detection</li>
<li>Leader Election</li>
<li>Agreement (harder than consensus)</li>
</ul>

<p><br></p>

<p>일반적으로 서버가 많으면</p>]]></description><link>http://1ambda.github.io/cloud-computing-paxos/</link><guid isPermaLink="false">fa427789-33eb-4728-913a-ab4b1cfbf14e</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[paxos]]></category><category><![CDATA[consensus]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 07 Mar 2015 19:44:32 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>대부분의 분산 서버 벤더들은 <code>99.99999%</code> 의 <em>reliability</em> 를 보장하지만, <code>100%</code>는 아닙니다. 왜그럴까요? 그들이 못해서가 아니라 <em>consensus</em> 문제 때문입니다.</p>

<blockquote>
  <p>The fault lies in the impossibility of consensus</p>
</blockquote>

<p><em>Consensus</em> 문제가 중요한 이유는, 많은 분산 시스템이 <em>consensus</em> 문제이기 때문입니다. </p>

<ul>
<li>Perfect Failure Detection</li>
<li>Leader Election</li>
<li>Agreement (harder than consensus)</li>
</ul>

<p><br></p>

<p>일반적으로 서버가 많으면 다음의 일들을 해야합니다.</p>

<ul>
<li><strong>Reliable Multicast:</strong> Make sure that all of them receive the same updates in the same order as each other</li>
<li><strong>Membership/Failure Detection:</strong> To keep their own local lists where they know about each other, and when anyone leaves or fails, everyone is updated simultaneously</li>
<li><strong>Leader Election:</strong> Elect a leader among them, and let everyone in the group know about it</li>
<li><strong>Mutual Exclusion:</strong> To ensure mutually exclusive access to a critical resource like a file</li>
</ul>

<p>이 문제들은 대부분 <em>consensus</em> 와 연관되어 있습니다. 더 직접적으로 연관되어 있는 문제들은</p>

<ul>
<li>The ordering of messages</li>
<li>The up/down status of a suspected failed process</li>
<li>Who the leader is</li>
<li>Who has access to the critical resource</li>
</ul>

<p><br></p>

<h3 id="consensusproblem">Consensus Problem</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_problem.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_problem2.png" alt=""></p>

<p>모든 프로세스(노드, 서버)가 같은 <em>value</em> 를 만들도록 해야 하는데, 몇 가지 제약조건이 있습니다.</p>

<ul>
<li><strong>validity:</strong> if everyone propose same value, then that's what's decided</li>
<li><strong>integrity:</strong> decided value must have been proposed by some process</li>
<li><strong>non-triviality:</strong> there is at least one initial system state that leads to each of the all-<code>0</code>'s or all-<code>1</code>'s outcomes</li>
</ul>

<p><em>non-triviality</em> 는 쉽게 말해서, 모두 <code>0</code> 이거나 모두 <code>1</code> 일 수 있는 상태가 있어야 한다는 뜻입니다. 왜냐하면 항상 <code>0</code> 이거나 <code>1</code> 만 나오면 <em>trivial</em> 하기 때문입니다. 별 의미가 없죠.</p>

<p><br></p>

<h3 id="models">Models</h3>

<p><em>consensus</em> 문제는 분산 시스템 모델에 따라 달라집니다. 모델은 크게 2가지로 나눌 수 있는데</p>

<p>(1) Synchronous Distributed System Model</p>

<ul>
<li>Each message is received within bounded time</li>
<li>Drift of each process' local clock has a known bound</li>
<li>Each step in a process takes <code>lb &lt; time &lt; ub</code></li>
</ul>

<p>동기 시스템 모델에서는 <em>consensus</em> 문제를 풀 수 있습니다.</p>

<p>(2) Asynchronous Distributed System Model</p>

<ul>
<li>Nobounds on process execution</li>
<li>The drift rate of a clock is arbitrary</li>
<li>No bounds on message transmission delay</li>
</ul>

<p>일반적으로 비동기 분산 시스템 모델이 더 일반적입니다, 그리고 더 어렵죠. 비동기를 위한 프로토콜은 동기 모델 위에서 작동할 수도 있으나, 그 역은 잘 성립하지 않습니다.</p>

<p>비동기 분산 시스템 모델에서는 <em>consensus</em> 문제는 풀 수 <strong>없습니다</strong></p>

<ul>
<li>Whatever protocol/algorithm you suggest, there is always a worst-case possible execution with failures and message delays that prevens the system from reaching consensus</li>
<li>Powerful result(see the <strong>FLP</strong> proof)</li>
<li>Subsequently, safe and <strong>probabilistic</strong> solution have become popular (e.g Paxos)</li>
</ul>

<p><br></p>

<h3 id="paxosinsyncronoussystems">Paxos in Syncronous Systems</h3>

<p>동기 시스템이라 가정합니다. 따라서</p>

<ul>
<li>bounds on message dealy</li>
<li>bounds on upper bound on clock drift rates</li>
<li>bounds on max time for each process step</li>
<li>processes can fail by stopping</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_in_sync_system.png" alt=""></p>

<ul>
<li>아무리 많아야 <code>f</code> 개의 프로세서에서 <em>crash</em> 가 나고</li>
<li>모든 프로세서는 <em>round</em> 단위로 동기화 되고, 동작하며</li>
<li><em>reliable communication</em> 을 통해 서로 통신합니다</li>
</ul>

<p><em>value_i^r</em> 을 <em>round</em> <code>r</code> 의 시작에 <code>P_i</code> 에게 알려진 <em>value</em> 의 집합이라 라 하겠습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos2.png" alt=""></p>

<p><code>f+1</code> 라운드 후에 모든 <em>correct</em> 프로세스는 같은 값의 집합을 가지게 되는데, 귀류법으로 쉽게 증명할 수 있습니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_in_async.png" alt=""></p>

<p>비동기 환경에서는, 아주아주아주아주아주 느린 프로세서와 <em>failed</em> 프로세서를 구분할 수 없기 때문에, 나머지 프로세서들이 이것을 결정하기 위해 영원히 기다려야 할지도 모릅니다. 이것이 기본적인 <em>FLP Proof</em> 의 아이디어입니다. 그렇다면, <em>consensus</em> 문제를 정말 풀기는 불가능한걸까요?</p>

<p>풀 수 있습니다. 널리 알려진 <em>consensus-solving</em> 알고리즘이 있습니다. 실제로는 불가능한 <em>consensus</em> 문제를 풀려는 것이 아니라, <em>safety</em> 와 <em>eventual liveness</em> 를 제공합니다. 야후의 <em>zookeeper</em> 나 구글의 <em>chubby</em> 등이 이 알고리즘을 이용합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/yes_we_can_with_paxos.png" alt=""></p>

<p><em>safety</em> 는 서로 다른 두개의 프로세서가 다른 값을 제출하지 않는것을 보장하고, (<em>No two non-faulty processes decide different values</em>) <em>eventual liveness</em> 는 운이 좋다면 언젠가는 합의에 도달한다는 것을 말합니다. 근데 실제로는 꽤 빨리 <em>consensus</em> 문제를 풀 수 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos_simple.png" alt=""></p>

<p>본래는 최적화때문에 더 복잡한데, 위 슬라이드에서는 간략화된 <em>paxos</em> 가 나와있습니다. <em>paxos</em> 의 <em>round</em> 마다 고유한 <em>ballot id</em> 가 할당되고, 각 <em>round</em> 는 크게 3개의 비동기적인 <em>phase</em> 로 분류할 수 있습니다.</p>

<ul>
<li><strong>election:</strong> a leader is elected</li>
<li><strong>bill:</strong> leader proposes a value, processes ack</li>
<li><strong>law:</strong> leader multicasts final value</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/election.png" alt=""></p>

<p>먼저 <em>potential leader</em> 가 <em>unique ballot id</em> 를 고르고, 다른 프로세서들에게 보냅니다. 다른 프로세스들의 반응에 의해서 선출될 수도 있고, 선출되지 않으면 새로운 라운드를 시작합니다. </p>

<ul>
<li>Because becoming a leader requires a majority of votes, and any two majorities intersect in at least one process, and each process can only vote once.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/bill.png" alt=""></p>

<p>리더가 다른 프로세스들에게 <code>v</code> 를 제안하고, 프로세스들은 지난 라운드에 <code>v'</code> 를 결정했었으면 <code>v=v'</code> 를 이용해 값을 결정합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/decision.png" alt=""></p>

<p>만약 리더가 <em>majority</em> 의 긍정적인 반응을 얻으면 모두에게 그 결정을 알리고 각 프로세서는 합의된 내용을 전달받고, 로그에 기록하게 됩니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos_no_return.png" alt=""></p>

<p>사실 이 과정은 응답을 리더가 받는 단계에서 결정되는 것이 아니라, 프로세서들이 <em>proposed value</em> 를 듣는순간 결정됩니다. 따라서 리더에서 <em>failure</em> 가 일어나도, 이전에 결정되었던 <code>v'</code> 을 이용할 수 있습니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos_safety.png" alt=""></p>

<p>이전에도 언급했듯이 <em>safety</em> 는 두개의 서로 다른 프로세서의 의해서 다른 값이 선택되지 않음을 보장합니다. 이는 잠재적 리더가 있다 하더라도 현재 리더와, 잠재적 리더에게 응답하는 <em>majority</em> (반수 이상) 을 교차하면 적어도 하나는 <code>v'</code> 를 응답하기 때문에 <em>bill phase</em> 에서 정의한대로 이전 결과인 <code>v'</code> 가 사용됩니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxsos_liveness.png" alt=""></p>

<p>그림에서 볼 수 있듯이 영원히 끝나지 않을수도 있지만, 실제로는 꽤 빠른시간 내에 합의에 도달합니다. (eventualy-live in async systems)</p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://ook.co/solutions/cloud-computing/">Title Image</a> <br>
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></content:encoded></item><item><title><![CDATA[Cloud Computing, Multicast]]></title><description><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p><em>multicast</em> 는 클라우드 시스템에서 많이 사용됩니다. <em>Cassandra</em> 같은 분산 스토리지에서는 <em>write/read</em> 메세지를 <em>replica gorup</em> 으로 보내기도 하고, <em>membership</em> 을 관리하기 위해서 사용하기도 합니다</p>

<p>그런데, 이 <em>multicast</em> 는 <em>ordering</em> 에 따라서 <em>correctness</em> 에 영향을 줄 수 있기 때문에 매우 중요합니다. 자주 쓰이는 기법으로 <em>FIFO</em>, <em>Casual</em>, <em>Total</em> 이 있는데 하나씩 살펴보겠습니다.</p>]]></description><link>http://1ambda.github.io/cloud-computing-multicast/</link><guid isPermaLink="false">1aa1fadb-da2f-4163-af61-a68ed5cef2ac</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[multicast]]></category><category><![CDATA[virtual synchrony]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 07 Mar 2015 17:20:18 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p><em>multicast</em> 는 클라우드 시스템에서 많이 사용됩니다. <em>Cassandra</em> 같은 분산 스토리지에서는 <em>write/read</em> 메세지를 <em>replica gorup</em> 으로 보내기도 하고, <em>membership</em> 을 관리하기 위해서 사용하기도 합니다</p>

<p>그런데, 이 <em>multicast</em> 는 <em>ordering</em> 에 따라서 <em>correctness</em> 에 영향을 줄 수 있기 때문에 매우 중요합니다. 자주 쓰이는 기법으로 <em>FIFO</em>, <em>Casual</em>, <em>Total</em> 이 있는데 하나씩 살펴보겠습니다.</p>

<p><br></p>

<h3 id="ordering">Ordering</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_FIFO.png" alt=""></p>

<p><em>FIFO</em> 를 이용한다면, 보낸 순서대로 도착하게 됩니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_casual.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_casual_example.png" alt=""></p>

<p><em>casual ordering</em> 에서는 반드시 <em>casuality-obeying order</em> 로 전달해야 합니다. 예를 들어 위 그림에서는 <code>M1:1 -&gt; M3:1</code> 이기 때문에 반드시 그 순서대로 받아야 합니다. <em>concurrent event</em> 는 어떤 순서로 받아도 상관 없습니다.</p>

<p><br></p>

<p><em>casual ordering</em> 이면 <em>FIFO ordering</em> 입니다. 왜냐하면 같은 프로세스에서 보낸 <em>casuality</em> 를 따르면 그게 바로 <em>FIFO</em> 이기 때문입니다. 역은 성립하지 않습니다.</p>

<p>일반적으로는 <em>casual ordering</em> 을 사용합니다. 서로 다른 친구로부터 댓글이 달렸는데, 늦게 달린 친구의 댓글이 먼저 보인다면 당연히 말이 되지 않습니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_total.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_total_example.png" alt=""></p>

<p><em>total ordering</em> 은 <em>atomic broadcast</em> 라 부르는데, 모든 프로세스가 같은 순서로 메시지를 받는것을 보장합니다.</p>

<ul>
<li>Since <em>FIFO/Casual</em> are orthogonal to <em>Total</em>, can have hybrid ordering protocol too (e.g <em>FIFO-total</em>, <em>Casual-total</em></li>
</ul>

<p><br></p>

<h3 id="fifoorderingimpl">FIFO Ordering Impl</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl2.png" alt=""></p>

<ul>
<li>각 프로세스는 <em>seq number</em> 로 구성된 벡터를 유지하고, </li>
<li>프로세스에서 메시지를 보낼때 마다 자신의 <em>seq number</em> 를 하나 증가 시켜서 보냅니다</li>
<li>메시지를 받았을때, <strong>자신의 벡터 내에 있는 값 + 1</strong> 일 경우에만 벡터 값을 +1 한뒤 전달하고, 아니면 +1 인 값이 올 때까지 버퍼에 넣고 기다립니다</li>
</ul>

<p>예제를 보면</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl_example.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl_example2.png" alt=""></p>

<p><br></p>

<h3 id="totalorderingimpl">Total Ordering Impl</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/total_impl1.png" alt=""></p>

<p><em>sequencer-based approach</em> 입니다. 먼저 하나의 프로세스가 <em>sequencer</em> 로 선출된 뒤, 어떤 프로세스가 메세지를 보낼때마다 그룹 뿐만 아니라 <em>sequencer</em> 에게 보내게 됩니다.</p>

<p>이 <em>sequencer</em> 는 글로벌 시퀀스 <code>S</code> 를 유지하면서, 메시지 <code>M</code> 을 받을때마다 <code>S++</code> 해서 <code>&lt;M, S&gt;</code> 로 멀티캐스트를 보냅니다.</p>

<p>각 프로세스에서는 <em>local</em> 에 글로벌 시퀀스 <code>Si</code> 를 유지합니다. 만약 프로세스가 메세지를 받는다면 <code>Si + 1 = S(M)</code> 값을 글로벌 시퀀서로부터 받을때까지 기다리고, 받은 후에야 <code>Si++</code> 하고 전달합니다.</p>

<p><br></p>

<h3 id="casualorderingimpl">Casual Ordering Impl</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl2.png" alt=""></p>

<p>자료구조 자체는 같으나, <em>casuality</em> 를 검사하기 위해 <em>sender</em> 가 <em>vector</em> 전체를 보냅니다. <em>receiver</em> 는 메세지를 받으면 다음 두 조건을 만족하기 전까지 버퍼에 넣습니다</p>

<ul>
<li><code>M[j]</code> = <code>P_i[j] + 1</code></li>
<li><code>M[k]</code> &lt;= <code>P_i[k]</code>, (<code>k != j</code>)</li>
</ul>

<p>두번째 조건을 해석하면, 자신의 벡터도 다음 프로세스에게 전달해야 하기 때문에 <code>M[k]</code> 이후의 벡터만 가지고 있어야 전달할 수 있다는 뜻입니다. (<code>M[j]</code> 는 제외)</p>

<p>이 두 조건이 만족되야만 <code>P_i[j] = M[j]</code> 로 세팅하고 <code>M</code> 을 전달합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl_example1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl_example2.png" alt=""></p>

<p><br></p>

<h3 id="reliablemulticast">Reliable Multicast</h3>

<p><em>reliable</em> 이란, 루즈하게 말하자면 모든 <em>receiver</em> 가 메세지를 받는다는 뜻입니다. <em>ordering</em> 과는 <em>orthogonal</em> 하기 때문에 <em>Reliable-FIFO</em>, 등등 구현이 가능합니다. 더 엄밀한 정의는</p>

<ul>
<li>need all <strong>correct</strong> (<em>non-faulty</em>) processes to receive the same set of multicasts as all other correct processes</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/reliable_multicast_impl1.png" alt=""></p>

<p>단순히 <em>reliable unicast</em> 를 여러개 보내는것 만으로는 부족합니다. 왜냐하면 <em>sender</em> 에서 <em>failure</em> 가 일어날 수 있기 때문입니다</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/reliable_multicast_impl2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/reliable_multicast_impl3.png" alt=""></p>

<p>비효율적이지만, <em>reliable</em> 합니다.</p>

<p><br></p>

<h3 id="virtualsynchrony">Virtual Synchrony</h3>

<p><em>virtual sinchrony</em> 혹은 <em>view synchrony</em> 라 불리는데, 이것은 <em>failure</em> 에도 불구하고 <em>multicast ordering</em> 과 <em>reliability</em> 를 얻기 위해 <em>membership protocol</em> 을 <em>multicast protocol</em> 과 같이 사용합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/view.png" alt=""></p>

<p>각 프로세스가 관리하는 <em>membership list</em> 를 <em>view</em> 라 부릅니다. <em>virtual synchrony</em> 프로토콜은 이런 <em>view change</em> 가 <em>correct process</em> 에 올바른 순서대로 전달됨을 보장합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/vsync_multicast.png" alt=""></p>

<p><em>Virtual Synchrony</em> 프로토콜은 다음을 보장합니다.</p>

<ul>
<li>the set of multicasts delivered in a given view is the same set at all correct processes that were in that view</li>
<li>the sender of the multicast message also belongs to that view</li>
<li>if a process <code>P_i</code> doesn't not deliver a multicast <code>M</code> in view <code>V</code> while other processes in the view <code>V</code> delivered <code>M</code> in <code>V</code>, then <code>P_i</code> will be <strong>forcibly removed</strong> from the next view delivered after <code>V</code> at the other processes</li>
</ul>

<p>다시 말해서, <em>multicast</em> 메세지는 같이 전달된 <em>view</em> 내에 있던 다른 프로세스에서 모두 동일합니다. 그리고 <em>view</em> <code>V</code> 내에 있는 어떤 프로세스가 <code>M</code> 을 전달하지 못할 경우, 다른 프로세스의 <em>next view</em> 에서 제거됩니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example3.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example4.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example5.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example6.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example7.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example8.png" alt=""></p>

<p><br></p>

<ul>
<li>Called <strong>"virtual synchrony"</strong> since in spite of running on an asynchronous network, it gives the appearance of a synchronous network underneath that obeys the same ordering at all processes</li>
</ul>

<p>그러나 <em>consensus</em> 를 구현하는데는 쓸 수 없습니다. <em>partitioning</em> 에 취약하기 때문입니다.</p>

<p>정리하자면 <em>multicast</em> 는 클라우드 시스템에서 중요한 요소입니다. 필요에 따라서 <em>ordering</em>, <em>reliability</em>, <em>virtual synchorny</em> 를 구현할 수 있습니다.</p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://ook.co/solutions/cloud-computing/">Title Image</a> <br>
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></content:encoded></item><item><title><![CDATA[Cloud Computing, Snapshots]]></title><description><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>이번시간에는 <em>Distributed Snapshot</em> 에 대해서 배웁니다. 클라우드 환경에서 각 어플리케이션(혹은 서비스) 는 여러개의 서버 위에서 돌아갑니다. 각 서버는 <em>concurrent events</em> 를 다루며, 서로 상호작용합니다. 이런 환경에서 <em>global snapshot</em> 을 캡쳐할 수 있다면</p>

<ul>
<li><strong>check pointing:</strong> can restart distributed application on failure</li>
<li><strong>garbage collection of objects:</strong> object at servers that don't</li></ul>]]></description><link>http://1ambda.github.io/cloud-computing-snapshot/</link><guid isPermaLink="false">7d51c274-e6e6-41dd-a37e-b548da6e711c</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[snapshot]]></category><category><![CDATA[Chandy-Lamport]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 07 Mar 2015 13:57:56 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>이번시간에는 <em>Distributed Snapshot</em> 에 대해서 배웁니다. 클라우드 환경에서 각 어플리케이션(혹은 서비스) 는 여러개의 서버 위에서 돌아갑니다. 각 서버는 <em>concurrent events</em> 를 다루며, 서로 상호작용합니다. 이런 환경에서 <em>global snapshot</em> 을 캡쳐할 수 있다면</p>

<ul>
<li><strong>check pointing:</strong> can restart distributed application on failure</li>
<li><strong>garbage collection of objects:</strong> object at servers that don't have any other objects(ay any servers) with pointers to them</li>
<li><strong>deadlock detection:</strong> useful in database transaction systems</li>
<li><strong>termination of computation:</strong> useful in batch computing systems like Folding@Homes, SETI@Home</li>
</ul>

<p><em>global snapshot</em> 은 두 가지를 포함합니다.</p>

<p>(1) Individual state of each process 
(2) Individual state of each communication channel </p>

<p><em>global snapshot</em> 을 만드는 한가지 방법은 모든 프로세스의 <em>clock</em> 을 동기화 하는 것입니다. 그래서 모든 프로세스에게 <em>time</em> <code>t</code> 에서의 자신의 상태를 기록하도록 요구할 수 있습니다. 그러나</p>

<ul>
<li>Time synchorization always has error</li>
<li>Doesn't not record the state of meesages in the channels</li>
</ul>

<p>지난 시간에 보았듯이, <em>synchronization</em> 이 아니라 <em>casuality</em> 로도 충분합니다. 프로세스가 <strong>명령을 실행하거나</strong>, <strong>메시지를 받거나</strong>, <strong>메시지를 보낼때마다</strong> <em>global system</em> 가 변합니다. 이를 저장하기 위해서 <em>casuality</em> 를 기록하는 방법을 알아보겠습니다.</p>

<p><br></p>

<h3 id="chandylamportalgorithm">Chandy-Lamport Algorithm</h3>

<p>시작 전에 <em>system model</em> 을 정의하면</p>

<ul>
<li>N Processes in the system</li>
<li>There are two uni-directional communication channels between each ordered process pair <code>P_j -&gt; P_i</code>, <code>P_i -&gt; P_j</code></li>
<li>communication channels are <strong>FIFO</strong> ordered</li>
<li><strong>No failure</strong></li>
<li>All messages arribe intact, and are not duplicated</li>
</ul>

<p><em>requirements</em> 는</p>

<ul>
<li><em>snapshot</em> 때문에 <em>application</em> 의 작업에 방해가 일어나서는 안됩니다</li>
<li>각 프로세스는 자신의 <em>state</em> 를 저장할 수 있어야 합니다</li>
<li><em>global state</em> 는 분산회되어 저장됩니다 (collected in a distributed manner)</li>
<li>어떤 프로세스든지, <em>snapshot</em> 작업을 시작할 수 있습니다</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport1.png" alt=""></p>

<ul>
<li>프로세스 <code>P_i</code> 가 <em>market</em> 메세지를 만들고, 자신을 제외한 다른 <code>N-1</code> 개의 프로세스에게 보냅니다</li>
<li>동시에 <code>P_i</code> 는 <em>incoming channel</em> 을 레코딩하기 시작합니다</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport2.png" alt=""></p>

<p>(1) 만약 <code>P_i</code> 가 <em>marker</em> 메시지를 처음 받는다면</p>

<ul>
<li>만약메시지를 받은 프로세스 <code>P_i</code> 에서는 자신의 <em>state</em> 를 기록하고</li>
<li>자신을 제외한 프로세스들에게 <em>marker</em> 보내고</li>
<li>는 <em>incoming channel</em> 을 레코딩하기 시작합니다</li>
</ul>

<p>(2) <code>P_i</code> 가 이미 <em>market</em> 메세지를 받은적이 있다면</p>

<ul>
<li>이미 해당 채널의 모든 메세지를 기록중이었으므로, 레코딩을 끝냅니다</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport3.png" alt=""></p>

<p>이 알고리즘은 모든 프로세스가 자신의 <em>state</em> 와 모든 <em>channel</em> 을 저장하면 종료됩니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example3.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example4.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example5.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example6.png" alt=""></p>

<p><br></p>

<h3 id="consistentcuts">Consistent Cuts</h3>

<p><em>Chandy-Lamport</em> 알고리즘은 <em>casuality</em> 를 보장합니다. 이에 대해 증명하기 전에 먼저, <em>consistent cut</em> 이란 개념을 보고 가겠습니다.</p>

<ul>
<li><p><strong>Cut:</strong> time frontier at each process and at each channel. Events at the process/channel that happen before the cut are <strong>in the cut</strong> and happening after the cut are <strong>out of the cut</strong></p></li>
<li><p><strong>Consistent Cut:</strong> a cut that obeys casuality. A cut <code>C</code> is a consistent cut iff for each pair of event <code>e</code> <code>f</code> in the system, such that event <code>e</code> is in the cur <code>C</code> and if <code>f -&gt; e</code></p></li>
</ul>

<p>다시 말해서 <code>e</code> 가 <code>C</code> 내에 있고, <code>f -&gt; e</code> 라면 <code>f</code> 도 <code>C</code> 에 있어야만 <em>consistent cut</em> 이란 뜻입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consistent_cut1.png" alt=""></p>

<p><code>F</code> 가 <em>cut</em> 내에 있지만, 올바르게 캡쳐되어 메시지 큐 내에서 전송중임을 <em>snapshot</em> 에서 보장합니다. 하지만 <code>G -&gt; D</code> 같은 경우는, <code>D</code> 가 <em>cut</em> 내에 있지만 <code>G</code> 가 그렇지 않아 <em>inconsistent cut</em> 입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consistent_cut2.png" alt=""></p>

<p><em>Chandy-Lamport Global Snapshot</em> 알고리즘은 항상 <em>consistent cut</em> 을 만듭니다. 왜 그런가 증명을 보면</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Proof1.png" alt=""></p>

<p><code>ei -&gt; ej</code> 를 보장한다는 말은 스냅샷 안에 두 이벤트가 있다는 뜻입니다. 따라서 <code>ej -&gt; &lt;P_j records its state&gt;</code> 일때 당연히 <code>ei -&gt; &lt;P_i records its state&gt;</code> 와 같은 말입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Proof2.png" alt=""></p>

<p>만약 <code>ej -&gt; &lt;P_j records its state&gt;</code> 일때 <code>&lt;P_i records its state&gt; -&gt; ei</code> 라 합시다.</p>

<p>그러면 <code>ei -&gt; ej</code> 로 가는 <em>regular app message</em> 경로를 생각해 봤을때, <code>P_i</code> 가 먼저 자신의 상태를 기록하기 시작했으므로 <em>marker</em> 메세지가 먼저 날라갈겁니다. (FIFO) 그러면 위에서 말한 <code>ei -&gt; ej</code> 경로를 타고 <em>marker</em> 메세지가 먼저 가게되고 <code>P_j</code> 는 자신의 상태를 먼저 기록하게 됩니다. 따라서 <code>P_j</code> 에서 <code>ej</code> 보다 자신의 상태를 기록하는 것이 먼저이므로 <code>ej</code> 는 <em>out of cut</em> 이고, 모순입니다.</p>

<p><br></p>

<h3 id="safetyandliveness">Safety and Liveness</h3>

<p>분산시스템의 <em>correctness</em> 와 관련해서 <em>safety</em> 와 <em>liveness</em> 란 개념이 있습니다. 이 둘은 주로 혼동되어 사용되는데, 둘을 구별하는 것은 매우 중요합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/liveness.png" alt=""></p>

<ul>
<li>distributed computation will terminate eventually </li>
<li>every failure is eventually deteced by some non-faulty process</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/safety.png" alt=""></p>

<ul>
<li>there is no deadlock in a distributed transaction system</li>
<li>no object is orphaned</li>
<li><strong>accuracy</strong> in failure detector</li>
<li>no two processes decide on different values</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/liveness_and_safety.png" alt=""></p>

<p><em>failure detector</em> 나 <em>concensus</em> 의 경우에서 볼 수 있듯이 <em>completeness</em> 와 <em>accuracy</em> 두 가지를 모두 충족하긴 힘듭니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/language_of_global_state.png" alt=""></p>

<p><em>global snapshot</em> 은 한 상태 <code>S</code> 이고, 여기서 다른 스냅샷으로의 이동은 <em>casual step</em> 을 따라 이동하는 것입니다. 따라서 <em>liveness</em> 와, <em>safety</em> 와 관련해 다음과 같은 특징이 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/using_global_snapshot.png" alt=""></p>

<p><em>Chandy-Lamport</em> 알고리즘은 <em>stable</em> 한지를 검사하기 위해 사용할 수도 있습니다. 여기서 <em>stable</em> 하다는 것은, 한번 참이면 그 이후에는 계속 참인 것을 말합니다. 이는 알고리즘이 <em>casual correctness</em> 를 가지기 때문입니다.</p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://ook.co/solutions/cloud-computing/">Title Image</a> <br>
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></content:encoded></item><item><title><![CDATA[Coding The Matrix 2, Vector Space]]></title><description><![CDATA[<p><img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""></p>

<h3 id="linearcombinations">Linear Combinations</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/linear_combinations.png" alt=""></p>

<p><code>b</code> 와 <code>v1, ..., vn</code> 이 주어졌을때 </p>

<ul>
<li><code>a1, ..., an</code> 을 찾을 수 있을까요? </li>
<li>있다면 <em>unique solution</em> 인지 어떻게 알 수 있을까요?</li>
</ul>

<p><br></p>

<h3 id="span">Span</h3>

<ul>
<li>The set of all linear combinations of some vectors <code>v1, ..., vn</code> is called <strong>span</strong> of these vector</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/span.png" alt=""></p>

<p>이브가 만약 위와 같은식을 만족한다는 사실을 알고 있다면, 패스워드의 모든</p>]]></description><link>http://1ambda.github.io/coding-the-matrix-2/</link><guid isPermaLink="false">5f630834-a38f-4833-a4a3-8d465a1c0b31</guid><category><![CDATA[coursera]]></category><category><![CDATA[linear algebra]]></category><category><![CDATA[vector space]]></category><category><![CDATA[span]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 04 Mar 2015 16:28:24 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""></p>

<h3 id="linearcombinations">Linear Combinations</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/linear_combinations.png" alt=""></p>

<p><code>b</code> 와 <code>v1, ..., vn</code> 이 주어졌을때 </p>

<ul>
<li><code>a1, ..., an</code> 을 찾을 수 있을까요? </li>
<li>있다면 <em>unique solution</em> 인지 어떻게 알 수 있을까요?</li>
</ul>

<p><br></p>

<h3 id="span">Span</h3>

<ul>
<li>The set of all linear combinations of some vectors <code>v1, ..., vn</code> is called <strong>span</strong> of these vector</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/span.png" alt=""></p>

<p>이브가 만약 위와 같은식을 만족한다는 사실을 알고 있다면, 패스워드의 모든 <em>span</em> <code>{a1, ..., an}</code> 에 대해서 적절한 <em>response</em> 를 추출할 수 있습니다. 증명은 위처럼 간단합니다.</p>

<p><br></p>

<p>Let <code>V</code> be a set of vectors if <code>v1, ..., vn</code> are vectors such that <code>V</code> = Span <code>{v1, ..., vn}</code> then</p>

<ul>
<li>we say <code>{v1, ..., vn}</code> is a generating set for <code>V</code></li>
<li>we refer to the vectors <code>v1, ..., vn</code> as generators for <code>V</code></li>
</ul>

<p><code>[x, y, z]</code> = <code>x[1,0,0] + y[0,1,0] + z[0,0,1]</code> 을 <code>R^3</code> 의 <em>standard generator</em> 라 부릅니다. </p>

<p><br></p>

<h3 id="geometryofsetsofvectors">Geometry of Sets of Vectors</h3>

<ul>
<li><em>Span of the empty set:</em> just the origin, <strong>Zero-dimensional</strong></li>
<li><em>Span</em> <code>{[1,2], [3,4]}</code>: all points in the plane, <strong>Two-dimensional</strong></li>
<li><em>Span</em> <code>{[1,0,1.65], [0,1,1]}</code> is a plain in three dimensions</li>
</ul>

<p><code>k</code> 벡터의 <em>span</em> 은 <em>k-dimensional</em> 일까요? 아닙니다.</p>

<ul>
<li>Span <code>{[0, 0]}</code> 은 <em>zero-dimensional</em> 입니다.</li>
<li>Span <code>{[1,3], [2,6]}</code> 은 <em>one-dimensional</em> 입니다. </li>
<li>Span <code>{[1,0,0], [0,1,0], [1,1,0]}</code> 은 <em>two-dimensional</em> 입니다.</li>
</ul>

<p>그러면 어떤 벡터 <code>v</code> 가 있을때 <em>dimensionality</em> 를 어떻게 알아낼 수 있을까요?</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/geometry_of_sets.png" alt=""></p>

<p>위 그림에서 볼 수 있듯이 <em>origin</em> 을 포함하는 <em>geometry object</em> 를 표현하는 방법은 두가지 입니다. 각각은 나름의 쓰임새가 있습니다.</p>

<p>(1) <em>span</em> of some vectors <br>
(2) 우변이 <code>0</code> 인 <em>linear equation system</em> 의 집합</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/two_representation1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/two_representation2.png" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/common_representation1.png" alt=""></p>

<p><em>field</em> 의 서브셋은 3가지 속성을 만족합니다. <em>field</em> 를 <code>R</code> 이라 하면</p>

<ul>
<li>subset contains the zero vector</li>
<li>if subset contains <code>v</code> then it contains <code>av</code> for every scala <code>a</code></li>
<li>if subset contains <code>u</code> and <code>v</code> then it contains <code>u+v</code></li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/common_representation2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/common_representation3.png" alt=""></p>

<p><code>F^D</code> 의 세가지 속성을 만족하는 <em>subset</em> 을 <strong>vector space</strong> 라 부릅니다. 그리고 <code>U</code> 가 <em>vector space</em> 고 <em>vector space</em> <code>V</code> 의 <em>subset</em> 일때, <code>U</code> 를 <code>V</code> 의 <em>subspace</em> 라 부릅니다.</p>

<p>뒤에서 배울테지만 모든 <code>R^D</code> 의 <em>subspace</em> 는 <em>span</em> <code>{v1, ..., vn}</code> 과 <code>{x: a1 * x = 0, ..., an * x = 0}</code> 의 형태로 쓸 수 있습니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/abstract_vector_space.png" alt=""></p>

<p>우리는 벡터에 대해 <em>sequence</em> 나, <em>function</em> 을 정의하지 않았습니다. 단순한 <em>operator</em> 와 공리를 만족하는지, 그리고 <em>property</em> <code>V1, V2, V3</code> 정도만 따졌습니다. 벡터에 대한 이런 추상적 접근은 많은 장점이 있습니다. 그러나 이 수업에서는 사용하지 않겠습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/convex_hull.png" alt=""></p>

<p><br></p>

<h3 id="vectorspace">Vector Space</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/exclude_origin_line.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/exclude_origin_plain.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_space.png" alt=""></p>

<p>벡터 <code>c</code> 와 벡터 스페이스 <code>V</code> 에 대해 <code>c + V</code> 와 같은 형태를 <em>affine space</em> 라 부릅니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination.png" alt=""></p>

<p><code>u1, u2, u3</code> 를 담고있는 <em>plain</em> 을 <code>u1 + V</code> 형태로 표현하고 싶습니다. 어떻게 해야할까요?</p>

<p><code>V</code> 를 <em>span</em> <code>{a, b}</code> 라 하고 <code>a = u2 - u1</code>, <code>b = u3 - u1</code> 라 하면 <code>u1 + V</code> 는 <em>plain</em> 의 변환이지만, 그 자체로서 <em>plain</em> 입니다</p>

<ul>
<li><em>span</em> <code>{a, b}</code> 는 <code>0</code> 을 포함하므로 <code>u1</code> + <em>span</em> <code>{a, b}</code> 는 <code>u1</code> 를</li>
<li><em>span</em> <code>{a, b}</code> 는 <code>u2 - u1</code> 도 을 포함하므로 <code>u1</code> + <em>span</em> <code>{a, b}</code> 는 <code>u2</code> 를</li>
<li><em>span</em> <code>{a, b}</code> 는 <code>u3 - u1</code> 도 을 포함하므로 <code>u1</code> + <em>span</em> <code>{a, b}</code> 는  <code>u3</code> 를 포함합니다.</li>
</ul>

<p>따라서 <code>u1</code> + <em>span</em> <code>{a, b}</code> 는 <code>u1, u2, u3</code> 를 모두 포함하는 평면입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination2.png" alt=""></p>

<p>더 간단히 <code>ru1 + au2 + bu3</code> (<code>r + a + b = 1</code>) 로 <em>affine combination</em> 을 표현할 수 있습니다. 그리고 더 <em>formal</em> 하게 정의하면,</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination3.png" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_equation.png" alt=""></p>

<p><em>affine space</em> 를 <em>a solution set of a system of linear equations</em> 으로 표현할 수 있습니다. 그런데, 역으로 이 솔루션이 <em>affine space</em> 일까요?</p>

<p>반례를 하나 들어보면 <code>1x = 1, 2x = 1</code> 일때 솔루션은 없습니다. 그러나 벡터 스페이스 <code>V</code> 는 <em>zero vector</em> 를 가져야 하므로 <em>affine space</em> <code>u + V</code> 는 적어도 하나의 <em>vector</em> 는 가져아합니다. 모순이 발생합니다.</p>

<ul>
<li><strong>Theorem:</strong> <em>solution set of a linear system</em> 은 <em>empty</em> 거나 <em>affine space</em> 입니다. 증명은 아래와 같습니다.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination_proof1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination_proof2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination_proof3.png" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/number_of_solutions.png" alt=""></p>

<p>지금까지 증명한 것은, <code>u1</code> 이 <em>linear system</em> 의 솔루션일때, <code>u1 + v</code> (<code>v</code> in <code>V</code>) 도 솔루션이란 사실입니다. 여기서 <code>V</code> 는 <em>homogeneous linear system</em> 입니다. (우변이 <code>0</code> 인)</p>

<p>따라서 </p>

<ul>
<li><em>unique solution</em> 을 가질때는 <code>V</code> 가 <code>0</code> 을 해로 가질 때이고</li>
<li><em>GF(2)</em> 의 솔루션 수는 <code>0</code> 이거나, <code>V</code> 와 같습니다.</li>
</ul>

<p><br></p>

<h3 id="checksumfunction">Checksum function</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/checksum1.png" alt=""></p>

<p><em>corrupted</em> 파일이 올바른 파일로 인식될 경우는 오리지널 바이너리 <code>p</code> 에 대해 손상된 파일 <code>p+e</code> 가 위 슬라이드의 방정식을 만족할 경우입니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/checksum2.png" alt=""></p>

<p>이 확률은 모든 가능한 <code>n</code> 벡터에 대해 존재하는 솔루션의 수 이므로 굉장히 낮습니다.</p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://colorsark.deviantart.com/art/3D-Cube-342632998">Title image</a> <br>
(2) <strong>Coding the Matrix</strong> by <em>Philip Klein</em>  </p>]]></content:encoded></item></channel></rss>