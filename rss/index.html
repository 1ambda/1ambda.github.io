<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Old Lisper]]></title><description><![CDATA[Lisp, Emacs, Scala]]></description><link>http://1ambda.github.io/</link><generator>Ghost 0.5</generator><lastBuildDate>Fri, 24 Oct 2014 07:31:23 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Machine Learning, Week 4]]></title><description><![CDATA[<p>지난 시간에는 실리콘 밸리의 머신러닝 개발자들이 귀한대접을 받는다는 훈훈한 덕담으로 강의가 끝났다. 이번시간에는 뜬금없이 <em>Neural Network (신경망)</em> 을 건들다가 놀랍게도 그것이 <em>logistic regression</em> 과 연관이 있으며 <code>n</code> 이 매우 클 경우의 <em>classification</em> 문제를 해결할 수 있다는 것을 배운다.</p>

<h3 id="nonlinearhypotheses">Non-Linear Hypotheses</h3>

<p>다음과 같은 트레이닝 셋이 있을때, 두 집단을 <em>classification</em> 하는 <em>hypothesis</em> 를 찾는다고 하자. </p>

<p><img src='http://www.holehouse.org/mlclass/08_Neural_Networks_Representation_files/Image.png'  align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org</a>)</p>

<p><code>x1</code> 과 <code>x2</code> 만으로는 찾을 수 없으니, 더 많은 <em>feature</em>  <code>x1^2, x1x2, x2^2</code> 를 도입한다 하자. 트레이닝 셋에 적합한 가설을 찾을수는 있겠지만, 항상 좋은건 아니다.</p>

<p>(1) 우선 지난 시간에 언급했듯이 <em>Overfitting</em> 이 발생할 수 있고 <br />
(2) <em>feature</em> 수가 <code>n</code> 이라 할때, 모든 <em>quadratic feature</em> 를 도입하면 <em>feature</em> 수가 <code>O(n^2)</code> (<code>n^2/2</code>)만큼 늘어난다. (아래 그림 참조) 다시 말해서 계산 비용이 엄청나게 비싸진다.</p>

<p><img src='http://img.blog.csdn.net/20140507021224421'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/feliciafay' >http://blog.csdn.net/feliciafay</a>)</p>

<p>그리고 <em>feature</em> 수를 줄이기 위해 <code>x1^2, x2^2, x3^2 ...</code> 등 <em>quadratic feature</em> 만을 도입하고 나머지 <em>parameter</em> 를 버리면, <em>hypothesis</em> 가 <em>underfit</em> 할 수 있다.</p>

<p>만약 <em>feature</em> 를 <em>cubic</em> 까지 도입하면 <em>feature</em> 수가 <code>O(n^3)</code> 으로 늘어나 계산시간은 어마어마하게 걸린다. 따라서 차수를 늘려 문제를 해결하려는 방법은 <code>n</code> 이 클때 좋은 방법이 아니다. 게다가 일반적으로 대부분의 문제들은 <code>n</code> 이 큰편이다.</p>

<p>자동차 이미지 인식 문제를 고려해 보자. 이미지는 픽셀이므로, 50 * 50 픽셀로 구성된 경우 <code>n = 2500</code> 이다.</p>

<p><img src='http://img.blog.csdn.net/20140507021231812'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/feliciafay' >http://blog.csdn.net/feliciafay</a>)</p>

<p>이건 그레이스케일의 경우고 만약 RGB 라면 여기에 3을 곱해서 <code>n = 7500</code> 이 된다. <em>quadratic</em> 이면 <code>7500^2 / 2</code>, 대략 3 millions 개의 <em>feature</em> 를 가지게 된다. 이쯤되면 답이 없다. <code>n</code> 이 큰 <em>classification</em> 에 대해 사용할 수 있는 다른 방법은 없을까?</p>

<h3 id="modelrepresentation">Model Representation</h3>

<p>잠깐 눈을 돌려 <em>Neural Networks</em> 에 대해 이야기 해 보자. 다양한 알고리즘을 개발하는 대신  스스로 학습하는 뇌를 모방한 알고리즘을 개발할 수 있다면 진짜 AI 를 구현할 수 있지 않을까? 라는 질문에서 <em>Neural networks</em> 는 출발한다.</p>

<p>뇌를 모방한 알고리즘을 만들려면, 인간의 뇌가 어떻게 작동하는지 알아야한다. 뇌는 <em>Neuron</em> 이라는 단위의 집합으로 구성되었는데, 요로코롬 생겼다.</p>

<p><img src='http://home.agh.edu.pl/' ~vlsi/AI/intro/neuron.png" align="center" />  </p>

<p align="center">(<a href='http://home.agh.edu.pl/' ~vlsi/AI/intro/'>http://home.agh.edu.pl/~vlsi/AI/intro/</a>)</p>  

<p><br/></p>

<p>여기서 <em>Dendrite</em> 라는 부분이 <strong>input</strong> 이고, <em>Axon</em> 이 <strong>output</strong> 이다. 이걸 모델링하면,</p>

<p><img src='http://img.blog.csdn.net/20140507021238515'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/feliciafay' >http://blog.csdn.net/feliciafay</a>)</p>

<p>위 그림에서 좌측에 있는 <code>x1, x2, x3</code> 가 <em>input</em> 이라 보면 되고, <code>h0(x)</code> 는 이전처럼 <code>0^T * x</code> 에 <em>sigmoid function</em> 을 적용한 것이다. 그리고 <em>neural network</em> 에서 <em>parameter</em> 대신 <code>0(theta)</code> 를 <strong>weights</strong> 라 부르기도 한다. <code>x0</code> 은 값이 <code>1</code> 이고, <em>bias unit</em> 이라 부르는데 편의상 그리기도 하고 안그리기도 한다. <del>교수님 뜻대로 하소서</del>
<br/><br/></p>

<p>여기까지는 단일 <em>neuron</em> 을 모델링 한것이고, <em>neural network</em> 는 여러개의 <em>neuron</em> 들이 합쳐진 것이다. 간단히 그려보면, </p>

<p><img src='http://img.blog.csdn.net/20140507021247656'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/feliciafay' >http://blog.csdn.net/feliciafay</a>)</p>

<p>여기서 <em>layer 1</em> 은 <em>input layer</em>, 마지막인 <em>layer 3</em>은 <em>output layer</em> 다. 그리고 가운데 있는 레이어들, 여기서는 <em>layer2</em>, <strong>hidden layer</strong> 라 부른다. 디버깅이 아니라면 <em>hidden layer</em> 에서 산출되는 값들을 관측하려고 할 필요는 없다. <em>hidden layer</em> 는 하나 이상일 수 있다. 실제 계산 과정을 보면</p>

<p><img src='http://img.blog.csdn.net/20140507021254640'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/feliciafay' >http://blog.csdn.net/feliciafay</a>)</p>

<p><code>ai^j</code> 는, <code>j</code> 번째 <em>hidden layer</em> 에서 <code>i</code> 번째 <em>unit</em> 이다. <code>0(theta)^j</code> 는 <em>layer j</em> 와 <em>layer j+1</em> 사이에서 사용되는 <em>weights</em> 다. 이때 <em>hidden layer</em> 의 각 <em>unit</em> 마다 <em>input</em> 을 위한 <em>weight</em> 를 가지고 있다고 하면 위의 그림에서 <code>0</code> 의 <em>dimension</em> 은 <code>3 * 4</code> 다. (<em>bias unit</em> <code>x0</code> 포함)</p>

<blockquote>
  <p>If network has <code>s_j</code> units in layer <code>j</code>, <code>s_j+1</code> units in layer <code>j+1</code>, then <code>0^j</code> will be dimension <code>s_j+1 * (s_j + 1)</code></p>
</blockquote>

<p>이제 <em>output layer</em> 를 잘 보면 이 레이어의 <em>input</em> 은 <code>a^(2)</code> 고, <em>weight</em> 로 <code>0^2</code> 를 가지고 있다. 따라서 <code>h0(x)</code> 는 위의 식처럼 된다.</p>

<h3 id="forwardpropagation">Forward Propagation</h3>

<p>위 그림처럼 <code>x</code> 를 받아, <code>h0(x)</code> 를 계산하는 방법을 <em>forward propagation</em> 이라 부르는데 <em>vectorization</em> 을 이용해서 간단히 해 보자.</p>

<p><img src='http://www.try2go.com/wp-content/uploads/2014/08/forward-propogation.jpg'  align="center" />  </p>

<p align="center">(<a href='http://www.try2go.com/201408/neural-networks-1/' >http://www.try2go.com/201408/neural-networks-1/</a>)</p>

<p><em>sigmoid fucntion</em> <code>g</code> 내부의 수식을 <code>z</code> 라 부르고 <code>a^(1) = x</code> 라 두면, 우측처럼 수식이 심플해진다. <code>z^(2) = 0^(1) * a^(1)</code> 이고, 여기에 <em>sigmoid function</em> 을 적용하면 <code>a^(2)</code> 가 나온다. 여기에 <em>bias unit</em> <code>a_0^(2) = 1</code> 을 더해 <code>a^(2)</code> 를 4차원 벡터로 만들면 다시 <code>z^(3)</code> 를 계산할 수 있다. 
<br/><br/></p>

<p>자, 이제 왜 <em>neural network</em> 를 뜬금없이 공부하다가 <em>forward propagation</em> 의 <em>vectorization</em> 까지 고려했는지를 밝힐 시간이다! 위 그림에서 <code>a^(1)</code> 즉, <em>layer 1</em> 을 가려버리면 아래와 같은데</p>

<p><img src='http://www.try2go.com/wp-content/uploads/2014/08/learn-features.jpg'  align="center" />  </p>

<p align="center">(<a href='http://www.try2go.com/201408/neural-networks-1/' >http://www.try2go.com/201408/neural-networks-1/</a>)</p>

<p>이때 <code>h0(x)</code> 를 계산하는 식을 구해보면, <em>logistic regression</em> 과 똑같다. <del>오오 머신러닝 오오</del> </p>

<p><strong>결국, <em>neural network</em> 가 하는 일은 <em>logistic regression</em> 이다.</strong> 단지  <em>hidden layer</em> 에서 <code>x1, x2, x3</code> 를 적당한 <em>weight</em> 로 훈련시켜 새로운 <em>feature</em> <code>a1^(2),  a2^(2), a3^(2)</code> 를 만들어 내고, 그걸로 <em>logistic regression</em> 을 할 뿐이다. </p>

<p>다시 한번 정리하자면 <em>neural network</em> 는 <em>feature</em> 를 훈련시켜 다른 값을 가진  <em>feature</em> 로 바꾸는 과정을 통해 <em>hypothesis</em> 를 매우 고차의 다항식으로 만들지 않고도 <code>n</code> 이 매우 큰 경우의 <em>classification</em> 을 풀 수 있도록 한다. 항상 같은 개수의 <em>feature</em> 만 나오는건 아니고, 더 줄이거나 좀 더 늘릴 수도 있다. 아래의 그림을 보자.</p>

<p><img src='http://alphaism.files.wordpress.com/2012/11/selection_001.png?w=630'  align="center" />  </p>

<p align="center">(<a href='http://alphaism.wordpress.com/' >http://alphaism.wordpress.com/</a>)</p>

<h3 id="examples">Examples</h3>

<p>먼저 간단히 <em>AND</em> 연산을 <em>neural network</em> 로 구현한다 하자. </p>

<p><img src='http://www.try2go.com/wp-content/uploads/2014/08/and.jpg'  align="center" />  </p>

<p align="center">(<a href='http://www.try2go.com/201408/neural-networks-1/' >http://www.try2go.com/201408/neural-networks-1/</a>)</p>

<p>위 그림처럼 <code>z^(2) = -30 + 20x1 + 20x2</code> 라면, 우측 표 처럼 각각 <code>h0(x)</code> 값이 나오고, <em>sigmoid function</em> 은 <code>4.6</code> 정도일때 <code>y ~= 0.99</code> 이므로 <code>g(+10)</code> 은 거의 <code>1</code>, <code>g(-10)</code> 은 거의 <code>0</code> 이라 볼 수 있다.</p>

<p><em>XNOR</em> 은 <em>AND</em> <em>~ AND ~</em> 그리고 <em>OR</em> 을 조합하면 만들 수 있다. 아래 그림을 보자.</p>

<p><img src='http://www.holehouse.org/mlclass/08_Neural_Networks_Representation_files/Image%20' [17].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org</a>)</p>

<p>결국 <em>neural network</em> 는 각 <em>hidden layer</em> 에서 함수를 이용해 이전 단계의 결과에 어떤 처리를 가해 복잡한 일들을 해낼 수 있는 것이다.</p>

<h3 id="multiclassclassification">Multiclass Classification</h3>

<p>이제 <em>multi-class</em> 를 고려해 보자.</p>

<p><img src='http://www.try2go.com/wp-content/uploads/2014/08/one-vs-all.jpg'  align="center" />  </p>

<p align="center">(<a href='http://www.try2go.com/201408/neural-networks-1/' >http://www.try2go.com/201408/neural-networks-1/</a>)</p>

<p>위 그림처럼 4개의 클래스가 있을 때, <em>output</em> 인 <code>h(x)</code> 를 <code>4 * 1</code> vector 로 만들도록 하고, 각 클래스에 대해서 <code>[1; 0; 0; 0], [0; 1; 0; 0], [0; 0; 1; 0], [0; 0; 0; 1]</code> 이 되도록 훈련시키면 된다. 기본적인 아이디어는 <em>one vs all method</em> 와 같다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://blog.csdn.net/feliciafay/article/details/25171147' >http://blog.csdn.net/feliciafay</a> <br />
(2) <a href='http://www.holehouse.org/mlclass/08_Neural_Networks_Representation.html' >http://www.holehouse.org</a> <br />
(3) <a href='http://home.agh.edu.pl/' ~vlsi/AI/intro/">http://home.agh.edu.pl/~vlsi/AI/intro/</a> <br />
(4) <a href='http://www.try2go.com/201408/neural-networks-1/' >http://www.try2go.com/201408/neural-networks-1/</a> <br />
(5) <a href='http://alphaism.wordpress.com/2012/11/13/neural-network-algorithm/' >http://alphaism.wordpress.com/</a></p>]]></description><link>http://1ambda.github.io/machine-learning-week-4/</link><guid isPermaLink="false">02903e2d-5c8c-4abf-9635-da5747fd9c01</guid><category><![CDATA[coursera]]></category><category><![CDATA[machine lerning]]></category><category><![CDATA[classification]]></category><category><![CDATA[neural network]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 23 Oct 2014 07:11:31 GMT</pubDate></item><item><title><![CDATA[Machine Learning, Week 3]]></title><description><![CDATA[<p>지난 시간엔 <em>Regression</em> 을 해결하기 위해 <em>graident descent</em> 알고리즘을 도입했었다. <em>learning rate</em>, <em>vectorization</em> 등에 대해서 알아 보기도 했고. 이번시간엔 <em>classification</em> 과 <em>regulrzation</em> 에 대해서 배워 본다. </p>

<p>이 수업이 재밌는 이유는 수식을 증명하는 것보다 수식속에 숨겨진 내용들을 직관적으로 이해할 수 있게 설명하기 때문이다. <del>그러나 교수님 과제는 제발 그만</del></p>

<h3 id="classification">Classification</h3>

<p><em>regression</em> 이 <em>continuous value</em> 를 다룬다면 <strong>Classification</strong> 은 <strong>discrete value</strong> 를 다룬다. 따라서 <em>Classification (분류)</em> 의 예는,</p>

<ul>
<li>이메일이 스팸인지 / 아닌지  </li>
<li>온라인 거래가 사기인지 / 아닌지 (Online Transaction: Fraudulent)  </li>
<li>악성 종양인지 / 아닌지  </li>
</ul>

<p><img src='http://i.stack.imgur.com/VVtRW.png'  align="center" />  </p>

<p align="center">(<a href='http://stats.stackexchange.com/' >http://stats.stackexchange.com</a>)</p>

<p>위와 같은 경우, <em>Regression</em> 으로 문제를 풀면 당장은 맞아 보이나, 종양이 이상한 위치에 생겼을 경우 아래와 같이 직선이 크게 변한다.</p>

<p><img src='http://i.stack.imgur.com/nEC4H.png'  align="center" />  </p>

<p align="center">(<a href='http://stats.stackexchange.com/' >http://stats.stackexchange.com</a>)</p>

<p>따라서 이렇게 <em>discrete value</em> 에 대해서는 <em>Regression</em> 보다는 <em>Threshold</em> 에 기반을 두어, <code>h(x)</code> 가 일정 값 이상이면 <code>y=1</code> 로 예측하는 편이 더 정확도가 높아진다. 게다가 <em>regression</em> 은 직선이기 때문에, <code>0 &lt;= y &lt;= 1</code> 인 <code>y</code> 에 대해서 0보다 작거나, 1보다 더 큰 <code>y</code> 를 만들어낼 수 있다.</p>

<p>이런 이유 때문에 <em>Classification</em> 문제에 <em>Regression</em> 을 잘 사용하지 않는다. 그러나 <code>y</code> 의 범위가 <code>0 &lt;= h(x) &lt;= 1</code> 을 가지는 <em>Logistic Regression</em> 도 있다. 이건 <em>Classification</em> 에 사용되기도 한다.</p>

<h3 id="logisticregression">Logistic Regression</h3>

<p>이전에 언급했듯이 <em>classification</em> 에선 예측된 값, 즉 <code>h(x)</code> 값이 0 과 1사이에 있길 바란다. 이를 위해 <em>logistic function</em>, 혹은 <strong>sigmoid function</strong> 이라 불리는 아래 식을 <em>hypothesis</em> <code>h(x)</code> 에 적용하면 아래와 같은 그림이 나온다.</p>

<p><img src='http://www.saedsayad.com/images/ANN_Sigmoid.png'  align="center" />  </p>

<p align="center">(<a href='http://www.saedsayad.com/' >http://www.saedsayad.com</a>)</p>

<p>이 때 <em>sigmoid function</em> 이 적용된 <code>h(x)</code> 는 최대값이 1이므로, 이건 입력값 <code>x</code> 에 대해서 <code>y</code> 가 1이 나올 확률이라 보아도 된다. 따라서</p>

<p><code>h(x) = P(y = 1 | x ; 0)</code></p>

<blockquote>
  <p>Probability that <code>y = 1</code>, given <code>x</code>, parameterized by <code>0(theta)</code></p>
</blockquote>

<p>이 때 <em>sigmoid function</em> 을 보면, X 축이 0보다 큰 점에선 <code>y</code> 값이 0.5 보다 크므로, 이 점 이후부터는 <code>y</code> 를 1 이라 <em>예측 (predict)</em> 하고, 반대로 X 축 값이 0보다 작은 지점에선 <code>y</code> 를 0이라 예측할 수 있다.</p>

<p>그런데 <code>h(x) = g(0^T * x)</code> 이므로, 본래의 <em>hypothesis</em> <code>0^T * x</code> 가 0이 되는 지점을 찾으면 된다.</p>

<p><img src='http://my.csdn.net/uploads/201207/04/1341403634_5914.jpg'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/abcjennifer/' >http://blog.csdn.net/abcjennifer/</a>)</p>

<h3 id="decisionboundary">Decision Boundary</h3>

<p>이제 실제로 문제에 적용해 보자. 다음과 같이 두개의 집단이 있을때, 이 두 집단을 가르는 식을 찾기 위한 <code>h(x) = g(01 + 01x1 + 02x2)</code> 가 있다고 해 보자. </p>

<p><img src='http://my.csdn.net/uploads/201207/05/1341470683_7505.jpg'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/abcjennifer/' >http://blog.csdn.net/abcjennifer/</a>)</p>

<p>이때 <code>0(theta)</code> 를 <code>[-3; 1; 1]</code> 로 잡으면 <code>y</code> 가 <code>1</code> 이 되는 지점은 <code>0^T * x &gt;= 0</code> 인 지점, 즉 <code>-3 + x1 + x2 &gt;= 0</code> 인지점을 찾으면 된다. 이 식을 풀어서 쓰면</p>

<p><code>x1 + x2 =&gt; 3</code> 이므로, 위 그림에서 분홍색 선을 찾을 수 있다. 이 선을 <strong>Decision Boundary</strong> 라 부른다. 그리고 이 <em>Decision Boundary</em> 는 <code>g(z) = 0</code> 즉,  <code>h(x) = 0.5</code> 인 지점이다.</p>

<p><em>Non-linear dicision boundary</em> 는 어떨까?</p>

<p><img src='http://my.csdn.net/uploads/201207/05/1341471338_7289.jpg'  align="center" />  </p>

<p align="center">(<a href='http://blog.csdn.net/abcjennifer/' >http://blog.csdn.net/abcjennifer/</a>)</p>

<p>이 경우  <code>x1^2</code>, <code>x2^2</code> 이라는 새로운 <em>feature</em> 를 도입하고, <em>parameter</em> 인 <code>theta</code> 를 <code>[-1; 0; 0; 1; 1;]</code> 로 잡았다. 식을 풀면, 위와 같은 원 형태의 <em>Decision Boundary</em> 가 나온다.</p>

<p><em>feature</em> 만 잘 조합하면, 즉 <em>polynomial</em> 만 잘 만들면 땅콩이나 하트모양 등의 <em>Decision boundary</em> 도 만들 수 있다.</p>

<h3 id="costfunction">Cost Function</h3>

<p>이제 문제는 <code>theta</code> 를 어떻게 고르느냐 하는건데, 식을 좀 다시 살펴보자.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [9].png" align="center" /> <br />
<img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [11].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p><em>Linear regression</em> 에서 사용하는 <em>cost function</em> 에 지금의 <code>h(x)</code>, 즉 <em>sigmoid function</em> 이 적용된 <code>h(x)</code> 를 제곱한 <code>J(0)</code> 는 <em>non-convex</em> 형태가 된다. 따라서 <em>global optimum</em> 보다는 <em>local optimum</em> 을 찾게 된다. </p>

<p>이를 방지하기 위해서, <em>convex</em> 형태의 <em>cost function</em> 을 사용해야 하는데, </p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [12].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>이 <em>cost function</em> 을 사용하면, <code>y = 1</code> 일때 다음과 같은 그래프를 얻게 된다. <code>0 &lt;= h(x) &lt;= 1</code> 임을 참고하자. <code>y = 1</code> 일때, <code>h(x) = 0</code> 으로 가면, <em>cost function</em> 의 값, 즉 <em>cost</em> 자체가 높아지므로, <em>Cost</em> 를 낮추는 반대 방향으로 움직이게 된다. </p>

<p>직관적으로 보면, <code>h(x)</code> 자체는 <code>y = 1</code> 일 확률인데, <code>y = 1</code> 일때, <code>h(x) = 0</code> 이라는 것은 말이 안 되므로 비용이 무한대로 증가하는 것이 말이 된다.  </p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [13].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>반대로 <code>y = 0</code> 일때의 그래프를 보면 <code>h(x) = 0</code> 즉, <code>y = 0</code> 일 확률이 <code>0</code> 으로 갈때 <em>cost</em> 가 감소한다.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [14].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>결국 아래의 새로운 <em>logistric regression cost function</em> 을 이용하면, <code>J(0)</code> 를 <em>convex function</em> 으로 만들 수 있다.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [12].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<h3 id="simplifiedcostfunctionandgradientdescent">Simplified Cost Function and Gradient Descent</h3>

<p>이제 <code>y = 0</code>, <code>y = 1</code> 로 나누어져 있던 <em>cost function</em> 을 좀 더 간단히 표현해 보자.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [15].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>다음과 동일하다. <code>y = 0</code>, <code>y = 1</code> 을 직접 넣어보면 금방 알 수 있다.</p>

<p><code>cost(hθ(x),y) = -y * log(hθ(x)) - (1-y) * log(1 - hθ(x))</code></p>

<p><br/> <br />
자 이제 다시 본론으로 돌아와서, 우리는 처음에 <code>theta</code> 를 찾길 원했고, 그래서 <em>gradient descent</em> 를 쓰려고 했는데, 마침 보니 <code>h(x)</code> 가 <em>sigmoid function</em> 이 적용된 형태라서 <em>non-convex function</em> 이므로, <code>h(x)</code> 를 포함한 <em>cost-function</em> 이 <em>convex function</em> 이 되는 식을 찾아냈다. 이제 그 식을 <em>gradient descent</em> 에 적용하면,</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [16].png" align="center" /></p>

<p>이고, 이제 이걸 <em>batch gradient descent</em> 에 적용하면 아래와 같은데, 여기에 <em>partial derivative</em> 를 적용하면</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [20].png" align="center" /></p>

<p>놀랍게도 <em>linear regression</em> 과 같은 식이 나온다. <del>오오 머신러닝 오오</del></p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [18].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>다만 다른점은 <em>hypothesis</em> 가 <em>sigmoid function</em> 을 적용한 형태라는 것,</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [17].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<h3 id="advancedoptimization">Advanced Optimization</h3>

<p>위에서 보았겠지만, <code>J(0)</code> 의 최소값을 찾기 위해서는 아래 두개의 값을 구해야 한다.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [19].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>이 값들을 이용해서 <em>gradient descent</em> 대신 다음의 알고리즘을 사용할 수 있다.</p>

<p>(1) Conjugate gradient <br />
(2) BFGS <br />
(3) L-BFGS  </p>

<p>이 알고리즘들의 장점은, <em>leanring rate</em> 를 고를 필요가 없고, 대부분 <em>gradient decsent</em> 보다 빠르다. </p>

<p>그러나 더 복잡하고, 라이브러리마다 구현이 다를 수 있으며, 디버깅이 힘들수 있다. 자 이제 <em>advanced optimization</em> 을 이용해 보자.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [21].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>위와 같은 식에 대해서 <em>cost function</em> 을 <code>octave</code> 에서 이렇게 만들 수 있다.</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [22].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>  

<p><br/></p>

<p>이제, <code>octave</code> 에서 제공해 주는 <code>fminunc</code> 에 우리가 만든 <code>costFunction</code> 과 초기 <code>theta</code> 값, 그리고 옵션을 집어 넣으면</p>

<pre><code class="matlab">% define the options data structure
options= optimset('GradObj', 'on', 'MaxIter', '100'); 

% set the initial dimensions for theta % initialize the theta values
initialTheta= zeros(2,1); 

% run the algorithm
[optTheta, funtionVal, exitFlag]= fminunc(@costFunction, initialTheta, options); 
</code></pre>

<p><code>optTheta</code> 는 우리 찾길 원했던 <code>theta</code> 값이고, <code>functionVal</code> 은 최종 <em>cost</em> 를 돌려준다. <code>exstFlag</code> 는 알고리즘이 수렴했는지, 아닌지 알려준다.</p>

<p>만약 <em>logistic regression</em> 에 대한 <code>theta</code> 값을 찾고 싶으면, <em>cost function</em> 을 <em>logistic regression</em> 에 맞게 작성하면 된다.</p>

<h3 id="multiclassclassification">Multiclass Classification</h3>

<p>이제 단순히 <code>y = 0 or 1</code>(<em>binary classification</em>) 이 아닌, 다양한 <em>class</em> 가 있는 <em>classification</em> 을 고려해보자, 예를 들면 날씨는 <code>sunny</code>, <code>cloudy</code>, <code>hot</code>, <code>cold</code> 등으로 분류될 수 있다.</p>

<h4 id="onevsallonevsrest">one-vs-all (One-vs-rest)</h4>

<p><em>multi class</em> 를 분류할 수 있는 한가지 방법은, 하나를 정하고, 그 나머지와 분류하는것이다. 이걸 <em>class</em> 갯수만큼 진행하면,</p>

<p><img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [23].png" align="center" /> <br />
<img src='http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20' [24].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>위 그림과 같은 경우, <em>class</em> 가 3개기 때문에 <code>(i = 1, 2, 3)</code> 으로 놓으면 <code>i</code> 마다 각각의 <code>hθ^(i)(x)</code> 값, 즉 예측 값을 얻을 수 있다. 따라서 새로운 무언가가 input 으로 들어왔을때, <code>hθ^(i)(x)</code> 값을 최대로 해주는 <code>i</code> 을 선택하면 분류가 된다. <del>참 쉽죠?</del></p>

<h3 id="overfitting">Overfitting</h3>

<p><strong>Overfitting</strong> 은 너무나 많은 <em>feature</em> 가 있을 때는 <em>cost function</em> 이 트레이닝 셋에 잘 맞아 <code>0</code> 에 수렴 하지만, 새로운 데이터가 들어왔을때는 예측을 잘 하지 못하는 경우를 말한다. 다시 말해 <em>hypothesis</em> 가 너무 고차원의 다항식이어서 그렇다. <em>(too many parameters)</em> 즉 아래 그림에서 좌측은 경향을 나타내긴 하지만 모든 트레이닝셋을 경유하는 직선은 만들어내지 못했다. (<em>under fit</em>) 반면 가장 우측은, 트레이닝셋을 모두 경유하는 <em>hypothesis</em> 를 만들어 냈지만, 다항식의 차수가 너무 높아 새로운 데이터가 들어왔을 때 예측하지 못할 수가 있다. <em>can't apply, unable to generalize</em> 교수님은 다음과 같이 슬라이드에 적으셨다.</p>

<blockquote>
  <p>It makes accurate predictions for examples in the training set, but it does not generalize well to make accurate prediction on new, previously unseen examples</p>
</blockquote>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image.png'  align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p><em>logistic regression</em> 에서도 <em>Overfitting</em> 이 발생할 수 있다.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [1].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>주로 <em>training set</em> 이 부족하고 <em>feature</em> 가 많을때 발생하는데 해결책은</p>

<p>(1) <em>feature</em> 를 줄일 수 있다. 수동으로 사용할 <em>feature</em> 를 선택하는 방법과 <em>Model selection algorithm</em> 을 사용할 수도 있다. <br />
(2)  <em>regularization</em> 을 이용한다. 모든 <em>feature</em> 를 유지하지만, 얼마나 각 <em>feature</em> 가 <em>prediction</em> 에 기여할지를 변경한다.</p>

<h3 id="regularizationcostfunction">Regularization, Cost function</h3>

<p><em>Regularization</em> 은 원하는 파라미터가 <em>hypothesis</em> 에 기여하는 바를 조절하는 것이다. 우리가 만약에 <code>0_3</code> 과 <code>0_4</code> 를 최소화 하고 싶다고 하자.  그럼 다음과 같은 식을 만들면 된다. 전체 식의 최소값을 찾는 것이기 때문에, 상수가 <code>1000</code> 인 <code>0_3</code>, <code>0_4</code> 는 <em>0(zero)</em> 에 가까운 수가 나온다. 다시 말해서 이들 두 파라미터가 기여하는 바를 줄인 것이다.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [2].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p><em>parameters</em> 가 작은 값을 가질수록 간단한 <em>hypothesis</em> 가 나오고, <em>overfitting</em> 하지 않는다. 이를 위해 <code>λ</code> 라는 <em>regularization parameter</em> 를 가진 식을 <em>cost function</em> 에 더 붙여 <em>parameter</em> 가 기여하는 바를 조절하면, 아래와 같은 식을 구할 수 있다. 참고로 뒷 부분의 식은  <em>regularization term</em> 이라 부르는데, <code>j</code> 가 1부터 시작하는 것에 주목하자. 이는 <code>0_0</code> 은 <em>regularization</em> 하지 않는다는 의미이다.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [5].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p><code>λ</code> 가 매우 크면 어떻게 될까? <code>0_0</code> 이외의 다른 파라미터는 0에 수렴 하므로, <em>hypothesis</em> 는 상수가 되어 트레이닝 셋에 <em>under fit</em> 할 것이다.</p>

<h3 id="regularizedlinearregression">Regularized Linear Regression</h3>

<p><em>regularization term</em> 으 <code>j</code> 가 1부터 시작하므로, <em>cost function</em> 을 쉽게 계산하기 위해 분리하면 <em>gradient descent</em> 식은 다음과 같이 적을 수 있다.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [6].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<p>이제 위 두 식에서 아래 식을 정리하면, 다음과 같고</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [8].png" align="center" /> <br />
&lt;면 된다. 이때 이 매트릭스의 <code>(0, 0)</code> <br />
위 식에서 앞부분은 아래와 같다. 보통 <code>m</code> 이 매우 크고, <code>a</code> 가 매우 작으므로 위 값은 1보다 작다. 예를 들면 <code>0.99 * 0_j</code> 처럼. </p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [9].png" align="center" /></p>

<p>이제 <em>Normal equation</em> 에 어떻게 적용할지 고려해 보자, 본래 <em>normal equation</em> 식은 아래와 같은데, </p>

<p><img src='http://www.holehouse.org/mlclass/04_Linear_Regression_with_multiple_variables_files/Image%20' [13].png" align="center" /></p>

<p><code>X^T * X</code> 부분에 <code>λ</code> 가 곱해지는 <code>n+1 * n+1</code> 의 <em>matrix</em> 를 곱하면 된다. 이때 이 매트릭스의 <code>(0, 0)</code> 부분이 <code>0</code> 인 것은 <code>0_0</code> 에 <em>regularization</em> 을 적용하지 않기 위한 것.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [10].png" align="center" /></p>

<p>그럼 만약에 <code>X^T * X</code> 가 <em>non-invertible</em> 이라면 어떻게 될까? 이건 지난 시간에 언급했듯이 <em>redundant feature</em> 가 너무 많거나, <code>m &lt;= n</code>, 즉 트레이닝 셋에 비해 <em>feature</em> 가 너무 많을 때 발생한다고 말했다.</p>

<p>놀랍게도, <code>λ &gt; 0</code> 이면, 아래 식에서 <code>X^T * X + λ</code> (λ's (0, 0) = 0) 은 제대로 <em>invertible</em> 함을 증명할 수 있다. 다시 말해서 <em>regularzation</em> 을 통해서 <em>non-invertible</em> 문제도 해결할 수 있다는 것.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [10].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>

<h3 id="regularizedlogisticregression">Regularized Logistic Regression</h3>

<p><em>linear regression</em> 과 마찬가지로 <code>0(theta)</code> 를 0과 1로 분리해 <em>regularization term</em> 을 추가하면 된다. 다른점은 <code>h(x)</code> 가 <em>sigmoid function</em> 의 형태라는 것.</p>

<p>그리고 <em>gradient descent</em> 를 풀기 위해 <em>octave</em> 에서 제공하는 알고리즘들을(<em>conjugate</em>, <em>BFGS</em>, <em>L-BFGS</em> 등) 을 <code>fminunc</code> 이용해서 사용할 수 있다. 이를 위해 언급 했듯이 <code>jval</code> 과 <code>0(theta)</code> 에 대한 <code>graident</code> 를 돌려주는 <em>cost function</em> 을 만들어야 하는데, <em>regularzation term</em> 이 추가되었으므로 해당하는 값을 더해서 각 <code>0</code> 에 대한 <em>gradient</em> 를 계산하는 식을 만들어주면 된다.</p>

<p><img src='http://www.holehouse.org/mlclass/07_Regularization_files/Image%20' [16].png" align="center" />  </p>

<p align="center">(<a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>)</p>  

<p><br/></p>

<h3 id="summary">Summary</h3>

<p>3주째에는 <em>Classification</em> 과 <em>Regularization</em> 에 대해서 배웠다. 수업은 어렵지 않다. 과제가 문제지 ㅠㅠ 교수님. 파이썬으로 과제를 내주셨으면 좀 더 배우는 맛이 있었을텐데요!</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://stats.stackexchange.com/questions/22381/why-not-approach-classification-through-regression' >why-not-approach-classification-through-regression</a> <br />
(2) <a href='http://www.saedsayad.com/artificial_neural_network.htm' >http://www.saedsayad.com</a> <br />
(3) <a href='http://blog.csdn.net/abcjennifer/' >http://blog.csdn.net/abcjennifer/</a> <br />
(4) <a href='http://www.holehouse.org/' >http://www.holehouse.org/</a>  </p>

<p><strong>Machine Learning</strong> by Andrew Ng, <em>Coursera</em></p>]]></description><link>http://1ambda.github.io/machine-learning-week-3/</link><guid isPermaLink="false">a123e443-ef68-426f-81a1-2af9b381d733</guid><category><![CDATA[coursera]]></category><category><![CDATA[machine lerning]]></category><category><![CDATA[regularization]]></category><category><![CDATA[classification]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 15 Oct 2014 13:18:03 GMT</pubDate></item><item><title><![CDATA[Functional Programming in Scala, Chapter 5]]></title><description><![CDATA[<p>지난주엔 Scala 가 <em>리스코프 치환 원칙</em> 을 지키기 위해 어떻게 <em>Variance(공변성)</em> 을 문법적으로 지원하는지 알아보았다. 직접 <code>List</code> 컨테이너를 구현해 보면서 함수의 인자는 <em>Covariant</em>, 리턴타입은 <em>Contravariant</em> 란 것도 알게 되었고, <code>Nil</code> 을 만들기 위해 <code>Nothing</code> 을 어떻게 엮을 수 있는지도 직접 확인해 보았다. 마지막으로, 프로그래머가 가장 많이 작성하는 로직인 <em>Decomposition</em> 을 <em>Pattern Matching</em> 을 이용해 더 우아하게 작성하는법도 배웠다. <del>오오 추상화 오오</del></p>

<p>이번시간에도 <code>List</code> 를 가지고 놀면서 <em>Reduce</em> 의 개념과 Scala 의 <em>Implicit</em> 키워드가 어떤 역할을 하는지 배워본다. </p>

<h3 id="morefunctionsonlists">More Functions on Lists</h3>

<p><code>List.last</code> 는 마지막 원소를 돌려준다. <code>head</code> 나 <code>tail</code> 같은 경우는 상수 시간 내에 리턴되지만, <code>last</code> 는 어떨까? </p>

<pre><code class="scala">def last[T](l: List[T]): T = xs match {  
  case List() =&gt; throw new Error('last of empty list')
  case List(x) =&gt; x
  case y :: ys =&gt; last(ys)
}
</code></pre>

<p>그러므로 길이 <code>n</code> 에 비례하는 성능을 보여준다.</p>

<blockquote>
  <p><code>last</code> takes steps proportional to the length of the list</p>
</blockquote>

<p>마찬가지로 마지막 원소를 제외하고 나머지를 돌려주는 <code>Last.init</code> 경우도 같은 성능을 보여준다. 이렇게 구현할 수 있다.</p>

<pre><code class="scala">  def init[T](xs: List[T]): List[T] = xs match {
    case List() =&gt; throw new Error("init of empty list")
    case List(x) =&gt; List()
    case y :: ys =&gt; y :: init(ys)
  }
</code></pre>

<p><code>concat</code> 은 어떨까? <code>xs</code> 를 받아서 <code>ys</code> 앞에 붙이는 함수다. <code>prepend</code> 함수라 보면 되겠는데, 지난 시간에 논의했었던 <code>:::</code> 랑 같다. </p>

<p>지난 시간에 언급 했듯이 <code>xs ::: ys</code> 처럼 <code>:</code> 로 끝나는 연산자는 우측에 오는것이 실제 좌측 피연산자다. <code>ys .::: (xs)</code> 와 같다.</p>

<pre><code class="scala">  def concat[T](xs: List[T], ys: List[T]): List[T] = xs match {
    case List() =&gt; ys
    case z :: zs =&gt; z :: concat(zs, ys)
  }
</code></pre>

<p>이제, <code>reverse</code> 를 구현 해 보자.</p>

<pre><code class="scala">  def reverse[T](xs: List[T]): List[T] = xs match {
    case List() =&gt; xs
    case y :: ys =&gt; reverse(ys) ++ List(y)
  }
</code></pre>

<p><code>reverse</code> 도 마찬가지로 길이 <code>n</code> 에 <em>quadratic</em> 한 성능을 보여준다. 이는 <code>reverse</code> 내부에서 <code>++</code> 을 사용하기 때문이다. 이는 더 개선할 수 있는데, 후에 논의하겠다.</p>

<p>참고로, <code>++</code> 와 <code>:::</code> 는 하는일은 같으나, <code>:::</code> 는 <code>List</code> 에만 적용 가능하고 <code>++</code> 는 다른 <em>Traversal</em> 에도 적용 가능하다. <a href='http://stackoverflow.com/questions/6559996/scala-list-concatenation-vs' >여기</a> 참조</p>

<p>이제 <code>removeAt</code> 을 구현 해 보자.</p>

<pre><code class="scala">  def removeAt[T](n: Int, xs: List[T]): List[T] = 
    (xs take n) ::: (xs drop n + 1)
</code></pre>

<p><code>flatten</code> 은 다음과 같이 작성할 수 있다.</p>

<pre><code class="scala">  def flatten(xs: List[Any]): List[Any] = xs match {
    case List() =&gt; xs
    case List(y :: ys) =&gt; y :: flatten(ys) 
    case y :: ys =&gt; y :: flatten(ys)
  }
</code></pre>

<h3 id="pairsandtuples">Pairs and Tuples</h3>

<p><code>(3, "example")</code> 과 같은 형태를 <em>Pair</em> 라 부르는데, 이건 사실 <em>Tuple</em> 의 특별한 형태다.</p>

<p><code>(T1, ..., Tn)</code> 은 <code>scala.Tuplen[T1, ..., Tn]</code> 의 <em>parameterized type</em> 이고, <em>expression</em>  <code>(e1, ..., en)</code> 은 사실 <code>scala.Tuplen(e1, ..., en)</code> 과 동일하다.</p>

<p>그리고 <em>tuple</em> 의 패턴 <code>(p1, ..., pn)</code> 은 <em>constructor pattern</em> <code>scala.Tuplen(p1, ..., pn)</code> 과 같다. <code>TupleN</code> 클래스를 구경 해 보자.</p>

<pre><code class="scala">case class Tuple2[T1, T2](_: +T1, _2: +T2) {  
  override def toString = "(" + _1 + "," + _2 + ")"
}
</code></pre>

<p>멤버를 접근할 때 <code>_1</code>, <code>_2</code> 와 같은 식으로 접근하므로, 패턴 매칭에서</p>

<p><code>val (label, value) = pair</code> 는 사실 다음과 같다.</p>

<pre><code class="scala">val label = pair._1  
val value = pair._2  
</code></pre>

<p><em>Tuple</em> 의 패턴 매칭을 이용하면, 다음과 같이 중첩된 <em>case</em> 를 사용하는 <em>merge sort</em> 함수를</p>

<pre><code class="scala">  def msort(xs: List[Int]): List[Int] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[Int], ys: List[Int]): List[Int] = xs match {
        case Nil =&gt; ys
        case x :: xs1 =&gt; ys match {
          case Nil =&gt; xs
          case y :: ys1 =&gt; {
            if (x &gt; y) y :: merge(xs, ys1)
            else x :: merge(xs1, ys)
          }
        }
      }

      val (left, right) = xs splitAt n
      merge(msort(left), msort(right))
    }
  }
</code></pre>

<p>요로코롬 바꿀 수 있다. <del>오오 패턴매칭 오오</del></p>

<pre><code class="scala">  def msort(xs: List[Int]): List[Int] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[Int], ys: List[Int]): List[Int] =
        (xs, ys) match {
          case (xs, Nil) =&gt; xs
          case (Nil, ys) =&gt; ys
          case (x :: xs1, y :: ys1) =&gt;
            if (x &gt; y) y :: merge(xs, ys1)
            else x :: merge(xs1, ys)
        }

      val (left, right) = xs splitAt n
      merge(msort(left), msort(right))
    }
  }
</code></pre>

<h3 id="implicitparameters">Implicit Parameters</h3>

<p><code>Int</code> 뿐만 아니라 우리가 만든 <code>msort</code> 함수를 더 범용적으로 활용할 수 있도록, <em>Currying</em> 을 이용하자.</p>

<pre><code class="scala">  def msort[T](xs: List[T])(lt: (T, T) =&gt; Boolean): List[T] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[T], ys: List[T]): List[T] =
        (xs, ys) match {
          case (xs, Nil) =&gt; xs
          case (Nil, ys) =&gt; ys
          case (x :: xs1, y :: ys1) =&gt;
            if (lt(x, y)) x :: merge(xs1, ys)
            else y :: merge(xs, ys1)
        }

      val (left, right) = xs splitAt n
      merge(msort(left)(lt), msort(right)(lt))
    }
  }
</code></pre>

<p>아래는 테스트코드</p>

<pre><code class="scala">  "msort" should "return an ordered list" in {
    val xs = List(4, 2, 7, 1, 11, 9, 3)
    val ys = List(10, 9, 8, 7, 6)

    assert(msort(xs)((x: Int, y: Int) =&gt; x &lt; y) == List(1, 2, 3, 4, 7, 9, 11))
    assert(msort(ys)((x: Int, y: Int) =&gt; x &lt; y) == List(6, 7, 8, 9, 10))
  }
</code></pre>

<p>참고로 <code>msort</code> 에 <code>Int</code> 인자를 주는 경우, <code>x: Int, y: Int</code> 처럼 타입을 명시하지 않아도 알아서 <code>xs</code> 를 보고 추론한다.</p>

<h4 id="parameterizationwithordered">Parameterization with Ordered</h4>

<p>사실은 <code>scala.math.Othering[T]</code> 에 <em>ordering</em> 을 나타낼 수 있는 클래스가 있다. 이를 활용하면 <code>msort</code> 를 다음과 같이 리팩토링 할 수 있다. </p>

<pre><code class="scala">  def msort[T](xs: List[T])(ord: Ordering[T]): List[T] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[T], ys: List[T]): List[T] =
        (xs, ys) match {
          case (xs, Nil) =&gt; xs
          case (Nil, ys) =&gt; ys
          case (x :: xs1, y :: ys1) =&gt;
            if (ord.lt(x, y)) x :: merge(xs1, ys)
            else y :: merge(xs, ys1)
        }

      val (left, right) = xs splitAt n
      merge(msort(left)(ord), msort(right)(ord))
    }
  }
</code></pre>

<p>테스트 코드는,</p>

<pre><code class="scala">  "msort" should "return an ordered list" in {
    val xs = List(4, 2, 7, 1, 11, 9, 3)
    val ys = List(10, 9, 8, 7, 6)
    val zs = List("pineapple", "apple", "banana", "watermelon")

    assert(msort(xs)(Ordering.Int) == List(1, 2, 3, 4, 7, 9, 11))
    assert(msort(ys)(Ordering.Int) == List(6, 7, 8, 9, 10))
    assert(msort(zs)(Ordering.String) == List("apple", "banana", "pineapple", "watermelon"))
  }
</code></pre>

<p>다 좋은데, <code>Ordering.Int</code> 인자 자체를 숨겨버렸으면 좋겠다. <code>msort</code> 의 <code>ord</code> 파라미터를 다음과 같이 변경하자. <code>(implicit ord: Ordering[T])</code></p>

<pre><code class="scala">  def msort[T](xs: List[T])(implicit ord: Ordering[T]): List[T] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[T], ys: List[T]): List[T] =
        (xs, ys) match {
          case (xs, Nil) =&gt; xs
          case (Nil, ys) =&gt; ys
          case (x :: xs1, y :: ys1) =&gt;
            if (ord.lt(x, y)) x :: merge(xs1, ys)
            else y :: merge(xs, ys1)
        }

      val (left, right) = xs splitAt n
      merge(msort(left), msort(right))
    }
  }
</code></pre>

<p>테스트 코드는 아래와 같다.</p>

<pre><code class="scala">  "msort" should "return an ordered list" in {
    val xs = List(4, 2, 7, 1, 11, 9, 3)
    val ys = List(10, 9, 8, 7, 6)
    val zs = List("pineapple", "apple", "banana", "watermelon")

    assert(msort(xs) == List(1, 2, 3, 4, 7, 9, 11))
    assert(msort(ys) == List(6, 7, 8, 9, 10))
    assert(msort(zs) == List("apple", "banana", "pineapple", "watermelon"))
  }
</code></pre>

<p>놀랍게도, 파라미터가 사라져버렸다. ~오오 스칼라 오오~ <code>implicit</code> 하나만 추가했을 뿐인데! <code>implicit</code> 를 파라미터 타입에 추가하면 아래처럼 해석된다.</p>

<p>타입 <code>T</code> 인 <code>implicit</code> 파라미터에 대해서,</p>

<p>(1) <code>implicit</code> 이며 <br />
(2) <code>T</code> 와 호환 가능한 타입을 가지고 있고 <br />
(3) <em>function call</em> 내에서 찾을 수 있거나 <br />
(4) 혹은 <code>T</code> 와 관련된 <em>companion object</em> 내에 있는</p>

<p><em>single definition (most specific)</em> 이 있는지 컴파일러가 찾는다. 파라미터로 사용하고 아니면, 에러를 뿜는다. </p>

<p>즉 위의 코드의 경우 <code>Ordering[String]</code> 와 <code>Ordering[Int]</code> 는 어딘가에 <code>implicit</code> 로 처리되어 이미 존재한다. </p>

<h3 id="higherorderlistfunctions">Higher-Order List Functions</h3>

<p><code>List</code> 에 사용하는 메소드들은 종종 <em>반복된 패턴 (recurring patterns)</em> 을 가지는데, 3가지로 요약해 보면 아래와 같다.</p>

<blockquote>
  <p>(1) transformaing each element in a list ina certain way <br />
  (2) retrieving a list of all elements satisfying a criterion <br />
  (3) combining the elements of a list using an operator</p>
</blockquote>

<p>함수형 언어는, <em>higher-order function</em> 이용해서 <em>generic function</em> 을 만들 수 있다.</p>

<h4 id="map">Map</h4>

<p>리스트의 모든 원소에 함수 <code>f</code> 를 <em>적용 (Applying)</em> 하는 <em>고차 함수 (Higher-Order Function)</em> 은 <code>map</code> 이다.</p>

<pre><code class="scala">abstract class List[T] {  
  ...
  def map[T](f: T =&gt; U): List[U] = this match {
    case Nil =&gt; this
    csae x :: xs =&gt; f(x) :: xs.map(f)
  }
  ...
}
</code></pre>

<p>실제로 <code>map</code> 은 좀 더 복잡한데, <em>tail-recursion</em> 과 다양한 종류의 <em>collection</em> 을 지원하기 위함이다.</p>

<h4 id="filter">Filter</h4>

<pre><code class="scala">abstract class List[T] {  
  ...
  def filter(p: T =&gt; Boolean): List[T] = this match {
    case Nil =&gt; this
    case x :: xs =&gt; if (p(x)) x :: xs.filter(p) else xs.filter(p)
  }
  ...
}
</code></pre>

<p>이외에도 <code>filterNot</code> 과 <code>partition</code>이 있다. <code>partition</code> 은 <code>filter</code> 와  <code>filterNot</code> 의 결과를 둘 다 돌려준다.</p>

<p><code>takeWhile</code> 은 일치하지 않는 곳에서 <em>filtering</em> 을 멈추고, 그 전까지의 결과를 돌려준다. 반대로 <code>dropWhile</code> 은 <code>takeWhile</code> 에서 취해진 결과 이외의 나머지를 돌려준다. </p>

<pre><code class="scala">scala&gt; val zs = List(2, -4, 1, 4, 7)  
zs: List[Int] = List(2, -4, 1, 4, 7)

scala&gt; zs partition(x =&gt; x &gt; 0)  
res38: (List[Int], List[Int]) = (List(2, 1, 4, 7),List(-4))

scala&gt; zs dropWhile(x =&gt; x &gt; 0)  
res39: List[Int] = List(-4, 1, 4, 7)

scala&gt; zs takeWhile(x =&gt; x &gt; 0)  
res40: List[Int] = List(2)

scala&gt; zs span(x =&gt; x &gt; 0)  
res41: (List[Int], List[Int]) = (List(2),List(-4, 1, 4, 7))  
</code></pre>

<p><code>takeWhile</code>, <code>dropWhile</code> 을 이용하면 다음과 같은 <code>pack</code> 함수도 만들 수 있다.</p>

<pre><code class="scala">  def pack[T](xs: List[T]): List[List[T]] = xs match {
    case Nil =&gt; Nil
    case x :: xs1 =&gt; 
      xs.takeWhile(y =&gt; y == x) :: pack(xs.dropWhile(y =&gt; y == x))
  }
</code></pre>

<p>아래는 테스트코드</p>

<pre><code class="scala">  val ts = List("a", "a", "b", "c", "c", "a")
  val ss = List(List("a", "a"), List("b"), List("c", "c"), List("a"))

  "pack" should "return a packed list" in {
    assert(pack(ts) == ss)
  }
</code></pre>

<h3 id="reductionoflists">Reduction of Lists</h3>

<p><code>reduce</code> 는 리스트의 모든 원소에 특정 연산을 수행해 하나의 결과를 만들어 내고 싶을 때 사용한다.</p>

<pre><code class="scala">  def sum(xs: List[Int]) = (0 :: xs) reduceLeft((x, y) =&gt; x + y)
  def product(xs: List[Int]) = (1 :: xs) reduceLeft((x, y) =&gt; x * y)
</code></pre>

<p>사실 <code>reduceLeft</code>, <code>reduceRight</code> 를 기억하는 쉬운 방법은, <em>왼쪽으로 / 오른쪽으로 기운 트리</em> 를 기억하는 것이다. </p>

<p><img src='https://joelneely.files.wordpress.com/2011/03/foldleftplain.jpg?w=219&amp;h=325'  align="center" />  </p>

<p align="center"><a href='https://joelneely.wordpress.com/' >https://joelneely.wordpress.com/</a></p>

<p><code>reduce</code> 와 비슷하지만 초기 인자를 받아 <em>empty-list</em> 에 대해서도 호출될 수 있는 <code>fold</code> 가 있다.</p>

<pre><code class="scala">abstract class List[T] {  
  ...
  def reduceLeft(op (T, T) =&gt; T): T = this match {
    case Nil =&gt; throw new Error("Nil.reduceLeft")
    case x :: xs =&gt; (xs foldLeft x)(op)
  }

  def foldLeft[U](z: U)(op: (U, T) =&gt; U): U = this match {
    case Nil =&gt; z
    case x :: xs =&gt; (xs foldLeft op(z, x))(op)
  }
  ...
}
</code></pre>

<p><br/> <br />
<code>foldRight</code> 는 <em>오른쪽으로 기운 트리</em> 를 생각하면 된다.</p>

<p><img src='https://joelneely.files.wordpress.com/2011/03/foldrightplain.jpg?w=219&amp;h=325'  align="center" />  </p>

<p align="center"><a href='https://joelneely.wordpress.com/' >https://joelneely.wordpress.com/</a></p>

<pre><code class="scala">def reduceRight(op: (T, T) =&gt; T): T = this match {  
  case Nil =&gt; throw new Error("Nil.reduceRight")
  case x :: Nil =&gt; x
  case x :: xs =&gt; op(x, xs.reduceRight(op))
}

def foldRight[U](z: U)(op: (T, U) =&gt; U): U = this match {  
  case Nil =&gt; z
  case x :: xs =&gt; op(x, (xs foldRight z)(op))
}
</code></pre>

<p><code>foldLeft</code> 와 <code>foldRight</code> 는 같은 일을 하긴 하는데, 때때로는 둘 중 하나만 적절한 경우도 있다. 예를 들어</p>

<pre><code class="scala">def concat[T](xs: List[T], ys: List[T]): List[T] =  
  (xs foldRight ys)(_ :: _)
</code></pre>

<p><code>foldRight</code> 대신에 <code>foldLeft</code> 가 오면 어떻게 될까? <em>타입 에러</em> 가 발생한다. <code>3 :: List(4)</code> 는 가능해도 <code>List(3) :: 4</code> 는 불가능하기 때문이다. </p>

<h3 id="reasoningaboutconcat">Reasoning About Concat</h3>

<blockquote>
  <p>We would like to verify that concatenation is associative, and that it admits the empty list <code>Nil</code> as neutral element to the left and to the right</p>
</blockquote>

<p>이번장에서는 <em>natural indction</em> 과 비슷한 <em>structural induction</em> 을 이용해 함수형 프로그래밍에서 어떻게 함수의 정확성을 증명할 수 있는지 배운다.</p>

<p>함수형 프로그래밍에선 <em>side-effect</em> 가 없기 때문에, <em>reduction step</em> 이 전체나, 부분이나 동일하게 적용된다. 이걸 다른말로 <em>참조 투명성 (referential transparency)</em> 라고 부른다. 혹시 몰라 원문을 첨부 하자면,</p>

<blockquote>
  <p>Note that a proof can freely apply reduction steps as equalities to some part of a term <br/></p>
  
  <p>That works because pure functional programs don't have side effects so that a term is equivalent to the terms to the term to which it reduces.</p>
  
  <p>This principle is called referential transparency.</p>
</blockquote>

<h4 id="structuralinduction">Structural Induction</h4>

<p><em>property</em> <code>P(xs)</code> 를 모든 <code>xs</code> 에 대해 증명하기 위해</p>

<p>(1) show that <code>P(Nil)</code> holds (Base case) <br />
(2) for a list <code>xs</code> and some element <code>x</code>, show the <em>induction step:</em> <br />
if <code>P(xs)</code> holds, then <code>P(x :: xs)</code> also holds</p>

<p>우리는 <code>(xs ++ ys) ++ zs = xs ++ (ys ++ zs)</code> 를 증명하고 싶다. 이를 위한 <code>concat</code> 함수는</p>

<pre><code class="scala">def concat[T](xs: List[T], ys: List[T]) = xs match {  
  case List() =&gt; ys
  case x :: xs1 =&gt; x :: concat(xs1, ys)
}
</code></pre>

<p>이 <code>concat</code> 의 정의로 부터 두 가지 사실을 뽑아낼 수 있다. (distill two defining clauses)</p>

<p>(1) <code>Nil ++ ys = ys</code> <br />
(2) <code>(x :: xs1) ++ ys = x :: (xs1 ++ ys)</code></p>

<p>이제 먼저 <em>Base-case</em> 인 <code>Nil</code> 에 대해 먼저 참임을 보이면 된다.</p>

<p><code>(Nil ++ ys) ++ zs = Nil ++ (ys ++ zs)</code> </p>

<blockquote>
  <p>좌변은 (1) 에 의해 <code>ys ++ zs</code> 이고
  우변도 (1) 에 의해 <code>ys ++ zs</code> 이다.</p>
</blockquote>

<p>이제 <code>P(xs)</code> 가 참일때 <code>P(x :: xs)</code> 임을 보이면 된다. 먼저 좌변부터 하면</p>

<p>= <code>((x :: xs) ++ ys) ++ zs</code> by (2) <br />
= <code>(x :: (xs ++ ys)) ++ zs</code> by (2) <br />
= <code>x :: ((xs ++ ys) ++ zs)</code> by (2) <br />
= <code>x :: (xs ++ (ys ++ zs))</code> by <em>induction hypothesis</em> (<code>P(xs)</code>) </p>

<p>우변을 정리하면,</p>

<p>= <code>(x :: xs) ++ (ys ++ zs)</code> by (2) <br />
= <code>x :: (xs ++ (ys ++ zs))</code>  </p>

<p>우변과 좌변이 같으므로, <code>P</code> 는 성립한다.</p>

<h3 id="alargerequationalproofonlists">A Larger Equational Proof on Lists</h3>

<p>이제 <code>reverse</code> 의 <code>xs.reverse.reverse = xs</code> 라는 속성을 증명해 보자. 다음 2개의 <em>clause</em> 를 알고 있다. (교수님이, 좀 더 <em>amenable</em> 하기 때문에 비 효율적인 정의를 골랐다고 하심.)</p>

<p>(1) <code>Nil.reverse</code> = <code>Nil</code> <br />
(2) <code>(x :: xs).reverse</code> = <code>xs.reverse</code> ++ <code>List(x)</code>  </p>

<p><em>Base-case</em> 는 패스하고, 바로 <code>x :: xs</code> 에 대한 것 부터 들어가면 좌변은  </p>

<p><code>(x :: xs).reverse.reverse</code> <br />
= <code>(xs.reverse ++ List(x)).reverse</code></p>

<p>우변은</p>

<p><code>x :: xs</code> <br />
= <code>x :: xs.reverse.reverse</code>  </p>

<p>이걸로는 할 수 있는게 없으므로 <code>xs.reverse</code> 를 <code>ys</code> 라 놓으면</p>

<p><code>(ys ++ List(x)).reverse</code> = <code>x :: ys.reverse</code> 를 증명하면 된다. <em>Auxiliary Equation</em> 인데, 먼저 <em>Base-case</em> 부터 참임을 보이면 </p>

<p>좌변은</p>

<p><code>(Nil ++ List(x)).reverse</code> <br />
= <code>List(x).reverse</code> // ++ clause 1 <br />
= <code>(x :: Nil).reverse</code> // List Definition <br />
= <code>Nll.reverse ++ List(x)</code> // reverse clause 2 <br />
= <code>Nil ++ List(x)</code> // reverse clause 1 <br />
= <code>x :: Nil</code> // List Definition  </p>

<p>우변은</p>

<p><code>x :: Nil.reverse</code> <br />
= <code>x :: Nil</code> // reverse clause 1  </p>

<p>이제 <code>((y :: ys) ++ List(x)).reverse</code> 와 <code>x :: (y :: ys).reverse</code> 가 같음을 보이면 된다.</p>

<p><code>((y :: ys) ++ List(x)).reverse</code> <br />
= <code>(y :: (ys ++ List(x)).reverse</code> // ++ clause 2 <br />
= <code>(ys ++ List(x)).reverse ++ List(y)</code>  // reverse clause 2 <br />
= <code>(x :: ys.reverse) ++ List(y)</code>  // <em>induction hypothesis</em> <br />
= <code>x :: (ys.reverse ++ List(y)</code>  // reverse clause 2 <br />
= <code>x :: (y : ys).reverse</code> </p>

<p>이것은 우변 <code>x :: (y :: ys).reverse</code> 와 동일하므로 <em>Auxiliary equation</em> 이 성립하고, 본래의 성질 <code>xs = xs.reverse.reverse</code> 도 성립한다.</p>

<h4 id="exercise">Exercise</h4>

<p><code>map</code> 을 증명하라고 주시는데, 못해먹겠다 -_-; 패쓰!</p>

<h3 id="summary">Summary</h3>

<p><em>Reduction</em>, <em>Fold</em>, <em>referential transparency</em> 그리고 <em>structural induction</em> 에 대해서 배웠다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://stackoverflow.com/questions/6559996/scala-list-concatenation-vs' >scala-list-concatenation-vs</a></p>

<p>2014-10-14, <strong>Functional Programming in Scala</strong>, Coursera</p>]]></description><link>http://1ambda.github.io/functional-programming-in-scala-chapter-5/</link><guid isPermaLink="false">a94afb0b-63a0-4cd9-8a0e-2224ff29fea2</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[functional programming]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 14 Oct 2014 10:48:03 GMT</pubDate></item><item><title><![CDATA[Analysis of Algorithms]]></title><description><![CDATA[<p><strong>Analysis of Algorithms</strong>, by <em>Kevin Wayne</em>, <em>Robert Sedgewick</em> in Coursera </p>

<p>알고리즘을 분석해야 하는 이유는 </p>

<p>(1) Predict performance <br />
(2) Compare algorithms <br />
(3) Provide guarantees <br />
(4) Understand theoretical basis  </p>

<p>그 중에서도 <em>performance bug</em> 를 피하는 것이 무엇보다 중요하다. 이를 통해 내 알고리즘이 <em>practical large input</em> 에 적용할 수 있을까? 고민하는 것이, 알고리즘 분석의 주된 동기다.</p>

<h3 id="observations">Observations</h3>

<p>주어진 배열에서 3개를 골라 더했을때 0이 나오는 <em>3-Sum</em> 문제를 고려해 보자. </p>

<pre><code class="java">for (int i = 0; i &lt; N; i++)  
  for(int j = i + 1; j &lt; N; j++)
    for(int k = j + 1; k &lt; N; k++) 
      if (array[i] + array[j] + array[k] == 0)
        count++;        
</code></pre>

<p>입력 대비 출력 시간을 <em>log-log plot</em> 으로 만들어, <code>y = a * N^b</code> 를 얻을 수 있다. 이것 보다 더 빠르게 찾는 방법은 <em>input</em> 을 두배씩 늘려가면서 로그 비율을 찾는 방법인데, <em>Doubling hypothesis</em> 라 부른다. 이 경우 <code>b</code> 가 3이 나오는걸 확인할 수 있다.</p>

<p>샘플 데이터가 다음과 같다고 하자. (Matlab format)</p>

<pre><code class="matlab">x = [  
1000;  
2000;  
4000;  
8000;  
16000;  
32000;  
64000]

y = [  
0.0;  
0.0;  
0.1;  
0.3;  
1.3;  
5.1;  
20.5]  
</code></pre>

<p>이 경우 수가 클때, 4배씩 증가하므로 <em>2-based log ratio</em> 는 <code>2</code> 다. 따라서 <code>a * N^b</code> 에서 <code>b</code> 를 2로 가정하면, <code>5.1 / 32000^2</code> 하면, 대략 <code>5.0 * 10^-9</code></p>

<h3 id="mathematicalmodels">Mathematical Models</h3>

<p>사실 <em>Running time</em> 에 있어서 연산의 수행 시간은 컴퓨터마다, 또 연산마다 다르므로 이것을 제하고 <em>operation number</em>, <em>frequency</em> 의 곱을 <em>input number</em> <code>N</code> 을 이용하여 표현한 모델을 이용할 수 있다. 예를 들어 <em>1-Sum</em> 코드의 경우</p>

<pre><code class="java">int count = 0;  
for (int i = 0; i &lt; N; i++)  
  if (array[i] == 0)
    count++;
</code></pre>

<blockquote>
  <p>variable declaration = 2 <br />
  assignment = 2 <br />
  less then compare = N + 1 <br />
  equal to compare = N <br />
  array access = N <br />
  increment = N to 2N</p>
</blockquote>

<p><em>2-Sum</em> 코드의 경우 </p>

<pre><code class="java">int count = 0;  
for (int i = 0; i &lt; N; i++)  
  for(int j = i + 1; j &lt; N; j++)
    if (array[i] + array[j] == 0)
      count++;
</code></pre>

<blockquote>
  <p>variable declaration = 2 + N 
  assignment = 2 + N
  less then compare = 1/2 * (N + 1) * (N + 2) <br />
  equal to compare = 1/2 * N * (N - 1) <br />
  array access = N * (N - 1) <br />
  increment = 1/2 * N * (N - 1) to N * (N - 1)</p>
</blockquote>

<p>세 보면 알겠지만 정말 귀찮다. 세야할 연산의 종류도 많고. 그렇기 때문에, <em>running-time</em> 을 간단히 추정하기 위해</p>

<p>(1) Use some basic operation as a proxy for running time <br />
(2) tilde notation: ignore lower order terms  </p>

<p>따라서 <em>2-Sum</em> 의 경우 유효한 연산을 배열 접근으로 잡으면, 연산 회수는 <code>~N^2</code> 이고 <em>3-Sum</em> 은 <code>~ 1/6 * N^3</code> 이다.</p>

<p><em>discrete sum</em> 을 편하게 계산하는 법이 있는데, 시그마를 적분으로 바꿔, 계산하면 된다. 따라서 <code>1 + 2 + ... + N</code> 은 <code>1/2 * N</code>, <code>1 + 1/2 + 1/3 + ... + 1/N</code> 은 <code>ln N</code>, </p>

<p><em>3-Sum</em> 의 <em>triple loop</em> 는 <code>N * 1/2 N* 1/3 N</code> 이므로, <code>~1/6 N</code> 이다. 여기에 3번의 Array Access 가 일어나므로 곱하면 <em>3-Sum</em> 은 <code>~1/2 N</code>이다.</p>

<pre><code class="java">int sum = 0;  
for (int i = 0; i &lt; N; i++)  
  for (int j = i; j &lt; N; j++)
    for (int k = 1; k &lt; N; k = k * 2)
      if (a[i] + a[j] &gt;= a[k]) sum++;
</code></pre>

<p>모든 <em>triple loop</em> 가 <code>~n^3</code> 을 가지는건 아니다. 위의 코드의 경우 <code>~ 1/2 N^2 * 3 lg  N</code> 이다.</p>

<h3 id="orderofgrowthclassification">Order of Growth Classification</h3>

<p><code>1</code> &lt; <code>lg N</code> &lt; <code>N</code> &lt; <code>N lg N</code> &lt; <code>N^2</code> &lt; <code>N^3</code> &lt; <code>2^N</code> 우측으로 갈 수록 알고리즘의 성능이 나쁘다. 일반적으로는 <code>N lg N</code> 이 쓸 수 있는 알고리즘이다. 좀 더 알아보자면, </p>

<blockquote>
  <p><strong>log N:</strong> N 이 절반으로 나누어지는 <em>binary search</em> 등 <br />
  <strong>N log N:</strong>, <em>divide and conquer: merge sort</em> 등 <br />
  <strong>2^N:</strong> 서브트리를 모두 검사하는 <em>exhaustive search</em> 등  </p>
</blockquote>

<p>알고리즘의 성능을 비교하기 위해 <code>T(2N) / T(N)</code> 을 구할 수 있는데, </p>

<p>(1) <code>N</code> 은 <code>2</code> (따라서 lg 2 = 1 이므로, <code>N^1</code> 이다.) <br />
(2) <code>N^2</code> 은 <code>4</code> <br />
(3) <code>N^3</code> 같은 경우 <code>8</code> 이다. 
(4) <code>2^N</code> 은 <code>T(N)</code> 이다.</p>

<p>잠깐 <code>~lg N</code> 의 복잡도를 가지는 <em>Binary Search</em> 에 대해 이야기 해 보자.</p>

<h4 id="binarysearch">Binary Search</h4>

<p>이진트리에 대해 재밌는 사실이 하나 있다. 이진트리가 나온건 1946년인데, 놀랍게도 버그가 없는 버전은 1962년에 처음 나왔다. 그리고 자바의 <code>Arrays.binarySerach()</code> 도 2006년에 버그가 발견되었다. 아래의 코드에서 만약 <code>arr</code> 에 <code>[1]</code> 을 넣고, <code>key</code> 에 <code>1</code> 을 주면 어떻게 될지 한번 생각 해 보자.</p>

<pre><code class="java">public static int binarySearch(int[] arr, int key) {  
  int low = 0, high = arr.length - 1;

  while (low &lt;= high) {
    int mid = low + (high - low) / 2;

    if (key &lt; arr[mid]) high = mid - 1; // 3-way compares
    else if (key &gt; arr[mid]) low = mid + 1;
    else return mid
  }

  return -1;
}
</code></pre>

<p><em>binary search</em> 를 <em>2-way compare</em> 로 구현하면, 다시 말해 <code>if-else</code> 만 이용하면 <code>1 + lg N</code> 의 복잡도를 가지게 된다. 이는 <code>T(N) &lt;= 1 + T(N/2)</code> , <code>T(N) &lt;= 1 + 1 + T(N/4)</code>, ... <code>T(N) = 1 + 1 + ... + T(N/N)</code> 이기 때문이다.</p>

<p><em>binary search</em> 가 <code>1 + lg N</code> 이라는 사실을 이용하면 <em>3-Sum</em> 을 <code>N^2 lg N</code> 으로 개선할 수 있다.</p>

<p>(1) sorting: <code>N^2</code> <br />
(2) binary search for <code>-(arr[i] + arr[j])</code>  : <code>N^2 log N</code>  </p>

<p>두번째 스탭에서 <code>i</code>, <code>j</code> 에 대해 이진탐색을 시도하므로 <code>N^2 * log N</code> 이다.</p>

<h3 id="theoryofalgorithms">Theory of Algorithms</h3>

<p>이제 <strong>Best case(lower bound on cost)</strong>, <strong>Worst case(upper bound on cost)</strong>, <strong>Average case(expected cost)</strong> 를 고려 해 보자</p>

<p>이를 위해 새로운 <em>notation</em> 을 도입할 수 있다. 교수님이 해주시는 설명을 솔직히 못 알아 듣겠다. 그냥 <em>big theta</em>, <em>big omega</em>, <em>big oh</em> 에 대해 구글링 해서 나오는 <a href='http://stackoverflow.com/questions/471199/what-is-the-difference-between-%CE%98n-and-on' >SO 답변</a> 을 참조했다.</p>

<p>먼저 <strong>asymptotic</strong> 이란 말을 이해해야 하는데 한국어로 표현하면 <em>점근적</em> 정도가 된다. <del>m 은 묵음</del></p>

<blockquote>
  <p>If an algorithm is of Θ(g(n)), it means that the running time of the algorithm as n (input size) gets larger is proportional to g(n).</p>
  
  <p>If an algorithm is of O(g(n)), it means that the running time of the algorithm as n gets larger is at most proportional to g(n).</p>
  
  <p>More technically, O(n) represents upper bound. Θ(n) means tight bound. Ω(n) represents lower bound.</p>
</blockquote>

<p>우리가 어떤 알고리즘이 <code>O(n)</code> 이라고 할 때 <code>O(n^2)</code>, 혹은 <code>O(n^3)</code> 이라고 말할 수 있다. <em>upper bound</em> 니까. 하지만 어떤 알고리즘(<code>f(n)</code>) 이 <code>Θ(n)</code> 일때, <code>Θ(n^2)</code> 이라 말할 순 없다. 그리고 <em>Big-Oh</em> 와 <em>Big-theta</em> 가 존재 해야 <em>Big-omega</em> 가 존재한다.</p>

<blockquote>
  <p>f(x) = Θ(g(x)) iff f(x) = O(g(x)) and f(x) = Ω(g(x))</p>
</blockquote>

<p>이런 표기법을 이용하는 이유는, 다시 말해서 <em>Theory of algorithm</em> 의 목적은 <em>optimal algorithm</em> 을 찾는데 있다. </p>

<p><em>1-sum</em> 을 예로 들어 보자. <em>upper bound</em> 는, 모든 원소를 찾는 것이다. 따라서 <code>O(n)</code>.  적어도 모든 원소를 한번씩은 다 뒤져봐야 하므로, <em>lower bound</em> 는 <code>Ω(n)</code> 이다. 따라서 두개가 <em>constant factor</em> 내에서 같으므로 <code>Θ(n)</code> 이다.</p>

<p><em>3-sum</em> 을 고려해 보자. <em>upper bound</em> 는 <code>O(n^2 * lg n)</code> 이다. <em>lower bound</em> 는 확실힌 모르겠지만 적어도 모든 원소를 한번씩은 훑어야 하므로 <code>Ω(n)</code> 다. <a href='http://cstheory.stackexchange.com/questions/14585/lower-bounds-for-3sum-with-a-free-cache' >여기</a> 보면 <em>3-sum</em> 의 <em>lower bound</em> 에 관한 논의가 있다.</p>

<p>따라서 <em>3-sum</em> 에 대한 확실한 <em>lower bound</em> 를 모르므로, <em>upper bound</em> 와의 갭이 있고, 아직까진 <em>optimal algorithm</em> 이 무엇인지 알 수 없다.</p>

<p>따라서 알고리즘을 디자인하는 접근 방법은,</p>

<p>(1) Develop an algorithm <br />
(2) Prove a lower bound</p>

<p>그리하여, <em>lower bound</em> 와 <em>upper bound</em> 사이의 갭이 있다면 <em>lower bound</em> 를 증가시키는 새로운 알고리즘이 여지가 있다. 그걸 찾아내면서 <em>lower bound</em> 를 올려가면 <em>optimal algorithm</em> 을 찾을 수 있다. </p>

<p>1970년대에는 <em>upper bound</em> 를 줄여왔지만, </p>

<p>(1) 너무 <em>worst case</em> 에만 집중헀고 <br />
(2) 이제 더 정확한 성능 측정을 위해서 <em>to within a constant factor</em> 보다 더 좋은 무언가가 필요하다.</p>

<p>그리고 많은 사람들이 <em>Big o</em> 를 <em>approximate model of running time</em> 으로 번역하는 실수를 저질렀는데, 이 수업에서는 <em>Big o</em> 대신 <em>tilde(~)</em> 를 사용하겠다.</p>

<p><img src='http://qlx.is.quoracdn.net/main-ce94d194dc6a85d3.png'  align="center" /></p>

<p align="center">If</p>

<p><img src='http://qlx.is.quoracdn.net/main-30ac99d6624fcf8c.png'  align="center" /></p>

<h3 id="memory">Memory</h3>

<p>자바에서는 다음과 같은 오버헤드가 있다.</p>

<p>(1) <code>N</code> 개의 1차원 배열을 만들때는 <em>Type * N + 24 Bytes</em> <br />
(2) <em>Object</em> 는 <em>16 Bytes</em> <br />
(3) <em>Reference</em> 는 <em>8 Bytes</em> <br />
(4) 각 오브젝트는 <em>8 Bytes</em> 단위로 패딩된다.</p>

<p><strong>String</strong> 은 조금 더 복잡한데,</p>

<p>오브젝트 오버헤드, <code>char</code> 배열 오버헤드(<code>2N + 24</code>)와 함께 <code>offset</code>, <code>count</code>, <code>hash</code> 를 <code>int</code> 타입으로 가지므로 <em>12 Bytes</em> 와 패딩이 포함된다.</p>

<p><em>inner class</em> 가 있다면 <em>Object</em> 에 <em>8 bytes</em> 의 메모리가 더 필요하다.</p>

<pre><code class="java">public class WeightedQuickUnionUF {  
  private int[] id;
  private int[] sz;
  private int count;

  ...
}
</code></pre>

<p>위 클래스를 인스턴스로 가지고 있을 경우엔 <code>N</code> 에 대해서</p>

<p>(1) 16 bytes <em>object overhead</em> <br />
(2) 8 + (4N + 24) for each <em>int[] array</em> <br />
(3) 4 bytes for <code>count</code> <br />
(4) 4 bytes padding</p>

<p>따라서 <code>8N + 88</code> 이므로 <code>~8 N</code> 이다.</p>

<h3 id="summary">Summary</h3>

<p><strong>Empirical analysis</strong> 은 실제로 프로그램을 돌려 성능을 얻은 다음 가설을 새워 예측하는 방법이다. 반면 <strong>Mathematical analysis</strong> 는 알고리즘을 분석해 연산 횟수에 기반한 모델을 새우는 방법이다. </p>

<blockquote>
  <p>Emplirical analysis model enables us to <strong>make predictions</strong> and necessary to validate mathematical models</p>
  
  <p>Mathematical analysis model enables us to <strong>explain behavior</strong> and is independent of a particular system. </p>
</blockquote>]]></description><link>http://1ambda.github.io/analysis-of-algorithms/</link><guid isPermaLink="false">3e2611a4-8600-4397-bef5-ea6d0245d660</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 11 Oct 2014 06:35:32 GMT</pubDate></item><item><title><![CDATA[Programming Language, Week1]]></title><description><![CDATA[<p><strong>Programming Language</strong> by <em>Dan Grossman</em>, Coursera</p>

<p><em>Coursera</em> PL 클래스인데 과제 마감기한도 까다롭고, 동료평가도 있고, 여러모로 조금 빡세다. 유일한 낙은 언어의 다양한 특징들을 탐구하기 위해 <strong>ML</strong> 을 사용하고 <del>오오 갓 ML</del> , emacs 를 사용한다는 건데.. 잘 버틸수 있을까 의심스럽다. 무려 첫 강의부터 대략 300분이 넘는 동영상을 올려주시는 교수님 -_-;</p>

<p>미국 CS 전공자들은 모두 이렇게 빡세게 배우는가요 ㅠㅠ?</p>

<p><code>SML/nj</code> 와 Emacs 에 <code>sml-mode</code> 설치 후 시작한다. <code>c-c, c-s</code> 는 <code>REPL</code> 을 켠다. </p>

<h3 id="mlvariablebindingsandexpressions">ML Variable Bindings and Expressions</h3>

<pre><code class="sml">(* This is a comment. *)

val x = 34;  
(*: static env: x : int *)
(*: dynamic env: x --&gt; 34 *)
val y = 35 : int;  
val z = (x + y) + (y + 2);  
</code></pre>

<p>각 라인마다, <em>dynamic environment</em> 에 바인딩을 하나씩 추가한다. 따라서 세번 째 라인에서 <code>x</code> 와 <code>y</code> 를 <code>z</code> 를 바인딩하기 위해 사용할 수 있다.</p>

<p>그리고, <em>dynamic env</em> 에 바인딩을 추가하기 전에 <em>static enviornment</em> 에 <em>Type</em> 을 추가한다. 맨 처음엔 <code>x: int</code> 가 추가되고 <code>y</code> 와 값이 바인딩 되기 전에는 <code>x: int, y: int</code> 가 <em>static env</em> 에 추가된다.</p>

<p>따라서 매 라인마다 <em>type checking</em> 이 먼저 일어나고 그 후에야 프로그램이 <em>evaluated (excuted)</em> 된다. </p>

<p><em>ML</em> 에서 <code>if</code> 는 다음과 같이 작성할 수 있다. 다르 언어와 비슷하다.</p>

<pre><code class="sml">val abs_of_z = if z &lt; 0 then 0 - z else z;  
</code></pre>

<p>여기서 잠깐 <em>Syntax</em> 와 <em>Semantics</em> 를 정리하자면</p>

<blockquote>
  <p><strong>Syntax</strong> is just how you write something<br/></p>
  
  <p><strong>Semantics</strong> is what that something means<br/>
  - <em>Type-checking</em> (before program runs)<br/>
  - <em>Evaluation</em> (as program runs)  </p>
</blockquote>

<p><em>variable binding</em> 에서는, <em>type checking</em> 은 <em>static environment</em> 를 확장하고, <em>evaluation</em> 은 <em>dynamic environment</em> 를 확장한다.</p>

<h3 id="rulesforexpressions">Rules for Expressions</h3>

<p><em>expression</em> 은 <em>sub-expression</em> 을 가질 수 있기 때문에, <em>expression</em> 을 해석 하는데 있어서 3가지가 꼭 필요하다.</p>

<p>(1) <strong>Syntax</strong> <br />
(2) <strong>Type-checking rules:</strong> produces a type of fails <br />
(2) <strong>Evaluation rules:</strong> produces a value</p>

<p>다시 말하면 <em>Syntax</em> 와 <em>Semantics</em> 가 필요하단 이야기다.</p>

<h4 id="variables">Variables</h4>

<blockquote>
  <p><strong>Syntax:</strong> sequence of letters, digits, _, not starting with digit</p>
  
  <p><strong>Type-checking:</strong> look up type in current statix env if
  non there, fail</p>
  
  <p><strong>Evaluation:</strong> look up value in current dynamic env</p>
</blockquote>

<h4 id="addition">Addition</h4>

<p>Addition 의 경우에는 <em>sub-exp</em> 가 있을 수 있다.</p>

<blockquote>
  <p><strong>Syntax:</strong> <code>e1</code> + <code>e2</code> where <code>e1</code> and <code>e2</code> are expressions</p>
  
  <p><strong>Type-checking:</strong> if <code>e1</code> and <code>e2</code> have type <em>int</em> then <em>int</em></p>
  
  <p><strong>Evaluation:</strong> if <code>e1</code> evaluates to <code>v1</code> and <code>e2</code> evaluates to <code>v2</code>, then sum of <code>v1</code> and <code>v2</code></p>
</blockquote>

<h4 id="values">Values</h4>

<p>모든 <em>value</em> 는 <em>expression</em> 이다. 그러나 모든 <em>expression</em> 이 <em>value</em> 인 것은 아니다. 그리고,</p>

<blockquote>
  <p>Every value evaluates to itself in <strong>zero steps</strong></p>
</blockquote>

<p>참고로, <code>()</code> 는 <code>unit</code> 타입을 가진다.</p>

<h4 id="conditional">Conditional</h4>

<blockquote>
  <p><strong>Syntax:</strong> if <code>e1</code> then <code>e2</code> else <code>e3</code> where if, then, and else are keywords and <code>e1</code> <code>e2</code> and <code>e3</code> are sub-expressions</p>
  
  <p><strong>Type-checking:</strong> <code>e1</code> must have type <code>bool</code>. <code>e2</code> and <code>e3</code> can have any type, but they must have the same type</p>
  
  <p><strong>Evaluation:</strong> first evaluate <code>e1</code> to <code>v1</code>, if it's true evaluate <code>e2</code> and that resut is the whole expressions's result else evaluate <code>e3</code></p>
</blockquote>

<h3 id="replanderrors">REPL and Errors</h3>

<h4 id="use">use</h4>

<p><code>use</code> 는 특정 파일을 읽어 <em>binding</em> 하고 <code>it: unit</code> 을 돌려주는데, 이건 무시해도 된다. 그리고 같은 파일을 <code>use</code> 할때는 항상 <code>REPL</code> 을 다시 시작하자. <code>C-d</code>, <code>C-c, C-s</code></p>

<h4 id="error">Error</h4>

<p>대부분의 에러는 <em>syntax</em>, <em>type-checking</em>, <em>evaluation</em> 의 문제다.</p>

<h3 id="shadowing">Shadowing</h3>

<p>같은 변수에 대한 <em>multiple binding</em> 은 <em>poor style</em> 이다. 그러나 이를 통해 <em>environment</em> 와 <em>binding</em> 이 어떻게 동작하는지 알 수 있다.</p>

<pre><code class="sml">val a = 10;  
val b = a * 2  
val a = 5; (* this is not an assignment statement *)  
(* a -&gt; 5, b -&gt; 20 *)
val c = 2;  
(* a -&gt; 5, b -&gt; 20, c -&gt; 20 *)
</code></pre>

<p><code>val a = 5</code> 문장은, 할당하는게 아니라 <code>a</code> 를 <em>shadowing</em> 한다. <em>ML</em> 에서는 <em>mutate</em> 할 수 없다. 매번 새롭게 <em>dynamic env</em> 를 만든다.</p>

<pre><code class="sml">val d = a  
(* ..., d -&gt; 5 *)
val a =  a + 1  
(* ..., a -&gt; 6 *)
val f = a * 2  
</code></pre>

<p><code>use</code> 를 이용하면, 기존의 <code>a</code> 의 값이 <code>&lt;hidden-value&gt;</code> 로 나오는 것을 확인 할수 있다.</p>

<pre><code class="sml">val a = 1;  
val b = a;  
val a = 2;  
</code></pre>

<p>다음과 같은 예제가 있을 때, <code>b</code> 는 <code>1</code> 이다. <em>eagerly evaluated</em> 되어 바인딩 후에는 <code>value</code> 를 만든 <em>expression</em> 과는 관련이 없어진다. 다시 말해  바인딩 후에는 <code>a</code> 와 <code>b</code>는 상관이 없다.</p>

<p>그리고 위에서 언급 했듯이 <strong>ML</strong> 에서는 <em>assign to</em> 가 없고, 앞의 <code>a</code> 는 뒤의 <code>a</code> 에가 있는 <em>dynamic env</em> 에 의해서 가려질 뿐이다.</p>

<p>그렇기 때문에 <em>REPL</em> 을 재시작 하지 않고서 같은 파일을 여러번 <code>use</code> 하면 문제가 생길 수 있다고 교수님이 누차 말한 것</p>

<h3 id="functionsinformally">Functions Informally</h3>

<pre><code class="sml">fun pow (x: int, y: int) =  
  if y = 0
  then 1
  else x * pow(x, y-1)

fun cube(x: int)  
  pow(x, 3)
</code></pre>

<p>이 경우 두 함수 모두 타입은 <code>fn: int -&gt; int</code> 다. 타입을 이름 뒤에 사용하는것도 그렇고, 함수 타입도 그렇고 스칼라와 문법이 비슷한 것 같다.</p>

<p><code>*</code> 가 타입에 있을때는 곱셈이 아니라 <code>,</code> 같은 역할을 한다. 따라서 다음과 같이 <code>pow</code> 를 호출할 수 있다.</p>

<pre><code class="sml">val x : int * int = (2, 3)  
val y = pow x  
</code></pre>

<p>참고로, 함수를 사용한 후 정의하는 것은 불가능하다. 따라서 사용하는 <em>expression</em> 위에 함수를 정의해야 한다.</p>

<h4 id="recursion">Recursion</h4>

<p>재귀에 대해서도 간단히 언급을 하는데, 문제를 간단한 방법으로 나누어 푸는 좋은 기술이라고..</p>

<h3 id="functionsformally">Functions Formally</h3>

<p>우리가 <strong>Function</strong> 이 무엇인지 PL 에서 정의하려면 위에서 언급했듯이 <em>syntax</em> 와 <em>semantics</em> 가 필요하다. </p>

<blockquote>
  <p><strong>Syntax:</strong> <code>fun x0 (x1: t1, ... , xn: tn) = e</code></p>
  
  <p><strong>Evaluation:</strong> A function is a value. <code>x0</code> is added to <em>dynamic env</em></p>
  
  <p><strong>Type-checking:</strong> <code>(t1 *, ..., * tn) -&gt; t</code></p>
</blockquote>

<p>타입체킹이 조금 복잡한데, <code>e</code> 가 <code>t</code> 타입을 가지는지 검사하고, 파라미터도 마찬가지로 올바른 타입을 가지는지 검사한다.</p>

<p>다른 언어와 마찬가지로 <code>t1</code> 등의 파라미터는 <code>e</code> 를 위한 <em>environment</em> 에만 추가된다.</p>

<p><code>x0</code> 이 <em>dynamic</em>, <em>static env</em> 에 추가되므로 이후의 코드에서 <em>recursion</em> 을 사용할 수 있다.</p>

<h4 id="functioncalls">Function calls</h4>

<p><em>Function calls</em> 의 <em>syntax</em> 는 <code>e0 (e1, ..., en)</code> 이다. 만약에 인자가 하나라면 괄호(parentheses) 는 없어도 된다.</p>

<p>참고로 <strong>ML</strong> 에서는 <strong>variable numbers of arguments</strong> 를 함수에서 받을 수 없다. 인자의 개수가 정해져야 한다.</p>

<p><em>type-checking</em> 의 경우에는 , <code>e0</code> 이 <code>(t1 * ... * tn) -&gt; t</code> 인지 검사하고 <code>en</code> 이 <code>tn</code> 타입을 가지면, <code>e0</code> 은 <code>t</code> 타입이다. </p>

<p><em>Evaluation</em> 스텝은 다음과 같다.</p>

<p>(1) evaluate <code>e0</code> to <code>fun x0(x1: t1, ... , x: tn) = e</code> <br />
(2) evaluate arguments <code>e1</code>, ... , <code>en</code> to <code>v1</code>, ..., <code>vn</code> <br />
(3) extend <em>dynamic env</em> mapping <code>x1</code> to <code>v1</code> , ... , <code>xn</code> to <code>vn</code></p>

<p>두 번째 스텝에서는 <em>eager evaluation</em> 이 사용되는데 <code>pow(2, 2+2)</code> 같은 경우 인자가 <code>2, 4</code> 가 된다. </p>

<p>세 번째 스텝에서는 <em>dynamic environment</em> 를 확장하는데, 현재 함수인 <code>x0</code> 과 인자들인 <code>xn</code> 을 포함하도록 한다. 따라서 <em>recursion</em> 이 가능하다.</p>

<p>사실은 스칼라의 그것과 같은데 교재에 나온 설명이 너무 함축적이어서 이해하기가 어렵다.</p>

<h3 id="pairsandothertuples">Pairs and Other Tuples</h3>

<p>위에서 잠깐 보았던 <code>t1 * t2</code> 같은 것들이 <em>Pair</em> 다. 다른말로 <em>2-tuples</em> 라 부른다. </p>

<p><em>Syntax</em> 는 <code>(e1, e2)</code> 로 <em>Type-checking</em> 은 <code>e1</code> 과 <code>e2</code> 가 올바른 타입을 가졌는지 검사한다.</p>

<p><em>Pair</em> 에 접근할때는 <code>#1 e</code> 또는 <code>#2 e</code> 와 같은 <em>Syntax</em> 를 사용하고, <code>e</code>가 <code>t1 * t2</code> 타입인지, 그 후에 <code>#1 e</code> 가 <code>t1</code> 또는 <code>#2 e</code> 가 <code>t2</code> 타입을 가졌는지 검사한다.</p>

<pre><code class="sml">fun su_two_pairs (pr1: int * int, pr2: int* int) =  
  (#1 pr1) + (#2 pr1) + (#1 pr2) + (#2 pr2)
</code></pre>

<p>의 경우에는 타입이 <code>(int * int) * (int * int) -&gt; int</code> 된다. 그리고 다른 언어와 마찬가지로 <em>tuple</em> 도 겹칠 수 있다.</p>

<pre><code class="sml">val x1 = (7, (true, 9)) // int * (bool * int )  
val x2 = #1 (#2 x1) // true  
</code></pre>

<h3 id="introducinglists">Introducing Lists</h3>

<p><em>Tuple</em> 은 여러 타입을 가질 수 있지만, 정해진 갯수만큼의 element 만 저장할 수 있다. 반면 <em>List</em> 는 하나의 타입만 가져야 하지만, 원소의 갯수가 변할 수 이다.</p>

<p>빈 리스트는 <code>[]</code> 와 같이 만든다. <code>[3, 4, 5]</code> 는 <code>int list</code> 다. <code>[(1+2), 3, 7]</code> 과 같이 초기화하면 <code>[3, 3, 7]</code> 이 나온다. 리스트는 그 자체로 <em>value</em> 다.</p>

<p><code>::</code> 는 <em>cons</em> 라 발음하고, 다음과 같이 쓸 수 있다.</p>

<pre><code class="sml">val x = [3, 4, 5]  
val y = 2 :: x  
</code></pre>

<p><em>cons</em> 뒤에 오는것은 <code>List</code> 여야 한다. 리스트가 비었는지 검사하기 위해 <code>null</code> 을, <em>head</em> 를 얻기 위해 <code>hd</code> 를, <em>tail</em> 을 얻기 위해 <em>tl</em> 을 이용한다. 따라서 <code>tl [3, 4, 5]</code> 는 <code>[4, 5]</code> 를 돌려준다.</p>

<p>그리고 다른 함수형 언어와 마찬가지로 <code>tl [9]</code> 는 <code>[]</code>(<em>nil</em>) 이다.</p>

<p>리스트는 다양한 타입을 가질 수 있기 때문에 <code>(int * int) list</code> 같은 것도 타입이 될 수 있다. <code>[(3, 4), (5, 6)]</code> 처럼.</p>

<p><code>null</code> 은 <code>fn: a list -&gt; bool</code> 타입이고, 
<code>hd</code> 는 <code>fn: a list -&gt; a</code>, 
<code>tl</code> 은 <code>fn: a list -&gt; a list</code></p>

<p><code>[]: a list</code> 는 좀 특이한데, 다양한 타입이 될 수 있다. <code>3 :: []</code>, <code>false :: []</code> 이라던지.</p>

<h3 id="listfunctions">List Functions</h3>

<p>리스트를 조작하는 간단한 함수를 <em>ML</em> 로 몇 개 짜보자.</p>

<pre><code class="sml">fun pow(x: int, y: int) =  
    if y = 0 then 1 else x * pow(x, y - 1);

fun cube(x: int) =  
    pow(x, 3);

fun sum_list(xs: int list) =  
    if null xs
    then 0
    else hd xs + sum_list(tl xs)

fun product_list(xs: int list) =  
    if null xs
    then 1
    else hd xs * product_list(tl xs)

fun countdown(x: int) =  
    if x = 0
    then []
    else x :: countdown(x - 1)

fun append(xs: int list, ys: int list) =  
    if null xs
    then ys
    else (hd xs) :: append(tl xs, ys)

fun sum_pair_list(xs: (int * int) list) =  
    if null xs
    then 0
    else (#1 (hd xs)) + (#2 (hd xs)) + sum_pair_list(tl xs)

fun firsts(xs: (int * int) list) =  
    if null xs
    then []
    else #1 (hd xs) :: firsts(tl xs)

fun seconds(xs: (int * int) list) =  
    if null xs
    then []
    else #2 (hd xs) :: seconds(tl xs)

fun sum_pair_list(xs: (int * int) list) =  
    if null xs
    then 0
    else sum_list(firsts xs) + sum_list(seconds xs)

fun factorial(n : int) =  
    product_list(countdown(n))
</code></pre>

<p>참고로 <code>#</code> 이 <code>+</code> 이나 <code>::</code> 보다 우선순위가 높다.</p>

<h4 id="listrecursion">List Recursion</h4>

<p>재귀에 대해 생각할땐, 항상 명심해야 하는게 있는데 <strong>탈출 조건</strong> 이다. 따라서 empty-list 에 대해선 어떤걸 돌려줄지, non-empty-list 에 대해서는 무엇을 처리해야 할지 항상 생각해야 한다.</p>

<h3 id="letexpressions">Let Expressions</h3>

<p><code>let</code> 은 <em>local variable</em> 을 바인딩하는 법이다.</p>

<blockquote>
  <p><strong>Syntax:</strong> <code>let b1 b2 ... bn in e end</code>. Each <code>b1</code> is any <em>binding</em> and <code>e</code> is any expression</p>
  
  <p><strong>Type-checking:</strong> Type of whole let-expression is the type of e. Type-check each <code>b1</code> and <code>e</code> in a staic env that includes the previous bindings</p>
  
  <p><em>*Evaluation: *</em> evaluate each <code>b1</code> and <code>e</code> in a dynamic env that includes the previous bindings. Result of whole expression is result of evaluating <code>e</code></p>
</blockquote>

<pre><code class="sml">fun silly () =  
    let
      val x = 3
    in
      (let val x = 2 in x + 1 end) + (let val y = x + 1 in y + 1 end)
    end
</code></pre>

<p>여기서 <em>Scope</em> 의 개념이 나온다.</p>

<blockquote>
  <p><strong>Scope:</strong> Where a binding is in the environment</p>
</blockquote>

<h4 id="nestedfunctions">Nested Functions</h4>

<p><em>Function</em> 은 <em>binding</em> 이다. 따라서 <code>let</code> 내부에서 <em>local binding</em> 할 수 있다.</p>

<pre><code class="sml">fun count_from_1 (x: int) =  
    let
    fun count (from: int, to: int) =
        if from == to
        then []
        else from :: count(from + 1, to)
    in
    count(1, x)
    end
</code></pre>

<p>이렇게 하면 <em>top-level</em> 에서 <code>count</code> 는 사라진다. 그리고 엄밀히 말해서 <code>count</code> 가 가진 <em>environment</em> 에는 <code>to</code> 가 있기 때문에, <code>to</code> 를 인자로 가질 필요가 없다.</p>

<pre><code class="sml">fun count_from_1 (x: int) =  
    let
    fun count (from: int) =
        if from = x
        then []
        else from :: count(from + 1)
    in
    count(1)
    end
</code></pre>

<h3 id="letandefficiency">Let and Efficiency</h3>

<p>가장 큰 숫자를 찾는 다음의 함수를 고려 해 보자</p>

<pre><code class="sml">fun bad_max (xs : int list) =  
  if null xs
  then 0
  else if null (tl xs)
  then hd xs
  else if hd sx &gt; bad_max(tl xs)
  then hd xs
  else bad_max(tl xs)
</code></pre>

<p>이 함수는 <code>[1, 2, ... , 30]</code> 과 같은 리스트에 굉장히 나쁜 성능 <em>exponentially (2^30)</em> 을 보여준다. <code>bad_max(tl xs)</code> 를 두번 호출하기 때문이다. 따라서 <code>max(tl xs)</code> 를 변수로 놓아 캐싱하면</p>

<pre><code class="sml">fun good_max (xs: int list) =  
    if null xs then 0
    else if null (tl xs) then hd xs
    else
    let
        val res = good_max(tl xs)
    in
        if hd xs &gt; res then hd xs
        else res

    end
</code></pre>

<p><code>bad_max</code> 의 <code>if-then-else</code> 가 10^-7 정도의 시간이 든다고 하면, <code>[1, 2, ..., 55]</code> 는 100년이 넘게 걸린다. 따라서 재귀를 구현하는데 있어서 <em>local binding</em> 은 필수다.</p>

<h3 id="options">Options</h3>

<p>참고로, <code>good_max</code> 는 리스트가 모두 음수일때 <code>0</code> 을 돌려준다. 이건 리스트가 비었을때 <code>0</code> 을 돌려주기 때문에 생기는 문제인데, <code>0</code> 말고 다른 무언갈 돌려줄 수 없을까?</p>

<p><em>SML</em> 도 <em>Scala</em> 처럼 <em>Option</em> 을 지원한다.(물론 <em>SML</em> 이 먼저..) <code>NONE</code> 은 <code>a option</code> 타입이고, <code>SOME e</code> 는 <code>t option</code> 이다. <code>t</code> 는 <code>e</code> 의 타입.</p>

<p><em>Option</em> 을 이용해 <code>max</code> 를 리팩토링 해 보면,</p>

<pre><code class="sml">fun max1 (xs: int list) =  
  if null xs NONE
  else 
    let val res = max(tl xs)    
    in if isSome res andalso isVal res &gt; hd xs then res
       else Some(hd xs) 
    end
</code></pre>

<p>그런데, 이 <code>max1</code> 또한 문제가 있다. 사실 <code>[]</code> 는 리스트가 오름차순으로 구성되어있을때 (<code>[1, 2, 3, 4]</code>) 맨 마지막 호출에서만 오는데, 매번 <code>isSome</code> 으로 검사하니까 비효율적이다. 다시 리팩토링하면</p>

<pre><code class="sml">fun max2 (xs: int list) =  
    if null xs then NONE
    else
    let
        fun max_non_empty(ys: int list) =
        if null (tl ys) then hd ys
        else
            let val res = max_non_empty(tl ys)
            in if hd xs &gt; res then hd ys
               else res
            end
    in
        SOME (max_non_empty xs)
    end
</code></pre>

<p><del>교수님 <code>let in end</code> 는 제발그만 가..가독성이</del></p>

<h3 id="booleansandcomparisonoperations">Booleans and Comparison Operations</h3>

<p>다른 언어의 <em>&amp;&amp; (and)</em> 와 <em>|| (or)</em> <em>! (not)</em> 은 <em>SML</em> 에서는 <code>ansalso</code>, <code>orelse</code>, <code>not</code> 이다.</p>

<p>그리고 <code>andalso</code>, <code>orelse</code> 연산자는 다른 언어처럼 <em>Short circuiting</em> 을 제공한다. 함수가 아니다.   </p>

<p><code>andalso</code> 와 <code>orelse</code>, <code>not</code> 은 다음처럼 쓸 수도 있다.</p>

<pre><code class="sml">(* andalso *)
if e1  
then e2  
else false

(* orelse *)
if e1  
then true  
else e2

(* not *)
if e1  
then false  
else true  
</code></pre>

<p><code>if-then-else</code> 만 가지고도 할 수 있으나, 그냥 <code>andalso</code> 와 <code>orelse</code>, <code>not</code> 을 쓰는게 코드를 읽는 사람의 정신 건강에 좋다. </p>

<h4 id="comparisons">Comparisons</h4>

<p>비교의 경우엔 <code>==</code> 가 아니라 <code>=</code> 를 쓴다. <code>!=</code> 가 아니라 <code>&lt;&gt;</code> 를 쓴다. </p>

<p>그리고 <code>3.0 &gt; 2</code> 와 같은 비교는 안된다.<code>3.0</code> 은 <code>real</code> 이고, <code>2</code> 는 <code>int</code> 다 <code>Real.fromInt</code> 를 이용하자.</p>

<h3 id="nomutation">No Mutation</h3>

<p>교수님이 <em>A valuable non-feature</em> 라고 이야기 하시는데, 기능이 없는게 장점이라고.. <em>SML</em> 에서는 아래의 두 코드가 같다. (<em>inditinguishable</em>)</p>

<pre><code class="sml">fun sort_pair(pr: int * int) =  
  if #1 pr &lt; #2 pr then pr
  else (#2 pr, #1 pr)

fun sort_pair(pr: int * int) =  
  if #1 pr &lt; #2 pr then (#1 pr, #2pr)
  else (#2 pr, #1 pr)
</code></pre>

<p>위가 더 나은 <em>style</em> 이라고 주장할 순 있지만, 다르다고 말할 순 없다. 그러나 <em>mutable compound data</em> 를 다루는 다른 언어에서는 위 두 함수는 다르다</p>

<p>예를 들어서 <em>mutable data</em> 를 다루는 언어라 가정하고 다음의 코드를 고려 해 보자.</p>

<pre><code class="sml">val x = (3, 4)  
val y = sort_pair x

(* somehow mutate #1 x to hold 5 *)

val z = #1 y  
</code></pre>

<p>이제 <code>z</code> 의 값은 무엇일까? <code>sort_pair</code> 구현에 따라 다르다. <code>then</code> 에서 <code>pr</code> 을 돌려줬다면, <code>5</code> 일거고, <code>(#1 pr, #2 pr)</code> 을 돌려줬다면 <code>3</code> 일거다. 그러나 <em>ML</em> 에선 문제가 안된다. <em>immutable</em> 하니까. <del>오오 immutable 오오</del></p>

<blockquote>
  <p>But <strong>without mutation</strong>, we can implement either way <br/><br/>
  - No code can ever distinguishe aliasing vs identical copies <br />
  - No need to think about aliasing: focus on other things <br />
  - Can use aliasing, which saves space, without danger</p>
</blockquote>

<p><em>ML</em> 에서는 <code>tl</code> 이 상수 시간내에 이뤄진다. 첫번째 원소를 제외한 나머지를 가리키기만 하면 되니까. 어차피 그 데이터는 <em>immutable</em> 이니까 그냥 쓰기만 하면 된다. 변경이 필요하면, 그 때 새로 만들면 된다.</p>

<h3 id="javamutation">Java Mutation</h3>

<pre><code class="java">public String[] getAllowedUsers() {  
  // return a references of allowedUsers
}
</code></pre>

<p><code>allowedUsers</code> 자체가 <code>private</code> 여도, 다음과 같은 코드에 취약하다.</p>

<pre><code class="java">p.getAllowedUsers()[0] = p.currentUser();  
p.useTheResource();  
</code></pre>

<p>따라서 위의 <code>getAllowedUsers</code> 는 <em>copy</em> 를 돌려줘야한다. </p>

<p><em>ML</em> 같은 <em>immutable</em> 한 언어에서는 <em>Reference (Alias)</em> vs <em>Copy</em> 는 문제가 안된다.</p>

<h3 id="piecesofalanguage">Pieces of a Language</h3>

<p>언어를 배울때는 다음의 다섯가지를 고려해야한다.</p>

<p>(1) <strong>Syntax:</strong> How do you write language constructs? <br />
(2) <strong>Semantics:</strong> What do programs mean? (Evaluation rules) <br />
(3) <strong>Idioms:</strong> What are typical patterns for using language features to express your computation <br />
(4) <strong>Libraries:</strong> What facilities does the language provide <strong>standard</strong>? <br />
(5) <strong>Tools:</strong> What do language implementations provide to make your job easier? (REPL debugger..)  </p>

<p>다시 말하면 다섯가지를 모두 배워야 한다. 언어의 코어부터 그 확장인 라이브러리와 툴까지. 그러나 이 코스에서는 <em>Semantics</em> 와 <em>Idioms</em> 에 집중한다. <em>ML</em> 을 고른것도 그 이유고, 이걸 잘 이해하게 되면 <em>Libraries</em> 가 어떻게 구성되었는지 더 잘 이해할 수 있다.</p>

<h3 id="summary">Summary</h3>

<p>처음엔 재귀가 어려웠는데, 시간이 지날수록 재귀가 얼마나 재밌고 강력한지 알게 된다. 함수를 <em>building block</em> 처럼 조립하는것도 너무 재밌고</p>

<p>Lisp 을 이용했으면 개인적 취향에 맞아 더 재밌게 배울 수 있었을텐데. 나중에 수업이 모두 끝났을때 <em>ML</em> 을 고른 이유를 느낄 수 있었으면 좋겠다.</p>

<p>그리고 Emacs <em>sml-mode</em> 가 좀.. 음.. 빈약한데 더 좋은걸 찾아야겠다. <em>MELPA</em> 엔 없던데.. 테스팅 프레임워크도 좀 찾아서 해보고. </p>]]></description><link>http://1ambda.github.io/programming-language-week1/</link><guid isPermaLink="false">30e30421-f55b-48df-b96b-a19a661c143f</guid><category><![CDATA[coursera]]></category><category><![CDATA[programming language]]></category><category><![CDATA[ml]]></category><category><![CDATA[emacs]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 10 Oct 2014 06:26:00 GMT</pubDate></item><item><title><![CDATA[Machine Learning, Week 2]]></title><description><![CDATA[<p><strong>Machine Learning</strong> by Andrew Ng, <em>Coursera</em></p>

<h2 id="linearregressionwithmultiplevariables">Linear Regression with Multiple Variables</h2>

<h3 id="mutiplefeatures">Mutiple Features</h3>

<p>변수가 적을때는 <em>Hypothesis</em> 가 간단하다. 많으면 어떻게 될까? <em>Feature</em> 가 <code>N+1</code> 개라면,</p>

<p><img src='http://bt22dr.files.wordpress.com/2013/05/04_2.png?w=300&amp;h=19'  align="center" />  </p>

<p align="center"><a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com</a></p>

<p>편의상 <code>x_0 = 1</code> 이라 두면, <em>Hypothesis</em> 는 <em>Zero-based index</em> 인 <code>n+1</code> 벡터 <code>h</code> 와 <code>x</code> 의 곱이다. 따라서 <code>h(x) = h_t * x</code> 로 표기할 수 있다. 이걸 <strong>Mutivariate linear regression</strong> 이라 부른다.</p>

<h3 id="gradientdescentformultiplevariables">Gradient Descent for Multiple Variables</h3>

<p><em>Cost function</em> 은 다음과 같다. 변수의 subscript 는 <code>j</code> 번째 <em>Feature</em> 를, superscript 는 <code>i</code> 번째 데이터임을 말한다.</p>

<p><img src='http://bt22dr.files.wordpress.com/2013/05/04_6.png'  align="center" />  </p>

<p align="center">(<a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com/</a>)</p>  

<p><br/></p>

<p>다음은 <em>Gradient Descent</em> 알고리즘을 구하는 정의다.</p>

<p><img src='http://bt22dr.files.wordpress.com/2013/05/04_7.png?w=300&amp;h=104'  align="center" />  </p>

<p align="center">(<a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com/</a>)</p>  

<p><br/></p>

<p>따라서</p>

<p><img src='http://bt22dr.files.wordpress.com/2013/05/04_8.png?w=630&amp;h=354'  align="center" />  </p>

<p align="center">(<a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com/</a>)</p>

<h3 id="featurescaling">Feature Scaling</h3>

<p><em>Feature</em> 간 데이터 크기가 많이 차이가 나면, <em>Gradient Descent</em> 에서 등고선 간 간격이 좁으므로, <em>Global optima</em> 를 찾는데 오래걸릴 수 있다. 따라서 <em>Feature</em> 값을 <code>m</code> 으로 나누거나  -1 과 1 사이로 <em>scaliing</em> 할 수 있다. 거꾸로 말하면, <em>Feature scaling</em> 을 이용하면 <em>Gradient descent</em> 가 결과값을 더 빠르게 찾는다.</p>

<p><img src='http://i.stack.imgur.com/4RBjR.png'  align="center" /></p>

<p>또한 <strong>Mean normalization</strong> 을 이용할 수 있는데, 모든 <em>feature</em> 에서 평균을 빼서, 평균을 0 으로 만드는 방법이다.</p>

<p>더 일반적인 방법은 <em>mean normalization</em> 을 하고, 거기에 <code>max-min</code> 또는 <em>standard deviation</em> 으로 나누는 방법이다.</p>

<h3 id="learningrate">Learning Rate</h3>

<p>디버깅 팁 중 하나는, 우리가 작성한 <em>Gradient descent</em> 알고리즘이 매 <em>interation</em> 마다 줄어들어야 한다는 것이다.</p>

<p><img src='http://d37rcl8t6g8sj5.cloudfront.net/wp-content/uploads/gradient_descent_error_by_iteration.png'  align="center" />  </p>

<p align="center">(<a href='http://spin.atomicobject.com/' >http://spin.atomicobject.com</a>)</p>

<p>그리고, 어느 지점에선가 <em>converged</em> 되는지 검사하기 위해 <em>automatic convergence test</em> 를 사용할 수 있다. 예를 들어 한 이터레이션에서, 10^-3 보다 적게 줄어드는지 검사한다거나.</p>

<p>만약에 <em>gradient descent</em> 값이 증가하면, 더 작은 <em>learning rate</em> 를 사용해라. 그렇다고 너무 작은 값을 사용하면 <em>gradient descent</em> 가 느리게 수렴할 수 있다. <em>learning rate</em> 가 너무 크면, 심지어 수렴하지 않을 수도 있다.</p>

<p>따라서 <em>learning rate</em> 를 <code>0.001</code>, <code>0.003</code>, <code>0.01</code>, <code>0.03</code>, <code>0.1</code>, <code>0.3</code>, <code>1</code> 처럼 작은 것부터 선택하되, 천천히 늘려가는 것이 좋다.</p>

<h3 id="polynomialregression">Polynomial Regression</h3>

<p>집값을 예측하기 위해 두개의 <em>feature</em>, <code>frontage</code> 와 <code>depth</code> 가 있다고 하자. 두 값을 곱해 <code>area</code> 라는 새로운 <em>feature</em> 를 만들면, <em>Hypothesis</em> 가 간단해진다. 따라서 기존의 <em>feature</em> 를 이용 할 수 있는지도 잘 알아보는 게 좋다.</p>

<p>자 이제, 집 값(Housing prices) 을 예측하기 위해 <em>Size(Area)</em> 라는 <em>feature</em> 를 이용한다 하자. <em>training set</em> 이 다음과 같을때, </p>

<p><img src='http://www.holehouse.org/mlclass/01_02_Introduction_regression_analysis_and_gr_files/Image.png'  align="center" />  </p>

<p align="center"><a href='http://www.holehouse.org/mlclass' >http://www.holehouse.org/mlclass</a></p>  

<p><br/></p>

<p><em>hypothesis</em> 를 <em>quadratic</em> 로 세우면 어느 지점부터는 예측된 값이 감소하므로 <em>traning set</em> 과 일치하지 않는다. 따라서 <em>cubic</em> 다항식을 이용해 볼 수 있겠는데, <em>feature</em> 가 <code>size</code> 하나 뿐이므로, <em>hypothesis</em> 는 <code>size</code> 를 이용한 삼차식이 되겠다.</p>

<p><img src='http://www.holehouse.org/mlclass/04_Linear_Regression_with_multiple_variables_files/Image%20' [10].png" align="center" />  </p>

<p align="center"><a href='http://www.holehouse.org/mlclass' >http://www.holehouse.org/mlclass</a></p>

<p>이 경우 <code>size</code> 하나로 3개의 <em>feature</em> 를 만들었으니, <em>scaling</em> 이 문제가 될 수 있다.</p>

<p>이 전에 앞서서 <em>feature</em> 가 두개인 <em>hypothesis</em> (quadratic) 은 말이 안된다고 했는데, 두개지만 <em>square</em> 모델을 사용하면 우리가 가진 <em>training set</em> 과 얼추 맞아 떨어지는 모델을 찾을 수 있다. 그림이 없어서 대충 식을 첨부하면,</p>

<p><code>h(x) = y0 + y1(size) + y2 * square(size)</code></p>

<p>여기서 <code>y</code> 는 강의에서 말하는 <code>0(theta)</code> 라 보면 된다.</p>

<h3 id="nomalequation">Nomal Equation</h3>

<p><em>gradient descent</em> 는 반복하면서 특정 값에 수렴해 가는 알고리즘 이었지만 <strong>normal equation</strong> 은 그냥 <code>J(0)</code> 식을 풀어버려 값을 찾아낸다.</p>

<p>예를 들어서 <code>J(0)</code> 가 <code>0(theta)</code> 에 대해  <em>quadratic</em> 이면, <code>0</code> 에 대해 미분해서 최저점을 찾아내면 된다. 문제는, <code>0</code> 가 여러개 일때, 모든 <code>0_j</code> 에 대해 <em>cost function</em> 을 풀어야 한다는 것이다. <em>partial derivative</em> 를 이용해서 해를 찾으면 된다.</p>

<p><img src='http://www.longhaiqiang.com/wp-content/uploads/2013/08/Snip20130817_44.png'  align="center" />  </p>

<p align="center">(<a href='http://www.longhaiqiang.com/' >http://www.longhaiqiang.com/</a>)</p>  

<p><br/></p>

<p>행렬을 이용할 수도 있다. 자세한 건 강의 내용을 보자, <em>design matrix</em> 라고 부르는 <code>X</code> 를 만들어서 아래의 식을 구하면 된다. 사실 <code>X</code> 는 그냥 <em>feature</em> 들을 있는 그대로 행렬로 만들면 된다. 맨 앞에 <code>x0</code> 만 추가해서. </p>

<p><img src='http://www.longhaiqiang.com/wp-content/uploads/2013/08/Snip20130817_41.png'  align="center" />  </p>

<p align="center">(<a href='http://www.longhaiqiang.com/' >http://www.longhaiqiang.com/</a>)</p>

<p>참고로, 저 식을 <em>Octave</em> 에서는 다음과 같이 계산한다.</p>

<pre><code class="octave">pinv(X`*X)*X`*y  
</code></pre>

<p><br/></p>

<p><em>normal equation</em> 을 이용할때는 <em>feature scaling</em> 을 하지 않아도 괜찮다. <em>gradient descent</em> 와 비교해 보자면,</p>

<blockquote>
  <p><strong>Gradient Descent:</strong> <br/>
  (1) <em>learning rate</em> 를 골라야 한다. 
  (2) <em>feature scaling</em> 을 해야할 필요가 있다. <br />
  (3) <em>interation</em> 을 해야하므로 알고리즘이 제대로 돌아가는지 체크해야할 필요가 있다. <br />
  (4) 대신 <code>n</code> 이 커도 잘 돌아간다.</p>
  
  <p><strong>Normal Equation:</strong> <br/>
  (1) <em>learning rate</em> 를 고를 필요가 없다. <br />
  (2) <em>feature scaling</em> 을 해야할 필요가 없다. <br />
  (3) <em>interation</em> 을 하지 않는다. <br />
  (4) <code>n</code> 이 커질경우 굉장히 느려지고 <code>(X^TX)^-1)</code> 을 계산해야 한다.</p>
</blockquote>

<p>따라서 <code>n</code> 이 너무 크지 않으면, 100~1000 정도까지는, <em>normal equation</em> 을 쓰는편이 낫다.</p>

<h3 id="nomalequationnoninvertibility">Nomal Equation Noninvertibility</h3>

<p>만약에, 우리가 가진 <code>X</code> 가 <em>non-invertible</em> 하다면 어떻게 될까? <em>invertible matrix</em> 란, 아래를 만족시키는 <code>B</code> 가 존재하는 행렬이다. <code>I</code> 는 <em>identity matrix</em> 다.</p>

<p><img src='http://upload.wikimedia.org/math/7/3/3/7334597613ae1773c19e1ed1289349db.png'  align="center" />  </p>

<p align="center">(<a href='http://en.wikipedia.org/wiki/Invertible_matrix' >http://en.wikipedia.org/wiki/Invertible_matrix</a>)</p>

<p>만약 저런 <code>B</code> 가 존재하지 않아 <em>non-invertible</em> 한 행렬을 <strong>sigular matrix</strong>, <strong>degenerate matrix</strong> 라 부른다.</p>

<p>우리가 계산해야 할 행렬이 <em>non-invertible</em> 이라면, 두 가지 경우가 있을 수 있는데, </p>

<p>(1) Redundant features(linearly dependent) e.g <code>x1 = (3.28) * x2</code> <br />
(2) too many features e.g <code>m &lt;= n</code></p>

<p>이럴 때는 몇몇 <em>feature</em> 를 삭제하고, <em>regulaization</em> 을 하면 된다. </p>

<h3 id="costfunctionoctave">Cost Function: Octave</h3>

<p><em>cost function</em> 을 구현 해 보면</p>

<pre><code class="matlab">function J = costFunctionJ(X, y, theta)

m = size(X, 1) % number of training examples  
predictions= X * theta; % predictions of hypothesis on all m examples  
sqrErros = (predictions-y).^2;

J = 1 / (2*m) * sum(sqrErros);  
</code></pre>

<p><em>R</em> 이나 이런것들은 행렬연산이 참 쉬운것 같다.</p>

<h3 id="vectorization">Vectorization</h3>

<p><em>Vectorization</em> 을 이용하면, <code>for loop</code> 을 제거할 수 있는데, 예를 들어</p>

<p><img src='http://i.ytimg.com/vi/jRr2XuZOWB8/hqdefault.jpg'  align="center" /></p>

<p>이건 행렬 곱셈이 한번에 이루어진다는 것을 이용한 방법이다. 따라서 <em>gradient descent</em> 알고리즘에서 <code>theta</code> 를 <code>for-loop</code> 으로 구하는 것이 아니라, <em>vectorization</em> 을 이용하면 한번에 계산할 수 있다.</p>

<p>이게 그림을 구하기가 어려운데, 아래첨자(sub-script) 를 이렇게 기술한다고 하자. <code>x_0</code> 그럼, <em>grandient descent</em> 알고리즘 식에서 <em>learning rate</em> 뒷부분이 <em>vector</em> 가 되는데 그 이유는 <code>theta</code> 와 마찬가지로 <code>j</code> 에 대한 나열이기 때문이다.</p>

<p><img src='http://2.bp.blogspot.com/-ZxJ87cWjPJ8/TtLtwqv0hCI/AAAAAAAAAV0/9FYqcxJ6dNY/s1600/gradient+descent+algorithm+OLS.png'  align="center" /></p>

<p>구글에 검색하니까 1번으로 뜨는게 <em>vectorization(parallel computing)</em> 이더라. 병렬 연산에 많이 사용되나보다.</p>

<h3 id="refenrences">Refenrences</h3>

<p>(1) <a href='http://stats.stackexchange.com/questions/111467/is-it-necessary-to-scale-the-target-value-in-addition-to-scaling-features-for-re' >StackExchange</a> <br />
(2) <a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com/</a> <br />
(3) <a href='http://spin.atomicobject.com/2014/06/24/gradient-descent-linear-regression/' >http://spin.atomicobject.com</a> <br />
(4) <a href='http://www.holehouse.org/mlclass/01_02_Introduction_regression_analysis_and_gr.html' >http://www.holehouse.org/mlclass/</a> <br />
(5) <a href='http://www.longhaiqiang.com/' >http://www.longhaiqiang.com/</a>  </p>]]></description><link>http://1ambda.github.io/machine-learning-week-2/</link><guid isPermaLink="false">78e8635f-a298-477a-8823-0c2738c21251</guid><category><![CDATA[coursera]]></category><category><![CDATA[machine lerning]]></category><category><![CDATA[gradient descent]]></category><category><![CDATA[normal equation]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 08 Oct 2014 10:50:00 GMT</pubDate></item><item><title><![CDATA[Functional Programming in Scala, Chapter 4]]></title><description><![CDATA[<p>2014-10-07, <strong>Functional Programming in Scala</strong>, Coursera</p>

<h2 id="typesandpatternmatching">Types and Pattern Matching</h2>

<h3 id="functionsasobjects">Functions as Objects</h3>

<blockquote>
  <p>In fact function values are treated as objects in Scala</p>
</blockquote>

<pre><code class="scala">trait Function1[A, B] {  
  def apply(x: A): B
}
</code></pre>

<p>결국, <code>function</code> 은 <code>apply</code> 메소드를 가진 오브젝트다.</p>

<p>예를 들어서 <code>(x: Int) =&gt; x * x</code> 는 다음과 같이 <code>Function1</code> ` <em>trait</em> 를 구현한 클래스 된다.</p>

<pre><code class="scala">{
  class AnonFun extends Function1[Int, Int] (
    def apply(x: Int) = x * x
  }

  new AnonFun
}

// or using anonymous class syntax
// trait can be instanciated

new Function1[Int, Int] {  
  def apply(x: Int) = x * x
}
</code></pre>

<p>따라서 이런 정의를 보면, <code>f(a, b)</code> 는 <code>f.apply(a, b)</code> 다. 그런데 만약 메소드인 <code>def apply</code> 자체도 오브젝트일까? 그렇지 않다. 만약 <code>apply</code> 자체도 오브젝트라면, 그 오브젝트도 <code>apply</code> 메소드를 가지고 있어야 하고, 또 다시 그렇게 반복될 수 있다.</p>

<h4 id="functionsandmethods">Functions and Methods</h4>

<p>따라서 <code>def f(x: Int): Int = ...</code> 메소드 자체는 <strong>Function</strong> 이 아니다. (<em>Method != Function</em>) 그러나 </p>

<blockquote>
  <p>If <code>f</code> is used in a place where a <code>Function</code> type is expected, it is converted automatically to the function value</p>
</blockquote>

<p>예를 들어, <code>(x: Int) = f(x)</code> 는 다음과 같이 확장된다.</p>

<pre><code class="scala">new Function1[Int Int] {  
 def apply(x: Int) = f(x)
}
</code></pre>

<p>이렇게 <em>Method</em> 가 <em>Function</em> 으로 변환되는 과정을 <em>lambda calculus</em> 에서는 <strong>eta-expansion</strong> 이라 부른다. </p>

<p>그리고 위에서 보았겠지만 <code>apply</code> 메소드는, 오브젝트에 있을때 오브젝트 이름 자체로 호출될 수 있도록 해준다. 예를들어 지난 시간에 만들었던 <code>List</code> <em>trait</em> 에 대해서,</p>

<pre><code class="scala">trait List[T] {  
  def isEmpty: Boolean
  def head: T
  def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {  
  def isEmpty = false
}

class Nil[T] extends List[T] {  
  def isEmpty = true
  def head = throw new NoSuchElementException("Nil.head")
  def tail = throw new NoSuchElementException("Nil.tail")
}
</code></pre>

<p>아래와 같은 호출을 원한다면</p>

<pre><code class="scala">val e = List()  
val e3 = List(3)  
val e34 = List(3, 4)  
</code></pre>

<p>다음과 같이 <code>List</code> <em>Object</em> 와 <code>apply</code> <em>Method</em> 를 정의할 수 있다. </p>

<pre><code class="scala">object List {  
  def apply() = new Nil
  def apply(x: Int) = new Cons(x, new Nil)
  def apply(x: Int, y: Int) = new Cons(x, new Cons(y, new Nil))
}
</code></pre>

<h3 id="subtypingandgenerics">Subtyping and Generics</h3>

<p>지난시간에는 <em>Polymorphism</em> 의 두가지 형태에 대해 배웠었다. 하나는 <strong>Subtyping</strong> 이고, 다른 하나는 <strong>Generics</strong> 다. 기억을 더듬어 보면</p>

<blockquote>
  <p><strong>Subtyping:</strong> Instance of a subclass can be passed to a base class <br />
  <strong>Generics:</strong> Instance of a function or class are created  by type parameterazation</p>
</blockquote>

<p>이 중에서 <em>subtyping</em> 은 OOP 에서 먼저 온 것이고, <em>generics</em> 는 <em>FP</em> 에서 먼저 온 것이라는 이야기 까지 했다.</p>

<h4 id="typebounds">Type Bounds</h4>

<p><code>assertAllPos</code> 메소드가 있다고 하자. <code>IntSet</code> 을 취해서, 모든 Element 가 양수면 <code>IntSet</code> 을 리턴하고 아니면 예외를 던진다. 다음과 같이 정의할 수 있겠다.</p>

<p><code>def assertAllPos(s: IntSet): IntSet</code></p>

<p>근데, 만약에 이 메소드가 <code>Empty</code> 를 받으면 <code>Empty</code> 를, <code>NonEmpty</code> 를 받으면 <code>NonEmpty</code> 를 돌려주게 하려면 어떻게 해야할까? 메소드를 2개를 더 만들어야 할까? <em>Type Bound</em> 를 이용해 문제를 해결할 수 있다.</p>

<p><code>def assertAllPos[S &lt;: IntSet](r: S): S = ...</code></p>

<p>여기서 <code>S &lt;: IntSet</code> 은 <code>S</code> 가 <code>IntSet</code> 의 서브타입임을 말하고, 이것을 <strong>Upper bound</strong> 라 부른다(<code>IntSet</code> 기준). 즉 <code>S</code> 의 상위 타입을 지정하는 것이다. </p>

<p>반대로 <code>S :&gt; IntSet</code> 도 있을 수 있다. 이것은 <strong>Lower bound</strong> 라 부르며(<code>IntSet</code> 기준), 이 메소드가 <code>IntSet</code> 의 상위 타입 <code>S</code> 를 이용한다는 것을 컴파일 타임에 지정한다. <code>S</code> 는 <code>IntSet</code>, <code>AnyRef</code>, <code>Any</code> 가 될 수 있다. 정리 하자면,</p>

<blockquote>
  <p><code>S &lt;: T</code> means: <strong>S is a subtype of T</strong> <br />
  <code>S :&gt; T</code> means: <strong>S is a supertype of T, or T is a subtype of S</strong></p>
</blockquote>

<p><strong>Mixed Bound</strong> 도 있다. <code>[S &gt;: NonEmpty &lt;: IntSet]</code></p>

<h4 id="covariance">Covariance</h4>

<p>그런데, <code>NonEmpty &lt;: IntSet</code> 일때 <code>List[NonEmpty] &lt;: List[IntSet]</code> 이면, <strong>Covariant</strong> 하다고 말한다. 직관적으로 보면 그럴듯 하다. </p>

<p>이거 정말 문제가 없을까? <code>List</code> 말고 자바의 <code>Array</code> 를 예로 들어보자.</p>

<pre><code class="java">NonEmpty[] a =  
  new NonEmpty[]{new NonEmpty(1, Empty, Empty)}

IntSet[] b = a  
b[0] = Empty  
NonEmpty s = a[0]  
</code></pre>

<p><code>b[0] = Empty</code> 가 문제가 된다. 여기서 런타임 예외가 발생하는데, 자바에서는 배열이 생성될때, 이 배열이 어떤 타입으로 생성되었는지 내부적으로 태그를 붙인다. 그런데, <code>NonEmpty</code> 로 태그가 붙은 배열에 호환되지 않는 <code>Empty</code> 를 넣고 있기 때문이다.</p>

<p>자바 1.5 이전에는 Generics 가 없었기 때문에 정렬을 위해서는 <code>sort(Object[] a)</code> 처럼 주어야 했는데, 이를 위해서는 자바의 배열이 <strong>Covariant</strong> 여야 했다.</p>

<h4 id="theliskovsubstitutionprinciple">The Liskov Substitution Principle</h4>

<p><strong>Liskov Substitution Princile(리스코프 치환원칙)</strong> 은 언제 한 타입이 다른 타입의 서브타입이 될 수 있는지 말해준다.</p>

<blockquote>
  <p>If <code>A &lt;: B</code>, then everything one can to do with a value of type <code>B</code> one should also be able to do with a value of type <code>A</code></p>
</blockquote>

<p>자 이제, Scala 에서 위의 코드를 작성하면 어디서 에러가 나는지 확인 해 보자.</p>

<pre><code class="scala">val a: Array[NonEmpty] = Array(new NonEmpty(1, Empty, Empty))  
val b Array[IntSet] = a  
b(0) = Empty  
val s: NonEmpty = a(0)  
</code></pre>

<p><code>val b: Array[IntSet] = a</code> 에서 컴파일 타임 에러가 난다. 왜냐하면 Scala 의 <code>Array</code> 는 <strong>Not</strong> <em>covariant</em> 이기 때문이다.</p>

<h3 id="variance">Variance</h3>

<p>어떤 타입은 <em>covariant</em> 고 어떤 타입은 그렇지 않은걸까? 엄격히 말해서, elements 들의 <em>mutation</em> 을 허용하는 타입은 <em>not-covariant</em> 여야 한다. </p>

<p>반면 <em>immutable types</em> 은 조건이 갖춰지면 <em>covariant</em> 일 수 있다. 위에서 <code>List</code> 는 되고, <code>Array</code>는 안되었던 것처럼.</p>

<p><code>C[T]</code> 가 있고, <code>A &lt;: B</code> 일때 다음과 같은 정의를 내릴 수 있다.</p>

<ul>
<li><code>C[A] &lt;: C[B]</code> 이면, <strong>C is covariant</strong>, <code>C[+A]</code> 로 표시</li>
<li><code>C[A] &gt;: C[B]</code> 이면, <strong>C is contravariant</strong>, <code>C[-A]</code> 로 표시  </li>
<li><code>C[A]</code> 와 <code>C[B]</code> 가 상관이 없으면, <strong>C is non-variant</strong>, , <code>C[A]</code> 로 표시</li>
</ul>

<p>그렇다면 다음과 같은 두개의 타입이 있을때, 어떤것이 서브타입이고 어떤  것이 슈퍼타입일까?</p>

<pre><code class="scala">type A = IntSet =&gt; NonEmpty  
type B = NonEmpty =&gt; IntSet  
</code></pre>

<p>설명을 조금 자세히 하면, 함수의 파라미터는 <em>Contravariant</em> 하고, 함수의 리턴타입은 <em>Covariant</em> 하다. <code>Function1[-A, +B]</code> 를 보면 알 수 있다. 따라서 <code>A &lt;: B</code> 다. 왜 그럴까? 여기 <a href='https://twitter.github.io/scala_school/type-basics.html' #variance">Scala School</a> 의 예제를 좀 보자.</p>

<pre><code class="scala">class Animal {  
  val sound = "rustle" 
  def name = "animal"
}

class Bird extends Animal {  
  override val sound = "call"
  def name = "bird"
}
class Chicken extends Bird {  
  override val sound = "cluck" 
  def name = "chicken"
}
</code></pre>

<p>이때, <code>val getTweet: (Bird =&gt; String)</code> 에 <code>(c: Chicken =&gt;  c.chicken</code> 과 같이 넘겨주고, 나중에 <code>getTweet(new Bird)</code> 를 호출하면 에러가 난다. 반면 <code>a: Animal =&gt; a.name</code> 을 주고, <code>getTweek(new Bird)</code> 는 상관 없다. 어차피 <code>Bird</code> 는 <code>Animal</code> 이니까</p>

<p>따라서 함수의 파라미터는 현재와 같은 타입이거나, 혹은 그 슈퍼타입이어야 한다, 다시말해서 <strong>Contravariant</strong> 해야 한다.</p>

<h4 id="variancechecks">Variance Checks</h4>

<p><code>Array</code> 의 경우 <code>update</code> 연산이 문제가 될 수 있다는걸 위에서 논의 했었는데, 이걸 정리하자면</p>

<blockquote>
  <p>*The problematic combination is <br />
  <strong>the covariant type parameter T</strong> <br />
  <strong>which appears in parameter position of method <code>update</code></strong></p>
</blockquote>

<p>즉 <em>covariant</em> 타입 <code>T</code> 가 <code>update</code> 연산에 나타날때 문제가 된다. 그래서 Scala 는 컴파일 타임에 이런 문제가 생기지 않는지 검사를 한다.</p>

<blockquote>
  <p><em>covariant</em> type parameters can only appear in method results <br />
  <em>contravariant</em> type parameters can only appear in method parameters <br />
  <em>invariant</em> type parameters can appear anywhere  </p>
</blockquote>

<p><code>Function1</code> <em>Trait</em> 는 그래서 사실 이런 모양이다.</p>

<pre><code class="scala">package scala  
trait Function1[-T, +U] {  
  def apply(x: T): U
}
</code></pre>

<p><code>T</code> 는 <em>contravariant</em> 이므로 파라미터에만, <code>U</code> 는 <em>covaraint</em> 이므로 리턴타입에만 나타난다. 이제 지난시간에 만들었던 <code>Nil</code> 클래스를 <em>Object</em> 로 만들어 보자.</p>

<pre><code class="scala">trait List[+T] {  
  def isEmpty: Boolean
  def head: T
  def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {  
  def isEmpty = false
}

object Nil extends List[Nothing] {  
  def isEmpty = true
  def head = throw new NoSuchElementException("Nil.head")
  def tail = throw new NoSuchElementException("Nil.tail")
}
</code></pre>

<p><code>Nil</code> 이 <code>List[Nothing]</code> 을 상속하게 해, 모든 리스트의 서브타입이 될 수 있도록 했다. 그러나 이것만으로는 부족하다. <code>trait List[T]</code> 로 만들면, <code>List[Something]</code> 과 <code>List[Nothing]</code> 과는 아무 관련이 없는 <em>non-variant</em> 다. 따라서 <code>List[+T]</code> 로 만들어, <code>List[Nothing] &lt;: List[Something]</code> 이 되도록 해야한다.</p>

<p>이제, 다음과 같은 <code>prepend</code> 메소드를 고려 해 보자.</p>

<pre><code class="scala">trait List[+T] {  
  ...
  def preprend(elem: T): List[T] = new Cons(elem, this)
  ...
}
</code></pre>

<p>이 경우에는 <em>covariant</em> <code>T</code> 가 파라미터에 나오므로, 컴파일이 실패한다. 그러나 우리의 <code>List</code> 는 <em>immutable</em> 한데, 이 경우 파라미터에 <code>T</code> 가 나오면 안되나?</p>

<h4 id="prependviolateslsp">Prepend Violates LSP</h4>

<pre><code class="scala">val xs = new List[IntSet]  
xs.prepend(Empty)

val ys = new List[NonEmpty]  
xs.prepend(Empty) // compilation fail  
</code></pre>

<p>따라서, <code>List[IntSet]</code> 으로 할 수 있는걸 <code>List[NonEmpty]</code>로 할 수 없으니, <strong>LSP</strong> 에 따라서, <code>List[NonEmpty]</code> 는 <code>List[IntSet]</code> 의 서브타입이 될 수 없다.</p>

<p><code>List</code> 는 <em>covariant</em> 하고, <code>update</code> 연산이 있는것도 아니므로 <code>immutable</code> 한데, <code>prepend</code> 메소드의 타입체킹이 문제다. 어떻게 하면 <em>covaraint</em> 타입 <code>T</code> 를 메소드 파라미터로 나타나게 할 수 있을까? <strong>Lower Bound</strong> 를 이용하면 된다.</p>

<pre><code class="scala">def prepend[U :&gt; T](elem: U): List[U] = new Cons(elem, this)  
</code></pre>

<p>이 경우 <code>List[NonEmpty].prepend(Empty)</code> 의 리턴값은 <code>List[IntSet]</code> 이 될것이다. 따라서 룰을 정리하면</p>

<blockquote>
  <p>(1) <strong>covariant type parameters</strong> may appear in <strong>lower bounds</strong> of method type parameters <br />
  (2) <strong>contravariant type parameters</strong> may appear in <strong>upper bounds</strong> of method</p>
</blockquote>

<h3 id="objectseverywhere">Objects Everywhere</h3>

<h4 id="pureobjectorientation">Pure Object Orientation</h4>

<p><em>Pure OO language</em> 는 모든 <em>value</em> 가 <em>object</em> 다. 스칼라는 얼핏 보기에 <em>primitive type</em> 을 사용하는 것 같지만 잘 보면 <code>scala.Boolean</code>, <code>scala.Int</code> 처럼 기본 타입이 클래스화 되어있다. (참고로 <code>Int</code> 는 성능을 위해 32-bit Integer 로 되어있다.)</p>

<p><code>scala.Boolean</code> 대신, 직접 만든 <code>Boolean</code> 을 사용해 보자.</p>

<pre><code class="scala">abstract class cBoolean {

  def IfThenElse[T](t: T, e: T): T

  def &amp;&amp;(other: cBoolean) = IfThenElse(other, False)
  def ||(other: cBoolean) = IfThenElse(True, other)
  def unary_! : cBoolean = IfThenElse(False, True)

  def ==(other: cBoolean) = IfThenElse(other, other.unary_!)
  def !=(other: cBoolean) = IfThenElse(other.unary_!, other)

  def &lt;(other: cBoolean) = IfThenElse(False, other)
  def &gt;(other: cBoolean) = IfThenElse(other.unary_!, False)
}

object True extends cBoolean {  
  def IfThenElse[T](t: T, e:T) = t
}

object False extends cBoolean {  
  def IfThenElse[T](t: T, e:T) = e
}
</code></pre>

<p>그럼 과연, <em>primitive type</em> 없이 언어의 모든 부분을 클래스와 오브젝트로 구성하는것이 가능할까? <code>Boolean</code> 은 우리가 <code>cBoolean</code> 으로 대체했다. <code>Int</code> 부터 더 자그마한 <code>Nat</code>, 즉 자연수 범위부터 시작해보자.</p>

<blockquote>
  <p>Can it be represented as a class from first principles (i.e not using primitie ints)</p>
</blockquote>

<pre><code class="scala">abstract class Nat {  
  def isZero: Boolean
  def predecessor: Nat
  def successor = new Succ(this)
  def + (that: Nat): Nat
  def - (that: Nat): Nat
}

object Zero extends Nat {  
  def isZero = true
  def predecessor = throw new RuntimeException("Zero.predecessor");
  def + (that: Nat) = that
  def - (that: Nat) = {
    if (that.isZero) this
    else throw new RuntimeException("Zero.-")
  }
}

class Succ(n: Nat) extends Nat {  
  def isZero = false
  def predecessor: Nat = n
  def + (that: Nat) = new Succ(n + that)
  def - (that: Nat) = if(that.isZero) this else n - that.predecessor
}
</code></pre>

<p>숫자가 없을때 숫자를 추상화(abstraction) 할 방법을 찾아야 하는데, 놀랍게도 인스턴스의 중첩을, 숫자로 표현했다. 개인적으로 기가막힌다. 4강 초반부에서 집합을 predicate function 의 접합(<code>||</code>, <code>&amp;&amp;</code>)으로 표현했을때도 놀라웠는데.. </p>

<p>위 코드에서 <code>Succ.-</code> 메소드 같은 경우 <code>new Succ(n - that)</code> 을 할 수 있는데, <code>n</code> 이 <code>Zero</code> 즉, 현재 <code>Succ</code> 인스턴스가 1인 경우를 고려해야 한다. 이 경우 런타임 예외가 발생하므로, <code>n - that.predecessor</code> 가 적절하다. 여기에 <code>that</code> 이 <code>Zero</code> 일 경우를 고려하면 된다.</p>

<p>테스트를 작성할 경우 <code>Zero</code> 를 제외하고는 나머지는 다 인스턴스라서, 비교가 어렵다. 그래서 다음과 같은 연속적인 <code>predecessor</code> 를 호출할 수 있는데,</p>

<pre><code class="scala">  val one = Zero.successor
  val two = one + one
  val three = two + one
  val four = three + one

  "One + One" should "be Two" in {
    assert(two.predecessor.predecessor == Zero)
  }

  "two + two" should "be four" in {
    assert(four.predecessor.predecessor.predecessor.predecessor == Zero)
  }
</code></pre>

<p>아래와 같은 테스트용 유틸리티 함수를 만들면 편하다. (아니면 <code>==</code>를 오버라이딩 하거나.)</p>

<pre><code class="scala">  def number = {
    def count(n: Int, succ: Nat): Int = {
      if (succ == Zero) n
      else count(n + 1, succ.predecessor)
    }

    count(0, this)
  }
</code></pre>

<p>이렇게, 실제 타입에 대한 <em>primitive value</em> 없이 <em>abstraction</em> 만으로 타입을 구성할 수 있다. 위에서 구현한 <code>Nat</code> 클래스를 기술적으로는 <strong>Peano numbers</strong> 라 부른다. 다시 말해서,</p>

<blockquote>
  <p>The properties of the natural numbers can e derived from the <strong>Peano axioms</strong></p>
</blockquote>

<p>자세한건 <a href='http://en.wikipedia.org/wiki/Natural_number' #Peano_axioms">여기</a>로</p>

<h3 id="decomposition">Decomposition</h3>

<p>프로그래밍의 많은 부분이 <em>Decomposition</em> 이다. 타입을 비교하고 타입에 따라 처리하는 일들. 다음과 같은 아주 자그마한 컴파일러가 있다고 해 보자. </p>

<pre><code class="scala">object Decomposition {  
  def eval(e: Expr): Int = {
    if (e.isNumber) e.numValue
    else if (e.isSum) eval(e.leftOp) + eval(e.rightOp)
    else throw new Error(s"unknown Expr $e")
  }
}

trait Expr {  
  def isNumber: Boolean
  def isSum: Boolean
  def numValue: Int
  def leftOp: Expr
  def rightOp: Expr
}

class Number(n: Int) extends Expr {  
  def isNumber = true
  def isSum = false
  def numValue = n
  def leftOp = throw new Error("Number.leftOp")
  def rightOp = throw new Error("Number.righOp")
}

class Sum(l: Expr, r: Expr) extends Expr {  
  def isNumber = false
  def isSum = true
  def numValue = throw new Error("Sum.numValue")
  def leftOp = l
  def rightOp = r
}
</code></pre>

<p>다음과 같은 테스트코드를 작성하면, 잘 돌아간다.</p>

<pre><code class="sclaa">  import Decomposition._

  "Sum(Number(3), Number(4))" should "be eql 7" in {
    val three = new Number(3)
    val four = new Number(4)
    val sum = new Sum(three, four)

    assert(eval(sum) == 7)
  }
</code></pre>

<p>위에서, <code>isNumber</code> 과 같은 것들을 <strong>Classification</strong>, <code>rightOp</code>, <code>numValue</code> 같은 것들을 <strong>Accessor</strong> 라 부른다. </p>

<p>문제는 만약 <code>Prod</code> 나 <code>Var</code> 같은 클래스들이 <code>Expr</code> 을 상속했을 때 새로운 <strong>Classification</strong> 과 <strong>Accessor</strong> 를 작성 해야 한다는 거다. 무려 <strong>25</strong> 개나! 단 두개의 클래스만 추가했을 뿐인데..</p>

<p>일반적으로 새롭게 클래스를 정의했을때 메소드는 <em>quadratic</em> 으로 증가한다. 이건 큰 문제다. </p>

<p>이걸 해결하는 한가지 방법은, <em>Type Cast</em> 와 <em>Type Test</em> 를 이용하는거다. 자바에서 사용하는 아래의 두 메소드는</p>

<pre><code class="java">x instansceOf T  
(T) x
</code></pre>

<p>스칼라에서 다음과 같다.</p>

<pre><code>x.isInstanceOf[T]  
x.asInstanceOf[T]  
</code></pre>

<p>이 방법을 이용하면 <code>eval</code> 함수에서 <code>if (e.isInstanceOf[Number])</code> 와 같이 비교할 수 있기 때문에 <em>Classification Method</em> 가 필요없다. 그러나, 타입캐스팅에 실패했을 경우 런타임 에러가 발생할 수 있다. 다른 방법은 없을까?</p>

<h4 id="objectorienteddecomposition">Object-Oriented Decomposition</h4>

<p>다른 한 가지 방법은, <code>eval</code> 에서 타입체킹을 하는게 아니라 각 클래스에 <code>eval</code> 메소드를 만드는거다.</p>

<pre><code class="scala">trait Expr {  
  def eval: Int
}
</code></pre>

<p>이 방법의 문제는 <code>Expr</code> 에 새로운 메소드를 추가했을때 <em>Hierarchy</em> 내에 있는 모든 클래스에 같은 메소드를 작성해야 한다는 것이다.</p>

<p>게다가 <code>a * b + a * c</code> 를 <code>a * (b + 3)</code> 로 축약하기가 어렵다. 이건 <em>Non-local simplification</em> 이기 때문에, sub-tree 를 모두 테스트하고 접근해야한다. <em>OO Decomposition</em> 은 <code>eval</code> 메소드 구현엔 좋지만, 이런 점에선 문제가 있다.</p>

<h3 id="patternmatching">Pattern Matching</h3>

<p>우리는 <em>Decomposition</em> 을 해결하기 위해서 3가지 방법을 시도해봤다.</p>

<p>(1) <em>Classification</em> and <em>acess</em> methods: <strong>quadratic explosion</strong> <br />
(2) <em>Type tests</em> and <em>Type casts</em>: <strong>unsafe</strong>, <strong>low-level</strong> <br />
(3) <em>OO Decomposition</em>: <strong>need to touch all classes to add a new method</strong>, <strong>does not work always</strong>  </p>

<h4 id="functionaldecompositionwithpatternmatching">Functional Decomposition with Pattern Matching</h4>

<p>사실 <em>Classification</em> 이나 <em>Access</em> 의 목적은 다음의 두가지라 봐도 충분하다.</p>

<blockquote>
  <p>(1) Which subclass was used? <br />
  (2) What were the arugmnets of the constructor?</p>
</blockquote>

<p>따라서 Scala 에서는 <strong>Pattern Matching</strong>, 그리고 그 과정에서 사용하는 <strong>Case class</strong> 를 통해 <em>Decomposition</em> 을 우아하게 자동화 한다. </p>

<pre><code class="scala">trait Expr  
case class Number(n: Int) extends Expr  
case class Sum(l: Expr, r: Expr) extends Expr

def eval(e: Expr): Expr = {  
  e match {
    case Number(n) =&gt; n
    case Sum(e1, e2) =&gt; eval(e1) + eval(e2)
  }
}
</code></pre>

<p>(1) 패턴에서 사용하는 <em>Variable(변수)</em> 는 소문자로 시작해야 한다. 
(2) <em>Variable</em> 은 두번 사용될 수 없다. <code>Sum(a, a)</code> 는 잘못된 패턴이다. <br />
(3) <em>Constant(상수)</em> 는 대문자로 시작해야 하는데, 예외는 <code>null</code>, <code>true</code>, <code>false</code> </p>

<p><code>Expr</code> <em>Trait</em> 내부에 <code>eval</code> 을 삽입하는 것도 가능하다</p>

<pre><code class="scala">trait Expr {  
  def eval: Int = {
    this match {
      case Number(n) =&gt; n
      case Sum(e1, e2) =&gt; e1.eval + e2.eval
    }
  }
}
</code></pre>

<p><em>Object-Oriented Decomposition</em> 과 <em>Functional Decomposition</em> 모두 장단이 있는데, 만약 메소드를 많이 만드는 경우라면 <em>Functional Decomposition</em> 이 더 우월하다. 매 클라스마다 메소드를 만들 필요가 없기 때문이다. 반대로, 클래스를 많이 만드는 경우라면, <em>OO Decomposition</em> 이 더 낫다. 클래스를 만들때마다 매번 <code>eval</code> 함수를 수정 할 필요 없기 <code>eval</code> 을 가진 클래스를 만들면 된다.</p>

<h3 id="lists">Lists</h3>

<p>Scala 에서 <code>List</code> 와 <code>Array</code> 는 크게 두가지 면에서 다르다, 먼저 <code>List</code> 는 <em>immutable</em> 이고, <em>recursive</em> 인 반면 <code>Array</code> 는 <em>mutable</em>, <em>flat</em> 하다.</p>

<pre><code class="scala">List("apple", "oranges", "pears")  
"apple" :: ("oranges" :: ("pears" :: Nil))

List()  
Nil  
</code></pre>

<h4 id="rightassociativity">Right Associativity</h4>

<p>좀 더 편하게 하기 위해서, Scala 는 다음과 같은 문법을 제공한다.</p>

<pre><code class="scala">A :: (B :: C)  
A :: B :: C  
</code></pre>

<p>이는 Scala 에서 <code>:</code> 로 끝나는 <em>operator</em> 는 <strong>Right-associative</strong> 이기 때문이다.</p>

<p>또한 <code>:</code> 로 끝나는 <em>operator</em> 에서는, 우측에 오는것이 본래의 <em>operand</em> 다</p>

<blockquote>
  <p>Operators ending in <code>:</code> are also difference in the they are seen as method calls of the right-hand operand</p>
</blockquote>

<p>따라서 다음의 세 라인은 모두 같다.</p>

<pre><code class="scala">1 :: 2 :: 3 :: 4 :: Nil  
1 :: (2 :: (3 :: (4 :: Nil)))  
Nil.::(4).::(3).::(2).::(1)  
</code></pre>

<p>그러므로 <code>::</code> 를 <code>prepend</code> 메소드라 보면 된다.</p>

<h4 id="listpatterns">List Patterns</h4>

<p><code>::</code>(Cons) 연산자를 이용하면 다음과 같은 패턴이 가능하다.</p>

<pre><code class="scala">1 :: 2 :: xs  
x :: Nil  
List(x) // same as x :: nil  
List() // Nil  
List(2 :: xs)  
</code></pre>

<h4 id="sortinglists">Sorting Lists</h4>

<p><strong>Insertion Sort</strong> 는 재귀를 이용하면 다음과 같이 구현할 수 있다.</p>

<pre><code class="scala">  def isort(xs: List[Int]): List[Int] = {
    xs match {
      case Nil =&gt; List()
      case y :: ys =&gt; insert(y, isort(ys))
    }
  }

  def insert(x: Int, xs: List[Int]): List[Int] = {
    xs match {
      case Nil =&gt; List(x)
      case y :: ys =&gt; {
        if (x &lt; y)  x :: xs
        else y :: insert(x, ys)
      }
    }
  }
</code></pre>

<h3 id="references">References</h3>

<p>(1) <a href='https://twitter.github.io/scala_school/type-basics.html' #variance'>https://twitter.github.io/scala_school/type-basics.html#variance</a>  </p>]]></description><link>http://1ambda.github.io/functional-programming-in-scala-chapter-4/</link><guid isPermaLink="false">fa146b4b-9c91-4762-ae3f-55f9179f16d9</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[variant]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 07 Oct 2014 08:06:00 GMT</pubDate></item><item><title><![CDATA[Machine Learning, Week 1]]></title><description><![CDATA[<p><strong>Machine Learning</strong> by Andrew Ng, <em>Coursera</em></p>

<h3 id="whatismachinelearning">What is Machine Learning?</h3>

<blockquote>
  <p>Field of study that gies computers the abiliry to learn without being explicitly programmed. (1959, Arthur Samuel)</p>
  
  <p><strong>Well-posed Learning Problem:</strong> A computer program is said to <em>learn</em> from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E (1998, Tom Michell)</p>
</blockquote>

<p>체크메이트를 예로 들면, 수천번의 체스 게임은 <em>E</em> 에 해당하고 게임 속에서 체크메이트는 <em>T</em> 에, <em>P</em> 는 다음 게임에서 이길 확률로 볼 수 있다.</p>

<p>다른 예로, 이메일을 분류하는 스팸검사기가 있다고 할때 </p>

<ul>
<li><em>E</em>: Wathing you label emails as spam or not spam.  </li>
<li><em>T</em>: Classifying emails as spam or not spam.  </li>
<li><em>P</em>: The number(or fraction) of emails correctly classified as spam/not spam.  </li>
</ul>

<h3 id="supervisedlearning">Supervised Learning</h3>

<blockquote>
  <p><strong>Given the rihgt answer</strong> for each example in the data</p>
</blockquote>

<p>즉, 주어진 정답이 있을때 사용할 수 있다. 이런 문제들은 많은데, <em>Regression</em> 이나 <em>Classification</em> 등이 있다.</p>

<ul>
<li><strong>Regression:</strong> Predict continuous valued output  </li>
<li><strong>Classification:</strong> Discrete valued output (0 or 1)  </li>
</ul>

<p>단순히 1개 혹은 2개의 attribute 를 사용할 수 있지만, infinite number of features(attribute) 를 사용하는 <em>Support Vector Machine</em> 같은 알고리즘도 있다.</p>

<h3 id="unsupervisedlearning">Unsupervised Learning</h3>

<p>즉 모든 데이터에 attribute 는 있지만 주어진 정답이 없을때 사용한다. 다시 말해서, 여러 집단으로 분류될때 미리 컴퓨터에게 이건 <code>type1</code> 이야 등의 정보를 제공하지 않는다. </p>

<p>예를 들어서, 다음의 두가지 예는 <em>Unsupervised leanring</em> 이 아니라 <em>Supervised learning</em> 이다.</p>

<blockquote>
  <p>(1) <strong>Given email labeled as spam/not spam</strong>, learn a spam filter<br/><br/>
  (2) <strong>Given a dataset of patients diagnosed as either having diabetes or not</strong>, learn to classify new patients as having diabetes or not</p>
</blockquote>

<p><strong>Clustering</strong> 이라 불리는데, DNS Clustering, Social network analysis, market segmentation 등에 쓰인다.</p>

<p><strong>Cocktail party problem</strong> 은 2명이 동시에 말하고, 이걸 서로 다른 위치에 있는 마이크가 녹음한다고 할 때 이 소리를 구분할 수 있는가 하는 문제다. 이것 또한 <em>Unsupervised lerning</em> 으로 해결할 수 있다.</p>

<h3 id="modelrepresentation">Model Representation</h3>

<p><img src='http://mercris.files.wordpress.com/2012/07/genericmlatwork.png'  />  </p>

<p align="center">(<a href='http://mercris.files.wordpress.com/2012/07/genericmlatwork.png' >http://mercris.files.wordpress.com/2012/07/genericmlatwork.png</a>)</p>

<p><em>Traning Set</em> 을 넣고 <em>Learning Algorithm</em> 을 돌리면 <em>Hypothesis</em> 가 나오는데, 이건 사실 함수라 보면 된다. 여기에 새로운 <em>Input X</em> 를 넣으면 <em>Estimated Y</em> 가 나온다.</p>

<p>참고로, 변수가 하나인 <em>Linear regression</em> 은 <strong>Univariate linear regression</strong> 이라 부른다.</p>

<h3 id="costfunction">Cost Function</h3>

<p>예를 들어서 다음과 같은 데이터셋이 있을때, </p>

<p><img src='http://mercris.files.wordpress.com/2012/07/screen-shot-2012-07-17-at-2-12-05-pm.png?w=584'  align="center" />  </p>

<p align="center"><a href='http://mercris.files.wordpress.com/2012/07/screen-shot-2012-07-17-at-2-12-05-pm.png?w=584' >http://mercris.files.wordpress.com/2012/07/screen-shot-2012-07-17-at-2-12-05-pm.png?w=584</a></p>

<p><em>H(hypothesis)</em> 가 다음처럼 나온다면 </p>

<p><img src='http://s0.wp.com/latex.php?latex=h_%7B%5Ctheta%7Dx+%3D+%5Ctheta_%7B0%7D+%2B+%5Ctheta_%7B1%7Dx&amp;bg=ffffff&amp;fg=333333&amp;s=0'  align="center" /></p>

<p>여기서 <code>0 (Theta)</code> 는 <em>parameter</em> 라고 부른다. 
문제는, 상수를 어떻게 찾느냐인데, 아이디어는 간단하다. training set <code>(x, y)</code> 에 가까운 <code>h(x)</code> 를 찾으면 된다.</p>

<p>따라서 다음과 같은 식을 만들 수 있고,</p>

<p><img src='http://s0.wp.com/latex.php?latex=J%28%5Ctheta_%7B0%7D%2C+%5Ctheta_%7B1%7D%29+%3D+%5Cdfrac+%7B1%7D%7B2m%7D+%5Csum+%5Climits_%7Bi%3D1%7D%5E%7Bm%7D+%28h_%7B%5Ctheta%7D+%28x%5E%7B%28i%29%7D%29+-+y%5E%7B%28i%29%7D%29%5E2&amp;bg=ffffff&amp;fg=333333&amp;s=0'  align="center" /> </p>

<p><code>J(01, 02)</code> 를 최소화 하는 <code>(01, 02)</code> 를 찾으면 된다. 이 식을 <strong>cost function</strong> 또는 <strong>squred error function</strong> 이라 부른다. 여기서 <code>1/2m</code> 으로 나누는 이유에 대해 좀 궁금해서 구글링 해봤는데, <code>1/m</code> 으로 나누는 이유는 <em>squared error</em> 에 대해 <em>mean</em> 을 얻기 위한거고, <code>1/2</code> 로 다시 나누는 이유는 미분했을때 나오는 <code>2</code> 를 제거하기 위해서다. <a href='http://stackoverflow.com/questions/21099289/cant-understand-the-cost-function-for-linear-regression' >SO 답변</a> 을 첨부하면,</p>

<blockquote>
  <p>The cost function is</p>
  
  <p>J(theta<em>0, theta</em>1) = 1/(2m) * sum<em>(i=1)^m [ h</em>theta(x^i) - y^i ]^2
  By h<em>theta(x^i) we denote what model outputs for x^i, so h</em>theta(x^i) - y^i is its error (assuming, that y^i is a correct output).</p>
  
  <p>Now, we calculate the square of this error [ h_theta(x^i) - y^i ]^2 (which removes the sign, as this error could be both positive and negative) and sum it over all samples, and to <strong>bound it somehow we normalize it - simply by dividing by m,</strong> so we have mean (because we devide by number of samples) squared (because we square) error (because we compute an error):</p>
  
  <p>1/m * sum<em>(i=1)^m [ h</em>theta(x^i) - y^i ]^2
  <strong>This 2 which appears in the front is used only for simplification of the derivative</strong>, because when you will try to minimize it, you will use the steepest descent method, which is based on the derivative of this function. Derivative of a^2 is 2a, and our function is a square of something, so this 2 will cancel out. This is the only reason of its existance.</p>
</blockquote>

<p>이 <em>cost function</em> 은 <em>regression</em> 문제를 위해 자주 쓰이는 기법이다. </p>

<h3 id="costfunctionintuition1">Cost Function: Intuition 1</h3>

<p><em>Cost function</em> 에서 만약에 <code>0_0</code> 이 제로라면 <code>0_1</code> 만 찾으면 된다. 따라서 다음과 같은 실제 데이터에서</p>

<p><img src='http://cfile3.uf.tistory.com/image/2275174452D612AE06C75B'  />  </p>

<p align="center">(<a href='http://mapository.tistory.com/59' >http://mapository.tistory.com/59</a>)</p>

<p><code>J(0_1)</code> 을 찾아보면, 다음과 같은 이차함수가 나온다.</p>

<p><img align="center" src='http://cfile29.uf.tistory.com/image/234E894A52D6113D1F8267'  />  </p>

<p align="center">(<a href='http://mapository.tistory.com/59' >http://mapository.tistory.com/59</a>)</p>

<p>당연히 이차함수이므로, 기울기가 0이 되는 지점은 <code>J(0_1)</code> 을 미분해서 찾으면 된다. (이래서 아까 1/2가 있던 것)</p>

<h3 id="costfunctionintuition2">Cost Function: Intuition 2</h3>

<p><em>Parameter</em> 가 <code>0_1</code> 만 있었을때는, (<code>0_0</code> = 0) <code>J(0_1)</code> 이 이차함수였지만, <code>J(0_0, 0_1)</code> 일때는 다음과 같은 모양을 보여준다.</p>

<p><img align="center" src='http://cfile2.uf.tistory.com/image/2232CA4C52D611111DDFCD'  />  </p>

<p align="center">(<a href='http://mapository.tistory.com/59' >http://mapository.tistory.com/59</a>)</p>

<p>여기서 <code>J(0_0, 0_1)</code> 값을 제외하고 <code>(0_0, 0_1)</code> 을 평면으로 나타내면 아래 사진에서 우측과 같은 여러 궤도가 나온다.</p>

<p><img src='http://cfile24.uf.tistory.com/original/2107074652D6134E0ECB0F'  align="center" />  </p>

<p align="center">(<a href='http://mapository.tistory.com/59' >http://mapository.tistory.com/59</a>)</p>

<p>여기서 같은 궤도에 있는 <code>(0_0, 0_1)</code> 쌍은, 같은 <code>J</code> 함수를 만든다. 그리고 재밌는 사실은 궤도가 가장 좁은 타원의 중심에 있는 <code>(0_0, 0_1)</code> 가 가장 작은 <code>J(0_0, 0_1)</code> 를 만들어 낸다.</p>

<h3 id="gradientdescent">Gradient Descent</h3>

<p><em>Gradient Descent</em> 알고리즘은 <em>Linear Regression</em> 에만 쓸 수 있는건 아니고, 범용적인 알고리즘이다. <em>cost function</em> 의 최소값을 찾기 위해 사용할 수 있는데, 다음과 같은 <code>J</code> 가 있을때,</p>

<p><img src='http://cfile28.uf.tistory.com/image/2401353E52D618322EDFB5'  align="center" />  </p>

<p align="center">(<a href='http://mapository.tistory.com/59' >http://mapository.tistory.com/59</a>)</p>

<p>높이를 비교해 가며 점점 낮은쪽으로 이동해 가면서 <code>J</code> 의 최소값을 찾을 수 있다. 식은 다음과 같은데,</p>

<p><img src='http://2.bp.blogspot.com/-AdV-O-MoZHE/TtLibFTaf9I/AAAAAAAAAVM/aOxUGP7zl98/s1600/gradient+descent+algorithm+OLS.png'  align="center" />  </p>

<p align="center">(<a href='http://econometricsense.blogspot.kr/2011_11_01_archive.html' >http://econometricsense.blogspot.kr/2011_11_01_archive.html</a>)</p>

<p>여기서 <code>:=</code> 는 <em>assignment</em> 다. <code>a(alpha)</code> 는 <em>learning rate</em> 라 부른다. 이때 <code>(0_0, 0_1)</code> 은 동시에 업데이트 되야한다. <strong>(Simultaneous update)</strong></p>

<h3 id="gradientdescentintuition">Gradient Descent: Intuition</h3>

<p>이제 저 식을 분해하기 위해 <code>J(0_1)</code> 처럼 <em>parameter</em> 하나만 놓고 보면, 이차원 함수가 나올테다. 만약 현재 <code>0_1</code> 이 이차함수의 최저점 우측에 있다면, <code>J(0_1)</code> 을 미분한 값<strong>(Slope, 기울기)</strong> 에 양수 <code>a</code> 를 곱한 값을 <code>0_1</code> 에서 뻬면서 갱신하면 <code>0_1</code> 은 점점 최저점 쪽으로 간다, </p>

<p>반대로 <code>0_1</code> 이 <code>J(0_1)</code> 의 좌측에 위치한다면 우측으로 이동하고, 아래는 그걸 요약한 그림이다.</p>

<p><img src='http://i.ytimg.com/vi/ud4o8AYe9tI/hqdefault.jpg'  align="center" /></p>

<p>따라서 <em>learning late</em> <code>a</code> 가 너무 작으면 <em>Gradient descent</em> 가 너무 느려진다. 왜냐하면 <code>0</code> 의 차이가 점점 작이지기 때문에 최저점에 도착할때 까지 너무 많은 step 이 필요하다.</p>

<p>반대로 너무 크면 최저점을 넘어갈 수 있다. 심지어 최저점에서 점점 더 멀어질 수 있다.</p>

<blockquote>
  <p>if <code>a</code> is too small, <em>gradient descent</em> can be slow <br/><br/>
  if <code>a</code> is too large, <em>gradient desscent</em> can overshoot the minimum, It may fail to converge, or even diverge</p>
</blockquote>

<p>그런데 이 <em>gradient descent</em> 알고리즘의 문제는 <strong>local optimum</strong> 수 있다는 점이다. 왜냐하면 <strong>local optimum</strong> 에서도 <code>J</code> 의 derivative 가 <code>0</code> 이기 때문이다.</p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Extrema_example.svg/2000px-Extrema_example.svg.png'  align="center" /><p align="center"><a href='http://en.wikipedia.org/wiki/Backpropagation' >http://en.wikipedia.org/wiki/Backpropagation</a></p></p>

<h3 id="gradientdescentforlinearregression">Gradient Descent For Linear Regression</h3>

<p>이제 <em>cost function</em> 을 <em>gradient descent</em> 에 집어넣고, 정리하자. <code>0_0(Theta zero)</code>, 과 <code>0_1(Theta one)</code> 대해서 시그마 내부 제곱을 각각 미분해서 정리하면,</p>

<p><img src='http://pingax.com/wp-content/uploads/2013/11/Convergence-300x107.png'   align="center" />  </p>

<p align="center">(<a href='http://pingax.com/linear-regression-with-r-step-by-step-implementation-part-1/' >http://pingax.com/linear-regression-with-r-step-by-step-implementation-part-1/</a>)</p>

<p>참고로 <strong>Convex function</strong> 은 <em>Bowl shaped</em> 처럼 <em>local optima</em> 가 없는 <code>h</code>(Hypothesis) 를 말한다. 따라서 <em>convex function</em> 을 선택할 수 있다면, 하는편이 낫다.</p>

<p><strong>Batch</strong> <em>gradient descent</em> 는 모든 training example 을 사용하는 <em>gradient descent</em> 를 말한다. (시그마에서)</p>

<p>어떤 경우에는 <em>gradient descent</em> 같은 interative algorithm 없이도 <code>min J(0_0, 0_1)</code> 를 풀 수 있다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://mercris.wordpress.com/' >http://mercris.wordpress.com/</a> <br />
(2) <a href='http://mapository.tistory.com/' >http://mapository.tistory.com/</a> <br />
(3) <a href='http://econometricsense.blogspot.kr/' >http://econometricsense.blogspot.kr</a> <br />
(4) <a href='http://pingax.com/' >http://pingax.com/</a></p>]]></description><link>http://1ambda.github.io/machine-learning-week-1/</link><guid isPermaLink="false">bf54bf16-5f85-4773-bc9c-658c74a10ecf</guid><category><![CDATA[coursera]]></category><category><![CDATA[machine lerning]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 06 Oct 2014 03:59:07 GMT</pubDate></item><item><title><![CDATA[Content-Type vs Accept, HTTP Header]]></title><description><![CDATA[<p>이 <a href='http://webmasters.stackexchange.com/questions/31212/difference-between-accept-and-content-type-http-headers' >답변</a> 이 젤 심플하다. </p>

<blockquote>
  <p>As you correctly note, the <strong>Accept</strong> header is used by HTTP clients to tell the server what content types they'll accept. The server will then send back a response, which will include a <strong>Content-Type</strong> header telling the client what the content type of the returned content actually is.</p>
  
  <p>However, as you may have noticed, HTTP requests can also contain <strong>Content-Type</strong> headers. Why? Well, think about POST or PUT requests. With those request types, the client is actually sending a bunch of data to the server as part of the request, and the <strong>Content-Type</strong> header tells the server what the data actually is (and thus determines how the server will parse it).</p>
  
  <p>In particular, for a typical POST request resulting from an HTML form submission, the Content-Type of the request will normally be either <strong>application/x-www-form-urlencoded</strong> or <strong>multipart/form-data</strong>.</p>
</blockquote>

<p>Request Header의 <code>Accept</code> 는 클라이언트가 <em>어떤 컨텐츠 타입을 받길 원하는가</em> 이고, <code>Content-Type</code> 은 어떤 컨텐츠 타입을 <em>실제로 보내는가</em> 를 기록한다. </p>

<p><code>PUT</code> 이나 <code>POST</code> 를 생각해 보면 Response Header 뿐만 아니라, Request Header 에도 <code>Content-Type</code> 이 포함될 수 있는데, HTML FORM 에서 생성되는 전형적인 <code>Content-Type</code> 은 <code>application/x-www-form-urlencoded</code> 와 <code>multipart/form-data</code> 다.</p>

<p>RFC 2616 원문을 보고 싶으면 이리로, <a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html' #sec14.1">Accept</a>, <a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html' #sec14.17">Content-Type</a></p>

<p><code>application/x-www-form-urlencoded</code> 는 <a href='http://www.w3.org/TR/html401/interact/forms.html' >Spec</a> 에 스페이스를 <code>+</code> 로 바꾸고, key-valur pair 사이를 <code>&amp;</code>로 분리하는 등의 일을 하는데, 큰 문제점이 하나 있다. 바로 non-alphanumeric bytes 가 <code>%HH</code> 로 변경되는데, 1byte 를 3bytes 로 바꾸면, 커다란 파일이나, 바이너리 혹은 non-ASCII 로 구성된 파일들을 보낼때 마다 굉장히 비효율적인 인코딩을 하게 된다.</p>

<p>그래서 나온게 바로 <code>multipart/form-data</code> 인데, 이건 데이터에 나타나지 않는 특별한 패턴, <strong>boundary</strong> 를 찾아 각 key-valur pair 를 <strong>part</strong> 로 나눈다. 각 파트마다 <strong>Content-Disposition</strong> 이라는 <strong>Content-Type</strong> 필드를 가지고 있고, 여기에 나온 MIME type 에 따라 적절한 인코딩을 한다. </p>

<pre><code class="html">&lt;FORM action="http://server.com/cgi/handle"  
       enctype="multipart/form-data"
       method="post"&gt;
   &lt;P&gt;
   What is your name? &lt;INPUT type="text" name="submit-name"&gt;&lt;BR&gt;
   What files are you sending? &lt;INPUT type="file" name="files"&gt;&lt;BR&gt;
   &lt;INPUT type="submit" value="Send"&gt; &lt;INPUT type="reset"&gt;
&lt;/FORM&gt;  
</code></pre>

<p>다음과 같은 Form 을 보낸다고 하면, 실제로는</p>

<pre><code>  Content-Type: multipart/form-data; boundary=AaB03x

   --AaB03x
   Content-Disposition: form-data; name="submit-name"

   Larry
   --AaB03x
   Content-Disposition: form-data; name="files"; filename="file1.txt"
   Content-Type: text/plain

   ... contents of file1.txt ...
   --AaB03x--
</code></pre>

<p>만약에 파일을 하나 더 보낸다면</p>

<pre><code>   Content-Type: multipart/form-data; boundary=AaB03x

   --AaB03x
   Content-Disposition: form-data; name="submit-name"

   Larry
   --AaB03x
   Content-Disposition: form-data; name="files"
   Content-Type: multipart/mixed; boundary=BbC04y

   --BbC04y
   Content-Disposition: file; filename="file1.txt"
   Content-Type: text/plain

   ... contents of file1.txt ...
   --BbC04y
   Content-Disposition: file; filename="file2.gif"
   Content-Type: image/gif
   Content-Transfer-Encoding: binary

   ...contents of file2.gif...
   --BbC04y--
   --AaB03x--
</code></pre>

<p>그렇다고 해서 <code>multipart/form-data</code> 가 항상 좋은건 아니다. 간단한 alpha-numeric 이라면 <strong>boundary</strong> 를 찾고 MIME 인코딩 하고 디코딩 하는 과정 대신 그냥 <code>application/x-www-form-urlencoded</code> 로 보내면 된다.</p>

<p>참고로, <code>Content-Type</code> 이 <code>text</code> 일 경우에는 문자 인코딩을 지정하기 위해 <code>charset</code> 을 사용할 수 있다. <code>text/plain; charset=utf-8</code> 처럼</p>

<p><a href='http://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data' >SO 답변</a> 에는 두 가지 컨텐츠 타입 뿐 아니라 <code>application/xml</code> 이나 <code>application/json</code> 을 이용해서도 binary 나 non-ascii 를 보낼수 있단다. </p>

<h3 id="applicationoctetstream">application/octet-stream</h3>

<p><code>Content-Type</code> 에 들어갈 수 있는 MIME 타입에는 <code>application/octet-stream</code> 이라는 arbitrary binary data 를 위한 값이 있다. 따라서</p>

<pre><code>Content-Type: application/octet-stream  
Content-Disposition: attachment; filename="picture.png"  
</code></pre>

<p>이건, 뭔진 모르겠지만 파일 이름은 <code>picture.png</code> 고 저장해줘, 라는 뜻이다.</p>

<pre><code>Content-Type: image/png  
Content-Disposition: attachment; filename="picture.png"  
</code></pre>

<p>이 요청은 이건 <code>png</code> 고, <code>picture.png</code> 라는 이름으로 저장해줘, 라는 뜻이다.</p>

<pre><code>Content-Type: image/png  
Content-Disposition: inline; filename="picture.png"  
</code></pre>

<p>이 요청은, 이건 <code>png</code> 인데 방법을 안다면 보여줘, 라는 뜻이다.</p>

<h3 id="contentencoding">Content-Encoding</h3>

<p><code>Content-Encoding</code> 은 그럼 무엇일까? <a href='http://en.wikipedia.org/wiki/HTTP_compression' >HTTP Compression</a> 을 보면, 클라이언트가 받길 기대하는 Encoding 의 목록이라고 나와있다. 문자열 인코딩이 아니라, <code>gzip</code> 이나 <code>bzip2</code>, <code>deflate</code> 같은 압축 방법이다. </p>

<p>먼저 클라이언트가 다음과 같이 요청을 보내면</p>

<pre><code>GET /encrypted-area HTTP/1.1  
Host: www.example.com  
Accept-Encoding: gzip, deflate  
</code></pre>

<p>서버가 다음과 같이 보낼 수 있다. </p>

<pre><code>HTTP/1.1 200 OK  
Date: mon, 4 Oct 2014 22:38:34 GMT  
Server: Apache/1.3.3.7 (Unix)  (Red-Hat/Linux)  
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT  
Accept-Ranges: bytes  
Content-Length: 438  
Connection: close  
Content-Type: text/html; charset=UTF-8  
Content-Encoding: gzip  
</code></pre>

<p>그럼 클라이언트는 <code>Content-Encoding</code> 필드를 파악한 뒤, 압축을 풀거나 하면 된다. </p>

<h3 id="transferencoding">Transfer-Encoding</h3>

<p><em>end-to-end</em> 인 <code>Content-Encoding</code> 과는 반대로 <code>Transfer-Encoding</code> 은 <code>hop-toh-top</code> 이다. <a href='http://stackapps.com/questions/916/why-content-encoding-gzip-rather-than-transfer-encoding-gzip' >SO 답변</a>을 그대로 가져오면</p>

<blockquote>
  <p>Transfer-Encoding is hop-by-hop, while Content-Encoding is end-to-end.</p>
  
  <p>This means that if there is a proxy involved, anywhere, the proxy will see the TE gzip, unzip it, and not necessarily forward the request as TE gzip.</p>
  
  <p>So, the choices are</p>
  
  <p>CE gzip and always know what you will be getting, requiring logic to decompress the response.</p>
  
  <p>TE gzip and never know what you will be getting requiring logic to decide whether to decompress the response and the logic to decompress it when required.</p>
  
  <p>The logical choice is CE gzip.</p>
</blockquote>

<p>요약하자면, <code>CE(Content-Encoding)</code> 은 <code>gzip</code>(예를들어) 되어 올걸 알기 때문에  압축을 풀 로직이 필요한 반면, <code>TE(Content-Encoding)</code> 은 중간에 <code>gzip</code> 을 풀 수 있는 프록시가 있다면, 풀려서 올수도 있고 아닐 수도 있기 때문에 압축을 푸는 로직은 물론, 풀어야 하는지 아닌지를 결정할 수 있는 로직도 필요하다. </p>

<p>아래는 RFC 2616(HTTP 1.1) 에서 <strong>Roy T. Fielding</strong> 이 작성한 글</p>

<blockquote>
  <p>changing content-encoding on the fly in an inconsistent manner (neither "never" nor "always) makes it impossible for later requests regarding that content (e.g., PUT or conditional GET) to be handled correctly. This is, of course, why performing on-the-fly content-encoding is a stupid idea, and why I added Transfer-Encoding to HTTP as the proper way to do on-the-fly encoding without changing the resource.</p>
</blockquote>

<h3 id="transferencodingchunked">Transfer-Encoding: Chunked</h3>

<p><a href='http://en.wikipedia.org/wiki/Chunked_transfer_encoding' >Chunked transfer encoding</a> 에 보면, HTTP Response 를 여러번 보낼 수 있는 방법이 있다. 바로 <code>Content-Length</code> 대신 <code>Transfer-Encoding</code> 에 <code>chunked</code> 값을 넣어 보내다가 final chunked(empty) 가 오면 끝난다.</p>

<p>예를들어, 서버가 다음과 같은 데이터를 보내면 (2라인씩 쌍지어 첫줄은 데이터의 길이, 두번째는 실제 데이터 chunk 다)</p>

<pre><code>4\r\n  
Wiki\r\n  
5\r\n  
pedia\r\n  
e\r\n  
 in\r\n\r\nchunks.\r\n
0\r\n  
\r\n
</code></pre>

<p>클라이언트는 다음과 같이 해석한다. 각 chunk 는 <code>CLRF</code> 로 끝나며 이건 길이에 포함되지 않는다. final chunk 는 길이가 <code>\r\n</code> 로만 표시된다.</p>

<pre><code>Wikipedia in

chunks.  
</code></pre>

<p><a href='http://en.wikipedia.org/wiki/Chunked_transfer_encoding' #rationale">여기</a> 보면 이걸 쓰는 이유가 몇 가지 나오는데,</p>

<p>(1) HTTP persistent connection 을 만들 수 있고 <br />
(2) 마지막에 부가적인 헤더를 첨부할 수 있으며 <br />
(3) <code>Content-Encoding</code> 과 같이 쓰일 수 있다.</p>

<h3 id="summary">Summary</h3>

<p>HTTP 헤더를 좀 살펴 보았다. <a href='http://en.wikipedia.org/wiki/HTTP/2' >HTTP 2.0</a> 나 <a href='http://en.wikipedia.org/wiki/SPDY' >SPDY</a> 도 좀 살펴보자.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://www.w3.org/TR/html401/interact/forms.html' #h-17.13.4">HTML Form Specification</a> <br />
(2) <a href='http://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data' >form-data vs x-www-urlencoded</a> <br />
(3) <a href='http://stackoverflow.com/questions/20508788/do-i-need-content-type-application-octet-stream-for-file-download' >application/octet-stream</a> <br />
(4) <a href='http://stackapps.com/questions/916/why-content-encoding-gzip-rather-than-transfer-encoding-gzip' >why-content-encoding-gzip-rather-than-transfer-encoding-gzip</a> <br />
(5) <a href='http://stackoverflow.com/questions/11641923/transfer-encoding-gzip-vs-content-encoding-gzip' >Transfer-Encoding vs Content-Encoding</a></p>]]></description><link>http://1ambda.github.io/content-type-vs-accept-http-header/</link><guid isPermaLink="false">44d146f0-65e4-42e0-ac79-93f0a672a238</guid><category><![CDATA[Accept]]></category><category><![CDATA[content-type]]></category><category><![CDATA[HTTP]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 05 Oct 2014 08:55:05 GMT</pubDate></item><item><title><![CDATA[PUT vs POST, REST API]]></title><description><![CDATA[<h3 id="idempotent">idempotent</h3>

<p><code>PUT</code> 과 <code>POST</code> 를 이해하려면, <strong><a href='http://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation' >idempotent</a></strong> 라는 개념의 도입이 필요하다. 한글로 직역하면 <em>멱등의</em> 정도 되시겠다. 수학적으로 이해하는 편이 쉬운데, </p>

<p><em>f(x) = f(f(x))</em></p>

<p>라 보면 된다. 다시 말해 몇 번이고 같은 <em>연산</em> 을 반복해도 같은 값이 나온다는 것. 이건 fault-tolerant API 를 디자인 하는데 있어서 굉장히 중요한 요소다.</p>

<p>예를 들어보자. 클라이언트가 <code>POST /dogs</code> 를 요청했는데, 어떤 이유로간에 요청이  time-out (408) 되었다고 해 보자. 클라이언트는 요청이 전달되었으나 네트워크가 끊어졌는지, 아니면 요청조차 전달이 되지 않았는지 알 수 없다.</p>

<p>이 때, 클라이언트가 원하는 operation 이 <strong>idempotent</strong> 하다면 다시 요청해도 상관 없다. 항상 같은 결과를 만드니까. 그러나 <code>POST</code> 는 <strong>idempotent</strong> 하지 않다.</p>

<h3 id="post">POST</h3>

<p><code>POST</code> 는 클라이언트가 <em>리소스의 위치를 지정하지 않았을때</em> 리소스를 생성하기 위해 사용하는 연산이다. 예를들어</p>

<pre><code class="json">POST /dogs HTTP/1.1

{ "name": "blue", "age": 5 }

HTTP/1.1 201 Created  
</code></pre>

<p>따라서 이 연산을 수행하면 <code>/dogs/2</code> 에 생기고, 그 다음번엔 <code>/dogs/3</code> 등 매번 다른곳에 새로운 리소스가 생성될 수 있으므로, 이 연산은 <strong>idempotent 하지 않다</strong>.</p>

<h3 id="put">PUT</h3>

<p>반면 리소스의 위치가 명확히 지정된 다음의 요청을 고려해 보자.</p>

<pre><code class="json">PUT /dogs/3 HTTP/1.1

{ "name": "blue", "age": 5 }
</code></pre>

<p><code>/dogs</code> 의 프로퍼티가 <code>name</code> 과 <code>age</code> 뿐이라면, 이건 몇 번을 수행하더라도, 같은 결과를 보장한다. 다시 말해 <strong>idempotent</strong> 하다.</p>

<p>그리고 위에 예에서 알 수 있듯이 <code>PUT</code> 은 <em>리소스의 위치가 지정되었을때</em> <strong>생성</strong> 또는 <strong>업데이트</strong> 를 위해 사용할 수 있다. </p>

<h3 id="patch"> PATCH</h3>

<p><code>PUT</code> 이 리소스의 모든 프로퍼티를 업데이트 하기 위해 사용된다면, <code>PATCH</code> 는 부분만을 업데이트하기 위해 사용한다. <code>PUT</code> 과 마찬가지로 리소스의 위치를 클라이언트가 알고 있을 때 사용한다.</p>

<p><a href='http://stackoverflow.com/questions/630453/put-vs-post-in-rest' >SO</a> 에는 3개의 메소드를 다음과 같이 요약하는 답변이 있다.</p>

<p>(1) <strong>POST</strong> to a URL <strong>creates a child resouce</strong> at a server defiend URL <br />
(<a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html' #sec9.5">RFC 2616 POST</a>) <br />
(2) <strong>PUT</strong> to a URL <strong>create/replaces the resource</strong> in is entirely at the client defined URL <br />
(<a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html' #sec9.6">RFC 2616 PUT</a>) <br />
(3) <strong>PATCH</strong> to a URL <strong>updates part of the resource</strong> at that client defined URL <br />
(<a href='http://tools.ietf.org/html/rfc5789' >RFC 5789: Patch Method for HTTP</a>)</p>

<h3 id="responsecode">Response Code</h3>

<p><code>POST</code> 이나 <code>POST</code> 요청이 리소스를 새로 생성할 경우엔 리소스의 위치를 response header 의 <strong>Location</strong> field 에 담아 <em>201 Created</em> 를 보낼 수 있다. 그러나 not-identifiable 한 리소스를 생성할 경우엔 <em>200 OK</em> 또는 <em>204 No Content</em> 를 보낼수도 있다.  </p>

<p><a href='http://www.w3.org/Protocols' 이나 <code>POST</code> /rfc2616/rfc2616-sec9스의tml#sec9.5">원문</a>을 첨부하자면, </p>

<blockquote>
  <p>The action performed by the POST method might not result in a resource that can be identified by a URI. In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result. <br/><br/>
  If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header (see section 14.30).</p>
</blockquote>

<p>Async 하게 서버가 처리한다면, 요청은 수락 되었으나 아직 커밋되지 않았음을 알리기 위해 <em>202 Accepted</em> 를 보내야 한다. (if the operation has not been commited yet)</p>

<p>아래 사진은, response code decision tree</p>

<p><br/> <br />
<a href='http://i.stack.imgur.com/whhD1.png' ><img src='http://i.stack.imgur.com/whhD1.png'  /></a><p align="center">(<a href='http://i.stack.imgur.com/whhD1.png' >http://i.stack.imgur.com/whhD1.png</a>)</p> <br />
<br/></p>

<h3 id="safemethods">Safe Methods</h3>

<p>리소스를 수정하지 않는 메소드들, <code>OPTIONS</code>, <code>GET</code>, <code>HEAD</code> 등을 <em>safe</em> 하다고 말한다. 대부분의 경우 <em>idempotent</em> 하면 <em>safe</em> 하다. 물론 예외도 있는데 <code>DELETE</code> 는 <em>idempotent</em> 하지만 리소스를 변경하므로 <em>safe</em> 하지 않다. 자세한 내용은 <a href='http://tools.ietf.org/html/rfc7231' #section-4.2">RFC 7231: Safe Methods</a> 를 보자. 참고로 <a href='http://tools.ietf.org/html/rfc7231' #section-4.2.1">RFC 7231</a> 은 <code>PUT</code>, <code>DELETE</code> 와 <em>safe methods</em> 를 <em>idempotent</em> 하다고 정의한다.</p>

<p><code>HEAD</code> 는 Response-Body 없이 Header 만 얻기 위해 사용하고, <code>OPTIONS</code> 는 해당 리소스에 대해 가능한 operation 이 무엇인지 응답을 얻기 위해 사용한다. 만약 <code>OPTIONS</code> 에 대한 응답이 온다면 response <code>Allow</code> 에 가능한 operation 이 와야한다. <a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html' >RFC2616</a> 에는 다음과 같이 나와있다.</p>

<blockquote>
  <p>The <code>OPTIONS</code> method represents a request for information about the communication options available on the request/response chain identified by the Request-URI. This method allows the client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval. <br/><br/>
  Responses to this method are not cacheable.</p>
</blockquote>

<h3 id="cacheablemethods">Cacheable Methods</h3>

<p>왜 <code>OPTIONS</code> 메소드에 대한 응답은 캐시가 불가능한걸까? SO 에서 이 <a href='http://stackoverflow.com/questions/13073313/http-options-not-cacheable' >답변</a> 이 제일 나은것 같아서 가져왔다.</p>

<blockquote>
  <p>The <code>OPTIONS</code> HTTP request returns the available methods which can be performed on a resource. (The objects methods)</p>
  
  <p>I can not say for certain why you can not cache the response, but its most likely a precaution. Caching would have little value for the <code>OPTIONS</code> http method.</p>
  
  <p>A Resource is "any information that can be given a name", that name is its URI. the response from the OPTIONs request is only a list of methods that can be requested on this resource (e.g. "GET PUT POST" maybe the response). To actually get at the information stored, you must use the GET method.</p>
  
  <p>History, more than anything; OPTIONS was defined that way to start with. The underlying reason is that HTTP caches are defined in terms of representations, which means the way you get something out of the cache is GET. This is why OPTIONS, PROPFIND, etc. caching are problematic.</p>
</blockquote>

<p>다시 말해서, 리소스는 주어진 URI 에 대한 정보인데 <code>OPTIONS</code> 는 정보를 가지고 오는 것이 아니라, 정보에 대해 어떤 연산이 가능한지를 알려준다. HTTP 에서는 정보에 대해 캐싱하므로, <code>GET</code> 이나 <code>HEAD</code> 같이 정보를 돌려주는 연산만 캐싱할 수 있다.</p>

<h3 id="traceconnect">Trace, Connect</h3>

<p><code>TRACE</code> 는 클라이언트가 방금 보낸 요청을 다시 달라고, 서버에게 요청하는 것이고 <code>CONNECT</code> 는 HTTP 터널링을 할때 쓰인다. 중간의 프록시 서버를 위해서는 <code>CONNECT</code> 로 요청하고, 마지막 프록시에서 end-point 로는 <code>GET</code> 또는 <code>CONNECT</code> 를 날린다. <code>HTTPS</code> 라면 <code>CONNECT</code> 를, <code>HTTP</code> 라면 둘 중 아무거나 써도 상관 없다. 더 자세한건 <a href='http://stackoverflow.com/questions/11697943/when-should-one-use-connect-and-get-http-methods-at-http-proxy-server' >SO 답변</a> 으로</p>

<p>원문을 첨부하면,</p>

<blockquote>
  <p><strong>CONNECT:</strong> This method could allow a client to use the web server as a proxy.</p>
  
  <p><strong>TRACE:</strong> This method simply echoes back to the client whatever string has been sent to the server, and is used mainly for debugging purposes. This method, originally assumed harmless, can be used to mount an attack known as Cross Site Tracing, which has been discovered by Jeremiah Grossman (see links at the bottom of the page).</p>
</blockquote>

<h3 id="summary">Summary</h3>

<p>HTTP 메소드에 대해서 알아보았는데, 조금 더 찾아보니 HTTP 는 0.9 -> 1.0 -> 1.1 순으로 변화했다고 한다. 0.9 에선 <code>GET</code> 을 이용한 Read-only 버전이었고 1.0 에 들어와서야 <code>HEAD</code>, <code>POST</code> 등을 이용해 서버로 데이터 전송이 가능해졌다.   HTTP 1.1 (RFC 2616) 에 와서야 <code>DELETE</code>, <code>PUT</code> 등이 추가되면서 변경, 삭제까지 가능해졌다.</p>

<p>다음번에 HTTP 를 또 살펴 볼 일이 생긴다면, <a href='http://tools.ietf.org/html/rfc7234' >RFC 7243: Caching</a> 과 <a href='http://tools.ietf.org/html/rfc7235' >RFC 7235: Authentication</a> 에 대해서 보지 않을까 싶다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://restcookbook.com/HTTP%20Methods/put-vs-post/' >REST Cookbook: PUT vs POST</a> <br />
(2) <a href='http://stackoverflow.com/questions/2342579/http-status-code-for-update-and-delete' >HTTP status code for UPDATE and DELETE</a> <br />
(3) <a href='http://stackoverflow.com/questions/630453/put-vs-post-in-rest/18243587' #18243587">PUT vs POST in REST</a> <br />
(4) <a href='http://restcookbook.com/HTTP%20Methods/idempotency/' >REST Coookbook: idempotency</a> <br />
(5) <a href='http://zacstewart.com/2012/04/14/http-options-method.html' >HTTP OPTIONS Method</a> <br />
(6) <a href='https://www.mnot.net/blog/2012/10/29/NO_OPTIONS' >NO OPTIONS</a> <br />
(7) <a href='http://www.mkexdev.net/Article/Content.aspx?parentCategoryID=1&amp;categoryID=11&amp;ID=119' >HTTP History</a> <br />
(8) <a href='http://stackoverflow.com/questions/13073313/http-options-not-cacheable' >HTTP OPTIONS not cacheable</a> <br />
(9) <a href='http://stackoverflow.com/questions/11697943/when-should-one-use-connect-and-get-http-methods-at-http-proxy-server' >CONNECT vs GET in proxy</a></p>]]></description><link>http://1ambda.github.io/put-vs-post-restful-api/</link><guid isPermaLink="false">cfc3ba0b-d27f-4ce2-8a41-61b7eab5b4c1</guid><category><![CDATA[post]]></category><category><![CDATA[put]]></category><category><![CDATA[REST]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 05 Oct 2014 05:23:28 GMT</pubDate></item><item><title><![CDATA[Partial Functions, Scala]]></title><description><![CDATA[<h3 id="case">Case?</h3>

<p><code>case</code> 는 <code>match</code> 가 없어도 쓰일 수 있다. 예를 들어</p>

<pre><code class="scala">val m1 = Map(1 -&gt; "one", 2 -&gt; "two")  
m1 foreach { case(k, v) =&gt; println(s"k -&gt; v" }  
</code></pre>

<p>사실, <code>case</code> 가 들어간 문장은 <code>function</code> 이다. Scala Doc 을 보면, <code>scala.collection.immutable.Map</code> 의 <code>foreach</code> 는 다음처럼 정의되어 있다.</p>

<pre><code class="scala">def foreach(f: ((A, B)) =&gt; Unit): Unit  
</code></pre>

<h3 id="mapvscollect">Map vs Collect</h3>

<p>여기 재미난 예제가 하나 더 있다. <code>map</code> 과 <code>collect</code> 가 서로 다른 결과를 보여준다.</p>

<pre><code class="scala">scala &gt; val l = List(490, "Nexus5")  
scala &gt; l map { case i: Int =&gt; i * 1000 }

scala.MatchError: Nexus5 (of class java.lang.String)  
  at $anonfun$1.apply(&lt;console&gt;:9)
  at $anonfun$1.apply(&lt;console&gt;:9)
  at scala.collection.immutable.List.map(List.scala:276)
</code></pre>

<p>문자열인 <code>"Nexus5"</code> 를 만나면 <code>MatchError</code> 가 발생한다. 반면 <code>collect</code> 는 </p>

<pre><code class="scala">scala &gt; val l = List(490, "Nexus5")  
scala &gt; l collect { case i: Int =&gt; i * 1000 }  
res11: List[Int] = List(49000)  
</code></pre>

<p>왜 그럴까? <code>scala.collection.immutable.List</code> 의 <code>collect</code> 정의를 한번 보자.</p>

<pre><code class="scala">def collect[B](pf: PartialFunction[A, B]): Map[B]  
</code></pre>

<p><code>function</code> 이 아니고 <code>PartialFunction</code> 을 취한다.</p>

<h3 id="partialfunction">Partial Function</h3>

<p><em>Partial Function</em> 을 이해하는 쉬운 방법은, 일반 <em>Function</em> 을 <em>Total Function</em> 으로 이해하면 된다. 즉, 일반 <em>Function</em> 이 주어진 인자에 대해 모든 값을 취한다면, <em>Partial Function</em> 은 주어진 타입에 대해서 특정 값만 취할 수 있다. Scala School 의 원문을 첨부하면</p>

<blockquote>
  <p>A function works for every argument of the defined type. In other words, a function defined as (Int) => String takes any Int and returns a String.
  </br> <br />
  A Partial Function is only defined for certain values of the defined type. A Partial Function (Int) => String might not accept every Int.
  <br/></p>
</blockquote>

<pre><code class="scala">val onlyOne : PartialFunction[Int, String] = { case 1 =&gt; "one" }

onlyOne.isDefinedAt(1) // true  
onlyOne.isDefinedAt(2) // false  
</code></pre>

<p><code>onlyOne</code> 은 <code>Int</code> 를 인자로 받지만, 그 중에서도 <code>1</code> 만 취해 <code>"one"</code> 을 돌려주는 <code>PartialFunction[Int, String]</code> 이다.</p>

<p><code>PartialFunction</code> 또한 compose 될 수 있다.</p>

<pre><code class="scala">val onlyOne : PartialFunction[Int, String] = { case 1 =&gt; "one" }  
val onlyTwo : PartialFunction[Int, String] = { case 2 =&gt; "two" }  
val wildcard : PartialFunction[Int, String] = { case _ =&gt; "else" }

val partial = onlyOne orElse onlyTwo orElse wildcard  
</code></pre>

<h3 id="case">Case!</h3>

<p>처음엔 <code>case</code> 가 <code>Function</code> 을 만든다고 했지만, 사실 <code>PartialFunction</code> 을 정의한다. <code>map</code> 나 <code>filter</code> 는 <code>Function</code> 을 받지만, <code>PartialFunction</code> 은 <code>Function</code> 의 subtype 이므로 파라미터로 넘겨줄 수 있다.</p>

<pre><code class="scala">case class Car(model: String, price: Int)

val list = List(Car("H", 3000), Car("A", 2800))

list filter { case Car(model, price) =&gt; price &lt; 2900 }

// List[Car] = List(Car("A", 2800))
</code></pre>

<h3 id="references">References</h3>

<p>(1) <a href='http://blog.bruchez.name/2011/10/scala-partial-functions-without-phd.html' >http://blog.bruchez.name/2011/10/scala-partial-functions-without-phd.html</a> <br />
(2) <a href='https://twitter.github.io/scala_school/pattern-matching-and-functional-composition.html' >https://twitter.github.io/scala_school/pattern-matching-and-functional-composition.html</a></p>]]></description><link>http://1ambda.github.io/partial-functions-scala/</link><guid isPermaLink="false">38ff8181-481c-4535-8106-52584a473c95</guid><category><![CDATA[scala]]></category><category><![CDATA[partial function]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 03 Oct 2014 16:28:12 GMT</pubDate></item><item><title><![CDATA[new to Play Framework 2]]></title><description><![CDATA[<p><em>Play Framework</em> 를 배우기로 마음먹었다. 새로운 무언가를 마주쳤을때, 어떻게 해결할까를 위주로 서술했다.</p>

<h3 id="installation">Installation</h3>

<p>우선 설치를 해야했다. <em>Play</em> 를 배포하는 Typesafe 의 <a href='https://typesafe.com/platform/getstarted' >Getting Started</a> 에 들어가서, 확인해보니 <strong>activator</strong> 라는 제품으로 <em>Play</em> 를 감싸 편하게 개발할 수 있도록 해주는 플랫폼을 만들어 놨다. </p>

<p><a href='https://www.playframework.com/documentation/2.3.x/Installing' >Installing Play</a> 를  참조해서 <strong>activator</strong> 설치 후에, <strong>PATH</strong> 에 추가했다. <a href='https://www.playframework.com/documentation/2.3.x/NewApplication' >Creating New Application</a> 와 <a href='https://www.playframework.com/documentation/2.3.x/PlayConsole' >Activator Console Usage</a> 을 참조해서 새 프로젝트를 생성하고, <strong>activator</strong> 의 기본적인 사용법을 익혔다.</p>

<pre><code class="scala">$ activator new example-app play-scala
$ cd example-app
$ ./activator run
</code></pre>

<p><strong>activator</strong> 는 <strong>sbt</strong> 위에서 돌아가는 또 다른 콘솔이기 때문에, 이렇게도 쓸 수 있다.</p>

<pre><code class="scala">$ sbt
[example-app] $ compile
[example-app] $ test
[example-app] $ run
</code></pre>

<p>IDE intergration 을 하려고 <a href='https://www.playframework.com/documentation/2.3.x/PlayConsole' >https://www.playframework.com/documentation/2.3.x/PlayConsole</a> 를 따라했는데 잘 안됀다. 나는 emacs 를 쓰는데 <code>ensime</code> 과 <code>activator</code> 가 디펜던시 충돌이 있는 것 같다. <code>ensime</code> 을 쓰지 않기로 결정했다. 구글링 해보니 <code>ensime-sbt</code> 0.17 에서 해결한단다. 지금은 0.15-SNAPSHOT 인데 1-2 달 걸린다고 하고 자세한건 <a href='https://github.com/sbt/sbt/issues/1592' >https://github.com/sbt/sbt/issues/1592</a> 여기 참조.</p>

<h3 id="directorystructure">Directory Structure</h3>

<p>이제 뭘 하려면 파일을 수정해야 하는데, <strong>activator</strong> 가 생성해주는 파일이 생각보다 많아서 무엇을 수정해야하는지 좀 난감했다. <a href='https://www.playframework.com/documentation/2.3.x/NewApplication' >Anatomy of a Play Application</a> 을 참조해서 디렉토리 구조를 살펴봤다.</p>

<pre><code>app                      → Application sources  
 └ assets                → Compiled asset sources
    └ stylesheets        → Typically LESS CSS sources
    └ javascripts        → Typically CoffeeScript sources
 └ controllers           → Application controllers
 └ models                → Application business layer
 └ views                 → Templates
build.sbt                → Application build script  
conf                     → Configurations files and other non-compiled resources (on classpath)  
 └ application.conf      → Main configuration file
 └ routes                → Routes definition
public                   → Public assets  
 └ stylesheets           → CSS files
 └ javascripts           → Javascript files
 └ images                → Image files
project                  → sbt configuration files  
 └ build.properties      → Marker for sbt project
 └ plugins.sbt           → sbt plugins including the declaration for Play itself
lib                      → Unmanaged libraries dependencies  
logs                     → Standard logs folder  
 └ application.log       → Default log file
target                   → Generated stuff  
 └ scala-2.10.0            
    └ cache              
    └ classes            → Compiled class files
    └ classes_managed    → Managed class files (templates, ...)
    └ resource_managed   → Managed resources (less, ...)
    └ src_managed        → Generated sources (templates, ...)
test                     → source folder for unit or functional tests  
</code></pre>

<p><code>build.sbt</code> 에 빌드 스크립트가, <code>project/plugins.sbt</code> 에 디펜던시가 나열되어 있었고 <code>lib</code> 폴더 내에 unmanaged 디펜던시를 넣게끔 되어 있었다. <code>build.properties</code> 는 <strong>sbt</strong> 버전이 기록되어있다. </p>

<p>로그같은 경우는 <code>logs</code> 폴더가 따로 있고, 여기 내에 <code>application.log</code> 파일에 디폴트로 로그가 쌓인다. </p>

<p><code>conf</code> 밑에는 <code>application.conf</code> 에 데이터베이스 커넥션이나, 로거 세팅등 <em>Play</em> 에서 사용하는 세팅이 적게끔 되어있다. <code>routes</code> 는 URL 세팅이 담겨있다. 새로운 API를 추가하면, 아마 여기에도 추가해야 할 것 같다.</p>

<p><code>app</code> 은 다른 웹 프레임워크처럼 <code>views</code>, <code>controllers</code>, <code>models</code> 와 같은 디렉터리가 있다. <code>views</code> 밑에 템플릿 파일들을 보면 파일 이름이 <code>main.scala.html</code>, <code>index.scala.html</code> 과 같은데, 이건 조금 더 살펴봐야겠다.</p>

<p><em>Play</em> 는 LESS 나 Stylus, Coffee 처럼 pre-processor 의 소스코드를 <code>app/assets</code> 하위에 놓고, 빌드 스크립트를 이용해서 <code>public</code> 으로 컴파일 되도록 해 놓았다.</p>

<h3 id="helloworld">Hello World</h3>

<p>이제 준비는 다 되었으니, <strong>Hello Wolrd</strong> 를 찍을 차례다. 다 됐고, <code>views</code> 폴더 밑에 있는 파일을 수정해야겠다. <code>localhost:9000</code> 를 입력했을때 나오는 컨트롤러와 뷰를 찾기 위해서 <code>conf/routes</code> 를 확인하니, 아래와 같았다.</p>

<pre><code class="scala"># Routes
# This file defines all application routes (Higher priority routes first)
# ~~~~

# Home page
GET     /                           controllers.Application.index

# Map static resources from the /public folder to the /assets URL path
GET     /assets/*file               controllers.Assets.at(path="/public", file)  
</code></pre>

<p><code>GET /</code> 했을때, <code>controllers/Application.scala</code> 파일로 간다.</p>

<pre><code class="scala">// controllers/Application.scala

package controllers

import play.api._  
import play.api.mvc._

object Application extends Controller {

  def index = Action {
    Ok(views.html.index("Your new application is ready."))
  }
}
</code></pre>

<p><code>views/index.scala.html</code> 에 <code>"Your new application is ready."</code> 를 전달한다. <code>Action</code> 과 <code>Ok</code> 은 무엇인지 몰라서 구글링 해보니 <a href='https://www.playframework.com/documentation/2.3.x/ScalaActions' >What is Action</a> 이라는 문서가 있다. 이 문서에 의하면 <code>Action</code> 은 <code>play.api.mvc.Request</code> 를 받아 <code>play.api.mvc.Response</code> 를 만드는 함수다.</p>

<pre><code class="scala">Action {  
  Ok("Hello world")
}
</code></pre>

<p>이 경우 <code>Ok</code> 는 <strong>HTTP Status 200</strong> 과 <code>text/plain</code> 컨텐츠를 담고있는 <code>play.api.mvc.Response</code> 를 만들어 낸다. 그리고 <code>play.api.mvc.Action</code> 의 컴패니온 오브젝트는 다양한 헬퍼를 제공하는데, 아래가 그 예다.</p>

<pre><code class="scala">Action { request =&gt;  
  Ok("Got request [" + request + "]")
}

Action(parse.json) { implicit request =&gt;  
  Ok("Got request [" + request + "]")
}
</code></pre>

<p>근데 그 전에, <code>implicit</code> 에 대해서 이해가 안됀다. <a href='http://stackoverflow.com/questions/10375633/understanding-implicit-in-scala' >Understanding implicit in Scala</a> 라는 SO(Stackoverflow) 질문에서 <a href='http://pietrowski.info/2009/07/scala-implicit-conversion/' >Scala Implicit Conversion</a> 이라는 블로그도 찾아냈다. </p>

<p><strong>Implicit conversion</strong> 은, 쉽게 말해서 <code>A</code> 가 필요할때 <code>B</code> 가 있고, 타입이 맞지 않는다면, <code>A -&gt; B</code> 를 해줄 수 있는 <code>implicit function value</code> 을 찾는다. (물론 <code>A</code> 와 <code>B</code>에 대한 컴패니온 오브젝트도 찾아서, 변환할 수 있으면 변환도 할거고). <code>function</code> 대신 <code>def</code> 를 사용해도 <strong>eta-expanded</strong> 될 것이므로 문제 없다. SO 의 원문도 첨부하면</p>

<blockquote>
  <p>When the compiler finds an expression of the wrong type for the context, it will look for an implicit Function value of a type that will allow it to typecheck. So if an A is required and it finds a B, it will look for an implicit value of type B => A in scope (it also checks some other places like in the B and A companion objects, if they exist). Since defs can be "eta-expanded" into Function objects, an implicit def xyz(arg: B): A will do as well.</p>
</blockquote>

<p><br/> <br />
이제, 컨트롤러를 일단 해결 했으니 <code>views/index.scala.html</code> 로 넘어가자.</p>

<pre><code class="scala">@(message: String)

@main("Welcome to Play") {

    @play20.welcome(message)

}
</code></pre>

<p><code>controlers/Application.scala</code> 컨트롤러에서 넘어온 문자열 값 <code>"Your new application is ready"</code> 가 <code>message</code> 변수에 들어가고 <code>@</code> 가 <em>Play</em> 템플릿 엔진에서 사용하는 문법 인것 같다. <code>@main</code> 은 아마 <code>views/main.scala.html</code> 을 <em>include</em> 하는 문법 같다. <code>main.scala.html</code> 의 내용은 아래와 같다.</p>

<pre><code class="html">@(title: String)(content: Html)

&lt;!DOCTYPE html&gt;

&lt;html&gt;  
    &lt;head&gt;
        &lt;title&gt;@title&lt;/title&gt;
        &lt;link rel="stylesheet" media="screen" href='http://1ambda.github.io/@routes.Assets.at' ("stylesheets/main.css")"&gt;
        &lt;link rel="shortcut icon" type="image/png" href='http://1ambda.github.io/@routes.Assets.at' ("images/favicon.png")"&gt;
        &lt;script src='http://1ambda.github.io/@routes.Assets.at' ("javascripts/hello.js")" type="text/javascript"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        @content
    &lt;/body&gt;
&lt;/html&gt;  
</code></pre>

<p>조금 난해하긴 한데, <code>@main</code> 이 <code>main.scala.html</code> 를 부르는거라 생각하면, 두개의 인자를 <code>main.scala.html</code> 에서 받으므로 <code>index.scala.html</code> 의 <code>@main</code> 부분 에서도 두개를 넘겨줘야 한다. 하나는 컨트롤러에서 받은 <code>message</code> 고 두번째 인자는 <code>main(message)</code> 가 리턴하는 함수에 넘겨줄 <code>content</code> 변수를 <code>play20.welcome</code> 를 통해서 만들어 낸다. 아직 왜 커링을 이용하는진 모르겠다.</p>

<p>찾아보니 <code>target/scala-2.11/twirl/main/views/html/index.template.scala</code> 에서 <code>play20.welcome</code> 을 호출한다. 아마 빌트인 라이브러리인가 보다. </p>

<p>템플릿 엔진에 대해 이해하기 전에, 일단 <code>welcome</code> API 부터 만들어 보자. 구글에서 검색하니 <a href='https://github.com/playforscala/sample-applications/' >Play for Scala, Sample Application</a> 라는 프로젝트가 있어서 참고했다.</p>

<p>결국 내가 <code>GET /welcome</code> 를 만들려면, <code>controllers/Application.scala</code> 에 메소드를 아래와 같이 추가한 뒤 </p>

<pre><code class="scala">def welcome(name: String) = Action {  
  Ok("welcome " + name)
}
</code></pre>

<p>해당 API 를 <code>conf/routes</code> 에 추가한다.</p>

<pre><code>GET    /welcome            controllers.Application.welcome(name: String)  
</code></pre>

<p>만약 <em>HTML</em> 을 렌더링하고 싶다면 <code>welcome.scala.html</code> 을 아래처럼 만들고</p>

<pre><code class="html">@(name: String)

&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
  &lt;title&gt;Welcome Page&lt;/title&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome, &lt;em&gt;name&lt;/em&gt;&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;  
</code></pre>

<p>컨트롤러의 <code>welcome</code> 메소드를 다음과 같이 수정한다.</p>

<pre><code class="scala">// Application.scala

def welcome(name: String) = Action {  
  Ok(views.html.welcome(name))
}
</code></pre>

<h3 id="templateengine">Template Engine</h3>

<p><a href='https://www.playframework.com/documentation/2.3.x/ScalaTemplates' >Scala Tempaltes</a> 링크에서 <em>Play</em> 템플릿 엔진에 대한 기본적인 이해를 할 수 있었다. 다른 언어와 다른점은, 템플릿 엔진 문법을 열고 닫고 할 필요 없이 스칼라는 <code>@</code> 한번만 이용해도 <code>if</code> 블럭같은 멀티라인 코드를 처리할 수 있다는 것.</p>

<pre><code class="html">@if(items.isEmpty) {
  &lt;h1&gt;Nothing to display&lt;/h1&gt;
} else {
  &lt;h1&gt;@items.size items!&lt;/h1&gt;
}
</code></pre>

<h3 id="restapiget">REST API : GET</h3>

<p>이제 기본적인 무언가를 만들 준비가 됐다. 구글에서 <em>scala play example github</em> 을 검색해서 나온 <a href='https://github.com/playforscala/sample-applications/blob/master/ch02-your-first-play-application/first-sample/' >예제 프로젝트</a>를 참고해서 만들어 보자.</p>

<p><code>conf/routes</code> 에 API 를 정의하고,</p>

<pre><code class="scala">GET /phones/:model.json controllers.Phones.show(model String)  
</code></pre>

<p><strong>Model</strong> 을 정의하자.</p>

<pre><code class="scala">// app/models/Phone.scala

case class Phone(model: String, brand: String, price: Int)  
</code></pre>

<p>이제 <code>app/controllers/Phones.scala</code> 컨트롤러를 만들면 된다. </p>

<pre><code class="scala">package controllers

import play.api._  
import play.api.mvc._

import models.Phone

object Phones extends Controller {

  def show(model: String) = Action {
    Ok(s"{ Model : ${model} }")
  }
}
</code></pre>

<p>근데, 잠깐! 어떻게 <em>Model</em> 을 <em>Json</em> 으로 변환하는지 모른다. <em>scala play json</em> 이라고 검색해보니 <a href='https://www.playframework.com/documentation/2.3.x/ScalaJson' >Scala Json</a> 이라는 문서가 나오긴 한다.</p>

<p><code>play.api.lib.json</code> 패키지에 있는 <code>JsValue</code> 를 만들면, <code>Ok</code> 를 이용해서 날릴 수 있다. <code>JsValue</code> 를 만들기 위해선 <code>Json.toJson</code> 을 사용하면 되는데, <strong>Primitive Type</strong> 이나 <strong>Collection</strong> 은 디폴트로 지원해 준다. 따라서 <code>Json.toJson("Fiver")</code> 혹은 <code>Json.toJson(Seq(1, 2, 3, 4))</code> 와 같이 사용할 수 있다.</p>

<p>그런데 문제는 우리가 만든 클래스는 디폴트로 <code>JsValue</code> 로 바꿀수 없다. <code>Json.toJson</code> 은 인자로 받은 것을 <code>JsValue</code> 로 변환하기 위해 <code>Json.toJson[T](T)(implicit writes: Writes[T])</code> 를 사용하는데, 우리가 만든 <code>Phone</code> 을 위한 <code>Writes[Phone]</code> 은 없기 때문에 만들어 줘야 한다.</p>

<pre><code class="scala">// controllers.Phones.scala

...
  def show(model: String) = Action {
    Ok(Json.toJson(Phone(model, "Samsung", 4900)))
  }

  implicit val phoneWrites = new Writes[Phone] {
    def writes(phone: Phone) = Json.obj(
      "model" -&gt; phone.model,
      "brand" -&gt; phone.brand,
      "price" -&gt; phone.price
    )
  }
...
</code></pre>

<p><code>Phones</code> 컨트롤러 내부에 위와 같이 작성하면, <code>/phones/samsung.json</code> 과 입력했을때 <code>{"model":"samsung","brand":"Samsung","price":4900}</code> 와 같은 <code>application/json</code> response 가 돌아온다. 코드는 간단하다, <code>Writes[Phone]</code> 을 만드는데, 여기 내부에 <code>Phone</code> 을 받아 <code>JsValue</code> 를 돌려줄수 있는 <code>writes</code> 함수를 <code>Json.obj</code> 를 이용해서 만들면 된다. </p>

<p>컨트롤러에 <code>Writes[Phone]</code> 이 있어야되는지 의문이다 모델에 있어야만 할 것 같다. 그리고 구글링 해서 나온 <a href='https://gist.github.com/ayush/2428013' >Gist: Play 2.0 Marshalling</a>를 따라가면 더 나은 버전이 있는데, 일단은 이걸로 족하다. 나중에 더 고치자.</p>

<p>이제 단순히 컨트롤러에서 직접 생성하는 대신, <em>Repository</em> 역할을 해줄 <code>Phone</code> 의 <em>Companion Object</em> 를 <code>models/Phone.scala</code> 에 만들자.</p>

<pre><code class="scala">object Phone {  
  var phones = Set(
    Phone("Nexus5", "Google", 459000),
    Phone("Galaxy Note4", "SamSung", 996000),
    Phone("G3 Pro", "LG", 681000)
  )
}
</code></pre>

<p>이제 컨트롤러에서 호출할 메소드를 만들면 되는데, 이름을 짓는법이 걱정이다. <code>getAll</code> 과 같은 이름도 나쁘진 않을텐데, 정해진 스탠다드가 있지 않을까? <em>DAO method name convention</em> 을 검색해 보았다. <a href='http://stackoverflow.com/questions/20447582/standard-naming-convention-for-dao-methods' >SO 답변</a> 을 보니, <strong>Spring Data JPA</strong> 의 메소드 컨벤션을 따르는것도 괜찮다고 해서 그러기로 했다. </p>

<p><code>find*</code> 는 <em>Select</em> 를 수행하는 메소드의 이름이다. <code>get</code> 은 보통 getter 와 혼동할 여지가 있기 때문에 <code>find</code> 가 더 나은것 같다. 나머지는 직관적인 <code>create</code>, <code>update</code>, <code>delete</code> 를 사용하기로 했다. </p>

<p>이제 <code>models/Phone.scala</code> 을 다시 작성해 보면</p>

<pre><code class="scala">package models

case class Phone(model: String, brand: String, price: Int) {  
  override def toString = "[%s : ], - %s".format(model, brand, price)
}

object Phone {  
  var phones = Set(
    Phone("nexus5", "Google", 459000),
    Phone("note4", "SamSung", 996000),
    Phone("g3", "LG", 681000)


  def findByModel(model: String) = phones.find(_.model == model)
}
</code></pre>

<p>컨트롤러는, </p>

<pre><code class="scala">  def get(model: String) = Action {
    Ok(Json.toJson(Phone.findByModel(model)))
  }
</code></pre>

<p>잘 동작한다. 있으면 뿌려주고, 없으면 <code>null</code> 을 Response 에 담아 보낸다. 난 <code>null</code> 대신 <em>HTTP status 404</em> 가 왔으면 좋겠다. 컨트롤러의 <code>get</code> 메소드를 다음처럼 고친다.</p>

<pre><code class="scala">  def get(model: String) = Action {
    Phone.findByModel(model).map { model =&gt;
      Ok(Json.toJson(model))
    }.getOrElse(NotFound)
  }
</code></pre>

<p>이제 <code>/phones.json</code> API 를 만들어 보자. 컨트롤러 내에 <code>list</code> 메소드를, <em>Phone</em> 컴패니언 오브젝트 내에 <code>findAll</code> 메소드를 추가한다.</p>

<pre><code class="scala">// models/Phone.scala

object Phone {  
  var phones = Set[Phone]()

  def findByModel(model: String) = phones.find(_.model == model)
  def findAll = phones.toList
}


// controllers/Phones.scala

  def list = Action {
    Ok(Json.toJson(Phone.findAll))
  }
</code></pre>

<p>갑자기 궁금해진게 있다. 내가 <code>var phones = Set[Phone]()</code> 처럼 empty <em>Repository</em> 를 만들면, <code>GET /phones.json</code> 을 요청했을때 <code>200 OK</code> 와  <code>[]</code>, 즉 빈 배열이 돌아오는데 이게 <em>REST API</em> 에서 적절한 응답일까? <em>REST get all resources empty</em> 라고 검색하니 SO 에서 <a href='http://stackoverflow.com/questions/13366730/proper-rest-response-for-empty-table' >Proper response for empty table?</a> 이라는 질문이 있다.</p>

<p><em>204 (No Content)</em> 와 <em>404 (Not Found)</em> 중 어떤걸 응답 코드로 사용해야 하냐는 질문에 <em>200 (OK)</em> 가 더 적절하다고 말한다. 왜냐하면, 요청된 리소스인 Collection 은 존재하나, 그 내부가 비었기 때문이다. </p>

<p>유저 몇명을 삭제해서 Collection 이 <em>비었을때</em> <strong>404</strong> 를 보낸다면 <strong>/users</strong> 라는 API 가 삭제된 것으로 오인할 수 있다.</p>

<p><strong>204</strong> 같은 경우, request 는 처리 되었으나 응답할 필요가 없는 <em>delete</em> 같은 요청의 응답코드로 사용되는 것이 적절하다. 원문을 첨부하면,</p>

<blockquote>
  <p><strong>Why not 404 (Not Found)?</strong> <br/><br/>
  The 404 status code should be reserved for situations, in which a resource is not found. In this case, your resource is a collection of users. This collection exists but it's currently empty. Personally, I'd be very confused as an author of a client for your application if I got a 200 one day and a 404 the next day just because someone happened to remove a couple of users. What am I supposed to do? Is my URL wrong? Did someone change the API and neglect to leave a redirection. <br/><br/>
  <strong>Why not 202 (No Content)?</strong> <br/><br/>
  A 204 is supposed to indicate that some operation was executed successfully and no data needs to be returned. This is perfect as a response to a DELETE request or perhaps firing some script that does not need to return data. In case of api/users, you usually expect to receive a representation of your collection of users. Sending a response body one time and not sending it the other time is inconsistent and potentially misleading.</p>
</blockquote>

<h3 id="restapipost">REST API : POST</h3>

<p>이제 <em>POST</em> 요청을 처리하기 위해 컨트롤러에 <code>add</code> 메소드를, 레포지터리에 <code>create</code> 메소드를 추가해 보자.</p>

<p>일단 <code>conf/routes</code> 에 라우팅을, 컨트롤러에 메소드를 추가한다.</p>

<pre><code>// conf/routes

`POST    /phones/:model.json         controllers.Phones.add(model: String)

// controllers/Phones.scala

  def add(model: String) = Action { request =&gt;

  }
</code></pre>

<p>이 <em>POST</em> 요청 핸들러를 작성하려면 내가 모르는것은 2가지다.</p>

<p><em>(1) Request body 에서 파라미터 추출</em> <br />
<em>(2) 추출한 파라미터를 암시적으로 <code>Phone</code> 인스턴스로 변경</em>  </p>

<p>일단, 검색을 해보니 여러 문서를 찾았다.</p>

<p>(1) <a href='https://www.playframework.com/documentation/2.3.x/ScalaJson' >ScalaJson</a> <br />
(2) <a href='https://www.playframework.com/documentation/2.3.x/ScalaJsonHttp' >ScalaJsonHttp</a> <br />
(3) <a href='https://www.playframework.com/documentation/2.3.x/ScalaJsonCombinators' >ScalaJsonCombinators</a>  </p>

<p>놀랍게도 이걸 다 이해해야 한다. 스칼라의 JSON 처리는, 아니 <em>Play</em> 의 JSON 처리는 <em>직관적이지 못한 것 같다.</em> 일단 예제 코드를 보면</p>

<pre><code class="scala">  def add() = Action(BodyParsers.parse.json) { request =&gt;
    val phoneRes = request.body.validate[Phone]
    phoneRes.fold(
      errors =&gt; {
        BadReques
      },
      phone =&gt; {
        Phone.create(phone)
      }
    )
  }

  implicit val phoneReads: Reads[Phone] = (
    (JsPath \ "model").read[String] and
    (JsPath \ "brand").read[String] and
    (JsPath \ "price").read[Int]
  )(Phone.apply _)
</code></pre>

<p>요약하자면, <code>Action(BodyParsers.parse.json</code> 을 이용하면, <em>Content-Type</em> 으로 <code>application/json</code> 혹은 <code>text/json</code> 을 받아들이고, Request Body 에 있는 값들을 파싱해서 <code>JsValue</code> 를 만들어 낸다.</p>

<p>그리고 <code>validate[Phone]</code> 를 이용해서 <code>implicit Reads[Phone]</code> 을 호출하여, validation 한 결과값을 얻는다. </p>

<p>그리고 이 값을 처리하기 위해 <code>fold</code> 메소드를 사용하는데, 첫 인자는 validation 에 실패했을 경우, 후자는 성공했을 경우의 로직을 적으면 된다.</p>

<p>정정하겠다. <em>Play</em> 의 JSON 처리는 처음보면 난해하지만, Static Typing 에서 필요한 instance converting 과 validation 을 잘 섞은 <em>깔끔한 방법</em> 이다.</p>

<p><code>phoneReads</code> 를 만드는 과정이 좀 난해하긴 한데, <a href='https://www.playframework.com/documentation/2.3.x/ScalaJsonCombinators' >여기</a> 를 좀더 참고하면 <code>JsPath</code> 와 <code>and</code> 를 이용해서 만드는건 사실 <code>FunctionalBuilder[Reads]#CanBuild3[String, String, Int]</code> 다. 이것 자체가 중요한것은 아니고, 이건 사실 바디파서로부터 뽑혀 나온 것들을 스칼라 타입으로 바꾼 것들을 담고 있는 통이고, 여기에 <code>Phone.apply</code> 를 호출해서 <code>Phone</code> 을 하나 만들 수 있다. </p>

<p><code>Writes[Phone]</code> 도 <code>JsPath</code> 를 이용해서 만들 수 있다.</p>

<pre><code class="scala">  implicit val phoneWirtes: Writes[Phone] = (
    (JsPath \ "model").write[String] and
    (JsPath \ "brand").write[String] and
    (JsPath \ "price").write[Int]
  )(unlift(Phone.unapply))
</code></pre>

<p>이 두개의 <code>Reads[T]</code> 와 <code>Writes[T]</code> 를 mixin 하면 <code>Format[T]</code> 가 된다. </p>

<pre><code class="scala">  val phoneWirtes: Writes[Phone] = (
    (JsPath \ "model").write[String] and
    (JsPath \ "brand").write[String] and
    (JsPath \ "price").write[Int]
  )(unlift(Phone.unapply))

  val phoneReads: Reads[Phone] = (
    (JsPath \ "model").read[String] and
    (JsPath \ "brand").read[String] and
    (JsPath \ "price").read[Int]
  )(Phone.apply _)

  implicit val phoneFormat: Format[Phone] =
    Format(phoneReads, phoneWirtes)
</code></pre>

<p>더 나아가서, 우리의 조그만 어플리케이션의 경우에는 <code>Reads</code> 와 <code>Writes</code> 가 다르지 않으므로 <code>Combinator</code> 를 이용해서 바로 <code>Format</code> 을 만들 수 있다.</p>

<pre><code class="scala">  implicit val phoneFormat: Format[Phone] = (
    (JsPath \ "model").format[String] and 
    (JsPath \ "brand").format[String] and
    (JsPath \ "price").format[Int]
  ) (Phone.apply, unlift(Phone.unapply))
</code></pre>

<p><code>Writes[Phone]</code> 이 <code>Phone</code> 을 이용해서 <code>Js.Value</code> 를 만들어준다는건 알겠는데, <code>unlift</code> 가 무엇인지 궁금하다. Scala Doc 에서 <a href='http://docs.scala-lang.org/overviews/quasiquotes/unlifting.html' >unlifting</a> 과 <a href='http://docs.scala-lang.org/overviews/quasiquotes/lifting.html' >lifting</a> 에 관한 링크를 찾아냈다. </p>

<p>쉽게 말해서 <strong>lifting</strong> 은 함수가 리턴해주는 타입에 대해 <code>Option</code> 을 씌워주는 것이고, <strong>unlifting</strong> 은 벗겨주는 것이다. <code>Phone.unapply</code> 는 <code>Phone =&gt; Option[(String, String, Int)]</code> 이므로, <code>unlift</code> 를 적용하면 <code>Phone =&gt; (String, String, Int)</code> 가 됀다. </p>

<p><strong>lifting</strong> 과 <strong>partial function</strong> 에 관한건 <a href='http://stackoverflow.com/questions/17965059/what-is-lifting-in-scala' >SO: What is lifting in Scala</a> 으로, <em>Play</em> 의 <strong>JSON API</strong> 에 관한건 <a href='http://mandubian.com/2012/10/01/unveiling-play-2-dot-1-json-api-part2-writes-format-combinators/' >Unveiling Play2 JSON API</a> 로</p>

<p>이제 구현을 요약하자면, <code>models/Phone.scala</code> 의 <code>create</code> 메소드는</p>

<pre><code class="scala">  def create(phone: Phone) = {
    phones = phones + phone
  }
</code></pre>

<p><code>controllers/Phones.scala</code> 의 <code>add</code> 메소드는</p>

<pre><code class="scala">  def add() = Action(BodyParsers.parse.json) { request =&gt;
    val phoneRes = request.body.validate[Phone]
    phoneRes.fold(
      errors =&gt; {
        BadRequest(Json.obj("status" -&gt;"404", "message" -&gt; JsError.toFlatJson(errors)))
      },
      phone =&gt; {
        Phone.create(phone)
        Created
      }
    )
  }
</code></pre>

<h3 id="summary">Summary</h3>

<p><em>Play</em> 에 대해 아무것도 모르는 상태에서, 간단한 엔티티를 하나 만들고 <em>POST</em>, <em>GET</em> API 를 만들어 보았다. 에러 핸들링도 없고, 부족한게 많지만 차차 붙여 나가면 될테다. </p>]]></description><link>http://1ambda.github.io/new-to-play-framework-2/</link><guid isPermaLink="false">e5700aaa-706e-4829-aef5-8c46a2dbf652</guid><category><![CDATA[scala]]></category><category><![CDATA[play framework]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 02 Oct 2014 12:50:48 GMT</pubDate></item><item><title><![CDATA[Functional Programming in Scala, Chapter 3]]></title><description><![CDATA[<p>2014-09-29, <strong>Functional Programming in Scala</strong>, Coursera</p>

<h3 id="31classhierarchies">3.1 Class Hierarchies</h3>

<h4 id="abstractclasses">Abstract Classes</h4>

<p><strong>abstract class</strong> 는 다른 언어의 그것과 같다.</p>

<pre><code class="scala">abstract class IntSet {  
  def contains(x: Int): Boolean
  def incl(x: Int): IntSet
}

object EmptySet extends IntSet {  
  def contains(x: Int) = false
  def incl(x: Int) = new NonEmptySet(x, EmptySet, EmptySet)
}

class NonEmptySet(elem: Int, left: IntSet, right: IntSet) extends IntSet {  
  def contains(x: Int) = {
    if (x &lt; elem) left contains x
    else if (x &gt; elem) right contains x
    else true
  }

  def incl(x: Int) = {
    if (x &lt; elem) new NonEmptySet(elem, left incl x, right)
    else if (x &gt; elem) new NonEmptySet(elem, left, right incl x)
    else this
  }
}
</code></pre>

<p>여기서 재밌는 점은 <code>incl</code> 을 수행할때 새로운 서브트리를 매번 만든다는 것인데, 이건 이 프로그램이 <code>immutable</code> 하다는 것을 말한다. </p>

<p>이전의 데이터들을 변경하지 않으므로 <strong>persistent data structures</strong> 라 볼 수 있다.</p>

<p>클래스에서는 다른 언어와 마찬가지로 <strong>override</strong> 를 이용해서 existing 혹은 non-abstract definition 을 서브클래스에서 <strong>재정의(redefined)</strong> 할 수 있다.  </p>

<h4 id="objectdefinitions">Object Definitions</h4>

<p><code>object</code> 키워드를 이용하면 <strong>singleton object</strong> 를 만든다. 그리고 <strong>singleton object</strong> 는 value 이기 때문에, 그 자체로 evaluate 된다. 다시말해 evaluation step 이 수행 될 필요가 없다.</p>

<pre><code class="scala">object EmptySet extends IntSet {  
  def contains(x: Int) = false
  def incl(x: Int) = new NonEmptySet(x, EmptySet, EmptySet)
}
</code></pre>

<h4 id="exercisee">Exercisee</h4>

<blockquote>
  <p>Write a method <code>union</code> for forming the union of two sets. You should implement the following abstract class</p>
</blockquote>

<pre><code class="scala">  def union(other: IntSet): IntSet = {
    ((left union right) union other) incl elem
  }
</code></pre>

<p>해석하면 terminal node 의 경우, union 연산이 <code>other incl elem</code> 이 된다. 게다가 매번의 <code>left union right</code> 연산은 현재보다 더 작은 단위를 호출하고, <code>(left union right) union other</code> 은 적어도 좌측 operand 가 적어도 현재보다 1개 작은 elem 을 가지고 있기 때문에 최소한 자기 자신을 다시 호출하지 않는다는 것을 알 수 있다. 따라서 이런 점을 고려하면 함수는 언젠가 끝난다는 것을 알 수 있다.</p>

<h4 id="dynamicbinding">Dynamic Binding</h4>

<blockquote>
  <p>Object-oriented language implement dynamic method dispatch. This means that the code invoked by a method call depends on the runtime type of the object that contains the method</p>
</blockquote>

<p>이렇게 보면, <strong>Dynamic dispatch</strong> 는 <em>* higher-orher functions</em>* 와 유사한데, 둘 다 static 타임에 어떤 함수가 실행될 지 알 수 없다. 그럼 둘을 섞으면 어떻게 될까?</p>

<h3 id="32howclassesareorganized">3.2 How Classes Are Organized</h3>

<p>스칼라에서 class 들은 <strong>package</strong> 로 관리된다. 스칼라에서 자동으로 임포트하는 것들은</p>

<ul>
<li>All members of package <code>scala</code> like scala.Int  </li>
<li>All members of package <code>java.lang</code> like java.lang.Object  </li>
<li>All members of the singleton object  <code>scala.Predef</code> like scala.Predef.require  </li>
</ul>

<h4 id="trait">Trait</h4>

<blockquote>
  <p>A trait is declared like an abstract class, just with trait instead of abstract class</p>
</blockquote>

<pre><code class="scala">trait Planar {  
  def height: Int
  def width: Int
  def surface = height * width
}
</code></pre>

<p><strong>Trait</strong> 는 자바의 <strong>Interface</strong> 와 비슷하지만, fields 와 concrete methods 를 포함할 수 있다는 점에서 더 강력하다. 반면 <strong>Trait</strong> 는 parameter 를 가질 수 없다.</p>

<h4 id="scalashierarchy">Scala's Hierarchy</h4>

<p><img src='http://librairie.immateriel.fr/baw/9780596155957/httpatomoreillycomsourceoreillyimages322250.png'  /></p>  

<p align="center">(<a href='http://librairie.immateriel.fr/fr/read_book/9780596155957/ch07s04' #scalas-type-hierarchy'>http://librairie.immateriel.fr/fr/read_book/9780596155957/ch07s04#scalas-type-hierarchy</a>)</p>

<p>그림을 보면 알겠지만, 가장 상위에 <code>scala.Any</code> 가 있고, 그 아래로 기본 타입들은 <code>scala.AnyVal</code> 아래에 위치한다. 스칼라의 <code>Double</code> 은 자바의 <code>double</code> 와 일치한다. <code>java.lang.Double</code> 과는 다르다. <code>java.lang.Double</code> 은 아래 설명을 보면 알겠지만, <code>AnyRef</code> 하위에 위치한다. </p>

<p>레퍼런스 타입은 <code>scala.AnyRef</code> 아래에 위치 한다. 그리고 <code>scala.AnyRef</code> 는 자바의 <code>java.lang.Object</code> 와 동일하다. 모든 스칼라 오브젝트들은 <code>scala.AnyRef</code> 를 하위에 위치한다. 받는다.</p>

<p>정리하자면 primitive type 은 <code>scala.AnyVal</code> 하위에 있고, object 는 <code>scala.AnyRef</code> 하위에 있다고 보면 된다.  </p>

<p>그리고 하위에 보면 <code>scala.Nothing</code> 과 <code>scala.Null</code> 이 <strong>Trait</strong> 로 존재하는 걸 확인할 수 있다.</p>

<p><br/>  </p>

<p><img src='http://docs.scala-lang.org/resources/images/classhierarchy.img_assist_custom.png'  /></p>  

<p align="center"><a href='http://docs.scala-lang.org/tutorials/tour/unified-types.html' >http://docs.scala-lang.org/tutorials/tour/unified-types.html</a></p>

<p>그림이 좀 작긴 한데, 자세히 보면 dotted arrow  가 있는걸 볼 수 있다. 이건 해당 타입이 화살표가 이어진 곳에 있는 타입으로 자동으로 converted 될 수 있는지의 여부다. 따라서 아래와 같은 <strong>REPL</strong> 실행 결과를 얻을 수 있다.</p>

<pre><code class="scala">scala&gt; val a: Byte = 1  
a: Byte = 1

scala&gt; val b: Short = a  
b: Short = 1

scala&gt; b  
res0: Short = 1

scala&gt; val c: Byte = b  
&lt;console&gt;:9: error: type mismatch;  
 found   : Short
 required: Byte
       val c: Byte = b
                     ^
</code></pre>

<h4 id="toptypes">Top Types</h4>

<p><code>Any</code> 은 모든 타입의 베이스 타입으로, <code>==</code>, <code>!=</code>, <code>equals</code>, <code>hashCode</code>, <code>toString</code> 등의 메소드를 포함하고 있다.</p>

<h4 id="thenothingtype">The Nothing Type</h4>

<p><br/>  </p>

<p><img src='http://docs.scala-lang.org/resources/images/classhierarchy.img_assist_custom.png'  /></p>  

<p align="center"><a href='http://docs.scala-lang.org/tutorials/tour/unified-types.html' >http://docs.scala-lang.org/tutorials/tour/unified-types.html</a></p>

<p><code>Nothing</code> 은 Scala's type hierarchy 가장 아래쪽에 위치하는데, <strong>모든 타입의 subtype</strong> 이다. <code>Nothing</code> 은 또한 값이 없는데, 다음의 두 가지 경우 유용하다.</p>

<p>(1). To signal abnormal termination <br />
(2). As an element type of empty collections. ex) <code>Set[Nothing]</code></p>

<p>참고로, <code>Exception</code> 의 타입도 <code>Nothing</code> 이다.</p>

<h3 id="null">Null</h3>

<p><code>Null</code> 은 모든 <code>scala.AnyRef</code> 하위에 있는 타입의 서브타입이다.</p>

<blockquote>
  <p>Every reference class type also has null as a value.</p>
</blockquote>

<p><code>null</code> 의 type 이 바로 <code>Null</code> 이다. <code>Null</code> 은 <code>java.lang.Object</code>, 즉 <code>scala.AnyRef</code> 를 상속받는 모든 클래스의 서브타입이기 때문에 <code>scala.AnyVal</code> 과는 incompatible 하다.</p>

<pre><code class="scala">scala&gt; null  
res1: Null = null

scala&gt; val a:String = null  
a: String = null

scala&gt; val b: Int =  null  
&lt;console&gt;:7: error: an expression of type Null is ineligible for implicit conversion  
       val b: Int =  null
</code></pre>

<p>참고로 <code>if (true) 1 else false</code> 의 타입은 <code>AnyVal</code> 인데 <code>1</code>과 <code>false</code> 의 공통적인 상위 타입은 <code>AnyVal</code> 이기 때문이다.</p>

<h3 id="33polymorphism">3.3 Polymorphism</h3>

<p>대부분의 함수형 언어에서 기본적인 데이터 구조는 <strong>immutable linked list</strong> 다. 이건 <strong>Nil</strong> 과 <strong>Cons</strong> 로 구성되어 있는데, <strong>Nil</strong> 은 empty list 를, <strong>Cons</strong> 는 element 를 담고있는 부분을 말한다. 리습의 그것과 같다. </p>

<p><br/>  </p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Cons-cells.svg/525px-Cons-cells.svg.png'  /></p><p align="center"><a href='http://en.wikipedia.org/wiki/Cons' >http://en.wikipedia.org/wiki/Cons</a></p>

<p>이번시간엔, <code>Cons</code> 와 <code>Nil</code> 들을 구현해 보자.</p>

<pre><code class="scala">trait List[T] {  
  def isEmpty: Boolean
  def head: T
  def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {  
  def isEmpty = false
}

class Nil[T] extends List[T] {  
  def isEmpty = true
  def head = throw new NoSuchElementException("Nil.head")
  def tail = throw new NoSuchElementException("Nil.tail")
}
</code></pre>

<p>여기서 클래스에 있는 파라미터, <code>val head: T</code> 를 <strong><em>Value Parameter</em></strong> 라 부른다. <code>val</code> 의 경우에는 자동으로 <strong>public getter</strong> 를 만들어 준다.</p>

<p>그리고 <code>[T]</code> 에서 <code>T</code> 는 <strong><em>Type Parameter</em></strong> 다. 타입 파라미터는 클래스 뿐만 아니라 함수에도 적용할 수 있는데, </p>

<p><code>def signleton[T](elem:T) = new Cons[T](elem, new Nil[T])</code></p>

<p>는 정상적으로 컴파일 된다. 물론 스칼라는 강력한 <strong><em>Type Inference</em></strong> 를 지원하기 때문에</p>

<p><code>singleton[Boolean](true)</code> 대신 스칼라 컴파일러는 type inference 를 이용해서 <code>singleton(true)</code> 혹은 <code>singleton(1)</code> 를 받아들인다.</p>

<h4 id="typesandevaluation">Types and Evaluation</h4>

<blockquote>
  <p>Type parameters do not affect evaluation in Scala</p>
</blockquote>

<p>재밌게도 Scala 프로그램이 evaluation 될 때  <code>[T]</code> 와 같은 <strong>Type parameters</strong> 는 전혀 영향을 미치지 않는다. 왜냐하면 Scala 가 evaluation 전에 모든 <strong>Type parameters</strong> 와 <strong>Type arguments</strong> 를 제거하기 때문이다. </p>

<p>이 과정은 <strong><em>Type erasure</em></strong> 로 불린다. Java, Scala, Haskell, ML, OCaml 등은 <strong><em>Type erasure</em></strong> 를 이용하고, 런타임에도 <strong>Type parameters</strong> 를 유지하는 언어는 C++, C#, F# 등이 있다.  </p>

<h4 id="polymorphism">Polymorphism</h4>

<p><strong>Polymorphism</strong> 은 <em>"in many forms"</em> 라는 뜻이다. 프로그래밍에서는 다음과 같은 의미를 가진다.</p>

<blockquote>
  <p>(1) the function can be applied to arguments of many types or <br/>
  (2) the type can have instances of many types</p>
</blockquote>

<p>이 정의로부터 두 가지 사실을 끌어낼 수 있는데,</p>

<blockquote>
  <p>(1) <strong>subtyping:</strong> instances of a subclass can be passed to a base class  <br/>
  (2) <strong>generics:</strong> instances of a function or class are created by type parameterization</p>
</blockquote>

<p>사실 <strong>subtyping</strong> 은 OOP 언어에서 먼저 온 것이고, <strong>generics</strong> 는 함수형 언어에서 온 것이나, Scala 는 모두 사용한다.</p>

<p>중요한 내용이므로 다시 한 번 정리 하면 <strong>다형성</strong> 이란, 다양한 형태를 가지고 있다는 뜻인데, 프로그래밍에서는 다음과 같은 의미를 지닌다.</p>

<p>(1) 함수는 다양한 타입의 인자를 받아들일 수 있다. <br />
(2) 타입은 다양한 타입의 인스턴스를 가질 수 있다.</p>

<p>따라서 함수나 클래스의 인스턴스는 <strong><em>type parameterization</em></strong> 을 통해 생성될 수 있으며, 하위 클래스의 인스턴스는 상위 클래스로서 동작할 수 있다.</p>

<h4 id="exercise">Exercise</h4>

<blockquote>
  <p>Write a function <code>nth</code> that takes an interger <code>n</code> and <code>a</code> list and selects the n'th element of the list<br/> <br/>
  If index is outside the range from 0 up the length of the list minus one, a <code>IndexOutOfBoundsException</code> should be thrown</p>
</blockquote>

<pre><code class="scala">def nth[T](n: Int, list: List[T]): T = {  
  if (list.isEmpty) throw new IndexOutOfBoundsException("out of bound index")
  else if (n == 0) list.head
  else nth(n - 1, list.tail)
}
</code></pre>]]></description><link>http://1ambda.github.io/functional-programming-in-scala-chapter-3/</link><guid isPermaLink="false">3853d556-1f59-4c73-b4b3-8ec4ffb80c4a</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 30 Sep 2014 12:26:11 GMT</pubDate></item><item><title><![CDATA[Functional Programming in Scala, Chapter 2]]></title><description><![CDATA[<p>2014-09-27, <strong>Functional Programming in Scala</strong>, Coursera</p>

<h3 id="21higherorderfunctions">2.1 Higher-Order Functions</h3>

<h4 id="higherorderfunctions">Higher-Order Functions</h4>

<p>Functional PL 에서는 함수를 <em>first-class</em> 로 다루는데, 이는 함수를 파라미터로 넘기거나 결과로 리턴할 수 있다는 소리다. </p>

<p>이렇게 함수를 파라미터로 받거나, 혹은 함수를 리턴하는 함수를 <strong>Higher order functions</strong> 라 부른다.</p>

<h4 id="functiontypes">Function Types</h4>

<blockquote>
  <p>type A => B is the type of a function that thaks an arg of type A and return a result of type B.</p>
</blockquote>

<h4 id="anonymousfunctions">Anonymous Functions</h4>

<blockquote>
  <p>The type of the parameter can be omittered if it can be infferred by the compiler</p>
</blockquote>

<h3 id="22currying">2.2 Currying</h3>

<p>2.1 에서 우리는 <strong>Higher Order Functions</strong> 를 만들었다. 다음과 같은 Tail-Recursive 버전의 <code>sum</code> 이 있다고 하자.</p>

<pre><code class="scala">def TailRecursiveSum(f: Int =&gt; Int, a: Int, b: Int): Int = {  
  def loop(a: Int, acc: Int): Int = {
    if (a &gt; b) acc
    else loop(a + 1, f(a) + acc)
  }
  loop(a, 0);
}

def sumInts(a: Int, b: Int) =  sum(x =&gt; x, a, b)  
def sumCubes(a: Int, b: Int) =  sum(x =&gt; x * x * x, a, b)  
def sumFactorials(a: Int, b: Int) =  sum(fact, a, b)  
</code></pre>

<pre><code>
</code></pre>

<p><code>a</code> 와 <code>b</code>는 <code>sumInts</code> 와 <code>sumCubes</code> 로 부터 <code>sum</code> 으로 변하지 않고 넘어간다. 제거할 수 없을까? <br />
답은 간단하다. <code>sum</code> 이 <code>a, b</code> 를 받는 함수를 리턴하면 된다.</p>

<pre><code class="scala">def sum(f: Int =&gt; Int): (Int, Int) =&gt; Int = {  
  def sumF(a: Int, b: Int): Int = {
    def loop(a: Int, acc: Int): Int = {
      if (a &gt; b) acc
      else loop(a + 1, f(a) +  acc)
    }
    loop(a, 0)
  }
  sumF
}
</code></pre>

<p>그러면 이렇게 인자를 숨길 수 있다.</p>

<pre><code class="scala">def sumInts = Currying.sum(x =&gt; x)  
assert(sumInts(1, 10) == 55)  
</code></pre>

<p><code>sum</code> 이 인자로 받은 <code>f</code> 를 적용한 새로운 함수 <code>sumF</code> 를 돌려주므로 다음과 같이 호출도 가능하다.</p>

<pre><code class="scala">def cube = (x: Int) =&gt; x * x * x  
sum(cube)(1, 10)  
</code></pre>

<p>함수를 리턴하는 함수는 유용하기 때문에, 스칼라에서는 이를 위한 특별한 문법을 제공한다. 다음의 두 함수 <code>sum1</code>과 <code>sum2</code> 는 동일하다.</p>

<pre><code class="scala">def sum1(f: Int =&gt; Int): (Int, Int) =&gt; Int = {  
  def sumF(a: Int, b: Int): Int = {
    if (a &gt; b) 0
    else f(a) + sum(a + 1, b)
  }
}

def sum2(f: Int =&gt; Int)(a: Int, b: Int): Int = {  
  if (a &gt; b) 0
  else f(a) + sum2(f)(a + 1, b)
}
</code></pre>

<h4 id="expansionofmultipleparameterlists">Expansion of Multiple Parameter Lists</h4>

<p><code>def f(args1)...(argsn) = E</code> 가 있을때 이건 다음과 같이 함수로 감싸고 그 함수를 다시 돌려주면, 원 함수 <code>f</code> 에서 파라미터를 하나 줄일 수 있다.</p>

<p><code>def f(args1)...(argsn-1) = { def g(argn) = E; g }</code> 만약 익명함수로 표현한다면,</p>

<p><code>def f(args1)...(argsn-1) = (argsn =&gt; E)</code> 와 같이 표현할 수 있다. 따라서 이와 같이 함수로 감싸 원 함수 <code>f</code> 에서 파라미터를 반복적으로 줄이다 보면 </p>

<p><code>def f(args1)...(argsn) = E</code> 는 인자를 1개씩 받는 N개의 익명함수로 표현할 수 있다.</p>

<p><code>def f = (args1 =&gt; (args2 =&gt; ...(argn =&gt; E) ...))</code> 이러한 스타일을 <strong>currying</strong> 이라 부른다.</p>

<h4 id="morefunctiontypes">More Function Types</h4>

<p>그렇다면, 위에서 본 <code>sum</code> 함수의 타입은 무엇일까? <code>def sum(f: Int =&gt; Int)(a: Int, b: Int): Int</code></p>

<p><code>(Int =&gt; Int) =&gt; Int, Int =&gt; Int</code> 로 표현할 수 있다. 근데 스칼라에서 <strong>functional types associate to the right.</strong> 이므로,</p>

<p><code>(Int =&gt; Int) =&gt; (Int, Int =&gt; Int)</code> 와 동일하다.</p>

<h4 id="exercise">Exercise</h4>

<blockquote>
  <p>(1). Write a <code>product</code> function that calculates the product of the value of a function for the points on a given interval</p>
</blockquote>

<pre><code class="scala">def product(f: Int =&gt; Int)(a: Int, b: Int): Int = {  
  if (a &gt; b) 1
  else f(a) * product(f)(a + 1, b)
}
</code></pre>

<blockquote>
  <p>(2). Write <code>factorial</code> in terms of <code>product</code></p>
</blockquote>

<pre><code class="scala">def factorial(n: Int): Int = {  
  product(x =&gt; x)(1, n)
}
</code></pre>

<blockquote>
  <p>(3). Can you write a more general funtion, which generalizes both <code>sum</code> and <code>product</code> </p>
</blockquote>

<pre><code class="scala">def mapReduce(f: Int =&gt; Int, combine: (Int, Int) =&gt; Int, init: Int)(a: Int, b: Int): Int = {  
  if (a &gt; b) init
  else combine(f(a), mapReduce(f, combine, init)(a + 1, b))
}

def sumUsingMapReduce(f: Int =&gt; Int)(a: Int, b: Int) =  
  mapReduce(f, (x: Int, y: Int) =&gt; x + y, 0)(a, b)

def productUsingMapReduce(f: Int =&gt; Int)(a: Int, b: Int) =  
  mapReduce(f, (x: Int, y: Int) =&gt; x * y, 1)(a, b)
</code></pre>

<h3 id="23examplefindingfixedpoints">2.3 Example: Finding Fixed Points</h3>

<h4 id="findingafixedpointofafunction">Finding a fixed point of a function</h4>

<blockquote>
  <p>A number is called a <strong>fixed point</strong> of a function f  if <code>f(x) = x</code> </p>
</blockquote>

<p>어떤 <code>f</code> 들에 대해서는 <code>f(x)</code> 를 반복적으로 적용하면서 변하지 않거나 변화량이 충분히 작아질때를 찾아 <strong>fixed point</strong> 를 찾을 수 있다.</p>

<p>1장에서 만들었던 제곱근을 구하는 함수로 돌아가 보자. 사실 이 함수는 <strong>fixed point</strong> 와 관련이 있다. <code>sqrt(x) = y</code> 라고 했을때 <code>y * y = x</code> 이므로 <code>y = x / y</code> 다. 따라서 <code>sqrt(x)</code> 는 함수 <code>y = x / y</code> 를 꾸준히 적용해서 찾아낼 수 있으므로 <code>y = x / y</code> 의 <strong>fixed point</strong> 다.</p>

<p>다음과 같은 <code>fixedPoint</code> 함수가 있다고 하자.</p>

<pre><code class="scala">val tolerance = 0.0001 // = 1.0E-4  
def isCloseEnough(x: Double, y: Double) = {  
  abs((x - y) / x) / x &lt; tolerance
}

def fixedPoint(f: Double =&gt; Double)(firstGuess: Double): Double = {  
  def iterate(guess: Double): Double = {
    val next = f(guess)
    if (isCloseEnough(guess, next)) next
    else iterate(next)
  }
  iterate(firstGuess)
}
</code></pre>

<p>이 함수를 이용해서 </p>

<p><code>sqrt(x: Int) = fixedPoint(y =&gt; x / y)(1.0)</code> </p>

<p>와 같은 제곱근을 구하는 함수를 만들어 볼 수 있겠다. 그러나 <code>sqrt(2)</code>
 를 실행하면 <code>guess</code> 값이 <code>1.0</code>과 <code>2.0</code> 사이를 널뛰기 하면서 무한 루프를 돈다.</p>

<p>이건 <code>guess</code> 값이 너무나 많이 변하기 때문인데, <code>f</code> 를 적용하는 시퀀스에서 연속적인 두개의 <code>guess</code> 값의 평균을 구하는 <code>f</code> 를 만듦으로서 이 문제를 피할 수 있다. (잘못된 해석일 수 있으므로 원문을 첨부한다.)</p>

<pre><code class="scala">One way to control such oscillations is to prevent the estimation from varying too much. This is done by averaging successive values of the original sequence  
</code></pre>

<h4 id="functionsasreturnvalues">Functions as return values</h4>

<p>여태까지는 함수를 인자로 사용했을때 언어에서 어떤 이점을 얻을 수 있는가에 대한 설명이었고, 이제부터는 함수를 리턴값으로 사용할때의 장점을 알아 보자. </p>

<p>아까와 같이 averaging 함으로써 stabilizing 하는 기법을 <strong>Average Damping</strong> 이라 부르는데, 아래와 같은 함수를 만들어서 인자로 넘길 수 있다.</p>

<p><code>def avgDamp(f: Double =&gt; Double)(x: Doube) = (x + f(x)) / 2</code></p>

<p>따라서 <code>sqrt</code> 함수는 다음과 같이 새로 작성할 수 있다.</p>

<pre><code class="scala">def avgDamp(f: Double =&gt; Double)(x: Double) = (x + f(x)) / 2  
def sqrt(x: Double): Double = fixedPoint(avgDamp(y =&gt; x / y))(1)  
</code></pre>

<p><code>avgDamp</code> 는 <code>x</code> 를 다시 인자로 받는 함수를 돌려준다. 원래라면 <code>def</code> 를 이용해서 새로 함수를 만들고 리턴했어야 하나, 스칼라에서 지원해주는 문법을 이용해서 <code>(x: Double)</code> 을 추가하는 것 만으로 편하게 만들었다.</p>

<p>이번장에선 Higher order function 을 이용해서 함수를 combine 하면 더 강력한 <strong>abstraction(추상화)</strong> 를 얻을 수 있다는 법을 배웠다. 비록 이 방법이 항상 좋은건  아니지만 배우면 다 쓸데가 있기 마련이다.</p>

<p>덤으로 하나 더 정리하자면, <strong>Currying</strong> 은 함수의 인자를 반복적으로 쪼개어 익명 함수로 만든 뒤 재활용 할 수 있도록 만드는 기술이라 보면 된다. 왜냐면 N개의 인자가 있다고 가정할때, 이전에는 1개의 함수에 다양한 인자를 줘야했지만, 커링을 이용하면 N개의 함수로 쪼갤 수 있고, 각각의 리턴되는 함수를 저장할 수 있으므로 각각을 재활용 할 수 있다.</p>

<h3 id="25functionsanddata">2.5 Functions and Data</h3>

<p>이번 장에서는 클래스를 사용한다. 유리수 계산을 하기 위해 <code>def add(n1: Int, d1: Int, n2: Int, d2: Int): Int</code> 와 같은 함수를 만드는 것이 아니라, 데이터를 추상화 하기 위한 방법으로 다음과 같은 클래스를 만들 수 있다.</p>

<pre><code class="scala">class Rational(x: Int, y: Int) {  
  def numer = x
  def denom = y

  def add(that: Rational) = {
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }
}
</code></pre>

<p>참고로, 스칼라는 <strong>type</strong> 과 <strong>value</strong> 를 서로 다른네임스페이스에서 관리하기 때문에 충돌할 걱정을 할 필요가 없다.</p>

<h4 id="exercise">Exercise</h4>

<blockquote>
  <p>(1). In your worksheet, add a method <code>neg</code> to class Rational that is used like this <code>x.neg // -x</code></p>
  
  <p>(2). Add a method sub to subtract two rational numbers</p>
  
  <p>(3). With the values of x, y, z as given in the previous slide, what is the result of <code>x - y - z</code></p>
</blockquote>

<pre><code class="scala">class Rational(x: Int, y: Int) {  
  def numer = x
  def denom = y

  def add(that: Rational) = {
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }

  def sub(that: Rational) = {
    add(that.neg)
  }

  def neg = new Rational(-numer, denom)
}
</code></pre>

<h3 id="26morefunwithrationals">2.6 More Fun With Rationals</h3>

<p>이전에 만든 <code>Rational</code> 클래스는 약분된 형태로 표현되지 않기 때문에 이런 기능을 추가할 필요가 있다.</p>

<blockquote>
  <p>reduce them to their smallest numerator and denominator by dividing both with a divisor</p>
</blockquote>

<p>다양한 방법으로 구현할 수 있겠지만, 가장 쉬운 방법은 <code>Rational</code> 오브젝트가 생성될때 약분 하는 방법이다. </p>

<pre><code class="scala">  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
  private val g = abs(gcd(x, y))

  def numer = x / g
  def denom = y / g
</code></pre>

<h4 id="selfreference">Self-reference</h4>

<p>그리고, <code>less</code>, <code>max</code> 와 같은 함수도 만들어 볼 수 있다. <code>max</code> 가 <strong>self-referencing</strong> 을 위해 <code>this</code> 키워드를 사용한다는 점에 주목하자.</p>

<pre><code class="scala">  def less(that: Rational) = numer * that.denom &lt; that.numer * denom
  def max(that: Rational) = if (this.less(that)) that else this
</code></pre>

<h4 id="precondition">Pre-condition</h4>

<p><code>new Rational(1, 0)</code> 을 시도하면 <code>0</code> 으로 나눌수 없기 때문에 에러를 뿜는다. 검사하기 위해 <code>require</code> 함수를 사용할 수 있다.</p>

<p><code>require(y &gt; 0, "denum must be != 0</code></p>

<p><code>assert</code> 도 사용할 수 있는데, <code>require</code> 와는 차이가 있다. <code>AssertionError</code> 가 나오고, <code>require</code> 에서는 <code>IllegalArgumentException</code> 이 나온다. 그래서 서로 다른 의도로 쓰이게끔 만들어졌다는걸 알 수 있다. (오역이 있을 수 있기 때문에 원문을 첨부한다.)</p>

<blockquote>
  <p>The reflects a difference in intent </br><br/>
  - <code>require</code> is used to enforce a precondition on the caller of a function <br/>
  - <code>assert</code> is used as to check the code of the function itself</p>
</blockquote>

<p>만약 예외를 테스트한다면 <code>scalatest</code> 에서는 <code>intercept</code> 를 이용하면 된다.</p>

<pre><code class="scala">  "Rational(1, 0)" should "throw IllegalArgumentException" in {
    intercept[IllegalArgumentException] {
      new Rational(1, 0)
    }
  }
</code></pre>

<h4 id="constructor">Constructor</h4>

<p>스칼라에서는 암시적(implicitly) 인 생성자를 도입했는데, 다시 말해 코드상에 없어도 <strong>Primary Constructor</strong> 가 존재하는데, 이 <strong>Primary Constructor</strong> 는 클래스의 파라미터를 받아서 클래스 바디의 모든 문장을 실행한다. 만약 다른 생성자를 만들고 싶으면, 다음과 같이 작성하면 된다.</p>

<p><code>def this(x: Int) = this(x, 1)</code></p>

<p>우측에 나오는 <code>this</code> 는 <strong>implicit primary constructor</strong> 다.</p>

<h4 id="exercise">Exercise</h4>

<blockquote>
  <p>Modify the <code>Rational</code> class so that rational numbers are kept unsimplified internally, but the simplification is applied when numbers are converted to strings. Do clients observe the same behavior when interacting with rational class? </br></p>
</blockquote>

<p>primary constructor 에서 약분을 하지 않고, <code>toString</code> 에서 약분을 할때 과연 제대로 되겠느냐인데, 답은 <strong>아니오</strong> 다. integer overflow 를 생각하면 쉽다. 최대한 약분할 수 있을때 먼저 해버리는것이 낫다. 커다란 수 <code>a</code> ... <code>z</code> 에 대해서 연산 해버리면, 마지막 <code>toString</code> 에서만 약분이 될텐데. 제대로 되지 않을 가능성이 있다.</p>

<blockquote>
  <p>Yes for small sizes of denominators and nominators and small numbers of operations</p>
</blockquote>

<h3 id="27evaluationandoperators">2.7 Evaluation and Operators</h3>

<h4 id="classesandsubstitutions">Classes and Substitutions</h4>

<p>(단어 오역이 있을 수 있어서 용어를 그대로 씀)</p>

<p>함수에서 <strong>subtitution</strong> 에 기반한 <strong>compuation model</strong> 을 이용했는데, 사실 이건 클래스를 인스턴스 할때도 똑같이 적용된다. 즉 <code>new C(x1, ... ,xn)</code> 은 <code>new C(v1, ..., vn)</code> 과 같다.</p>

<p>그렇다면, 다음과 같이 클래스가 인자 n 개를 받는 함수를 정의했을때 <code>def f(y1, ... , yn) = b</code> 이런 식은 어떻게 평가될까?</p>

<p><code>new C(v1, ..., vm).f(w1, ... , wn)</code></p>

<p>(1). 클래스의 <strong>formal parameter</strong> <code>x1, ..., xn</code> 이 <strong>actual parameter</strong> <code>v1, ... , vm</code> 으로 <strong>substitution</strong> 된다.<br/></p>

<p>(2). 함수 <code>f</code> 의 <strong>formal parameter</strong> <code>y1, ... , yn</code> 이 <strong>actual parameter</strong> <code>w1, ... , wn</code> 으로 <strong>substitution</strong> 된다. <br/></p>

<p>(3) <code>new Class(v1, ... , vm)</code> 이 <code>this</code> 로 치환되고</p>

<p>(4) <code>f</code> 의 바디 <code>b</code> 가 평가된다.</p>

<p>따라서 이를 식으로 표현하면, 다음과 같이 쓸 수 있다.</p>

<p><code>[v1/x1, ... , vm/xm][w1/y1, ... , wn/yn][new C(v1, ..., vm)/this]b</code> </p>

<p>그러면, 예제를 통해서 살펴보자.</p>

<pre><code class="scala">new Rational(1, 2).less(new Rational(2, 3))  
</code></pre>

<p>이건 다음과 같이 평가된다.</p>

<pre><code class="scala">[1/2, 2/y][new Rational(2, 3)/that][new Rational(1, 2)/this] this.numer * that.denom &lt; that.numer * this denom
</code></pre>

<p>결국 이건 아래와 같다.</p>

<pre><code class="scala">new Rational(1, 2).numer * new Rational(2, 3).denom &lt; new Rational(2, 3).numer * new Rational(1, 2).denom

// 1 * 3 &lt; 2 * 2
// true
</code></pre>

<h4 id="operators">Operators</h4>

<p><code>Int</code> 의 경우에는 <code>+</code> 를 사용하면 <code>3 + 5</code> 와 같이 표현할 수 있지만 <code>Rational</code> 의 경우에는 <code>r.add(r2)</code> 와 같이 사용해야 했다. 뭔가 불편하다.</p>

<p>스칼라에는 이런 문제를 해결하기 위해 <strong>Infix Notation</strong> 이 있다. 함수의 인자가 하나라면, 괄호를 생략하는 것이다. 바이너리 오퍼레이터처럼 보일 수 있도록.</p>

<pre><code class="scala">r add s // r.add(s)  
r less s // r less s  
r max s // r max s  
</code></pre>

<h4 id="relaxedidentifiers">Relaxed Identifiers</h4>

<p>스칼라에서는 <strong>operator</strong> 또한 <strong>identifier</strong> 가 될 수 있다. 스칼라에서 <strong>identifier</strong> 룰은 아래와 같다</p>

<blockquote>
  <p>(1). <strong>Alphanumeric:</strong> starting with a letter, followed by a sequence of letters or numbers <br/></p>
  
  <p>(2). <strong>Symbolic:</strong> starting with an operator symbol, followed by other character operator symbols <br/></p>
  
  <p>(3). The underscore character <code>_</code> counts as a letter <br/></p>
  
  <p>(4). Alphanumeric identifiers can also end in an underscore, followed by some operator symbols</p>
</blockquote>

<p>따라서 <code>*</code>, <code>+?%&amp;</code>, <code>vector_++</code>, <code>counter_=</code> 모두 유효한 identifier 들이다. </p>

<p>이제 이런 symbolic identifier 들을 이용해서 <code>Rational</code> 클래스의 함수 이름들을 산술연산 처럼 보이도록 변경해 보자.</p>

<pre><code class="scala">class Rational(x: Int, y: Int) {  
  require(y &gt; 0, "denom != 0")

  // secondary constructor
  def this(x: Int) = this(x, 1)

  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
  private val g = abs(gcd(x, y))

  def numer = x / g
  def denom = y / g

  def &lt; (that: Rational) = numer * that.denom &lt; that.numer * denom
  def max(that: Rational) = if (this &lt; that) that else this

  def + (that: Rational) = {
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }

  def - (that: Rational) = {
    this + -that
  }

  def unary_- = new Rational(-numer, denom)
}
</code></pre>

<p>재밌는 점은 <code>neg</code> 를 <strong>unary operator</strong> <code>-</code> 로 만들기 위해 <code>unary_</code> 를 이용해서 <code>unary_-</code> 로 정의했다는 것이다. </p>

<p>참고로, return 값을 주기 위해서 <code>unary-_: Rational</code> 과 같이 정의하면 에러가 난다. <code>:</code> 가 포함된 identifier 로 인식하기 때문에 <code>unary-_ :</code> 로 스페이스를 꼭 주어야 한다.</p>

<h4 id="precedencerules">Precedence Rules</h4>

<p>그렇다면 <code>x * x + y</code> 와 같은 경우 <code>*</code> 가 먼저 계산되어야 하는데, 이런건 어떻게 해결할까? 우리가 만든건 정수 연산자가 아니라 함수인데.</p>

<p>이를 위해 스칼라는 다음과 같은 룰을 만들어 두었다.</p>

<blockquote>
  <p>The precedence of an operator is determined by its first character. The following table lists the characters in increasing order of priority precedence</p>
</blockquote>

<pre><code class="scala">(all letters) // Alphanumeric
|
^
&amp;
&lt; &gt;  
= !
:
+ -
* / %
(all other special characters)
</code></pre>

<p>identifier 의 첫글자가 미리 정의된 테이블에 있다면 우선순위가 정해지는 룰이다.</p>]]></description><link>http://1ambda.github.io/functional-programming-in-scala-chapter-2/</link><guid isPermaLink="false">20cff111-9852-407f-9222-acac9d6733e0</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 29 Sep 2014 16:09:24 GMT</pubDate></item><item><title><![CDATA[Scala for the Impatient, Chapter 1, 2, 3]]></title><description><![CDATA[<h3 id="chapter1">Chapter 1</h3>

<p>(1). 스칼라의 REPL 은 엄밀히 말해서 인터프리터가 아니다. 입력받은 코드를 자바 바이트코드로 컴파일 한 후 자바 가상머신에서 실행시킨뒤 결과를 돌려준다.</p>

<p>(2). 스칼라는 문자열을 위한 추가적인 연산들을 제공하기 위해 <code>java.lang.String</code> 오브젝트를 <code>StringOps</code> 오브젝트로 변환한다. <code>"Hello".intersect("World")</code> 가 그 예다. 따라서 ScalaDoc 을 보려면 <code>SpringOps</code> 클래스를 살펴보는 편이 정신 건강에 좋다.</p>

<p>마찬가지로 <code>Int</code>, <code>Double</code> 등에도 편의 메소드를 추가한 <code>RichInt</code>, <code>RichDouble</code>, <code>RichChar</code> 등을 제공한다. <code>1.to(10)</code> 에서 <code>1</code> 은 <code>RichInt</code> 로 변환된 뒤에 <code>to</code> 메소드를 적용한다.</p>

<p>참고로 스칼라에서는 숫자간 타입 변환을 위해 캐스팅이 아니라 메소드를 사용한다. <code>99.44.toInt</code>, <code>99.toChar</code>, <code>"99.44".toDouble</code></p>

<p>(3). 스칼라에는 <code>++</code> 연산자가 없다.</p>

<p>(4). 스칼라에는 Static Method 대신 <strong>Singleton Object</strong> 와 <strong>Companion Object</strong> 가 있다.</p>

<p>(5). 오브젝트를 수정하지 않는, 인자가 없는 메소드는 괄호를 사용하지 않는다. </p>

<p><code>"Hello".distinct</code> </p>

<p>(6). ScalaDoc 에서 <strong>implicit</strong> 로 태그된 메소드는 자동변환이다. 예를들어 <code>BigInt</code> 오브젝트는 필요할때 자동으로 <code>int</code> 와 <code>long</code> 을 <code>BigInt</code> 로 바꾼다.</p>

<h3 id="chapter2">Chapter 2</h3>

<p>(1). 스칼라에서는 <strong>구문(Statement)</strong> 이 아니라 모든 것을 <strong>식(Expression)</strong> 으로 취급한다. 그런데, <code>else</code> 가 없는 <code>if</code> 문은 값이 없을 수 있는데, 스칼라에서는 <code>Unit</code> 클래스를 도입해서 해결한다. <code>Unit</code> 은 <strong>값 없음</strong> 을 뜻하는 <code>()</code> 을 값으로 가진다.</p>

<p>(2). 스칼라에서 <strong>할당(assignment)</strong> 은 <code>Unit</code> 타입의 값을 가진다. 따라서 할당을 묶어서 사용하지 않는다.</p>

<p><code>x = y = z = 1 // no</code></p>

<p>(3) <code>for</code> 루프에서 인덱스가 필요하면, <code>until</code> 을 사용하면 된다.</p>

<pre><code class="scala">val str = "lambda"  
var sum = 0  
for (index &lt; - 0until str.length)  
  sum += index
</code></pre>

<p>(4). <code>return</code> 이 없는 삶에 익숙해지자, 익명함수를 사용할 경우 리턴값이 쓸모가 없다. <code>break</code> 쯤으로 여기는 것이 마음 편하다.</p>

<p>(5). 재귀 함수는 타입을 반드시 명시해야 한다. <strong>ML</strong> 이나 <strong>하스켈</strong> 같은 일부 언어는 <strong><a href='http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system' >힌들리-밀너</a></strong> 알고리즘을 이용하여 재귀함수의 타입을 추론할 수 있지만, 이 알고리즘은 객체지향과는 잘 안맞는다.</p>

<p>(6). 가변인자가 필요하면, <code>*</code> 를 사용하자. 배열을 풀어헤치기 위해 사용하는 <code>_*</code> 는 <strong>Splat operator</strong> 다</p>

<pre><code class="scala">def sum(args: Int*) = {  
  var sum = 0;
  for(arg &lt;- args) sum += arg
  sum
}

sum(1 to 5: _*)

def recursiveSum(args: Int*): Int = {  
  if (args.length == 0) 0
  else args.head + recursiveSum(args.tail : _*)
}
</code></pre>

<p>참고로, <code>Object</code> 타입의 가변인자를 받으면 <code>42.asInstanceOf[AnyRef]</code> 처럼 직접 변환해야 한다.</p>

<p>(7). <strong>=</strong> 가 없는 함수는 <strong>Unit</strong> 리턴 타입을 가지며, <strong>프로시저</strong> 라 불린다. 값을 리턴하지 않기 때문에, 사이드 이펙트만를 위해 사용한다. 프로시저에서 <code>Unit</code> 을 직접 명시할수도 있다.</p>

<pre><code class="scala">def proc(str: String) {  
  ...
  ... // side effect
  ...
}
</code></pre>

<p>(8). <code>lazy val</code> 을 이용하면, <code>def</code> 처럼 해당 변수가 사용되기 전까지 평가되지 않는다.</p>

<pre><code class="scala">lazy val words = scala.io.Source.fromFile("words.txt").mkString  
</code></pre>

<p>그런데, <code>lazy</code> 로 선언되면 값을 접근할때 마다 스레드세이프하게 초기화가 되었는지 확인하는 검사가 필요하므로 비용이 든다.</p>

<p>(8). 스칼라에는 체크예외가 없다. 모두 런타임 예외다. 그리고, <code>throw</code> 는 <code>Nothing</code> 을 값으로 가지는데, <code>if</code> 문에서는 <code>Nothing</code> 대신 다른 분기의 타입으로 식의 값이 정해진다.</p>

<h3 id="chapter3">Chapter 3</h3>

<p>(1). 고정길이 배열이 필요하면 <code>Array</code> 로 사용하면 된다. 만약 초기값이 필요없으면 <code>new</code> 를 사용하고, 아니면 <code>new</code> 를 제외한다.</p>

<pre><code class="scala">val nums = new Array[Int](10)  
val strs = Array[String]("Hello", "World")  
</code></pre>

<p>고정 배열은 JVM 내부에서 자바의 일반 배열로 처리된다.</p>

<p>(2). 가변빌이 배열이 필요하면 <code>ArrayBuffer</code> 를 사용하면 된다. 자바의 <code>ArrayList</code> 라 보면 된다. </p>

<pre><code class="scala">val ab = ArrayBuffer[Int]()  
ab += 1  
ab += (2, 3)  
ab ++= Array(4, 5)  
</code></pre>

<p><code>ArrayBuffer</code> 끝에 원소를 삽입하고 삭제하는건 성능이 괜찮지만, 중간에 삽입하고 삭제하면 기존의 원소를 옮겨야 하므로 성능이 떨어진다는 점에 주의하자. </p>

<p>만약 <code>Array</code> 를 <code>ArrayBuffer</code> 로 만들려면 <code>toBuffer</code> 메소드를, <code>ArrayBuffer</code> 를 <code>Array</code> 로 만들려면 <code>toArray</code> 를 호출하면 된다.</p>

<p>(3). <code>until</code> 은 <code>RichInt</code> 클래스에 속한다. 만약 0부터 10까지 2씩 건너뛰고 싶으면</p>

<p><code>0 to (10, 2)</code> </p>

<p>거꾸로 순회하고 싶으면</p>

<p><code>(0 to 10).reverse</code></p>

<p>(4). 만약 <code>ArrayBuffer</code> 에 있는 음수 중, 처음 것만 제외하고 모두 삭제하고 싶을때 Flag 를 사용하면 다음과 같은 코드를 만들 수 있다.</p>

<pre><code class="scala">val first = true  
val n = arr.length  
var i = 0

while(i &lt; n) {  
  if (arr(i) &gt;= 0) i += 1
  else {
    if (first) { first = false; i += 1}
    else {
      arr.remove(i); n -= 1
    }
  }
}
</code></pre>

<p>그런데, 배열 버퍼 중간에 있는 원소를 삭제하는건 비효율적이기 때문에, 차라리 인덱스를 보존하고 한꺼번에 옮겨 자르는 편이 더 낫다.</p>

<pre><code class="scala">val indexes = for(i until arr.length if arr(i) &gt;= 0 || first) yield {  
  if (a &lt; 0) first = false;
  i
}

for(j until indexes.length) {  
  arr(j) == arr(indexes(j))
}

arr.trimEnd(arr.length - indexes.length)  
</code></pre>

<p>(4). <strong>for comprehension</strong> 의 <code>guard</code> 와 <code>yield</code> 를 사용하든, <strong>collection</strong> 의 <code>filter</code> 와 <code>map</code>을 사용하든 하는일은 같다.</p>

<p>(5). <code>ArrayBuffer</code> 나 <code>Array</code> 는 <code>max</code>, <code>min</code>, <code>sum</code> 과 같은 메소드 들을 가지고 있다. 그리고 <code>min</code>, <code>max</code> 혹은 <code>scala.util.Sorting.quickSort</code> 에 들어갈 컬렉션의 원소타입들은 반드시 비교 연산을 가지고 있어야 하는데, <strong>숫자</strong>, <strong>문자열</strong>, <strong>Ordered Trait</strong> 을 가지는 타입이 해당된다.</p>

<p>(6). 컬렉션의 원소를 이쁘게 출력하고 싶으면 <code>mkString</code> 을 이용하자.</p>

<pre><code class="scala">Array(1, 2, 3).mkString(" and ")  
// "1 and 2 and 3"
Array(1, 2, 3).mkString("&lt;", ", ", "&gt;")  
//  "&lt;1, 2, 3&gt;"
</code></pre>

<p>(7) <code>Array</code> 의 <code>toString</code> 은 <code>ArrayBuffer</code> 와는 달리 쓸모가 없다.</p>

<pre><code class="scala">scala&gt; Array(1, 2, 3).toString  
// res28: String = [I@412d54b3
</code></pre>

<p>(8). ScalaDoc 을 여행하다보면 기기묘묘한 것들을 만날 수 있다.</p>

<p><code>def appendAll(xs: TraversableOnce[A]): Unit</code> 같은 경우, <code>xs</code> 는 <code>TraversableOnce</code> 트레이트를 구현하는 콜렉션이라 보면 된다.. 스칼라의 모든 컬렉션은  <code>TraversableOnce</code> 또는 흔하게 볼 수 있는 컬렉션의 트레이트로 <code>TraversableIterable</code> 이 있다.</p>

<p><code>def += (elem: A): ArrayBuffer.this.type</code> 의 경우 체이닝이 가능하도록 자기 자신을 리턴하는 메소드다. 이를테면 <code>b += 4 += 5.</code> 처럼</p>

<p><code>def copyToArray[B &gt;: A] (xs: Array[B]): Unit</code> 의 경우 <code>ArrayBuffer[A]</code> 의 모든 원소를 <code>Array[B]</code> 로 복사하는데 <code>B</code>는 <code>A</code> 의 하위 타입이다. <code>ArrayBuffer[Int]</code>,   <code>Array[Any]</code> 처럼</p>

<p>(9). 자바처럼 당연히 컬럼이 고정되지 않은 다차원 배열도 만들 수 있다. </p>

<pre><code class="scala">val triangle = new Array[Array[Int]](10)  
for(i &lt;- 0 to triangle.length)  
  triangle(i) = new Array[Int](i + 1)
</code></pre>

<p>만약 컬럼이 고정된 다차원 배열을 만든다면 <code>ofDim</code> 메소드를 이용하면 된다. 접근하려면 괄호를 두번 사용한다.</p>

<pre><code class="scala">val matrix = Array.ofDim[Double](3, 4)

maxtric(0)(1)  
</code></pre>

<p>(10). 스칼라 배열은 자바 배열로 구현되므로, 당연히 주고 받을 수 있다. <code>java.util.List</code> 를 받거나 리턴하는 자바 메소드를 호출하면 스칼라 코드에서 <code>ArrayList</code> 를 사용할 수 있지만, 이것 대신 <code>scala.collection.JavaConversions</code> 에 속한 메소드들을 임포트하면, 스칼라 버퍼를 자동으로 자바 리스트로 변환할 수 있다. </p>

<p>아래 예제에서 자바의 <code>java.lang.ProcessBuilder</code> 는 <code>List&lt;String&gt;</code> 을 받는 생성자를 가지고 있는데, <code>JavaConversions.bufferAsJavaList</code> 를 임포트하면 스칼라 버퍼가 <code>java.util.List</code> 인터페이스를 구현한 자바 클래스 오브젝트로 감싸진다.</p>

<pre><code class="scala">iport scala.collection.JavaConversions.bufferAsJavaList  
import scala.collection.mutable.ArrayBuffer

val command = ArrayBuffer("ls", "-al" "/home/user")  
val processBuilder(command)  
</code></pre>

<p>반대로 자바 메소드가 <code>java.util.List</code> 리턴하면 <code>Buffer</code> 로 자동으로 변환할 수 있다. 아래 예제에서 <code>cmd == command</code> 다. 바로 <code>ArrayBuffer</code> 로 받지 않는다는 점에 주의하자. <code>Buffer</code> 만 보장한다.</p>

<pre><code class="scala">import scala.collection.JavaConversions.asScalaBuffer  
import scala.collection.mutable.ArrayBuffer  
sd  
val cmd: Buffer[String] = pb.command()  
</code></pre>

<p>참고로, 스칼라의 컬렉션은 <code>immutable</code> 이 기본이고, 자바의 컬렉션은 <code>mutable</code> 이 기본이다.</p>]]></description><link>http://1ambda.github.io/scala-for-the-impatient-chapter-1-2-3/</link><guid isPermaLink="false">d3535bd4-9f25-4ff0-bec0-74124cfc98fd</guid><category><![CDATA[scala]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 26 Sep 2014 10:31:09 GMT</pubDate></item></channel></rss>