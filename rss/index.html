<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Old Lisper]]></title><description><![CDATA[Lisp, Emacs, Scala]]></description><link>http://1ambda.github.io/</link><generator>Ghost 0.5</generator><lastBuildDate>Sun, 28 Dec 2014 17:39:14 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Maximum Flow]]></title><description><![CDATA[<p><img src='https://graph-tool.skewed.de/static/doc/_images/example-edmonds-karp.png'  alt="" /></p>

<h3 id="mincut">Min Cut</h3>

<p><em>edge weighted</em> 그래프에서 <code>st</code>-<em>cut</em> 이란 <em>vertices</em> 를 두개의 <em>disjont sets</em> 으로 나누는 것이다. 이때 <code>s</code>, <code>t</code> 는 각각 다른 집합 <code>A</code>, <code>B</code> 에 속해있다.</p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/0/02/Min-cut.svg/220px-Min-cut.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org/' >http://en.wikipedia.org</a>)</p>

<p><strong>capacity</strong> 란 컷으로 나뉘어진 두 집합 <code>A</code>, <code>B</code> 를 기준으로 <code>A</code> 에서 <code>B</code> 로 가기 위한 모든 <em>edge</em> 의 <em>weight</em> 를 모두 합친 것이다. <code>B</code> 에서 <code>A</code> 로의 <em>edge</em> 는 세지 않는 다는 것에 주의하자.</p>

<p><em>mincut problem</em> 은 <em>min capacity</em> 를 갖는 <em>cut</em> 을 찾는 문제다. 응용으로는</p>

<ul>
<li>실제 전쟁에서 보급로를 끊거나</li>
<li>독재 정부에서 커뮤니케이션을 제한하거나</li>
</ul>

<h3 id="maxflow">Max Flow</h3>

<p><img src='http://kunuk.files.wordpress.com/2010/11/fordfulkerson1.gif?w=700'  alt="" /></p>

<p align="center">(<a href='http://kunuk.wordpress.com/' >http://kunuk.wordpress.com</a>)</p>

<p><em>edge</em> 에 <em>weight</em> 이외에도 <em>flow</em> 를 할당할 수 있다. 이 플로우는 몇 가지 성질을 만족하는데</p>

<ul>
<li><strong>capacity constraint:</strong> <code>0 &lt;= edge's flow &lt;= edge's capa</code></li>
<li><strong>local equilibrium:</strong> <code>inflow = outflow</code> at every vertex except <code>s</code> and <code>t</code></li>
</ul>

<p>즉 한 에지에서 캐퍼시티는 항상 플로우보다 크거나 같고, <code>s, t</code> 를 제외한 모든 노드에서 <em>inflow = outflow</em> 다.</p>

<p><em>flow</em> 의 <em>value</em> 는 <code>t</code> 에서의 <em>inflow</em> 다. 이때 <code>s</code> 를 가리키는 노드가 없고, <code>t</code> 가 가리키는 노드가 없다고 가정한다. 다시 말해 <code>s</code> 는 시작점, <code>t</code> 는 종료지점이다.</p>

<p>따라서 플로우를 어떻게 할당하냐에 따라 <em>value</em> 가 달라질 수 있다. 이 때 <em>maximum flow</em> 문제는 최대 값을 갖는 <em>flow</em> 를 찾는 문제다.</p>

<p><em>max flow</em> 의 응용은</p>

<ul>
<li>운송량을 최대로 하는 보급로를 찾기</li>
</ul>

<h4 id="summary">Summary</h4>

<p>정리하면 <em>weighted digraph</em> 에서 <em>source vertex</em> <code>s</code>, <em>target vertex</em> <code>t</code> 에 대해</p>

<p>두 가지 문제를 정의할 수 있다.</p>

<ul>
<li><strong>min cut:</strong> Find a cut of minimum capacity</li>
<li><strong>max flow:</strong> Find a flow of maximum value</li>
</ul>

<p>사실 이 문제는 상당히 유사한데, <em>dual</em> 관계다. 하나를 풀면 다른 하나도 풀 수 있다.</p>

<h3 id="fordfulkersonalgorithm">Ford-Fulkerson Algorithm</h3>

<p>기본적인 아이디어는 <em>augmenting path</em> 를 찾으면서 <em>flow</em> 값을 증가시키는 것이다.</p>

<ul>
<li><em>forward edge</em> (not full) 을 이용해서 <em>flow</em> 값을 증가시키고</li>
<li><em>backward edge</em> (not empty) 를 이용해서 감소시킬 수 있다</li>
</ul>

<p><em>backward edge</em> 의 아이디어는 <em>local equilibrium</em> 이다. 진행할 수 없는 상황에서 <em>backward edge</em> 를 만들고, 거기서 <em>flow</em> 의 평형을 맞추는 값만큼 뺀 후 다시 진행한다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWXljek0wSTJNaWRqWTNZVEx6RWpaaDF5TTVZMk10TWpabVZUTDVNR1ppbHpZaUJ6TDNNek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>더이상 <em>augmenting path</em> 를 찾을 수 없을 때 알고리즘이 종료된다. 이건 <em>full forward edge</em> 가 존재하거나 <em>empty backword edge</em> 가 만들어졌기 때문이다.</p>

<p><img src='http://www.cs.princeton.edu/courses/archive/spr13/cos226/lectures/summaries/maxFlowCheckpoint.png'  alt="" /></p>

<p align="center">(<a href='http://www.cs.princeton.edu/' >http://www.cs.princeton.edu/</a>)</p>

<p>알고리즘을 서술하면</p>

<pre><code>// Fold-Fulkerson algorithm

Start with 0 flow  
While there exists an augmenting path  
- find an augmenting path
- compute bottleneck capacity
- increase flow on that path by bottleneck capacity
</code></pre>

<p>그럼, 이제 문제는 <em>min cut</em> 은 어떻게 계산하고 <em>augmenting path</em> 는 어떻게 찾을지로 치환된다.</p>

<p>그리고 추가적인 질문으로 <em>FF</em> 알고리즘이 <em>max flow</em> 를 찾는지, 그리고 항상 종료된다는 걸 보장하는지, 종료된다면 얼마만큼의 <em>augmentations</em> 를 찾아내는지를 물어볼 수 있다.</p>

<p>좀 더 자세한 알고리즘 설명은 이 <a href='http://www.cs.princeton.edu/courses/archive/spring13/cos226/lectures/64MaxFlow.pdf' >슬라이드</a> 를 참조할 것</p>

<h3 id="maxflowmincuttheorem">Maxflow-Mincut Theorem</h3>

<p><em>cut</em> 과 <em>flow</em> 는 무슨 관계일까? </p>

<p><em>net flow accros cut</em> <code>(A, B)</code> 는 <code>A-&gt;B</code> 로의 <em>flow</em> 를 모두 합한 것에서 <code>B-&gt;A</code> 로의 <em>flow</em> 를 모두 뺀 것이다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5WWhKV1lsRkRaeVFtTTVZV0xtVkRPaTF5TTFjek10TXpZbGxUTGxCRE1pWkRaaFZ6TDVNek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<blockquote>
  <p><em>flow-value lemma:</em> Let <code>f</code> be any flow and let <code>(A, B)</code> be any cut. Then the net flow accros <code>(A, B)</code> equals the value of <code>f</code></p>
</blockquote>

<p><code>B</code> 의 사이즈에 대해 귀납법을 이용하면 증명은 어렵지 않다.</p>

<p>(1) Base case <code>B = { t }</code></p>

<p><em>base case</em> 에선 당연히 <em>value</em> 와 <em>net flow accros</em> 가 동일하다.</p>

<p>(2) Inductive case</p>

<p><code>A</code> 에서 <code>B</code> 로 <em>vertex</em> 를 하나씩 옮겨도 <em>local equilibrium</em> 이 참이므로 이 속성은 유지된다. 옮기려는 <em>vertex</em> 를 <code>k</code> 라 하면</p>

<p><code>k</code> 를 기준으로 <em>inflow</em></p>

<ul>
<li><code>A -&gt; k</code></li>
<li><code>B -&gt; k</code></li>
</ul>

<p>는 다음의 <em>outflow</em> 와 동일하다.</p>

<ul>
<li><code>k</code> -> <code>A</code></li>
<li><code>k</code> -> <code>B</code></li>
</ul>

<p>그런데 <code>k</code> 를 <code>B</code> 로 옮기게 되면 <em>net flow accros</em> 에 미치는 영향이 <em>inflow</em>, <em>outflow</em> 간 반대가 되지만 어쨌든 <em>local equilibrium</em> 에 의해 값은 같으므로 어차피 <em>value</em> 와 같다.</p>

<p>그리고 결국 <code>k</code> 를 계속 옮기다 보면<code>s</code> 의 <em>outflow</em> 는 <code>t</code> 의 <em>inflow</em> 와 같고 이것인 <em>value of flow</em> 와 같다.</p>

<h4 id="weakduality">Weak Duality</h4>

<p><em>weak duality</em> 란 <code>f</code> 를 아무 플로우, <code>(A, B)</code> 를 어느 컷이라 할 때 </p>

<blockquote>
  <p><em>value of flow</em> <code>&lt;=</code> <em>capacity of cut</em></p>
</blockquote>

<p>이 성립함을 말한다. 따라서 <em>max flow</em> 는 <em>min cut</em> 이다. 증명과정을 좀 보자. 위에서 귀납법으로 참임을 보인 성질에 의해 다음이 성립한다. <del>뜬금없이 증명해버림</del></p>

<p><em>value of flow</em> <code>f</code> = *net flow accros <code>(A, B)</code> &lt;= capacity of <code>(A, B)</code></p>

<ul>
<li><strong>Augmenting path theorem:</strong> A flow <code>f</code> is a maxflow iff no augmenting paths</li>
<li><strong>Maxflow-mincut theorem:</strong> Value of the maxflow = capacity of mincut</li>
</ul>

<p>즉 이 말은 <del>동어 반복의 향연</del></p>

<p>(1) 플로우 <code>f</code> 의 <em>value</em> 와 동일한 값의 <em>capacity</em> 를 가지는 어떤 컷이 있다. <br />
(2) <code>f</code> 는 <em>max flow</em> 다 <br />
(3) <code>f</code> 에 대해 <em>augmenting path</em> 가 없다.</p>

<p>정리해 보면 <em>max flow</em> 로 부터 <em>min cut</em> 을 계산할 수 있다는 소리가 된다. 잘 보면 <em>max flow</em> <code>f</code> 에서는 <em>augmenting path</em> 가 없다.</p>

<p>다시 말해 </p>

<ul>
<li>한 집합은 <code>s</code> 에서 <em>non-full forward</em> 로 출발하지만 <em>empty backward</em> 에 의해 막히고</li>
<li>다른 집단은 <em>full foraward</em> 때문에 <code>t</code> 로의 <em>non empty backword</em> 가 막힌다.</li>
<li>이 두집단의 자르는 <em>cut</em> 은 <em>full forward</em>, <em>empty backward</em> 로만 구성된다.</li>
</ul>

<p>이 컷은 <em>net flow accros cut</em> 고 첫번째 집단은 <code>A</code>, 두번째 집단은 <code>B</code> 가 된다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWjVZR05sSlRPaE4yTm1KVEw1TVdZNTBDTzJnek10VW1ZaUZXTG1CRFpoRkRaaU56THpRek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p>따라서 러닝타임은 <em>max flow</em> <code>f</code> 가 주어진다면 모든 <em>vertex</em>, <em>edge</em> 를 한번씩 보며 <code>A</code> 를 찾는 시간이므로 <code>V + E</code> 다.</p>

<h3 id="runningtimeanalysis">Running Time Analysis</h3>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5WTBJRE40a3pNMklXWW1KVEx5SVRaNTB5WWpaek10QVROaGhUTGlSV1lqUkdPM1V6TDNRek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>아까 했던 질문들에 답해보면</p>

<ul>
<li><em>mincut</em> 을 계산하긴 쉽다.</li>
<li><em>BFS</em> 로 <em>augmenting path</em> 를 찾을 수 있다.</li>
<li><em>Ford-Fulkerson</em> 이 종료되면 <em>max flow</em> 를 찾을 수 있다</li>
<li><em>capacity</em> 가 정수거나, <em>argumenting path</em> 를 신중히 고른다면 <em>FF</em> 는 종료된다.</li>
<li>얼마나 많은 <em>augmentations</em> 가 있을진 생각좀 해봐야 한다.</li>
</ul>

<p>간단한 경우부터 좀 보자.</p>

<h4 id="integercapacities">Integer Capacities</h4>

<p><em>edge capacities</em> 가 <code>[1, U]</code> 사이의 값이면 <em>FF</em> 알고리즘에 걸쳐서 모든 <em>flow</em> 값은 정수다. 쉽게 증명 가능한데</p>

<ul>
<li>Bottleneck capacity is an integer</li>
<li>Flow on an edge increases / decreases by bottleneck capa</li>
</ul>

<blockquote>
  <p><code># of augmentations &lt;= max flow value</code></p>
</blockquote>

<p>다시 말해 <em>augmentations</em> 의 수는 <em>max flow value</em> 보다 작거나 같다. 왜냐하면 처음에 <code>0</code> 부터 시작해서 매 <em>augmentation</em> 마다 적어도 <em>value</em> 를 1 씩 증가시키기 때문이다.</p>

<ul>
<li><strong>Integrality theorem:</strong> There exists an integer-values maxflow </li>
</ul>

<p>이 때 <em>FF</em> 알고리즘이 종료되면 <em>max flow</em> 를 찾아내고, 이것은 위에서 보였듯이 <em>integer-value</em> 를 가진다.</p>

<h4 id="badcaseforff">Bad case for FF</h4>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTW1Oek15RW1Zd0FqTWlWVExpbHpZNTBDWmhSMk10VURad01UTDJZek1oTldNeEl6THhVek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p><em>integer value max flow</em> 에선 운이 나쁠 경우 <em>max flow value</em> 만큼 <em>augmentation</em> 이 일어난다. 위 슬라이드에서 볼 수 있듯이 그래프 사이즈에 비해 어마어마한 <em>augmentation</em> 이 일어날 수 있다.</p>

<p>다행히도 <em>shortest, fattest path</em> 를 이용해 이런 상황을 피할 수 있다.</p>

<ul>
<li><em>shortest path:</em> augmenting path with <strong>fuwest number of edges</strong></li>
<li><em>fattest path:</em> augmenting path with <strong>maximum bottleneck capacity</strong></li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5WWtWMk4yTUdNbFZUWmpWVEx6UVdZaTFDTWtOMk10UVdNaUJUTGlaR1owTVRNbVoyTDFVek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>따라서 <em>FF</em> 알고리즘의 성능은 어떤 <em>augmenting path</em> 를 선택하느냐에 따라 달라질 수 있다.</p>

<h3 id="implementation">Implementation</h3>

<p><em>Ford-Fulkerson</em> 알고리즘을 구현함에 있어서 실제로 사용하게 될 값은 두 가지다.</p>

<ul>
<li><em>forward edge residual capacity</em> = <code>c - f</code></li>
<li><em>backward edge residual capacity</em> = <code>f</code></li>
</ul>

<p>따라서 <em>flow</em>, <em>capacity</em> 보다는 <em>residual capacity</em> 를 <em>edge</em> 의 가중치로 표시하는 <em>residual network</em> 를 이용하는편이 더 직관적이다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTT2lSMk1rRkdNNGN6WTVVVExsRjJZNTB5WWlsek10RVRPeVFXTDRjak41TVRObVp6TDNVek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>실제 클래스 구현은</p>

<pre><code class="java">public class FlowEdge {

  private final int v, w;
  private final double capacity;
  private double flow;

  public FlowEdge(int v, int w, double capacity) {
    this.v = v; 
    this.w = w;
    this.capacity = capacity;
  }

  public int from() { return v; }
  public int to() { return w; }
  public double capacity() { return capacity; }
  public double flow() { return flow; }

  // other endpoint
  int other(int vertex) {
    if (vertex == v) return w;
    else if (vertex == w) return v;
    else throw new RuntimeException("Illegal endpoint");
  }

  // residual capacity toward v
  double residualCapacityTo(int vertex) {
    if (vertex == v)      return flow;            // backward edge
    else if (vertex == w) return capacity - flow; // forward edge
    else throw new IllegalArgumentException();
  }

  // add delta flow toward v
  void addResidualFlowTo(int vertex, double delta) {
    if (vertex == v)      flow -= delta; // backward edge
    else if (vertex == w) flow += delta; // forward edge
    else throw new IllegalArgumentException();
  } 
}
</code></pre>

<p><code>FlowNetwork</code> 는</p>

<pre><code class="java">public class FlowNetwork {  
  private final int V;
  // Bag is a list without remove op
  private Bag&lt;FlowEdge&gt;[] adj;

  public FlowNetwork(int V) {
    this.V = V;
    adj = (Bag&lt;FlowEdge&gt;[]) new Bag[V];
    for (int v = 0; v &lt; V; v++)
      adj[v] = new Bag&lt;FlowEdge&gt;();
  }

  public void addEdge(FlowEdge e) {
    int v = e.from();
    int w = e.to();
    adj[v].add(e); // add forward edge
    adj[w].add(e); // add backward edge
  }

  public Iterable&lt;FlowEdge&gt; adj(int v) { 
    return adj[v];
  }

  public int V() { return V; }
}
</code></pre>

<p><em>FF</em> 알고리즘 구현은 아래와 같다. <em>shortest augmenting path</em> 를 찾기 위해 <em>BFS</em> 를 이용했다.</p>

<pre><code class="java">public class FordFulkerson {

  private boolean[] marked;  // ture if s-&gt;v path in residual network
  private FlowEdge[] edgeTo; // last edge on s-&gt;v path
  private double value;      // value of flow

  public FordFulkersen(FlowNetwork G, int s, int t) {
    value = 0.0;

    while (hasAugmentingPath(G, s, t)) {
      double bottle = Double.POSITIVE_INFINITY;

      // compute bottleneck capacity
      for (int v = t; v != s; v = edgeTo[v].other(v))
        bottle = Math.min(bottle, edgeTo[v].residualCapacityTo(v));

      // augment flow
      for (int v = t; v != s; v = edgeTo[v].other(v))
        edgeTo[v].addResidualFlowTo(v, bottle);

      value += bottle;
    }
  }

  // find a shortest augmenting path using BFS
  private boolean hasAugmentingPath(FlowNetwork G, int s, int t) {
    edgeTo = new FlowEdge[G.V()];
    marked = new boolean[G.V()];

    Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
    q.add(s);
    marked[s] = true;

    while (!q.isEmpty()) {
      int v = q.remove();

      for (FlowEdge e : G.adj(v)) {
        int w = e.other(v);

        // path s-&gt;w is in the residual network?
        if (e.residualCapacityTo(w) &gt; 0 &amp;&amp; !marked[w]) {
          edgeTo[w] = e;
          marked[w] = true;
          q.add(w);
        }
      }
    }

    return marked[t];
  }

  public double value() { return value; }
  // is `v` reachable from s in residual network?
  public boolean inCut(int v) { return marked[v]; } 
}
</code></pre>

<p><img src='http://upload.wikimedia.org/wikipedia/en/thumb/0/0e/Max-flow_min-cut_example.svg/288px-Max-flow_min-cut_example.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org/' >http://en.wikipedia.org</a>)</p>

<p>테스트 코드도 좀 돌려보자. 예제는 위와 같고, 코드는 아래에 있다.</p>

<pre><code class="java">public class FordFulkensonTest {

  @Test
  public void test() {
    int E = 5;

    int s = 0;
    int t = 3;

    // http://en.wikipedia.org/wiki/Max-flow_min-cut_theorem#Example
    FlowEdge[] edges = new FlowEdge[E];
    edges[0] = new FlowEdge(s, 1, 4.0);
    edges[1] = new FlowEdge(s, 2, 3.0);
    edges[2] = new FlowEdge(1, 2, 3.0);
    edges[3] = new FlowEdge(1, t, 4.0);
    edges[4] = new FlowEdge(2, t, 5.0);

    int V = 4;
    FlowNetwork G = new FlowNetwork(V);

    for (FlowEdge e : edges)
      G.addEdge(e);

    FordFulkerson FF = new FordFulkerson(G, s, t);

    assert(FF.value() == 7);
  }
}
</code></pre>

<h3 id="maxflowapplication">Max Flow Application</h3>

<p><em>shortest path</em> 처럼 <em>max flow</em> 도 정말 많은 곳에 응용할 수 있다.</p>

<ul>
<li>Bipartite maching</li>
<li>Network reliability</li>
<li>Baseball elimination</li>
<li>Image segmentation</li>
<li>Distributed computing</li>
<li>...</li>
</ul>

<h4 id="bipartitemachingproblem">Bipartite maching problem</h4>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTTRNalowTVdPNE1UTTBVV0x6TVRONDBDTzFVMk10WUROakZUTDJVMk0wVUROa056THhZek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p><code>N</code> 명의 <em>student</em> 가 <code>N</code> 개의 <em>company</em> 로부터 각각 몇개씩의 주문을 받았을 때, <code>1:1</code> 로 대응하는 그래프를 그릴 수 있느냐의 문제다. </p>

<p><em>max flow</em> 알고리즘을 이용해 <em>bipartite maching</em> 문제를 풀 수 있다.</p>

<ul>
<li>Create <code>s</code>, <code>t</code>, one vertex for each student, and one vertex for each company(job)</li>
<li>Add edge from <code>s</code> to each student (capacity 1)</li>
<li>Add edge from each job to <code>t</code> (capacity 1)</li>
<li>Add edge from student to each job offered (infinite capacity)</li>
</ul>

<p>이렇게하면 <em>local equilibrium</em> 에 의해 각 <em>student</em> 마다 하나씩의 <em>out-flow</em> 밖에 가지지 못하고, 마찬가지로 <em>job</em> 도 하나씩의 <em>in-flow</em> 밖에 가지지 못하므로 <code>1:1</code> 대응을 만들 수 있다.</p>

<p>완벽히 매칭이 이루어지는지, 아닌지를 <em>min cut</em> 을 이용해 알 수 있다. 그림을 보자.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTm1OV08xSUdOd1VtWTJNVExsQnpNaDFTWjJRek10WXpNaUZUTGlWMk4wZ1ROa0p6THpZek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<ul>
<li>Let <code>S</code> = students on <code>s</code> side of cut.</li>
<li>Let <code>T</code> = companies on <code>s</code> side of cut.</li>
<li><code>|S|</code> > <code>|T|</code>; students in <code>S</code> can be matched only to companies in <code>T</code>.</li>
</ul>

<h4 id="baseballelimination">Baseball elimination</h4>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzV5TWhWVE9oZERNeGNET2paVEx6a0RPaDFDTm1WMk10UXpNMllUTGhKVFppSlRZME16TDFZek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<blockquote>
  <p>Which teams have a chance of finishing the season with the most wins?</p>
</blockquote>

<p>이건 게임이 얼마나 남았느냐 뿐만 아니라, 누구와 상대하냐도 문제가 되기 때문에 이렇게 그래프를 그려 풀 수 있다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTTm1SR08yVTJZMlFqTTRnVEwxTURNaTFTWmpoek10TVRZaVJXTDJFMk5sSkdPakp6TDNZek53OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>여기서 디트로이트 (<code>4</code>) 는 수학적으로 봤을때 우승이 불가능하므로 미리 제거했다. 그리고, <code>s</code> 에서 출발하는 <em>edge</em> 를 각 팀간 남은 경기로, 그리고 <code>t</code> 로 들어가는 <em>edge</em> 를 디트로이트의 남은경기, 이긴경기에서 해당 팀의 이긴경기를 빼서 <em>upper bound</em> 를 설정한다.</p>

<blockquote>
  <p>Team 4 (디트로이트) not eliminated iff all edges pointing from <code>s</code> are full in max flow</p>
</blockquote>

<h3 id="performance">Performance</h3>

<p><em>max flow</em> 문제의 경우 <em>FF</em> 알고리즘을 이용하면 <em>worst case</em> 에서 <code>E^2U</code> 성능이 나온다고 한다. 근데 이건 1955년도에 발견된 알고리즘이고, 가장 최근에는 <em>compact network</em> 라는 기법이 2012년에 만들어졌다. 이건 <code>E^2 / log E</code> 의 <em>worst case performance</em> 라고 함.</p>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Ro$bert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='https://graph-tool.skewed.de/static/doc/flow.html' >https://graph-tool.skewed.de/</a> <br />
(4) <a href='http://en.wikipedia.org/wiki/Cut_' (graph_theory)">Wikipedia: Cut</a> <br />
(5) <a href='http://kunuk.wordpress.com/2010/11/09/graph-flow-ford-fulkerson-algorithm-example-with-c/' >http://kunuk.wordpress.com - Flow</a> <br />
(6) <a href='http://www.programering.com/a/MDN0gDNwATY.html' >http://www.programering.com</a> <br />
(7) <a href='http://en.wikipedia.org/wiki/Max-flow_min-cut_theorem' #Example">Wikipeda - Max Flow</a></p>]]></description><link>http://1ambda.github.io/maximum-flow/</link><guid isPermaLink="false">90497f41-cd0f-4eb0-99bf-f59bbd7d1871</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[maximum flow]]></category><category><![CDATA[ford-fulkerson]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 28 Dec 2014 08:04:11 GMT</pubDate></item><item><title><![CDATA[Reactive Programming 5, Actor]]></title><description><![CDATA[<p><img src='http://prabhubuzz.files.wordpress.com/2012/09/demo1.png'  alt="" /></p>

<p align="center">(<a href='http://prabhubuzz.wordpress.com/' >http://prabhubuzz.wordpress.com</a>)</p>

<p><em>Actor</em> 는 원래 1973년에 인공지능 연구를 위해 개발되었는데, 1995년에는 <em>Erlang/OTP</em> 에서 텔레커뮤니케이션 플랫폼을 위해 사용되기도했다. 2006년에는 스칼라 스탠다드 라이브러리로 구현되었고, 2009년에는 <em>Akka</em> 가 만들어졌다.</p>

<h3 id="whyactors">Why Actors?</h3>

<p>액터가 왜 필요한지를 기존의 스레드를 사용하는 방법과 비교해 알아보자. 지난번에 배웠던 <em>bank account</em> 예제를 들고오면</p>

<pre><code class="scala">class BankAccount {  
  private var balance = 0

  def deposit(amount: Int): Unit = 
    if (amount &gt; 0) balance = balance + amount

  def withraw(amount: Int): Int = 
    if (0 &lt; amount &amp;&amp; amount &lt;= balance) {
      balance = balance - amount
      balance
    } else throw new Error("insufficient funds")
}
</code></pre>

<p>이 예제를 두개의 스레드로 동시에 돌리면 충돌이 난다. 잔고가 얼마인지는 어떤 스레드가 나중에 실행되느냐에 따라 달라질 수 있다. </p>

<p>이를 해결하기 위한 일반적인 방법은 <em>synchronization</em> 을 이용하는 것이다. <em>lock, mutex, semaphore</em> 등을 이용할 수 있다.</p>

<p>스칼라도 이를 지원하기 위해 모든 오브젝트마다 <em>synchronization</em> 블럭을 설정할 수 있다.</p>

<pre><code class="scala">class BankAccount {  
  private var balance = 0

  def deposit(amount: Int): Unit = this.synchronized { 
    if (amount &gt; 0) balance = balance + amount
  }

  def withraw(amount: Int): Int = this.synchronized {
    if (0 &lt; amount &amp;&amp; amount &lt;= balance) {
      balance = balance - amount
      balance
    } else throw new Error("insufficient funds")
  }
}
</code></pre>

<p><code>deposit</code> 도 <code>balance</code> 를 수정하기 때문에 <em>synchronization</em> 블럭이 필요하다. 이 말은 결국 <code>balance</code> 를 수정하는 모든 곳에서 동기화 블럭을 작성해야 한다는 뜻이다.</p>

<pre><code class="scala">def transfer(from: BankAccount, to: BankAccount, amount: Int): Unit = {  
  from.synchronized {
    to.synchronized {
      from.withdraw(amount)
      to.deposit(amount)
    }
  }
}
</code></pre>

<p>과도한 동기화는 데드락을 만들 수 있다. 이를 피하기 위해 <em>ordered lock</em> 을 이용하는 등 다양한 방법이 있다. 그러나 코드가 복잡해진다. 이건 간단한 예제라 별로 복잡해질게 없지만, 더 커다란 예제라면 끔찍해진다.</p>

<ul>
<li>blocking synchronization introduces <strong>dead-lock</strong></li>
<li>blocking is bad for CPU utilization</li>
<li>synchronous communication couples sender and receiver</li>
</ul>

<p><em>non-blocking object</em> 를 이용하되, 병렬로 실행할 수 있는 방법은 없을까? 그게 바로 액터다.</p>

<h3 id="theactormodel">The Actor Model</h3>

<blockquote>
  <p>The Actor Model represents objects and their interactions, resembling human organizations are built upon the laws of physics</p>
</blockquote>

<ul>
<li>Actor is an object with <strong>identity</strong></li>
<li>Actor <strong>has a behavior</strong></li>
<li>Actor only interacts using <strong>asynchonous message passing</strong> </li>
</ul>

<pre><code class="scala">type Receive = PartialFunction[Any, Unit]

trait Actor {  
  def receive: Receive
  ...
}
</code></pre>

<p>액터 타입에서 말해주듯이 메세지를 받는다. 액터는 <code>PartialFunction[Any, Unit]</code> 에서 볼 수 있듯이 어떤 인자든 처리할 수 있지만 아무것도 돌려주진 않는다. 타입 자체가 <em>asynchronous</em> 하게 메세지를 처리함을 보여준다.</p>

<p>간단한 액터를 만들어 보면</p>

<pre><code class="scala">class Counter extends Actor {  
  var count = 0 
  def receive = {
    case "incr" =&gt; count += 1
  }
}
</code></pre>

<p><code>"incr"</code> 만 받고, 자신은 메세지를 주지 않기 때문에 별로 할게 없다. 좀 더 예제를 키워보면</p>

<pre><code class="scala">class Counter extends Actor {  
  var count = 0 
  def receive = {
    case "incr" =&gt; count += 1
    case ("get", customer: ActorRef) =&gt; customer ! count
  }
}
</code></pre>

<p><em>akka</em> 에서 액터는 <code>ActorRef</code> 라는 <em>address</em> 를 이용해서 메세지를 보낼 수 있다. <code>!</code> 는 <em>tell</em> 이라 읽는다. 메세지를 보낸단 뜻이다.</p>

<pre><code class="scala">trait Actor {  
  implicit val self: ActorRef
  def sender: ActorRef
  ...
}

abstract class ActorRef {  
  def !(msg: Any)(implicit sender ActorRef = Actor.noSender): Unit
  def tell(msg: Any, sender: ActorRef) = this.!(msg)(sender)
  ...
}
</code></pre>

<p>얼랭에서는 매번 <code>sender</code> 를 지정하는 모양이다. 그러나 이건 자주 사용되는 패턴이기때문에 메세지를 보낼때 <code>sender</code> 를 <em>implicit</em> 하게 보내 이렇게 코드를 작성할 수 있다.</p>

<pre><code class="scala">def receive = {  
    case "incr" =&gt; count += 1
    case ("get", customer: ActorRef) =&gt; customer ! count
}

// same
def receive = {  
    case "incr" =&gt; count += 1
    case "get" =&gt; sender ! count
}
</code></pre>

<h4 id="theactorscontext">The Actor's Context</h4>

<pre><code class="scala">trait ActorContext {  
  def become(behavior: Receive, discardOld: Boolean = true): Unit
  def unbecome(): Unit
  ...
}

trait Actor {  
  implicit val context: ActorContext
}
</code></pre>

<p>액터는 <code>ActorContext</code> 라는 <em>behavior stack</em> 을 가지고 있는데, <code>become</code> 이용해 <em>push</em> 하거나 <code>unbecome</code> 을 이용해 <em>pop</em> 할 수 있다.</p>

<pre><code class="scala">class Counter extends Actor {  
  def counter(n: Int): Receive = {
    case "incr" =&gt; context.become(counter(n + 1))
    case "get" =&gt; sender ! n
  }

  def receive = counter(0)
}
</code></pre>

<p>여기서 볼 수 있는 것은</p>

<ul>
<li>state change is explicit (<code>become</code>)</li>
<li>state is scoped to current behavior (<code>context</code>)</li>
</ul>

<p>일종의 <em>asynchronous tail-recursion</em> 과 비슷하다.</p>

<h4 id="creatingandstopping">Creating and Stopping</h4>

<p>액터는 액터에 의해서 생성되고, 자기 자신에 의해서도 수행이 중단될 수 있다.</p>

<pre><code class="scala">trait ActorContext {  
  def actorOf(p: Props, name: String): ActorRef
  def stop(a: ActorRef): Unit
}
</code></pre>

<p>이제 <code>Counter</code> 에게 메세지를 보내는 <code>CounterMain</code> 을 만들면</p>

<pre><code class="scala">class CounterMain extends Actor {  
  val counter = context.actorOf(Props[Counter], "counter")

  counter ! "incr"
  counter ! "incr"
  counter ! "incr"
  counter ! "get"

  def receive = {
    case count: Int = &gt;
      println(s"count was $count")
      context.stop(self)
  }
}
</code></pre>

<p>돌리려면 <code>sbt "run-akka akka.Main CounterMain"</code> 처럼 실행해야 한다. <em>sbt</em> 세팅은</p>

<pre><code class="scaka">import sbt._  
import Process._  
import Keys._

name := "reactive-programming"

version := "1.0"

scalaVersion := "2.11.2"

resolvers += "Typesafe Repository" at "http://repo.typesafe.com/typesafe/releases/"

libraryDependencies ++= Seq(  
  "org.scalatest" % "scalatest_2.11" % "2.2.1" % "test",
  "io.reactivex" %% "rxscala" % "0.22.0",
  "com.typesafe.akka" %% "akka-actor" % "2.3.8"
)

testOptions in Test += Tests.Argument("-oI")  
</code></pre>

<p>전체 코드는</p>

<pre><code class="scala">package coursera.chapter5

import akka.actor.Actor  
import akka.actor.Props

class Counter extends Actor {  
  var count = 0

  def receive = {
    case "incr" =&gt;
      println("Counter received 'incr'")
      count += 1
    case "get" =&gt; sender ! count
  }
}

// sbt run-main akka.Main coursera.chapter.CounterMain
class CounterMain extends Actor {

  val counter = context.actorOf(Props[Counter], "counter")

  counter ! "incr"
  counter ! "incr"
  counter ! "incr"
  counter ! "get"

  def receive = {
    case count: Int =&gt;
      println(s"count was $count")
      context.stop(self)
  }
}

// run main actor
&gt; run-main akka.Main coursera.chapter5.CounterMain
[info] Running akka.Main coursera.chapter5.CounterMain
Counter received 'incr'  
Counter received 'incr'  
Counter received 'incr'  
count was 3  
[INFO] [12/27/2014 16:23:40.182] [Main-akka.actor.default-dispatcher-2] [akka://Main/user/app-terminator] application supervisor has terminated, shutting down
[success] Total time: 1 s, completed Dec 27, 2014 4:23:40 PM
&gt;
</code></pre>

<p>정리하자면 액터 모델에서의 <em>computation</em> 은</p>

<ul>
<li>send message</li>
<li>create actors</li>
<li>designate the behavior for the next message</li>
</ul>

<h3 id="messageprocesscingsemantics">Message Processcing Semantics</h3>

<p>액터의 상태를 직접적으로 변경할 수 있는 방법은 없다. 상태를 변경하려면 메세지를 보내야 한다. 그리고 메세지를 보내려면 <em>address, 주소</em> <code>ActorRef</code> 를 알고 있어야 한다.</p>

<ul>
<li>every actor knows its own address <code>self</code></li>
<li>creating an actor returns its address</li>
<li>addresses can be sent within be sent within messages (e.g <code>sender</code>)</li>
</ul>

<p>액터를 잘 보면 서로 독립적인 <em>computation, 연산</em> 을 수행한다. 이들은 병렬적으로 실행되며, 서로 커뮤니케이션 할 수 있는 유일한 방법은 메세지를 보내는 것 뿐이다.</p>

<ul>
<li>local execution, no notion of global synchronization</li>
<li>all actors run fully concurrently</li>
<li>message-passing primitive is one-way communication</li>
</ul>

<p>그리고 액터 하나를 기준으로 보면, <em>single-threaded</em> 로 처리 될 수 있다.</p>

<ul>
<li>messages are recived sequentially</li>
<li>behavior change is effective before processing the next message</li>
<li>processing one message is the atomic unit of execution</li>
</ul>

<p>메세지를 처리하는 메소드는 <em>synchronized method</em> 처럼 동작하지만 블러킹 없이 큐에 메세지를 넣는것으로 대신한다.</p>

<h4 id="bankaccountusingactor">Bank Account using Actor</h4>

<p>액터의 메세지를 <em>companion object</em> 에 정의하는 것 부터 시작하자. </p>

<pre><code class="scala">package coursera.chapter5.banking

import akka.actor.Actor  
import akka.actor.Props

object Account {  
  case class Deposit(amount: BigInt) {
    require(amount &gt; 0)
  }

  case class Withdraw(amount: BigInt) {
    require(amount &gt; 0)
  }

  case object Done
  case object Failed
}

class Account extends Actor {

  import Account._

  var balance = BigInt(0)

  def receive = {
    case Deposit(amount) =&gt; 
      balance += amount
      sender ! Done                      
    case Withdraw(amount) if amount &lt;= balance =&gt;
      balance -= amount
      sender ! Done
    case _ =&gt;
      sender ! Failed
  }
}
</code></pre>

<p><em>transfer</em> 를 구현하려면 한 액터(<code>BankAccount</code>) 로 부터 인출하고, 다른 액터에게 같은 금액을 입금하라고 명령을 내리는 액터를 만들면 된다.</p>

<pre><code class="scala">package coursera.chapter5.banking

import akka.actor.{Actor, Props, ActorRef}

object WireTransfer {  
  case class Transfer(from: ActorRef, to: ActorRef, amount: BigInt)
  case object Done
  case object Failed
}

class WireTransfer extends Actor {  
  import WireTransfer._

  def receive: Receive = {
    case Transfer(from, to, amount) =&gt;
      from ! Account.Withdraw(amount)
      context.become(awaitFrom(to, amount, sender))
  }

  def awaitFrom(to: ActorRef, amount: BigInt, customer: ActorRef): Receive = {
    case Account.Done =&gt;
      to ! Account.Deposit(amount)
      context.become(awaitTo(customer))
    case Account.Failed =&gt; 
      customer ! Failed
      context.stop(self)
  }

  def awaitTo(customer: ActorRef): Receive = {
    case Account.Done =&gt;
      customer ! Done
      context.stop(self)
    case Account.Failed =&gt;
      customer ! Failed
      context.stop(self)
  }
}
</code></pre>

<p>디버깅 위해 <code>akka.event.LoggingReceive</code> 를 구현한 <code>Main</code> 을 보자.</p>

<pre><code class="scala">package coursera.chapter5.banking

import akka.actor.Actor  
import akka.actor.Props  
import akka.event.LoggingReceive

// in sbt
// &gt; run-main akka.Main coursera.chapter5.banking.Main
class Main extends Actor {

  val accA = context.actorOf(Props[Account], "accA")
  val accB = context.actorOf(Props[Account], "accB")

  accA ! Account.Deposit(50)

  def receive = LoggingReceive {
    case Account.Done =&gt; transfer(50)
  }

  def transfer(amount: BigInt): Unit = {
    // transcation
    val tx = context.actorOf(Props[WireTransfer], "tx")

    tx ! WireTransfer.Transfer(accA, accB, amount)
    context.become(LoggingReceive {
      case WireTransfer.Done =&gt;
        println("successfully transfered")
        context.stop(self)
    })
  }
}
</code></pre>

<p>실행하려면 세팅을 좀 바꿔야한다. 나는 <code>main</code> 에서 그냥 실행하니까, <code>main/resources</code> 밑에 <code>application.conf</code> 를 만들고 이 세팅을 넣으면 된다. <code>test</code> 에서 실행하면 마찬가지로 <code>test/resources</code> 에 넣으면 되고.</p>

<pre><code>akka {  
  loglevel = "DEBUG"
    actor {
      debug {
        receive = on
      }
    }
}
</code></pre>

<p>잡다구리한거 제거하고 로그를 뽑으면</p>

<pre><code class="scala">&gt; run-main akka.Main coursera.chapter5.banking.Main
[accountA] received handled message Deposit(50)
[Main] received handled message Done
[accountA] received handled message Withdraw(50)
[accountB] received handled message Deposit(50)
successfully transfered  
[Main] received handled message Done
</code></pre>

<p>액터 모델에서 메세지 전송은 </p>

<blockquote>
  <p>all communication is inherently unreliable</p>
</blockquote>

<p>즉, 메세지가 전달되지 않을수도 있다는 뜻이다. 근데 이건 액터 모델뿐만 아니라 <em>synchronous</em> 에서도 마찬가지다. 컴퓨터가 크래시 나거나, 네트워크가 끊기거나.</p>

<p>그래서 프로토콜을 만들어 메세지가 실제로 전송되었는지 확인해야 한다.</p>

<blockquote>
  <p>delivery of a message requires eventual availability of channel, recipient</p>
</blockquote>

<p>3가지 전략을 사용할 수 있는데</p>

<ul>
<li><strong>at-most-once:</strong> sending once deilvers <code>[0, 1]</code> times</li>
<li><strong>at-least-once:</strong> resending until acknoledged delivers <code>[1, ~</code> times</li>
<li><strong>exactly-once:</strong> processing only first reception delivers 1 time</li>
</ul>

<p>두번째 전략의 경우 센더가 메세지를 다시 보내기 위해 가지고 있어야 한다. 세번째 전략은 가장 비용이 큰 전략인데, 리시버가 메세지가 이미 처리되었는지 아닌지를 판별할 수 있어야 한다.</p>

<p><em>reliability</em> 를 위해 </p>

<ul>
<li>모든 메세지가 <em>persisted</em> 되고 (저장된다는 뜻인듯)</li>
<li><em>unique correlation ID</em> 를 지정할 수 있고</li>
<li>성공할때까지 메세지를 계속 보낼 수 있다.</li>
</ul>

<blockquote>
  <p>Reliability can only be ensured by <strong>business-level acknowledgement</strong></p>
</blockquote>

<p>근데 실제로는 리시버로부터 응답이 오기전까진 제대로 보내졌는지 알 수 없으므로 비즈니스 레벨 측면에서 신뢰성을 정의해야한다는 뜻인것 같다.</p>

<p>은행계좌 예제에 지금까지 논의한 <em>reliability</em> 를 추가하기 위해</p>

<ul>
<li>log acivities of <code>WireTransfer</code> to persistent storage</li>
<li>each transfer has a unique ID</li>
<li>add ID to <code>Withdraw</code> and <code>Deposit</code></li>
<li>store IDs of completed actions within <code>BankAccount</code></li>
</ul>

<h4 id="messageordering">Message Ordering</h4>

<p>본래 액터 모델에는 순서와 관련된 스펙이 없다고 한다. <em>akka</em> 에서는 이 부분을 수정하여 똑같은 목적지로 메세지를 보냈다면, 보낸 순서대로 메세지가 도착한다고 한다.</p>

<blockquote>
  <p>If an actor sends multiple messages to the same destination, they will not arrive out of order (this is <strong>Akka-specific</strong>)</p>
</blockquote>

<p><em>E</em> 언어에서는 더 강화된 룰이 있다고 한다. <em>akka</em> 와는 좀 다른측면에 집중하기 때문이라고 함.</p>

<h3 id="designingactorsystem">Designing Actor System</h3>

<p>액터 모델을 따르는 크롤러를 구현해보자. 웹페이지를 긁어오는 부분부터 보면</p>

<h4 id="webclient">Web Client</h4>

<pre><code class="scala">val client = new AsyncHttpClient  
def get(url: String): String = {  
  val res = client.prepareGet(rul).execute().get
  if (res.getStatusCode &lt; 400)
    res.getResponseBodyExcerpt(131072) // 128KB
  else throw BadStatus(response.getStatusCode)
}
</code></pre>

<p>근데, 긁어오는 부분이 블러킹이라 좀 그렇다. </p>

<ul>
<li>액터에서 이 코드를 사용하면 긁는동안 다른 요청에 반응을 못하고, </li>
<li>이 액터가 반응을 못하면 다른 액터로 그 영향이 전파된다. 수천개의 액터를 가지고있다면..</li>
</ul>

<pre><code class="scala">private val client = new AsyncHttpClient

def ge(url: String)(implicit exec: Executor): Future[String] = {  
  val f = client.prepareGet(url).execute();
  val p = Promis[String]()

  f.addListener(new Runnable {
    def run = {
      val res = f.get
      if (res.getStatusCode &lt; 400)
        p.success(res.getResponseBodyExcerpt(131072))
      else p.failure(BadStatus(response.getStatusCode))
    }
  }, exec)

  p.future
}
</code></pre>

<h4 id="findinglinks">Finding Links</h4>

<pre><code class="scala">val A_TAG = "(?i)&lt;a ([^&gt;]+)&gt;.+?&lt;/a&gt;".r  
val HREF_ATTR = """\s*(?i)href\s*=\s*(?:"([^"]*)"|'([^']*)'|([^'"&gt;\s]+))\s*""".r

def findLinks(body: String): Iterator[String] = {  
  for {
    anchor &lt;- A_TAG.findAllMatchIn(body)
    HREF_ATTR(dquot, quot, bare) &lt;- anchor.subgroups
  } yield if (dquot != null) dquot
  else if (quot != null) quot
  else bare
} 
</code></pre>

<p><code>&lt;a href=</code> 부분이 쌍따옴표나, 따옴표로 감싸져있거나, 아니면 그냥 링크부분이 문자열일 수 있으므로 나눠서 찾아본다.</p>

<h4 id="getteractor">Getter Actor</h4>

<pre><code class="scala">class Getter(url: String, depth: Int) extends Actor {  
  implicit val exec = 
    context.dispatcher.asInstanceOf[Executor with ExecutionContext]

  val future = WebClient.get(url)

  future.onComplete {
    case Success(body) =&gt; self ! body
    case Failure(err)  =&gt; self ! Status.Failure(err)
  }

  ...

}
</code></pre>

<p>이건 너무나 자주 나오는 패턴매칭이므로 <em>akka</em> 에서는 <code>pipeTo</code> 를 이용해 이렇게 줄일 수 있다.</p>

<pre><code class="scala">class Getter(url: String, depth: Int) extends Actor {  
  implicit val exec = 
    context.dispatcher.asInstanceOf[Executor with ExecutionContext]

  val future = WebClient.get(url)
  future.pipeTo(self)

  // or
  WebClient get url pipeTo self
  ... 
}
</code></pre>

<p>여기서 <code>get</code> 과 <code>pipeTo</code> 가 비동기로 실행되야하기 때문에 <code>Executor</code> 가 필요하다. 그리고 이 <code>dispatcher</code> 는 상당히 중요한데, 이 디스패처가 액터를 실행하고, 퓨처를 실행한다. 그리고 이 디스패처는 공유될 수 있다.</p>

<blockquote>
  <p>Actors are run by a dispatcher (potentially shared) which can also run Futures</p>
</blockquote>

<p>메세지를 받는 부분은</p>

<pre><code class="scala">class Getter(url: String, depth: Int) extends Actor {  
  ...

  def receive = {
    case body: String =&gt;
      for (link &lt;- findLinks(body))
        context.parent ! Controller.Check(link, depth)
      stop()
    case _: Status.Failure =&gt; stop()
  }

  def stop(): Unit = {
    context.parent ! Done
    context.stop(self)
  }
}
</code></pre>

<p>모든 액터는 다른 액터에 의해 만들어지기 때문에 <code>context.parent</code> 로 접근할 수 있다.</p>

<h4 id="actorbasedlogging">Actor-Based Logging</h4>

<ul>
<li>Logging includes <em>IO</em> which can block indefinitely</li>
<li><em>Akka</em>'s logging passes that task to dedicated actors</li>
</ul>

<pre><code class="scala">class Controller extends Actor with AtcorLogging {  
  var cache = Set.empty[String]
  var children = Set.empty[ActorRef]

  def receive = {
    case Check(url, depth) =&gt;
      log.debug("{} checking{}", depth, url)
      if (!cache(url) &amp;&amp; depth &gt; 0)
        children += context.actorOf(Props(new Getter(url, depth - 1)))
      cache += url
    case Getter.Done =&gt;
      children -= sender
      if (children.isEmpty) context.parent ! Result(cache)
  }
}
</code></pre>

<p>다른 쿼리를 처리하는 도중에 <code>Result(cache)</code> 가 부모에게 전송되었다고 하자. <em>mutable set</em> 이면 끔찍하다. 그러나 <em>immutable set</em> 을 사용하기 때문에 공유해도 문제 없다.</p>

<h4 id="handlingtimeouts">Handling Timeouts</h4>

<p>웹서버가 어마어마하게 늦게 응답한다면 어떻게 할까?</p>

<pre><code class="scala">class Controller extends Actor with AtcorLogging {  
  context.setReceiveTimeout(10 seconds)

  ...

  def receive = {
    case Check       ...
    case Getter.Done ...
    case ReceiveTimeout =&gt; children foreach (_ ! Getter.Abort)
  }
}

class Getter(url: String, depth: Int) extends Actor {  
  def receive = {
    ...
    case Abort =&gt; stop()
  }

  ...
}
</code></pre>

<h4 id="scheduler">Scheduler</h4>

<p><em>akka</em> 는 <em>high volume</em>, <em>short duration</em>, <em>frequent cancellation</em> 을 위한 <em>time service</em> 를 제공한다. 스케쥴러도 그 중 하나다</p>

<pre><code class="scala">trait Scheduler {  
  def scheduleOnce(delay: FiniteDuration, target: ActorRef, msg: Any)
                   (implicit ec: ExecutionContext): Cancellable
  def scheduleOnce(delay: FiniteDuration)(block: =&gt; Unit)
                   (implicit ec: ExecutionContext): Cancellable
  def scheduleOnce(delay: FiniteDuration, run: Runnable)
                   (implicit ec: ExecutionContext): Cancellable                 
}
</code></pre>

<p>태스크의 실행과 취소가 리소스를 두고 경쟁할 수 있기 때문에 취소가 호출된 후 메세지를 받는 일도 생긴다. 그러나 취소요청된 메세지는 저장되기때문에 필터링 할 수 있어 별 문제가 안된다.</p>

<p>이 스케쥴러를 이용하면 위에서 본 취소 코드를 이렇게도 작성하면...<strong>안된다</strong></p>

<pre><code class="scala">class Controller extends Actor with AtcorLogging {  
  import context.dispatcher
  var children = Set.empty[ActorRef]

  context.system.scheduler.scheduleOnce(10 seconds) {
    children foreach (_ ! Getter.Abort)
  }

  ...
}
</code></pre>

<p>스케쥴러와 액터의 컨텍스트가 다르기 때문에 동시에 <code>children</code> 을 수정하는 코드다. <strong>not thread-safe</strong> 다. 이건 컴파일러 에러도 안준다.</p>

<p>액터의 컨텍스트에 접근하려면 메세지를 보내야 한다.</p>

<pre><code class="scala">class Controller extends Actor with AtcorLogging {  
  import context.dispatcher
  var children = Set.empty[ActorRef]

  context.system.scheduler.scheduleOnce(10 seconds, self, Timeout)

  def receive {
    ...
    case Timeout =&gt; children foreach (_ ! Getter.Abort)
  }

  ...
}
</code></pre>

<p>비슷한 문제를 더 살펴보자.</p>

<pre><code class="scala">class Cache extends Actor {  
  val cache = Map.empty[String, String]
  def receive = {
    case Get(url) =&gt;
      if (cache contains url) sender ! cache(url)
      else
        WebClient get url foreach { body =&gt;
          cache += url -&gt; body // buggy
          sender ! body
        }  
  }
}
</code></pre>

<p>이것도 액터 컨텍스트 밖에서 <code>cache</code> 에 접근하고 있다. <code>get</code> 은 <code>Future</code> 를 돌려주는데, 이건 분명히 액터의 컨텍스트가 아니다. <code>cache += url -&gt; body</code> 이부분</p>

<p>이전과 마찬가지로 액터에게 메세지를 보내는 방식으로 해결할 수 있다. 명심하자 액터 내부의 변수는 액터로 메세지를 보내 변경하자.</p>

<pre><code class="scala">  val cache = Map.empty[String, String]
  def receive = {
    case Get(url) =&gt;
      if (cache contains url) sender ! cache(url)
      else
        WebClient get url map(Result(sender, url, _)) pipeTo self

     case Result(client, url, body) =&gt;
       cache += url -&gt; body
       client ! body
</code></pre>

<p>근데 이것도 문제가 있다. <code>map</code> 이 <code>Future</code> 에 의해 실행되기 때문에, <code>sender</code> 가 메세지를 보낸 사람이란걸 보장할 수가 없다.</p>

<blockquote>
  <p>Do not refer to actor state from code running asynchoronously</p>
</blockquote>

<pre><code class="scala">  val cache = Map.empty[String, String]
  def receive = {
    case Get(url) =&gt;
      if (cache contains url) sender ! cache(url)
      else
        val client = sender
        WebClient get url map(Result(client, url, _)) pipeTo self

     case Result(client, url, body) =&gt;
       cache += url -&gt; body
       client ! body
</code></pre>

<h4 id="thereceptionist">The Receptionist</h4>

<pre><code class="scala">class Receptionist extends Actor {  
  def receive = wating

  // upon Get(url) start a traversal and become running
  val wating: Receive = {
    case Get(url) =&gt; context.become(runNext(Vector(Job(sender, url)))
  }

  // upon Get(url) append that to queue and keep running
  // upon Controller.Result(links) ship that to client
  // and run next job from queue if any
  def running(queue: Vector[Job]): Receive = {
    case Controller.Result(links) =&gt;
      val job = queue.head
      job.client ! Result(job.url, links)
      context.stop(sender)
      context.become(runNext(queue.tail))
    case Get(url) =&gt;
      context.become(enqueueJob(queue, Job(sender, url)))
  }
}

case class Job(client: ActorRef, url: String)  
var reqNo = 0

def runNext(queue: Vector[Job]): Receive = {  
  reqNo += 1
  if (queue.isEmpty) wating
  else {
    val controller = context.actorOf(Props[Controller], s"c$reqNo")
    controller ! Controller.Check[queue.head.url, 2)
    running(queue)
  }
}

def enqueueJob(queue: Vector[Job], job: Job): Receive = {  
  if (queue.size &gt; 3) {
    sender ! Failed(job.url)
    running(queue)
  } else running(queue :+ job)
}
</code></pre>

<p><code>Receive</code> 가 <code>Actor</code> 의 <em>state, 상태</em> 를 나타낸다. 어떤 메세지를 받을 수 있는지 정의하면서</p>

<h4 id="main">Main</h4>

<pre><code class="scala">import akka.actor.{Actor, Props, ReceiveTimeout}  
import scala.concurrent.duration._

class Main extends Actor {  
  import Receptionist._
  import context.dispatcher

  val receptionist = context.actorOf(Props[Receptionist], "receptionist")

  receptionist ! Get("http://www.google.com")

  context.system.scheduler.scheduleOnce(10 seconds, self, ReceiveTimeout)

  def receive = {
    case Result(url, links) =&gt;
      println(links.toVector.sorted.mkString(s"Results for '$url':\n", "\n", "\n"))
    case Failed(url) =&gt;
      println(s"Failed to fetch '$url'\n")
    case ReceiveTimeout =&gt;
      context.stop(self)
  }

  override def postStop(): Unit = {
    WebClient.shutdown()
  }
}
</code></pre>

<p>전체 코드는 <a href='https://github.com/ardumont/scala-lab/tree/master/src/main/scala/concurrency/actor/crawler' >여기</a> 서 확인할 수 있다.</p>

<h4 id="summary">Summary</h4>

<p>(1) A reactive application is <strong>non-blokcing</strong> &amp; <strong>event-driven</strong> top to bottom <br />
(2) Actors are run by a dispatcher (potentially shared) which can also run Futures <br />
(3) Prefer imuutable data structures, since they can be shared <br />
(4) Do not refer to actor state from code running asynchronously <br />
(5) Prefre <code>context.become</code> for different states, with data local to the behavior</p>

<h3 id="testingactorsystem">Testing Actor System</h3>

<p>테스팅은 오직 외부의 <em>observable effects</em> 만 가능하다.</p>

<blockquote>
  <p>Tests can only verify externally observable effects</p>
</blockquote>

<p>여기 <code>Toggle</code> 이란 액터를 하나 만들어 보자.</p>

<pre><code class="scala">import akka.actor.Actor

class Toggle extends Actor {  
  // happy state
  def happy: Receive = {
    case "How are you?" =&gt;
      sender ! "happy"
      context become sad
  }

  // sad state
  def sad: Receive = {
    case "How are you?" =&gt;
      sender ! "sad"
      context become happy
  }

  // initial state: happy
  def receive = happy
}
</code></pre>

<p>이 액터를 테스트할 수 있는 유일한 방법은 메세지를 보내고, 그 응답을 확인하는 것이다. <em>akka</em> 의 테스트킷은 <code>TestProbe</code> 를 제공하는데, 일종의 <em>remote controlled actor</em> 다.</p>

<p><em>SBT</em> 파일에 이렇게 디펜던시를 추가하고</p>

<pre><code class="scala">resolvers += "Typesafe Repository" at "http://repo.typesafe.com/typesafe/releases/"

libraryDependencies ++= Seq(  
  ...
  "com.typesafe.akka" %% "akka-testkit" % "2.3.8",
  ...
)
</code></pre>

<p>아래처럼 사용할 수 있다.</p>

<pre><code class="scala">implicit val system = ActorSystem("TestSys")  
val toggle = sytem.actorOf(Props[Toggle])  
val p = TestProbe()

p.send(toggle, "How are you?")  
p.expectMsg("happy")  
p.send(toggle, "unknown")  
p.expectNoMsg(1 second)  
...
...

system.shutdown()  
</code></pre>

<p>이렇게 더 편하게 쓸 수 있다.</p>

<pre><code class="scala">new TestKit(ActorSystem("TestSys")) with ImplicitSender {  
  val toggle = system.actorOf(Props[Toggle])

  toggle ! "How are you"
  expectMsg("happy")
  ...
  ...
  system.shutdown()
}
</code></pre>

<p><code>ImplicitSender</code> 를 이용하면 테스트 시스템 내에서 자동으로 <em>sender</em> 가 <em>test actor</em> 로 지정된다.</p>

<p>동작하는 코드는 <a href='https://github.com/ardumont/scala-lab/blob/master/src/main/scala/concurrency/actor/toggle/happySad.scala' >여기</a>로</p>

<p><br/></p>

<p>일반적으로 테스트를 작성할때는 독립적인 모듈을 먼저 테스트한다. 그리고 필요한경우 가짜 데이터를 돌려주는 <em>mock</em> 등을 만든다.</p>

<p>데이터베이스에서 데이터를 가져오는 모듈을 테스트하고 싶다면 그것만 테스트하면 된다. 실제 데이터베이스에 연결 해볼 필요는 없다. </p>

<p>앞서 크롤러 같은 경우 <code>Receptionist</code> 를 테스팅하기 위해 가짜 <code>Controller</code> 를 만들 수 있다.</p>

<pre><code class="scala">class FakeController extends Actor {  
  def receive = {
    case Controller.Check(url, depth) =&gt;
      context.system.scheduler.scheduleONce(1 seconds,
                                            sender,
                                            Controller.Result(Set(url)))
  }
}
</code></pre>

<h3 id="references">References</h3>

<p>(1) <em>Reactive Programming</em> by <strong>Martin Ordersky</strong> <br />
(2) <a href='http://prabhubuzz.wordpress.com/2012/09/28/akka-really-mountains-of-concurrency/' >http://prabhubuzz.wordpress.com</a></p>]]></description><link>http://1ambda.github.io/reactive-programming-5/</link><guid isPermaLink="false">99e31196-6379-4fef-b26d-29a2e5d1bb6c</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[reactive programming]]></category><category><![CDATA[actor]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 27 Dec 2014 05:33:25 GMT</pubDate></item><item><title><![CDATA[Reactive Programming 4, Observable, Rx]]></title><description><![CDATA[<p>지난시간엔 단일 데이터에 대해 <em>latency</em> 를 지원하는 <em>Future, Promise</em> 에 대해서 알아봤다. 이번에는 컬렉션에서 <em>latency</em> 를 지원하는 방법인 <em>Observable</em> 을 배워보자.</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<h3 id="fromfuturestoobservables">From Futures to Observables</h3>

<p><code>Future</code> 의 정의를 다시 보면,</p>

<pre><code class="scala">trait Future[T] {  
  def onComplete[U](f: Try[T] =&gt; U)
  (implicit ex: ExecutionContext): Unit
}
</code></pre>

<p>여기서 중요한 부분은 콜백 <code>f</code> 를 받아 <code>Unit</code> 을 돌려준다는 것이다.</p>

<pre><code class="scala">(Try[T] =&gt; Unit) =&gt; Unit
</code></pre>

<p>이제 <code>=&gt;</code> 를 뒤집고, <code>Unit</code> 을 <code>()</code> 로 표기해서 어떤 <em>intuition</em> 을 얻어보자.</p>

<pre><code class="scala">(Try[T] =&gt; Unit) =&gt; Unit
Unit =&gt; (Unit =&gt; Try[T]) // reverse  
() =&gt; (()=&gt; Try[T])      // Unit -&gt; ()

Try[T]                   // simplify  
</code></pre>

<p>여기서 핵심은 <code>()</code> 는 사이드 이펙트를 위해 존재하므로 그 부분을 제거하면 타<code>Future[T]</code> 의 결과는 <code>Try[T]</code> 와 같다는 것이다.</p>

<blockquote>
  <p><code>Future[T]</code> and <code>Try[T]</code> are <strong>dual</strong></p>
</blockquote>

<p><em>duality</em> 란 <a href='http://en.wikipedia.org/wiki/Category_theory' >Category Theory</a> 에 의하면</p>

<blockquote>
  <p>Every statement, theorem, or definition in category theory has a dual which is essentially obtained by <strong>"reversing all the arrows"</strong>.</p>
</blockquote>

<p>처음 시작 부분에서 이런 테이블을 봤을텐데, 여기서도 <em>duality</em> 관계가 나타난다.</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<p>그리고 지난시간에 이메일을 발송하는 코드에서 <code>onComplete</code> 를 몇 번 호출하던 콜백이 받는 <code>Try[T]</code> 는 동일하다는 것을 봤다. 이것은 <code>Future[T]</code> 가 <code>Try[T]</code> 를 돌려주고, 그 값이 일정하다는 사실을 말한다.</p>

<p>이렇게 생각할수도 있다. 콜백 <code>f: Try[T] =&gt; Unit</code> 을 넘기고 <code>Try[T]</code> 를 얻기 위해 <code>asynchronous()</code> 를 사용할 수 있고, <code>Try[T]</code> 를 얻기 전까지 블럭되는 <code>synchronous</code> 를 이용할 수도 있다는 식으로</p>

<pre><code class="scala">def asynchronous(): Future[T]  
def synchronous(): Try[T]  
</code></pre>

<h3 id="iterable">Iterable</h3>

<p><code>Observable[T]</code> 를 보기전에 <em>synchronous data stream</em> 인 <code>Iterable[T]</code> 를 좀 살펴보자.</p>

<pre><code class="scala">trait Iterable[T] { def iterator(): iterator[T] }  
trait Iterator[T] { def hasNext: Boolean; def next(): T }  
</code></pre>

<p><code>while (hasNext) next()</code> 처럼 사용할 수 있다.</p>

<p>그리고 <code>Iterable[T]</code> 를 위한 <code>flatMap</code> 도 정의되어 있다. 따라서 <code>Iterable</code> 은 모나드다.</p>

<pre><code class="scala">def flatMap[B](f: A =&gt; Iterable[B]): Iterable[B]  
</code></pre>

<p>이 <code>Iterator</code> 를 이용해서 디스크에서 파일을 읽는 코드를 작성하면</p>

<pre><code class="scala">def ReadLinesFromDisk(path: String): iterator[String] = {  
  Source.fromFile(path).getLines()
}

val lines = ReadLinesFromDisk(path)

for (line &lt;- lines) {  
  ... DoWork(line) ... // latency
}
</code></pre>

<p>한 라인이 <code>100K</code> 로 어마어마하게 길다면 디스크를 읽기 전까지 기다려야할까? <code>Future</code> 처럼 비동기로 IO 연산을 수행하는 방법을 찾아보자. 이전과 좀 다른점은 지금은 컬렉션을 다루고 있다는 점이다. </p>

<p>이 문제를 해결하기 위해 컬렉션을 순회하는 <code>trait</code> 를 좀 살펴보자. 어떤 일을 해야 하는지 알아야하니까.</p>

<pre><code class="scala">trait Iterable[T] {  
  def iterator(): Iterator[T]
}

trait Iterator[T] {  
  def hasNext: Boolean
  def next(): T
}
</code></pre>

<p><code>Iterable</code>, <code>Iterator</code> 을 좀 간략화 하면, </p>

<ul>
<li><code>Iterable</code> 는 <code>()</code> 를 인자로 받아 <code>Iterator</code> 를 돌려주고</li>
<li><code>Iterator</code> 는 <code>()</code> 를 인자로 받아 <code>Try[Option[T]]</code> 를 돌려준다</li>
</ul>

<p>전체적으로 보면 <code>() =&gt; (() =&gt; Try[Option[T]])</code> 다. 사이드이펙트로 예외를 돌려주거나, <code>None</code> 일수 있거나, 아니면 정상적인 값을 얻을 수 있다는 뜻이다.</p>

<p>타입이 좀 복잡한데, 아까 <em>arrow</em> <code>=&gt;</code> 를 뒤집었던 방법을 다시 사용해서 간단히 만들어 보자. 강의에서는 <em>dualization trick</em> 이라 부른다.</p>

<p>뒤집은 후에는 <code>Try[Option[T]]</code> 를 분해해 보자. 예외를 주거나, 아무 값도 주지 않거나(끝나거나), 값을 주거나.</p>

<pre><code class="scala">() =&gt; (() =&gt; Try[Option[T]])

// reverse
(Try[Option[T]] =&gt; Unit) =&gt; Unit)

// simplify
( T         =&gt; Unit, // Value
  Throwable =&gt; Unit, // Exception
  ()        =&gt; Unit  // Nothing, Terminate
) =&gt; Unit
</code></pre>

<p>즉, 비동기로 컬렉션을 순회하기 위해서는 이런 작업을 처리해줄 무언가가 필요하다. 스칼라에서는 <code>Observable, Observer, Subscription</code> 이 그 일을 담당한다.</p>

<pre><code class="scala">trait Observable[T] {  
  def Subscribe(observer: Observer[T]): Subscription
}

trait Observer[T] {  
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
  def OnCompleted(): Unit
}

trait Subscription {  
  def unsubscribe(): Unit
}
</code></pre>

<p>즉, <code>Observable</code> 에 <code>Try[Option[T]]</code> 에 따라 할일을 지정해 놓은 <code>Observer</code> 를 세팅하고, <code>Subscription</code> 을 얻은 뒤 이후에 필요에 의해 중단해야 하면 <code>unsubscribe</code> 를 호출하는 방식이다. 이는 작업하는 대상이 컬렉션이므로 <code>Future</code> 와는 달리, 하나의 값이 아니라 무한한 값들을 얻어올 수 있기 때문.</p>

<h3 id="futurevsobservable">Future vs Observable</h3>

<p>초반에, 이 테이블을 다시 보면 <code>Iterable</code> 과 <code>Observable</code> 이 <em>dual</em> 이다.</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<p>그리고 이 테이블에 의하면, <code>Future</code> 와 <code>Observable</code> 을 비교해보면 <em>one</em> 과 <em>many</em> 가 의미하는 바를 <em>type</em> 으로 이해할 수 있다.</p>

<pre><code class="scala">Observable[T] = (Try[Option[T]] =&gt; Unit) =&gt; Unit  
Future[T]     = (Try[T]         =&gt; Unit) =&gt; Unit  
</code></pre>

<p>타입을 보면 <code>Future</code> 는 <code>Option</code> 부분이 없지만 <code>Observable</code> 은 있다. 즉 <code>Observable</code> 은 아무런 값도 없다는 사실을 의미하는 타입 <code>Option</code> 을 이용해 <em>종료시점</em> 을 알려줄 수 있기 때문에 <em>multiple values</em> 를 처리할 수 있다.</p>

<p><em>concurrency</em> 측면에선 어떨까? 타입을 살펴보면</p>

<pre><code class="scala">object Future {  
  def apply[T](body: =&gt; T)
   (implicit executor: ExecutionContext): Future[T]
}

trait Observable[T] {  
  def observeOn(scheduler: Scheduler): Observable[T]
}
</code></pre>

<p><code>Observable</code> 의 경우엔 하나의 <code>ExecutionContext</code> 가 아니라 여러개를 가져야 하기 때문에 <code>Scheduler</code> 를 이용한다. 이 부분은 나중에 더 자세히 살펴보자.</p>

<h4 id="observableexample">Observable example</h4>

<pre><code class="scala">val ticks: Observable[Long] = Observable.interval(1 seconds)  
val evens: Observable[Long] = ticks.filter(s =&gt; s % 2 == 0)  
val bufs:  Observable[Seq[Long]] = evens.buffer(2, 1)  
val s = bufs.subscribe(b =&gt; println(b))

readLine()  
s.unsubscribe  
</code></pre>

<p><code>Observable</code> 을 <em>latency</em> 를 지원하는 컬렉션으로 이해하면 쉽다. <code>interval</code>  을 이용해 간격을 지정하거나, 일반 컬렉션처럼 <code>filter</code> 도 사용할 수 있다. <code>evens.buffer</code> 는 그냥 버퍼링이라고 생각하면 된다. 버퍼 크기가 2인 것으로.</p>

<p>이런 것도 가능하다.</p>

<pre><code class="scala">val xs = Observable.range(1, 10)  
val ys = xs.map(x =&gt; x + 1)  
</code></pre>

<p><code>xs</code> 는 비동기 순회를 지원하는 컬렉션이다. <code>filter</code>, <code>map</code>, <code>flatMap</code>, <code>take</code>, <code>zip</code> 등 을 지원한다.</p>

<h3 id="flatmap">flatMap</h3>

<p><img src='https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/flatMap.png'  alt="" /></p>

<p align="center">(<a href='http://reactivex.io/' >http://reactivex.io/</a>)</p>

<p>색깔의 순서를 봐야할 필요가 있다. <code>Observable</code> 은 비동기 연산이기 때문에 순서가 좀 달라질 수 있다. 구현에도 그런 부분이 나타나 있는데 아래의 코드에서 <code>flatten</code> 이 의미하는 바는 <em>non-deterministic merge</em> 다. </p>

<pre><code class="scala">def flatMap(f: T =&gt; Observable[S]): Observable[S] = {  
  map(f).flatten()
}
</code></pre>

<p>다른 코드도 좀 보면</p>

<pre><code class="scala">val xs: Observable[Int] = Observable(3, 2, 1)

val yss: Observable[Observable[Int]] =  
  xs.map(x =&gt; Observable.Interval(x seconds).map(_ =&gt; x).take(2))

val zs: Observalble[Int] = yss.flatten()  
</code></pre>

<p><img src='https://camo.githubusercontent.com/1db5afe0637db37bf24a0476deeb4a6af5f846a1/687474703a2f2f692e696d6775722e636f6d2f5a75364f5034442e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<p>위 코드는 <code>x</code> 초 후에 <code>x</code> 2개를 뱉는 <code>Oberservable</code> 을 만든 후 <code>flatten</code> 을 사용해 껍데기를 벗긴다. <code>List(List(1, 2), List(3)).flatten</code> 하면 <code>List(1, 2, 3)</code> 이 되듯이 <code>Observable[Observable].flatten</code> 도 <code>Observable</code> 을 만든다고 생각하면 쉽다.</p>

<h3 id="merge">Merge</h3>

<p><img src='https://camo.githubusercontent.com/7bf59d06b672be32c63b8c2260e68840b408e100/687474703a2f2f692e696d6775722e636f6d2f64376e74576d462e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<p>예외나, 종료 등 어떤 이유에서든지 먼저 끝나는 <code>Observable</code> 에 의해 <code>merge</code> 가 종료된다는 점에 주의하자.</p>

<h3 id="concat">Concat</h3>

<pre><code class="scala">val xs: Observable[Int] = Observable(3, 2, 1)

val yss: Observable[Observable[Int]] =  
  xs.map(x =&gt; Observable.Interval(x seconds).map(_ =&gt; x).take(2))

val zs: Observalble[Int] = yss.concat  
</code></pre>

<p><img src='https://camo.githubusercontent.com/2a578ecf4d5c6890f82ef27a5eb5330e3a613d4c/687474703a2f2f692e696d6775722e636f6d2f4b386a5147316e2e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<p>여기서 재밌는점은 <code>yss</code> 의 첫번째 원소인 </p>

<pre><code class="scala">Observable.Interval(3 seconds).map(_ =&gt; x).take(2)  
</code></pre>

<p>가 끝나기 전까지 다른 원소들이 버퍼링 되므로 주의해야 한다는 점이다. <em>marble diagram</em> 으로 보면</p>

<p><img src='https://camo.githubusercontent.com/126a399bf6587fd5d3a5e23975b3aeb865573269/687474703a2f2f692e696d6775722e636f6d2f62334a6e564d542e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<h3 id="earthquakesexample">Earthquakes example</h3>

<pre><code class="scala">def usgs(): Observable[EarthQuake] = { ... }

class EarthQuake {  
  ...
  def magnitude: Double
  def location: GeoCoordinate
}

object Magnitude extends Enumeration {  
  def apply(magnitude: Double): Magnitude = { ... }
  type Magnitude = Value

  val Micro, Minor, Light, Moderate, Strong, Major, Great = Value
}

val major = quakes.  
  map(q =&gt; (q.location, Magnitude(q.magnitude))).
  filter { case (loc, mag) =&gt; mag =&gt; Major }

major.subscribe({ case (loc, mag) =&gt;  
  println($"Magnitude ${ msg } quake at ${ loc }")
})
</code></pre>

<p>이런식으로 사용할 수 있다. 더 실제 동작하는 코드는 <a href='https://github.com/headinthebox/CourseraCodeSamplesReactiveProgramming' >여기</a>로. 조금 복잡하다.</p>

<p>위치를 <code>GeoCoordinate</code> 로 받기 때문에, 해당 위치의 나라를 돌려준다든지 등으로 개선할 수 있다.</p>

<pre><code class="scala">def reverseGeocode(g: GeoCoordinate): Future[Country] = { ... }  
</code></pre>

<p>이 함수를 구현하면</p>

<pre><code class="scala">val withCountry: Observable[Observable[EarthQuake, Country)]] =  
  usgs().map(q =&gt; {
    val country: Future[Country] = reverseGeocode(q.location)
    Objservable(country.map(country =&gt; (quake, country)))
  })

// val merged: Observable[(EarthQuake, Country)] =
//  withCountry.flatten()
val merged: Observable[(EarthQuake, Country)] = withCountry.concat()  
</code></pre>

<p>여기서 머징하기 위해 <code>flatten</code> 이나 <code>concat</code> 을 사용할 수 있는데, 언급했듯이 어떤걸 쓰느냐에 따라 순서가 달라질 수 있다. 아래 그림은 각각 <code>flatten</code>, <code>concat</code> 을 설명한다.</p>

<p><img src='https://camo.githubusercontent.com/d33a97e9d34e395be97256e9993798e4ae24362e/687474703a2f2f692e696d6775722e636f6d2f6258665a5a30532e706e67'  alt="" /></p>

<p><img src='https://camo.githubusercontent.com/f8689dc2d0bdd4435a34c5309f54c59b39b85162/687474703a2f2f692e696d6775722e636f6d2f6a3161486e55462e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<h4 id="groupby">group by</h4>

<p><img src='https://camo.githubusercontent.com/f0c975e06586e938d62c8c6c96eac90132cbc591/687474703a2f2f692e696d6775722e636f6d2f6e36543251624b2e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<pre><code class="scala">def groupBy[K](keySelector: T =&gt; K): Observable[(K, Observable[T])]  
</code></pre>

<p>즉 <code>T</code> 를 받아 키 <code>K</code> 를 만들고, 이것에 따라 <code>Observable</code> 을 그룹짓는다. 이걸 응용하면 나라별로 지진을 취합하는 것이 가능하다.</p>

<pre><code class="scala">val byCountry: Observable[(Country, Observable[(EarthQuake, Country)]] =  
  merged.groupBy( case (q, c) =&gt; c }
</code></pre>

<p><img src='https://camo.githubusercontent.com/c5cff5ae933284de2de7ed009c3d4228ea2f1b12/687474703a2f2f692e696d6775722e636f6d2f775852325a4c592e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<p>이제 <code>runningAverage</code> 란 함수가 있다고 해 보자. <code>Observable[Double]</code> 을 받아  업데이트 후 <code>Observable[Double]</code> 을 돌려주는 함수. 그러면 <code>runningAveragePerCountry</code> 는 어떻게 구현할까?</p>

<pre><code class="scala">val byCountry: Observable[(Country, Observable[(EarthQuake, Country)]]  
def runningAverage(s: Observable[Double]): Observable[Double] =  
  { ... }
val runningAveragePerCountry: Observable[(Country, Observable[Double])] =  
  byCountry.map { case (country, cqs) =&gt; 
    (country, runningAverage(cqs.map(_._1.magnitude))
  }
</code></pre>

<h3 id="subscription">Subscription</h3>

<p>지진 예제를 다시 가져오면, 더이상 관심 없을때 <code>unsubscribe</code> 를 호출할 수 있다.</p>

<pre><code class="scala">val quakes: Observable[EarthQuake] = { ... }  
val s: Subscription = quakes.Subscribe(...)

s.unsubscribe()  
</code></pre>

<p>근데, 생각해보면 여러 곳에서 <em>subscription</em> 할 수 있다. <em>UI</em> 같은 경우 그 수가 많을 것이다. 이 경우 <em>unsubscribing</em> 이 <em>cancellation</em> 을 의미하지 않는다. 왜냐하면 다른곳에서 <em>subscribing</em> 하고 있을 수 있기 때문이다.</p>

<p>타입을 좀 보면</p>

<pre><code class="scala">trait Subscription {  
  def unsubscribe(): Unit
}

object Subscription {  
  def apply(unsubscribe: =&gt; Unit): Subscription
}

trait BooleanSubscription extends Subscription {  
  def isUnsubscribed: Boolean
}

trait CompositeSubscription extends BooleanSubscription {  
  def +=(s: Subscription): this.type
  def -=(s: Subscription): this.type
}

trait MultipleAssignmentSubscription extends BooleanSubscription {  
  def subscription: Subscription
  def subscription_=(that: Subscription): this.type
}
</code></pre>

<p>여기서 <code>CompositeSubscription</code> 은 컬렉션처럼 <code>Subscription</code> 을 추가하거나, 제거할 수 있고 <code>unsubscribe</code> 하면 나머지도 모두 취소 된다.</p>

<p><code>MultipleAssignmentSubscription</code> 은 일종의 <em>inner subscription</em> 을 위한 프록시처럼 동작한다. 세팅하고, 교체할 수 있지만, 항상 내부에는 동작하는 하나의 <code>Subscription</code> 이 있다.</p>

<pre><code class="scala">import rx.lang.scala.subscriptions._  
import rx.lang.scala.Subscription

val s = Subscription {  
  println("bye, bye")
}

s.unsubscribe()  
s.unsubscribe() // buggy  
</code></pre>

<p>이 경우 두번째 <code>unsubscribe()</code> 를 호출했을때 <code>"bye, bye"</code> 가 호출되지 않는다. 먼저 <code>unsubscribe()</code> 를 호출했기 때문이다. </p>

<p>직접 <code>Subscription</code> 을 구현할때는 다수의 스레드에서 저마다 <code>unsubscribe()</code> 를 호출할 수 있기 때문에 이 메소드는 <em>idempotent</em> 하게 구현되야 한다.</p>

<p><code>CompositeSubscription</code> 을 이미 <code>unsubscribe</code> 했을땐, 새로운 <code>Subscription</code> 을 추가한다 하더라도 자동으로 <code>unsubscribe</code> 가 호출된다.</p>

<p><code>MultiAssignmentSubscription</code> 의 경우에는 여러번 할당할 수 있으나, 단 하나의 <code>Subscription</code> 만 가리킨다. 따라서 다음 코드를 실행할 경우 <code>b.unsubscribe</code> 만 호출된다.</p>

<pre><code class="scala">val a = Subscription { println("A") }  
val b = Subscription { println("B") }  
val m = MultiAssignmentSubscription()

multi.subscription = a  
multi.subscription = b  
multi.unsubscribe  
</code></pre>

<p><code>CompositeSubscription</code> 과 마찬가지로 이미 <code>unsubscribe</code> 되었다면, 할당되는 <code>Subscription</code> 도 자동으로 <code>unsubscribe</code> 된다.</p>

<p><code>CompositeSubscription</code> 이나 <code>MultiAssignment</code> 를 연산을 공유하는 컨테이너라 볼 수 있겠는데, 그럼 여기서 내부의 것만 <code>unsubscribe</code> 하면 어떻게 될까? 당연히 외부의 <code>MultiAssignment</code> 나 <code>Composite</code> 는 알 길이 없으니 <code>isUnsubscribe</code> 는 <code>false</code> 가 된다.</p>

<h3 id="rxstream">Rx Stream</h3>

<p>자주 보게 될 타입부터 소개하면</p>

<pre><code class="scala">object Observable {  
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

trait Observable[T] {  
  def subscribe(observer: Observer[T]): Subscription
}

trait Observer[T] {  
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
  def OnCompleted(): Unit
}

trait Subscription {  
  def unsubscribe(): Unit
}
</code></pre>

<p>아무런 알림도 못받는 <code>Observable</code> 을 만드는 <code>never</code> 와, <code>onError</code> 를 호출하는 <code>apply</code> 를 구현해 보자.</p>

<pre><code class="scala">def never(): Observable[Nothing] = Observable[Nothing](observer =&gt; {  
  Subscription {}
})

def apply[T](error: Throwable): Observable[T] =  
  Observable[T](observer =&gt; {
    observer.onError(error)
    Subscription {}
  }
</code></pre>

<p>이제 이 함수들을 이용해 다양한 함수를 구현해 보자.</p>

<h4 id="startwith">startWith</h4>

<pre><code class="scala">object Observable {  
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

def switchWith(ss: T*): Observable[T] = {  
  Observer[T](observer =&gt; {
    for(s &lt;- ss) observer onNext(s)
    subscribe(observer)
  }
}
</code></pre>

<h4 id="filter">filter</h4>

<p><img src='http://reactivex.io/assets/operators/filter.png'  alt="" /></p>

<pre><code class="scala">object Observable {  
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

def filter(p: T =&gt; Boolean): Observable[T] = {  
  Observable[T](observer =&gt; {
    subscribe(
      (t: T) =&gt; { if (p(t)) observer.onNext(t) },
      (e: Throwable) =&gt; { observer.onError(e) },
      () =&gt; { observer.onCompleted() }
    )
  })
}
</code></pre>

<p><br/></p>

<h4 id="map">map</h4>

<p><img src='http://reactivex.io/assets/operators/map.png'  alt="" /></p>

<pre><code class="scala">object Observable {  
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

def map[S](f: T =&gt; S): Observable[S] = {  
  Observable[T](observer =&gt; {
    subscribe(
      (t: T) =&gt; { if (p(t)) observer.onNext(f(t)) },
      (e: Throwable) =&gt; { observer.onError(e) },
      () =&gt; { observer.onCompleted() }
    )
  })
}
</code></pre>

<p>그림을 잘 보면 <em>input stream</em> 으로 부터 값을 얻어 함수를 적용하고 <em>output stream</em> 으로 뱉는다. 구현도 마찬가지로 현재의 컨테이너인 <code>Observable</code> 로 부터 값을 얻었을때 함수를 적용하고 어떻게 넘겨줄지를 정의한다. </p>

<p><em>duality</em> 관계인 <code>Iterable</code> 의 <code>map</code> 구현을 보면 더 명확히 알 수 있다.</p>

<pre><code class="scala">def map[S](f: T =&gt; S): Iterable[S] = {  
  new Iterable[S] {
    val it = this.iterator()
    def iterator: Iterator[S] = new Iterator[S] {
      def hasNext: Boolean = { it.hasNext }
      def next(): S = { f(it.next()) }
    }
  }
}
</code></pre>

<h4 id="futuretoobservable">Future to Observable</h4>

<p><code>Future[T]</code> 를 얻어 <code>Observable[T]</code> 로 바꿔보자. <code>T</code> 를 <code>List[T]</code> 로 바꾸듯이. 그럴려면 <code>Subject</code> 를 알아야 하는데, 이건 지난시간에 배운 <code>Promise</code> 비슷한 역할을 한다.</p>

<pre><code class="scala">import scala.concurrent.ExecutionContext.Implicits.global

def race[T](left: Future[T], right: Future[T]): Future[T] = {  
  val p = Promise[T]()

  left  onComplete { p.tryComplete(_) }
  right onComplete { p.tryComplete(_) }

  p.future
}
</code></pre>

<p><code>Promise</code> 로 부터 <code>Future</code> 를 얻고, <code>Future.onComplete</code> 에 콜백을 넘기면, 완료되었을때 <code>Promise.complete</code> 에 의해 호출된다. <code>Promise</code> 는 <code>Future</code> 를 위한 대리자? 프록시쯤으로 볼 수 있다. </p>

<p><code>Observable</code> 과 <code>Subject</code> 도 비슷한 관계다. </p>

<p><img src='https://camo.githubusercontent.com/bf2c5f3f0d9cadd2b62b347d91be4f4024bd5c8d/687474703a2f2f692e696d6775722e636f6d2f4879644b49374c2e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<p>코드로 이해해 보자.</p>

<pre><code class="scala">val channel = PublishSubject[Int]()

val a = channel.subscribe(x =&gt; println("a: " + x))  
val b = channel.subscribe(x =&gt; println("b: " + x))

channel.onNext(42)  
a.unsubscribe()

channel.onNext(4711)  
channel.onComplete()

val c = channel.subscribe(x =&gt; println("c: " + x))  
channel.onNext(13)  
</code></pre>

<p><img src='https://camo.githubusercontent.com/52f18665a6534224028549d548f23833f3abab10/687474703a2f2f692e696d6775722e636f6d2f5671507a6b42372e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<p><code>Subject</code> 는 일종의 채널이라 보면 된다. 위 코드에서 흥미로운 점은 <code>onComplete</code> (<code>!</code> 로 표시) 가 호출 된 뒤에 옵저버 <code>c</code> 를 <code>Subject</code> 에 추가했음에도 <code>c</code> 도 <code>onComplete</code> 가 호출된 것을 알고 있다는 사실이다. </p>

<p><br/></p>

<pre><code class="scala">val channel = ReplaySubject[Int]()

val a = channel.subscribe(x =&gt; println("a: " + x))  
val b = channel.subscribe(x =&gt; println("b: " + x))

channel.onNext(42)  
a.unsubscribe()

channel.onNext(4711)  
channel.onComplete()

val c = channel.subscribe(x =&gt; println("c: " + x))  
channel.onNext(13)  
</code></pre>

<p><img src='https://camo.githubusercontent.com/5a105a4004a31498e930295235501c0963ae7fe0/687474703a2f2f692e696d6775722e636f6d2f577770466d34752e706e67'  alt="" /></p>

<p><code>ReplaySubject</code> 의 경우에는 <code>c</code> 에도 모든 데이터를 받는다. 이는 <code>ReplaySubject</code> 가 히스토리를 캐싱하고있기 때문이다. </p>

<p>다양한 종류의 <code>Subject</code> 를 그림으로 보면</p>

<p><img src='https://camo.githubusercontent.com/ee926edb502552b7b50a1858ae4baf601d19b26b/687474703a2f2f692e696d6775722e636f6d2f78424a5874596d2e706e67'  alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine' >https://github.com/iirvine</a>)</p>

<h4 id="convertingfuturetoobservable">Converting Future to Observable</h4>

<pre><code class="scala">object Observable {  
  def apply[T](f: Future[T]): Observable[T] = {
    val as = AsyncSubject[T]()

    f onComplete {
      case Failure(e) =&gt; { as.onError(e) }
      case Success(c) =&gt; { as.onNext(c); as.onCompleted() }
    }

    as
  }
}
</code></pre>

<p>복잡하게 생각하지 말고 그냥 <code>Promise</code> 랑 비슷한 일을 한다고 이해하면 쉽다.</p>

<h4 id="notifications">Notifications</h4>

<p>지난 시간에 <code>Future</code> 가 <code>Try</code> 를 이용하는걸 봤다. <code>Future[Try[T]</code> 처럼.  <code>Notification</code> 도 이와 비슷하다. <code>Observable[Notification[T]]</code> 처럼 사용한다.</p>

<pre><code class="scala">abstract class Try[+T]  
case class Success[T](elem: T) extends Try[T]  
case class Failure(t: Throwable) extends Try[Nothing]

abstract class Notification[+T]  
case class OnNext[T](elem: T) extends Notification[T]  
case class OnError(t: Throwable) extends Notification[Nothing]  
case object onCompleted extends Notification[Nothing]

def materialize: Observable[Notification[T]] = { ... }  
</code></pre>

<p>차이라면, <em>종료</em> 를 알려주는 <code>onCompleted</code> 가 있다는 것이다. <code>materialize</code> 는 <code>Observable[T]</code> 를 감싸 <code>Observable[Notification[T]]</code> 로 만든다.</p>

<p><img src='https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/materialize.png'  alt="" /></p>

<h4 id="blocking">Blocking</h4>

<p>권할만한 방법은 아니지만, 만약에, 만약에 블러킹이 필요하다면 이런식으로 코드를 작성할 수도 있다는 것을 지난시간에 배웠다.</p>

<pre><code class="scala">val f: Future[String] = { ... }  
val text: String = Await.result(f, 10 seconds)  
</code></pre>

<p><code>Observable</code> 도 마찬가지다.</p>

<p><img src='https://camo.githubusercontent.com/f71128934e19a648745cd6d02664cdc887b55db6/687474703a2f2f692e696d6775722e636f6d2f66683745746f692e706e67'  alt="" /></p>

<pre><code class="scala">val xs: Observable[Long] = Observable.interval(1 seconds).take(5)  
val ys: List[Long] = xs.toBlockingObservable.toList

println(ys)

// all Rx operators are non-blocking
val zs: Observable[Long] = xs.sum  
val s: Long = zs.toBlockingObservable.single  
</code></pre>

<h4 id="observabletoscalartypes">Observable to Scalar Types</h4>

<p><code>Observable</code> 내에 있는 값들을 계산하기 위해 <code>reduce</code> 를 사용할 수 있다. <code>fold</code> 와 비슷하달까</p>

<p><img src='https://camo.githubusercontent.com/c2f1c7ca45a71649a8f64c515c282835ef543b1d/687474703a2f2f692e696d6775722e636f6d2f5130636a64395a2e706e67'  alt="" /></p>

<pre><code class="scala">def reduce(f: (T, T) =&gt; T): Observable[T]  
</code></pre>

<p>재밌는 사실은 리턴타입이 원소가 <code>Observable</code> 을 돌려주기 때문에 <code>Future</code> 와 비슷하다는 것이다.</p>

<h4 id="iterabletoobservable">Iterable to Observable</h4>

<p>잘못된 구현을 먼저 보자.</p>

<pre><code class="scala">def from[T](seq: Iterable[T]): Observable[T] =  
  Observable(o =&gt; {
    seq.foreach(s =&gt; o.onNext(s)) // What if seq is infinite?
    o.onCompleted // What if seq fails?
    Subscription {}
  })
</code></pre>

<p>이 구현의 문제점은, <code>Iterable</code> 이 무한하거나, 실패하면 어떻게 처리할지 전혀 고려하지 않았다는 것이다. 게다가 빈 <code>Subscription</code> 을 돌려주기 때문에, <code>unsubscribe</code> 할 수도 없다.</p>

<p>이 문제를 풀기 위해서는 <em>scheduler</em> 가 필요하다.</p>

<h3 id="scheduler">Scheduler</h3>

<p>우선 돌아가는 코드를 만들기 전에 테스트 케이스부터 작성하자</p>

<pre><code class="scala">// factory method
object Observable {  
  def apply[T](subscribe: Observer[T] =&gt; Subscription): Observable[T]
}

def from[T](seq: Iterable[T]): Observable[T] = { ... }

// infinite seq
def nats(): Iterable[Int] = new Iterable[Int] {  
  val i = -1
  def iterator: Iterator[Int] = new Itertor[Int] {
    def hasNext: Boolean = { true }
    def next(): Int = { i += 1; i }
  }
}

val infinite: Iterable[Int] = nats()  
val subscription = from(infinite).subscribe(x =&gt; println(x))

subscription.unsubscribe()  
</code></pre>

<p>만약 <code>from</code> 이 위에서 본 것처럼 구현되어 있다면 <code>subscription.unsubscribe()</code> 에 도달하지 못한다. 따라서 <em>iteration</em> 을 진행하는 것과는 다른 컨텍스트를 도입해 <code>unsubscribe</code> 를 호출해야 한다. 그래서 스케쥴러가 필요하다. </p>

<p><code>Future</code> 에서는 <code>ExecutionContext</code> 가 있었지만, <code>Observable</code> 은 복수개의 컨텍스트를 조작해야 하므로 스케쥴러를 써야한다.</p>

<pre><code class="scala">object Future[  
  def apply[T](body: =&gt; T)
   (implicit executor: ExecutionContext): Future[T]
}

trait Observable[T] {  
  def observeOn(scheduler: Scheduler): Observable[T]
}

// Runnable == Java's Runnable
trait ExecutionContext {  
  def execute(runnable: Runnable): Unit
}

// '=&gt; Unit' == Runnable
trait Scheduler {  
  def schedule(work: =&gt; Unit) Subsciption
}

// example
val scheduler = Scheduler.newThreadScheduler  
val subscription = scheduler.schedule {  
  println("Hello World!")
}
</code></pre>

<p><code>Future</code> 는 <code>Runnable</code> 을 취소할 수 있는 방법이 없지만, <code>Scheduler</code> 는 <code>Subscription</code> 을 리턴하기 때문에 취소할 수 있다. 그러나 일단 작업이 시작되면 취소할 수 있는 방법은 없다. 아래 예제를 보자</p>

<pre><code class="scala">def from[T](seq: Iterable[T])  
    (implicit s: Scheduler): Observable[T] = {

  Observable[T](o =&gt; {
    s.schedule {
      seq.foreach(x =&gt; observer.onNext(x))
      observer.onCompleted()
    }
  }
}
</code></pre>

<p><code>onNext</code> 가 호출되기 전, 아주 잠깐동안만 작업을 취소할 수 있는 기회가 있다. 다시 말해서, 이터레이션이 통채로 스케쥴링 되기 때문에 좀 별로라는 것이다. 매 이터레이션마다 취소할 기회가 있는 <code>from</code> 을 구현하고 싶다. </p>

<p><code>scheduler</code> 의 다른 시그니쳐를 좀 보자.</p>

<pre><code class="scala">trait Scheduler {  
  def schedule(work: =&gt; Unit): Subscription

  def schedule(work: Scheduler =&gt; Subscription): Subscription

  def schedule(work: (=&gt; Unit) =&gt; Unit): Subscription
}
</code></pre>

<p>두번째 시그니쳐를 보자. <code>schedule</code> 함수가 하는 일이 <code>Scheduler</code> 를 받아 등록하고 <code>Subscription</code> 을 돌려주는 일이라면 그것 자체를 <code>work</code> 로 받고, 해당 <code>work</code> 에서 한번씩만 이터레이션 한다면 매 이터레이션에서 취소할 기회를 가질 수 있다. </p>

<p>이건 사실 세번째 시그니쳐와 동일한데 이유는 뒤에서 보겠다. </p>

<p><code>from</code> 의 새로운 구현을 보면</p>

<pre><code class="scala">def from[T](seq: Iterable[T])  
    (implicit) scheduler: Scheduler): Observable[T] = {

  Observable[T](o =&gt; {
    val it = seq.iterator()

    scheduler.schedule(self =&gt; {
      if (it.hasNext) { o.onNext(it.next()); self() }
      else { o.onCompleted() }
    }
  }
}
</code></pre>

<p><del>으사양반 이게 무슨 개소리요!</del></p>

<p>조금 난해한데, <code>it.hasNext</code> 가 있어서 다음 이터레이션으로 넘어갈 수 있으면 <code>self()</code> 를 호출해 자기 자신을 스케쥴링한다. 따라서 매 이터레이션마다 사용 가능한 <code>Subscription</code> 이 있으므로 취소할 수 있는 기회가 생긴다. </p>

<p><img src='https://camo.githubusercontent.com/216556caf19e30587d4697466b4244b33f182f76/687474703a2f2f692e696d6775722e636f6d2f78683546576a382e706e67'  alt="" /></p>

<p>물론 <code>Subscription</code> 이 갱신되는데 어떻게 하나의 레퍼런스로 그게 가능하느냐 하는 질문이 나올 수 있는데, 우리는 이미 <code>MultipleAssignmentSubscription</code> 을 배웠다. <code>schedule</code> 함수의 내부를 보자.</p>

<pre><code class="scala">def schedule(work: (=&gt; Unit) =&gt; Unit): Subscription = {  
  val subs = new MultipleAssignmentSubscription()

  schedule(scheduler =&gt; {
    def loop(): Unit = {
      subs.Subscription = scheduler.schedule {
        work { loop() }
      }
    }

    loop()
    subs
  })

  subs
}

def from[T](seq: Iterable[T])  
    (implicit) scheduler: Scheduler): Observable[T] = {

  Observable[T](o =&gt; {
    val it = seq.iterator()

    scheduler.schedule(self =&gt; {
      if (it.hasNext) { o.onNext(it.next()); self() }
      else { o.onCompleted() }
    }
  }
}
</code></pre>

<p>즉, <code>self</code> 가 바로 <code>loop</code> 다. 자기 자신을 스케쥴링하는 함수인데, 
<code>work -&gt; loop -&gt; work -&gt; loop -&gt; ...</code> 을 반복하면서 더 이터레이션할 멤버가 없거나, <code>unsubscribe</code> 하기 전까지 재귀적으로 돈다. </p>

<h4 id="schedulertoobservable">Scheduler to Observable</h4>

<p>돌려주는 값 없이 행위 그 자체만 보면, 스케쥴러 그 자체는 <code>Observable[Unit]</code> 에 대응된다. </p>

<pre><code class="scala">object Observable {  
  def apply() (implicit s: Scheduler): Observable[Unit] = {
    Observable(o =&gt; {
      s.schedule(self =&gt; {
        o.onNext(()); self
      })
    })
  }
}

implicit val s = Scheduler.NewThreadScheduler  
val ticks: Observable[Unit] = Observable()  
</code></pre>

<p>이게 실제로 어떻게 동작하나 보면</p>

<pre><code class="scala">object Observable {  
  def apply(s: Observer[T] =&gt; Subscription) = new Observable[T] {
    def subscribe(o: Observer[T]): Subscription = { Magic(s(o)) }
  }
}

val subs = Observable(o =&gt; F(o)).subscribe(observer)

// = conceptually
val subs = Magic(F(observer))  
</code></pre>

<p>여기서 <code>F</code> 나 <code>Magic</code> 는 임의의 함수라 생각하면 된다. (그런게 있나보다 하자.)</p>

<p>이걸 왜 이야기하냐 하면 <em>auto unsubscribe</em> 가 가능하기 때문이다. 스케쥴링 하는 행위를 <em>observable</em> 로 변경할 수 있다면, 스케쥴링이 불가능할때 <em>unsubscribe</em> 하도록 만드는 것이다.</p>

<p><code>F</code> 가 <code>observer.onCompleted</code> 나 <code>observer.OnError</code> 를 호출한다면, <code>Magic</code> 함수에 의해 자동으로 <code>unsubscribe</code> 가 호출된다. 이로인해 다음에 호출되는 <code>onNext</code> 는 아무런 영향도 미치지 않게 된다.</p>

<p>이럴 수 있는 이유는 <code>Observable</code> 을 생성하는 방식이 <em>Rx Contract</em> 을 만족하기 때문이다. (따라서 직접 <code>Observable, Observer</code> 를 만들지 말고 팩토리 메소드를 사용해야한다)</p>

<pre><code class="scala">(onNext)*(onCompleted + onError)?
</code></pre>

<p><code>onNext</code> 는 여러번 호출될 수 있으나 겹치지 않고, <code>onCompleted</code> 나 <code>OnError</code> 는 옵션이지만 (무한한 시퀀스가 존재하기때문) 호출된다면 둘 중 단 한개만, 단 한번 호출되야한다는 것이다. 아까 본 코드를 다시 나열해서 어떻게 그렇게 되나 살펴보자.</p>

<pre><code class="scala">object Observable {  
  def apply() (implicit s: Scheduler): Observable[Unit] = {
    Observable(o =&gt; {
      s.schedule(self =&gt; {
        o.onNext(()); self
      })
    })
  }
}

def schedule(work: (=&gt; Unit) =&gt; Unit): Subscription = {  
  val subs = new MultipleAssignmentSubscription()

  schedule(scheduler =&gt; {
    def loop(): Unit = {
      subs.Subscription = scheduler.schedule {
        work { loop() }
      }
    }

    loop()
    subs
  })

  subs
}


implicit val s = Scheduler.NewThreadScheduler  
val ticks: Observable[Unit] = Observable()

ticks.subscribe(observer)  
</code></pre>

<p>여기서 <code>ticks.subscribe(observer)</code> 를 계속 풀면</p>

<pre><code class="scala">Observable({ o =&gt; scheduler.schedule {  
  self =&gt; o.onNext(()); self()
}}).subscribe(observer)

// unfold create
scheduler.schedule {  
  self =&gt; observer.onNext(()); self()
}

// unfold schedule
val m = new MultipleAssignmentSubscription()

schedule(scheduler =&gt; {  
  def loop(): Unit = {
    m.Subscription = scheduler.schedule {
      { self =&gt; observer.onNext(()); self() }({ loop() })
    }
  }

  loop()
  m
})

// `self` is a continuation
val m = new MultipleAssignmentSubscription()

schedule(scheduler =&gt; {  
  def loop(): Unit = {
    m.Subscription = scheduler.schedule {
      { observer.onNext(()); loop() }
    }
  }

  loop()
  m
})

// extract loop
val m = new MultipleAssignmentSubscription()

def loop(): Unit = {  
    m.Subscription = scheduler.schedule {
      { observer.onNext(()); loop() }
    }
}

schedule(scheduler =&gt; {  
  loop()
  m
})

// apply loop
schedule(scheduler =&gt; {  
  m.Subscription = scheduler.schedule {
      { observer.onNext(()); loop() }
  }

  m
})
</code></pre>

<p>즉 매 스케쥴링마다, <em>subscription</em> 을 갱신하고, 작업을 진행한뒤, 자기 자신을 다시 스케쥴링 한다.</p>

<h4 id="range">Range</h4>

<p>이렇게 응용할 수 있다.</p>

<pre><code class="scala">implicit val scheduler: Scheduler = Scheduler.NewThreadScheduler

def range(start, Int, count: Int):  
  (implicit s: Scheduler) Observable[Int] = {

  Observable(o =&gt; {
    var i = 0
    Observable().subscribe(u =&gt; {
      if (i &lt; count) { o.onNext(start + i); i += 1 }
      else { o.onCompleted() }
    })
  })
}

val xs = range(1, 10)  
    xs.subscribe(x =&gt; println(x))
    println("range out")
</code></pre>

<p>즉 <code>Observable()</code> 은 일종의 무한히 반복되는 스케쥴러고 여기에 액션을 추가해 원하는 작업을 해낼 수 있다. 그리고 작업이 완료되면 자동으로 <em>unsubscribe</em> 를 수행한다. 이제 무한히 긴 스트림을 <code>Observable</code> 로도 다룰 수 있게 되었다.</p>

<h3 id="references">References</h3>

<p>(1) <em>Reactive Programming</em> by <strong>Martin Ordersky</strong> <br />
(2) <a href='http://reactivex.io/' >http://reactivex.io/</a> <br />
(3) <a href='https://github.com/iirvine/principles-of-reactive-programming/blob/master/notes/week-4/002-basic-combinators-on-observable-collections.md' >https://github.com/iirvine</a>  </p>]]></description><link>http://1ambda.github.io/reactive-programming-4/</link><guid isPermaLink="false">d34db484-100f-49c7-b55a-670970d19b33</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[observable]]></category><category><![CDATA[rx]]></category><category><![CDATA[scheduler]]></category><category><![CDATA[subscription]]></category><category><![CDATA[subject]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 26 Dec 2014 09:58:19 GMT</pubDate></item><item><title><![CDATA[Process Mining, Week5]]></title><description><![CDATA[<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-3-728.jpg?cb=1305062373'  alt="" /></p>

<p>지난 4주간 배운바를 간단히 정리해보면</p>

<ul>
<li>첫 2주는 <em>model discovery</em></li>
<li>지난 2주는 <em>conformance checking</em> </li>
</ul>

<p>이 것들은 <em>control flow</em> 에 관련된 것들이었다. 이제는 기본적인 <em>event log</em> 의 데이터 뿐만 아니라 <em>time, resource, data</em> 등을 이용하면서 <em>model enhancement</em> 를 할 수 있는 기법들을 배워보자.</p>

<p>앞으로 이야기 할 내용은</p>

<ul>
<li>mining decision points</li>
<li>mining bottlenecks</li>
<li>mining social networks</li>
<li>comparative process mining</li>
<li>operational support: detect, predict, recommend</li>
</ul>

<h3 id="miningdecisionpoints">Mining Decision Points</h3>

<p><em>model enhancement</em> 은 <em>conformance checking</em> 과는 다르게, 모델을 더 나은 방향으로 <strong>변형</strong>하는 것을 목표로 한다.</p>

<ul>
<li><strong>extend:</strong> adding additional perspectives to the model using event data</li>
<li><strong>repair:</strong> improving the quality of the model using event data</li>
</ul>

<p>먼저 <em>extend</em> 에 대해 이야기 해 보자. <em>decision point</em> 를 마이닝 할 건데, 인풋으로 </p>

<ul>
<li><em>event log</em></li>
<li><em>process model</em></li>
</ul>

<p>이 필요하다. 그리고 로그와 모델이 <strong>aligned</strong> 되어 있다는 가정하에 마이닝을 시작한다.</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-33-728.jpg?cb=1305062373'  alt="" /></p>

<p><em>decision tree</em> 에서 했던것 처럼 <em>predictor variable</em> 을 이용해 <em>response variable</em> 인 <em>transition</em> 을 선택할 수 있다. 이 때 <em>predictor variable</em> 은 <em>event log</em> 에 있는 <em>attribute</em> 다. 예를 들어</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-35-728.jpg?cb=1305062373'  alt="" /></p>

<p>여기서 우측 하단에 <em>inclusive OR</em> 이 있는데, 하나만 택하거나 둘 모두 택할 수 있는 <em>place</em> 다. 이 것도 마찬가지로 <em>decision tree</em> 를 만들듯이 생성할 수 있다. 슬라이드에서는 <code>x, y</code> 로의 두 <em>guard</em> 를 만들었지만 둘다 택 할 수 있는 경우가 있다. 예를 들어 <code>amount &lt; 500, type = silver</code> 면 <code>y, z</code> 모두를 택한다.</p>

<p><em>event log</em> 에 있는 정보 이외에도, <em>decision point</em> 를 마이닝 하기 위해 <em>predictor variable</em> 로 <em>last event</em> 나 <em>previous event</em> 를 사용할 수 있다.</p>

<p>이외에도 <em>predictor variable</em> 는 프로세스 인스턴스의 <em>context</em> 에 근거해서 다양한 값일 수 있는데</p>

<ul>
<li>number of cases running</li>
<li>number of resources present</li>
<li>workload of reousrce</li>
<li>day of the week 등</li>
</ul>

<p>한 가지 주의할점은 더 많은 변수, 더 많은 조합들이 있을수록 데이터가 희박해지기 때문에 <em>overfitting</em> 할 수 있다는 점이다. </p>

<p>이벤트 로그의 속성을 이용해 만든 <em>decision tree</em> 로, 모델에 <em>guard</em> 를 추가할 수 있다. 하지만, 이 가드가 <em>prescriptive</em> 한 것은 아니다. 오히려 <em>descriptive</em> 에 가깝다.</p>

<blockquote>
  <p>The guard discovered are describing what has happend rather than what should have happended</p>
</blockquote>

<h3 id="miningbottlenecks">Mining Bottlenecks</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-29-728.jpg?cb=1305062373'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-30-728.jpg?cb=1305062373'  alt="" /></p>

<p>위 로그를 돌려보면, 이와 같은 <em>duration</em> 같은 정보를 얻을 수 있다.</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-31-728.jpg?cb=1305062373'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-32-728.jpg?cb=1305062373'  alt="" /></p>

<p>이런식으로 볼 수도 있다.</p>

<h3 id="miningsocialnetworks">Mining Social Networks</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-18-728.jpg?cb=1305062373'  alt="" /></p>

<p>잘 보면 이벤트로그를 <em>arrtibute</em> <code>name</code> 과 연관 지었다. </p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-19-728.jpg?cb=1305062373'  alt="" /></p>

<p>이 로그를 이용하면 누가 무엇을 얼마나 실행했는지 파악할 수 있고, 이를 이용해서 그래프를 그릴 수 있다. 한 가지 생각해 볼 점은 노드가 얼마나 <strong>중요한가</strong> 는 정의에 따라 다를 수 있다는 것이다. <em>closeness</em>, <em>out degree</em> 등등.</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-21-728.jpg?cb=1305062373'  alt="" /></p>

<p>이건 누구로 부터 누구로 일이 전달되었는가를 매트릭스로 표현한 것이다. 이걸 이용하면</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-22-728.jpg?cb=1305062373'  alt="" /></p>

<p>이름이 아니라 다른 <em>attribute</em> 인 <em>role</em> 을 이용하면</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-23-728.jpg?cb=1305062373'  alt="" /></p>

<p>소셜 네트워크 마이닝을 위한 기법을 정리하면</p>

<ul>
<li><strong>Resource-activity matrix</strong> 로 누가 무엇을 하는지</li>
<li><strong>Handover of work matrix</strong> 로 일이 어떻게 전달되는지</li>
</ul>

<p>를 파악할 수 있고, 이를 이용해 그래프를 만들 수 있다. 물론 이 외에도 다양한 방법들이 있다.</p>

<h3 id="organizationalmining">Organizational Mining</h3>

<p>클러스터링과 비슷하다고 보면 된다. 이벤트 로그를 기반으로 몇개의 집단으로 묶는 것이다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-24-728.jpg?cb=1305062373'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-25-728.jpg?cb=1305062373'  alt="" /></p>

<p><br/></p>

<p>위의 예에서는 <em>resource</em> 기반으로 묶었지만 <em>case</em> 로 묶어 <em>process variants</em> 를 확인할 수도 있다.</p>

<p>그리고 위에서 발견한 <em>organizational perspective</em> 를 모델에 적용하면 이런 재미난 그림을 얻을 수 있다. 누가 어떤일을 하는지를 넘어, 어떤 집단이 어떤 일을 주로 하는지를 파악할 수 있는 것이다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-26-728.jpg?cb=1305062373'  alt="" /></p>

<p><br/></p>

<p>프로세스 마이닝을 실제 로그에 적용해 보면 스트레스 대비 일의 퍼포먼스를 설명하는 [<em>Yerkes-Dodson law</em>] 도 볼 수 있다고 한다.</p>

<p><img src='http://sourcesofinsight.com/wp-content/uploads/2008/09/yerkes-dodson-human-performance-curve.gif'  alt="" /></p>

<p align="center">(<a href='http://sourcesofinsight.com/' >http://sourcesofinsight.com/</a>)</p>

<p>프로세스 마이닝은 사회과학쪽으로도 유용할 것 같다. <del>근데 이 그래프는 너무 테일러리즘ㅠ</del></p>

<h3 id="conbiningdifferentperspectives">Conbining Different Perspectives</h3>

<p>이 전 까지 배웠던 다양한 <em>perspectives</em> 들</p>

<ul>
<li>data perspective</li>
<li>resource perspective</li>
<li>time perspective</li>
<li>control-flow perspective</li>
</ul>

<p>이런 하나의 모델로 조합해 보자.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-37-728.jpg?cb=1305062373'  alt="" /></p>

<p><br/></p>

<p><em>control flow</em>, 즉 모델에 </p>

<ul>
<li><em>data perspective</em> 를 추가하면 <em>guard</em> 를 얻을 수 있고 </li>
<li><em>time perspective</em> 는 <em>wating time</em>, <em>service time</em> 을 확인하는데 도움을 준다</li>
<li><em>resource perspetive</em> 는 모델을 <em>role</em>, <em>individual</em> 관점에서 이해하는데 도움을 준다.</li>
</ul>

<p>이 조합된 모델에 <em>limitation</em> 이 있다는 것, 그리고 이 모든 것은 <em>descriptive</em>(<strong>as is</strong>) 하다는 것을 명심하자.</p>

<p>다양한 관점이 적용된 모델을 이런 곳에 활용할 수 있다.</p>

<ul>
<li><em>diagnosis</em></li>
<li><em>re-engineering</em></li>
<li>예측이나 추천같은 <em>operational support</em> </li>
<li><strong>What if</strong> 를 다루는 <em>simulation</em> </li>
</ul>

<h3 id="comparativeprocessminingusingprocesscubes">Comparative Process Mining Using Process Cubes</h3>

<p><em>event log</em> 에는 다양한 <em>attribute</em> 를 가지고 있다. 이것들을 서로 비교해 가면서 더 좋은 프로세스 마이닝 모델을 선택할 수 있다. 즉, 다양한 조합의 액티비티, 케이스, 리소스 등을 선택해 가면서 가장 적합한 모델을 찾아내는 것이다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter10toolsupport-121219213613-phpapp01/95/process-mining-chapter10toolsupport-4-638.jpg?cb=1355974631'  alt="" /></p>

<p>이 큐브의 각 축은 차원을 나타내고, 각 셀은 어떤 특정 패턴의 이벤트 로그를 나타낸다 볼 수 있다.</p>

<p>이렇게 프로세스 큐브를 사용하면 다차원 분석이 가능하다. <em>data ware house</em> 나 <em>OLAP</em> 도 비슷한 일을 하긴 하는데, 프로세스 마이닝과의 큰 차이점이 하나 있다.</p>

<blockquote>
  <p>Related, but often data is aggregated it useless for process mining(events are lost)</p>
</blockquote>

<h3 id="refinedprocessminingframework">Refined Process Mining Framework</h3>

<p>전체적인 큰 그림은 아래와 같다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter09operationalsupport-110510153302-phpapp02/95/process-mining-chapter-9-operational-support-4-728.jpg?cb=1305062304'  alt="" /></p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter09operationalsupport-110510153302-phpapp02/95/process-mining-chapter-9-operational-support-5-728.jpg?cb=1305062304'  alt="" /></p>

<p>꼭대기부터 차근차근 보자. 여기서 <em>provenance</em> 란 수집하는 이벤트 로그가 신뢰성이 있어야 한다는 것을 의미한다. 그리고 이 이벤트 로그는 두 가지로 나뉘는데</p>

<ul>
<li><p><strong>Post mortem event data:</strong> refer to information about cases that have completed. i.e., these can be used for process improvement and auditing but not for influencing the cases they refer to</p></li>
<li><p><strong>Pre mortem event data:</strong> If a case is still running, <strong>alive</strong>, then it may be possible that information in the event log about this case <strong>can be exploited</strong> to ensure the correct or efficient handling of this case</p></li>
</ul>

<p>즉 <em>pre mortem</em> 은 현재 진행중인 것을 말한다. <del>와이리 복잡하게 설명하시뮤ㅠ</del>  예를 들어 <em>student-related event data</em> 에서 </p>

<blockquote>
  <p><strong>post mortem:</strong> Understanding where and why students drop out or deviate. Should the curriculum be redesigned? What are the bottlenecks?</p>
  
  <p><strong>pre mortem:</strong> What advice can we give a particular student that is likely do drop out? How to signal the lecturer that the exam is likely to be a <em>massacre</em> due to inactivity of students?</p>
</blockquote>

<p><br/></p>

<h4 id="dejurevsdefacto">De Jure vs De Facto</h4>

<p>큰 그림에서 밑 부분을 보면 모델에도 두 종류가 있다.</p>

<p><strong>de jure model</strong> 은 <em>normative</em> 즉 <strong>되어야 하는 것</strong> 을 설명하는 것이고, <strong>de facto model</strong> 은 <em>descriptive</em>, 즉 <strong>실제로 행해지는 것</strong> 을 설명한다.</p>

<h4 id="cartography">Cartography</h4>

<p><img src='http://image.slidesharecdn.com/processminingchapter09operationalsupport-110510153302-phpapp02/95/process-mining-chapter-9-operational-support-8-728.jpg?cb=1305062304'  alt="" /></p>

<p>이벤트 로그를 이용해서 모델을 발견하고, 개선하고, 진단하는 과정을 말한다</p>

<h4 id="auditing">Auditing</h4>

<p><img src='http://image.slidesharecdn.com/processminingchapter09operationalsupport-110510153302-phpapp02/95/process-mining-chapter-9-operational-support-9-728.jpg?cb=1305062304'  alt="" /></p>

<ul>
<li><strong>detect:</strong> <em>de jure model</em> 과 <em>pre mortem</em> 을 비교해 <em>violation</em> 이 없는지 확인한다.</li>
<li><strong>check:</strong> <em>detect</em> 에서 찾은 것을 수량화하고, 어떤 <em>deviation</em> 인가 확인한다.</li>
<li><strong>compare:</strong> <em>defacto model</em> 과 비교해서 실제에서 어떤 <em>deviation</em> 이 있는가 본다. </li>
<li><strong>promote:</strong> 위 정보를 토대로 모델을 개선한다.</li>
</ul>

<h4 id="navigation">Navigation</h4>

<p><img src='http://image.slidesharecdn.com/processminingchapter09operationalsupport-110510153302-phpapp02/95/process-mining-chapter-9-operational-support-10-728.jpg?cb=1305062304'  alt="" /></p>

<p>이 단계에서는 런타임에 <em>explore</em> 할 수도 있고, <em>prediction</em> 나 <em>recommendation</em> 도 가능하다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://issuu.com/wmpvanderaalst/docs/procminbook?e=14081202/9829483' >Book: Process Mining</a> <br />
(2) <a href='http://www.slideshare.net/wvdaalst/process-mining-chapter08miningadditionalperspectives' >Slide</a> <br />
(3) <strong>Process Mining: Data science in Action</strong> by Wil van der Aalst <br />
(4) <a href='http://1ambda.github.io/www.processmining.org' >www.processmining.org</a> <br />
(5) <a href='http://pais.hse.ru/en/' >http://pais.hse.ru/en/</a> <br />
(6) <a href='http://sourcesofinsight.com/yerkes-dodson-human-performance-curve/' >http://sourcesofinsight.com/</a></p>]]></description><link>http://1ambda.github.io/process-mining-week5/</link><guid isPermaLink="false">0e6897a3-6487-4810-9b0c-3c555faba7d7</guid><category><![CDATA[coursera]]></category><category><![CDATA[process mining]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 24 Dec 2014 03:41:31 GMT</pubDate></item><item><title><![CDATA[Reactive Programming 3, Futures, Promises]]></title><description><![CDATA[<p>이번시간엔 <em>Try</em>, <em>Future</em>, <em>Awaitable</em>, <em>Async</em>, <em>Promise</em> 에 대해 알아본다. <del>모나드가 삶을 윤택하게 하리라</del></p>

<h3 id="monadsandeffects">Monads and Effects</h3>

<p>프로그래밍에서 4가지 본질적 <em>effects</em> 는</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<p><em>asynchoronous computation</em> 을 살펴보기전에 <em>synchronous</em> 부터 살펴볼건데 간단한 어드벤쳐 게임으로 시작하자.</p>

<pre><code class="scala">trait Adventure {  
  def collectCoins(): List[Coin]
  def buyTreasure(coins: List[Coin]): Treasure
}

val adventu  
re = Adventrue()  
val coins = adventure.collectCoins()  
val treasure = adventure.buyTreasure(coins)  
</code></pre>

<p>여기서 <code>collecCoins, buyTreasure</code> 는 구현에 따라 실패할 수도 있다. 예를 들어</p>

<pre><code class="scala">def collectCoins(): List[Coin] = {  
  if (eatenByMonster(this)) throw new GameOverException("Ooops")
  List(Silver, Silver, Gold)
}
def buyTreasure(coins: List[Coin]): Treasure = {  
  if (coins.sumBy(_.value) &lt; treasureCost)
    throw new GameOverException("Nice try!")
  Diamond
}
</code></pre>

<p>그런데, 타입상으로는 <code>collectCoins, buyTreasure</code> 는 함수가 실패할 것이라는 어떠한 정보도 주지 않는다. <code>Try</code> 를 이용해 함수가 예외를 던질수도 있다는 것을 타입에 표시하자.</p>

<h4 id="try">Try</h4>

<p>아래는 <code>Try</code> 의 정의다.</p>

<pre><code class="scala">abstract class Try[T]  
case class Success[T](elem: T) extends Try[T]  
case class Failure[T](t: Throwable) extends Try[Nothing]  
</code></pre>

<p>이걸 게임 함수의 리턴값에 적용하면</p>

<pre><code class="scala">import scala.util.{Try, Success, Failure}

def collectCoins(): Try[List[Coin]] = {  
  if (eatenByMonster(this)) throw new GameOverException("Ooops")
  List(Silver, Silver, Gold)
}
def buyTreasure(coins: List[Coin]): Try[Treasure] = {  
  if (coins.sumBy(_.value) &lt; treasureCost)
    throw new GameOverException("Nice try!")
  Diamond
}

val adventure = Adventrue()  
val coins: Try[List[Coin]] = adventure.collectCoins()  
val treasure = coins match {  
  case Success(cs) =&gt; adventure.buyTreasure(cs)
  case failure @ Failure(t) =&gt; failure
}
</code></pre>

<p>좀 귀찮다. 많이 귀찮다. <em>higher order function</em> 의 은혜를 받아 삶을 좀 윤택하게 해 보자.</p>

<pre><code class="scala">def flatMap[S](f: T =&gt; Try[S]): Try[S]

def flatten[U &lt;: Try[T]]: TRy[U]

def map[S](f: T =&gt; S): Try[T]

def filter(p: T =&gt; Boolean): Try[T]

def recoverWith(f: PartialFunction[Throwable, Try[T]]): Try[T]  
</code></pre>

<p>여기서 <code>flatMap</code> 을 이용하면 코드가 상당히 이뻐질 것 같다.</p>

<p>사실 비밀을 하나 공개하자면, <code>Try[T]</code> 는 모나드다. 그 중에서 <em>exception</em> 을 다루는 모나드.</p>

<p><code>Try</code> 모나드를 이용하면 <em>exception</em> 부분(<code>Try[T]</code>)은 알아서 다루어 주고, 우리가 다뤄야 할 <code>T</code> 부분에 집중하게 해준다.</p>

<p><code>flatMap</code> 이 코드를 어떻게 바꾸는가 한번 보자.</p>

<pre><code class="scala">val treasure: Try[Treasure] =  
  adventure.collectCoins().flatMap(coins =&gt; {
    adventure.buyTreasure(coins)
  }
</code></pre>

<p>리턴타입은 <code>Try[Treasure]</code> 인데 <code>Try</code> 패턴매칭이 사라졌다? 그게 바로 <code>flatMap</code> 이 해주는 일이다. 타입을 다시 보자.</p>

<pre><code class="scala ">def flatMap[S](f: T =&gt; Try[S]): Try[S]  
</code></pre>

<p><code>T</code> 를 받아 <code>Try[S]</code> 를 돌려줄 함수만 넣어주면, 실제 <code>T</code> 를 이 함수에 넣기 위해 해야할 패턴매칭은 알아서 해준다.</p>

<p>그리고 지난 <a href='http://1ambda.github.io/reactive-programming-1/' >1강</a> 에서 모나드속에 있는 타입을 빼기 위해 <em>for expression</em> 을 이용했었다. 마찬가지로 <code>Try</code> 도 가능하다. <code>flatMap</code> 보다 더 이뻐진다.</p>

<pre><code class="scala">val treasure: Try[Treasure] = for {  
  coins &lt;- adventure.collectCoins()
  treasure &lt;- adventure.buyTreasure(coins)
} yield treasure
</code></pre>

<p>우측에서 <code>Try[T]</code> 를 리턴하고, <code>for</code> 가 알아서 <code>Try</code> 를 제거하고 좌측에 <code>T</code> 를 돌려준다.</p>

<p><code>Try</code> 를 다루기 위한 <em>higher order function</em> 이 내부적으로 어떻게 돌아가는지 한번 살펴보자.</p>

<pre><code class="scala">def map[S](f: T =&gt; S): Try[S] = this match {  
  case Succes(value) =&gt; Try(f(Value))
  case failure @ Failure(t) =&gt; failure
}

def flatMap[S](f: T =&gt; Try[S]): Try[S] = this match {  
  case Success(value) =&gt; try { f(value) } catch { cast t =&gt; Failure(t) }
  case failure @ Failure(t) =&gt; failure
}

object Try {  
  def apply[T](r: =&gt; T): Try[T] = {
    try { Success(r) }
    catch { case t =&gt; Failure(t) }
  }
}
</code></pre>

<p><code>flatMap</code> 내부에서 패턴매칭 및 예외 처리를 해준다. </p>

<h3 id="latencyasaneffect">Latency as an Effect</h3>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<p>지금까지 <code>T/Try[T]</code> 에 대해서 봤다. 이번엔 <em>asynchronous</em> 로 옮겨가 <code>Future[T]</code> 를 한번 볼건데, 간단한 네트워크 프로그램을 모델링 하면서 배워보자.</p>

<pre><code class="scala">trait Socket {  
  def readFromMemory(): Array[Byte]
  def sendToEurope(packet: Array[Byte]): Array[Byte]
}

val socket = Socket()  
val packet = socket.readFromMemory()  
val confirmation = socket.sendToEurope(package)  
</code></pre>

<p>이 코드도 이전의 어드벤쳐 게임처럼 실행중에 어떤일이 발생할지 모른다. 예외가 발생하지 않았을때만 정상적으로 실행된다. 게다가 <code>readFromMemory</code>, <code>sendToEurope</code> 동안 함수가 블럭되면 프로그램은 멈춰있다. (<em>heavy effect</em>)</p>

<p>이걸 해결하는게 <em>Future</em> 모나드다. 이 모나드는 <em>exception</em> 과 <em>latency</em> 를 다룬다. <code>Future[T]</code> 의 정의는</p>

<pre><code class="sala">import scala.concurrent._  
import scala.concurrent._ExecutionContext.Implicits.global

trait Future[T] {  
  def onComplete(callback: Try[T] =&gt; Unit)
     (implicit excutor: ExecutionContext): Unit
}
</code></pre>

<p><code>Try[T]</code> 를 받는 콜백을 인자로 필요로 하는 <code>onComplete</code> 메소드가 있다. 아랫 부분에 <code>ExecutionContext</code> 는 백그라운드에서 다른 스레드로 돌리기 위해 사용하고, <code>implicit</code> 는 이런 디테일을 숨기기 위함이다.</p>

<p><em>Future</em> 는 다른 버전으로 작성될 수도 있는데,</p>

<pre><code class="scala">trait Future[T] {  
  def onComplete(success: T =&gt; Unit, 
                 failed Throwale =&gt; Unit): Unit

  def onComplete(callback: Observer[T]): Unit
}

trait Observer[T] {  
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
}
</code></pre>

<p>이건 위 버전에서의 <em>callback</em> 을 좀 세분화 한것이다. 어차피 콜백이 <code>Try[T]</code> 를 받기 때문에 내부에서 <em>case</em> 로 분리해야 하는데, 미리 로직을 분리해서 각각의 경우에 대해 넘겨주는 것이다.</p>

<p>아니면 그 아래 <code>onComplete</code> 정의처럼 <code>Observer</code> 로 감싸서 줄 수 있다. 이것도 마찬가지로 성공했을때의, 실패했을때의 콜백이다.</p>

<p>이제 처음의 소켓 프로그램으로 돌아와서 <em>Future</em> 를 적용하면</p>

<pre><code class="scala">trait Future[T] {  
  def onComplete(callback: Try[T] =&gt; Unit)
     (implicit executor: ExecutionContext): Unit
}

trait Socket {  
  def readFromMemory(): Future[Array[Byte]]
  def sendToEurope(package: ArrayByte]): Future[Array[Byte]]
}
</code></pre>

<p>이제 <code>readFromMemory(), sendToEurope()</code> 의 함수 호출이 긴 시간이 걸릴수 있겠구나 하고 <code>Future</code> 가 리턴타입에 있음을 보고 알 수 있다.</p>

<p><em>future</em> 는 참 좋은건데, 이걸 사용하면 아까 실행 코드는</p>

<pre><code class="scala">// before
val socket = Socket()  
val packet = socket.readFromMemory()  
val confirmation = socket.sendToEurope(package)

// after
val socket = Socket()  
val packet: Future[Array[Byte]] = socket.readFromMemory()

// can't compile
val confirmation: Future[Array[Byte]] =  
  packet onComplete {
    case Success(p) =&gt; socket.sendToEurope(p)
    case Failure(t) =&gt; ...
  }
</code></pre>

<p>잘 보면 <code>onComplete</code> 의 리턴타입은 <code>Unit</code> 이기 때문에 <code>confirmation</code> 은 <code>Future[Array[Byte]]</code> 가 될 수 없다.</p>

<p>한 가지 방법은 <code>confirmation</code> 을 내부에 넣는건데,    그러면 나머지 밑 부분 코드도 모두 <code>Success</code> 내부에 작성해야 한다. <del>자바스크립트 콜백헬</del></p>

<pre><code class="scala">// can't compile
  packet onComplete {
    case Success(p) =&gt; 
      val confirmation = socket.sendToEurope(p)
      ...
      ...
      // callback hell
      ...
    case Failure(t) =&gt; ...
  }
</code></pre>

<p>이 문제를 해결하기 위해 <em>future</em> 를 만들 수 있다. <code>Future</code> 의 <em>companion object</em> 정의를 보면</p>

<pre><code class="scala">object Future {  
  def apply(body =&gt; T)
     (implicit context: ExecutionContext): Future[T]
}
</code></pre>

<p>예제를 보면</p>

<pre><code class="scala">import scala.concurrent.ExecutionContext.Implicit.global  
import akka.serializer._

val memory = Queue[EmailMessage](  
  EmailMessage(from = "Erik",   to = "Roland")
  EmailMessage(from = "Martin", to = "Erik")
  EmailMessage(from = "Roland", to = "Martin"))

def readFromMemory(): Future[Array[Byte]] = Future {  
  val email = queue.dequeue()
  val serializer = serialization.findSerializationFor(email)
  serializer.toBinary(email)
}

val packet: Future[Array[Byte]] = socket.readFromMemory()

packet onSuccess {  
  case bs =&gt; socket.sendToEurope(p)
}

packet onSuccess {  
  case bs =&gt; socket.sendToEurope(p)
}
</code></pre>

<p>이렇게 사용할 수 있다. 이 코드가 모두 실행되면, 이메일 큐에는 두개의 이메일이 남는다. <strong>하나가 아니다!!</strong> <code>Future</code> 는 <strong>미래에 돌려줄 결과</strong>를 가지고 있다고 보면 되는데, 하나의 결과에 대해 두개의 콜백을 호출해도 하나의 결과, 즉 이메일 하나만 뽑아먹었다는 사실은 변하지 않는다.</p>

<h3 id="combinatorsonfutures">Combinators on Futures</h3>

<p>이제 <em>future</em> 가 무슨일을 하는지 알았으면, 이걸 어떻게 모나드스럽게 사용할지 알아보자. 단골손님 <code>flatMap</code> 과 그 친구들이 등장한다.</p>

<pre><code class="scala">trait Awaitable[T] extends AnyRef {  
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}

trait Future[T] extends Awaitable[T] {  
  def filter(p: T =&gt; Boolean): Future[T]
  def flatMap[S](f: T =&gt; Future[S]): Future[S]
  def map[S](f: T =&gt; S): Future[S]
  def recoverWith(f: PartialFunction[Throwable, Future[T]]): Future[T]
}

objec Future {  
  def apply[T](body: =&gt; T): Future[T]
}
</code></pre>

<p><code>flatMap</code> 님을 이용해서 코드를 작성하자.</p>

<pre><code class="scala">val socket = Socket()  
val packet: Future[Array[Byte]] = socket.readFromMemor()  
val confirmation: Future[ArrayByte]] =  
  packet.flatMap(p =&gt; {
    socket.sendToEurope(p)
  }
</code></pre>

<p><code>flatMap</code> 의 정의를 보면 알겠지만, 함수 <code>f: T =&gt; Future[S]</code> 만 제공하면 앞의 <code>Future</code> 를 껍질을 벗겨, <code>T</code> 로 넣어준다. 근데 여기서 재밌는 사실은, <code>flatMap</code> 의 리턴 타입이 <code>Future[S]</code> 기 때문에 <code>confirmation</code> 도 같은 타입이 된다.</p>

<p>즉, <code>flatMap</code> 을 이용하면 모나드를 체이닝할 수 있다. 다른 예제도 좀 보자.</p>

<pre><code class="scala">import scala.concurrent.ExecutionContext.Implicits.global  
import scala.imaginary.Http._

object Http {  
  def apply(url: URL, req: Request): Future[Response] = 
  { .. runs the http request asynchronously }
}

// buggy
def sendToEurope(packet: Array[Byte]): Future[Array[Byte]] =  
  Http(URL("mail.server.eu"), Request(packet))
    .filter(response =&gt; response.isOK)
    .map(response =&gt; response.toByteArray)
</code></pre>

<p>마지막 부분의 코드를 다양하게 활용해 보자.</p>

<pre><code class="scala">def sendTo(url: URL, packet: Array[Byte]): Future[Array[Byte]] =  
  Http(URL("mail.server.eu"), Request(packet))
    .filter(response =&gt; response.isOK)
    .map(response =&gt; response.toByteArray)

def sendToAndBackup(packet: Array[Byte]):  
  Future[(Array[Byte], Array[Byte])] = {
    val europeConfirm = sendTo(mailServer.europe, packet)
    val usaConfirm    = sendTo(mailServer.usa, packet)
    europeConfirm.zip(usaConfirm)
  }
</code></pre>

<p>는 정상적인 코드가 아니다. 유럽이나 미국 둘중 하나라도 실패하면, 전체가 실패한다. 다행히도 스칼라 디자이너가 이런 문제를 해결하기 위한 함수들 <code>recover, recoverWith</code> 를 준비 해 놓았다.</p>

<pre><code class="scala">def recover(f: PartialFunction[Throwable, T]): Future[T]  
def recoverWIth(f: PartialFunction[Throwable, Future[T]): Future[T]  
</code></pre>

<p>타입을 잘보면 예외를 검사해서 다시 <code>Future[T]</code> 를 던지는 함수들이다. 특히 <code>recoverWith</code> 는 또 다른 비동기 연산을 할 수 있도록 <code>Future[T]</code> 를 지원한다.</p>

<p>위의 이메일 예제에 <code>recover, recoverWith</code> 를 적용해 보자.</p>

<pre><code class="scala">def sendTo(url: URL, packet: Array[Byte]): Future[Array[Byte]] =  
  Http(URL("mail.server.eu"), Request(packet))
    .filter(response =&gt; response.isOK)
    .map(response =&gt; response.toByteArray)

def sendToAndBackup(packet: Array[Byte]): Future[Array[Byte]] =  
  sendTo(mailServer.europe, packet) recoverWith {
    case europeError =&gt; sendTo(mailServer.usa, packet) recover {
      case usaError =&gt; usaError.getMessage.toByteArray      
    }
  }
</code></pre>

<p>근데 마지막 부분에서 <code>usaError.getMessage.toByteArray</code> 가 별로 맘에 안든다.  미국으로 보내는건 백업일 뿐이고, 실제로는 유럽에 보내고 싶었다. 그래서 실패한 메세지를 받더라도 유럽쪽 에러를 받고 싶다. 또 다른 문제는 코드가 좀 못생겼다. 이 두가지 문제를 해결해보자.</p>

<pre><code class="scala">def fallbackTo(that: =&gt; Future[T]): Future[T] = {  
  if this future fails take the successful result
  of that future
  if that future fails too, take the error of
  this future
}
</code></pre>

<p>이런 메소드가 있다면 다음처럼 작성할 수 있다.</p>

<pre><code class="scala">def sendSafe(packet: Array[Byte]): Future[Array[Byte]] =  
  sendTo(mailServer.europe, packet) fallbackTo {
    sendTo(mailServer.usa, packet)
  } recover {
    case europeError =&gt; europeError.getMessage.toByteArray
  }
</code></pre>

<p><code>fallbackTo</code> 의 구현은 </p>

<pre><code class="scala">def fallbackTo(that: =&gt; Future[T]): Future[T] = {  
  this recoverWith {
    case _ =&gt; that recoverWith { case _ =&gt; this }
  }
}
</code></pre>

<p><code>Try</code> 에 실패했을때 복구하는 <code>Try</code> 를 만들 수 있다.</p>

<pre><code class="scala">object Try {  
  def apply(f: Future[T]): Future[Try[T]] = 
    f.map(s =&gt; Success(s)) recover { case t =&gt; Failure(t) }
}
</code></pre>

<h4 id="awaitable">Awaitable</h4>

<pre><code class="scala">trait Awaitable[T] extends AnyRef {  
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}

trait Future[T] extends Awaitable[T] {  
  def filter(p: T =&gt; Boolean): Future[T]
  def flatMap[S](f: T =&gt; Future[S]): Future[S]
  def map[S](f: T =&gt; S): Future[S]
  def recoverWith(f: PartialFunction[Throwable, Future[T]]): Future[T]
}
</code></pre>

<p>때때로 <em>asynchronous</em> 보다는 <em>blocking</em> 을 원할 수 있다. 그럴때는 <code>Awaitable</code> 을 사용하면 된다. 지정된 시간동안 블럭 후에 <code>result</code> 함수는 모나드를 벗겨 <code>T</code> 를 돌려준다.</p>

<p>예를 들어</p>

<pre><code class="scala">val socket = Socket()  
val packet: Future[Array[Byte]] = socket.readFromMemory()  
val confirmation: Future[Array[Byte]] =  
  packet.flatMap(socket.sendToSafe(_))

val c = Await.result(confirmation, 2 seconds)  
println(c.toText)  
</code></pre>

<p>여기 잘 보면 <code>2 seconds</code> 라고 썼는데, 진짜 동작하는 코드다.</p>

<pre><code class="scala">import scala.language.postFixOps

object Duration {  
  def apply(length: Long, unit: TimeUnit): Duration
}

val fiveYears = 1826 minutes  
</code></pre>

<h3 id="composingfutures">Composing Futures</h3>

<pre><code class="scala">val socket = Socket()  
val packet: Future[Array[Byte]] =  
  socket.readFromMemory()

val confirmation: Future[Array[Byte]] =  
  packet.flatmap(socket.sendToSafe(_))
</code></pre>

<p>위에서 이런 코드를 작성했었다. 당연히 <em>for expression</em> 으로 변환할 수 있다.</p>

<pre><code class="scala">val socket = Socket()

val confirmation: Future[Array[Byte]] = for {  
  packet  &lt;- socket.readFromMemory()
  confirm &lt;- socket.sendToSafe(packet)
} yield confirm
</code></pre>

<p>여기에 더 많은 <em>control flow</em> 를 도입하려면 어떻게 해야할까? <code>flatMap</code> 만으로는 좀 부족해보인다. 예를 들어 정해진 횟수만큼 <em>retry</em> 를 하고싶다고 하자. 이런 함수를 만들어야 하는데,</p>

<pre><code class="scala">def retry(times: Int)(block: =&gt; Future[T]): Future[T]  
</code></pre>

<p>재귀로 구현하면</p>

<pre><code class="scala">def retry(times: Int)(block: =&gt; Future[T]): Future[T] = {  
  if (times == 0) Future.failed(new Exeception("Sorry")
  else 
    block fallbackTo { 
      retry(times - 1) { block }
    }
}
</code></pre>

<p>음... 못생겼다. 재귀긴 한데.. 에릭 마이어에 의하면 <em>recursion</em> 은 함수형 프로그래밍의 <strong>GOTO</strong> 라고 한다. 재귀 말고 <em>fold</em> 를 사용하자.</p>

<pre><code class="scala">def retry(times: Int)(block: =&gt; Futurep[T]): Future[T] = {  
  val ns: Iterator[Int] = (1 to times).iterator
  val attempts: Iterator[Future[T]] = ns.map(_ =&gt; () =&gt; block)
  val failed = Future.failed(new Exception)

  attempts.foldLeft(failed)
    ((a, block) =&gt; a recoverWith { block() })
}
</code></pre>

<p>즉, <em>future</em> 를 받아 <code>times</code> 만큼의 리스트를 만들어 놓고, <em>fold</em> 를 이용해 <code>recoverWith</code> 를 호출한다. </p>

<p>따라서 <code>retry(3) { block }</code> 코드는 이렇게 확장된다.</p>

<pre><code class="scala">((failed recoverWith block) recoverWith block) recoverWith block
</code></pre>

<p>만약 <em>foldRight</em> 를 이용하면</p>

<pre><code class="scala">def fallbackTo(that: =&gt; Future[T]): Future[T] = {  
  this recoverWith {
    case _ =&gt; that recoverWith { case _ =&gt; this }
  }
}

def retry(times: Int)(block: =&gt; Futurep[T]): Future[T] = {  
  val ns: Iterator[Int] = (1 to times).iterator
  val attempts: Iterator[Future[T]] = ns.map(_ =&gt; () =&gt; block)
  val failed = Future.failed(new Exception)

  attempts.foldRight(() =&gt; failed)
    ((block, a) =&gt; () =&gt; { block() fallbackTo { a() } })
}

retry(3) { block } ()

// ==
block fallbackTo { block fallbackTo { block fallbackTo { failed }}}  
</code></pre>

<p>잘보면 <code>foldRight</code> 부분에서 초기값이 <code>() =&gt; failed</code> 로 변했다. 이는 우리가 <code>fallbackTo</code> 를 이용하기 때문인데, <code>fallbackTo</code> 의 로직상 <code>this</code> 가 실패하면 <code>that</code> 을 시도하게끔 되어있다. <code>that</code> 이 성공하면 <code>that</code> 을 돌려준다.</p>

<p>우리는 이미 실패한 <code>block</code> 을 <code>a</code> 에 쌓아놨기 때문에, 이것을 그대로 돌려주려면 <code>() =&gt;</code> 로 감싸서 성공할 수 있도록 해야한다.</p>

<h3 id="async">Async</h3>

<p>타입에 <em>effect</em> 를 명시하는건 무슨일이 일어나는지 알려주니까 정말 좋긴 한데, 코드를 작성하기가 까다롭다. 좀 간단하게 할 수 있는 방법은 없을까?</p>

<pre><code class="scala">import scala.async.Async._

def async[T](body: =&gt; T)  
  (implicit context: ExecutionContext): Future[T]

def await[T](future: Future[T]): T  
</code></pre>

<p>여기서 <code>async</code> 는 <code>Future</code> 의 팩토리라 보면 된다. 위에서 본 코드와의 다른점은, 내부에 <code>await</code> 함수를 사용할 수 있다. 얼핏 보면 <code>await</code> 은 블럭킹을 위한 <code>Awaitable</code> 과 비슷하게 보이기도 한다. <code>Future</code> 를 받아 <code>T</code> 를 돌려주니까.</p>

<pre><code class="scala">trait Awaitable[T] extends AnyRef {  
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}

// usage
Await.result(confirmation, 2 seconds)  
</code></pre>

<p>그러나 놀랍게도 <code>await</code> 함수는 블럭되지 않는다. 코드를 보기전에 잠깐 설명서를 좀 보면</p>

<blockquote>
  <p><strong>Illegal Uses</strong></p>
  
  <ul>
  <li><p>await requires a directly-enclosing async; this means await must not be used inside a closure nested within in an async block, or insdie a nested object, trait, or class</p></li>
  <li><p>await must not be used inside an expression passed as an argument to a by name parameter</p></li>
  <li><p>await must not be used inside a Boolean short-circuit argument</p></li>
  <li><p>return expression are illegal inside an async block</p></li>
  <li><p>await should not be used under a <strong>try / catch</strong></p></li>
  </ul>
</blockquote>

<p><code>try / catch</code> 구문을 이용할 수 없으므로 <code>Try</code> 모나드를 써야한다. 이제 위에서 봤던 <code>retry</code> 함수를 <code>await</code> 을 이용해서 작성하면</p>

<pre><code class="scala">def retry(times: Int)(block =&gt; Future[T]): Future[T] = async {  
  val i = 0
  var result: Try[T] = Failure(new Exception("sorry man!"))

  while (i &lt; times &amp;&amp; result.isFailure) {
    result = await { Try(block) }
    i += 1
  }

  result.get
}
</code></pre>

<p>코드가 좀 더 이해하기 쉬워졌다. 그리고 내부에서는 <em>mutable state</em> 를 사용할지라도 외부로는 여전히 <em>purely functional</em> 이다.</p>

<p>내친김에 <code>filter</code> 도 구현해 보자.</p>

<pre><code class="scala">def async[T](body: =&gt; T)  
  (implicit context: ExecutionContext): Future[T]
def await[T](future: Future[T]): T

def filter(p: T =&gt; Boolean): Future[T] = async {  
  val x = await { this }

  if (!p(x)) throw new NoSuchElementException()
  else x
}
</code></pre>

<p>여기서 예외를 던지는 이유는 <em>empty future</em> 를 예외로 간주하기 때문이다. 앞서 코드에서도 그랬듯이.</p>

<p><code>flatMap</code> 은 어떨까?</p>

<pre><code class="scala">def async[T](body: =&gt; T)  
  (implicit context: ExecutionContext): Future[T]
def await[T](future: Future[T]): T

def flatMap[S](f: T =&gt; Future[S]): Future[S] =  
  async { await { f(await {this}) }}
</code></pre>

<h3 id="promise">Promise</h3>

<p><code>await</code> 없이 <code>filter</code> 를 만들려면 <code>Promise</code> 를 사용할 수 있다.</p>

<pre><code class="scala">def filter(pred: T =&gt; Boolean): Future[T] = {  
  val p = Promise[T]()

  this onComplete {
    case Failure(e) =&gt; p.failure(e)
    case Success(x) =&gt; 
      if (!pred(x)) p.failure(new NoSuchElementException)
      else p.success(x)
  }

  p.future
}
</code></pre>

<p><code>Promise</code> 의 정의를 보면</p>

<pre><code class="scala">trait Promise[T] {  
  def future: Future[T]
  def complete(result: Try[T]): Unit
  def tryComplete(result: Try[T]): Boolean
}

trait Future[T] {  
  def onCompleted(f: Try[T] =&gt; Unit): Unit
}
</code></pre>

<p><code>Promise</code> 는 <code>Future</code> 를 담고 있는데, <code>Future.onCompleted</code> 에 등록된 콜백 <code>f: Try[T] =&gt; Unit</code> 은, <code>Promise.complete</code> 에 의해 호출된다. </p>

<p><code>Promise.complete</code> 는 한번만 호출될 수 있다. 상식적으로 생각해봐도 그렇다. 따라서 <code>tryComplete</code> 를 만들어, 이미 완료되었으면 <code>false</code> 를 얻어 검사한다.</p>

<p>재미난 예제를 하나 더 보자.</p>

<pre><code class="scala">import scala.concurrent.ExecutionContext.Implicits.global

def race[T](left: Future[T], right: Future[T]): Future[T] = {  
  val p = Promise[T]()

  left  onComplete { p.tryComplete(_) }
  right onComplete { p.tryComplete(_) }

  p.future
}
</code></pre>

<p>두 <code>left, right</code> <em>computation</em> 중 먼저 끝나는 연산이 돌려주는 <code>Try[T]</code> 가 <code>p.future.onComplete</code> 의 콜백에 삽입된다. </p>

<p>어떤 리소스를 얻길 원하는데 로컬 캐싱값과 리모트 값 둘 중 먼저 얻어오는 것을 사용하려고 할 때 이런 코드를 작성할 수 있다. <em>HTML5</em> 에도 <em>worker</em>(?) 라고 이렇게 활용할 수 있는 기능이 있는걸로 안다.</p>

<p><code>Promise</code> 에는 몇 가지 함수들이 더 있다.</p>

<pre><code class="scala">trait Promise[T] {  
  def future: Future[T]
  def complete(result: Try[T]): Unit
  def tryComplete(result: Try[T]): Boolean

  // helper method
  def success(value: T): Unit = this.complete(Success(value))
  def failure(t: Throwable): Unit = this.complete(Failure(t))
}
</code></pre>

<p>이제 아까 <code>filter</code> 로 다시 돌아가자.</p>

<pre><code class="scala">// async version
def filter(p: T =&gt; Boolean): Future[T] = async {  
  val x = await { this }

  if (!p(x)) throw new NoSuchElementException()
  else x
}

// promise version
def filter(pred: T =&gt; Boolean): Future[T] = {  
  val p = Promise[T]()

  this onComplete {
    case Failure(e) =&gt; p.failure(e)
    case Success(x) =&gt; 
      if (!pred(x)) p.failure(new NoSuchElementException)
      else p.success(x)
  }

  p.future
}
</code></pre>

<p><code>zip</code> 도 <code>Promise</code> 와 <code>await</code> 이용해 작성해 보자.</p>

<pre><code class="scala">// promise version
def zip[S, R](that: Future[S], f: (T, S) =&gt; R): Future[R] = {  
  val p = Promise[R]()

  this onComplete {
    case Failure(e) =&gt; p.failure(e)
    case Success(x) =&gt; that onComplete {
      case Failure(e) =&gt; p.failure(e)
      case Success(y) =&gt; p.success(f(x, y))
    }
  }

  p.future
}

// async version
def zip[S, R](p: Future[S], f: (T, S) =&gt; R): Future[R] = async {  
  f(await { this }, await {that })
}
</code></pre>

<p><del>갓 async</del> </p>

<p>시퀀스도 <code>await</code> 을 이용해서 구현하면</p>

<pre><code class="scala">def sequence[T](fs: List[Future[T]]): Future[List[T]] = async {  
  var _fs = fs
  var r = ListBuffer[T]()
  while (_fs != Nil) {
    r += await { _fs.head }
    _fs = _fs.tail
  }

  r.result
}
</code></pre>

<p>즉 <code>Future[T]</code> 를 하나씩 <em>async</em> 하게 얻어, 리스트로 돌려준다. 만약 이걸 <code>Promise</code> 로 구현하면</p>

<pre><code class="scala">def sequence[T](fs: List[Future[T]]): Future[List[T]] = {  
  val successful = Promise[List[T]]()
  successful.success(Nil)

  fs.foldRight(successful.future) {
    (f, acc) =&gt; for {x &lt;- f; xs &lt;- acc} yield x :: xs
  }
}
</code></pre>

<p><code>Future[T]</code> 를 누적해서 리스트를 만들어야 하기 때문에 <code>Promise.complete(Nil)</code> 을 세팅해 이것의 <code>Promise.future</code> 를 <code>foldRight</code> 의 초기값으로 사용한다.</p>

<p>그리고 <em>for expression</em> 에서 <code>f: Future[T], acc: Future[List[T]]</code> 다. 따라서 <code>for</code> 구문에서 모나드가 벗겨져 <code>x: T, xs: List[T]</code> 이며 성공적으로 <code>x</code> 를 가져오면 컨싱한다.</p>

<p>지금까지 <code>Try</code> 와 <code>Future</code> 를 살펴봤다. 다음엔 하나의 값이 아니라 컬렉션을 <em>async</em> 하게 어떻게 처리하나 알아보자.</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<h3 id="references">References</h3>

<p>(1) <em>Reactive Programming</em> by <strong>Martin Ordersky</strong>  </p>]]></description><link>http://1ambda.github.io/reactive-programming-3/</link><guid isPermaLink="false">9519a124-ef47-4ab8-9521-c7641b60eb23</guid><category><![CDATA[coursera]]></category><category><![CDATA[reactive programming]]></category><category><![CDATA[ scala]]></category><category><![CDATA[futures]]></category><category><![CDATA[promises]]></category><category><![CDATA[awaitable]]></category><category><![CDATA[try]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 21 Dec 2014 11:09:38 GMT</pubDate></item><item><title><![CDATA[Reactive Programming 2, Stateful]]></title><description><![CDATA[<p>지금까지 우리가 작성한 프로그램은 <em>side-effect free</em> 였기 때문에, <strong>time</strong> 이 중요한 요소가 아니였다. 무슨말인고 하니, 모든 프로그램은 <em>sequence of actions</em> 에 대해 항상 같은 결과를 주게 되어있었다.</p>

<p>이건 <em>substitution model</em> 에 반영되어 있다. </p>

<h3 id="substitutionmodel">Substitution Model</h3>

<p><em>substitution model</em> 을 복습해 보면, 프로그램의 <em>evaluation</em> 은 <em>rewriting</em> 이다.</p>

<pre><code class="scala">def f(x1, ..., xn) = B; ... f(v1, ..., vn)  
</code></pre>

<p>은 다음처럼 평가된다. 여기서 <code>B</code> 는 펑션 바디. </p>

<pre><code class="scala">def f(x1, ..., xn) = B; ... f(v1/x1, ..., vn/xn) B  
</code></pre>

<p>예를 들어</p>

<pre><code class="scala">def interate(n: Int, f: Int =&gt; Int, x: Int) =  
  if (n == 0) x else iterate(n-1, f, f(x))

def square(x: int) = x * x  
</code></pre>

<p><code>iterate(1, square, 3)</code> 은 이렇게 평가된다.</p>

<pre><code class="scala">if (1 == 0) 3 else iterate(1-1, square, square(3))  
iterate(0, square, square(3))  
iterate(0, square, 3 * 3)  
iterate(0, square, 9)  
if (0 == 0) 9 else iterate(0-1, square, square(9))  
9  
</code></pre>

<p>그런데 여기서 재미난 부분이 있다. <em>rewriting</em> 은 어느 <em>term</em> 에서나 일어날 수 있고, 모든 <em>종료되는</em> <em>rewriting</em> 은 같은 결과를 만든다.</p>

<blockquote>
  <p>Rewriting can be done anywhere in a term, and all rewritings which terminated lead to the same solution</p>
</blockquote>

<p>그리고 이 개념이 람다 대수와, 함수형 프로그래밍의 기반이다. 아래의 두 식은 같은 식이다. </p>

<pre><code class="scala">if (1 == 0) 3 iterate(1 - 1, square, square(3))

// ==
iterate(0, square, square(3))

// ==
if (1 == 0) 3 else iterate(1 - 1, square, 3 * 3)  
</code></pre>

<p>어느 부분에 집중하냐에 따라 <em>term</em> 에서의 <em>rewriting</em> 이 달라질 수는 있으나, 결과는 같다. 이걸 <em>confluence (합류)</em> 라 부르기도 하고 <a href='http://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem' >Church-Rosser Theorem</a> 이라 부르기도 한다.</p>

<h3 id="statefulobject">Stateful Object</h3>

<p>지금까지는 <em>pure functional world</em> 의 이야기였다. 이제 좀 바깥 세상 이야기를 해보자. 상태가 변하고 하는것들.</p>

<p>일반적으로 <em>world</em> 를 <em>a set of objects</em> 로 정의할 수 있으며, 이 <em>object</em> 들은 시간이 지남에 따라 <em>change</em> 가 일어난다. </p>

<blockquote>
  <p>An object <strong>has a state</strong> if its behavior is influenced by its history</p>
</blockquote>

<p>예를 들어서 <em>은행 계좌</em> 는 <em>state</em> 를 가지고 있다. 왜냐하면 다음 질문의 답이</p>

<blockquote>
  <p><strong>"Can I withdraw 100 CHF?"</strong></p>
</blockquote>

<p>계좌의 이전 상태들이 어땠는지에 따라 달라지기 때문이다. (<em>may vary over the course of the lifetime of the account</em>)</p>

<p>모든 <em>mutable state</em> 는 <em>variable</em> 을 이용해 만들 수 있는데 스칼라에서는 <em>value definition</em> 인 <code>val</code> 대신에 <em>variable definition</em> 인 <code>var</code> 을 이용한다.</p>

<p>실제로는 <code>var</code> 보다는 다수의 <em>variable</em> 을 가진 <em>object</em> 를 이용해 오브젝트를 나타낸다. 아래는 은행 계좌 예제</p>

<pre><code class="scala">  class BankAccount {
    private var balance = 0

    def deposit(amount: Int): Unit = {
      if (amount &gt; 0) balance = balance + amount
    }

    def withdraw(amount: Int): Unit = {
      if (0 &lt; amount &amp;&amp; amount &lt;= balance) balance = balance - amount
      else throw new Error("insufficient")
    }
  }
</code></pre>

<p>여기서 <code>BankAcoount</code> 는 <code>deposit</code> 과 <code>withdraw</code> 가 어떻게 얼마나 호출되었는지(히스토리)에 따라 상태 <code>balance</code> 가 달라진다. </p>

<p>여기서 지난번에 배웠던 <code>Stream</code> 의 구현을 잠깐 보자. 이건 <em>stateful object</em> 일까?</p>

<pre><code class="scala">def const[T](hd: T, tl: =&gt; Stream[T]) = new Stream[T] {  
  def head = hd
  private var tlOpt = Option[Stream[T]] = None
  def tail: T = tlOpt match {
    case Some(x) =&gt; x
    case None =&gt; tlOpt = Some(tl); tail
  }
}
</code></pre>

<p>이건 시스템이 어떠한가 하는 <em>가정</em> 에 따라 참일수도, 아닐수도 있다.</p>

<p>(1) 만약에 <code>tl</code> 연산에서 <em>side-effct</em> 가 없다면 <code>tlOpt</code> 를 캐시하기 위한 최적화는 이 클래스 외부에 대해 어떤 영향도 없으므로 스트림은 <em>stateful object</em> 가 아니다.</p>

<p>(2) 반대로 <code>tl</code> 을 계산하는 과정에서 <em>print</em> 나 등등 <em>side-effect</em> 가 발생한다면 첫번째로 <code>tl</code> 을 호출하냐, 두번째로 호출하냐에 따라 <em>print</em> 가 발생할 수, 아닐수도 있으므로 <em>stateful object</em> 다.</p>

<p>그럼 이제 이런 은행계좌 클래스를 생각해 보자.</p>

<pre><code class="scala">class BankAccountProxy(ba: BankAccount) {  
  def deposit(amount: Int) = ba.deposit(amount)
  def withdraw(amount: Int) = ba.withdraw(amount)
}
</code></pre>

<p>사실 이 <code>BankAccountProxy</code> 클래스는 어느 <em>varaible</em> 도 가지고 있지 않지만, 이 클래스의 <em>behavior</em> 이 <code>ba</code> 의 <em>state</em> 를 결정하기 때문에 <em>stateful object</em> 다.</p>

<h3 id="identityandchange">Identity and Change</h3>

<p>이번엔 두 <em>state</em> 가 같은지를 판별하는 문제를 생각해 보자.</p>

<p><em>assignment</em> 는 두 <em>expression</em> 이 서로 같은지(<em>the same</em>)에 대한 질문을 던진다.</p>

<p>예를 들어 <code>val x = E; val y = E</code> 라 하자. 여기서 <code>E</code> 는 임의의 <em>expression</em>. 여기서 <em>assignment</em> 가 없다면 아래 식 처럼 바꿔 쓸 수 있다.</p>

<pre><code class="scala">val x = E; val y = x  
</code></pre>

<p><em>property</em> 를 <strong>referential transparency</strong> 라 부른다. 근데 만약 <em>assigment</em> 가 있으면, 두 <em>formulation</em> 은 다를 수 있다.</p>

<pre><code class="scala">val x = new BankAccount  
val y = new BankAccount  
</code></pre>

<h4 id="operationalequivalence">Operational Equivalence</h4>

<p>두 변수가 같은지를 판별하기 위해서, <em>같다</em> 라는 말을 좀 더 엄밀히 정의해 보자. </p>

<blockquote>
  <p>The precise meaning of <strong>"being the same"</strong> is defined by the property of <em>operational equivalence</em>*</p>
</blockquote>

<p><code>x, y</code> 두 개의 <em>definition</em> 을 가지고 있다고 하자. </p>

<blockquote>
  <p><code>x</code> and <code>y</code> are operationally equivalent if <strong>no possible test</strong> can disingquish between them</p>
</blockquote>

<p>그러므로 우리는 <code>x, y</code> 가 같은지 비교하기 위해 </p>

<blockquote>
  <p>Execute the definitions followed by an arbitrary sequence <code>f</code> of operations that involves <code>x</code> an <code>y</code>, observing the possible outcomes.</p>
</blockquote>

<pre><code class="scala">val x = new BankAccount  
val y = new BankAccount  
f(x, y)

// another execution
val x = new BankAccount  
val y = new BankAccount  
f(x, x)  
</code></pre>

<blockquote>
  <p>Then, execute the definitions with another sequence <code>S'</code> obtains by renaming all occurences of <code>y</code> by <code>x</code> in <code>S</code></p>
</blockquote>

<p>만약 이 실행 결과가 다르다면 <code>x, y</code> 는 다른것이고 그 반대로 모든 <code>(S, S')</code> 가 같은 결과를 돌려준다면 <code>x, y</code> 는 같다. 왜냐하면 더이상 구분할 수 없기 때문이다. 이게 바로 <em>operationally equivalence</em></p>

<p>이제 이 <em>operational equvalence</em> 를 이용해서 위에서 나온 질문을 해결해 보자. <em>counter example</em> 로,</p>

<pre><code class="scala">// sequence S
val x = new BankAccount  
val y = new BankAccount

x deposit 30  // 30  
y withdraw 20 // error: insufficient

// sequnece S'
val x = new BankAccount  
val y = new BankAccount

x deposit 30  // 30  
x withdraw 20 // 10  
</code></pre>

<p>따라서 <code>x, y</code> 는 서로 다르다. 반면 <code>val y = x</code> 로 정의한다면 어떤 <em>operation</em> 도 두 변수를 구분할 수 없기 때문에 똑같다.</p>

<h4 id="assignmentandsubstitutionmodel">Assignment and Substitution Model</h4>

<p>지금까지 논의한 바를 정리해 보면 <em>assignment</em> 가 도입됨에 따라 우리가 가진 <em>computation model</em> 이 적용 불가능해 졌다.</p>

<pre><code class="scala">val x = new BankAccount  
val y = x

// will be replaced to, but not correct
val x = new BankAccount  
val y = new BankAccount  
</code></pre>

<p>위 식은 아래 식처럼 치환되지만, 절대 같은 결과가 아니다. 다른 프로그램이 된다!</p>

<blockquote>
  <p><em>The substitution model</em> <strong>ceases</strong> to be valid when we add the <em>assignment</em></p>
</blockquote>

<p><em>store</em> 개념을 도입하면 <em>substituion model</em> 을 적용 가능하지만, 이건 프로그램을 상당히 복잡하게 만든다.</p>

<p><em>purely functional world</em> 에서 벗어나니 세상이 복잡해졌다. 어떻게 두 세계를 잘 버무릴수 있을까?</p>

<h3 id="loops">Loops</h3>

<p>사실 <em>loop</em> 는 <em>imperative programming</em> 에서 필수적인 요소는 아니다. <em>variable</em> 만으로 절차형 언어를 모델링하기에 충분하긴 한데, 어쨌든 있긴 하니까 함수형 언어에서도 모델링 할 수 있는 방법을 강구해보자. <em>function</em> 으로 할 수 있다. </p>

<pre><code class="scala">def power(x: Double. exp: Int): Double = {  
  var r = 1.0
  var i = exp

  while (i &gt; 0) { r = r * x; i = i - 1}
  r
}
</code></pre>

<p>스칼라에서 <code>while</code> 은 키워드니까, <code>WHILE</code> 을 이용해 루프를 모델링하는 함수를 만들어 보자.</p>

<pre><code class="scala">def WHILE(condition: =&gt; Boolean)(body: =&gt; Unit): Unit = {  
  if (condition) {
    body
    WHILE(condition)(body)
  } else ()
}
</code></pre>

<ul>
<li><em>re-evaluation</em> 을 피하기 위해서 (인자로넘길때) <code>condition, body</code> 는 <em>by name</em> 으로 넘겨야 한다. </li>
<li><code>WHILE</code> 은 <em>tail-recursive</em> 이므로 <em>constant stack-size</em> 를 가진다.</li>
</ul>

<p><em>repeat</em> 는 이런식으로</p>

<pre><code class="scala">def REPEAT(body: =&gt; Unit)(condition: =&gt; Boolean): Unit = {  
  body
  if (condition) ()
  else REPEAT(body)(condition)
}
</code></pre>

<p><em>until</em> 을 만들고 싶으면 내부 함수를 만들면 된다.</p>

<pre><code class="scala">// ref: https://gist.github.com/metasim/7503601
def REPEAT(body: =&gt; Unit) = new {  
  def UNTIL(condition: =&gt; Boolean): Unit = {
    body
    if (condition) ()
    else UNTIL(condition)
  }
}

// test code
REPEAT {  
  x = x + 1
} UNTIL (x &gt; 3)
</code></pre>

<h4 id="forloops">For-Loops</h4>

<p>자바의 <em>for-loop</em> 를 단순히 <em>higher-order function</em> 를 사용하는것 만으로는 모델링하기 어렵다. 왜냐하면 <code>i</code> 의 <em>declaration</em> 이 포함되어있기 때문이다.</p>

<pre><code class="java">for (int i = 1; i &lt; 3; i = i + 1) { System.out.print(i + " "); }  
</code></pre>

<p>스칼라에서도 비슷한 루프를 제공하긴 하는데, 위 루프보다는 <em>extended</em> 루프에 더 가깝다.</p>

<pre><code class="scala">for (i &lt;- 1 until 3) { System.out.print(i + " ") }  
</code></pre>

<p><em>for loop</em> 는 <em>foreach combinator</em> 로  번역 된다. 참고로 <em>for expression</em> 은 <code>map, flatMap</code> 으로 번역된다.</p>

<pre><code class="scala">def foreach(f: T =&gt; Unit): Unit =  
  // apply 'f' to each element of the collection

// example
for (i &lt;- 1 until 3; j &lt;- "abc") println(i + " " + j)

// translated to
(1 until 3).foreach(i =&gt; "abc" foreach (j =&gt; println(i + " " + j)))
</code></pre>

<h3 id="discreteeventsimulation">Discrete Event Simulation</h3>

<p>지금까지 <em>world</em> 를 모델링 할 수 있는 <em>state</em> 와, 여기에 적용할 수 있는 <em>control structure</em> 를 살펴봤는데, 이걸 이용해서 시뮬레이션을 해보자.</p>

<h4 id="digitalcircuit">Digital Circuit</h4>

<p><em>digital circuit</em> 은 <strong>wires</strong> 와 <strong>functional components</strong> 로 구성된다. </p>

<blockquote>
  <p>Wires transport signals thar are transformed by components</p>
</blockquote>

<p><em>signal</em> 을 <code>True, False</code> 로 표현하자. 그리고 기본 <em>components</em> 로</p>

<ul>
<li>Inverter</li>
<li>AND Gate</li>
<li>OR Gate</li>
</ul>

<p>그러면 다른 컴포넌트들은 이 조합으로 만들 수 있다. 그리고 각 컴포넌트는 <em>delay</em> 를 가질 수 있다.</p>

<pre><code class="scala">def inverter(input: Wire, output: Wire): Unit  
def andGate(a1: Wire, a2: Wire, output: Wire): Unit  
def orGate(o1: Wire, o2: Wire, output: Wire): Unit  
</code></pre>

<p>이제 <em>half adder, HA</em> 를 만들어 보면 </p>

<p><img src='http://i.msdn.microsoft.com/dynimg/IC141779.gif'  alt="" /></p>

<p align="center">(<a href='http://msdn.microsoft.com/' >http://msdn.microsoft.com</a>)</p>

<pre><code class="scala">def halfAdder(a: Wire, b: Wire, c: Wire, s: Wire): Unit = {  
  val d = new Wire
  val e = new Wire

  orGate(a, b, d)
  andGate(a, b, e)
  inverter(c, e)
  andGate(d, e, s)
}
</code></pre>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Full_Adder_Blocks.svg/2000px-Full_Adder_Blocks.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikibooks.org/' >http://en.wikibooks.org</a>)</p>

<p><img src='http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/ietron/fulladd.gif'  alt="" /></p>

<p align="center">(<a href='http://hyperphysics.phy-astr.gsu.edu/' >http://hyperphysics.phy-astr.gsu.edu</a>)</p>

<p>그러면 <em>full adder</em> 는</p>

<pre><code class="scala">def fullAdder(a: Wire, b: Wire, cin: Wire, sum: Wire, cout: Wire): Unit = {  
  val s = new Wire
  val c1 = new Wire
  val c2 = new Wire

  halfAdder(b, cin, s, c1)
  halfAdder(a, s, sum, c2)
  orGate(c1, c2, cout)
}
</code></pre>

<h4 id="action">Action</h4>

<p><em>discrete event simulator</em> 는 특정 <em>moment</em> 에서의 수행되는 <em>actions</em> 이다. 아무런 파라미터도 필요없는 <em>action</em> 은</p>

<pre><code class="scala">type Action = () =&gt; Unit  
</code></pre>

<p>어떤 <em>side-effect</em> 를 수행하면서 <em>time</em> 을 시뮬레이션 할 수 있다.</p>

<h4 id="simulator">Simulator</h4>

<pre><code class="scala">  trait Simulation {
    def currentTime: Int = ???
    def afterDelay(delay: Int)(block: =&gt; Unit): Unit = ???
    def run(): Unit = ???
  }
</code></pre>

<ul>
<li><code>currentTime</code> returns the current simulated time</li>
<li><code>afterDelay</code> registeres an action to perform after a certain delay</li>
<li><code>run</code> performs the simulation until there are no more actions wating</li>
</ul>

<p>이렇게 시뮬레이터 <em>trait</em> 를 만들고 상속 구조를 만들면</p>

<pre><code class="scala"> Simulation
     |
   Gates     // Wire, AND, OR, INV
     |
  Circuits   // HA, ADDER  
     |
MySimulation // implementation  
</code></pre>

<h4 id="wire">Wire</h4>

<pre><code class="scala">class Wire {  
  private var sigVal = false
  private var actions: List[Action] = List()

  def getSignal: Boolean = sigVal
  def setSignal(s: Boolean): Unit =
    if (s != sigVal) {
      sigVal = s
      actions foreach (_())
    }

 def addAcion(a: Action): Unit = {
    actions = a :: actions
    a()
  }
}
</code></pre>

<h4 id="inverterandorgates">Inverter, AND, OR Gates</h4>

<p><em>input wire</em> 로 부터의 입력을 뒤집어서 <em>output wire</em> 에다 돌려주는 <code>inverter</code> 를 구현할 수 있다. 근데 회로에서는 <em>delay</em> 가 있기 때문에 바로는 뒤집기 보다는 <code>InvertDelay</code> 이후에 신호를 반전시키는 <em>action</em> 을 구현하자. 아까 <code>Simulation</code> 내의 <code>afterDelay</code> 를 구현하면 된다.</p>

<pre><code class="scala">  def andGate(in1: Wire, in2: Wire, output: Wire): Unit = {
    def andAction(): Unit = {
      val in1Signal = in1.getSignal
      val in2Signal = in2.getSignal
      afterDelay(AddGateDelay) { output setSignal (in1Signal &amp; in2Signal) }
    }

    in1 addAction andAction
    in2 addAction andAction
  }

  def orGate(in1: Wire, in2: Wire, output: Wire): Unit = {
    def orAction(): Unit = {
      val in1Signal = in1.getSignal
      val in2Signal = in2.getSignal
      afterDelay(OrGateDelay) { output setSignal (in1Signal | in2Signal) }
    }

    in1 addAction orAction
    in2 addAction orAction
  }

  def inverter(input: Wire, output: Wire): Unit = {
    def invertAction(): Unit = {
      val inputSig = input.getSignal
      afterDelay(InverterDelay) { output setSignal (!inputSig) }
    }
    input addAction invertAction
  }
</code></pre>

<p><br/></p>

<p><del>혼란이 오기 시작했다</del></p>

<blockquote>
  <p>What happens if we compute <code>in1Sig</code> and <code>in2Sig</code> inline inside <code>afterDelay</code> instead of computing them as value?</p>
</blockquote>

<p>당연히 <em>delay</em> 후의 <em>signal</em> 값을 가지고 <em>action list</em> 에 추가하므로 제대로 모델링하지 못한다.</p>

<pre><code class="scala">afterDelay(OrGateDelay) {  
  output setSignal (in1.getSignal | in2.getSignal)
}
</code></pre>

<h3 id="thesimulationtrait">The Simulation Trait</h3>

<p>지금까지를 정리하면, <code>Wire</code> 클래스는 <em>statefule object</em> 를 나타낸다. 상태 <code>signal</code>, <code>actions</code> 는 <code>addAction, setSignal</code> 호출에 의해 정해진다. 이 함수들의 호출은 일종의 <em>event</em> 이며, <em>delay</em> 와 <em>action</em> 으로 구성된다.</p>

<p>그리고 이 모든 <code>Event</code> 는 <code>Simulation</code> <em>trait</em> 내 리스트로 저장된다. 일종의 할일 목록이나, <em>history</em> 로 보면 쉬울듯. </p>

<pre><code class="scala">type Action = () =&gt; Unit  
case class Event(time: Int, action: Action)  
private type Agenda = List[Event]  
private var agenda: Agenda = List()

private var curtime: Int = 0  
def currentTime: Int = curtime  
</code></pre>

<p>현재 시뮬레이션 타임을 기록하기 위해 <code>curtime</code> 정의하고, 이를 이용해 <code>Event</code> 를 정의할 수 있다. <code>Event(curtime + delay, () =&gt; block)</code> 처럼</p>

<pre><code class="scala">def afterDelay(delay: Int)(block: =&gt; Unit): Unit = {  
  val item = Event(currentTime + delay, () =&gt; block)
  agenda = insert(agenda, item)
}

private def insert(ag: List[Event], item: Event): List[Event] = ag match {  
  case first :: rest if first.time &lt;= item.time =&gt; first :: insert(rest, item)
  case _ =&gt; item :: ag
}
</code></pre>

<p>그리고 <code>agenda</code> 에 있는 액션들을 처리할 <code>loop</code> 와 시뮬레이션을 돌릴 <code>run</code> 함수를 구현하면</p>

<pre><code class="scala">private def loop(): Unit = agenda match {  
  case first :: rest =&gt;
    agenda = rest
    curtime = first.time
    first.action()
    loop()
  case _ =&gt;
}

def run(): Unit = {  
  afterDelay(0) {
    println("*** simulation started, time = " + currentTime + " ***")
  }

  loop()
}
</code></pre>

<p>그리고 시뮬레이션 자체는 아무런 <em>output</em> 도 주지 않기 때문에, 디버깅에 유용한 <code>probe</code> 함수를 추가하자. 디버깅용 <em>action</em> 을 추가한다 생각하면 쉽다. 일종의 <em>gate</em> 이기도 하다.</p>

<pre><code class="scala">def probe(name: String, wire: Wire): Unit = {  
  def probeAction(): Unit = {
    println(s"$name $currentTime value = ${wire.getSignal}")
  }

  wire addAction probeAction
}
</code></pre>

<p>이제 각 게이트마다의 딜레이를 위한 <em>trait</em> 를 만들자. 회로를 무엇으로 구성하냐에 따라 다를 수 있으므로 <em>trait</em> 으로 만드는건 좋은 선택이다.</p>

<pre><code class="scala">trait Parameters {  
  def InverterDelay = 2
  def AndGateDelay = 2
  def OrGateDelay = 2
}
</code></pre>

<h4 id="implementation">Implementation</h4>

<pre><code class="scala">
</code></pre>

<h4 id="test">Test</h4>

<pre><code class="scala">trait Simulation {  
  type Action = () =&gt; Unit
  case class Event(time: Int, action: Action)
  private type Agenda = List[Event]
  private var agenda: Agenda = List()

  private var curtime: Int = 0
  def currentTime: Int = curtime

  def afterDelay(delay: Int)(block: =&gt; Unit): Unit = {
    val item = Event(currentTime + delay, () =&gt; block)
    agenda = insert(agenda, item)
  }

  private def insert(ag: List[Event], item: Event): List[Event] = ag match {
    case first :: rest if first.time &lt;= item.time =&gt; first :: insert(rest, item)
    case _ =&gt; item :: ag
  }

  private def loop(): Unit = agenda match {
    case first :: rest =&gt;
      agenda = rest
      curtime = first.time
      first.action()
      loop()
    case _ =&gt;
  }

  def run(): Unit = {
    afterDelay(0) {
      println("*** simulation started, time = " + currentTime + " ***")
    }

    loop()
  }

}

abstract class Gates extends Simulation {

  def AndGateDelay: Int
  def OrGateDelay: Int
  def InverterGateDelay: Int

  class Wire {
    private var sigVal = false
    private var actions: List[Action] = List()

    def getSignal: Boolean = sigVal
    def setSignal(s: Boolean): Unit =
      if (s != sigVal) {
        sigVal = s
        actions foreach (_())
      }

    def addAction(a: Action): Unit = {
      actions = a :: actions
      a()
    }
  }

  def andGate(in1: Wire, in2: Wire, output: Wire): Unit = {
    def andAction(): Unit = {
      val in1Signal = in1.getSignal
      val in2Signal = in2.getSignal
      afterDelay(AndGateDelay) { output setSignal (in1Signal &amp; in2Signal) }
    }

    in1 addAction andAction
    in2 addAction andAction
  }

  def orGate(in1: Wire, in2: Wire, output: Wire): Unit = {
    def orAction(): Unit = {
      val in1Signal = in1.getSignal
      val in2Signal = in2.getSignal
      afterDelay(OrGateDelay) { output setSignal (in1Signal | in2Signal) }
    }

    in1 addAction orAction
    in2 addAction orAction
  }

  def inverter(input: Wire, output: Wire): Unit = {
    def invertAction(): Unit = {
      val inputSig = input.getSignal
      afterDelay(InverterGateDelay) { output setSignal (!inputSig) }
    }
    input addAction invertAction
  }

  def probe(name: String, wire: Wire): Unit = {
    def probeAction(): Unit = {
      println(s"$name $currentTime value = ${wire.getSignal}")
    }

    wire addAction probeAction
  }
}

abstract class Circuits extends Gates {

  // input a, b
  // output sum, carry
  def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire): Unit = {
    val d = new Wire
    val e = new Wire

    orGate(a, b, d)
    andGate(a, b, c)
    inverter(c, e)
    andGate(d, e, s)
  }

  def fullAdder(a: Wire, b: Wire, cin: Wire, sum: Wire, cout: Wire): Unit = {
    val s = new Wire
    val c1 = new Wire
    val c2 = new Wire

    halfAdder(b, cin, s, c1)
    halfAdder(a, s, sum, c2)
    orGate(c1, c2, cout)
  }
}

trait Parameters {  
  def InverterGateDelay = 2
  def AndGateDelay = 3
  def OrGateDelay = 5
}
</code></pre>

<p>테스트코드는</p>

<pre><code class="scala">object test extends Circuits with Parameters  
import test._  
val in1, in2, sum, carry = new Wire

halfAdder(in1, in2, sum, carry)  
probe("sum", sum)  
probe("carry", carry)

in1.setSignal(true)  
test.run()  
in2.setSignal(true)  
test.run()  
</code></pre>

<p>결과는</p>

<pre><code class="scala">sum 0 value = false  
carry 0 value = false  
*** simulation started, time = 0 ***
sum 8 value = true  
*** simulation started, time = 8 ***
carry 11 value = true  
sum 16 value = false  
</code></pre>

<p>흐름을 정리해 보면,</p>

<p>(1) <code>halfAdder</code> <br />
(2) <code>orGate, andGate, invertGate</code> <br />
(3) <code>addAction</code>
(4) <code>a()</code> -> <code>afterDelay</code> <br />
(5) <code>insert</code> 에서 시간을 고려해 이벤트리스트에 삽입 <br />
(6) <code>loop</code> 가 돌아가면서 모든 <code>action</code> 실행</p>

<h4 id="avariant">A Variant</h4>

<p><em>OR gate</em> 는 <em>AND, Invert</em> 로 구성될 수 있다. <code>a | b = ~(~a &amp; ~b)</code> 이기 때문인데</p>

<pre><code class="scala">def orGateAlt(in1: Wire, in2: Wire, output: Wire): Unit = {  
  def orAction(): Unit = {
    val notIn1, notIn2, notOut = new Wire
    inverter(in1,notIn1);
    inverter(in2,notIn2);
    andGate(notIn1, notIn2, notOut)
    inverter(notOut, output)
  }
}
</code></pre>

<p>만약에 이 <em>OR Gate</em> 를 사용하면 어떻게 될까? 시간은 당연히 달라지고, 추가적인 이벤트도 발생한다.</p>

<h3 id="summary">Summary</h3>

<ul>
<li><em>state</em> 와 <em>assignment</em> 는 모델을 더 복잡하게 만든다. </li>
<li><em>referential transparency</em> 도 포기해야 한다</li>
</ul>

<p>반면</p>

<ul>
<li><em>discrete event simulation</em> 같은 특정 형태의 프로그램을 우아하게 작성할 수 있다</li>
<li>시스템은 <em>mutable list of actions</em> 로 표현되고</li>
<li><em>action</em> 이 호출되면 그 효과로 인해 오브젝트의 상태가 변한다</li>
<li>미래에 호출될 <em>action</em> 을 <em>install</em> 할 수 있다.</li>
</ul>

<h3 id="references">References</h3>

<p>(1) <em>Reactive Programming</em> by <strong>Martin Ordersky</strong> <br />
(2) <a href='http://msdn.microsoft.com/en-us/library/aa288734' (v=vs.71).aspx">MSDN: Half Adder</a></p>]]></description><link>http://1ambda.github.io/reactive-programming-2/</link><guid isPermaLink="false">1f0f0056-8b79-426c-abcb-ce9071c541bb</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[reactive programming]]></category><category><![CDATA[referential transparency]]></category><category><![CDATA[operational equivalence]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 21 Dec 2014 01:57:05 GMT</pubDate></item><item><title><![CDATA[하스켈로 배우는 함수형 언어 9]]></title><description><![CDATA[<h3 id="intro">Intro</h3>

<p>이번시간엔 함수형 프로그래밍에서 <em>property</em> 를 증명하는 방법인 <em>induction</em> 에 대해 배워보고, 하스켈에서 알고리즘의 성능이 어떨까에 대해 좀 논의해 보겠습니다. 마지막엔 <em>Rose Tree</em> 를 구현하면서 <em>Functor, Monoid, Foldable</em> 등에 대해 좀 알아봅시다.</p>

<p>수학에서 다음 두 식은 똑같습니다.</p>

<pre><code>xz + yz = (x + y)z  
</code></pre>

<p>근데, 잘 보면 연산의 수가 다릅니다. 좌측은 3개고, 우측은 2개면 되지요. 하스켈에서도 이런 생각들을 좀 해봅시다. <em>built-in</em> 연산자에 대해서뿐만 아니라, <em>user-defined</em> 연산자 (함수) 에 대해서도 생각할 수 있으니까, 좀 다양하겠네요.</p>

<h3 id="reasoningabouthaskell">Reasoning about Haskell</h3>

<pre><code class="haskell">double :: Int -&gt; Int  
double x = x + x  
</code></pre>

<p>이제 모든 <code>x + x</code> 는 <code>double x</code> 로, 바꿀 수 있죠. 그 반대도 가능하고요. 근데, <em>multiple equations</em> 를 쓰면 좀 얘기가 다릅니다.</p>

<pre><code class="haskell">isZero :: Int -&gt; Bool  
isZero 0 = True  
isZero n = False  
</code></pre>

<p>첫번째 식 <code>isZero 0 = True</code> 는 어느 방향으로든 자유롭게 적용가능하지만, 두번째는 아닙니다. 사실은 이런 뜻이거든요</p>

<pre><code class="haskell">isZero 0          = True  
isZero n | n /= 0 = False  
</code></pre>

<p>이제 좌우를 쉽게 치환할 수 있습니다. 이렇게 식의 순서에 의존하지 않는 패턴을 <em>disjoint</em> 혹은 <em>non-overlapping</em> 이라 부릅니다.</p>

<blockquote>
  <p>Patterns that do not rely on the order in which the are matched are called <em>disjoint</em> or <em>non-overlapping</em></p>
</blockquote>

<p>프로그램에 대해서 <em>reasoning</em> 할 땐 가능하면 <em>non-overlapping</em> 패턴을 사용하는게 좋습니다. <em>standard library</em> 에 있는 대부분의 함수들은 이런식으로 작성 되어있습니다.</p>

<h3 id="simpleexamples">Simple examples</h3>

<pre><code class="haskell">reverse :: [a] -&gt; [a]  
reverse [] = []  
reverse (x:xs) reverse xs ++ [x]  
</code></pre>

<p>이 구현을 보면 <code>reverse [x] = [x]</code> 입니다. 근데, 이걸 연산하려면</p>

<pre><code class="haskell">reverse [x]  
reverse (x:[])  
reverse [] ++ [x]  
[] ++ [x]
[x]
</code></pre>

<p>따라서 <code>reverse [x] = [x]</code> 를 추가해서 효율적인 구현을 할 수 있습니다. </p>

<h3 id="inductiononnumbers">Induction on numbers</h3>

<p>함수형 프로그램은 종종 재귀를 이용해 작성되는데, 여기에 <em>induction</em> 을 이용할 수 있습니다. 예전에 본 자연수 타입 <code>Nat</code> 의 정의를 떠올려 보면</p>

<pre><code class="haskell">data Nat = Zero | Succ Nat  
</code></pre>

<p>어떤 유한한 수에 대해서 어떤 <em>property</em> <code>p</code> 를 증명하려고 할 때, 먼저 <em>base case</em> 인 <code>Zero</code> 에 대해 보이고, <em>inductive case</em> <code>Succ</code> 에 대해서 보이면 됩니다. 더 자세히는, 어떤 자연수 <code>n</code> 에 대해서 <code>p</code> 가 참일때 (<em>induction hypothesis</em>), <code>Succ n</code> 에 대해서도 참임을 보이면 됩니다.</p>

<p>구체적인 예제를 보도록 하죠. 두 <code>Nat</code> 를 더해 <code>Nat</code> 를 만드는 <code>add</code> 함수를 만들면</p>

<pre><code class="haskell">add :: Nat -&gt; Nat -&gt; Nat  
add Zero m = m  
add (Succ n) m = Succ (add n m)  
</code></pre>

<p>첫 번째씩 <code>add Zero m = m</code> 은 모든 자연수 <code>m</code> 에 대해 참이기 때문에, <code>add n Zero = n</code> 을 증명하겠습니다. 이걸 가설 <code>p</code> 라 부릅시다. </p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">add Zero Zero  
Zero  
</code></pre>

<p>(2) <em>inductive case</em></p>

<p>이 단계에서는 <code>p</code> 가 자연수 <code>n</code> 에 대해 참일때 <code>p (Succ n)</code> 이 참임을 보이면 됩니다. 다시 말해 가설 <code>p</code> <code>add n Zero = n</code> 을 이용해 <code>add (Succ n) Zero = Succ n</code> 임을 보여야 합니다.</p>

<pre><code class="haskell">add (Succ n) Zero -- should be `Succ n`

= Succ (add n Zero) 

= Succ n -- by induction hypothesis
</code></pre>

<p>다른 속성으로 <em>associativity</em> 를 증명할 수도 있습니다. </p>

<pre><code class="haskell">add x (add y z) = add (add x y) z  
</code></pre>

<p>인자가 3개인데 무엇부터 시작해야 할까요? <code>add</code> 는 패턴매칭을 이용해 작성되었고, 재귀 부분이  첫번째 인자를 주로 이용하므로 <code>x</code> 를 선택하는게 자연스러울 겁니다. <code>y</code>는 1 번 쓰이고, <code>z</code>는 첫번째 인자로 한번도 안쓰이네요. </p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">add Zero (y z) -- should be `add (add Zero y) z`

= add y z
= add (add Zero y) z -- unapplying add
</code></pre>

<p>(2) <em>inductive case</em></p>

<p><code>p</code> 는 `add x (add y z) = add (add x y) z</p>

<pre><code class="haskell">add (Succ x) (add y z) -- should be 'add (add (Succ x) y) z`

= Succ (add x (add y z)) -- apply outer add
= Succ (add (add x y) z) -- induction hypothesis
= add (Succ (add x y) z) -- unapply outer add
= add (add (Succ x) y) z -- unapply inner add
</code></pre>

<p>이렇게 <em>unapply, apply</em> 를 편하게 할 수 있는 이유는 위에서 <code>add</code> 를 <em>non-overlapping</em> 패턴으로 작성했기 때문이지요.</p>

<p><em>induction</em> 을 <em>recursive type</em> 인 <code>Nat</code> 에 적용했지만, <code>Integer</code> 타입에도 적용할 수 있습니다.</p>

<p>어떤 <em>property</em> <code>p</code> 를 <code>n &gt;= 0</code> 에 대해 증명하려고 할 때는 먼저 <em>base case</em> 인 <code>0</code> 에 대해 참임을 보이고, <code>n &gt;= 0</code> 일때, <code>n + 1</code> 에 대해서도 참임을 보이면 됩니다.</p>

<pre><code class="haskell">replicate :: Int -&gt; a -&gt; [a]  
replicate 0 _       = []  
replicate (n + 1) x = x : replicate n x  
-- replicate n x = x : replicate (n - 1) x
</code></pre>

<p>요즘 컴파일러는 <code>n + 1</code> 패턴을 막아서 아마 주석처리부분처럼 작성해야 합니다. 무튼 저 정의대로만 보면, <code>n</code> 에 대해 참일때 <code>n + 1</code> 일때도 참임을 보이는건 정말 쉽습니다. 정의 그 자체가 <em>induction</em> 이니까요.</p>

<h3 id="inductiononlists">Induction on lists</h3>

<p>재귀는 자연수에만 쓸 수 있는건 아니고, 리스트와 같은 다양한 재귀적인 타입에 사용할 수 있습니다. <em>base case</em> 는 <code>[]</code> 이 되겠고, <em>successor function</em> 은 <code>:</code> 이 되겠네요.</p>

<p>그러므로 리스트에 대해 어떤 <em>property</em> <code>p</code> 를 증명하려면, 먼저 <code>[]</code> 에 대해 참임을 보이고 <code>p xs</code> 가 참일때 <code>p x:xs</code> 가 참임을 보이면 됩니다. <del>참 쉽죠?</del></p>

<p><em>reverse</em> 연산에 대해 <code>reverse (reverse xs) = xs</code> 를 증명해 봅시다.</p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">reverse (reverse []) -- should be '[]'

= reverse []
= []
</code></pre>

<p>(2) <em>inductive case</em></p>

<pre><code class="haskell">-- induction hypothesis

reverse (reverse xs) = xs  
</code></pre>

<p>증명은</p>

<pre><code class="haskell">reverse (reverse x:xs) -- = x:xs

= reverse (reverse xs ++ [x])
= reverse [x] ++ reverse (reverse xs) -- by distributivity
= [x] ++ xs -- induction hypothesis
= x:xs
</code></pre>

<p>여기서 사용한 성질중에 하나가 <em>distributivity</em> 인데,</p>

<pre><code class="haskell">-- induction hypothesis
reverse (xs ++ ys) = reverse ys ++ reverse xs  
</code></pre>

<p>(1) <em>base-case</em> </p>

<pre><code class="haskell">reverse ([] ++ ys) -- reverse ys ++ reverse [] 

= reverse ys
= [] ++ reverse ys -- unapply ++
= reverse [] ++ reverse ys
</code></pre>

<p>(2) <em>inductive case</em></p>

<pre><code class="haskell">reverse ((x:xs) ++ ys) -- reverse ys ++ reverse (x:xs)

= reverse (x:(xs ++ ys))
= reverse (xs ++ ys) ++ [x]
= reverse ys ++ (reverse xs ++ [x])
= reverse ys ++ (reverse (x:xs)) -- unapply second reverse
</code></pre>

<p>이 증명은 <code>++</code> 가 <em>associative</em> 라는 사실을 이용해 증명했는데, 이것도 마찬가지로 증명할 수 있습니다.</p>

<h3 id="markingappendvanish">Marking append vanish</h3>

<p>많은 재귀 함수들이 <code>++</code> 연산을 이용해 작성되었는데, 편하긴 하지만 재귀적으로 사용되면 비용이 좀 듭니다. 따라서 이번에는 <code>++</code> 를 제거 해서 좀 더 효율적으로 함수를 작성해봅시다.</p>

<p><code>reverse</code> 함수부터 해 보면</p>

<pre><code class="haskell">reverse :: [a] -&gt; [a]  
reverse [] = []  
reverse (x:xs) = reverse xs ++ [x]  
</code></pre>

<p>이렇게 작성된 <code>reverse</code> 함수의 성능은 어떨까요? 먼저 생각해 볼 것은 <code>xs ++ ys</code> 을 <em>evaluation</em> 하기 위해 얼마의 스텝이 필요할까? 입니다. <code>xs ++ ys</code> 는 <code>xs</code> 를 쪼개가면서 <code>xs</code> 에 붙이기 때문에, <code>xs + 1</code> 만큼의 스텝이 필요하죠.</p>

<p>참고로 <code>append</code> 의 정의는</p>

<pre><code class="haskell">append :: [a] -&gt; [a] -&gt; [a]  
append [ ] xs    = xs  
append (x:xs) ys = x : append xs ys  
</code></pre>

<p>좀 간단히 생각하기 위해 <code>xs, ys</code> 가 <em>fully evaluated</em> 되었다 합시다. 그 결과로 <code>++</code> 는 첫 번째 인자 <code>xs</code> 의 길이에 비례하는 <em>linear time</em> 퍼포먼스를 보여줍니다.</p>

<p>결과적으로 <code>reverse xs</code> 의 성능은, 길이를 <code>n</code> 이라 했을 때 <code>1 + 2 + ... + n + 1</code> 입니다. <code>(n^2 + 3n + 2) / 2</code> 겠네요. 이는 <code>reverse</code> 함수가 <em>quadratic time</em> 의 함수라는걸 말해줍니다. 1000 개를 뒤집으려면, 10000000 번만큼 연산을 해야한다는 소리지요.</p>

<p>다행히도 <em>induction</em> 을 이용해 쓸모없는 <code>++</code> 부분을 제거하고, 성능을 개선할 수 있습니다.</p>

<p><code>reverse</code> 와 <code>++</code> 를 합친 좀 더 <em>general</em> 한 함수를 만듭시다. <code>reverse'</code> 라 부를건데, <code>reverse xs += ys</code> 와 같은 일을 할겁니다. </p>

<pre><code class="haskell">reverse' xs ys -- = reverse xs ++ ys  
</code></pre>

<p>이렇게 만들면 <code>reverse</code> 자체는 이렇게 정의할 수 있습니다. <code>[]</code> 가 <em>append</em> 를 위한 <em>identity</em> 라는 점을 이용한 것이지요.</p>

<pre><code class="haskell">reverse xs = reverse' xs []  
</code></pre>

<p>신기하게도 이 속성을 증명하면서, 이 <code>reverse'</code> 의 정의 자체를 얻을 수 있습니다. </p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">reverse' [] ys 

= reverse [] ++ ys 
= [] ++ ys
= ys
</code></pre>

<p>(2) <em>inductive case</em></p>

<pre><code class="haskell">reverse' (x:xs) ys

= reverse (x:xs) ++ ys
= (reverse xs ++ [x]) ++ ys
= reverse xs ++ ([x] ++ ys]) -- by associativity of ++
= reverse' xs ([x] ++ ys) -- by induction hypothesis
= reverse' xs (x:ys)
</code></pre>

<p>따라서 <code>reverse'</code> 의 정의는</p>

<pre><code class="haskell">reverse' [a] -&gt; [a] -&gt; [a]  
reverse' [] y = ys  
reverse' (x:xs) ys = reverse' xs (x:ys)  
</code></pre>

<p>아까 언급했던대로 <code>reverse</code> 를 다시 만들면</p>

<pre><code class="haskell">reverse :: [a] -&gt; [a]  
reverse xs = reverse' xs []  
</code></pre>

<p>이제는 <code>x:ys</code> 처럼, 하나씩 분리해 나가면서 붙기때문에 성능이더 빠릅니다. 정확히는 <code>n + 2</code>  연산이 필요하지요. <em>linear time</em> 입니다. </p>

<p>사실은 7장 에서 이미 개선된 <em>reverse</em> 를 봤었습니다. <code>reverse = foldl (:) []</code> 기억 나시나요?</p>

<h4 id="flatten">flatten</h4>

<pre><code class="haskell">data Tree = Leaf Int | Node Tree Tree  
flatten :: Tree -&gt; [Int]  
flatten (Leaf n) = [n]  
flatten (Node l r) = flatten l ++ flatten r  
</code></pre>

<p>이 <code>flatten</code> 도 <code>++</code> 때문에 느립니다. 위 <code>reverse</code> 처럼 개선해 보면</p>

<pre><code class="haskell">flatten' t ns = flatten t ++ [ns]  
</code></pre>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">flatten' (Leaf n) ns

= flatten (Leaf n) ++ ns
= [n] ++ ns
n:ns  
</code></pre>

<p>(2) <em>inductive case</em></p>

<pre><code class="haskell">flatten' (Node l r) ns

= (flatten l ++ flatten r) ++ ns
= flatten l ++ (flatten r ++ ns) -- associativity
= flatten' l ++ (faltten r ++ ns) -- hypothesis
= flatten' l (flatten' r ns)
</code></pre>

<p>따라서 <code>flatten'</code>, <code>flatten</code> 은</p>

<pre><code class="haskell">flatten' :: Tree -&gt; [Int] -&gt; [Int]  
flatten' (Leaf n) ns = n:ns  
flatten' (Node l r) ns = flatten' l (flatten' r ns)

flatten :: Tree -&gt; [Int]  
flatten t = flatten' t []  
</code></pre>

<h3 id="compilercorrectness">Compiler Correctness</h3>

<pre><code class="haskell">data Expr = Val Int | Add Expr Expr

eval :: Expr -&gt; Int  
eval (Val n) = n  
eval (Add x y) = eval x + eval y  
</code></pre>

<p>지난번에 만들었던 이 계산 기계를 잘 보면, <em>expression</em> 이 간접적으로 <em>evaluated</em> 됩니다. 스택을 이용해 실행되는 코드의 도움을 받아서요. </p>

<p>자세히 보면 스택은 <em>integer list</em> 고, 코드는 <em>push, add</em> 연산의 리스트입니다. 따라서</p>

<pre><code class="haskell">type Stack = [Int]  
type Code = [Op]  
data Op = PUSH Int | ADD  
</code></pre>

<p>결국 코드를 실행한다는 말은 초기 스택을 받아, 이걸 이용해 계산을 하고 다시 스택을 돌려준다는 뜻입니다.</p>

<pre><code class="haskell">exec :: Code -&gt; Stack -&gt; Stack  
exec []         s       = s  
exec (PUSH n:c) s       = exec c (n:s)  
exec (ADD:c)    (m:n:s) = exec c (m+n:s)  
</code></pre>

<p>이제 <code>Expr</code> 을 <code>Code</code> 로 변경하는 함수 <code>compile</code> 를 만들면</p>

<pre><code class="haskell">compile' :: Expr -&gt; Code  
compile' (Val n) = [PUSH n]  
compile' (Add x y) = compile x ++ compile y ++ [ADD]

compile :: Expr -&gt; Code  
compile e = compile' e  
</code></pre>

<p>그리고 화면에 출력을 위해 <code>Show</code> 를 구현하고 샘플식 <code>e</code> 를 만들면</p>

<pre><code class="haskell">instance Show Expr where  
  show (Val n) = "(Val " ++ show n ++ ")"
  show (Add x y) = "(Add " ++ show x ++ " " ++ show y ++ ")"

instance Show Op where  
  show (PUSH n) = "(PUSH " ++ show n ++ ")"
  show (ADD) = "(ADD)"

e :: Expr  
e = (Add (Add (Val 2) (Val 3)) (Val 4))  
</code></pre>

<pre><code class="haskell">&gt; e
-- (Add (Add (Val 2) (Val 3)) (Val 4))

&gt; eval e
-- 9

&gt; compile e
-- [(PUSH 2),(PUSH 3),(ADD),(PUSH 4),(ADD)]
</code></pre>

<p>잘 보면, 식을 컴파일해서 초기스택 <code>[]</code> 와 함께 실행시킨 것은, <code>[eval e]</code> 와 같다는 것을 알 수 있지요. <code>[]</code> 대신 임의의 스택 <code>s</code> 를 이용하면</p>

<pre><code class="haskell">exec (compile e) s = eval e:s  
</code></pre>

<p>(1) <em>base-case:</em> <code>(Val n)</code></p>

<pre><code class="haskell">exec (compile (Val n)) s

= exec [PUSH n] s
= n : s
eval (Val n) : s -- unapply eval  
</code></pre>

<p>(2) <em>inductive case:</em> <code>(Add x y)</code></p>

<pre><code class="haskell">exec (compile (Add x y)) s

= exec (compile x ++ compile y ++ [ADD]) s
= exec (compile x ++ (compile y ++ [ADD])) s -- associativity
= exec (compile y ++ [ADD]) (exec (compile x) s) -- distributivity of exec
= exec (compile y ++ [ADD]) (eval x:s) -- induction hypothesis for x
= exec [ADD] (exec (compile y) (eval x:s)) -- distributivity
= exec [ADD] (eval y : eval x : s)
= (eval x + eval y) : s -- apply exec
= eval (Add x y) : s -- unapply eval
</code></pre>

<p>위에서 쓴 <code>exec</code> 의 <em>distributivity</em> 를 보이면</p>

<pre><code class="haskell">exec (c ++ d) s = exec d (exec c s)  
</code></pre>

<p><code>c</code> 가 <code>PUSH</code> 일때, 그리고 <code>ADD</code> 일때로 나눠서 증명하면 되죠.</p>

<p>(1) <em>base case</em></p>

<pre><code class="haskell">exec ([] ++ d) s 

= exec d s
= exec d (exec [] s) -- unapply exec
</code></pre>

<p>(2-1) <em>inductive case:</em> <code>PUSH n</code></p>

<pre><code class="haskell">exec ((PUSH n : c) ++ d) s

= exec (PUSH n : (c ++ d)) s
= exec (c ++ d) (n:s)
= exec d (exec c (n:s)) -- induction hypothesis
= exec d (exec (PUSH n:c) s) -- unapply exec
</code></pre>

<p>(2-2) <em>inductive case:</em> <code>ADD</code></p>

<pre><code class="haskell">exec ((ADD : c) ++ d) s  
= exec (ADD : (c ++ d)) s
= exec (ADD : (c ++ d)) (m:n:s') -- assume s == m:n:s'
= exec (c ++ d) (m+n:s') -- apply exec
= exec d (exec c (m+n:s')) -- induction hypothesis
= exec d (exec (ADD : c) (m:n:s')) -- unapply exec
= exec d (exec (ADD : c) s)
</code></pre>

<p><code>s</code> 를 <code>m:n:s'</code> 로 의 가정은 <em>underflow error</em> 를 겪을 수 있는것처럼 보이지만, 실제로는 그렇지 않습니다. 왜냐하면 <code>ADD</code> 연산이 들어있다는 자체가 최소한 두개의 숫자는 스택에 포함한다는 뜻이기 때문입니다. (<code>exec</code> 의 정의를 보세요)</p>

<p>그리고 이전 장에서 <em>append</em> 연산에 적용했던 테크닉을 다시 가져와서, <em>distributivity property</em> 의 <em>underflow</em> 이슈를 예방할 수 있습니다. 이 속성을 유지하도록 하면요</p>

<pre><code class="haskell">compile' e c = compile e ++ c  
</code></pre>

<p>이 속성을 <em>induction</em> 을 이용해서 차근차근 풀면, 아래와 같은 정의를 얻을 수 있습니다.</p>

<pre><code class="haskell">compile' :: Expr -&gt; Code -&gt; Code  
compile' (Val n) c = PUSH n : c  
compile' (Add x y) = compile' x (compile' y (ADD : c))

compile e = compile' e []  
</code></pre>

<p>그러면 <em>compiler correctness</em> 는 </p>

<pre><code class="haskell">exec (compiler' e c) s = exec c (eval e : s)  
</code></pre>

<p>해석은 원문을 첨부하겠습니다.</p>

<blockquote>
  <p>That is, compiling an expression and then executing the resulting code together with arbitrary additional code gives the same result as executing the additional code with the value of the expression on top of the original stack</p>
  
  <p>Note that with <code>s = c = [ ]</code>, this new result simplifies to <code>exec (compile e) [] = [eval e]</code>, our original statement of correctness. </p>
  
  <p>In addition to avoiding the problem of stack underflow in the correctness proof, the accumulator version of the compiler has two further benefits. </p>
  
  <p>First of all, <strong>it avoids the use of ++,</strong> and is hence more efficient. And, </p>
  
  <p>secondly, <strong>the new proof is less than half the combined length of our previous two proofs.</strong> As is often the case in formal reasoning, generalising a result in the appropriate manner can considerably simplify its proof. Mathematics is an excellent tool for guiding the development of efficient programs with simple proofs!</p>
</blockquote>

<h3 id="rosetree">Rose Tree</h3>

<p>로즈 트리는 원소의 개수가 <em>unbounded</em> 인 트리입니다. 이렇게 정의할 수 있습니다.</p>

<pre><code class="haskell">data a = a :&gt; [Rose a] deriving Show  
</code></pre>

<p>여기서 <code>:&gt;</code> 는 <em>constructor</em> 입니다. 생성자가 <em>infix</em> 연산자로 올때는 <code>:</code> 로 시작해야 합니다. <code>deriving Show</code> 는 좀 디버깅 쉬우라고, 화면에 출력하기 위해 사용했습니다.</p>

<p>몇 가지 헬퍼 함수를 만들면,</p>

<pre><code class="haskell">root :: Rose a -&gt; a  
root (x :&gt; xs) = x

children :: Rose a -&gt; [Rose a]  
children (x :&gt; xs) = r

size :: Rose a -&gt; Int  
size (x :&gt; xs) = 1 + sum (map size xs)

leaves :: Rose a -&gt; Int  
leaves (_ :&gt; []) = 1  
leaves (_ :&gt; xs) = 1 + sum (map leaves xs)  
</code></pre>

<p>샘플 로즈 트리를 만들어 봅시다. </p>

<pre><code class="haskell">tree = 'x' :&gt; map (flip (:&gt;) []) ['a'..'z']

-- same as
tree = 'x' :&gt; map (\c -&gt; c :&gt; []) ['a'..'z'] 

&gt; tree
-- 'x' :&gt; ['a' :&gt; [],'b' :&gt; [],'c' :&gt; [],'d' :&gt; [],'e' :&gt; [],'f' :&gt; [],'g' :&gt; [],'h' :&gt; [],'i' :&gt; [],'j' :&gt; [],'k' :&gt; [],'l' :&gt; [],'m' :&gt; [],'n' :&gt; [],'o' :&gt; [],'p' :&gt; [],'q' :&gt; [],'r' :&gt; [],'s' :&gt; [],'t' :&gt; [],'u' :&gt; [],'v' :&gt; [],'w' :&gt; [],'x' :&gt; [],'y' :&gt; [],'z' :&gt; []]

&gt; size tree
-- 27

&gt; leaves tree
-- 26
</code></pre>

<h3 id="functor">Functor</h3>

<p>좀 삼삼하죠? 할게 별로 없으니. <em>rose tree</em> 를 <em>functor</em> 로 만들어 봅시다. 아래 짤방이 아마 세상에서 펑터를 가장 쉽게 설명할겁니다. <code>fmap (+3) (Just 2)</code> 에 대해</p>

<p><img src='http://adit.io/imgs/functors/fmap_just.png'  alt="" /></p>

<p align="center">(<a href='http://adit.io/' >http://adit.io</a>)</p>

<p>즉, <code>Just</code> 는 펑터이므로 <code>2</code> 를 꺼내 <code>+3</code> 을 적용하고, 다시 <code>Just</code> 를 씌워 <code>Just 5</code>로 만들어 줍니다. 그게 <code>fmap</code> 이 하는 일이고, 모든 <em>functor</em> 는 <code>fmap</code> 이 적용 가능합니다. <em>functor</em> 의 정의를 보면</p>

<pre><code class="haskell">class  Functor f  where  
    fmap        :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p>타입이 직관적이죠? <code>a -&gt; b</code> 함수를 받아, <code>f a</code> 에 함수를 적용해서 <code>f b</code> 를 만듭니다. <code>f</code> 는 컨테이너라고 보시면 됩니다. <code>Maybe</code> 같은 것들요 대표적인 <code>Functor</code> 로</p>

<pre><code class="haskell">instance  Functor Maybe  where  
    fmap f Nothing = Nothing
    fmap f (Just x) = Just (f x)


instance  Functor []  where  
    fmap = map 
</code></pre>

<p>그럼 우리가 만든 <code>Rose</code> 는 어떻게 해야 <code>Functor</code> 로 만들 수 있을까요?</p>

<pre><code class="haskell">instance Functor Rose  where  
    fmap g (x :&gt; xs) = g x :&gt; map (fmap g) xs  
</code></pre>

<p>직관적으로 보면 됩니다. 루트에 <code>g</code> 를 적용하고, <code>xs</code> 는 <code>[Rose]</code> 이므로 <code>x :&gt; xs</code> 와 똑같이 취급해서 <code>fmap g</code> 를 적용하면 됩니다. 이 때 지켜줘야 하는 <em>functor laws</em> 는</p>

<pre><code class="haskell">fmap id  ==  id  
fmap (f . g)  ==  fmap f . fmap g  
</code></pre>

<p>그럼 이제, 좀 재미난걸 할 수 있습니다. 이젠 <code>Rose</code> 가 <em>functor</em> 니까요. 다양한 함수를 적용할 수 있죠. </p>

<pre><code class="haskell">tree' = 1 :&gt; map (flip (:&gt;) []) [1..5]

&gt; tree'
-- 1 :&gt; [1 :&gt; [],2 :&gt; [],3 :&gt; [],4 :&gt; [],5 :&gt; []]

&gt; fmap (+1) tree'
-- 2 :&gt; [2 :&gt; [],3 :&gt; [],4 :&gt; [],5 :&gt; [],6 :&gt; []]

&gt; fmap (*10) tree'
-- 10 :&gt; [10 :&gt; [],20 :&gt; [],30 :&gt; [],40 :&gt; [],50 :&gt; []]

&gt; fmap (:&gt; []) tree'
-- (1 :&gt; []) :&gt; [(1 :&gt; []) :&gt; [],(2 :&gt; []) :&gt; [],(3 :&gt; []) :&gt; [],(4 :&gt; []) :&gt; [],(5 :&gt; []) :&gt; []]
</code></pre>

<h3 id="monoid">Monoid</h3>

<p><em>monoid</em> 는 <code>mempty</code>, <code>mappend</code> 두개의 함수를 가지고 있는 <code>m</code> 타입의 인스턴스입니다.</p>

<ul>
<li><code>mappend :: m -&gt; m -&gt; m</code> 은 <em>associative</em> 한 연산자로, 두 <code>m</code> 을 받아서, 하나의 <code>m</code> 으로 합칩니다. </li>
<li><code>mempty :: m</code> 은 <code>mappend</code> 의 <em>neutral element</em> 를 표현합니다. </li>
</ul>

<p>뭔소리야 하실텐데, 우리 주변의 많은 것들이 <em>monoid</em> 입니다. 예제를 봅시다.</p>

<pre><code class="haskell">&gt; (5 + 6) + 10 == 5 + (6 + 10)
True

&gt; (5 * 6) * 10 == 5 * (6 * 10)
True

&gt; ("Hello" ++ " ") ++ "world!" == "Hello" ++ (" " ++ "world!")
True  
</code></pre>

<p><code>[Char]</code> 에서 <code>mempty</code> 는 <code>[]</code> <code>mappend</code> 는 <code>++</code> 입니다. <code>Integer</code> 의 <code>mappend</code> 는 다양한데, <code>+</code> 라면 <code>mempty</code> 가 <code>0</code> 이고, <code>*</code> 라면 <code>mempty</code> 가 <code>1</code> 일 겁니다. 항등원 기억나시죠? 그거랑 비슷합니다.</p>

<pre><code class="haskell">class  Monoid a  where  
    mappend :: a -&gt; a -&gt; a
    mempty  :: m
    mconcat :: [a] -&gt; a
    mconcat :: foldr mappend mempty
</code></pre>

<p><code>mconcat</code> 은 <code>foldr (++) []</code> 를 생각하시면 이해가 쉽습니다. 네! 리스트도 모노이듭니다!</p>

<pre><code class="haskell">instance  Monoid [a]  where  
    mempty = []
    mappend = (++)
</code></pre>

<p>모노이드를 일종의 연산과 그에 대한 항등원이 구현된 클래스라 보셔도 됩니다. 그러면 <code>Sum</code>, <code>Product</code> 모노이드를 만들어 보죠. <code>Rose</code> 에 적용할 수 있을 것 같아요.</p>

<pre><code class="haskell">newtype Sum a = Sum { getSum :: a } deriving Show  
newtype Product a = Product a deriving Show

unProduct :: Product a -&gt; a  
unProduct (Product x) = x

instance Num a =&gt; Monoid (Sum a) where  
  mempty = Sum 0
  Sum x `mappend` Sum y = Sum (x + y)

instance Num a =&gt; Monoid (Product a) where  
  mempty = Product 1
  Product x `mappend` Product y = Product (x * y)
</code></pre>

<p>중간에 보면 <code>unProduct</code> 란게 있는데, 생성자에서 <code>getSum</code> 처럼 <em>accessor</em> 를 만들어 주면 필요 없고, 안만들어 주면 저렇게 만들어서 써야 합니다. 차이점을 보여드리기 위해 두 방법을 모두 사용 해봤어요. 근데, <em>accessor</em> 가 있으면 출력때 같이 나와서 좀 불편합니다.</p>

<pre><code class="haskell">-- 6 * (3 + 4)
&gt; unProduct (Product 6 `mappend` (Product . getSum $ Sum 3 `mappend` Sum 4))

-- 42
</code></pre>

<p>무튼, 이제 모노이드도 있겠다, <code>Rose</code> 에 적용할 수 있습니다. 이게 무슨 뜻이냐면, <code>Rose</code> 컨테이너가 가진 <em>value</em> 가 <code>Product</code>, <code>Sum</code> 연산이 가능하게끔 바꿀 수 있다는 뜻입니다.</p>

<pre><code class="haskell">&gt; tree'
-- 1 :&gt; [1 :&gt; [],2 :&gt; [],3 :&gt; [],4 :&gt; [],5 :&gt; []]

&gt; fmap Sum tree'
-- Sum 1 :&gt; [Sum 1 :&gt; [],Sum 2 :&gt; [],Sum 3 :&gt; [],Sum 4 :&gt; [],Sum 5 :&gt; []]

&gt; fmap Product tree'
-- Product 1 :&gt; [Product 1 :&gt; [],Product 2 :&gt; [],Product 3 :&gt; [],Product 4 :&gt; [],Product 5 :&gt; []]
</code></pre>

<h3 id="foldable">Foldable</h3>

<p><img src='https://www.haskell.org/wikiupload/thumb/3/39/FunctorHierarchy.svg/558px-FunctorHierarchy.svg.png'  alt="" /></p>

<p align="center">(<a href='https://www.haskell.org/' >https://www.haskell.org</a>)</p>

<p><em>foldable</em> 은 진짜 말 그대로 접을 수 있는 연산 <code>fold</code> 를 지원하는 인스턴스를 말합니다.</p>

<pre><code class="haskell">class Foldable t where  
    fold    :: Monoid m =&gt; t m -&gt; m
    foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m

    foldr   :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldr'  :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b

    foldl   :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldl'  :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b

    foldr1  :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a
    foldl1  :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a
</code></pre>

<p>여기선 <code>fold, foldMap</code> 만 다루도록 하죠. <code>fold</code> 의 타입을 보면 아시겠지만, <code>Monoid  m</code> 의 컨테이너인 <code>Foldable t</code> 를 접어서 단일 <code>m</code> 으로 만듭니다.</p>

<p>따라서 복수개의 <code>Sum, Product</code> 를 접어 하나로 만들수 있지요. 어차피 이 두 모노이드에 대해 연산 자체는 정해져 있기 때문에 접는법만 알려주면 됩니다. </p>

<p>그리고 더 중요한 사실은, <code>Rose</code> 가 <code>Foldable</code> 이 되면 <code>Sum</code> 등이 적용된 <code>Rose</code> 를 접어 계산할 수 있습니다. 다시 말해 컨테이너에, 연산을 추가하고, <code>fold</code> 할 수 있다는 이야기지요. </p>

<p>아참! <code>foldMap</code> 은 이름에서 볼 수 있듯이 <code>fmap</code> 후 <code>fold</code> 한다고 생각하면 쉽습니다. <code>fold . fmap</code> 처럼요.</p>

<pre><code class="haskell">class Functor f =&gt; Foldable f where  
  fold :: Monoid m    =&gt; f m -&gt; m
  foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; (f a -&gt; m)
  foldMap = fold $ fmap g a

instance Foldable Rose where  
  fold (x :&gt; xs) = (h.g) xs `mappend` x
    where g = map (fold)
          h = foldr (mappend) mempty
</code></pre>

<p>직관적으로 보면 쉽습니다. <code>h</code> 는 모노이드 <code>m</code> 을 펼치는 역할을 합니다. <code>g</code> 는 <code>f m</code> 을  재귀적으로 펼치구요. 이는 로즈 트리가, 복수개의 자식 노드를 가질 수 있기 때문에 그런건데, 어찌 되었든 펼치면서 노드를 끝에다 붙여 나갑니다. </p>

<p>먼저 로즈 트리를 펼친 후에 모노이드를 합칠거니까, 순서는 <code>(g.h)</code> 입니다.</p>

<p>이제 그러면, 로즈트리가 <em>functor</em> 이므로 모노이드로 감쌀 수 있고 (연산을 지정할 수 있고)    게다가 <em>foldable</em> 이므로 그 연산을 이용해 하나로 접을 수 있습니다. </p>

<pre><code class="haskell">&gt; tree'
-- 1 :&gt; [1 :&gt; [],2 :&gt; [],3 :&gt; [],4 :&gt; [],5 :&gt; []]

&gt; fmap Sum tree'
-- Sum 1 :&gt; [Sum 1 :&gt; [],Sum 2 :&gt; [],Sum 3 :&gt; [],Sum 4 :&gt; [],Sum 5 :&gt; []]

&gt; fold $ fmap Sum tree'
-- Sum 16

&gt; unSum $ fold $ fmap Sum tree'
-- 16
</code></pre>

<p><del>갓스켈</del></p>

<h3 id="references">References</h3>

<p>(1) <strong>DelftX FP 101x</strong> <br />
(2) <em>Programming in Haskell</em> <br />
(3) <a href='http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html' >Functor, Monad, Applicative</a> <br />
(4) <a href='http://en.wikibooks.org/wiki/Haskell/Monoids' >Haskell WikiBooks - Monoids</a> <br />
(5) <a href='https://www.haskell.org/haskellwiki/Foldable_and_Traversable' >Foldable, Traversable</a> <br />
(6) <a href='http://blog.jakubarnold.cz/2014/07/30/foldable-and-traversable.html' >foldable and traversable</a></p>]]></description><link>http://1ambda.github.io/haskell-intro9/</link><guid isPermaLink="false">129bd89e-f8b4-4154-8c14-4f5c61aa2a43</guid><category><![CDATA[edx]]></category><category><![CDATA[haskell]]></category><category><![CDATA[induction]]></category><category><![CDATA[functor]]></category><category><![CDATA[monoid]]></category><category><![CDATA[foldable]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 18 Dec 2014 08:24:13 GMT</pubDate></item><item><title><![CDATA[Substring Search Algorithm]]></title><description><![CDATA[<h3 id="introtosubstringsearch">Intro to Substring Search</h3>

<p><code>N</code> 길이의 텍스트에서 <code>M</code> 길이의 패턴을 찾는 문제다. 일반적으로 <code>N &gt;&gt; M</code> 이다. <code>N</code> 이 좀 많이 (무한히) 길기 때문에 지난시간까지 배운 알고리즘을 적용하기가 좀 힘들다.</p>

<p>(1) <em>suffix sort</em> 를 쓰려고 보니 <em>suffixes</em> 를 만드는 것 자체가 어렵다. 따라서 <em>manber-myers MSD</em> 도 패스.</p>

<p>(2) <em>R-way</em> 든 <em>Ternary</em> 든 <em>tries</em> 자체를 만들기 어렵다. 탐색해야 할 문서는 어마어마하기 때문에 메모리의 양이 모자랄 수 밖에 없다. </p>

<p>뭔가 문서를 <em>streaming</em> 취급하면서 처리할 수 있는 알고리즘이 필요하다.</p>

<p>주된 <em>application</em> 은</p>

<ul>
<li><strong>computer forensics:</strong> search memory, disk for signatures</li>
<li><code>CTRL + F</code></li>
<li><strong>spam filtering:</strong> 특정 패턴이 발견되면 스팸이라 볼 수 있다.</li>
<li><strong>internet traffic monitoring:</strong> 보안</li>
<li><strong>screen scraping:</strong> 관련있는 패턴을 추출할 수 있다.</li>
</ul>

<p>자바에서는 <code>indexOf</code> 메소드가 문자열에서 해당 패턴을 발견해 시작 인덱스를 돌려준다.</p>

<h3 id="bruteforce">Brute Force</h3>

<p><del>언젠가 양자 컴퓨터가 나오면 쓸모 있을까</del></p>

<pre><code class="java">public static int bruteForce(String pattern, String docs) {  
    int M = pattern.length();
    int N = docs.length();

    for (int i = 0; i &lt; N - M; i ++) {
        int j;

        for (j = 0; j &lt; M; j++) 
            if (pattern.charAt(j) != docs.charAt(i + j)) break;

        if (j == M) return i;
    }

    return N;
}
</code></pre>

<p>성능은 <em>worst case</em> 에서 <code>~M N</code> 번의 <em>char compares</em> 가 필요하다. 예를 들어 문서가 <code>AAAAAAAAAAAB</code> 고 패턴이 <code>AAAAAB</code> 면 최악이다.</p>

<h4 id="backup">Backup</h4>

<p>대부분의 <em>application</em> 에서 <em>backup</em> 하길 원치 않는다. 서론에 언급했듯이 스트림처럼 취급하고싶은데, <em>brute force</em> 에서는 <em>backup</em> 이 필요하기 때문에 <em>last <code>M</code> characters</em> 의 버퍼를 유지한다거나의 방법을 쓸 수 있다.</p>

<p>아래의 구현은 똑같은 비교 회수를 가지는데, <em>backup</em> 한다는걸 확실히 보여준다.</p>

<ul>
<li><code>i</code> points to end of sequence of already-matched chars in docs</li>
<li><code>j</code> stores # of already-matched chars (end of sequence in pattern)</li>
</ul>

<pre><code class="java">public static int bruteForceBackup(String pattern, String docs) {  
    int i, N = docs.length();
    int j, M = pattern.length();

    for (i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++) 
        if (docs.charAt(i + j) == pattern.charAt(j)) j++;
        else { i -= j; j = 0; }

    if (j == M) return i - M;
    else return N;
}
</code></pre>

<p>이게 <code>M</code> 이 작으면 문제가 안되는데, <code>M</code> 이 크면 문제가 될 수 있다.</p>

<p>우리가 풀어야 할 문제는</p>

<p>(1) <em>linear-tme guarantee</em> 가 필요 <br />
(2) <em>backup</em> 하지 않기</p>

<h3 id="knuthmorrispratt">Knuth-Morris-Pratt</h3>

<p>아이디어는 간단하다. 매칭에 실패했을 경우, 현재까지 처리한 문자들에 대한 <em>정보</em> 를 가지고 있기 때문에, 이걸 이용해서 필요 없는 부분을 건너 뛴다.</p>

<pre><code>// pattern: BAAAAAAAAA

A B A A A A B A A A A A A A A A  
  B A A A A ^ // fail
            B // ignore previous chars
</code></pre>

<h4 id="dfa">DFA</h4>

<p><em>Knuth-Morris-Pratt</em> 알고리즘은 <em>deterministic finite state automation, DFA</em> 란 것에 이론적으로 기반한다.</p>

<p><em>DFA</em> 는 <em>abstract string-searching machine</em> 이다.</p>

<ul>
<li>Finite number of states (including start and halt)</li>
<li><strong>Exactly one transition</strong> for each char in alphabet</li>
<li>Accept if sequence of transitions leads to half state</li>
</ul>

<p><img src='http://www-igm.univ-mlv.fr/' ~lecroq/string/images/rwadfa2.png" alt="" /></p>

<p align="center">(<a href='http://www-igm.univ-mlv.fr/' >http://www-igm.univ-mlv.fr</a>)</p>

<p>더 크게 보면 <em>DFA</em> 는 <em>Finite State Machine, FSM</em> 의 한 종류다. <em>DFA</em> 말고도 <em>Nondeterministic Finite Automata, NFA</em> 가 있는데,  차이점은 이렇다.</p>

<blockquote>
  <p>비결정적 유한 오토마타는 결정적 유한 오토마타와는 다르게 입력 기호에 대해서 <code>\epsilon</code>-transition 에 의해 0개 이상의 이동이 가능하다. 만약 가능한 다음 상태의 경우가 없다면, 기계는 입력을 거부한다.</p>
</blockquote>

<p>결정적 유한 오토마타는 입력값에 대해 출력 값이 1개라는 소리 같은데, 좀 모호해서 더 찾아봤다. <a href='http://math.stackexchange.com/questions/563829/difference-between-nfa-and-dfa' >여기</a> 에 의하면</p>

<blockquote>
  <p>Each input to a <strong>DFA</strong> or <strong>NFA</strong> affects the state of the automaton: if it was in state q immediately before the input, either it will be in some state q′ after the input, or the input will cause it to choke. (Note that q′ may be the same as q.) Suppose that we have an automaton in a state q. The difference in behavior between a DFA and an NFA is this:</p>
  
  <ul>
  <li><p>If it’s a <strong>DFA</strong>, each possible input determines the resulting state q′ uniquely. Every input causes a state change, and the new state is completely determined by the input. Moreover, the automaton can change state only after reading an input.</p></li>
  <li><p>If it’s an <strong>NFA</strong>, some inputs may allow a choice of resulting states, and some may cause the automaton to choke, because there is no new state corresponding to that input. Moreover, the automaton may be constructed so that it can change state to some new state q′ without reading any input at all.</p></li>
  </ul>
  
  <p>As a consequence of this difference in behavior, DFA’s and NFA’s differ in another very important respect.</p>
  
  <ul>
  <li><p>If you start a <strong>DFA</strong> in its initial state and input some word w, the state q in which the DFA ends up is completely determined by w: inputting w to the DFA will always cause it to end up in state q. This is what is meant by calling it deterministic.</p></li>
  <li><p>If you start an <strong>NFA</strong> in its initial state and input some word w, there may be several possible states in which it can end up, since some of the inputs along the way may have allowed a choice of state changes. Consequently, you can’t predict from w alone in exactly which state the automaton will finish; this is what is meant by calling it nondeterministic. (And it’s actually a little worse than I’ve indicated, since an NFA is also allowed to have more than one initial state.)</p></li>
  </ul>
  
  <p>Finally, these differences affect how we determine what words are accepted (or recognized) by an automaton.</p>
  
  <ul>
  <li><p>If it’s a <strong>DFA</strong>, we know that each word completely determines the final state of the automaton, and we say that the word is accepted if that state is an acceptor state.</p></li>
  <li><p>If it’s an <strong>NFA</strong>, there might be several possible final states that could result from reading a given word; as long as at least one of them is an acceptor state, we say that the automaton accepts the word.</p></li>
  </ul>
</blockquote>

<p><del>갓 아메리카</del></p>

<p>똑같은 입력에 대해 <em>NFA</em> 는 다양한 최종상태를 만들 수 있다고 한다. 그래서 그 중 하나라도 <em>accept</em> 되면, 처리 된 것으로 받아들인다고 함. 어디서 주워들은 <em>NP hardness</em> 와 비스무리한 개념인것 같다. 그림을 다시 보면</p>

<p><img src='http://www-igm.univ-mlv.fr/' ~lecroq/string/images/rwadfa2.png" alt="" /></p>

<p align="center">(<a href='http://www-igm.univ-mlv.fr/' >http://www-igm.univ-mlv.fr</a>)</p>

<p>검색하려는 패턴, 즉 <em>desired state</em> 나열하고 <em>transition</em> 를 그려가며 <em>DFA</em> 를 만든다. 이를 이용해 텍스트를 파싱하면서 <em>final state</em> 에 도달하는지 보면 된다.    </p>

<p>구현은 </p>

<pre><code class="java">public int kmpStringSearch(String docs, String pattern) {  
  int i, j;
  int N = docs.length(), M = pattern.length();
  Int[][] dfa = createDFA(pattern);

  for (i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++) {
    j = dfa[txt.charAt(i)][j];
  }

  if (j == M) return i - M 
  else N
}
</code></pre>

<p>재밌는 사실은 <em>backup</em> 이 더이상 필요 없기 때문에 입력을 <em>stream</em> 으로 받을 수도 있다.</p>

<pre><code>public int kmpStringSearch(In in, String pattern) {  
  int i, j;
  int M = pattern.length();
  Int[][] dfa = createDFA(pattern);

  for (i = 0, j = 0; !in.isEmpty() &amp;&amp; j &lt; M; i++) {
    j = dfa[in.readChar()][j];
  }

  if (j == M) return i - M 
  else N
}
</code></pre>

<p>따라서 <em>running time</em> 은 <em>DFA</em> 만 있다면 확실히 <code>N</code> 번의 <em>char access</em> 다. 그럼 이제 문제는, <em>DFA</em> 를 만드는데 얼마나 시간이 걸릴것 인가? </p>

<p><em>DFA</em> 를 만들면서 알아보자. <code>ABABAC</code> 의 패턴이 있을때</p>

<p>(1) <em>match transition</em></p>

<p>현재 상태가 <code>j</code> 이고 다음 문자인 <code>c</code> 가 <code>c == pattern.charAt(j)</code> 이면 <em>match transition</em> 이므로 <code>j++</code> 이다.</p>

<p>따라서 패턴 <code>ABABAC</code> 의 <em>DFA</em> 는</p>

<pre><code>               j     0 1 2 3 4 5 
pattern.charAt(j)    A B A B A C

dfa[][j]          A  1   3   5  
                  B    2   4  
                  C            6                  
</code></pre>

<p>(2) <em>mismatch transition</em></p>

<p>상태 <code>j</code> 에서 <code>c != pattern.chatAt(j)</code> 이면, <em>mismatch</em> 다. 그러면  방금 전까지 만든 <code>j-1</code> 까지의 <em>DFA</em> 를 이용해서 <code>pattern[1 .. j-1]</code> 까지를 인풋으로 넣어 돌리면 된다. 무슨말인고 하니</p>

<p><code>ABABAC</code> 에서 현재 <em>state</em> 가 <code>5</code> 면, 다음 인풋으로 <code>C</code> 를 받아야한다. <code>ABABA^C</code> 이렇게 표기하자. 그러면, <code>ABABA</code> 까지의 <em>DFA</em> 를 만들었으므로, 첫 문자 <code>A</code> 를 버리고 다음 문자 <code>C</code> 를 포함해서 <code>BABAC</code> 를 인풋으로 해서 <em>DFA</em> 를 돌리면 된다.</p>

<p>예를 들어 <code>j = 5</code>, <code>c = A, B</code> 에 대해 <code>j = 4</code> 까지의 <em>DFA</em> 를 짓고</p>

<pre><code>               j     0 1 2 3 4 5 
pattern.charAt(j)    A B A B A C

dfa[][j]          A  1 1 3 1 5  
                  B  0 2 0 4 0
                  C  0 0 0 0 0 6                  
</code></pre>

<p>에 대해서 <code>BABA</code> 를 반복하면, <code>j = 3</code> 이다. 따라서</p>

<ul>
<li><code>dfa['A'][5] = dfa['A'][3] = 1</code></li>
<li><code>dfa['B'][5] = dfa['B'][3] = 4</code></li>
</ul>

<p>이게 잘 보면 매번 <code>j - 1</code> 의 스텝을 반복해야하는 걸로 보일 수 있는데, 그러지 말고 <code>pattern[1 .. j-1]</code> 을 <em>state</em> <code>X</code> 라 부르고, 이걸 유지하면 <em>transition</em> 을 <em>constant time</em> 으로 지을 수 있다. 즉 <code>j</code> 가 하나 증가할 때 마다 </p>

<p><code>X = dfa[pattern.charAt(j)][X]</code></p>

<p>이렇게 <code>X</code> 를 업데이트하면, <code>j - 1</code> 까지의 상태가 <code>X</code> 다. 따라서 <em>DFA</em> 를 <em>linear time</em> 으로 만들 수 있다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTT3lJR08zSUdOalZUTm1WV0x6UVRPaDFDTmhkek10RXpZeFFXTGpWR1p3a1RZekkyTDRnek0wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<h4 id="performance">Performance</h4>

<p><em>DFA</em> 를 만드는 속도는 <code>M</code> <em>char access</em> 이므로 전체 문서를 검색하는데 걸리는 시간은 <code>M + N</code> <em>char access</em> 다. (<code>M</code> 은 패턴의 길이, <code>N</code> 은 문서의 길이)</p>

<p>그러나 <em>DFA</em> 를 만드는데 필요한 메모리가 <code>R * M</code> 이다.</p>

<p><em>NFA</em> 를 이용하면 <em>KMP</em> 알고리즘을 더 개선할 수 있다. <code>M</code> 에 비례하는 시간, 공간만으로도 패턴을 문서에서 탐색할 수 있다고 한다. <a href='http://algs4.cs.princeton.edu/53substring/KMPplus.java.html' >KMPplus.java</a></p>

<h4 id="kmpimplementation">KMP Implementation</h4>

<p>구현하면</p>

<pre><code class="java">public class DFA {

    int[][] dfa;

    public DFA(String pattern, int R) {
        int M = pattern.length();

        // initialize
        dfa = new int[R][];
        for (int r = 0; r &lt; R; r++)
            dfa[r] = new int[M];

        dfa[pattern.charAt(0)][0] = 1;

        // build DFA
        for (int X = 0, j = 1; j &lt; M; j++) {
            // mismatch
            for (int c = 0; c &lt; R; c++)
                dfa[c][j] = dfa[c][X];

            // match
            dfa[pattern.charAt(j)][j] = j + 1;

            // update X
            X = dfa[pattern.charAt(j)][X];
        }
    }

    public int search(String docs) {

        int i, j, M = pattern.length(), N = docs.length();

        for (i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++) {
            j = dfa[docs.charAt(i)][j];
        }

        if (j == M) return i - M;
        else return N;
    }
}
</code></pre>

<h3 id="boyermoore">Boyer-Moore</h3>

<p><em>KMP</em> 알고리즘은 <em>linear time</em> 인데, 이보다 더 빠르게 할 수 있을까?</p>

<p><br/></p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDTmtkVE5qaHpZaWRUWWhSVEx5STJNaDFDWmlCek10SUdaeFlUTGlGVE0yRVdPakp6TDRJRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com</a>)</p>

<p>패턴의 우측부터 매칭해 가면, 꽤나 많은 <code>M</code> 사이즈의 텍스트를 빠르게 제낄 수 있다. 문제는 패턴이 어디까지 매칭되었는지에 따라 스킵할 수 있는 문자가 다르다는 것이다. 경우를 좀 나눠서 살펴보자 <code>i</code> 는 현재 문서의 탐색할 인덱스를, <code>^</code> 는 <em>mismatch</em> 를 나타낸다.</p>

<pre><code class="java">// case 1

          i     ^
. . . . . . . . T L E . . . . 
          N E E D L E

                  i
. . . . . . . . T L E . . . . 
                  N E E D L E
</code></pre>

<p><em>case 1</em> 은 운이 좋아서, 미스매치 <code>T</code> 가 패턴에 없기 때문에 <code>T</code> 다음으로 <code>i</code> 를 옮길 수 있다.</p>

<pre><code class="java">// case 2a

          i     ^
. . . . . . . . N L E . . . . 
          N E E D L E

                i 
. . . . . . . . N L E . . . . 
                N E E D L E
</code></pre>

<p>여기선 <em>mismatch</em> 문자 <code>N</code> 이 패턴에 있기 때문에 <em>rightmost</em> <code>N</code> 을 찾아 다시 비교를 시작한다. (우측부터 비교하기 때문)</p>

<pre><code class="java">// case 2b

          i     ^
. . . . . . . . E L E . . . . 
          N E E D L E

// rightmost 'E'          

      i          
. . . . . . . . E L E . . . . 
      N E E D L E


// just increament `i` by 1

                i         
. . . . . . . . E L E . . . . 
            N E E D L E
</code></pre>

<p>이 경우엔 <em>rightmost</em> <code>E</code> 가 별로 도움이 안되므로, 그냥 <code>i</code> 를 증가시킨다.</p>

<p>다시 한번 정리하면, </p>

<p>(1) 우측부터 시작해서 비교하다 <em>mismatch</em> 문자가 있을 때 필요 없는 문자를 몇개나 제낄 수 있느냐 하는 문제는, 패턴 안에서 해당 <em>mismatch</em> 문자가 있느냐 없느냐에 따라 다르다.</p>

<p>(2) 없다면 모두 제껴버리면 되는거고, </p>

<p>(3) 있다면 그 문자가 얼마나 우측에 오느냐에 따라 스킵할 수 있는 문자의 수가 달라진다. 우측에 오면 올 수록 거기서 부터 다시 비교해야 하기 때문에, <em>heuristic</em> 이 별로 도움이 안될 수도 있다. <em>case 2b</em> 가 바로 그 예다. 그럴때는 그냥 1 만큼 증가시키는것이 더 나을 수도 있다. </p>

<p><em>skip table</em> 을 만들면</p>

<pre><code class="java">int M = pattern.length();  
int[] right = new int[R];

for (i = 0; i &lt; R; i++) right[i] = -1;  
for (j = 0; j &lt; M; j++) right[pattern.charAt(j)] = j;  
</code></pre>

<p>이 테이블을 이용해 탐색을 하면</p>

<pre><code class="java">int N = docs.length();  
int M = pattern.length();

for (int i = 0; i &lt;= N - M; i++) {  
  int skip = 0;

  for (int j = M - 1; j &gt;=0; j--) {
    if (docs.charAt(i + j) != pattern.charAt(j)) {
      skip = Math.max(1, j - right[docs.charAt(i + j)]);
      break;
    }
  }

  if (skip == 0) return i;
}

return N;  
</code></pre>

<p>이 알고리즘에서 <code>skip</code> 을 계산하는 부분을 잘 보면</p>

<pre><code class="java">skip = Math.max(1, j - right[docs.charAt(i + j)]);  
</code></pre>

<p>현재 비교가 진행된 <code>j</code> 에서 <em>mismatch</em> 문자의 인덱스를 뺄셈해서 1 보다 큰지를 비교한다. 만약 1 보다 작다면, 다시 말해 <code>0</code> 이나 음수라면 <code>skip</code> 이 마이너스로, 즉 왼쪽으로 되기 때문에 스킵할 필요가 없다. 그냥 우측으로 <code>+1</code> 해서 다시 비교하면 된다.</p>

<p>전체 코드는</p>

<pre><code class="java">public class BoyerMoore {

    int[] right;
    String pattern;

    public BoyerMoore(String pattern, int R) {

        this.pattern = pattern;
        int M = pattern.length();

        // initialize skip table
        right = new int[R];
        for (int i = 0; i &lt; R; i++) right[i] = -1;
        for (int j = 0; j &lt; M; j++) right[pattern.charAt(j)] = j;
    }

    public int search(String docs) {

        int M = pattern.length();
        int N = docs.length();

        for (int i = 0; i &lt;= N - M; i++) {
            int skip = 0;

            for (int j = M - 1; j &gt;=0; j--) {
                if (pattern.charAt(j) != docs.charAt(i + j)) {
                    // calculate skip value
                    skip = Math.max(1, j - right[docs.charAt(i + j)]);
                    break;
                }
            }

            if (skip == 0) return i;
        }

        return N;
    }
}
</code></pre>

<p>이건 <em>bad character</em> 라는 특성을 이용한 방법이고, <em>good suffix</em> 등을 과 비교하여 얼마나 더 스킵할지를 결정할 수 있다. </p>

<p>보이어 무어 알고리즘에 대한 설명은 <a href='http://xenostudy.tistory.com/72' >여기</a>가 제일 잘 되어있다. </p>

<h4 id="performance">Performance</h4>

<p>일반적으로는(휴리스틱) <code>~N/M</code> 의 <em>char compare</em> 비교를 한다고 알려져있다. <em>sublinear</em> 한건데, </p>

<p><em>worst case</em> 에서는 <code>~ MN</code> 이다. 예를 들어 패턴이 <code>ABBBB</code> 고 문서가 <code>BBBBBBBBBBBBBBBBB..</code> 일때 최악이다.</p>

<p><em>worst case</em> 를 <code>~3N</code> 까지 개선할 수 있다. <em>KMP-like rule</em> 을 더해 반복적인 패턴을 비하면 된다.</p>

<p>실제로 보이어 무어 알고리즘은 검색할 문자열이 길때 효과가 있다. 그래야 스킵할것이 많기 때문이다. 그러나 대부분의 경우 검색어가 그다지 길지 않다는 것.</p>

<h3 id="rabinkarp">Rabin-Karp</h3>

<p><img src='http://terpconnect.umd.edu/' ~sthomas2/images/rabinkarp.jpg" alt="" /></p>

<p align="center">(<a href='http://terpconnect.umd.edu/' >http://terpconnect.umd.edu</a>)</p>

<p>기본 아이디어는 <em>modular hashing</em> 이다. 인덱스를 하나씩 증가시켜가면서 문자열의 해싱 값을 비교한다.</p>

<p>먼저 해야할 일은 <em>hash function</em> 을 만드는 건데, <code>t_i</code> 를 문서(<code>txt</code>) 의 <code>i</code> 번째 캐릭터라 하면</p>

<p><img src='http://chart.apis.google.com/chart?cht=tx&amp;chl=x_t%20%3D%20t_i%20R%5E%7BM-1%7D%5C%20%20%2B%5C%20%20t_%7Bi%2B1%7D%20R%5E%7BM-2%7D%5C%20%20%2B%5C%20%20%5Ccdots%20%5C%20%5C%20%20%2B%5C%20%20%20t_%7Bi%2BM-1%7D%20R%5E%7B0%7D%5C%20%5C%20%20' (mod)%5C%20%5C%20%20Q" alt="" /></p>

<p>여기서 <code>M</code>-<em>digit</em>, <code>R</code>-<em>base</em>, <code>Q</code> modulo 다. <code>M</code>-<em>degree</em> 다항식인데, <em>Horner's method</em> 를 쓰면 중복된 계산 없이 <em>linear time</em> 으로 <em>evaluation</em> 가능하다. </p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTWjBnak1rUkRPeUVqWWpSVEwwRW1NaDFpWjVVek10WVROME1UTDNjVFl4SUdaemt6TDNjRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com/</a>)</p>

<p>난 첨에 뭔소린가 했는데 다항식의 값을 구할 때 중복된 계산을 피하기 위해 이렇게 구현하는걸 말한다.</p>

<p><img src='http://web-ext.u-aizu.ac.jp/course/alg1/ex/uk/ex04/horner2.png'  alt="" /></p>

<p><code>R</code> 에 대한 다항식이기 때문에, 해싱함수의 구현은</p>

<pre><code class="java">private long hash(String key, int M, int Q) {  
  long h = 0;

  for(int j = 0; j &lt; M; j++)
    h = (R * h + key.charAt(j)) % Q;

  return h;
}
</code></pre>

<p><code>x_i</code> 의 해싱값을 계산하고, 매칭이 안되면 다음으로 넘어가 <code>x_(i+1)</code> 을 계산해야 한다. 그런데, 좀 더 효율적으로 할 수 있는 방법이 없을까? 당연히 가능하다. 두 해싱값 서로 다른 1개의 항 빼고는 모두 같은 항을 가지고 있기 때문이다. </p>

<p><img src='http://chart.apis.google.com/chart?cht=tx&amp;chl=x_i%5C%20%20%3D%5C%20t_iR%5E%7BM-1%7D%5C%20%2B%5C%20t_%7Bi%2B1%7DR%5E%7BM-2%7D%5C%20%2B%5C%20%5Ccdots%5C%20%2B%5C%20t_%7Bi%20%2B%20M%20-%201%7DR%5E0%5C%5C%0A%5C%20%5C%5C%20%0A%5C%20%5C%5C%0A%5C%20%5C%5C%0A%5C%20%5C%5C%0A%5C%20%5C%5C%0Ax_i%5C%20%20%3D%5C%20t_%7Bi%20%2B%201%7DR%5E%7BM-1%7D%5C%20%2B%5C%20t_%7Bi%2B1%7DR%5E%7BM-2%7D%5C%20%2B%5C%20%5Ccdots%5C%20%2B%5C%20t_%7Bi%20%2B%20M%7DR%5E0'  alt="" /></p>

<p>따라서 <code>x_(i+1)</code> 은</p>

<p><img src='http://chart.apis.google.com/chart?cht=tx&amp;chl=x_%7Bi%2B1%7D%5C%20%20%3D%5C%20%20' (x_i%5C%20%20%5C%20-%20t_iR%5E%7BM-1%7D)%5C%20%20*%5C%20%20R%5C%20%2B%5C%20%20t_%7Bi%2BM%7D%20" alt="" /></p>

<p>이므로, 상수 시간 내에 다음 문자열의 해시값을 구할 수 있다. 따라서 매 <code>i</code> 마다 상수 시간이므로 <code>~N</code> 으로 패턴을 찾을 수 있다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTmhKR00yWVROaEpHT2psVEwzTW1ONTBpWndjek10Z1RNbGxUTHpNR054WVdPM1l6TDVjRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(<a href='http://www.programering.com/' >http://www.programering.com/</a>)</p>

<h4 id="implementation">Implementation</h4>

<p>전체 코드는 <a href='http://algs4.cs.princeton.edu/53substring/RabinKarp.java.html' >RabinKarp.java</a> 로</p>

<pre><code class="java">public class RabinKarp {

    String pattern;
    long patternHash;
    int M;
    long Q;
    int R;
    long RM; // R^(M-1) % Q

    public RabinKarp(String pattern) {
        this.pattern = pattern;

        R = 25;
        M = pattern.length();
        Q = longRandomPrime();

        // pre-compute R^(M-1) % Q for use in removing leading digit
        RM = 1;
        for (int i = 1; i &lt;= M-1; i++)
            RM = (RM * R) % Q;

        patternHash = hash(pattern, M);
    }

    private long hash(String key, int M) {
        long h = 0;

        for (int j = 0; j &lt; M; j++)
            h = (R * h + key.charAt(j)) % Q; 
        return h;
    }

    private static long longRandomPrime() {
        BigInteger prime = BigInteger.probablePrime(31, new Random());
        return prime.longValue();
    }

    public int search(String docs) {
        int N = docs.length();
        long docsHash = hash(docs, M);

        if (docsHash == patternHash) return 0;

        for (int i = M; i &lt; N; i++) {
            // remove leading digit
            docsHash = (docsHash + Q - RM * docs.charAt(i-M) % Q) % Q;
            // add trailing digit
            docsHash = (docsHash * R + docs.charAt(i)) % Q;

            // match
            if (patternHash == docsHash) return i - M + 1;
        }

        return N;
    }
}
</code></pre>

<p>참고로, 해시값을 비교하는 것에는 두 가지 버전이 있다.</p>

<p>(1) <strong>Monte Carlo version:</strong> return match if hash match <br />
(2) <strong>Las Vegas version:</strong> check for substring match if hash match and continue search if false collision.</p>

<p>몬테 카를로는 확률적으로 여러번 구해서 맞는 값을 찾는거다. 근데 만약에 <code>Q</code> 가 <code>MN^2</code> 정도로 상당히 크다면, 충돌이 일어날 확률은 <code>1/N</code> 이다.</p>

<p>실제 돌려보면 <code>Q</code> 를 충분히 크게 고르되, 오버플로우가 안 일어나면 <code>1/Q</code> 의 적은 확률로 충돌이 일어난다.</p>

<p>따라서</p>

<p>(1) <strong>Monte Carlo version</strong></p>

<ul>
<li>Always runs in linear time</li>
<li>Extremely likely to return correct answer (but not always)</li>
</ul>

<p>(2) <strong>Las Vegas version</strong></p>

<ul>
<li>Always returns correct answer</li>
<li>Extremely likely to run in linear time (but worst case is <code>M N</code>)</li>
</ul>

<p>라스베가스 버전에서 <em>worst case</em> 는, 충돌이 매번 나고 매번 검사하는건데. 그럴 일은 거의 없다.</p>

<h4 id="prosandcons">Pros and cons</h4>

<p><em>rabin-karp</em> 알고리즘은 앞서 보았던 <em>KMP</em> 나 <em>boyed moore</em> 에 비해 장점이 있는데</p>

<ul>
<li>Extends to 2d patterns</li>
<li>Extends to finding multiple patterns</li>
</ul>

<p>예를 들어서 다양한 패턴을 찾고싶다 하면, 그 패턴들의 심볼 테이블을 만들어 놓고 검색하면 된다.</p>

<p>단점으로는</p>

<ul>
<li>Arithmetic ops slower than char compares</li>
<li>라스베가스 버전은 백업을 필요로 함</li>
<li>poor worst case guarantee</li>
</ul>

<h3 id="summary">Summary</h3>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWTVNMlkxWVdOMUVXTXdJV0w0TWpZaDF5TjJrek10WTJZM0lXTDRjek5pSldabFIyTDBrRE4wOHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Ro$bert Sedgewick</strong> <br />
(2) <a href='http://introcs.cs.princeton.edu/java/73dfa/' >http://introcs.cs.princeton.edu</a> <br />
(3) <a href='http://math.stackexchange.com/questions/563829/difference-between-nfa-and-dfa' >Difference between NFA and DFA</a> <br />
(4) <a href='http://www-igm.univ-mlv.fr/' ~lecroq/string/node4.html">Automaton</a> <br />
(5) <a href='http://somemoreacademic.blogspot.kr/2012/09/boyer-moore-string-matching-algorithm.html' >Boyer Moore string matching algorithm</a> <br />
(6) <a href='http://xenostudy.tistory.com/72' >보이어 무어 알고리즘에 대한 고찰</a> <br />
(7) <a href='http://terpconnect.umd.edu/' ~sthomas2/rabin-karp.html">Rabin-Karp Algorithm</a></p>]]></description><link>http://1ambda.github.io/substring-search/</link><guid isPermaLink="false">2c08e92e-2241-4624-988e-32d552ed67e1</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[substring search]]></category><category><![CDATA[boyer-moore]]></category><category><![CDATA[rabin-karp]]></category><category><![CDATA[knuth-morris-pratt]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 17 Dec 2014 15:16:42 GMT</pubDate></item><item><title><![CDATA[Reactive Programming 1, Monads]]></title><description><![CDATA[<h3 id="whatisreactiveprogramming">What is Reactive Programming?</h3>

<p><em>reactive</em> 란 뜻은</p>

<ul>
<li><em>React to events</em> <strong>(event-driven)</strong></li>
<li><em>React to load</em> <strong>(scalable)</strong></li>
<li><em>React to failures</em> <strong>(resilient)</strong></li>
<li><em>React to users</em> <strong>(responsive)</strong></li>
</ul>

<h4 id="eventdriven">Event-driven</h4>

<p><em>event-driven</em> 을 통해 <em>scalable, resilient</em> 해질 수 있고, 이 3가지를 통해 <em>responsive</em> 한 서비스를 만들 수 있다.</p>

<p>옛날에는 시스템이 <em>multi-threaded</em> 로 구성되어 <em>shared, synchronized state</em> 를 통해 커뮤니케이션 했었다. 그래서</p>

<blockquote>
  <p>Strong coupling, hard to compose</p>
</blockquote>

<p>근데 요즘 시스템은 <em>loosely coupled even handlers</em> 로 구성되기 때문에</p>

<blockquote>
  <p>Events can be handled asynchoronously, without blokcing</p>
</blockquote>

<h4 id="scalable">Scalable</h4>

<blockquote>
  <p>An application is <strong>scalable</strong> if it is able to be expanded according ot its usage</p>
</blockquote>

<ul>
<li><strong>scale up:</strong> make use of parallelism in multi-core systems</li>
<li><strong>scale out:</strong> make use of multiple server nodes</li>
</ul>

<blockquote>
  <p><strong>Important for scalability:</strong> minimize shared mutable state</p>
  
  <p><strong>Important for scale out:</strong> location transparency, resilience</p>
</blockquote>

<h4 id="resilient">Resilient</h4>

<blockquote>
  <p>An application is <strong>resilient</strong> if it can recover quickly from failures</p>
</blockquote>

<p>일반적으로 <em>resilience</em> 는 나중에 (<em>afterthought</em>) 추가하기 어렵다. 시작부터 디자인의 일부로 고려해야한다. 이를 위해</p>

<ul>
<li>loose coupling</li>
<li>strong ecapsulation of state</li>
<li>pervasive supervisor hierarchies</li>
</ul>

<h4 id="responsive">Responsive</h4>

<blockquote>
  <p>An application is <strong>responsive</strong> if it provides rich, real-time interaction with its users even under load and in the presence of failures.</p>
  
  <p>Responsive applications can be built on an event-driven, scalable, and resilient architecture</p>
  
  <p>Still need careful attention to algorithms, system design, back-pressure, and many other details.</p>
</blockquote>

<h4 id="callback">Callback</h4>

<p>보통 이벤트를 다루기 위해 <em>callback</em> 이 사용되는데 자바를 예로 들면</p>

<pre><code class="scala">class Counter extends ActionListener {  
  private var count = 0
  button.addActinoListener(this)

  def actionPerformed(e: ActionEvent): Unit = {
    count += 1
  }
}
</code></pre>

<p>여기서 볼 수 있는 문제는 </p>

<p>(1) <em>shared mutable state</em> 가 필요하다 <br />
(2) <em>composing</em> 하기 힘들다 <br />
(3) 시스템이 커지면 <em>callback hell</em> 이 될 수 있다</p>

<h4 id="composableeventabstraction">Composable Event Abstraction</h4>

<p>일반적으로 함수형 프로그래밍에서 이를 해결하기 위한 방법은 <em>composable event abstraction</em> 이다.</p>

<ul>
<li>Events are first class</li>
<li>Events are often represented as messages</li>
<li>Handlers of events are also first-class</li>
<li>Complex handlers can be composed from primitive ones</li>
</ul>

<p>이 수업에서 다룰 내용은 <em>monad</em>, <em>future</em>, <em>observables</em>, <em>actor</em>, <em>supervisor</em>, <em>distributed actor</em> 등이다.</p>

<h4 id="functionpatternmaching">Function, Pattern Maching</h4>

<p>잠깐 복습하고 가면 <em>JSON</em> 을 모델링 하기 위해서</p>

<pre><code class="scala">abstract class JSON  
case class JSeq (elems: List[JSON])           extends JSON  
case class JObj (bindings: Map[String, JSON]) extends JSON  
case class JNum (num: Double)                 extends JSON  
case class JStr (str: String)                 extends JSON  
case class JBool (b: Boolean)                 extends JSON  
case class JNull                              extends JSON  
</code></pre>

<p>그러면 요로코롬 데이터를 표현할 수 있다.</p>

<pre><code class="scala">  val data = JObj(Map(
    "firstName"   -&gt; JStr("Jason"),
    "lastName"    -&gt; JStr("Bone"),
    "phoneNumber" -&gt; JSeq(List(
      JObj(Map(
        "type" -&gt; JStr("home"), "number" -&gt; JStr("212 555 3347"),
        "type" -&gt; JStr("fax"),  "number" -&gt; JStr("33312 555 3347")
      ))
    ))
  ))
</code></pre>

<p>자바스크립트에서 이거랑 똑같다. 좀 스칼라 버전이 복잡해 보이는데, 오더스키 말로는 더 문법적으로 간편하도록 작성할 수 있다고 한다. 아마 어디 라이브러리에 구현되어있을듯</p>

<pre><code class="javascript">data = {  
  "firstName": "Json",
  "lastName": "Bone",
  "phoneNumber": [
    { "type: "home", "number", "212 555 3347" },
    { "type: "fax",  "number", "33312 555 3347" }
  ]
}
</code></pre>

<p>이제 <code>JSON</code> 을 출력하는 <code>show</code> 함수를 만들어 보면</p>

<pre><code class="scala">  def show(json: JSON): String = json match {
    case JSeq(elems) =&gt; "[" + (elems map show mkString ", ") + "]"
    case JObj(bindings) =&gt;
      val assocs = bindings map {
        case (key, value) =&gt; "\"" + key + "\":" + show(value)
      }
      "{" + (assocs mkString ", ") + "}"

    case JNum(num) =&gt; num.toString
    case JStr(str) =&gt; "\"" + str + "\""
    case JBool(b) =&gt; b.toString
    case JNull() =&gt; "null"
  }
</code></pre>

<p><em>case class</em> 가 나와서 잠깐 보면 다음 타입은 무엇일까?</p>

<pre><code class="scala">{ case (key, value) =&gt; ...  }
</code></pre>

<p>이것 자체로는 아무 타입이 아닌데, 타입을 지정해 주면 <em>function</em> 이 될 수 있다. 무슨말인고 하니</p>

<pre><code class="scala">type JBinding = (String, JSON)  
val f = { case (key, value) =&gt; ...  } // error  
val f: JBinding =&gt; String = { case (key, value) =&gt; ...  }  
</code></pre>

<p>두 번째 <code>val</code> 만 성공적으로 컴파일된다. 그리고 스칼라에서 모든 구체적인 타입은 <em>class</em> 나 <em>trait</em> 의 구현체인데 <em>function</em> 도 마찬가지다.</p>

<p><code>JBinding =&gt; String</code> 은 <code>scala.Function1[JBinding, String]</code> 이다. 다시 말해서 모든 함수는 <code>Function</code> <em>trait</em> 의 구현이다.</p>

<pre><code class="scala">trait Function[-A, +R] {  
  def apply(x: A): R
}
</code></pre>

<p>여기서 <code>-A</code>, <code>+R</code> 등은 <em>variance</em> 와 관련된 것인데, 이 <em>variance</em> 란 것이 어떤 두 타입사이에 관계가 있다면, 컨테이너에 넣었을때의 관계는 어떠한가를 기술하는 것이다. </p>

<ul>
<li><code>S &lt;: T</code> means <strong>S is a subtype of T</strong></li>
<li><code>S :&gt; T</code> means <strong>S is a supertype of T</strong></li>
</ul>

<p>이걸 <em>bound</em> 라 부른다. 따라서 <em>mixed bound</em> 도 있다. <code>S &gt;: NonEmpty &lt;: IntSet]</code> 이라던지.</p>

<p><code>A &lt;: B</code>, 즉 <em>lower bound</em> 가 있고, 컨테이너 <code>C</code> 가 있을때</p>

<ul>
<li><code>C[A] &lt;: C[B]</code> means <strong>C is covariant</strong>, <code>C[+A]</code></li>
<li><code>C[A] &gt;: C[B]</code> means <strong>C is contravariant</strong>, <code>C[-A]</code></li>
<li>상관 없으면 <strong>C is non-variant</strong>, <code>C[A]</code></li>
</ul>

<p>위에서 봤듯이 함수의 파라미터는 <em>contravariant</em>, 리턴타입은 <em>covariant</em> 인데 이는 파라미터를 나중에 함수 호출할 수 있기 때문이다.</p>

<p>더 자세한 내용은 <a href='http://1ambda.github.io/functional-programming-in-scala-chapter-4/' >Functional Programming in Scala Chapter4</a> 를 참조하자.</p>

<p>함수는 <em>trait</em> 의 구현이고, <code>Map</code> 은 <code>Function1</code> 의 서브클래스다. 따라서 맵을 사용할때 <code>exampleMap(key)</code> 처럼 사용할 수 있다.</p>

<p><code>Seq</code> 도 마찬가지로 서브클래스다. 그래서 <code>Vector(3)</code> 처럼 사용할 수 있다.</p>

<h4 id="collection">Collection</h4>

<p>컬렉션도 잠깐 복습해 보자.</p>

<p><img src='http://librairie.immateriel.fr/baw/9780596155957/httpatomoreillycomsourceoreillyimages322250.png'  alt="" /></p>

<p align="center">(<a href='http://librairie.immateriel.fr/' >http://librairie.immateriel.fr</a>)</p>

<p><img src='http://i.stack.imgur.com/2fjoA.png'  alt="" /></p>

<p align="center">(<a href='http://stackoverflow.com/' >http://stackoverflow.com</a>)</p>

<p><em>filter, map</em> 과 같은 메소드들은 다양한 컬렉션을 지원하지만, <em>list</em> 에서는 <em>tail recursive</em> 하게 정의되어 있다고 한다.</p>

<h3 id="forexpression">For Expression</h3>

<p>스칼라에서 <code>for</code> 구문은 <code>map, flatMap</code> 그리고 <em>lazy variant</em> <code>filter</code> 로 번역된다.</p>

<p>(1) <code>for (x &lt;- e1) yield e2</code> 는</p>

<p><code>e1.map(x =&gt; e2)</code> 다.</p>

<p>(2) <code>for (x &lt;- e1 if f; s) yield e2</code> 는</p>

<p>여기서 <code>f</code> 는 <em>filter</em> 고 <code>s</code> 는 <em>sequence of generators and filters</em> 다. 따라서</p>

<p><code>for (x &lt;- e1.withFilter(x =&gt; f); s) yield e2</code> 로 번역된다. 외울 필요는 없고 <code>for</code> 루프를 쓸 때 <code>withFilter</code> 때문에 메모리 낭비가 적다는 사실 정도만 알고 있으면 된다.</p>

<blockquote>
  <p>You can think of <code>withFilter</code> as a variant of <code>filter</code> that doesn't produce an intermediate list, but instead filters the following <code>map</code> or <code>flatMap</code> function application</p>
</blockquote>

<p>(3) <code>for (x &lt;- e1; y &lt;- e2; s) yield e3</code> 는</p>

<p><code>e1.flatMap(x =&gt; for (y &lt;- e2; s) yield e3)</code> 로 번역된다.</p>

<p>(4) <code>for</code> 구문에서 <em>generator</em> 의 <em>left-hand side</em> 가 패턴일 수 있다. 무슨말인고 하니</p>

<pre><code class="scala">val data: List[JSON] = ...

for {  
  JObj(bindings) &lt;- data
  JSeq(phones) &lt;- bindings("phoneNumber")
  JObj(phone) &lt;- phones
  JStr(digits) = phone("number")
  if digits startWith "212"
} yield (bindings("firstName"), bindings("lastName"))
</code></pre>

<p><code>pattern &lt;- expr</code> 은 이렇게 번역된다.</p>

<pre><code class="scala">x &lt;- expr withFilter {  
        case pattern =&gt; true
        case _ =&gt; false
     } map {
       case pattern =&gt; x
     }
</code></pre>

<h3 id="functionalrandomgenerators">Functional Random Generators</h3>

<p><code>for</code> 구문은 <em>collection</em> 에만 쓸 수 있지 않다. <code>map, flatMap, withFilter</code> 만 구현 된다면 다른 곳으로의 응용도 가능하다. (LINQ 도 그 예라고 본것 같음)</p>

<p><em>random value generator</em> 가 하나의 예제인데, 뭔지 살펴보자.</p>

<pre><code class="scala">  trait Generator[+T] {
    def generate: T
  }

  val integers = new Generator[Int] {
    val rand = new java.util.Random
    def generate = rand.nextInt()
  }

  val booleans = new Generator[Boolean] {
    def generate = integers.generate &gt; 0
  }

  val pairs = new Generator[(Int, Int)] {
    def generate = (integers.generate, integers.generate)
  }
</code></pre>

<p>말 그대로 랜덤한 값들을 타입별로 생성해주는거다. 근데, 매번 해야하는 <em>boilerplate</em> 땜에 귀찮타. 더 좋은 방법은 없을까? 예를 들어 이렇게 쓸 수 있다면,</p>

<pre><code class="scala">val booleans = for (x &lt;- integers) yield x &gt; 0

def pairs[T, U](t: Generator[T], u: Generator[U]) = for {  
  x &lt;- t
  y &lt;- u
} yield (x, y)
</code></pre>

<p><del>존나</del> 쿨하다! 근데 이게 스칼라에서 이렇게 번역되기 때문에</p>

<pre><code class="scala">val booleans = integers map (x =&gt; x &gt; 0)

def pairs[T, U](t: Generator[T], u: Generator[U]) =  
  t flatMap(x =&gt; u map (y =&gt; (x, y)))
</code></pre>

<p><em>generator</em> 을 위한 <code>map</code>, <code>flatMap</code> 을 만들어야 한다. 이 함수들이  새로운 타입을 위한 <code>Generator</code> 를 돌려주면 된다. <del>모나드 느낌이 솔솔 난다</del></p>

<pre><code class="scala">trait Generator[+T] {  
  self =&gt; // an alias for "this"
  def generate: T

  def map[S](f: T =&gt; S): Generator[S] = new Generator[S] {
    def generate = f(self.generate)
  }

  def flatMap[S](f: T =&gt; Generator[S]): Generator[S] = 
    new Generator[S] {
      def generate = f(self.generate).generate
    }
}
</code></pre>

<p>여기서 <code>self</code> 가 필요한 이유는 <code>map</code> 함수 내부에서 <code>this</code> 컨텍스트를 사용할 수 없기 때문이다. <code>map</code> 의 <code>this</code> 로 해석되어 무한루프에 빠진다.</p>

<p>이렇게 <code>Generator</code> 를 위한 <code>map, flatMap</code> 을 만들면 <code>booleans</code> 가 이렇게 번역된다.</p>

<pre><code class="scala">val booleans = for (x &lt;- integers) yield x &gt; 0

val booleans = integers map { x =&gt; x &gt; 0 }

val booleans = new Generator[Booelan] {  
  def generate = (x =&gt; x &gt; 0)(integers.generate)
}

val booleans = new Generator[Booelan] {  
  def generate = integers.generate &gt; 0
}
</code></pre>

<pre><code class="scala">def pairs[T, U](t: Generator[T], u: Generator[U]) = t flatMap {  
  x =&gt; u map { y =&gt; (x, y) }
}

...
...
...

def pairs[T, U](t: Generator[T], u: Generator[U]) =  
  new Generator[(T, U)] {
    def generate = (t.generate, u.generate)
  }
</code></pre>

<p>여기 몇개 더 유용한 <em>generator</em> 를 좀 살펴보면</p>

<pre><code class="scala">  def single[T](x: T): Generator[T] = new Generator[T] {
    def generator = x
  }

  def choose(l: Int, h: Int): Generator[Int] =
    for (x &lt;- integers) yield l + x % (h - l)

  def oneOf[T](xs: T*): Generator[T] =
    for (i &lt;- choose(0, xs.length)) yield xs(i)
</code></pre>

<p>재밌는 사실은 <em>Generator</em> 가 <em>building block</em> 이 된다는 사실이다. <em>Generator</em> 를 조합해 <em>Generator</em> 를 만들고.</p>

<p>처음에 <em>reactive programming</em> 에 관해서 잠깐 이야기 하면서 <em>compose</em> 란 단어가 나왔는데, 이게 바로 <em>composing</em> 의 강력함이다.</p>

<h4 id="listgenerator">List Generator</h4>

<pre><code class="scala">  def lists: Generator[List[Int]] = for {
    isEmpty &lt;- booleans
    list &lt;- if (isEmpty) emptyLists else nonEmptyLists
  } yield list

  def emptyLists = single(Nil)

  def nonEmptyLists = for {
    head &lt;- integers
    tail &lt;- lists
  } yield head :: tail
</code></pre>

<h4 id="treegenerator">Tree Generator</h4>

<pre><code class="scala">  // tree generator
  trait Tree
  case class Leaf(x: Int)                   extends Tree
  case class Inner(left: Tree, right: Tree) extends Tree

  def leafs: Generator[Leaf] = for {
    x &lt;- integers
  } yield Leaf(x)

  def inners: Generator[Inner] = for {
    l &lt;- trees
    r &lt;- trees
  } yield Inner(l, r)

  def trees: Generator[Tree] = for {
    isLeaf &lt;- booleans
    tree &lt;- if (isLeaf) leafs else inners
  } yield tree
</code></pre>

<p>코드를 보면, 좀 뭔가 감이 올테다. 바로 <code>map</code>, <code>flatMap</code> 을 <code>Geneartor</code> 에 대해서 정의했기 때문에 <code>for</code> 내부에서 <code>Generator</code> 에서 <code>T</code> 타입을 빼올 수 있다. 그리고 <code>yield</code> 를 이용해 만드는 것 또한 <code>Generator</code> 가 된다. </p>

<p><del>오더스키 교수는 진짜 천재같다. 모나드를 이렇게 설명하다니. 예전 강의 들을때도 정말 쉽게 설명한다는 느낌을 많이 받았는데</del></p>

<h4 id="applicationrandomtesting">Application: Random Testing</h4>

<p>유닛테스팅을 할때 <em>input</em> 에 대해서 <em>expected output</em> 과 비교해 테스팅을 진행하는데, <em>input</em> 을 직접 만들지 않고 테스팅이 가능할까?</p>

<blockquote>
  <p>Yes, By generating random test inputs</p>
</blockquote>

<pre><code class="scala">def randomTest[T](g: Generator[T], times: Int = 100)(f: T =&gt; Boolean): Unit = {  
  for (i &lt;- 0 until times) {
    val value = g.generate
    assert(f(value), "test failed for" + value)
  }
  println("passed " + times + "tests")
}
</code></pre>

<p>이런 테스팅을 한다면, </p>

<pre><code class="scala">randomTest(pairs(lists, lits)) {  
  case (xs, ys) =&gt; (xs ++ ys).length &gt; xs.length
}
</code></pre>

<p>실패할 것이다. 둘다 <code>Nil</code> 이면 실패한다.</p>

<p>우리는 <em>test</em> 를 작성할 필요가 없고, 항상 참이어야 하는 <em>properties</em> 만 작성하면 된다. 그게 <a href='http://www.scalacheck.org/' ><em>ScalaCheck</em></a> 도구의 기본 아이디어다.</p>

<p><em>ScalaCheck</em> 튜토리얼을 보면 </p>

<pre><code class="scala">import org.scalacheck.Properties  
import org.scalacheck.Prop.forAll

object StringSpecification extends Properties("String") {

  property("startsWith") = forAll { (a: String, b: String) =&gt;
    (a+b).startsWith(a)
  }

  property("concatenate") = forAll { (a: String, b: String) =&gt;
    (a+b).length &gt; a.length &amp;&amp; (a+b).length &gt; b.length
  }

  property("substring") = forAll { (a: String, b: String, c: String) =&gt;
    (a+b+c).substring(a.length, a.length+b.length) == b
  }
}
</code></pre>

<p>하스켈의 <a href='https://www.haskell.org/haskellwiki/Introduction_to_QuickCheck1' ><em>QuickCheck</em></a> 가 먼저 구현되었다고 한다.</p>

<pre><code class="haskell">*A&gt; quickCheck ((\s -&gt; (reverse.reverse) s == s) :: [Char] -&gt; Bool)
</code></pre>

<h3 id="monads">Monads</h3>

<p><del>올것이 왔다</del></p>

<blockquote>
  <p>Data structures with <code>map</code> and <code>flatMap</code> seem to be quite common.</p>
  
  <p>In fact there's a name that describe this class of a data structure together with some algebraic laws that they hould have</p>
  
  <p>They are called <strong>monads</strong></p>
</blockquote>

<p>모나드는 <code>M[T]</code> 타입으로 표시하는데, 다음의 함수들을 구현해야 한다. 하스켈에서 <code>&gt;&gt;=, return</code> 과 동일하다.</p>

<pre><code class="scala">trait M[T] {  
  // `&gt;&gt;=` called bind
  def flatMap[U](f: T =&gt; M[U]): M[U]
}

// return
def unit[T](x: T): M[T]  
</code></pre>

<p>이미 우리가 모르는 사이에 썼던 모나드를 보면</p>

<ul>
<li><code>List</code> is a monad with <code>unit(x) = List(x)</code></li>
<li><code>Set</code> is a monad with <code>unit(x) = Set(x)</code></li>
<li><code>Option</code> is a monad with <code>unit(x) = Some(x)</code></li>
<li><code>Generator</code> is a monad with <code>unit(x) = single(x)</code></li>
</ul>

<p><code>flatMap</code> 은 이들 타입에 두루 쓰일 수 있는 반면 스칼라에서 <code>unit</code> 은 각 모나드 마다 다르다. </p>

<p>그리고 <code>map</code> 은 모나드에서 <code>flatMap</code> 과 <code>unit</code> 을 조합해 만들 수 있다.</p>

<pre><code class="scala">m map f

== m flatMap (x =&gt; unit(f(x)))
== m flatMap (f andThen unit) // composing functions
</code></pre>

<p>즉 <code>f</code> 를 받아 적용하고, <code>unit</code> 으로 모나드로 감싼뒤 <code>flatMap</code> 을 이용해 <em>flattening</em> 하면 <code>map</code> 의 결과가 나온다.</p>

<h4 id="monadlaws">Monad Laws</h4>

<ul>
<li><em>associativity</em></li>
</ul>

<pre><code class="scala">m flatMap f flatMap g == m flatMap (x =&gt; f(x) flatMap g)  
</code></pre>

<ul>
<li><em>left unit</em></li>
</ul>

<pre><code class="scala">unit(x) flatMap f == f(x)  
</code></pre>

<ul>
<li><em>right unit</em></li>
</ul>

<pre><code class="scala">m flatMap unit = m  
</code></pre>

<p><a href='http://en.wikibooks.org/wiki/Haskell/Understanding_monads' #Monad_Laws">하스켈 문법</a>으로 보면</p>

<pre><code class="haskell">(m &gt;&gt;= f) &gt;&gt;= g  =  m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)  -- associativity

return x &gt;&gt;= f   =  f x                      -- left unit

m &gt;&gt;= return     =  m                        -- right unit  
</code></pre>

<p><em>associativity</em> 와 관련해서, <em>monoid</em> 란 것도 있는데 이건 <em>bind</em> 가 없는 모나드라 생각하면 쉽다. 예를 들어 <em>integer</em> 는 모노이드다</p>

<pre><code>(x + y) + z = x + (y + z)
</code></pre>

<p><em>monad laws</em> 를 확인하기 위해 <code>Option</code> 을 좀 보자.</p>

<pre><code class="scala">abstract class Option[+T] {  
  def flatMap[U](f: T =&gt; Option[U]): Option[U] = this match {
    case Some(x) =&gt; f(x)
    case None =&gt; None
  }
}
</code></pre>

<p><em>left unit</em> 을 보이려면 <code>return x &gt;&gt;&gt; f   =   f x</code>, 즉</p>

<pre><code class="scala">Some(x) flatMap f == f(x)

// ==
Some(x) match {  
  case Some(x) =&gt; f(x)
  case None =&gt; None
}

// == 
f(x)  
</code></pre>

<p><em>right unit</em> 을 보이려면 <code>m &gt;&gt; return     =    m</code> 임을 보이면 된다.</p>

<pre><code class="scala">opt flatMap Some // == opt

// == 
opt match {  
  case Some(x) =&gt; Some(x)
  case None =&gt; None
}
</code></pre>

<p><em>associative law</em> 를 보이려면 </p>

<pre><code class="haskell">(m &gt;&gt;= f) &gt;&gt;= g     =     m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)
</code></pre>

<p>따라서 스칼라에선</p>

<pre><code class="scala">opt flatMap f flatMap g  
// == opt flatMap (x =&gt; f(x) flatMap g)

opt flatMap f flatMap g

// ==
opt match { case Some(x) =&gt; f(x) case None =&gt; None }  
    match { case Some(y) =&gt; g(y) case None =&gt; None }

// ==
opt match {  
  case Some(x) =&gt;
    f(x) match { case Some(y) =&gt; g(y) case None =&gt; None }
  case None =&gt;
    None match { case Some(y) =&gt; g(y) case None =&gt; None }
}

// ==
opt match {  
  case Some(x) =&gt; f(x) match {
    case Some(y) =&gt; g(y) case None =&gt; None
  }
  case None =&gt; None
}

// ==
opt match{  
  case Some(x) =&gt; f(x) flatMap g
  case None =&gt; None
}

// ==
opt flatMap (x =&gt; f(x) flatMap g)  
</code></pre>

<p>결국 <code>Option</code> 은 모나드다. 근데 이런 <em>monad laws</em> 를 지키면 얻는게 뭘까? </p>

<p><em>associativity</em> 가 지켜지면, 중첩된 <em>for-loop</em> 를 <em>inline</em> 할 수 있다.</p>

<pre><code class="scala">for (y &lt;- for (x &lt;- m; y &lt;- f(x)) yield y  
     z &lt;- g(y)) yield z

// ==
for (x &lt;- m;  
     y &lt;- f(x)
     z &lt;- g(y)) yield z
</code></pre>

<p><em>right unit</em> 은 </p>

<pre><code class="scala">for (x &lt;- m) yield x

== m
</code></pre>

<p>애석하게도 <em>left unit</em> 은 마땅한 <em>for-loop</em> 가 없다.</p>

<blockquote>
  <p>Left unit does not have an analogue for <em>for-expression</em></p>
</blockquote>

<h3 id="anothertypetry">Another type: Try</h3>

<p>강의 후반부에서 <code>Try</code> 라는 타입을 다룰건데, 이 타입은 <code>Option</code> 과 비슷하다. 서브타입이 <code>Success, Failure</code> 로 <em>exception</em> 이 발생할 경우와 아닐 경우를 처리하는데 쓸 수 있다.</p>

<pre><code class="scala">abstract class Try[+T]  
case class Success[T](x: T)         extends Try[T]  
case class Failure[T](e: Exception) extends Try[Nothing]  
</code></pre>

<p>이 <code>Try</code> 를 예외가 발생할 수 있는 <em>computation (연산)</em> 을 <em>thread, computer</em> 간 넘겨주는데 사용할 수 있다. 참고로 스칼라에서 <code>Nothing</code> 은 <em>bottom type</em> 이다.</p>

<p>이 <code>Try</code> 를 이용해 <em>computation</em> 을 감쌀 수 있다. <code>Try(expr)</code> 처럼</p>

<pre><code class="scala">object Try {  
  def apply[T](expr: =&gt; T): Try[T] =
    try Success(expr)
    catch {
      case NonFatal(e) =&gt; Failure(e)
    }
}
</code></pre>

<p>여기서 <code>=&gt; T</code> 로 <code>expr</code> 를 <em>by name</em> 으로 받는 이유는 연산을 나중에 하기 위해서다.</p>

<p><code>Try</code> 를 <em>for-loop</em> 에 활용하면</p>

<pre><code class="scala">for {  
  x &lt;- computeX
  y &lt;- computeY
} yield f(x, y)
</code></pre>

<p>이 구문이 하는 일은, <code>computeX</code>, <code>computeY</code> 가 모두 성공할 경우에만 <code>Success(f(x, y))</code> 를 돌려준다. 둘 중 하나라도 실패하면 <code>Failure(e)</code> 를 반환할 것이다.</p>

<p><code>Try</code> 를 위한 <code>map</code>, <code>flatMap</code> 은</p>

<pre><code class="scala">abstract class Try[T] {  
  def flatMap[U](f: T =&gt; Try[U]): Try[U] = this match {
    case Success(x) = try f(x) 
                      catch { case NonFatal(e) =&gt; Failure(ex)
    case fail: Failure =&gt; fail
  }

  def flatMap[U](f: T =&gt; U): Try[U] = this match {
    case Success(x) =&gt; Try(f(x))
    case fail: Failure =&gt; fail
  }
}


// t map f
// == t flatMap (f andThen Try)
</code></pre>

<p><code>Try</code> 를 모나드라 생각해 보자. <em>monad law</em> 중 실패하는 것이 있을까? 다시 한번 보면</p>

<pre><code class="haskell">return x &gt;&gt;= f     =    f x    -- left unit  
m &gt;&gt;= return       =    m      -- right unit  
-- associativity
(m &gt;&gt;= f) &gt;&gt;= g    =    m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g) 
</code></pre>

<p>아까 <em>for-expression</em> 에 사용했으니 <em>right unit, associativity</em> 는 맞을 거고 <em>left unit</em> 을 살펴보자.</p>

<pre><code class="scala">// return x &gt;&gt;= f     =    f x
Try(x) flatmap f

// ==
this match {  
  Success(x) =&gt; try f(x) 
                catch { case NonFatal(e) =&gt; Failure(ex)
  case fail: Failure =&gt; fail
}
</code></pre>

<p>보면 알겠지만, 예외가 발생하지 않을 경우에만 <em>left unit</em> 이 성립한다.</p>

<pre><code class="scala">Try(expr) flatMap f != f(expr)  
</code></pre>

<p>좌변은 예외를 그냥 던지지않고, 감싸서 준다. 반면 우측은 예외를 던질 수 있다. 즉 예외를 던지지 않는 <em>law</em> 를 얻기 위해 <em>left unit</em> 을 희생했다고 보면 된다.</p>

<blockquote>
  <p>An expression composed from <code>Try</code>, <code>map</code>, <code>flatMap</code> will never throw a non-fatal exception</p>
</blockquote>

<p>이거 <em>bullet-proof principle</em> 이라 부른다.</p>

<h3 id="summary">Summary</h3>

<p>이제까지 <em>collection</em> 뿐만 아니라 다양한 타입에 대해 <em>for-expression</em> 을 쓸 수 있음을 배웠다. <code>map</code>, <code>flatMap</code>, <code>withFilter</code> 등을 구현하면 된다.</p>

<p><code>flatMap</code> 을 구현한 많은 타입이 <em>monad</em> 다. 만약에 <code>withFilter</code> 를 구현하면 <em>monad with zero</em> 라 부른다.</p>

<p>모나드 법칙은 <em>API</em> 를 구현할때 가이드라인이 되지만, <code>Try</code> 의 예에서 봤듯이 모나드 법칙을 버려서 다른 이득을 얻을 수도 있다. <del>만만한 left unit</del></p>

<h3 id="references">References</h3>

<p>(1) <a href='http://stackoverflow.com/questions/1722137/scala-2-8-collections-design-tutoria$l' >Scala 2.8 Collection</a> <br />
(2) <a href='http://en.wikibooks.org/wiki/Haskell/Understanding_monads' #Monad_Laws">Haskell Wiki: Monad</a>  </p>]]></description><link>http://1ambda.github.io/reactive-programming-1/</link><guid isPermaLink="false">c49814fa-24c5-4f5f-83c4-d1a196a8b687</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[variance]]></category><category><![CDATA[monad]]></category><category><![CDATA[reactive programming]]></category><category><![CDATA[generator]]></category><category><![CDATA[scala check]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 17 Dec 2014 07:30:37 GMT</pubDate></item><item><title><![CDATA[Process Mining, Week4]]></title><description><![CDATA[<h3 id="twophaseprocessdiscoverylimitations">Two-Phase Process Discovery, Limitations</h3>

<p>지난시간에 두 단계를 거치는 프로세스 마이닝 알고리즘을 봤었다.</p>

<p>하나는 <em>heuristic mining</em> 으로 <em>dependency graph</em> 를 만들고, 이것을 <em>C-nets</em> 으로 변환했었다.</p>

<p>다른 하나는 <em>transition system</em> 을 학습하는 것으로 먼저 <em>state abstraction</em> 을 이용해 <em>transition system</em> 을 만들고 여기에 숨어있는 <em>state-based region</em> 을 이용해 <em>Petri-nets</em> 을 만들었다.</p>

<p>그런데, <em>state-based region</em> 접근 방법에는 문제점이 있다.</p>

<p>(1) Inability to discover particular <strong>process construct</strong>s <br />
(2) Inability to balance the four forces (<em>fitness</em>, <em>precision</em>, <em>generalization</em>, simplicity)</p>

<p>예를 하나 보자. <code>&lt;a, a&gt;^55</code> 란 로그가 있을때 만들어지는 트랜지션 시스템으로 <code>s1 -&gt; s2 -&gt; s3</code> 가 있다. 여기엔 몇개의 <em>non-trivial region</em> 이 있을까?</p>

<p>없다. <em>empty set</em>, <code>{s1, s2, s3}</code> 가 있는데, <em>trivial region</em> 이므로</p>

<p>따라서 이걸 이용해 <em>petri-net</em> 을 만들면 <em>place</em> 가 없는 <em>petri-net</em> 이 만들어 지고, <code>&lt;a, a, a&gt;</code> 등의 로그를 허용하므로 에러가 있다.</p>

<p><code>&lt;a, c&gt;, &lt;a, b, c&gt;, &lt;a, b, b, c&gt; ...</code> 의 로그를 훈련시켜 만든 트랜지션 시스템은 대략 이런 모양이다</p>

<p><code>s1 -&gt; s2 &gt; s3</code> (<code>s2</code> 는 자기 자신으로의 액션 <code>b</code> 가 있음) </p>

<p>이 때 여기에는 <em>non-trivial region</em> 이 3개가 생기는데, 이걸 이용해 <em>petri-net</em> 을 만들면 <code>b</code> 만 붕 떠 있어, <code>b</code> 가 가운데 실행되지 않고 먼저나, 나중에 실행되는 <em>petri-net</em> 이 만들어 진다. <em>underfit</em> 이다.</p>

<blockquote>
  <p>Petri net can simulate the behavior of the transition system, but not the other way around (no bisimulation)</p>
</blockquote>

<p>첫 번째 문제같은 경우는 <em>forward closure</em> 속성을 검사해서, 문제가 발견되면 <em>label</em> 을 <em>spliting</em> 하는걸로 해결할 수 있다. (이미지를 첨부하고 싶은데 찾을 수가 없다.) 두 번째 문제도 같은 방법으로 해결할 수 있다. <em>ProM</em> 에는 <em>bisimulation</em> 을 위한 플러그인이 있다.</p>

<p>이제 특정 프로세스 패턴을 발견하지 못하는 문제를 해결했다. 이제 문제 (2) 를 해결해 보자.</p>

<blockquote>
  <p>(2) Inability to balance the four forces (<em>fitness</em>, <em>precision</em>, <em>generalization</em>, simplicity)</p>
</blockquote>

<p>먼저 <em>step 1</em> 에서 트랜지션 시스템을 학습할때는 <em>fitness, generalization</em>, <em>precision</em>, <em>simplicity</em> 의 <em>trade-off</em> 를 봐가면서 해야한다.</p>

<p><em>step 2</em> 에서는 <em>region</em> 을 이용해서 <em>concurrency</em> 를 발견하는데 사실 잘 생각해 보면 <em>Petri-nets</em> 은 트랜지션시스템에서의 변환이므로 이 단계에서는 <em>simplicity</em> 나 <em>generalization</em> 의 개선 여지가 없다. 트랜지션 시스템이 이미 복잡한데 어떻게 페트리넷을 간단하게 할까? 마찬가지로 트랜지션 시스템이 이미 <em>overfit</em> 되어있는데, 어떻게 이 문제를 풀까? 이 두 가지 문제를 해결하려면 (1) 로 돌아가야 한다.</p>

<p>정리하자면 <em>Region-based techniques</em> 은 </p>

<ul>
<li><strong>Overfitting</strong> may be a problem</li>
<li>Inability to leave out <strong>infrequent</strong> behavior (but can be done in the transtion system)</li>
<li><strong>Noise</strong> and <strong>incompleteness</strong> connot be handled well</li>
</ul>

<h3 id="alternativeprocessdiscoverytechniques">Alternative Process Discovery Techniques</h3>

<p>이전까지는 모델의 퍼포먼스를 기준으로 삼았지만 사실 </p>

<ul>
<li>speed</li>
<li>memory usage</li>
<li>representational bias</li>
<li>flexibility(related problems),</li>
<li>implementation vs apporach</li>
</ul>

<p>등을 고려해야 한다. </p>

<p><em>petri net</em> 에서 무엇을 해야 <em>behavior</em> 를 추가할 수 있을까? <em>place</em> 는 일종의 <em>constraint</em> 라 보면 된다. 그리고 <em>place</em> 에 토큰이 많아지면 다 더 다양한 로그가 생길 수 있다.</p>

<ul>
<li>Add a transition</li>
<li>Remove a place</li>
<li>Add an arc from a transition to a place</li>
<li>Remove an arc from a place to a transtion</li>
</ul>

<p>반대로 <em>behavior</em> 를 제거하려면</p>

<ul>
<li>Remove a transition</li>
<li>Add a place</li>
<li>Add an arc from a place to transition</li>
<li>Remove an arc from a transition to a place</li>
</ul>

<p><em>process discovery</em> 가 <em>finding place</em> 라는 점을 고려하면 <em>alpha algorithm</em> 에서는 <em>constraint</em> 인 <em>place</em> 를 발견하는 과정이었다. <em>state-based region</em> 에서는 먼저 <em>transition</em> 을 만들고, 이걸 <em>place</em> 로 변환했었다.</p>

<p>이번엔 <em>language-based region</em> 이란 기법을 배워보자.</p>

<h3 id="languagebasedregion">Language-based Region</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-36-728.jpg?cb=1305062477'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-37-728.jpg?cb=1305062477'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-38-728.jpg?cb=1305062477'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-40-728.jpg?cb=1305062477'  alt="" /></p>

<p><br/></p>

<p><code>c * 1 + A' * x - A * y &gt;= 0</code> 등의 식으로 표현되는데, 이 말은 <em>place</em> 가 음수가 될 수 없다는 뜻이라 보면 된다. <del>이제 나도 뭔소린지 모르겠다 너무멀리 와버렸음 ㅠㅠ</del></p>

<p><img src='http://latex.codecogs.com/gif.latex?c%20' *%201%20&plus;%20A%27%20x%20-%20Ay%20%5Cgeq%200" alt="" /></p>

<p>여기서 <code>A', A</code> 는 <em>log</em>, <code>x, y</code> 는 <em>petri-nets</em>, <code>c</code> 는 초기에 <em>place</em> 내에 있는 토큰의 수다. 이 때 위 방정식을 만족하는 <code>x, y, c</code> 가 <em>region</em> 이다. </p>

<ul>
<li><code>c</code> is the initial number of tokens in the place</li>
</ul>

<p>예를 들어</p>

<p><code>&lt;a&gt;, &lt;b&gt;, &lt;a, b&gt;, &lt;b, a&gt;</code> 인 로그가 있다고 하자. 그러면 진리표처럼 로그 내에 <code>a, b</code> 쌍을 <code>0, 1</code> 로 표현할 수 있다. 이걸 <code>A</code> 라 하면</p>

<p><img src='http://latex.codecogs.com/gif.latex?A%20%3D%20%5Cbegin%7Bpmatrix%7D%201%20%26%200%5C%5C%200%20%26%201%5C%5C%201%20%26%201%5C%5C%201%20%26%201%20%5Cend%7Bpmatrix%7D'  alt="" /></p>

<p>그리고 <code>A'</code> 를 만들기 위해 마지막 <em>trace</em> 는 무시하도록 하자. 그러면 다음 식을 만들 수 있다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?c%20' *%20%5Cbegin%7Bpmatrix%7D%201%5C%5C%201%5C%5C%201%5C%5C%201%20%5Cend%7Bpmatrix%7D%20&plus;%20%5Cbegin%7Bpmatrix%7D%200%20%26%200%5C%5C%200%20%26%200%5C%5C%201%20%26%200%5C%5C%200%20%26%201%20%5Cend%7Bpmatrix%7D%20*%20%5Cbegin%7Bpmatrix%7D%20x_a%5C%5C%20x_b%20%5Cend%7Bpmatrix%7D%20-%20%5Cbegin%7Bpmatrix%7D%201%20%26%200%5C%5C%200%20%26%201%5C%5C%201%20%26%201%5C%5C%201%20%26%201%20%5Cend%7Bpmatrix%7D%20*%20%5Cbegin%7Bpmatrix%7D%20y_a%5C%5C%20b_b%20%5Cend%7Bpmatrix%7D%20%5Cgeq%20%5Cbegin%7Bpmatrix%7D%200%5C%5C%200%5C%5C%200%5C%5C%200%20%5Cend%7Bpmatrix%7D" alt="" /></p>

<ul>
<li><code>x_a</code> is the number of arcs from transition <code>a</code> to the place</li>
<li><code>x_b</code> is the number of arcs from transition <code>b</code> to the place</li>
<li><code>y_a</code> is the number of arcs from the place to transtion <code>a</code></li>
<li><code>y_b</code> is the number of arcs from the place to transtion <code>b</code></li>
</ul>

<p>식을 풀면</p>

<p><img src='http://latex.codecogs.com/gif.latex?%5C%20%5C%5C%20c%20-%20y_a%20%5Cgeq%200%20%5C%5C%20c%20-%20y_b%20%5Cgeq%200%20%5C%5C%20c%20&plus;%20x_a%20-%20y_a%20-%20y_b%20%5Cgeq%200%20%5C%5C%20c%20&plus;%20x_b%20-%20y_a%20-%20y_b%20%5Cgeq%200%20%5C%5C'  alt="" /></p>

<p>하나의 답으로 </p>

<ul>
<li><code>c=1, x_a=0, x_b=0, y_a=1, y_b=0</code></li>
<li><code>c=1, x_a=0, x_b=0, y_a=0, y_b=1</code></li>
</ul>

<p><em>language-based region</em> 에서는</p>

<ul>
<li>any solution is a feasible place</li>
<li>additional constraints can be added easily</li>
<li><strong>goal function</strong> can be used to select most interesting places</li>
<li>optimiazation problem (e.g ILP)</li>
</ul>

<h3 id="geneticprocessmining">Genetic Process Mining</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-22-728.jpg?cb=1305062477'  alt="" /></p>

<p>이번엔 <em>genetic process mining</em> 기법을 살펴보자.</p>

<p><em>event log</em> 로 부터 <em>initial population</em> 을 만들고, 이것에 대해 <em>conformance checking</em> 등을 이용해 얼마나 좋은 모델인가 본다. 이것을 다시 매 턴마다 랜덤하게 변이시키면서 계속 반복하는 것이다.</p>

<p>많은 <em>generation</em>, <em>mutation</em> 이 있을 수 있기 때문에 굉장히 느리지만 <em>very flexible</em> 할 수 있다. 왜냐하면 <em>qualty measure</em> 을 이용해서 4 품질(fitness 등) 을 조절할 수 있기 때문이다.</p>

<h3 id="inductiveprocessmining">Inductive Process Mining</h3>

<p>로그를 <em>trace</em> 를 기준으로 쪼개는 방법인데</p>

<pre><code>abdef  
acdef  
abdeg  
adceg  
</code></pre>

<p>가 있을때, <code>abcd</code>, <code>efg</code> 기준으로 쪼개면</p>

<pre><code>abd  
acd  
abd  
adc

ef  
ef  
eg  
eg  
</code></pre>

<p>로 분리할 수 있다. 여기서 <code>abcd</code> 부분을 또 쪼개면 <code>a</code> <code>seq</code> <code>bcd</code> 로 쪼갤 수 있다. 마찬가지로 뒷부분도 <code>e</code> <code>seq</code> <code>fg</code> 로 쪼갤 수 있다. 뒷부분의 경우 <code>f xor g</code> 로 다시 쪼갤 수 있고. 이렇게 반복하면서 쪼개는 방법이다. 이 결과로 만들어지는 것이 <em>process tree</em> 다. 이를 <em>petri-net</em> 이나 <em>BPMN</em> 으로 변경할 수 있다. </p>

<p><em>ProM</em> 에도 플러그인이 있다고 함.</p>

<h3 id="introtoconformancechecking">Intro to Conformance Checking</h3>

<p><img src='http://www.win.tue.nl/' ~mpechen/projects/edm/images/framework.jpg" alt="" /></p>

<p align="center">(<a href='http://www.win.tue.nl/' >http://www.win.tue.nl</a>)</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-4-728.jpg?cb=1305062420'  alt="" />
<br/></p>

<p>다른 품질도 중요하긴 한데, <em>replay fitness</em> 가 주된 관심사라고 한다. <em>conformance checking</em> 의 주된 용도는</p>

<ul>
<li>Auditing and compliance</li>
<li>Evaluating process discovery algorithm</li>
<li>Conformance to specification (software, service)</li>
</ul>

<p><em>conformance checking</em> 은 <em>runtime</em> 에 할수도 있다.</p>

<h3 id="footprintsbasedconformancechecking">Footprints-based Conformance Checking</h3>

<p>알파 알고리즘을 사용할때 <em>footprints</em> 를 봤었다. 테이블에 각 <em>trace</em> 사이의 <em>direct succession, causality, parallel, choice</em> 를 표시한 것이다. </p>

<p>로그로 부터 <em>footprint</em> 가 나왔기 때문에 로그의 <em>footprint-based conformance</em> 는 항상 <code>1</code> 이다. 다시 말해서</p>

<blockquote>
  <p>footprints of log and model coincide</p>
</blockquote>

<p>그런데, 모델을 만들고 보니 다음과 같이 로그와 모델의 <em>footprint</em> 를 작성했다고 하자.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-34-728.jpg?cb=1305062420'  alt="" /></p>

<p><code>a - d, b - d</code> 부분이 다르다. 따라서 다른 부분을 파악해서 값으로 매기면</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-35-728.jpg?cb=1305062420'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-36-728.jpg?cb=1305062420'  alt="" /></p>

<p><br/></p>

<p><em>flower model</em> 에서는 수 많은 조합이 가능하기 때문에 <em>footprint-based conformance</em> 가 떨어진다.</p>

<p><em>footprint-based conformance</em> 자체는 굉장히 유연하다. </p>

<ul>
<li><em>log to log</em></li>
<li><em>log to model</em></li>
<li><em>model to model</em></li>
</ul>

<p>모두 가능하다. 그러나</p>

<ul>
<li>frequencies are not used</li>
<li>behavior is only considered indiretcly (directly follows relation)</li>
<li>aims to capture fitness, precision and generalization in a single metric</li>
</ul>

<p>다양한 <em>metric</em> 으로 <em>fitness</em> 을 분류하고 싶을 수도 있는데, <em>footprint-based</em> 는 그러질 못한다. 이 때문에 <em>token-based conformance</em> 를 이용하기도 한다.</p>

<h3 id="tokenbasedreplay">Token-based Replay</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-12-728.jpg?cb=1305062420'  alt="" /></p>

<p><em>traces</em> 를 모델에 실제 <em>replay</em> 해 보면서 <em>missing token</em>, <em>remaining token</em> 을 기록한다.</p>

<ul>
<li><code>p</code>, <em>produced tokens</em></li>
<li><code>c</code>, <em>consumed tokens</em></li>
<li><code>m</code>, <em>missing tokens</em></li>
<li><code>r</code>, <em>remaining tokens</em></li>
</ul>

<p><img src='http://latex.codecogs.com/gif.latex?fitness%28%5Csigma%2C%20N%29%20%3D%20%5C%5C%20%5C%5C%20%7B1%20%5Cover%202%7D%20%281%20-%20%7Bm%20%5Cover%20c%7D%29%20&plus;%20%7B1%20%5Cover%202%7D%281%20-%20%7Br%20%5Cover%20p%7D%29'  alt="" /></p>

<p>그리고, 어느 <em>place</em> 에서든 <em>invariants</em> 는</p>

<p><img src='http://latex.codecogs.com/gif.latex?%5C%20%5C%5C%20p%20&plus;%20m%20%5Cgeq%20c%20%5Cgeq%20m%5C%20%5C%20%5Cmbox%7B%28at%5C%20any%5C%20time%29%7D%20%5C%5C%20r%20%3D%20p%20&plus;%20m%20-%20c%5C%20%5C%20%5Cmbox%7B%28at%5C%20the%5C%20end%29%7D'  alt="" /></p>

<p><em>replay</em> 의 시작과 끝을 생각해 보면</p>

<ul>
<li>In the beginning, a token is <strong>produced</strong> for the <em>source place</em> <code>p = 1</code></li>
<li>At the end, a token is <strong>consumed</strong> from the <em>sink place</em> (also if not there) <code>c' = c + 1</code></li>
</ul>

<p>뭔 소린가 했는데, <em>conformance checking</em> 을 위해 초기에 토큰을 하나 넣어주고, <em>replay</em> 가 끝났을 때 <em>sink place</em> 에서 <em>consume</em> 해서 <code>c</code> 값을 하나 증가시킨다는 이야기</p>

<p>왼쪽 위의 값을 주목하면서 따라가 보자.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-17-728.jpg?cb=1305062420'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-18-728.jpg?cb=1305062420'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-19-728.jpg?cb=1305062420'  alt="" /></p>

<p><br/></p>

<p>이번엔 좀 문제가 있는 <em>event log</em></p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-20-728.jpg?cb=1305062420'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-21-728.jpg?cb=1305062420'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-22-728.jpg?cb=1305062420'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-24-728.jpg?cb=1305062420'  alt="" /></p>

<p><br/></p>

<p>각 <em>log</em> 가 <em>transition</em> 에서 얼마나 실행되었는지 기록해서 모델에 어떤 문제가 있는지 파악할 수 있다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-30-728.jpg?cb=1305062420'  alt="" /></p>

<p><em>frequency</em> 는 <code>p, c, m, r</code> 에 곱해서 전체 <em>fitness</em> 값을 얻으면 된다. </p>

<p>만약 <em>consumed token</em> 이 모두 <em>missing token</em> 이고, <em>produced token</em> 이 모두 <em>remaining token</em> (미사용) 이면 <em>fitness</em> 는 <code>0</code> 이다.</p>

<h4 id="limitations">Limitations</h4>

<ul>
<li>Basic replay approache assumes <strong>visible, unique labeled</strong> transitions</li>
<li>ProM implementation uses <strong>heuristics</strong> to deal with slient transitions having same label</li>
<li>Conformance value is too optimistic due tu <strong>token flooding</strong></li>
<li>Local decision marking may misleading</li>
</ul>

<p>특히 마지막은 중요한데, 우리는 <em>value</em> 를 보고 싶은게 아니라 <em>closest path</em> 를 보고싶어 할수도 있다.</p>

<p>예를 들어 <code>&lt;a, c1, c2, c3, e1, e2, e3&gt;</code> 값이 <code>0.8</code> 로 나왔다 하면, "그럼 올바른 <em>path</em> 는 무얼까?" 하고 질문할 수 있다.</p>

<blockquote>
  <p>Replay technique does not provide corresponding path through model</p>
</blockquote>

<p>다음장에서 배울 <em>alignment</em> 를 이용하면 모델에서 가능한 <em>real path</em> 를 얻을 수 있다.</p>

<h3 id="alignmentbasedconformancechecking">Alignment-based Conformance Checking</h3>

<p>먼저 생각해 볼 거리는</p>

<blockquote>
  <p>Conformance checking <strong>should not impose restriction</strong> on the process notation e.g slient transitions and two transitions with same label should be possible</p>
  
  <p>Should provide <strong>closest maching path</strong> (required for <em>performance analysis</em>)</p>
</blockquote>

<p>특히 <em>closest maching path</em> 가 제공되면 <em>fitness</em> 를 넘어 <em>generalization</em>, <em>precision</em>, <em>bottle-neck</em> 등에 이용할 수 있다. 대략 이런 느낌이라고 보면 된다.</p>

<p><img src='http://image.slidesharecdn.com/alignmentbasedprecisionchecking-121013004859-phpapp01/95/alignment-based-precision-checking-5-728.jpg?cb=1350107718'  alt="" /></p>

<p>즉 <em>replay</em> 불가능한 로그에서 <em>replay</em> 가능한 로그와 차이점을 반영한 것이라 보면 된다. 그러면, 다음중 어떤 것이 더 <em>possible</em> 한 로그일까?</p>

<pre><code>a &gt;&gt; c1 c2 e1 e2 e3 // invalid path  
&gt;&gt; b c1 c2 e1 e2 e3 // valid path

a1 c1 c2 &gt;&gt; &gt;&gt; &gt;&gt; e1 e2 e3 // invalid  
a1 c1 c2 d1 d2 d3 &gt;&gt; &gt;&gt; &gt;&gt; // valid  
</code></pre>

<p>이건 <em>cost function</em> 에 따라 다르다. <em>standard cost function</em> 의 경우 <code>&gt;&gt;</code> (<em>move</em>) 의 수를 센다.</p>

<p>근데 몇 가지 생각해볼 거리가 있다. <code>-2</code> 와 <code>+2</code> 의 <em>cost</em> 가 있을 때 어떤 것을 택할건가 하는 문제들이다. 이 차이 때문에 루프가 있을수도 있다.    </p>

<h3 id="alignmentbasedfitness">Alignment-based Fitness</h3>

<p>1 에서 <em>optimal cost</em> / <em>worst cost</em> 를 빼면 된다. 강의에서 나오는 <em>log</em> 의 경우</p>

<pre><code>// optimal
a &gt;&gt; c1 c2 e1 e2 e3  
&gt;&gt; b c1 c2 e1 e2 e3

// worst
a1 c1 c2 e1 e2 e3 &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt;  
&gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; &gt;&gt; b1 c1 c2 d1 d2 d3
</code></pre>

<p>따라서 <code>1 - (2 / 12) = 0.83</code></p>

<p><em>alignment-based conformance checking</em> 의 장점으로는 </p>

<ul>
<li>observed behavior is directly related to modeled behavior</li>
<li>very <strong>flexible</strong> (any cost structure)</li>
<li>detailed diagnostics</li>
<li>after aligning log and model, other quality dimensions can be investigated</li>
</ul>

<p>다른 장점으로는 <em>drilling down</em> 도 있다. 즉 <em>replay</em> 되는 것과 아닌 것을 분리해서 분석할 수 있다는 뜻이다. 분리 된 것중 이상한 로그를 <em>새로운</em> 로그처럼 취급해서 다양한 기법들을 적용할 수 있다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-32-728.jpg?cb=1305062420'  alt="" /></p>

<p><br/></p>

<p>지금까지 <em>fitness</em> 만 좀 봤지만 다른 퀄리티에 대해서도 적용 가능하다. 그리고 지금까지는 <em>control flow</em> 관점으로 좀 봤는데, <em>cost, time</em> 등 다른 기준으로도 볼 수 있다. 이를 위한 기법으로 <em>data-aware alignments</em> 가 있다.</p>

<h3 id="exploringeventdata">Exploring Event Data</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter07conformancechecking-110510153239-phpapp02/95/process-mining-chapter-7-conformance-checking-3http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-16-728.jpg?cb=13050623738-728.jpg?cb=1305062420'  alt="" /></p>

<p><del>멘탈이 터짐</del></p>

<p><em>model view</em>, <em>instance view</em>, <em>event view</em> 사이에 관계가 있다고 함.</p>

<p><br/></p>

<h4 id="dottedchart">Dotted Chart</h4>

<p>모든 이벤트를 볼 수 있는 일종의 <em>view</em> 인데 <em>dot</em> 과 <em>event</em> 사이에는 1:1 관계가 있다. 모든 <em>event</em> 에는 <em>timestamp</em> 가 있는데, 이것을 이용해 <code>X</code> 를 계산하고 다른 <em>attribute</em> 를 이용해서 <code>Y</code> 축을 잡는다. 액티비티나 리소스에 따라 다른 색을 가질 수 있다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-16-728.jpg?cb=1305062373'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter08miningadditionalperspectives-110510153251-phpapp02/95/process-mining-chapter-8-mining-additional-perspectives-17-728.jpg?cb=1305062373'  alt="" /></p>

<p><br/></p>

<p>이게 중요한 이유가 <code>Y</code> 축과 컬러를 어떻게 하느냐에 따라 정말 다양한 <em>view</em> 를 얻을 수 있다. 그래서 강의에서 헬리콥터 뷰 라고 표현함. 심지어 <em>time</em> 을 <em>logical time</em> (step 1) 등으로 수정해서 볼 수도 있다. </p>

<p>다양한 뷰를 조절해 가면서 왜 <em>delayed</em> 되었는지, <em>decision</em> 이 없다면 이전 스텝이 무엇인지 등을 파악할 수 있다. </p>

<p><em>dotted chart</em> 를 이용하면 모델을 작업 하기 전에 <em>input</em> 만을 이용해 다양한 직관을 얻을 수 있다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://issuu.com/wmpvanderaalst/docs/procminbook?e=14081202/9829483' >Book: Process Mining</a> <br />
(2) <a href='https://d396qusza40orc.cloudfront.net/procmin/lecture_slides/22-Petri%20Nets%20%281%29.pdf' >Slide</a> <br />
(3) <strong>Process Mining: Data science in Action</strong> by Wil van der Aalst <br />
(4) <a href='http://1ambda.github.io/www.processmining.org' >www.processmining.org</a> <br />
(5) <a href='http://fluxicon.com/' >http://fluxicon.com</a> <br />
(6) <a href='http://www.win.tue.nl/' ~mpechen/projects/edm/">http://www.win.tue.nl</a> <br />
(7) <a href='http://www.slideshare.net/caise2013vlc/ramezani-taghiabadi-temporal-compliance-checking-2' >Temporal Compliance Checking</a> <br />
(9) <a href='http://www.slideshare.net/aryaadriansyah/alignment-based-precision-checking' >Alignment-based onformance Checking</a></p>]]></description><link>http://1ambda.github.io/process-mining-week4/</link><guid isPermaLink="false">c0ec136c-9e68-46bc-b21f-0cd5f8661eb9</guid><category><![CDATA[coursera]]></category><category><![CDATA[process mining]]></category><category><![CDATA[conformance checking]]></category><category><![CDATA[token-based]]></category><category><![CDATA[footprint-based]]></category><category><![CDATA[alignment-based]]></category><category><![CDATA[dotted chart]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 17 Dec 2014 00:59:53 GMT</pubDate></item><item><title><![CDATA[R-way, Ternary Search Tries]]></title><description><![CDATA[<h3 id="stringsymboltable">String Symbol Table</h3>

<p>지난 시간에 <em>symbol-table</em> 의 구현으로 <em>red-black tree, hash table</em> 의 성능을 살펴봤었다.</p>

<p><em>red black tree</em> 는 <em>search, insertion, delete</em> 에 <code>compareTo</code> 를 이용해 <code>log N</code>, <em>hash table</em> 은 <code>equals, hashCode</code> 를 이용해 <code>1</code> (under uniform hashing assumption) 의 성능을 확인했다. </p>

<p><em>red black tree</em> 의 경우에는 <em>rank</em> 같은 다른 연산도 하는것도 봤다. 그런데, 이보다 더 빠르게 만들 순 없을까?</p>

<p>가능하다. 스트링 정렬처럼, <em>entire key</em> 를 모두 검사하지 않으면 더 빠르게 만들 수 있다. 먼저 시작 전에 <em>String symbol table API</em> 를 좀 보고가면</p>

<pre><code class="java">public class StringST&lt;Value&gt; {  
  ...

  void put(String key, Value value)
  Value get(String key)
  void delete(String key)

  ...
}
</code></pre>

<h3 id="tries">Tries</h3>

<p><em>red black tree</em> 나 <em>hash table</em> 과는 다르게 한 노드에 <em>key</em> 가 아니라 <em>character</em> 를 저장한다. 아래 짤방을 보는게 이해가 더 빠를듯. 끝 초록색 노드에 붙어있는 숫자가 바로 <em>value</em> 다.</p>

<p><img src='http://t2.hhg.to/V12-d3.png'  alt="" /></p>

<p align="center">(<a href='http://t2.hhg.to/' >http://t2.hhg.to</a>)</p>

<p>이름은 re<strong>trie</strong>val 에서 왔다고 한다. <em>try</em> 랑 똑같이 발음함. 허프만 코드랑 비슷하게도 보인다.</p>

<ul>
<li>For now, store <em>char</em> in nodes (not keys)</li>
<li>Each node has <code>R</code> children, one or each possible chars</li>
<li>Store values in nodes corresponding to last chars in keys</li>
</ul>

<p><em>value</em> 는 항상 끝에만 있을 수 있는건 아니고 <code>shell</code>, <code>she</code> 둘 다 저장했을때 <code>e</code> 에도 <code>she</code> 를 위한 <em>value</em> 를     저장할 수 있다.</p>

<h4 id="trieperformance">Trie Performance</h4>

<ul>
<li>Search hit</li>
</ul>

<p><code>L</code> 개의 문자를 모두 탐색해야 한다. 그리 긴 시간은 아님.</p>

<ul>
<li>Search miss</li>
</ul>

<p>첫 번째 문자부터 탐색에 실패할 확률도 있다. 전형적인 경우는 몇 개의 문자를 탐색하다 실패하는 경우이므로 <em>sublinear</em> 한 퍼포먼스를 보여준다.</p>

<p>각 <code>leaf</code> 마다 <code>R</code> 개의 널 링크가 필요한데, 그래도 <em>sublinear</em> 라고 말할 수 있는 것이 짧은 문자열들은 <em>common prefix</em> 를 공유한다.</p>

<blockquote>
  <p>Fast search hit and evn faster search miss, but waste spaces.</p>
</blockquote>

<p><em>search miss</em> 의 성능이 <code>log_R N</code> 으로 빨라져서 좋긴 한데, <em>space</em> 가 <code>(R + 1) * N</code> 이라 좀 부담이다. (<em>search hit, insert</em> 는 해시 테이블처럼 <code>L</code>)</p>

<p>유니코드면 <em>65536-way trie</em> 를 만들어야 한다.</p>

<p>유명한 <em>job interview</em> 로 <em>efficient spell checking</em> 의 자료구조를 구현하는 것이 있는데. <em>26-way tries</em> 를 만들면 된다. <em>value</em> 는 <em>bit</em> 로</p>

<h4 id="deletioninanrwaytrie">Deletion in an R-way Trie</h4>

<p>만약 마지막 노드가 <em>all null links</em> 를 가지고 있으면 제거하면 된다. 그리고 백트래킹 하면서 <em>value</em> 를 만나기 전 까지 삭제되면 됨.</p>

<h4 id="rwaytriesimplementation">R-way Tries Implementation</h4>

<pre><code class="java">public class TrieST&lt;Value&gt; {

    private static final int R = 256; // extended ASCII
    private Node root = new Node();
    private int N;

    private static class Node {
        private Object val;
        private Node[] next = new Node[R];
    }

    public TrieST() { N = 0; }

    public int size() { return N; }

    public boolean isEmpty() { return size() == 0; }

    public Value get(String key) {
        Node x = get(root, key, 0);

        if (x == null) return null;
        return (Value) x.val;
    }

    public void delete(String key) {
        root = delete(root, key, 0);
    }

    private Node delete(Node x, String key, int d) {
        if (x == null) return null;

        if (d == key.length()) {
            if (x.val != null) N--;
            x.val = null;
        } else {
            char c = key.charAt(d);
            x.next[c] = delete(x.next[c], key, d + 1);
        }

        // remove subtrie rooted at x if it is completely empty
        if (x.val != null) return x;
        for (int c = 0; c &lt; R; c++)
            if (x.next[c] != null) return x;

        return null;
    }

    private Node get(Node x, String key, int d) {
        if (x == null) return null;
        if (d == key.length()) return x;
        char c = key.charAt(d);
        return get(x.next[c], key, d + 1);
    }

    public boolean contains(String key) {
        return get(key) != null;
    }

    public void put(String key, Value val) {
        if (val == null) delete(key);
        else root = put(root, key, val, 0);
    }

    private Node put(Node x, String key, Value val, int d) {
        if (x == null) x = new Node();
        if (d == key.length()) {
            if (x.val == null) N++;
            x.val = val;
            return x;
        }

        char c = key.charAt(d);
        x.next[c] = put(x.next[c], key, val, d + 1);
        return x;
    }
}
</code></pre>

<h3 id="ternarysearchtries">Ternary Search Tries</h3>

<p>이전의 <em>R-way</em> 는 <code>R</code> 개의 자식들을 가졌지만, <em>ternary</em> 에서는 <code>3</code> 개만 가진다. <del>이것도 교수님이 만듬</del></p>

<ul>
<li>Store chars and values in nodes (not keys)</li>
<li>Each node has 3 children; smaller, equal, larger</li>
</ul>

<p><em>binary search</em> 와 거의 유사하다. 그냥 <em>key</em> 를 <em>string</em> 로 사용하고 효율적인 검색을 위해 노드에 <em>character</em> 를 저장한다는 점만 다르고. 이 차이점을 그냥 교수님은 <em>tree</em> 가 아니라 <em>trie</em> 라 부르는 것 같다.</p>

<p>어쨌든 <em>ternary</em> 는 <em>r-way</em> 보다 <em>null link</em> 자체가 훨씬 적다. 따라서 메모리 사용량에 부담 없고, <em>hash table</em> 보다 상당히 빠른 <em>search miss</em> 를 보여준다. 구현은 <a href='http://algs4.cs.princeton.edu/52trie/TST.java.html' >여기로</a></p>

<h4 id="tstimpelementation">TST Impelementation</h4>

<pre><code class="java">public class TernaryST&lt;Value&gt; {

    private int N;
    private Node root;

    private class Node {
        private char c;
        private Value val;
        private Node left, mid, right;
    }

    public TernaryST() { N = 0; }

    public int size() { return N; }
    public boolean isEmpty() { return size() == 0; }

    public boolean contains(String key) {
        return get(key) != null;
    }

    public Value get(String key) {
        if (key == null) throw new NullPointerException();
        if (key.length() == 0) throw new IllegalArgumentException("key shouldn't be empty");

        Node x = get(root, key, 0);
        if (x == null) return null;
        return x.val;
    }

    private Node get(Node x, String key, int d) {
        if (key == null) throw new NullPointerException();
        if (key.length() == 0) throw new IllegalArgumentException("key shouldn't be empty");
        if (x == null) return null;

        char c = key.charAt(d);
        if      (c &lt; x.c)               return get(x.left, key, d);
        else if (c &gt; x.c)               return get(x.right, key, d);
        else if (d &lt; key.length() - 1)  return get(x.mid, key, d + 1);
        else                            return x;
    }

    public void put(String key, Value val) {
        if (!contains(key)) N++;
        root = put(root, key, val, 0);
    }

    private Node put(Node x, String key, Value val, int d) {
        char c = key.charAt(d);

        if (x == null) {
            x = new Node();
            x.c = c;
        }

        if      (c &lt; x.c)               x.left = put(x.left, key, val, d);
        else if (c &gt; x.c)               x.right = put(x.right, key, val, d);
        else if (d &lt; key.length() - 1)  x.mid = put(x.mid, key, val, d + 1);
        else                            x.val = val;

        return x;
    }   
}
</code></pre>

<p>항상 느끼는건데, <em>imperative</em> 언어에서의 재귀가 더 어려운 것 같다.</p>

<h4 id="tstperformance">TST Performance</h4>

<p>(1) <strong>R-way trie</strong></p>

<ul>
<li><strong>search hit:</strong> <code>L</code></li>
<li><strong>search miss:</strong> <code>log_R N</code></li>
<li><strong>insert:</strong> <code>L</code></li>
<li><strong>space:</strong> <code>(R + 1) * N</code></li>
</ul>

<p>(2) <strong>Ternary trie(TST)</strong></p>

<ul>
<li><strong>search hit:</strong> <code>L + ln N</code></li>
<li><strong>search miss:</strong> <code>ln N</code></li>
<li><strong>insert:</strong> <code>L + ln N</code></li>
<li><strong>space:</strong> <code>4N</code></li>
</ul>

<p>메모리가 <code>4N</code> 밖에 안든다! 해싱은 모든 연산이 <code>L</code> 이겠지만, 대신 메모리가 <code>4N ~ 16N</code> 이다.</p>

<p>따라서 <em>ternary symbol table</em> 은 <em>hash table</em> 만큼 빠르고, 메모리도 덜 든다.</p>

<p>참고로 <em>rotation</em> 연산을 이용해서 <em>balanced TST</em> 를 만들면 <em>worst case</em> 에도 <code>L + logN</code> 이 나온다.</p>

<h4 id="tstwithr2branchingatroot">TST with R2 Branching at root</h4>

<p>꼭대기엔 <code>R^2-way</code> 로 짓고, 자식은 <em>TST</em> 로 지을 수 있다. 분석 결과로는 일반 <em>TST</em> 보다 더 빠르다고 한다.</p>

<h4 id="tstvshashing">TST vs Hashing</h4>

<p>(1) Hashing</p>

<ul>
<li>Need to examine entier key</li>
<li>Search hits and misses cost about the same</li>
<li>Performance relies on hash function</li>
<li>Does not support ordered symbol table operations.</li>
</ul>

<p>(2) TST</p>

<ul>
<li>Works only for strings (or digital keys)</li>
<li>Only examines just enough key characters</li>
<li>Search miss may involve only a few characters</li>
<li>Supports ordered symbol table operations (plus others!).</li>
</ul>

<p>정리하면, <em>TST</em> 는 해싱만큼 빠르고 <em>search miss</em> 는 더 빠르다. 그리고 <em>red-black BST</em> 보다 유연하다. 그러나 자료의 형태에 제한이 있다.</p>

<h3 id="characterbasedoperations">Character-Based Operations</h3>

<p><em>string symbol table</em> 의 경우에는 유용한 <em>chars-based operation</em> 을 제공한다. </p>

<ul>
<li><em>prefix match</em> </li>
<li><em>wildcard match</em> </li>
<li><em>longest prefix</em></li>
</ul>

<p><em>API</em> 를 보면</p>

<pre><code class="java">public class SymbolST&lt;Value&gt; {

  ...
  ...

  Iterable&lt;String&gt; keys()
  Iterable&lt;String&gt; keysWithPrefix  (String s)
  Iterable&lt;String&gt; keysThatMatch   (String s)
  String           longestPrefixOf (String s) 

  ...
  ...
}
</code></pre>

<p>이 외에도 <em>ordered ST</em> 를 위한 <em>floor, rank</em> 등의 연산도 추가할 수 있다.</p>

<h4 id="inordertraverseoftrie">Inorder Traverse of Trie</h4>

<p>탐색이 이진트리하고 좀 다른게, 매 문자열마다 시작점부터 시작해야 된다. <em>leaf</em> 까지 방문하는건 같은데</p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/250px-Trie_example.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org/wiki/Trie' >http://en.wikipedia.org/wiki/Trie</a>)</p>

<pre><code class="java">public Iterable&lt;String&gt; keys() {  
  Queue&lt;String&gt; q = new Queue&lt;String&gt;();
  collect(root, "", q);
  return q;
}

public void collect(Node x, String prefix, Queue&lt;String&gt; q) {  
  if (x == null) return;
  if (x.val != null) q.enequeue(prefix);

  for (char c = 0; c &lt; R; c++)
    collect(x.next[c], prefix + c, q);
}
</code></pre>

<p><em>queue</em> 는 단순히 <code>she</code> 를 방문할때 <code>she</code> 를 저장하기 위한 용도다. <code>val != null</code> 일 때 저장하므로 <code>s, sh</code> 등은 저장하지 않는 다는 점에 유의하자.</p>

<p>그리고 여기서 큐는 <em>DFS, BFS</em> 처럼 로직에 쓰이지 않는다. 모든 노드를 방문하긴 하는데 <code>c = 0</code> 부터 시작하니 왼쪽부터 방문하는 재귀 순회라 보면 쉽다.</p>

<p>여기서 <code>collect</code> 함수는 인자로 받은 노드 <code>x</code> 를 기준으로 하위에 있는 <em>substring</em> 을 찾아낸다.</p>

<p>실제 구현에서는 <code>StringBuilder</code> 를 사용한다.</p>

<pre><code class="java">    private void collect(Node x, StringBuilder prefix, Queue&lt;String&gt; q) {
        // TODO Auto-generated method stub

        if (x == null) return;
        if (x.val != null) q.add(prefix.toString());

        for (char c = 0; c &lt; R; c++) {
            prefix.append(c);
            collect(x.next[c], prefix, q);
            prefix.deleteCharAt(prefix.length() - 1);
        }
    }

    public Iterable&lt;String&gt; keys() { return keysWithPrefix(""); }
</code></pre>

<h4 id="prefixmatchs">Prefix Matchs</h4>

<p>구글링 하면서 매일 사용하는 기능이다. 구현은 위의 <code>collect</code> 함수를 사용하면 쉽다. <code>keyWithPrefix("sh")</code> 라면, <code>sh</code> 까지 내려간 뒤 <code>collect</code> 를 호출하면 된다.</p>

<pre><code class="java">public Iterable&lt;String&gt; keysWithPrefix(String prefix) {  
  Queue&lt;String&gt; q = new Queue&lt;String&gt;();
  Node x = get(root, prefix, 0);
  collect(x, prefix, q);
  return q;
}
</code></pre>

<p>자바의 <code>Queue</code> 는 인터페이스이므로 실제 구현은</p>

<pre><code class="java">    public Iterable&lt;String&gt; keysWithPrefix(String prefix) {
        Queue&lt;String&gt; q = new LinkedList&lt;String&gt;();
        Node x = get(root, prefix, 0);
        collect(x, new StringBuilder(prefix), q);
        return q;
    }
</code></pre>

<h4 id="longestprefix">Longest Prefix</h4>

<p>라우터에서 자주 사용한다. 아이피를 문자열로 표현하고, 자기가 알고 있는 인접한 라우터중 어디로 보낼지를 결정하기 위해 <em>longest prefix</em> 를 알아내 보낸다. </p>

<pre><code class="java    ">longestPrefixOf("128.112.136.11")  
// 128.112.136
</code></pre>

<p>아이디어는 간단하다. <code>null</code> 이나 찾으려는 문자열의 마지막 문자를 만나기 전까지의 문자열을 모아 돌려주면 된다.</p>

<pre><code class="java">public String longestPrefixOf(String query) {  
  int length = search(root, query, 0, 0);
  return query.substring(0, length);
}

public int search(Node x, String query, int d, int length) {

  if (x == null) return length;
  if (x.val != null) length =  d;
  if (d == query.length) return length;

  char c = query.charAt(d);
  return search(x.next[c], query, d + 1, length);
}
</code></pre>

<h4 id="patriciatrie">Patricia Trie</h4>

<p><code>shells, shellfish</code> 를 넣으면 브랜칭이 길게 이루어진다. 메모리 낭비가 있을 수 있는데, <code>shell</code> 밑에 <code>s, fish</code> 를 자식으로 만들면 괜찮다.</p>

<p>그러나 이 강의의 범위를 넘어서는 것이라 안알려준다고 함 ㅠㅠ. 이미지를 구해서 첨부하면</p>

<p><img src='http://2.bp.blogspot.com/-0B8D2LHyQVc/USMklcwZnMI/AAAAAAAAAKc/UBmZnHflOa0/s640/radix_tries.png'  alt="" /></p>

<p><img src='http://3.bp.blogspot.com/-nQ0ZUeIpDrQ/USMkvNUKHBI/AAAAAAAAAKk/rrvVaYU4Pwo/s640/fractal+tries.png'  alt="" /></p>

<p align="center">(<a href='http://aketa.blogspot.kr/' >http://aketa.blogspot.kr</a>)</p>

<p>아마도 통짜로 삽입 후 이후에 비슷한 <em>suffix</em> 의 문자열이 들어오면 분리를 시키는 것 같다. </p>

<h4 id="suffixtree">Suffix Tree</h4>

<p><img src='http://marknelson.us/attachments/1996/suffix-trees/FIGURE2.gif'  alt="" /></p>

<p align="center">(<a href='http://marknelson.us/' >http://marknelson.us</a>)</p>

<p>문자열 <em>suffix</em> 의 <em>patricia trie</em> 인데 <em>linear time</em> 으로 만들 수 있다고 한다.</p>

<ul>
<li>longest repeated substring</li>
<li>longest common substring</li>
</ul>

<p>등에 쓸 수 있단다.</p>

<h3 id="summary">Summary</h3>

<p>(1) Red-Black BST</p>

<ul>
<li><strong>Performance guarantee:</strong> <code>lg N</code> key compares</li>
<li>Supports ordered symbol table API</li>
</ul>

<p>(2) Hash Table</p>

<ul>
<li><strong>Performance guarantee:</strong> <em>constant</em> number of probes</li>
<li>Requires good hash function for key type</li>
</ul>

<p>(3) R-way, TST</p>

<ul>
<li><strong>Performance guarantee:</strong> <code>lg N</code> <em>character</em> accessed </li>
<li>Supports <em>character-based</em> operations</li>
</ul>

<blockquote>
  <p>You can get at anything by examining 50-100 bits!</p>
</blockquote>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://t2.hhg.to/V12-lausn.html' >http://t2.hhg.to</a> <br />
(3) <a href='http://en.wikipedia.org/wiki/Trie' >Wikipedia: Trie</a> <br />
(4) <a href='http://aketa.blogspot.kr/2013/02/squeezed-tries-fractal-compression-for.html' >Squeezed Tries, Fractal Compression</a> <br />
(5) <a href='http://marknelson.us/1996/08/01/suffix-trees/' >Mark Nelson</a></p>]]></description><link>http://1ambda.github.io/r-way-ternary-search-tries/</link><guid isPermaLink="false">68259e58-854a-4a4f-a621-ee864f210992</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[r-way trie]]></category><category><![CDATA[ternary trie]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 16 Dec 2014 08:49:07 GMT</pubDate></item><item><title><![CDATA[Machine Learning, Week 10]]></title><description><![CDATA[<p>이번 주에는 <em>mini-batch, stochastic graident descent</em>, <em>online learning</em>, <em>map-reduce</em> 등의 개념에 대해 배운다.</p>

<h3 id="learningwithlargedatasets">Learning With Large Datasets</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361499744_2717.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>왜 그렇게 큰 데이터 셋이 필요할까? 좋은 퍼포먼스를 얻기 위한 한 가지 방법이, <em>low bias</em> 알고리즘에 <em>massive data</em> 를 활용해 훈련하는 것이기 때문이다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361499747_9327.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>그러나 커다란 데이터 셋을 연산하기 위해서는 연산비용이 정말 비싸다. 예를 들어 
<code>m = 100,000,000</code> 이라 하면 <em>gradient</em> 를 계산하기 위해 매번 <code>k * m</code> 의 연산이 필요하다.</p>

<p>따라서 모든 데이터를 이용해 알고리즘을 훈련하기 보다는, 랜덤하게 고른 작은 서브셋에 대해서 알고리즘을 개발하고, 이후에 전체 데이터에 대해서 훈련하는 방법을 쓰기도 한다.</p>

<p>그러면 <code>m</code> 이 작아도 알고리즘이 충분히 잘 훈련된다는 것을 어떻게 보장할까? 이는 <em>learning curve</em> 를 그려보면 된다.</p>

<p>위 슬라이드에서 우측 하단은 <em>high bias</em> 알고리즘인데 <code>m</code> 을 많이 투입해도 별다른 이득이 없으므로 적당한 수준에서 <code>m</code> 을 정하면 된다.</p>

<p>물론 만든 알고리즘이 우측처럼 <em>high bias</em> 로 나오면, 좀 더 자연스러운 생각은 <em>hidden layer</em> 를 추가한다거나, 새로운 <em>feature</em> 를 도입해서 <em>bias</em> 를 낮추는 것이다.</p>

<p><br/></p>

<h3 id="stochsticgradientdescent">Stochstic Gradient Descent</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361500908_4667.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>gradient descent</em> 를 이용하는 <em>linear regression</em> 에서</p>

<p><img src='http://latex.codecogs.com/gif.latex?h_%5Ctheta%28x%29%20%3D%20%5Csum_%7Bj%3D0%7D%5En%20%5C%20%5Ctheta_jx_j'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?J_%7Btrain%7D%28%5Ctheta%29%20%3D%20%7B1%20%5Cover%202m%7D%20%5Csum_%7Bi%3D1%7D%5Em%5C%20%28h_%5Ctheta%28x%29%5E%7B%28i%29%7D%20-%20y%5E%7B%28i%29%7D%29%5E2'  alt="" /></p>

<p>이미 언급했듯이 <em>batch gradient descent</em> 의 문제는, <code>m</code> 이 크면 <code>J</code> 의 연산이 어마어마하게 많아진다는 것이다. 매 스텝마다 <code>m</code> 을 읽고, 계산값을 저장하기 때문이다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361501694_2445.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>이 문제를 해결하기 위해 <em>stochastic gradient descent</em> 에서는 한 턴에 한 쌍의 <code>x, y</code> 에 대해서만 <em>gradient</em> 를 계산한다.</p>

<p><em>batch gradient decsent</em> 에서는 한 턴마다 모든 모든 쌍의 <code>x, y</code> 에 대해     <em>gradient</em> (= <code>theta_j</code>) 를 계산 했었다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?cost%28%5Ctheta%2C%20%28x%5E%7B%28i%29%7D%2C%20y%5E%7B%28i%29%7D%29%29%20%3D%20%7B1%20%5Cover%202%7D%5C%20%28h_%5Ctheta%28x%5E%7B%28i%29%7D%20-%20y%5E%7B%28i%29%7D%29%5E2'  alt="" /></p>

<p><img src='http://latex.codecogs.com/gif.latex?J_%7Btrain%7D%28%5Ctheta%29%20%3D%20%7B1%20%5Cover%20m%7D%20%5Csum_%7Bi%3D1%7D%5Em%20cost%28%5Ctheta%2C%20%28x%5E%7B%28i%29%7D%2C%20y%5E%7B%28i%29%7D%29%29'  alt="" /></p>

<p>라고 하면</p>

<pre><code>- Randomly shuffle dataset  
- Repeat for i = 1 to m
  - 0_j := 0_j - a * derivative of cost(0, (xi, yi)
</code></pre>

<p>즉 <code>J_train</code> 의 미분 대신에 <code>cost</code> 의 미분값을 이용해서 연산을 줄이는 방법이다. 이 때 데이터가 이미 랜덤하게 섞였다는 점을 기억하자. 기하학적으로 보면</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361502040_9252.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>batch</em> 에서는 올바른 방향을 향해 가지만, 보폭이 좀 좁다. <em>stochastic</em> 은 이리 갔다, 저리 갔다 하지만 결국에는 최저점을 향해 간다. 다만 <em>global optima</em> 에 도달하지 못하고 그 근처에 도착할 수 있다.</p>

<p><code>m</code> 이 굉장히 크면, <em>repeat</em> 부분의 루프를 1번만 돌려도 될 테지만, 작으면 여러번 돌려서 최대한 좋은 퍼포먼스를 내도록 훈련시킬 수 있다.</p>

<p><br/></p>

<h3 id="minbatchgradientdescent">Min-Batch Gradient Descent</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361503946_9357.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<ul>
<li><strong>Batch gradient descent:</strong> Use all <code>m</code> examples in each iteration</li>
<li><strong>Stochastic gradient descent:</strong> Use <code>1</code> example in each iteration</li>
<li><strong>Batch gradient descent:</strong> Use <code>b</code> examples in each iteration</li>
</ul>

<p><img src='http://latex.codecogs.com/gif.latex?%5Ctheta_j%20%3A%3D%20%5Ctheta-j%20-%20%7B%5Calpha%20%5Cover%20b%7D%20%5Csum_%7Bk%20%3D%20i%7D%5E%7Bi%20&plus;%20b%20-%201%7D%20%28h_%5Ctheta%28x%5E%7B%28k%29%7D%29%20-%20y%5E%7B%28k%29%7D%29%20x_j%5E%7B%28k%29%7D'  alt="" /></p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361504164_4561.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><code>b</code> 는 보통 <code>2 - 100</code> 사이의 값이기 때문에 <em>batch</em> 보다 훨씬 빠르다. 또한 <em>vectorization</em> 을 이용하면 <em>gradient computation</em> 을 <em>partially parallelize</em> 할 수 있기 때문에 <em>stochastic</em> 보다 더 빠를 수 있다. <del>병렬화의 미덕</del></p>

<p>단점으로는 추가적인 파라미터 <code>b</code> 가 필요하다는 점이다. 그러나 <em>vectorization</em> 을 잘 이용하면 더 빨라지므로 문제 없다.</p>

<p><br/></p>

<h3 id="stochasticgradientdescentconvergence">Stochastic Gradient Descent Convergence</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361519060_5993.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>convergence</em> 를 검증하는 방법으로, 훈련시키는 동안 얻은 <code>cost(0, (xi yi)</code> 평균값을 이용해 플롯을 그릴 수 있다.     </p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361519096_5186.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>stochastic</em> 은 <em>global optimum</em> 을 찾아내지 못할 수도 있기 때문에, 그 주변에서 알짱거릴 수도 있다.</p>

<p>더 많은 <code>m</code> 을 투입하면, 까끌거리는 선보다 좀 매끄러운 곡선을 얻을 수도 있다.</p>

<p>때때로 알고리즘이 전혀 학습하지 못하는 것 처럼 보일수도 있는데, 그럴 경우 <code>m</code> 을 더 투입하면 좀 경사가 낮은 커브로 조금씩 <em>decreasing</em> 할 수 있다. 이를 보면 결국 훈련되긴 하는데, 평균값을 플랏으로 그리니 들쭉날쭉 해 보이는 것이다. (물론 학습하지 못하는 경우도 있다. <code>m</code> 을 더 늘려서 확인해 보자.)</p>

<p><code>cost</code> 값이 증가한다면 더 작은 <em>learning late</em> 값을 이용하자.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361519184_7199.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>learning rate</em> 와 관련해서 위 슬라이드처럼 식을 만들면, 이터레이션 넘버가 천천히 증가하면서 <code>alpha</code> 가 감소해 <em>converge</em> 하는 결과를 얻을 수 있다.</p>

<blockquote>
  <p>If we reduce learning rate <code>alpha</code> (and run stochastic gradient descent long enough), it's possible that we may find a set of better parameters than with large <code>alpha</code></p>
</blockquote>

<p><br/></p>

<h3 id="onlinelearning">Online Learning</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361520551_7175.jpg'  alt="" /></p>

<p><em>online learning</em> 에서는 데이터를 얻어 <code>theta</code> 를 업데이트하는데 사용하고, 버린다. 큰 사이트라면 데이터가 지속적으로 들어오기 때문에, <em>trianing data</em> 를 볼 필요가 없다. 다시 말해 같은 데이터를 두번 이상 쓰지 않는다는 말이다.</p>

<p>또 다른 장점으로는 사용자의 취향 변화를 빠르게 반영할 수 있다는 점이다.</p>

<blockquote>
  <p>Can adopt to changing user preference</p>
</blockquote>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361520594_9988.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>product search</em> 에 <em>predicted CTR</em> 를 이용해, 검색어와 잘 매칭되는 상품을 결과로 돌려수 있다. 이때 매 검색마다 돌려주는 검색결과는 일종의 <em>training set</em> 이 된다.</p>

<ul>
<li>special offers</li>
<li>customized selection</li>
</ul>

<p>등에도 사용할 수 있다.</p>

<p><br/></p>

<h3 id="mapreduceanddataparallelism">Map Reduce and Data Parallelism</h3>

<p>데이터가 어마어마하게 많으면, 하나의 컴퓨터에서 머신러닝 알고리즘을 돌리기가 좀 힘들다. 어떻게 해결할까?</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361522176_1942.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/22/1361522180_7521.jpg'  alt="" /></p>

<p>쉽게 말하면, 분산해서 처리할 수 있는 결과는 <code>map</code> 으로 해결하고, 이 결과들을 이용해 전체적인 결과는 <code>reduce</code> 가 계산한다. (실제로는 <code>reduce</code> 도 여러개 일 수 있다)</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361522184_5033.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<blockquote>
  <p>Many lenaring algorithms can be expressed as computing sums of functions over the training set</p>
</blockquote>

<p>이렇기 때문에 <em>map-reduce</em> 가 큰 데이터셋에 대한 계산 처리 방법으로 좋은 해결책이 될 수 있다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/22/1361522188_9650.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>요즘엔 대부분의 프로세서가 멀티코어이기 때문에, 하나의 컴퓨터에서도 병렬화를 이용해 계산을 빠르게 해 낼 수 있다. 이 경우는 <em>network latency</em> 등에 대해 생각을 안해도 된다. 참고로 좋은 라이브러리들은 자동으로 연산을 병렬화한다. </p>

<p><br/></p>

<h3 id="photoocrandpipeline">Photo OCR and Pipeline</h3>

<p>머신러닝 예제로 <em>Photo OCR</em> 을 알아보자.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361935712_3407.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><em>Photo OCR pipeline</em> 은 </p>

<ul>
<li>Image</li>
<li>Text detection</li>
<li>Character segmentation</li>
<li>Character recognition</li>
</ul>

<p>의 단계를 거친다. 각 단계마다 머신러닝을 적용할 수 있다.</p>

<p><br/></p>

<h3 id="slidingwindows">Sliding Windows</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361936303_5994.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361936307_1350.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361937647_2708.jpg'  alt="" /></p>

<p>텍스트나, 보행자등 특정 패턴을 검색하기 위해 이동하는 <em>rectangle</em> 의 단위를 <em>step-size, slide</em> 라 부른다. <em>slide</em> 의 사이즈를 변경해 가면서 패턴을 파악하는 방법을 <em>sliding window</em> 라 부른다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361937654_3410.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361937664_2466.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>텍스트를 인식해서, 근처의 텍스트와 묶는 <em>expansion</em> 작업을 하고 <em>character segmentation</em> 단계로 넘어간다. </p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361937671_6657.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361937676_4874.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><br/></p>

<h3 id="artificialdata">Artificial Data</h3>

<p><em>low bias</em> 에 <em>massive data set</em> 을 조합하면 좋은 퍼포먼스가 나오긴 하는데, 어디서 커다란 데이터셋을 구할까? 작은 데이터 셋으로 커다란 데이터셋을 인위적으로 만들 수 있을까?</p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361948453_3756.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361948457_9107.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361948462_1113.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>스케일링, 로테이션, 디스토션, 백그라운드 수정 등 다양한 조합을 통해 진짜처럼 보이는 <em>synthetic data</em> 를 얻을 수 있다. 마찬가지로, <em>speech recognition</em> 에도 <em>synthetic data</em> 를 만들어 퍼포먼스를 높일 수 있다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361948466_5032.jpg'  alt="" /></p>

<ul>
<li><em>synthetic data</em> 를 만들기 전에 <em>low bias classifier</em> 인지 확인하자.</li>
<li>데이터를 조합하는데 들어가는 노력이 얼마나 들까 생각해보자</li>
<li><em>crowd source</em> 를 고려하자. (e.g. Amazon Mechanical Turk)</li>
</ul>

<p>10 초당 1개의 <em>example</em> 을 수동으로 얻는다면, 10000 개를 얻는데 대략 3.5일의 시간이 걸린다.</p>

<h3 id="ceilinganalysis">Ceiling Analysis</h3>

<p>이전의 <em>Photo OCR</em> 문제에서 퍼포먼스를 높이려면 파이프라인의 각 단계 중 어느 부분에 가장 많은 노력을 들여야할까? </p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361952527_2269.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p>각 단계에서 수동으로 정확도 100% 를 만들었을때와, 전체적인 정확도를 비교해서 어느 부분을 향상 시켰을때 가장 효율적일지를 파악할수 있다.  </p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361952535_9451.jpg'  alt="" />
<img src='http://img.my.csdn.net/uploads/201302/27/1361952540_1528.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><br/></p>

<h3 id="summary">Summary</h3>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361952938_3624.jpg'  alt="" /></p>

<p align="center">(<a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a>)</p>

<p><strong>supervised learning</strong> 의 종류로</p>

<ul>
<li>linear regresison</li>
<li>logistic regression</li>
<li>neural networks</li>
<li>SVM</li>
</ul>

<p><strong>unsupervised learning</strong> 으로</p>

<ul>
<li>k-means</li>
<li>PCA</li>
<li>anomaly detection</li>
</ul>

<p>또한 머신 러닝의 응용으로</p>

<ul>
<li>recommender system</li>
<li>large scale ML</li>
</ul>

<p>마지막으로 머신러닝에 도움이 되는 주제로</p>

<ul>
<li>bias vs variance</li>
<li>regularization</li>
<li>evaluation technique</li>
<li>learning curve</li>
<li>error analysis</li>
<li>ceiling analysis</li>
</ul>

<p>등을 배웠다.</p>

<p><img src='http://img.my.csdn.net/uploads/201302/27/1361953290_6926.jpg'  alt="" /></p>

<h3 id="references">References</h3>

<p>(1) <em>Machine Learning</em> by <strong>Andrew NG</strong> <br />
(2) <a href='http://blog.csdn.net/linuxcumt' >http://blog.csdn.net/linuxcumt</a> <br />
(3) <a href='http://blog.csdn.net/abcjennifer' >http://blog.csdn.net/abcjennifer</a>  </p>]]></description><link>http://1ambda.github.io/machine-learning-week-10/</link><guid isPermaLink="false">5ffe5848-c50e-42ff-84ab-153d47f0c7d3</guid><category><![CDATA[coursera]]></category><category><![CDATA[machine learning]]></category><category><![CDATA[stochastic gradient descent]]></category><category><![CDATA[mini-batch gradient descent]]></category><category><![CDATA[online learning]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 15 Dec 2014 03:14:52 GMT</pubDate></item><item><title><![CDATA[Radix Sort, Suffix Sort]]></title><description><![CDATA[<h3 id="stringsinjava">Strings in Java</h3>

<p>문자열은 <em>Character (문자)</em> 의 나열이다. C 에서 하나의 캐릭터는 <em>8-bit</em> 인데, 자바의 경우에는 <em>16-bit unsigned integer</em> 로 표시한다. </p>

<p>스트링의 길이를 얻기 위해 <code>length</code>, 인덱싱 하기 위해 <code>charAt</code>, 서브스트링을 얻기 위해 <code>substring</code> 의 메소드를 지원한다.</p>

<pre><code class="java">public final class String implements Comparable&lt;String&gt; {

  private char values;
  private int offset; // index of first char in array
  private int length;
  private int hash; // cache of hashCode()

  ...

  public char charAt(int i) {
    return value[i + offset];
  }

  ...
}
</code></pre>

<p>자바에서 문자열은 <em>immutable</em> 이다. 더 정확히는 <em>immutable</em> <code>char []</code> <em>array</em> 라 보면 된다. 길이 정보를 가지고 있고 배열이기 때문에 <code>length</code>, <code>charAt</code>, <code>substring</code> 등의 연산은 <code>O(1)</code> 임을 보장한다.</p>

<p><code>concat</code> 의 경우에는 새로운 문자열을 만들기 때문에 <code>O(N)</code> 이다. 메모리는 길이 <code>N</code> 의 문자열에 대해 <code>40 + 2N</code> 을 필요로 한다. 메모리를 아껴야 한다면 <em>byte, char</em> 을 이용할 수 있겠지만 여러 편리한 스트링의 메소드를 사용하지 못한다.</p>

<h3 id="stringbuilderstringbuffer">StringBuilder, StringBuffer</h3>

<p><code>StringBuilder</code> 는 <em>mutable</em> 이다. <code>char []</code> 배열을 <em>resizing</em> 하기 때문에 </p>

<ul>
<li><code>substirng</code> 의 경우 <code>O(N)</code> 이며 (새 스트링을 만든다)</li>
<li><code>concat</code> 은 <code>O(1*)</code> 이다. (<code>*</code> 는 amortized)</li>
</ul>

<p><code>length, charAt</code> 은 마찬가지로 <code>O(1)</code> 이다. 참고로 <code>StringBuffer</code> 는 <code>StringBuilder</code> 와 비슷하지만 <em>thread safe</em> 하고, 느리다.</p>

<p>그러면 <em>reverse</em> 를 구현 할 때 <code>String</code> 과 <code>StringBuilder</code> 중 어떤 것이 더 나을까?</p>

<pre><code class="java">// 1. use String
public static String reverse(String s) {  
  String rev = "";
  for (int i = s.length() - 1; i &gt;= 0; i--)
    rev += s.charAt(i);

  return rev;
}  

// 2. use StringBuilder
public static String reverse(String s) {  
  StringBuilder rev = new StringBuilder();
  for (int i = s.length() - 1; i &gt;= 0; i--)
    rev.append(s.charAt(i));

  return rev.toString();
}  
</code></pre>

<p><code>String</code> 을 이용한 버전은 <code>O(n^2)</code> 이고, <code>StringBuilder</code> 를 이용한 버전은 <code>O(n)</code> 이다. 이는 <code>+=</code> 와 <code>append</code> 의 차이 때문이다.</p>

<p><em>suffixes</em> 문제도 생각해 보자.</p>

<pre><code class="java">// input string
a a c a a g t t a c a a g c

// output
c     // suffixes 14  
g c   // suffixes 13  
a g c // suffixes 12  
...
...
a a c a a g t t a c a a g c // suffixes 0  
</code></pre>

<p><code>String</code> 과 <code>StringBuilder</code> 의 구현을 생각해 보면,</p>

<pre><code class="java">// 1. use String 
public static String[] suffixes(String s) {  
  int N = s.length();
  String[] suffixes = new String[N];

  for (int i = 0; i &lt; N; i ++)
    suffixes[i] = s.substring(i, N);

  return suffixes;
}

// 2. use StringBuilder 
public static String[] suffixes(String s) {  
  int N = s.length;
  stringBuilder sb = new StringBuilder(s);
  String suffixes = new String

  for (int i = 0; i &lt; N; i++)
    suffixes[i] = s.substring(i, N);

  return suffixes;
}
</code></pre>

<p>당연히 <code>substring</code> 은 <code>String</code> 이 메모리 사용량이 훨씬 더 적을꺼라 생각했는데 Java7 Update6 부터 좀 달라졌다고 한다.</p>

<p><em>Java 7 Update 6</em> 부터는 이전처럼 <code>String</code> 의 <code>char []</code> 가 공유되지 않는단다. 따라서 <code>String.substring</code> 은 더이상 <em>constance space, time</em> 이 아니라 <em>linear space, time</em> 의 비용이 든다. 자세한 내용은 <a href='http://java-performance.info/changes-to-string-java-1-7-0_06/' >Changes to String Java 1.7.0-06</a>로 </p>

<p>따라서 알고리즘 <code>1</code> 은 <em>linear time, space</em> <code>2</code> 는 <em>quadratic time, space</em> 의 알고리즘이다.</p>

<h4 id="longestcommonprefix">Longest common prefix</h4>

<pre><code class="java">public static int lcp(String s, String t) {  
  int n = Math.min(s.length(), t.length());

  for (int i = 0; i &lt; n; i++)
    if (s.charAt(i) != t.charAt(i))
      return i;

  return n;
}
</code></pre>

<p>러닝타임은 <code>s, t</code> 중 더 긴 문자열의 길이에 비례한다. 일반적으로는 <em>sublinear time</em> 이다. 따라서 <code>compareTo</code> 메소드를 <em>sublinear time</em> 으로 구현할 수 있다.</p>

<h4 id="radix">Radix</h4>

<p>알파벳을 다양한 형태로 표현할 수 있는데, <em>binary</em> 의 경우엔 <code>01</code> 이 될 것이다. 이때의 <em>radix</em> 는 2 다. <em>DNS</em> 는 <code>ACTG</code> 로 표현할 수 있으므로 <code>R = 4</code> 다.</p>

<h3 id="keyindexedcounting">Key-Indexed Counting</h3>

<p>정렬 알고리즘의 성능을 정리해 보면,</p>

<p>(1) <strong>Insertion Sort</strong></p>

<ul>
<li><strong>guarantee:</strong> <code>O(N^2 / 2)</code></li>
<li><strong>random:</strong> <code>O(N^2 / 4)</code></li>
<li><strong>extra space:</strong> <code>1</code></li>
<li><strong>stable:</strong> <code>yes</code></li>
</ul>

<p>(2) <strong>Merge Sort</strong></p>

<ul>
<li><strong>guarantee:</strong> <code>O(N log N)</code></li>
<li><strong>random:</strong> <code>O(N log N)</code></li>
<li><strong>extra space:</strong> <code>N</code></li>
<li><strong>stable:</strong> <code>yes</code></li>
</ul>

<p>(3) <strong>Quick Sort</strong></p>

<ul>
<li><strong>guarantee:</strong> <code>O(1.39 N log N)</code></li>
<li><strong>random:</strong> <code>O(1.39 N log N)</code></li>
<li><strong>extra space:</strong> <code>c log N</code></li>
<li><strong>stable:</strong> <code>no</code></li>
</ul>

<p>(4) <strong>Heap Sort</strong></p>

<ul>
<li><strong>guarantee:</strong> <code>O(2 N log N)</code></li>
<li><strong>random:</strong> <code>O(2 N log N)</code></li>
<li><strong>extra space:</strong> <code>1 log N</code></li>
<li><strong>stable:</strong> <code>no</code></li>
</ul>

<p>이런 <em>comparison based</em> 알고리즘은 <em>lower bound</em> 가 <code>N log N</code> 이다. 따라서 <em>key compare</em> 를 하지 않는다면 더 나은 성능을 낼 수 있다.</p>

<p><em>key-indexed counting</em> 에서는 <em>key</em> 가 <code>0</code> 부터 <code>R - 1</code> 사이의 정수라 가정한다. 따라서 키를 배열의 인덱스로 사용할 수 있다.</p>

<p>따라서 다음처럼 활용할 수 있다.</p>

<ul>
<li>Sort String by first letter</li>
<li>Sort class roster by section</li>
<li>Sort phone number by area code</li>
<li>Subroutine in a sorting algorithm</li>
</ul>

<p>알고리즘을 보자. </p>

<blockquote>
  <p><strong>Goal:</strong> Sort an array <code>a[]</code> of <code>N</code> integers between <code>0</code> and <code>R - 1</code></p>
</blockquote>

<p>(1) Count frequencies of each letter using key as index <br />
(2) Compute frequecy cumulates which specify destinations <br />
(3) Access cumulates using key as index to move items <br />
(4) Copy back into original array</p>

<pre><code class="java">int N = a.length();  
int[] count = new int[R + 1];

// step (1)
for (int i = 0; i &lt; N; i++)  
  count[a[i] + 1]++;

// step (2)
for (int r = 0; r &lt; R; r++)  
  count[r + 1] += count[r];

// step (3)
for (int i = 0; i &lt; N; i++)  
  aux[count[a[i]]++] = a[i];

// step (4)
for (int i = 0; i &lt; N; i++)  
  a[i] = aux[i];
</code></pre>

<ul>
<li><code>~11N + 4R</code> <em>array access</em></li>
<li><code>N + R</code> <em>extra space</em></li>
</ul>

<p><em>key-indexed counting</em> 은 <em>linear time, stable sorting</em> 이다.</p>

<h4 id="stable">Stable</h4>

<p>알고리즘이 <em>stable</em> 하다는 건 무슨 뜻일까? </p>

<blockquote>
  <p>A stable sort is one which preserves the original order of the input set while The unstable algorithm exhibits undefined behaviour when two elements are equal, it is perfectly possible that the order is sometimes preserved.</p>
</blockquote>

<p><img src='http://i.stack.imgur.com/hn6Rg.png'  alt="" /></p>

<p align="center">(<a href='http://programmers.stackexchange.com/' >http://programmers.stackexchange.com/</a>)</p>

<h3 id="lsdradixsort">LSD Radix Sort</h3>

<p><em>least-significant-digit-first string(radix) sort</em></p>

<p>아이디어는 간단하다. 우측부터 좌측으로 한 문자씩 <em>key-indexed couting</em> 을 하면 된다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTjVFR1ozVWpNaVJHTzVZV0x4QXpZNDBpWjNJMk10WW1ZeEVUTHlZak5pVkdOMWN6TDJnRE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<blockquote>
  <p>Which of the following is the most efficient algorithm to sort 1 million 32-bit integers?</p>
</blockquote>

<p>답은 <em>radix sort</em></p>

<h4 id="correctness">Correctness</h4>

<blockquote>
  <p>LSD sorts fixe-length strins in ascending order</p>
</blockquote>

<p>가설에 의해 <code>i</code> 번째 pass 후에는 뒤 부터 <code>i</code> 개의 문자들이 정렬되어 있다.  이 때 비교하려는 <code>i+1</code> 번째의 두 문자가 다르다면, <em>key-indexed sort</em> 가 두 개의 문자열을 정렬한다. 이 때 <em>key-indexed sort</em> 는 <em>stable</em> 하므로 이전 까지의 정렬했던 순서를 보존한다.</p>

<h4 id="implementation">Implementation</h4>

<pre><code class="java">    // W: fixed-length of strings
    public static void LSDsort(String[] a, int W) {
        int N = a.length;
        int R = 256;
        String[] aux = new String[N];

        // key indexed counting for each digit from right to left
        for (int d = W - 1; d &gt;= 0; d--) {
            int[] count = new int[R + 1];

            // count frequencies
            for (int i = 0; i &lt; N; i++) 
                count[a[i].charAt(d) + 1]++;

            for (int r = 0; r &lt; R; r++)     
                count[r + 1] += count[r];

            for (int i = 0; i &lt; N; i++)
                aux[count[a[i].charAt(d)]++] = a[i];

            for (int i = 0; i &lt; N; i++)
                a[i] = aux[i];
        }
    }
</code></pre>

<p><em>LSD sort</em> 퍼포먼스는 <code>2WN</code>, 랜덤하게 <code>2WN</code>, 공간은 <code>N + R</code>, <em>stable</em> 하다. 참고로, <code>4byte Int</code> 에 대해 <code>1Byte</code> 씩 <em>LSD sort</em> 를 적용하면 <code>Array.sort</code> 보다 2~3배 더 빠르다고 한다. <a href='http://algs4.cs.princeton.edu/51radix/LSD.java.html' >코드는 여기로</a></p>

<h3 id="msdradixsort">MSD Radix Sort</h3>

<p><em>most significant-digit-first string sort</em></p>

<ul>
<li>Partition array into <code>R</code> pieces according to first character</li>
<li>Recursively sort all strings that start with each character</li>
</ul>

<p>좌측 문자열 부터 시작하고, 현재 문자가 같은 문자열들 끼리 모아, 나머지 부분을 <em>sub-array</em> 취급해서 재귀적으로 정렬한다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWjNNV001VW1ZaWhETTRjVExoTldONDBpTTJVMk10RVdaeEFUTHpVRFptZHpNaEYyTDVFVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<p><em>LSD</em> 는 다루지 못하는 <em>variable-length string</em> 을 정렬할 수 있다.</p>

<h4 id="implementation">Implementation</h4>

<p>참고로 자바에서는 <code>\0</code> 이 없다. 그래서 문자열의 길이를 넘어서는 인덱스에 대해 <code>-1</code> 을 돌려주는 <code>charAt</code> 을 만들자. 추가적인 문자가 없다면, 정렬된 것으로 보고 끝내면 된다. </p>

<pre><code class="java">private static int charAt(String s, int d) {  
  if (d &lt; s.length()) return s.charAt(d);
  else return -1;
}

    private static void msdSort(String[] a, String[] aux, int l, int h, int d) {

        if (h &lt;= l) return;

        int R = 256;
        int[] count = new int[R + 2];

        // count frequencies
        for (int i = l; i &lt;= h; i++) {
            int c = charAt(a[i], d);
            count[c + 2]++;
        }

        // accumulate
        for (int r = 0; r &lt; R + 1; r++)
            count[r + 1] += count[r];

        // sort
        for (int i = l; i &lt;= h; i++) {
            int c = charAt(a[i], d);
            aux[count[c + 1]++] = a[i];
        }

        // copy
        for (int i = l; i &lt;= h; i++)
            a[i] = aux[i - l];

        // solve sub-arrays
        for (int r = 0; r &lt; R; r++)
            msdSort(a, aux, l + count[r], l + count[r + 1] - 1, d + 1);
    }

    public static void MSDsort(String[] a) {
        String[] aux = new String[a.length];
        msdSort(a, aux, 0, a.length - 1, 0);
    }
</code></pre>

<p>그런데 이 구현은 몇 가지 문제가 있다.</p>

<p>(1) 매 재귀마다 <code>count</code> 배열을 만들고, 그 크기는 <code>R</code> 에 비례하기 때문에 <code>~11R + N</code> 의 성능을 갖는 <em>key-indexed counting</em> 연산이 <em>small subarray</em> 가 많아지면서 급격히 느려진다. </p>

<p>(2) 조그마한 <em>sub-array</em> 에 대해 많은 수의 재귀가 호출된다.</p>

<p>이 문제를 해결하기 위해 적은 수의 <em>small array</em> 에 대해 <em>insertion sort</em> 를 사용하자. </p>

<pre><code class="java">    // substring comparison is much faster than charAt comparison
    private static boolean less(String v, String w, int d) {
        return v.substring(d).compareTo(w.substring(d)) &lt; 0;
    }

    private static void isort(String[] a, String[] aux, int l, int h, int d) {
        // insertion sort
        for (int i = l; i &lt;= h; i++)
            for (int j = i; j &gt; l &amp;&amp; less(a[j], a[j - 1], d); j--) {
                // swap a[j - 1], a[j]
                String temp = a[j - 1];
                a[j - 1] = a[j];
                a[j] = temp;
            }

    }

    private static void msdSort(String[] a, String[] aux, int l, int h, int d) {

        int CUTOFF = 15;
        if (h &lt;= l + CUTOFF) {
            isort(a, aux, l, h, d);
            return;
        }
    ...
    ...
    ...
</code></pre>

<h4 id="performance">Performance</h4>

<p><em>MSD string sort</em> 는 필요한만큼 <em>character</em> 를 확인하기 때문에, 데이터에 따라 성능이 다르다. 그러나 대부분의 경우 <em>sublinear</em> 하고, 운이 나쁜 경우 <em>linear</em> 의 성능이 나온다. <em>duplicated key</em> 가 있는 경우에는 <em>nearly linear</em> 다.</p>

<p>재밌는 사실은 <code>compareTo</code> 를 이용하지만 <em>sublinear</em> 하게 성능이 나올 수도 있다는 점이다.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTWhkVFk0VXpZa2RqTmtaV0x3Z2paNTBpTTNZek10VWpNMFVUTGxSMlkxY1Raamx6TDRJVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<p><em>MSD string sort</em> 는 매 재귀마다 새로운 <code>count</code> 배열을 만들기 때문에 <code>N + DR</code> 만큼의 메모리가 필요하다., (<code>D</code> 는 재귀 호출의 수)</p>

<p><em>LSD</em> 에 비해서 가변길이 문자열을 정렬할 수 있고, <em>random</em> 데이터에 대해 <code>N log_R N</code> 의 성능을 보여준다. <em>LSD</em> 와 마찬가지로 <em>stable</em> 하다.</p>

<h4 id="msdvsquick">MSD vs quick</h4>

<p><em>MSD string sort</em> 는 <em>random access</em> 를 하기 때문에 <em>cache inefficient</em> 할 수 있고, <em>quicksort</em> 에 비해 <em>inner loop</em> 에 많은 명령어가 있다. 게다가 <code>count, aux</code> 등 추가적인 메모리가 필요하다.</p>

<p>반면 <em>quicksort</em> 는 <em>linear</em> 하지 않다. 그리고, 많은 수의 문자들을 다시 비교해야한다. 이 두가지를 합친 방법은 없을까?</p>

<h3 id="3wayradixquicksort">3-way Radix Quicksort</h3>

<p><del>무려 교수님이 만드신 알고리즘 1997년에 이 수업에서 만들었다고 함</del></p>

<p>기본적인 아이디어는</p>

<blockquote>
  <p>Do 3-way partitioning on the <code>d</code> th character</p>
</blockquote>

<ul>
<li>Less overhead than <code>R</code>-way partitioning in <em>MSD string sort</em></li>
<li>Does not re-examine characters equal to the partitioning char (but does re-examine characters not equal to the partitioning char)</li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpTWhKVFpoTkRPMk1qWTRRV0xsTm1ZaTFDTjVFek10SVdNaVZUTHdZVFlsVldPbVoyTDBNVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<p>즉, 첫 문자열의 첫 번째 문자를 기준으로, 이것보다 큰 것, 작은 것, 같은 것 3개로 파티셔닝하면서 정렬하는 알고리즘이다. </p>

<h4 id="implementation">Implementation</h4>

<p>구현은 퀵소트랑 상당히 유사하다.</p>

<pre><code class="java">    // 3-Way Quicksort
    public static void Quicksort3way(String[] a) {
        qsort3way(a, 0, a.length - 1, 0);
    }

    // helper method for 3 way quicksort
    private static void swap(String[] a, int i, int j) {
        String temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

    private static void qsort3way(String[] a, int l, int h, int d) {
        if (h &lt;= l) return;

        int lt = l, gt = h;
        int v = charAt(a[l], d);
        int i = l + 1;

        // partition
        while (i &lt;= gt) {
            int t = charAt(a[i], d);

            if      (t &lt; v) swap(a, lt++, i++);
            else if (t &gt; v) swap(a, i, gt--);
            else            i++;
        }
        // a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]
        qsort3way(a, l, lt - 1, d);
        if (v &gt;= 0) qsort3way(a, lt, gt, d + 1);
        qsort3way(a, gt + 1, h, d);
    }
</code></pre>

<p><em>MSD string sort</em> 와 마찬가지로 <code>CUTOFF</code> 를 이용해서 작은 <em>sub-array</em> 를 <em>insetion sort</em> 로 정렬할 수 있다.</p>

<h4 id="3wayquicksortvsstandardquicksor">3-way quicksort vs standard quicksor</h4>

<p>일반적으로 <em>quicksort</em> 는 <code>compareTo</code> 를 기준으로 <code>~ 2N lnN</code> 의 성능을 보여주고, <em>long common prefixes</em> 가 있는 경우에 상당히 계산 비용이 비싸다. 이는 비교했던 문자열을 또 비교할 수 있기 때문이다.</p>

<p>그러나 <em>3-way string quicksort</em> 는 <code>charAt</code> 을 기준으로 <code>~ 2N lnN</code> 의 성능을 보인다. 그리고 같은 파티션에 대해 <code>d + 1</code> 로 재귀호출하기 때문에 같은 파티션 내에서는 비교했던 문자를 다시 계산하지 않는다. <del>갓 교수님</del></p>

<h4 id="3wayquicksortvsmsdsort">3-way quicksort vs MSD sort</h4>

<p>(1) <strong>MSD string sort</strong> 는</p>

<ul>
<li>같은 <code>count</code> 값을 가진 문자열에 뜬금없이 접근하기 때문에 <em>cache-inefficient</em></li>
<li>재귀마다 <code>count[]</code> 를 새로 만들어 너무 많은 메모리를 사용</li>
<li><code>count[], aux[]</code> 를 초기화하는데 너무 많은 오버헤드</li>
</ul>

<p>(2) <strong>3-way string quicksort</strong> 는</p>

<ul>
<li>더 짧은 <em>inner loop</em></li>
<li><code>while</code> 을 이용해 순차적으로 접근하므로 <em>cache-friendly</em></li>
<li><em>in-place</em></li>
</ul>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVTTTJFV09tZFRPakoyTTVjVEwxWW1ZNDBDTWtoek10UVRZMUlXTDVVRE8wWUdNd1UyTHhRVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<h3 id="suffixarrays">Suffix Arrays</h3>

<p><em>keyword-in-context search</em> 란</p>

<blockquote>
  <p>Given a text of <code>N</code> chars, preprocess i to enable fast substring search (find all occurrences of query string ocntext)</p>
</blockquote>

<p>쉽게 말해서 구글 검색창에 <em>world</em> 라고 치면 <em>hello world</em> 등이 자동으로 검색목록에 나오는것.</p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVDWmtkVFozRW1ZbFZtTmlGVEx6RVRPNDBTWTFZek10UVRNeFFXTGlKVFpqbERNekkyTHpRVE14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<p><em>suffixes</em> 를 만든다음에 문자열 정렬을 해서 중복된 <em>suffix</em> 가 있는지 보면 된다. <code>String</code> 의 경우 <code>substring</code> 을 얻는데 <code>O(1)</code> 이이므로 <em>suffixes</em> 를 만드는데 <code>O(n)</code> 이다. </p>

<p>그 후에 <em>binary search</em> 를 하면, 일치하는 문자열을 검색할 수 있다.</p>

<p>(1) <strong>Preprocess:</strong> <em>suffix sort</em> the text. <br />
(2) <strong>Query:</strong> <em>binary search</em> for query; scan until mismatch.  </p>

<h3 id="longestrepeatedsubstring">Longest repeated substring</h3>

<blockquote>
  <p>Gien a string of <code>N</code> characters, find the longest repeated substring.</p>
</blockquote>

<p>유전자 지도 <code>a g t t a a t c g ~</code> 에서 일치하는 가장 긴 유전자 문자열을 찾아내는데 활용할 수 있다.</p>

<p><em>data compression</em> 에도 활용 가능하다. 자주 반복되는 긴 패턴을 발견해 짧게 줄이면 용량을 상당히 줄일 수 있다.</p>

<p>악보를 이용해서 음악을 <em>visualization</em> 하는데도 활용할 수 있다.</p>

<h4 id="bruteforce">Brute Force</h4>

<p>문자열의 길이가 <code>N</code>, 가장 긴 패턴의 길이가 <code>D</code> 라면 <em>worst case</em> <code>DN^2</code> 이다. </p>

<h4 id="sortingsolution">Sorting solution</h4>

<p>(1) form suffixes (<code>O(n)</code>) <br />
(2) sort suffixes (<code>O(n log n)</code>) <br />
(3) compute longest prefix between adjacent suffixes (<code>O(kn)</code>)  </p>

<pre><code class="java">    // longrest common prefix
    public static String lcp(String v, String w) {

        int n = Math.min(v.length(), w.length());

        for (int i = 0; i &lt; n; i++) {
            if (v.charAt(i) != w.charAt(i)) return v.substring(0, i);
        }

        return v.substring(0, n);
    }

    // longest repeated substring
    public static String lrs(String s) {

        int N = s.length();
        String[] suffixes = new String[N];

        // form suffixes
        for(int i = 0; i &lt; N; i++)
            suffixes[i] = s.substring(i, N);

        // sort
        Arrays.sort(suffixes);

        // find longest repeated substring using lcp
        String lrs = "";

        for (int i = 0; i &lt; N - 1; i++) {
            String x = lcp(suffixes[i], suffixes[i + 1]);

            if (x.length() &gt; lrs.length()) lrs = x;
        }

        return lrs;
    }
</code></pre>

<p><em>suffix soring</em> 에 <em>3-way string quicksort</em> 를 이용하면 어마어마하게 빠르다.</p>

<p>한 가지 문제는 <em>lrs</em> 의 길이가 길어지면 <em>suffix sort</em> 의 성능이 급격히 떨어진다. <code>D</code> 를 <em>lrs</em> 의 길이라 했을때 적어도 <code>1 + 2 + ... + D</code> 의  문자열 비교가 필요하다. (자신과 자신의 서브스트링과의 비교)</p>

<p>따라서 <code>D</code> 가 길면 길수록 성능이 나빠진다. </p>

<blockquote>
  <p>Quadratic (or worse) in <code>D</code> for <em>LRS</em></p>
</blockquote>

<p>성능이 떨어지는 입력 데이터로, 반복되는 인풋이 있다. <code>twinstwins</code> 를 예로 들면</p>

<pre><code>ins  
instwins  
ns  
nstwins  
s  
stwins  
twins  
twinstwins  
wins  
winstwins  
</code></pre>

<p>그러면 더 빠른 알고리즘이 없을까? <em>Manber-Myers algorithm</em> 이란게 있는데, 요건 <em>linearithmic</em></p>

<p><em>suffix trees</em> 란 것도 있다. 이건 <em>linear</em></p>

<h4 id="manbermyersmsdalgorithm">Manber-Myers MSD Algorithm</h4>

<p>(1) sort on first character using key-indexed counting sort <br />
(2) given array of suffixes sorted on first <code>2^(i-1)</code> characters (phase <code>i</code>)  </p>

<p><em>worse-case</em> 퍼포먼스는 <code>N lgN</code></p>

<p><img src='http://www.programering.com/images/remote/ZnJvbT1pdGV5ZSZ1cmw9Y21idzVpWmtCVE9rZFRaMVFEWjVBVEwwY2paaTFTTjBjek10Z0RabU5XTGlSRE9qUkRNalIyTDNNak14OHlNNUFETXZRbmJsMUdhakZHZDBGMkxrRjJic0JYZHYwMmJqNVNaNVZHZHA1aU1zUjJMdm9EYzBSSGE.jpg'  alt="" /></p>

<p align="center">(www.programering.com)</p>

<p><em>key-indexed counting</em> 을 이용해 먼저 하나의 문자를 정렬하고, 그 이후에는 <code>2, 4, 6, 8, ...,</code> 개씩 정렬해 나간다. 이 과정에서 <code>inverse[]</code> 를 이용한 <em>index sort</em> 란걸 하는데, 아이디어는 이렇다.</p>

<p><em>suffixes</em> 에서 비교하려는 두 문자열의 뒷부분의 일부는 이미 이전 단계에 정렬 되었을 수 있다. (슬라이드의 빨간색 부분) 따라서 이미 정렬해 된 순서 <code>inverse[]</code> 를 이용해서 현재 비교하려는 두 문자열의 순서를 정할 수 있다. </p>

<h4 id="summary">Summary</h4>

<ul>
<li><em>linear-time</em> 문자열 정렬을 할 수 있다.</li>
</ul>

<p>왜냐하면 <em>key comparison</em> 이 아니라 <em>character comparison</em> 으로 해낼 수 있기 때문</p>

<ul>
<li><em>sublinear-time</em> 정렬도 만들 수 있다.</li>
</ul>

<p>모든 문자열을 비교할 필요가 없기 때문 (Input size is amount of data in keys, not number of keys.)</p>

<ul>
<li><em>3-way string quicksort is asymptotically optimal</em></li>
</ul>

<p><code>1.39 N lgN</code> 의 문자열 비교, <em>random data</em> 에 대해. 그러나 <em>suffix sort</em> 에 대해 <code>N lgN</code> 을 보장하려면(<em>worst case</em>) <em>Manber-Myer</em> 를 사용해야 한다.</p>

<ul>
<li>Long strings are rarely random in practice</li>
</ul>

<h3 id="references">References</h3>

<p>(1) <em>Algorithms: Part 2</em> by <strong>Robert Sedgewick</strong> <br />
(2) <a href='http://programmers.stackexchange.com/questions/247440/what-does-it-mean-for-a-sorting-algorithm-to-be-stable' >What is a stable sorting algorithm?</a> <br />
(3) <a href='http://www.programering.com/a/MTOyYjNwATM.html' >www.programering.com</a></p>]]></description><link>http://1ambda.github.io/radix-sort-suffix-sort/</link><guid isPermaLink="false">e649e1bf-a946-4414-a54a-e3f1be9c1d66</guid><category><![CDATA[Algorithm]]></category><category><![CDATA[coursera]]></category><category><![CDATA[radix sort]]></category><category><![CDATA[String]]></category><category><![CDATA[3 way radix]]></category><category><![CDATA[MSD]]></category><category><![CDATA[LSD]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 11 Dec 2014 06:59:33 GMT</pubDate></item><item><title><![CDATA[Process Mining, Week3]]></title><description><![CDATA[<h3 id="fourqualitycriteriaforprocessdiscovery">Four Quality Criteria For Process Discovery</h3>

<p><em>real process</em> 로 부터 <em>event log</em> 를 얻고 이것으로 <em>process model</em> 을 만든다. </p>

<p><em>process model</em> 을 평가하기 위해 해야하는 질문은</p>

<blockquote>
  <p>Is the process model a correct reflection of the real process?</p>
</blockquote>

<p>그러나 <em>real process</em> 를 모르기 때문에 판단하기가 쉽지 않다. 일반적으로 데이터마이닝에서 사용하는 평가 지표인 <em>confusion matrix</em> 를 도입하면</p>

<p><img src='http://lh3.ggpht.com/_qIDcOEX659I/SzjW6wGbmyI/AAAAAAAAAtY/Nls9tSN6DgU/contingency_thumb%5B3%5D.png?imgmax=800'  alt="" /></p>

<p align="center">(<a href='http://crsouza.blogspot.kr/' >http://crsouza.blogspot.kr</a>)</p>

<ul>
<li><strong>True Positive:</strong> traces possible in model and also possible in real process</li>
<li><strong>True Negative:</strong> traces not possible in model and also not possible in real process</li>
<li><strong>False Positive:</strong> traces possible in model and but not possible in real process</li>
<li><strong>False Negative:</strong> traces not possible in model and but possible in real process</li>
</ul>

<p>보통은 평가 지표로 <em>recall</em>, <em>precision</em>, <em>F1 score</em> 등을 이용하는데 프로세스마이닝에서의 문제는 <em>real process</em> 에서 일어나는 <strong>FN, TP</strong> 를 알 수가 없다는 것이다.</p>

<p>따라서 <em>event log</em> 의 <strong>FN', TP'</strong> 를 이용해서 <em>replay fitness</em> 를 이용한다.</p>

<p><img src='http://latex.codecogs.com/gif.latex?replay%5C%20fitness%20%5C%5C%5C%5C%20%3D%20%7BTP%27%20%5Cover%20TP%27%20&plus;%20FN%27%7D'  alt="" /></p>

<p>이 외에도 다양한 문제를 마주칠 수 있는데,</p>

<ul>
<li>보통 이벤트로그로 부터는 <strong>FN'</strong> 이 무엇인지 알 수 없다.</li>
<li>로그가 <em>possible traces</em> 의 일부분만 담고 있다.</li>
<li>Almost vs poorly fitting traces</li>
<li>루프가 있으면 무한히 많은 <em>possible traces</em> 가 있다.</li>
<li>Murphy's law for process mining: <strong>Anything is possible, so pobabilities matter</strong></li>
</ul>

<p>이런 문제점들은 다음의 기준들 사이에서 균형을 맞춰야 함을 알려준다.</p>

<ul>
<li><strong>fitness:</strong> observed behavior fits</li>
<li><strong>simplicity:</strong>  Occam's razor</li>
<li><strong>precision:</strong> avoiding underfitting</li>
<li><strong>generalization:</strong> avoiding overfitting</li>
</ul>

<p><img src='http://image.slidesharecdn.com/processminingchapter05processdiscovery-110510153220-phpapp01/95/process-mining-chapter-5-process-discovery-51-728.jpg?cb=1305062521'  alt="" /></p>

<p>여기서 <em>precision</em> 이 문제가 되는 경우라는 것은, <em>flower model</em> 처럼 필요 이상으로 가능한 모든 경우의 수를 도입한 모델이라 보면 된다. 다시 말해서 기존의 <em>log</em> 와는 완전히 다른 로그가 모델에 맞을 경우를 말한다. (<em>underfitting</em>) </p>

<p><br/> <br />
<img src='http://image.slidesharecdn.com/processminingchapter05processdiscovery-110510153220-phpapp01/95/process-mining-chapter-5-process-discovery-52-728.jpg?cb=1305062521'  alt="" /></p>

<p>반대로 <em>generalization</em> 이 낮은 모델은, 너무 <em>log</em> 에 맞추느라 복잡해진 경우를 말한다. (<em>overfitting</em>)</p>

<p>따라서 <em>traces</em> 의 수가 적은 경우에 너무 <em>overfitting</em> 하려고 하면 퍼포먼스가 낮아진다. 반대로 <em>traces</em> 수가 상당히 많다면, 다음에 들어올 <em>traces</em> 가 다른 형태일 확률이 낮아지므로 모델을 조금 더 <em>fitting</em> 하는 편이 낫다. (오히려 이 경우는 <em>overfitting</em> 이라 보기 어렵다.)</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter05processdiscovery-110510153220-phpapp01/95/process-mining-chapter-5-process-discovery-43-728.jpg?cb=1305062521'  alt="" /></p>

<p><br/></p>

<h3 id="representationalbias">Representational Bias</h3>

<blockquote>
  <p>Modeling language provides a bias</p>
</blockquote>

<p>예를 들어 <em>petri net</em> 같은 경우는 <em>concurrency</em> 를 모델링하는데 문제가 없는 반면 <em>transition system</em> 은 어렵다.</p>

<p><em>concurrency</em> 에 대해서도 생각해 볼 것이, <code>k = 10</code> 의 <em>parallel activities</em> 가 있다면 가능한 <em>traces</em> 는 <code>10! ~= 3600000</code> 이다.</p>

<p>반면 알파 알고리즘이 이 모델을 발견하려면 단지 <code>k(k-1</code> 의 <em>direct succession</em> 만 필요하다.</p>

<p>그러나 알파 알고리즘은 <em>optional(skip)</em> 이 있는 모델을 발견하지 못한다. 그리고, <em>silent transition(OR-joins)</em> 이 있는 모델에서의 가능한 <em>traces</em> 수는</p>

<p><img src='http://latex.codecogs.com/gif.latex?%5Csum_%7Bi%20%3D%200%7D%5Ek%20%5Cbinom%7Bk%7D%7Bi%7D%20i%21'  alt="" /></p>

<p><em>WF-net</em> 같은 경우는 <em>unique label</em> 과 관련해서 문제가 있다.</p>

<p><code>L = [&lt;a, c, d&gt;^45, &lt;b, c, e&gt;^42, &lt;a, c, e&gt;^20]</code> </p>

<p>이 있을때, <em>WF-net</em> 은 <code>e</code> 두개인 모델을 발견할 것이다.</p>

<p>그리고 만약 <em>no indirected dependencies</em> 라면,</p>

<p><code>L = [&lt;a, c, d&gt;^45, &lt;b, c, e&gt;^42]</code> 에서 올바른 모델을 찾아내지 못할것이다.  (<code>a, b</code> 가 <code>d, e</code> 의 선택에 영향을 준다.)</p>

<blockquote>
  <p>Visualization of discovered model != representatoinal bias</p>
</blockquote>

<h4 id="whatisprocessdiscoverysodifficult">What is process discovery so difficult?</h4>

<ul>
<li>There are <strong>no negative examples</strong></li>
<li>Due to concurrency, loops, and choices the search space has a complex structure and the log typically contains only a fraction of all possible behaviors</li>
<li>There is no clear relation between the size of a model and its behavior</li>
</ul>

<p>특히 마지막 문제는, 일반적인 경우에선 작은 모델이 작은 로그를 만들어 내지만 프로세스 마이닝에선 작은 모델이라도 많은 로그를 만들 수 있다.</p>

<p>따라서 <em>representational bias</em> 를 잘 고려해서 모델을 선택해야 한다.</p>

<h3 id="businessprocessmodelandnotationbpmn">Business Process Model and Notation (BPMN)</h3>

<blockquote>
  <p>Representational bias impacts search space</p>
</blockquote>

<p><img src='http://upload.wikimedia.org/wikipedia/en/7/71/BPMN_gateway_types.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org/' >http://en.wikipedia.org/</a>)</p>

<p><em>exclusive OR</em> 은 둘 중 하나만 선택이고, <em>parallel</em> 은 모두로 분기한다. <em>inclusive OR</em> 은 하나 이상을 선택할 수 있다. 더 자세한 내용은 <a href='http://tynerblain.com/blog/2006/07/27/bpmn-gateways/' >BPMN Gateway</a> 를 참고하자.</p>

<p>보통 <em>inclusive OR join</em> 이 있으면 <em>synchronization</em> 이 된다. 그리고 앞쪽에 <em>inclusive OR split</em> 이 있고 뒤쪽에 <em>and join</em> 이 있으면 <em>deadlock</em> 이 있을 가능성이 높다.</p>

<p>일반적으로는 <em>OR join, split</em> 을 <em>AND join split</em> 을 결합해야 데드락이 없다.</p>

<p>참고로 <em>BPMN</em> 은 <em>UML</em> 이나 <em>Event-Driven Process Chains, EPCs</em> 와 비스무리하다. 아래는 <em>BPMN</em> 예제</p>

<p><img src='http://sehlhorst.smugmug.com/photos/84432593-M.jpg'  alt="" /></p>

<p align="center">(<a href='http://tynerblain.com/blog' >http://tynerblain.com/blog</a>)</p>

<p>보통은 <em>Petri net</em> 이나 <em>process tree</em> 로 작업하고 <em>BPMN</em> 으로 변환한다. <em>BPMN</em> 으로 바로 작업하는 경우는 흔하지 않다고 함.</p>

<h4 id="viciouscycleparadox">Vicious Cycle Paradox</h4>

<p>이부분은 당최 뭔 소린지 이해가.. 나중을 위해서 그림만 넣어놈.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter02processmodelingandanalysis-121219213500-phpapp02/95/process-mining-chapter02processmodelingandanalysis-14-638.jpg?cb=1355974557'  alt="" /></p>

<h3 id="dependencygraphs">Dependency Graphs</h3>

<p><img src='http://www.ijmijournal.com/cms/attachment/305569/1959182/gr6.gif'  alt="" /></p>

<p align="center">(<a href='http://www.ijmijournal.com/' >http://www.ijmijournal.com</a>)</p>

<p><em>footprint</em> 의 <em>casuality</em> 를 이용해서 <em>dependency graph</em> 를 만들 수 있다. <em>place</em> 가 없는 일종의 <em>Petri Net</em> 이라 볼 수 있다.</p>

<p>참고로 <em>casuality</em> 는</p>

<blockquote>
  <p>causality: <code>x -&gt; y</code>, iff <code>x &gt; y</code> and not <code>y &gt; x</code></p>
</blockquote>

<p><em>dependency graph</em> 는 의존성은 잘 보여주지만 <em>executable semantic</em> 이 없다. 각 노드는 <em>OR join, split</em> 의 <strong>fuzzy</strong> 로 볼 수 있다.</p>

<ul>
<li>Fuzzy models can be viewed as dependency graphs</li>
<li>No precise semantics  </li>
<li>Many ways to create dependency graphs often based on heuristics</li>
</ul>

<h3 id="casualnets">Casual Nets</h3>

<p><img src='http://image.slidesharecdn.com/processminingchapter02processmodelingandanalysis-121219213500-phpapp02/95/process-mining-chapter02processmodelingandanalysis-15-638.jpg?cb=1355974557'  alt="" /></p>

<p><em>Casual nets, C-nets</em> 은 <em>dependency graph</em> 에 <em>inpt, output</em> 을 붙여 <em>possible behavior</em> 를 보여준다.</p>

<p><br/></p>

<p>왜 <em>C-nets</em> 을 이야기 할까?</p>

<ul>
<li>Output of several mining techniques, e.g., the well-known huritics miner</li>
<li>Fits well with mainsteam languages (BPMN, EPCs, YAWL, etc.)</li>
<li>Able to model <strong>XOR, AND, OR</strong> but <strong>no sidlent steps or duplicate activities needed</strong></li>
<li>Loose interpretation. <strong>focus on replay semantics rather then executing semantics</strong></li>
</ul>

<p><em>C-nets</em> 에서는 <em>obligation</em> 이 <em>token</em> 의 역할을 한다. </p>

<blockquote>
  <p>Semantics are declarative <br />
  Only valid binding sequences are considered</p>
</blockquote>

<p><em>C-nets</em> 은 <em>WF-nets</em> 으로 쉽게 변환될 수 있다. <em>WF-nets</em> 에선 <em>deadlock</em> 이 있을 수 있는 반면 <em>C-nets</em> 에선 <em>valid seq</em> 만을 논하기 때문에 <em>deadlock</em> 은 이야기 하지 않는다.</p>

<blockquote>
  <p>Valid binding seqence of <em>C-net</em> is, Valid firing sequence of <em>WF-net</em></p>
</blockquote>

<p>그리고 <em>C-net</em> 이 <em>WF-nets</em> 보다 좀 더 표현적이다. 강의에서 나온 <em>C-nets</em> 같은 경우, 무한한 수의 <code>b, c, d</code> 를 표현하면서도 <em>order</em> 가 유지되고, <code>b, c, d</code> 가 같은 수로 반복된다.</p>

<h3 id="heuristicmining">Heuristic Mining</h3>

<p>(1) Learn a dependency graph by counting freq => <strong>dependency graph</strong> <br />
(2) Learn splits and joins => <strong>C-nets</strong> <br />
(3) visualize (and convert if needed) => <strong>BPMN, etc.</strong>  </p>

<h3 id="learningdependencygraphs">Learning Dependency Graphs</h3>

<p>알파 알고리즘을 이용하면 별별 문제가 다 생기는데, 휴리스틱하게 모델을 만들면 이런 문제는 좀 피할 수 있다.</p>

<p>그리고 한 가지 더 생각해 볼 문제는</p>

<blockquote>
  <p>Freqencies matter</p>
</blockquote>

<p>무슨 말인고 하니, 빈번한 로그만 <em>valid</em> 취급하면 <em>overfitting</em> 을 피할 수 있다. 알파 알고리즘에 적용하면, 좀 빈도수가 많은 것들만 <em>valid casuality</em> 로 취급할 수 있다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-12-728.jpg?cb=1305062477'  alt="" /></p>

<p><br/></p>

<h4 id="dependencymeasure">Dependency Measure</h4>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-15-728.jpg?cb=1305062477'  alt="" title="" />    </p>

<p><em>dependency measure</em> 값은 <code>-1 ~ 1</code> 인데, 1 에 가까울 수록 <em>casuality</em> 가 있다. 아래 그림은 <em>threshold</em> 를 넘는 <em>direct succession, casuality</em> 만 표시한 <em>dependency graph</em> 다. </p>

<p><em>threshold</em> 가 높아질 수록 그래프가 심플해진다.</p>

<p><br/></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-17-728.jpg?cb=1305062477'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-18-728.jpg?cb=1305062477'  alt="" /></p>

<p><em>dependency measure</em> <code>a =&gt; b</code> <em>direct succession</em> <code>a &gt; b</code> 값을 이용해서 <em>sequence, AND split, join, XOR join, split</em> 등의 패턴을 파악할 수 있다.</p>

<p>게다가 <code>a =&gt; a</code> 도 값을 세기 때문에 <em>loop pattern</em> 도 발견할 수 있다</p>

<h3 id="learningcnets">Learning C-nets</h3>

<p>휴리스틱 마이닝의 두번째 단계는 <em>split, join</em> 등을 파악해서 <em>C-nets</em> 을 만드는 것이다.</p>

<p>어떻게 <em>split, join</em> 을 파악할까? 자주 사용하는 두 가지 접근 법이 있다.</p>

<p>(1) <strong>Heuristics approaches:</strong> using a <strong>time window</strong> before and after each activity. By counting sets of input and output acivities the bindings can be determinded (local decision)  </p>

<p>(2) <strong>Optimization approaches:</strong> based on replay, Given a set of possible input and ouput bindings one can see whether reality can be <strong>replayed property</strong>. The set of possible input and output bindings are finite, so a "best set bindings" can be determined using some goal function.</p>

<h4 id="approach1basedonheuristics">Approach 1: Based on heuristics</h4>

<p><em>dependency graph</em> 에서 볼 수 있듯이 각 <em>activity</em> 는 가능한 <em>input, output</em> 이 있다. 얼마나 자주 나오는지 세면 된다. 이 때 어느 범위까지 셀지를 <em>window size</em> 라 부른다.</p>

<p>예를 들어 <em>window size</em> <code>= 4</code> 면</p>

<pre><code>1 ... klbg[a]dhek ...  
2 ... lkgc[a]hedl ...  
3 ... kblg[a]ehdk ...  
4 ... klgb[a]dehk ...  
5 ... klkc[a]dkeh ...  
</code></pre>

<p>이 때 <code>b, c</code> 에 대해서 <code>{b} = 3, {c} = 2</code> 다. 요게 <em>input binding</em></p>

<p><code>{d, e} = 5</code> 다. 요게 <em>output binding</em>. 이 값들을 <em>depdency graph</em> 를 표시하면 된다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-19-728.jpg?cb=1305062477'  alt="" /></p>

<p><br/></p>

<p>이걸로 끝나는것은 아니고 <em>refinement</em> 가 필요하다.</p>

<ul>
<li>What if there are no corresponding acivities in the input or output window?</li>
<li>Noise filtering (remove infreq bindings)</li>
<li>Handling repeating activities (cut off window size)</li>
<li>Details are out of scope, but be aware of such complications when interpreting result</li>
</ul>

<h4 id="approache2optimizationproblem">Approache 2: Optimization problem</h4>

<ul>
<li>Evaluate all possible acivity bindings and take best one.</li>
<li>Based on the idea that ideally a trace can be <strong>replayed from the initial input state to the final state</strong></li>
<li>This <strong>can be checked</strong> precisely using various replay approaches</li>
<li>Hence, one can use approaches that simply <strong>try bindings exhaustively</strong></li>
</ul>

<p>간단히 말해서 가능한 모든 조합을 구하고, 말이 될 만한 <em>input, output</em> 을 <strong>replay</strong> 를 통해 골라내면 된다.</p>

<p>여기서 평가 기준은 <em>fitness simplicity, precision, generalization</em> 등이다. 시간이 너무 걸린다면 <em>randomize</em>, <em>genetic algorithm</em> 등을 이용할 수 있다. (generic 이 아니고 <em>genetic</em> 이다.)</p>

<h3 id="learningtransitionsystem">Learning Transition System</h3>

<p>지금까지 모델을 만들기 위해 다음의 방법을 배웠다.</p>

<ul>
<li>Alpha algorithm</li>
<li>Heuristic mining <em>dep graph, C-net</em></li>
</ul>

<p>이번시간엔 <em>state-based regions</em> 를 배워보자.</p>

<p>(1) Learning a transition system using a state abstraction => <em>transition system</em>  </p>

<p>(2) Transform the transition system into an equivalent Petri net => <em>Petri net</em>  </p>

<p>(3) visualize (and convert if needed) => <em>BPMN, etc.</em></p>

<p>트랜지션 시스템을 학습하는 방법은, 현재 <em>state</em> 를 기준으로 <em>past, future</em> 를 보고 이 두가지를 합치면 된다. <del>말은 언제나 쉽다.</del> </p>

<p>예를 들어 <code>a b c d c d c d e ^ f a g h h h i</code> 를 기준으로, 현재 상태가 <code>^</code> 라 하면 </p>

<ul>
<li><strong>past:</strong> <code>a b c d c d c d e</code></li>
<li><strong>future:</strong> <code>f a g h h i</code></li>
</ul>

<p>여기서 <em>order</em> 는 무시하고 <em>frequency</em> 만 고려하면 <em>past</em> 는 </p>

<p><code>[a, b, c^3, d^3, e]</code> 가 된다. 만약에, 여기서 <em>time window</em> (<strong>k-tail</strong>) 를 이용하면 <code>[c, d^2, e]</code> 가 된다.</p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-121219213521-phpapp01/95/process-mining-chapter06advancedprocessdiscoverytechniques-29-638.jpg?cb=1355974629'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-121219213521-phpapp01/95/process-mining-chapter06advancedprocessdiscoverytechniques-30-638.jpg?cb=1355974629'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-121219213521-phpapp01/95/process-mining-chapter06advancedprocessdiscoverytechniques-31-638.jpg?cb=1355974629'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-121219213521-phpapp01/95/process-mining-chapter06advancedprocessdiscoverytechniques-32-638.jpg?cb=1355974629'  alt="" /></p>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-33-728.jpg?cb=1305062477'  alt="" /></p>

<h4 id="postprocessing">Postprocessing</h4>

<ul>
<li>remove <em>self-loop</em></li>
<li>imporve <em>diamond structure</em> (for missing interleavings)</li>
<li>merge <em>similar states</em> based on inputs</li>
</ul>

<h3 id="usingregionstodiscoverconcurrency">Using Regions to Discover Concurrency</h3>

<p>이제 <em>transition system</em> 을 <em>Petri net</em> 으로 변경하면 된다. </p>

<p>기본적인 아이디어는 <em>transition system</em> 의 <em>subset</em> 이 <em>Petri net</em> 의 <em>place</em> 의 해당한다는 것이다. 이는 당연한데 트랜지션 시스템에서 어떤 상태는, 이 전까지의 상태의 반영이고, 이건 <em>place</em> 다.</p>

<blockquote>
  <p>State-based regions correspond to places</p>
</blockquote>

<p><img src='http://image.slidesharecdn.com/processminingchapter06advancedprocessdiscoverytechniques-110510153227-phpapp02/95/process-mining-chapter-6-advanced-process-discoverytechniques-34-728.jpg?cb=1305062477'  alt="" /></p>

<p>이 때 <em>state-based region</em> 의 <em>enter, exit</em> 를 확인 하면 쉽게 <em>place</em> 를 만들 수 있다.</p>

<blockquote>
  <p>All states need to be reachable</p>
  
  <p>A region is a set of states, such that, if a transition <strong>exits</strong> the region, then all equally labeled trasition <strong>exit</strong> the region</p>
  
  <p>and If a transition <strong>enters</strong> the region, then all equally labeled transitions <strong>enter</strong> the region</p>
  
  <p>All events not entering or exiting the region <strong>do not cross</strong> the region</p>
</blockquote>

<p><code>n</code> 개의 <em>concurrent activity</em> 가 있으면 <code>2^n</code> 개의 <em>state</em> 가 생긴다. 이 때 몇 개의 <em>region</em> 이 생길까? </p>

<p>아무리 많아봐야 1 개의 트랜지션 라벨만 <em>crossing</em> 할 수 있으므로, <code>n</code> <em>split</em> 을 만들 수 있고 여기에 <em>empty</em> 까지 더하면 <code>2(n + 1)</code> 이다.</p>

<p>직선인 <em>petri net</em> 의 경우는 더 심각하다. 모든 <em>transition</em> 의 <em>subset</em> 이 <em>region</em> 이므로 <code>2^(n+1)</code> 이 된다. 따라서 <em>non-trivial minimal region</em> 만 포함해야 한다.</p>

<p><em>Petri net</em> 을 만드는 알고리즘은</p>

<p>(1) For each transition label in the transition system, a <strong>transition</strong> is added to the Petri net <br />
(2) The <strong>minimal non-trivial regions</strong> are computed <br />
(3) For each minimal non-trivial region in the transition system, a <strong>place</strong> is added to the Petri net. <br />
(4) The coressponding arcs are generated <br />
(5) A <strong>token</strong> is aded to each place that corresponds to a region containing the initial state</p>

<p><code>L = [&lt;a, c, d&gt;^45, &lt;b, c, e&gt;^42]</code></p>

<p>의 경우 알파 알고리즘은 <em>non directed dependency</em> 를 발견하지 못하는데, 트랜지션 시스템을 만들고, <em>state-based region</em> 을 이용하면 올바른 <em>petri net</em> 을 만들 수 있다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://issuu.com/wmpvanderaalst/docs/procminbook?e=14081202/9829483' >Book: Process Mining</a> <br />
(2) <a href='https://d396qusza40orc.cloudfront.net/procmin/lecture_slides/22-Petri%20Nets%20%281%29.pdf' >Slide</a> <br />
(3) <strong>Process Mining: Data science in Action</strong> by Wil van der Aalst <br />
(4) <a href='http://1ambda.github.io/www.processmining.org' >www.processmining.org</a> <br />
(5) <a href='http://fluxicon.com/' >http://fluxicon.com</a> <br />
(6) <a href='http://crsouza.blogspot.kr/2009/12/performing-discriminant-power-analysis.html' >Confusion matrix</a> <br />
(7) <a href='http://en.wikipedia.org/wiki/Business_Process_Model_and_Notation' #mediaviewer/File:BPMN_gateway_types.png">Wikipedia - BPMN</a> <br />
(8) <a href='http://tynerblain.com/blog/2006/07/27/bpmn-gateways/' >BPMN Gateway</a> <br />
(9) <a href='http://www.ijmijournal.com/' >http://www.ijmijournal.com</a></p>]]></description><link>http://1ambda.github.io/process-mining-week3/</link><guid isPermaLink="false">43e49375-88bc-4ec0-aff0-93f098b34d10</guid><category><![CDATA[coursera]]></category><category><![CDATA[process mining]]></category><category><![CDATA[BPMN]]></category><category><![CDATA[dependency graph]]></category><category><![CDATA[C-nets]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 09 Dec 2014 10:44:29 GMT</pubDate></item><item><title><![CDATA[Intro to Computational Thinking and Data Science 4]]></title><description><![CDATA[<p>그래프는 네트워크를 표현하는 것 뿐만 아니라, <em>state</em> 를 표현할 수 있다.</p>

<ul>
<li>Nodes represent states of system</li>
<li>Edges represent actions that cause a change of state</li>
</ul>

<p>그러면 그래프 문제는 </p>

<ul>
<li>Finding sequence of actions to convert system to desired state</li>
</ul>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/8puzzle_example.svg/2000px-8puzzle_example.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org/' >http://en.wikipedia.org</a>)</p>

<p><em>8 puzzle</em> 도 이렇게 그래프 문제로 변환할 수 있다. 그런데, <code>9! = 362880</code> 의 <em>node</em> 와 노드당 <code>2~4</code> 개의 <em>edge</em> 를 가지고 있으므로 문제의 사이즈가 어마어마하게 커진다. 거의 백만개의 <em>edge</em> 를 가진다.</p>

<h3 id="animplicitgraph">An Implicit Graph</h3>

<p>그래서, 처음부터 모든 <em>state</em> 를 만들기 보다는 초기 상태로부터 <em>action</em> 을 취해가면서 <em>desired state</em> 를 찾는 방식으로 해결하자.</p>

<p>퍼즐의 상태를 문자열로 표현하면</p>

<pre><code class="python">class puzzle(object):  
    def __init__(self, order):
        self.label = order

        for i in range(9):
            if order[i] == '0':
                self.spot = i
                return None

    def transition(self, to):
        currentLabel = self.label
        blank = self.spot
        # current slot value which will be filled with blank
        current = str(currentLabel[to]) 
        nextLabel = ''

        for i in range(9):
            if i == to:
                nextLabel += '0'
            elif i == blank:
                nextLabel += current
            else:
                nextLabel += str(currentLabel[i])

        return puzzle(nextLabel)

    def __str__(self):
        return "{0} {1} {2}\n{3} {4} {5}\n{6} {7} {8}\n".format(self.label[0],
                                                                self.label[1],
                                                                self.label[2],
                                                                self.label[3],
                                                                self.label[4],
                                                                self.label[5],
                                                                self.label[6],
                                                                self.label[7],
                                                                self.label[8])
</code></pre>

<p>그리고 각 슬롯의 이동 가능한 방향을 딕셔너리로 만들면</p>

<pre><code class="python">shiftDict = {}  
shiftDict[0] = [1, 3]  
shiftDict[1] = [0, 2, 4]  
shiftDict[2] = [1, 5]  
shiftDict[3] = [0, 4, 6]  
shiftDict[4] = [1, 3, 5, 7]  
shiftDict[5] = [2, 4, 8]  
shiftDict[6] = [3, 7]  
shiftDict[7] = [4, 6, 8]  
shiftDict[8] = [5, 7]  
</code></pre>

<p>이제 <em>state</em> 를 변경해 나아가면서 그래프를 만들 수 있다 <em>state</em>, 즉 <em>node</em> 를 변경해 나아가면서 그래프를 탐색하는 방법은 2개가 있는데, <em>BFS, DFS</em> 다. 코드는 거의 유사하다. 스택을 쓰냐 큐를 쓰냐의 차이다.</p>

<pre><code class="python">def notInPath(state, path):  
    for s in path:
        if s.label == state.label:
            return False

    return True


def BFS(start, end, q=[]):  
    initPath = [start]
    q.append(initPath)

    while len(q) != 0:
        currentPath = q.pop(0)
        lastState = currentPath[len(currentPath) - 1]

        if lastState.label == end.label:
            return currentPath

        for s in shifts[lastState.spot]:
            nextState = lastState.transition(s)

            if notInPath(nextState, currentPath):
                nextPath = currentPath + [nextState]
                q.append(nextPath)

    return None


def DFS(start, end, stack=[]):  
    initPath = [start]
    stack.insert(0, initPath)

    while len(stack) != 0:
        currentPath = stack.pop(0)
        lastState = currentPath[len(currentPath) - 1]

        if lastState.label == end.label:
            return currentPath

        for s in shifts[lastState.spot]:
            nextState = lastState.transition(s)

            if notInPath(nextState, currentPath):
                nextPath = currentPath + [nextState]
                stack.insert(0, nextPath)

    return None
</code></pre>

<p>테스트는</p>

<pre><code class="python">def test():  
    goal = puzzle('012345678')
    test1 = puzzle('125638047')
    answer = BFS(test1, goal)

    for state in answer:
        print state
</code></pre>

<p>비교해 보면 <em>BFS</em> 가 훨씬 빠르다.</p>

<h3 id="maximumcliques">Maximum Cliques</h3>

<blockquote>
  <p>For some problems, finding sugraphs of a graph that are complete can be important</p>
</blockquote>

<p>여기서 <em>complete</em> 란 노드가 다른 노드 모두와 연결되어 있다는 뜻이다.</p>

<ul>
<li>Finding sets of people in a social network that all know each other</li>
<li>Finin subjects in an infected population that all have had contact with one another</li>
</ul>

<p>두 번째 예제는 <em>complete subgraph</em> 를 찾는 것의 중요성을 잘 보여준다.</p>

<p><em>clique</em> 는 communication networks, gene expression data 등에도 이용할 수 있다.</p>

<h4 id="bruteforce">Brute Force</h4>

<p><em>maximum clique</em> 문제를 <em>brute force</em> 로 풀려면, 가능한 모든 서브 그래프를 찾고, <em>clique</em> 인지 판별하면서 큰 사이즈의 <em>clique</em> 를 유지하면 된다.</p>

<p>모든 서브 그래프를 찾을려면, <a href='http://1ambda.github.io/edx-600-2x-3/' >지난시간</a> 에 <em>knapsack problem</em> 을 풀 때 이용했던 <em>power set</em> 을 도입하면 된다.</p>

<p><em>knapsack</em> 문제도 <em>brute force</em> 로 풀기 위해서 가능한 모든 집합을 구했었다. 후에는 <em>search space</em> 를 줄이기 위해 <em>decision tree</em> 를 도입하고, 반복 계산을 피하기 위해 <em>memoization</em> 이용했었다.</p>

<p><em>clique</em> 문제도 마찬가지로 각 노드를 숫자로 표현할 수 있으므로 <code>n</code> 자리의 이진수를 만들어 <em>power set</em> 을 생성할 수 있다. 지난 시간에 이용했었던 대강의 로직은 </p>

<pre><code class="python">count = 2 ** len(nodes)

binStrs = []

for i in range(count):  
  binStrs.append(int2bin(i, len(nodes))

powerSet = []

for bs in binStrs:  
  subGraph = []

  for i range(len(bs)):
    if bs[i] == '1':
      subGraph.append(nodes[i])

  powerSet.append(subGraph)

return powerSet  
</code></pre>

<p>이번시간엔 재귀를 이용해서 <em>power set</em> 을 구해보자. 하스켈로 로직을 표현하면,</p>

<pre><code class="haskell">powerset [] = [[]]  
powerset (x:xs) = xs' ++ map (x:) xs'  
  where xs' = powerset xs
</code></pre>

<p>따라서 파이선 코드는</p>

<pre><code class="python">def powerSet(xs):  
    if len(xs) == 0:
        return [[]]

    else:
        # xs = head:tail
        head = xs[0]
        tail = xs[1:]

        prev = powerSet(tail)
        incl = map(lambda sub: sub + [head], prev)
        return prev + incl
</code></pre>

<p>이걸 이용해 모든 <em>sub graph</em> 를 만들고, <em>clique</em> 인지 검사하는 함수를 만들면</p>

<pre><code class="python">def powerGraph(graph):  
    nodes = []

    for n in graph.nodes:
        nodes.append(n)

    pSet = powerSet(nodes)
    return pSet


def isClique(graph, subGraph):  
    for n in subGraph:
        for m in subGraph:
            if not m == n:
                if n not in graph.childrenOf(m):
                    return False

    return True


def maxClique(graph):  
    maximum = None
    maxLen = 0
    subGraphs = powerGraph(graph)

    for sub in subGraphs:
        if isClique(graph, sub):
            if len(sub) &gt; maxLen:
                maximum = sub
                maxLen = len(sub)

    return maximum
</code></pre>

<p><a href='https://courses.edx.org/c4x/MITx/6.00.2_2x/asset/clique.py' >지난시간에 작성했던 Graph 코드</a> 는 여기로, </p>

<p>테스트 코드는 </p>

<pre><code class="python">def testGraph():  
    nodes = []
    for name in range(5):
        nodes.append(Node(str(name)))
    g = Graph()
    for n in nodes:
        g.addNode(n)
    g.addEdge(Edge(nodes[0],nodes[1]))
    g.addEdge(Edge(nodes[1],nodes[2]))
    g.addEdge(Edge(nodes[2],nodes[0]))
    g.addEdge(Edge(nodes[2],nodes[4]))
    g.addEdge(Edge(nodes[4],nodes[3]))
    return g


trialGraph = testGraph()  
myClique = maxClique(trialGraph)  
</code></pre>

<p><code>myClique</code> 를 출력하면, <em>node</em> 가 3개 나와야 한다.</p>

<h3 id="machinelearning">Machine Learning</h3>

<blockquote>
  <p><strong>Automating automation</strong></p>
  
  <p>Computer programs can automatically follow rules. <br />
  How do we determine these rules automatically?</p>
  
  <p><strong>ML fources on getting computers to program themselves</strong></p>
  
  <p>Let the data do the work. <br />
  Automatically generate programs that create useful outputs from data</p>
</blockquote>

<p>전통적인 프로그래밍에선 <em>data</em> 와 <em>program</em> 을 넣고 <em>output</em> 을 기대했다면, </p>

<p><em>machine learning</em> 에서는 <em>data, output</em>  을 넣고 <em>program</em> 을 만든다. 이 프로그램은 다음번에 <em>data</em> 가 들어왔을 때 <em>output</em> 을 만들어 낸다. 다시 말해서 머신러닝은 일종의 <em>generalization</em> 이다.</p>

<blockquote>
  <p><strong>Supervised</strong></p>
  
  <p>Given a set of feature/label pairs, find a rule that predicts the label associated with a previously unseen input</p>
  
  <p><strong>Unsupervied</strong></p>
  
  <p>Given a set of feature vectors (without labels), group them into "natural clusters"</p>
</blockquote>

<p>예를 들어 다음은 <em>supervised learning</em> 이다.</p>

<blockquote>
  <p>A group of 1000 students are asked for a sample of their handwriting. Researchers make pairs of (handwritten text, typed text). Given a new handwriting sample from a new student, we want to determine what the typed version of the handwriting sample would be.</p>
</blockquote>

<h3 id="clustering">Clustering</h3>

<ul>
<li>Low intra-cluster dissimilarity</li>
<li>High inter-cluster dissimilarity</li>
</ul>

<p>간단하긴 한데, 연산 비용이 비싸다. <em>k-means</em> 와 <em>hierarchical clustering</em> 을 살펴보자.</p>

<h4 id="hierarchicalclustering">Hierarchical Clustering</h4>

<p>(1) Start by assigning each item to a cluster, so that if you have <code>N</code> items, you now have <code>N</code> clusters, each containing just one item.</p>

<p>(2) Find the closest (most similar) pair of clusters and merge them into a single cluster, so that now you have one cluster fewer.</p>

<p>(3) Continue the process until all items are clustered into a single cluster of size <code>N</code></p>

<p><img src='http://www.alanfielding.co.uk/multivar/images/dend5.gif'  alt="" /></p>

<p align="center">(<a href='http://www.alanfielding.co.uk/' >http://www.alanfielding.co.uk</a>)</p>

<blockquote>
  <p><strong>Linkage Criteria</strong></p>
  
  <p>in <strong>single-linkage</strong> clustering (also called the <em>connectedness</em> or <em>minimum</em> method), we consider the distance between one cluster and another cluster to be equal to the shortest distance from any member of one cluster to any member of th other cluster</p>
  
  <p>in <strong>complete-linkage</strong> clustering (also called the <em>diameter</em> or <em>maximum</em> method), we consider the distance between one cluster and another cluster to be equal to th greatest distance from any member of one cluster to any member of the other cluster</p>
  
  <p>in <strong>average-linkage</strong>, we consider the distance between one cluster and another cluster to be equal to th average distance from any member of one cluster to any member of the other cluster. A slight variant of this uses the median instead of the mean</p>
</blockquote>

<p><em>single-linkage</em> 클러스터 간 거리를 두 클러스터 사이의 최소 거리로, <em>complete-linkage</em> 는 최대 거리로, <em>average-linkage</em> 는 평균 거리로 본다.</p>

<pre><code class="python">    def singleLinkageDist(self, other):
        """ Returns the float distance between the points that 
        are closest to each other, where one point is from 
        self and the other point is from other. Uses the 
        Euclidean dist between 2 points, defined in Point."""
        minDist = float("inf")
        for p1 in self.points:
            for p2 in other.points:
                dist = p1.distance(p2)
                if dist &lt; minDist:
                    minDist = dist

        return minDist

    def maxLinkageDist(self, other):
        """ Returns the float distance between the points that 
        are farthest from each other, where one point is from 
        self and the other point is from other. Uses the 
        Euclidean dist between 2 points, defined in Point."""
        maxDist = float(0)
        for p1 in self.points:
            for p2 in other.points:
                dist = p1.distance(p2)
                if dist &gt; maxDist:
                    maxDist = dist

        return maxDist

    def averageLinkageDist(self, other):
        """ Returns the float average (mean) distance between all 
        pairs of points, where one point is from self and the 
        other point is from other. Uses the Euclidean dist 
        between 2 points, defined in Point."""
        dists = []
        for p1 in self.points:
            for p2 in other.points:
                dists.append(p2.distance(p1))

        return sum(dists) / float(len(dists))
</code></pre>

<h3 id="kmeansclustering">K-Means Clustering</h3>

<p><img src='http://latex.codecogs.com/gif.latex?%5Csum_%7Bc%3D1%7D%5EK%20%5Csum_%7Bx%5C%20%5Cin%5C%20c%7D%20%5Cleft%20%5C%7C%20x%20-%20%5Cmu_c%20%5Cright%20%5C%7C%5E2'  alt="" /></p>

<ul>
<li>Final result can depend upon initial centroids</li>
<li>Greedy algorihm can find different local optima</li>
<li>Choosing the <em>wrong</em> <code>K</code> can lead to nonsense</li>
</ul>

<p>따라서</p>

<ul>
<li>Use priori knowledge about application domain</li>
<li>Try multiple times</li>
</ul>

<p><em>hierarchical</em> 과 비교하면</p>

<blockquote>
  <p>Hierarchical looks at different numbers of clusters From 1 to n</p>
  
  <p>K-means looks at many ways of createing k clusters.</p>
</blockquote>

<p><em>hierarchical</em> 은 좀 느린편이고 <em>deterministic</em> 이다. 반면 <em>K-means</em> 는 비교적 빠르고, <em>stochastic</em> 이다.</p>

<p>아래는 <em>K-means</em> 로 분류하기 어려운 몇 가지 예제들</p>

<p><img src='https://courses.edx.org/c4x/MITx/6.00.2_2x/asset/k1.png'  alt="" /></p>

<p><img src='https://courses.edx.org/c4x/MITx/6.00.2_2x/asset/k3.png'  alt="" /></p>

<p align="center">(<a href='https://courses.edx.org/c4x/MITx/6.00.2_2x' >https://courses.edx.org/c4x/MITx/6.00.2_2x</a>)</p>

<h3 id="scaling">Scaling</h3>

<p><em>odd ratio</em> 는 <em>acutal / expected</em> 값인데, 1에 가까우면 클러스터링이 랜덤에 비해 별로 나을게 없다는 소리다. (좋은 클러스터링이 아니란 뜻)</p>

<p>강의에서 나온 환자 예제는 이 값이 1에 근접하는데, 이는 <em>HR, age</em> 값이 단위가 커서 이 <em>feature</em> 에 영향을 많이 받기 때문이다.</p>

<p>따라서 평균 0, 표준편차 1을 가지도록 모든 <em>feature</em> 를 스케일링 하고 다시 돌리면  <em>odd ratio</em> <code>0.18, 1.45</code> 의 두 클러스터를 얻을 수 있다. 하나는 <em>heart attack</em> 이 잘 안올 환자, 다른 하나는 위험한 환자.</p>

<p>아래 예제는 스케일링 하면 안되는 경우</p>

<blockquote>
  <p>The percent concentration of a virus in a random sampling of healthy and unhealthy people.</p>
  
  <p>The angle of refraction of light (degree that light bends) observed when entering water vs. glass vs a diamond.</p>
</blockquote>

<h3 id="statisticalfallacies">Statistical Fallacies</h3>

<p>세상에는 3 종류의 거짓말이 있다고 한다.</p>

<ul>
<li>LIES</li>
<li>DAMNED LIES</li>
<li><strong>STATISTICS</strong></li>
</ul>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Anscombe%27s_quartet_3.svg/638px-Anscombe%27s_quartet_3.svg.png'  alt="" /></p>

<p align="center">(<a href='http://en.wikipedia.org/wiki/Anscombe' s_quartet'>http://en.wikipedia.org/wiki/Anscombe's_quartet</a>)</p>

<p>보면 데이터가 정말 다르게 분포해 있지만, <em>mean, variance, correlation, linear regression</em> 이 동일하다.</p>

<p>흔한 오류 중 하나로, <em>correlation => causation</em> 도 있다. </p>

<p>학교가 문을 여는 시즌에, 독감이 많이 유행한다고 해서 상관 관계가 있다고 단정짓긴 어렵다. 어쩌면 다른 요인이 있을지도 모른다.</p>

<p><em>non response bias</em> 도 생각해봐야 한다. 예를 들어 전화조사에서, 응답자와 비응답자의 정치 성향이 다를 수도 있다는 것이다.</p>

<h3 id="dataenhancement">Data Enhancement</h3>

<p><em>texas sharpshotter fallacy (텍사스 명사수의 오류)</em> 란 것도 있다. <a href='http://en.wikipedia.org/wiki/Texas_sharpshooter_fallacy' >위키</a> 에서 인용하면</p>

<blockquote>
  <p>The Texas sharpshooter fallacy is an informal fallacy which is committed when differences in data are ignored, but similarities are stressed.</p>
</blockquote>

<p>텍사스의 총잡이가 헛간에 총을 마구마구 쏜 후, 밀집한 지역 중심으로 원을 그리면! 그 총잡이는 명사수처럼 보이게 된다는 것에서 유래한 오류다.</p>

<p>바꿔 말하면, 우연도 필연으로 해석한다는 것이다. (존재하지도 않는 패턴을 찾으려고 하는것에 비유하기도 함)</p>

<h3 id="references">References</h3>

<p>(1) <em>MIT 6.00.2 2x</em> in <strong>edx</strong> <br />
(2) <a href='http://en.wikipedia.org/wiki/Heuristic_function' >Wikipedia: Huristic Function</a> <br />
(3) <a href='http://www.alanfielding.co.uk/multivar/dend.htm' >http://www.alanfielding.co.uk</a> <br />
(4) <a href='http://en.wikipedia.org/wiki/Anscombe' s_quartet">Wikipedia - Anscombe's quartet</a></p>]]></description><link>http://1ambda.github.io/edx-600-2x-4/</link><guid isPermaLink="false">a07909c0-49d7-4a0a-9dd8-5e52550b331f</guid><category><![CDATA[edx]]></category><category><![CDATA[python]]></category><category><![CDATA[graph]]></category><category><![CDATA[hierarchical clustering]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 09 Dec 2014 03:23:13 GMT</pubDate></item></channel></rss>