<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Old Lisper]]></title><description><![CDATA[Functional Programming World]]></description><link>http://1ambda.github.io/</link><generator>Ghost 0.6</generator><lastBuildDate>Fri, 16 Oct 2015 14:45:38 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Easy Scalaz 1, State]]></title><description><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<h3 id="state">State</h3>

<p><code>State</code> 를 설명하는 수많은 문구들이 있지만, 타입만큼 간단한건 없습니다.</p>

<pre><code class="language-scala">State[S, A] :: S =&gt; (S, A)  
</code></pre>

<blockquote>
  <p>A state transition, representing a <strong>function</strong> </p>
</blockquote>

<p>즉 <code>S</code> 를 받아 <code>(S, A)</code> 를 돌려주는 함수를, 타입클래스 <code>State[S, A]</code> 로 표현합니다. </p>

<p>더 엄밀히는, (<em>scalaz</em>  구현에서는) <code>type State[S, A] = StateT[Id, S, A]</code></p>]]></description><link>http://1ambda.github.io/easy-scalaz-1-state/</link><guid isPermaLink="false">f9bd7b24-522b-412b-8c4f-cd741c93bc28</guid><category><![CDATA[scala]]></category><category><![CDATA[state monad]]></category><category><![CDATA[scalaz]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 12 Oct 2015 14:14:00 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<h3 id="state">State</h3>

<p><code>State</code> 를 설명하는 수많은 문구들이 있지만, 타입만큼 간단한건 없습니다.</p>

<pre><code class="language-scala">State[S, A] :: S =&gt; (S, A)  
</code></pre>

<blockquote>
  <p>A state transition, representing a <strong>function</strong> </p>
</blockquote>

<p>즉 <code>S</code> 를 받아 <code>(S, A)</code> 를 돌려주는 함수를, 타입클래스 <code>State[S, A]</code> 로 표현합니다. </p>

<p>더 엄밀히는, (<em>scalaz</em>  구현에서는) <code>type State[S, A] = StateT[Id, S, A] where Id[+X] = X</code> 인데 이것은 나중에 <code>StateT</code> 에서 다시 보겠습니다.</p>

<p>우선 기억해둘 것은 <code>State</code> 가 <strong>함수</strong> 를 나타낸다는 사실입니다. 상태 <code>S</code> 를 변경하면서 <code>A</code> 를 만들어내는 함수를 말이지요. 즉, <code>State</code> 는 더도 말고 덜도 말고, 상태를 조작하는 <strong>함수</strong> 입니다. 여기에 모나드라고 하니, <code>flatMap</code> 같은 몇몇 함수가 추가된 것 뿐이지요.</p>

<h3 id="statebasics">State Basics</h3>

<p><code>State</code> 코드를 들춰보면, 아래와 같이 생겼습니다. </p>

<pre><code class="language-scala">object State extends StateFunctions {  
  def apply[S, A](f: S =&gt; (S, A)): State[S, A] = new StateT[Id, S, A] {
    def apply(s: S) = f(s)
  }
}

trait StateFunctions extends IndexedStateFunctions {  
  def constantState[S, A](a: A, s: =&gt; S): State[S, A] = State((_: S) =&gt; (s, a))
  def state[S, A](a: A): State[S, A] = State((_ : S, a))
  def init[S]: State[S, S] = State(s =&gt; (s, s))
  def get[S]: State[S, S] = init
  def gets[S, T](f: S =&gt; T): State[S, T] = State(s =&gt; (s, f(s)))
  def put[S](s: S): State[S, Unit] = State(_ =&gt; (s, ()))
  def modify[S](f: S =&gt; S): State[S, Unit] = State(s =&gt; {
    val r = f(s);
    (r, ())
  })
}
</code></pre>

<ul>
<li><code>State.apply</code> 에 상태 <code>S</code> 를 조작하는 함수 <code>f</code> 를 먹이면 <code>StateT</code> 가 나오고</li>
<li><code>StateT.apply</code> 에 초기 상태 <code>S</code> 를 먹이면 최종 결과물인 <code>(S, A)</code> 가 나옵니다</li>
</ul>

<p>그리고 코드를 조금 만 더 따라가다 보면 <code>apply</code> 의 <em>alias</em> 로 <code>run</code> 이라는 함수가 제공되는걸 알 수 있습니다. <a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/StateT.scala#L10">(Scalaz StateT.scala #L10)</a></p>

<p><code>flatMap</code> 으로 상태 조작함수 <code>f</code> 여러개를 엮다가 하다가 마지막에 <code>run</code> 으로 실행시킬것 같다는 느낌이 들죠? </p>

<p><br></p>

<p>이제 <code>StateFunctions</code> <em>trait</em> 로 제공되는 함수를 사용해 볼까요? 그냥 써보면 재미 없으니, Github 에서 각 Repository 마다 존재하는 <em>star</em> 를 가져오는 것을 간단히 모델링 해보겠습니다. 매번 네트워크 요청을 통해 가져오면 느리니까, <code>Map[String, Int]</code> 타입의 캐시도 포함시켜서요.</p>

<pre><code class="language-scala">import scalaz._, Scalaz._ /* import all */

type Cache = Map[String, Int]

"create, run State" in {
  val s: State[Cache, Int] = State { c =&gt; (c, c.getOrElse("1ambda/scala", 0))}
  val c: Cache = Map("1ambda/scala" -&gt; 1)

  // def run(s: S): (S, A)
  val (c1, star1) = s.run(c)
  val (c2, star2) = s.run(Map.empty)

  (c1, star1) shouldBe (Map("1ambda/scala" -&gt; 1), 1)
  (c2, star2) shouldBe (Map(), 0)
}
</code></pre>

<p>이 작은 코드에서 우리가 다루는 상태는 <code>Cache</code> 입니다. 아직은 <code>State { c =&gt; ... }</code> 에서 받은 <code>c: Cache</code> 를 수정하지 않기 때문에 <code>run</code> 에서 돌려주는 상태 (<em>State</em>) 는 <code>run</code> 에 넘긴 것과 동일합니다. 그런고로 <code>c == c1 == c2</code> 입니다. </p>

<p>이번엔 상태를 변경하는 함수를 만들어 보겠습니다. 캐시에서 데이터를 가져오면, 캐시를 그대로 돌려주고 미스가 발생하면 캐시에 레포지토리 URL 을 추가하겠습니다.</p>

<pre><code class="language-scala">def getStargazer(url: String): State[Cache, Int] = State { c =&gt;  
  c.get(url) match {
    case Some(count) =&gt; (c, count)
    case None        =&gt; (c.updated(url, 0), 0)
  }
}

"getStargazer" in {
  val c: Cache = Map("1ambda/scala" -&gt; 1)

  val s1 = getStargazer("1ambda/haskell")
  val (c1, star) = s1.run(c)

  (c1, star) shouldBe (c.updated("1ambda/haskell", 0), 0)
}
</code></pre>

<p><code>State</code> 는 모나드기 때문에, <code>for</code> 내에서 이용할 수 있습니다. 아래에서 더 자세히 살펴보겠습니다.</p>

<h3 id="statemonadapplicativeandfunctor">State Monad, Applicative and Functor</h3>

<p>모나드는 <code>return</code> 과 <code>bind</code> 를 가지고 특정한 규칙을 만족하는 타입 클래스를 말하는데요, <em>scala</em> 에서는 <code>bind</code> 는 <code>flatMap</code> 이란 이름으로 제공되는 것 아시죠? </p>

<pre><code class="language-scala">trait Monad[A] {  
  // sometimes called `unit`
  def return(a: A): M[A]
  def flatMap[B](f: A =&gt; M[B]): M[B]
}
</code></pre>

<p><em>scalaz</em> 에선 <code>Monad</code> 는 아래의 두 타입클래스를 상속받아 구현됩니다. </p>

<ul>
<li><code>Applicative.point</code> (= <code>return</code>)</li>
<li><code>Bind.bind</code> (= <code>bind</code>) </li>
</ul>

<pre><code class="language-scala">trait Bind[F[_]] extends Apply[F] { self =&gt;  
  ...
  def bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]
  ...
}

trait Applicative[F[_]] extends Apply[F] { self =&gt;  
  ...
  def point[A](a: =&gt; A): F[A]
  ...
}
</code></pre>

<p>게다가 <code>Apply</code> 가 <code>Functor</code> 를 상속받으므로 </p>

<pre><code class="language-scala">trait Apply[F[_]] extends Functor[F] { self =&gt;  
  def ap[A,B](fa: =&gt; F[A])(f: =&gt; F[A =&gt; B]): F[B]
  ...
</code></pre>

<p><em>scalaz</em> 에서 <code>State</code> 는 <code>Functor</code> 이면서, <code>Applicative</code> 이고, <code>Monad</code> 입니다.</p>

<p>아래는 <a href="https://github.com/tpolecat/doobie">doobie</a> 를 만든 <a href="https://github.com/tpolecat">@tpolecat</a> 의 블로그에서 가져온 <em>scalaz</em> 타입 클래스 계층인데, 이 그림을 보면 왜 그런지 알 수 있습니다. (<a href="http://tpolecat.github.io/assets/scalaz.svg">http://tpolecat.github.io/assets/scalaz.svg</a>)</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/scalaz.png" alt=""></p>

<p>이제 <code>State</code> 가 모나드라는 사실을 알았으니, 위에서 작성했던 <code>getStargazer</code> 함수를 다시 작성해보겠습니다. <em>for comprehension</em> 을 사용할건데요, </p>

<ul>
<li>먼저 <code>State[Cache, Int]</code> 의 상태인 <code>Cache</code> 를 얻어와야 하므로 <code>get</code> 을 이용하고</li>
<li>상태를 변경해야 하므로 <code>modify</code> 를 호출하겠습니다. </li>
</ul>

<pre><code class="language-scala">// State helper functions defined in `StateFunctions` trait
def state[S, A](a: A): State[S, A] = State((_ : S, a))  
def init[S]: State[S, S] = State(s =&gt; (s, s)) /* 상태 S 를 아웃풋 A 위치로 꺼냄 */  
def get[S]: State[S, S] = init  
def gets[S, T](f: S =&gt; T): State[S, T] = State(s =&gt; (s, f(s)))  
def put[S](s: S): State[S, Unit] = State(_ =&gt; (s, ()))  
def modify[S](f: S =&gt; S): State[S, Unit] = State(s =&gt; {  
  /* 상태 S 를 변경하는 함수를 받아, 적용하고 A 위치에 `()` 를 돌려줌 */
  val r = f(s);
  (r, ())
})

def getStargazer(url: String): State[Cache, Int] = State { c =&gt;  
  c.get(url) match {
    case Some(count) =&gt; (c, count)
    case None        =&gt; (c.updated(url, 0), 0)
  }
}

def getStargazerWithFor(url: String): State[Cache, Int] =  
  for {
    c &lt;- State.get[Cache]
    optCount = c.get(url)
    _ &lt;- modify { c: Cache =&gt;
      // same as `if (optCount.isDefined) c else c.updated(url, 0)`
      optCount match {
        case Some(count) =&gt; c
        case None        =&gt; c.updated(url, 0)
      }
    }
  } yield optCount.getOrElse(0)
</code></pre>

<h3 id="whentousestate">When to use State</h3>

<p>그러면, 언제 <code>State</code> 가 필요할까요? 하나의 <strong>상태</strong> (<em>State</em>) 를 지속적으로 변경, 공유하면서 연산을 실행할 때 사용할 수 있습니다.</p>

<blockquote>
  <p>Building computations from sequences of operations that require a shared state.</p>
</blockquote>

<p>예를 들어 HTTP 요청과 응답, 트랜잭션 등을 <code>State</code> 로 다루면서 연산을 조합해서 사용할 수 있습니다.</p>

<ul>
<li>HttpRequest, HttpResponse, HttpSession</li>
<li>Database Transaction</li>
<li>Random Number Generator</li>
</ul>

<h3 id="githubserviceexample">Github Service Example</h3>

<p>그러면 위에서 보았던 <code>Cache</code> 에 약간의 기능을 추가해 볼까요? 캐시 히트, 미스도 저장하고 캐시 히트는 최대 5분까지만 인정하기로 하지요. 오래된 캐시를 삭제하는 기능을 빼고 만들어 보면,</p>

<pre><code class="language-scala">type URL = String  
type StarCount = Int

case class Timestamped(count: StarCount, time: DateTime)

case class Cache(hits: Int, misses: Int, map: Map[URL, Timestamped]) {  
  def get(url: URL): Option[Timestamped] = map.get(url)
  def update(url: URL, timestamp: Timestamped): Cache = {
    val m = map + (url -&gt; timestamp)
    this.copy(map = m)
  }
}

object Cache {  
  def empty = Cache(0, 0, Map())
}
</code></pre>

<p>만약 <code>State</code> 가 없다면, 우리가 다루는 상태인 <code>Cache</code> 를 명시적으로 넘겨주고, 리턴받기 위해 이렇게 코드를 작성해야 할테지요. 여기서 <code>c1</code> 대신 <code>c</code> 를 쓰는 오타라도 발생한다면..</p>

<pre><code class="language-scala">def stargazerCount(url: URL, c: Cache): (Cache, StarCount) = {  
  val (c1, optCount) = checkCache(url, c)

  optCount match {
    case Some(count) =&gt; (c1, count)
    case None =&gt; retrieve(url, c1)
  }
}

def checkCache(url: URL, c: Cache): (Cache, Option[StarCount]) =  
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&gt;
      (c.copy(misses = c.misses + 1), None)
  }

def retrieve(url: URL, c: Cache): (Cache, StarCount) = {  
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def stale(then: DateTime): Boolean = DateTime.now &gt; then + 5.minutes  
def getStarCountFromWebService(url: URL): StarCount = ...  
</code></pre>

<p><br></p>

<p>여기에 <code>State</code> 를 하나씩 적용해 보겠습니다.</p>

<pre><code class="language-scala">def stargazerCount(url: URL, c: Cache): (Cache, StarCount) = {  
  val (c1, optCount) = checkCache(url, c)

  optCount match {
    case Some(count) =&gt; (c1, count)
    case None =&gt; retrieve(url, c1)
  }
}
</code></pre>

<p>먼저 <code>State</code> 타입을 적용하고, 그 후에 <code>for</code> 문을 적용한 뒤에, <code>State.state</code> 를 이용해서 조금 더 깔끔하게 바꾸면</p>

<pre><code class="language-scala">// applying State 
def stargazerCount(url: URL): State[Cache, StarCount] =  
  checkCache(url) flatMap { optCount =&gt;
    optCount match {
      case Some(count) =&gt; State { c =&gt; (c, count) }
      case None        =&gt; retrieve(url)
    }
  }

// use for-comprehension
def stargazerCount2(url: URL): State[Cache, StarCount] = for {  
  optCount &lt;- checkCache(url)
  count &lt;- optCount match {
    case Some(count) =&gt; State[Cache, StarCount] { c =&gt; (c, count) }
    case None        =&gt; retrieve(url)
  }
} yield count

// State.state
def stargazerCount(url: URL): State[Cache, StarCount] = for {  
  optCount &lt;- checkCache(url)
  count &lt;- optCount
    .map(State.state[Cache, StarCount])
    .getOrElse(retrieve(url))
} yield count
</code></pre>

<p><code>checkCache</code> 함수에도 적용해 보겠습니다.</p>

<pre><code class="language-scala">def checkCacheOrigin(url: URL, c: Cache): (Cache, Option[StarCount]) =  
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&gt;
      (c.copy(misses = c.misses + 1), None)
  }

def checkCache1(url: URL): State[Cache, Option[StarCount]] = State { c =&gt;  
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&gt;
      (c.copy(misses = c.misses + 1), None)
  }
}

/**
 *  Has potential bug.
 *  Always use `State.gets` and `State.modify`.
 */
def checkCache2(url: URL): State[Cache, Option[StarCount]] = for {  
  c &lt;- State.get[Cache]
  optCount &lt;- State.state {
    c.get(url) collect { case Timestamped(count, time) if !stale(time) =&gt; count }
  }
  _ &lt;- State.put(optCount ? c.copy(hits = c.hits + 1) | c.copy(misses = c.misses + 1))
} yield optCount

def checkCache(url: URL): State[Cache, Option[StarCount]] = for {  
  optCount &lt;- State.gets { c: Cache =&gt;
    c.get(url) collect { case Timestamped(count, time) if !stale(time) =&gt; count }
  }
  _ &lt;- State.modify { c: Cache =&gt;
    optCount ? c.copy(hits = c.hits + 1) | c.copy(misses = c.misses + 1)
  }
} yield optCount
</code></pre>

<p><code>checkCache2</code> 는 <code>State.get</code> <code>State.put</code> 때문에 버그가 발생할 수 있습니다. <code>get</code> 으로 꺼낸 뒤에 <code>put</code> 으로 넣으면, 이전에 어떤 상태가 있었든지, 덮어 씌우기 때문에 주의가 필요합니다. 일반적으로는 <code>put</code> 대신 <code>modify</code> 를 이용합니다.</p>

<pre><code class="language-scala">def init[S]: State[S, S] = State(s =&gt; (s, s))  
def get[S]: State[S, S] = init  
def put[S](s: S): State[S, Unit] = State(_ =&gt; (s, ()))

def gets[S, T](f: S =&gt; T): State[S, T] = State(s =&gt; (s, f(s)))  
def modify[S](f: S =&gt; S): State[S, Unit] = State(s =&gt; {  
</code></pre>

<p>마지막으로 <code>retrieve</code> 함수도 수정해볼까요</p>

<pre><code class="language-scala">def retrieveOrigin(url: URL, c: Cache): (Cache, StarCount) = {  
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def retrieve1(url: URL): State[Cache, StarCount] = State { c =&gt;  
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def retrieve(url: URL): State[Cache, StarCount] = for {  
  count &lt;- State.state { getStarCountFromWebService(url) }
  timestamp = Timestamped(count, DateTime.now)
  _ &lt;- State.modify[Cache] { _.update(url, timestamp) }
} yield count
</code></pre>

<h3 id="references">References</h3>

<ul>
<li><a href="https://speakerdeck.com/mpilquist/scalaz-state-monad">State Monad in Scalaz</a></li>
<li><a href="http://tpolecat.github.io/assets/scalaz.svg">Scalaz Typeclass Hierarchy</a></li>
<li><a href="http://cs.lth.se/edan40">Haskell Image</a></li>
<li><a href="https://github.com/fpinscala/fpinscala/wiki/Chapter-11:-Monads">fpinscala - Monad</a></li>
<li><a href="https://wiki.haskell.org/All_About_Monads#The_IO_monad">Haskell Monad</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Reactive Message Patterns w/ Actor Model, Chapter 1]]></title><description><![CDATA[<p><img src="http://berb.github.io/diploma-thesis/original/resources/actors.svg" alt=""></p>

<h2 id="whyenterprisesoftwaredevelopmentishard">Why Enterprise Software Development Is Hard</h2>

<p>엔터프라이즈 소프트웨어를 구현할 때 마주치는 문제점은, 고려해야할 것이 너무나 많다는 점입니다.</p>

<ul>
<li>Physical Tiers</li>
<li>Application Servers</li>
<li>Software layers</li>
<li>Frameworks and Patterns</li>
<li>Toolkits</li>
<li>Databases</li>
<li>Messaging Systems</li>
<li>Third-Party Applications</li>
<li>...</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/reactive-message-patterns/complexity_stack.png" alt=""></p>

<p>이런 요소들로 구성된 <strong>complexity stack</strong> 의 내부를 잘 살펴보면, 결국 관심사는 <strong>command</strong> 에 의해 생성된 <strong>domain event</strong> 를</p>]]></description><link>http://1ambda.github.io/reactive-message-patterns-w-actor-model-chapter-1/</link><guid isPermaLink="false">5c6d3ec5-2b23-462a-94da-f5df4ae0bdda</guid><category><![CDATA[scala]]></category><category><![CDATA[actor]]></category><category><![CDATA[akka]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 20 Sep 2015 16:33:22 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://berb.github.io/diploma-thesis/original/resources/actors.svg" alt=""></p>

<h2 id="whyenterprisesoftwaredevelopmentishard">Why Enterprise Software Development Is Hard</h2>

<p>엔터프라이즈 소프트웨어를 구현할 때 마주치는 문제점은, 고려해야할 것이 너무나 많다는 점입니다.</p>

<ul>
<li>Physical Tiers</li>
<li>Application Servers</li>
<li>Software layers</li>
<li>Frameworks and Patterns</li>
<li>Toolkits</li>
<li>Databases</li>
<li>Messaging Systems</li>
<li>Third-Party Applications</li>
<li>...</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/reactive-message-patterns/complexity_stack.png" alt=""></p>

<p>이런 요소들로 구성된 <strong>complexity stack</strong> 의 내부를 잘 살펴보면, 결국 관심사는 <strong>command</strong> 에 의해 생성된 <strong>domain event</strong> 를 저장하는 일임을 알 수 있습니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/reactive-message-patterns/simplicity_stack.png" alt=""></p>

<p><em>Actor Model</em> 은 여기에서 출발합니다. 불필요한 컴포넌트를 제외하고, <strong>command</strong> 와 <strong>event</strong> 에만 집중할 수 있도록 추상화를 제공합니다.</p>

<ul>
<li>What incoming messages (commands and/or events) do I accept?</li>
<li>What outgoing messages (commands and/or events) do I emit?</li>
<li>How can my state be mutated in reaction to incoming messages?</li>
<li>What is my supervision strategy for supervised actors?</li>
</ul>

<p><br></p>

<h2 id="originofactors">Origin Of Actors</h2>

<p>Actor Model 은 최근에 새롭게 만들어진 개념이 아니라, 1973년(<em>Dr. Carl Hewitt</em>) 부터 있었던 개념입니다. 다만 당시에는 컴퓨팅 파워가 부족했기 때문에 활용되지 않았을 뿐입니다. Actor Model 이 처음 만들어졌을 당시에는 CPU 클럭은 1MHz 남짓이었고 멀티코어 프로세서는 존재하지도 않았습니다. </p>

<p><br></p>

<h2 id="understandingactors">Understanding Actors</h2>

<p><em>Actor</em> 는 하나의 컴퓨팅 객체로서 메시지를 받아 다음의 일들을 수행할 수 있습니다.</p>

<ul>
<li>Send a finite number of messages to other actors</li>
<li>Create a finite number of new actors</li>
<li>Designate the behavior to be used for the next messages it receives</li>
</ul>

<p>Actor System 에서는 모든것이 Actor 입니다. 따라서 <code>Int</code>, <code>String</code> 처럼 일종의 <em>primitive type</em> 으로 생각하면 더 이해가 쉽습니다.</p>

<p>Actor System 과 Actor 는 다음의 특성을 가지고 있습니다. </p>

<ul>
<li>Communication via direct asynchronous message</li>
<li>State machines (FSM)</li>
<li>Share nothing</li>
<li>Lock-Free Concurrency</li>
<li>Parallelism</li>
</ul>

<p><strong>Akka</strong> 에서 추가적으로 제공하는 특성들은 다음과 같습니다.</p>

<ul>
<li>Location Transparency</li>
<li>Supervision</li>
<li>Future / Promises</li>
</ul>

<p><br></p>

<h2 id="concurrencyandparallelism">Concurrency and Parallelism</h2>

<blockquote>
  <p>Concurrency describes multiple computation occurring simultaneously. Parallelism is concurrency but applied to achieving a single goal. Parallelism is achieved by dividing a single complex process into smaller tasks and executing them concurrently. </p>
</blockquote>

<p><a href="https://en.wikipedia.org/wiki/Amdahl%27s_law?oldformat=true">Amdahl’s law</a> 에 의하면 <strong>병렬화해서 얻을 수 있는 최대 성능은, 병렬화 할 수 없는 부분에 의해서 제한됩니다.</strong> </p>

<p>따라서 시스템을 얼마나 병렬화 할 수 있도록 디자인하는가가 성능에 영향을 주게 됩니다. 이는 일반적으로 어려운 일이지만, Actor System 을 이용하면 atomic 연산 unit 인 Actor 를 기반으로 디자인할 수 있으므로 부가적인 계층(Tier) 보다는 로직(이 메시지를 받았을 때 어떤 일을 해야하는가)에 더 집중하게 되어 쉬운 일이 됩니다. </p>

<p>Akka 프로젝트 설명에서도 볼 수 있듯이, 분산 병렬 시스템을 만드는 것은 어려운 일이지만 대부분의 경우는 잘못된 추상(Abstaction), 도구(Tool) 을 이용하기 때문입니다. Actor Model 은 프로그래머가 더 쉬운 방법으로 분산 병렬 시스템을 디자인할 수 있도록 돕습니다.</p>

<blockquote>
  <p>We believe that writing correct concurrent &amp; distributed, resilient and elastic applications is too hard. Most of the time it's because we are using the wrong tools and the wrong level of abstraction.</p>
  
  <p>Akka is here to change that.</p>
  
  <p>Using the Actor Model we raise the abstraction level and provide a better platform to build correct concurrent and scalable applications. </p>
</blockquote>

<p><br></p>

<h2 id="nondeterminism">Non-determinism</h2>

<p>Actor Model 이 비결정적이라는 비판들이 있습니다. 그러나 실제로 내부를 잘 살펴보면 Actor 그 자체는 <em>deterministic atomic unit</em> 입니다. 따라서 시스템을 Reactive 하게 구성하는 과정에서 프로그래머가 다루어야 하는 <em>non-determinism</em> 을 Actor Model 을 이용하면 더 간단하게 다룰 수 있습니다.</p>

<p><br></p>

<h2 id="references">References</h2>

<ul>
<li>Title Image - <a href="http://berb.github.io/">http://berb.github.io/</a></li>
<li>Book - <a href="http://www.amazon.com/Reactive-Messaging-Patterns-Actor-Model/dp/0133846830/ref=sr_1_2?ie=UTF8&amp;qid=1442747296&amp;sr=8-2&amp;keywords=akka+in+action">Reactive Message Patterns with the Actor Model</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Angular, Providers]]></title><description><![CDATA[<p><img src="https://ga-core.s3.amazonaws.com/production/uploads/program/default_image/1444/Angularjs-Bootcamp-LONDON.jpg" alt=""></p>

<p>자그마한 프로젝트를 엇그제 시작했습니다. 오늘 해야 할 일은 Linkedin, Github API 를 붙이는 일인데, 그 전에 Angular 를 좀 보고 넘어가겠습니다. 아래는 <a href="https://github.com/DaftMonk/generator-angular-fullstack">angular-fullstack</a> 으로 만들면 생성되는 템플릿 코드인데, 어디서 부터 시작해야할지 감이 안잡히네요!</p>

<pre><code class="javascript">angular.module('app', [  
  'ngCookies',
  'ngResource',
  'ngSanitize',
  'ui.router',
  'ui.bootstrap'
])
  .config(function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider) {
    $urlRouterProvider</code></pre>]]></description><link>http://1ambda.github.io/angular-providers/</link><guid isPermaLink="false">fac918aa-4bc5-464c-ba73-2d2fad7e6a9d</guid><category><![CDATA[Angular]]></category><category><![CDATA[Trend Factory]]></category><category><![CDATA[factory]]></category><category><![CDATA[service]]></category><category><![CDATA[provider]]></category><category><![CDATA[injector]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 14 Mar 2015 16:42:33 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://ga-core.s3.amazonaws.com/production/uploads/program/default_image/1444/Angularjs-Bootcamp-LONDON.jpg" alt=""></p>

<p>자그마한 프로젝트를 엇그제 시작했습니다. 오늘 해야 할 일은 Linkedin, Github API 를 붙이는 일인데, 그 전에 Angular 를 좀 보고 넘어가겠습니다. 아래는 <a href="https://github.com/DaftMonk/generator-angular-fullstack">angular-fullstack</a> 으로 만들면 생성되는 템플릿 코드인데, 어디서 부터 시작해야할지 감이 안잡히네요!</p>

<pre><code class="javascript">angular.module('app', [  
  'ngCookies',
  'ngResource',
  'ngSanitize',
  'ui.router',
  'ui.bootstrap'
])
  .config(function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider) {
    $urlRouterProvider
      .otherwise('/');

    $locationProvider.html5Mode(true);
    $httpProvider.interceptors.push('authInterceptor');
  })

  .factory('authInterceptor', function ($rootScope, $q, $cookieStore, $location) {
    return {
      // Add authorization token to headers
      request: function (config) {
        config.headers = config.headers || {};
        if ($cookieStore.get('token')) {
          config.headers.Authorization = 'Bearer ' + $cookieStore.get('token');
        }
        return config;
      },

      // Intercept 401s and redirect you to login
      responseError: function(response) {
        if(response.status === 401) {
          $location.path('/login');
          // remove any stale tokens
          $cookieStore.remove('token');
          return $q.reject(response);
        }
        else {
          return $q.reject(response);
        }
      }
    };
  })

  .run(function ($rootScope, $location, Auth) {
    // Redirect to login if route requires auth and you're not logged in
    $rootScope.$on('$stateChangeStart', function (event, next) {
      Auth.isLoggedInAsync(function(loggedIn) {
        if (next.authenticate &amp;&amp; !loggedIn) {
          $location.path('/login');
        }
      });
    });
  });
</code></pre>

<h3 id="configrun">config, run</h3>

<p>원문은 <a href="https://docs.angularjs.org/guide/module#module-loading-dependencies">Angular Document: Module Loading &amp; Dependencies</a></p>

<p><em>configuration</em> 과 <em>run block</em> 은 <em>bootstrap</em> 과정에서 실행되는데</p>

<ul>
<li><em>configuration block</em> 에서는 <strong>provider</strong>, <strong>constant</strong> 만 <em>injected</em> 될 수 있고</li>
<li><em>run block</em> 은 <em>injector</em> 가 생성되고, 어플리케이션을 구동하기 위해 사용된 후에 실행됩니다. <strong>instance</strong> 와 <strong>constant</strong> 만 <em>injected</em> 될 수 있습니다.</li>
</ul>

<pre><code class="javascript">angular.module('myModule', []).

  config(function(injectable) { // provider-injector
    // you can only inject Providers (not instances)
    // into config block
  }).

  run(function(injectable) {    // instance-injector
    // you can only inject instances (not Providers)
    // into run blocks
  });
</code></pre>

<p>아래는 동일한 코드를 다른 메소드를 이용해 작성한 애플리케이션 초기화 코드입니다.</p>

<pre><code class="javascript">angular.module('myModule', []).  
  value('a', 123).
  factory('a', function() { return 123; }).
  directive('directiveName', ...).
  filter('filterName', ...);

// is same as

angular.module('myModule', []).  
  config(function($provide, $compileProvider, $filterProvider) {
    $provide.value('a', 123);
    $provide.factory('a', function() { retrun 123; });
    $compileProvider.directive('directiveName', ...);
    $filterProvider.register('filterName', ...);
  });  
</code></pre>

<p>배운것보다 모르는게 더 많이 생겼습니다. <code>Provider</code>, <code>$provide</code>, <em>injectable</em>  이 뭘까요?</p>

<p><br></p>

<h3 id="providers">Providers</h3>

<p>원문은 <a href="https://docs.angularjs.org/guide/providers">Angular Document: Providers</a></p>

<p><em>angular app</em> 에서 쓰이는 오브젝트들은 <a href="https://docs.angularjs.org/api/auto/service/$injector"><em>intector service</em></a> 에 의해서 인스턴스화(<em>instantiated</em>) 됩니다. <em>injector</em> 는 두 타입의 오브젝트를 만드는데, </p>

<p>(1) <strong>Services:</strong> are objects whose API is defined by the developer writing the service <br>
(2) <strong>Specialized objects:</strong> conform to a specific angular framework API. These objects are one of controllers, directives, filters or animations</p>

<p><em>injector</em> 가 이러한 서비스를 만들기 위해서는 <em>recipe</em> 를 알려줘야 하는데, 크게 5가지 <em>recipe</em> 가 있습니다. </p>

<p>가장 유명한건 <strong>Provider</strong> 입니다. 그 외에 <em>Provider</em> 를 이용해 만든 <strong>Value</strong>, <strong>Factory</strong>, <strong>Service</strong>, <strong>Constant</strong> 가 있습니다. </p>

<p><em>angular module</em> 은 하나 이상의 <em>Provider</em> 를 포함할 수 있습니다. 애플리케이션이 시작될때 <em>Angular</em> 는 <em>injector</em> 의 새로운 인스턴스를 만들고, <code>ng</code> 모듈, 애플리케이션 모듈, 그리고 그 <em>dependencies</em> 에 있는 모든 <em>recipe</em> 를 하나의 레지스트리에 등록합니다. 그리고 이후에 필요할때마다 <em>injector</em> 는 이 레지스트리에 새로운 인스턴스를 만들어야 할지, 아니면 존재하는 것을 사용할지 질의합니다.</p>

<p><em>Value recipe</em> 를 이용한 간단한 <a href="https://docs.angularjs.org/guide/providers#value-recipe">예제</a> 를 보겠습니다.</p>

<pre><code class="javascript">var myApp = angular.module('myApp', []).  
              value('clientId', 'a12345654321x');

myApp.controller('myController', ['clientId',  
                                  function(clientId) {
  this.clientId = clientId;
}]);                              
</code></pre>

<p><code>myApp</code> 모듈에 정의되어 있는 <code>clientId</code> <em>Value recipe</em> 를 등록하고 컨트롤러에서 사용했습니다.</p>

<p><br></p>

<h3 id="factory">Factory</h3>

<pre><code class="javascript">myApp.factory('apiToken', ['clientId', function apiTokenFactory(clientId) {

  var encrypt = function(data1, data2) {
  // encryption algorithm:
    return (data + ':' + data2).toUpperCase();
  };

  var secret = window.localStorage.getItem('myApp.secret');
  var apiToken = encrypt(clientId, secret);

  return apiToken;
}]);
</code></pre>

<p><em>Factory recipe</em> 를 이용해서 <code>apiToken</code> 서비스를 정의했습니다. 이 서비스는 <em>Value recipe</em> 를 이용해 만든 <code>clientId</code> 서비스에 의존합니다.</p>

<p><br></p>

<h3 id="service">Service</h3>

<p><code>apiToken</code> 서비스를 이용하는 다른 서비스를 <em>Service recipe</em> 를 이용해서 만들어 볼텐데, 동시에 <em>Service recipe</em> 가 어떤 역할을 하는지 비교하기 위해 <em>Factory recipe</em> 로도 만들어 보겠습니다.</p>

<pre><code class="javascript">function UnicornLauncher(apiToken) {

  this.launchedCount = 0;
  this.launch = function() {
    // Make a request to the remote API and include the apiToken
    ...
    this.launchedCount++;
  }
}

myApp.factory('unicornLauncher', ["apiToken", function(apiToken) {  
  return new UnicornLauncher(apiToken);
}]);

// is same as
myApp.service('unicornLauncher', ["apiToken", UnicornLauncher]);  
</code></pre>

<p><em>Factory recipe</em> 로도 만들 수 있지만, 일반적으로 <em>Service recipe</em> 는 <code>new</code> 와 함께 호출되는 서비스를 정의하기 위해 사용합니다. <a href="http://stackoverflow.com/questions/14324451/angular-service-vs-angular-factory">Stackoverflow: Factory vs Service</a> 에서도 그 답변을 찾을 수 있습니다.</p>

<p>예를 들어서 위에서 우리가 정의한 <code>unicornLauncher</code> 서비스는, <code>UnicornLauncher</code> 생성자를 <code>new</code> 로 호출됩니다.</p>

<p><br></p>

<p>아래는 대략적인 두 함수의 구성입니다.</p>

<pre><code class="javascript">function factory(name, factoryFn) {  
    return provider(name, { $get: factoryFn }); 
}

function service(name, constructor) {  
    return factory(name, ['$injector', function($injector) {
      return $injector.instantiate(constructor);
    }]);
}
</code></pre>

<p><code>$injector</code> 는 <em>provider</em> 에 의해 정의된 인스턴스를 <em>angular app</em> 내에서 조회하고, 생성할 수 있습니다. 이외에도 메소드를 호출하거나, 모듈을 로드할 수 있습니다.</p>

<p><br></p>

<h3 id="provider">Provider</h3>

<p><em>Provider recipe</em> 는 <em>Service</em> 나 <em>Factory</em> 등 다른 <em>recipe</em> 를 구성하는 코어 컴포넌트입니다. 문법적으로는 <code>$get</code> 을 구현한 커스텀 타입입니다. 이 <code>$get</code> 메소드는 <em>Factory recipe</em> 에서 사용했던 것과 같은 <em>factory function</em> 입니다. </p>

<p>다시 말해서, <em>Factory recipe</em> 만들때 하는 일은 <em>empty Provider</em> 에 <code>$get</code> 을 이용해 정의된 <em>factory function</em> 을 가져오는 일입니다.</p>

<p><em>Provider recipe</em>  는 반드시 애플리케이션이 시작 되기 전에 생성되야 하는 <em>application-wide configuration</em> 을 위한 <em>API</em> 를 정의할때만 사용해야 합니다.</p>

<pre><code class="javascript">myApp.provider('unicornLauncher', funtion UnicornLauncherProvider() {  
  var useTinfoilShielding = false;

  this.useTinfoilShielding = function(vaue) {
    useTinfoilShielding = !!value;
  };

  this.$get = ["apiToken", function unicornLauncherFactory(apiToken) {
    return new UnicornLauncher(apiToken, useTinfoilShielding);
  }];
});

myApp.config(["unicornLauncherProvider", function(unicornLauncherProvider) {  
  unicornLauncherProvider.useTinfoilShielding(true);
}]);
</code></pre>

<p>처음에 <em>configuration block</em> <code>config</code> 를 언급하면서 <strong>provider</strong>, <strong>constant</strong> 만 <em>injected</em> 될 수 있다고 말했었는데, 이런 이유에서입니다.</p>

<p><em>regular instance injector</em> 와는 달리 <em>provider injector</em> 에 의해 실행되는 이런 <em>injection</em> 을 통해 모든 <em>provider</em> 가 인스턴스화 (<em>instantiated</em>) 됩니다.</p>

<p><em>angular</em> 애플리케이션이 부트스트랩되는 동안, <em>provider</em> 가 구성되고, 생성되는 동안에는 <em>service</em> 에 접근할 수 없습니다. 이는 <em>service</em> 가 아직 생성되지 않았기 때문입니다.</p>

<p><em>configuration phase</em> 가 지난 후에야 <em>services</em> 가 생성되고, 이 단계를 <em>run phase</em> 라 부릅니다. 이 때문에 <em>run block</em> 에서 <strong>instance</strong> 와 <strong>constant</strong> 만 <em>injected</em> 될 수 있다고 위에서 언급한 것입니다.</p>

<p><br></p>

<h3 id="specialpurposeobjects">Special Purpose Objects</h3>

<p>앞서 <em>Angular</em> 에서 쓰이는 모든 오브젝트는 <em>intector service</em> <code>$injector</code>  에 의해서 초기화 된다고 했었습니다. 일반적인 서비스 오브젝트와, 특별한 목적을 가진 오브젝트들이 있다고 언급하기도 했지요.</p>

<p>이런 특별한 오브젝트들은 프레임워크를 확장하는 플러그인으로서 <em>Angular</em> 에서 정의한 <em>interface</em> 를 구현해야 하는데, 이 인터페이스는 <code>Controller</code>, <code>Directive</code>, <code>Filter</code>, <code>Animation</code> 입니다. </p>

<p><code>Controller</code> 오브젝트를 제외하고는 이러한 <em>special object</em> 를 생성하기 위해 <em>injector</em> 는 <em>Factory recipe</em> 를 이용합니다. 따라서 인자로 넣어준 팩토리 함수가 디렉티브를 만들기 위해 호출됩니다.</p>

<pre><code class="javascript">myApp.directive('myPlanet', ['planetName', function myPlanetDirectiveFactory(planetName) {  
  // directive definition object
  return {
    restrict: 'E',
    scope: {},
    link: function($scope, $element) { $element.text('Planet: ' + planetName); }
  }
}]);
</code></pre>

<p><br></p>

<h3 id="controller">Controller</h3>

<pre><code class="javascript">myApp.controller('DemoController', ['clientId', function DemoController(clientId) {  
  this.clientId = clientId;
}]);
</code></pre>

<p><code>Controller</code> 는 조금 다르게, <em>Factory recipe</em> 를 이용하지 않습니다. 인자로 정의한 <em>constructor function</em> 함수가 <strong>모듈과 함께 등록</strong>됩니다. </p>

<p>애플리케이션이 <code>DemoController</code> 가 필요할때마다 매번 <em>constructor</em> 를 통해서 인스턴스화(<em>instantiated</em>) 합니다. 일반적인 <em>service</em> 와는 다르게, <strong>컨트롤러는 싱글턴이 아닙니다</strong>. </p>

<p>지금까지 배운 내용을 정리하면</p>

<ul>
<li>The injector uses recipes to create two type of objects: <strong>services</strong> and <strong>special purpose objects</strong></li>
<li>There are five recipe types that define how to create objects: <strong>Value</strong>, <strong>Factory</strong>, <strong>Service</strong>, <strong>Provide</strong>, and <strong>Constant</strong></li>
<li>Factory and Service are the most commonly used recipes. The only differences between them is that the <em>Service recipe</em> works better <strong>for objects of a custom type</strong>, while the <em>Factory</em> can produce <strong>primitives and functions</strong></li>
<li>The <em>Provider recipe</em> is the core recipe type and all the other ones are just syntactic sugar on it</li>
<li><em>Provider</em> is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration</li>
<li>All special purpose objects except for the <strong>Controller</strong> are defined via <em>Factory recipes</em></li>
</ul>

<p><br></p>

<h3 id="dependencyinjection">Dependency Injection</h3>

<p><img src="https://docs.angularjs.org/img/guide/concepts-module-injector.png" alt=""></p>

<p><em>service</em> 는 <code>$injector</code> 에 의해서 싱글턴 인스턴스가 만들어지고, <code>$injector.get()</code> 을 통해 얻을 수 있습니다. 만약 캐시된 인스턴스가 있다면 가져오고 없으면 새로 만듭니다. 아래는 외부에서 <code>injector</code> 를 통해 내부 서비스를 접근하는 방법입니다.</p>

<pre><code class="javascript">var injector = angular.injector(['myModule', 'ng']);  
var greeter = injector.get('greeter');  
</code></pre>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) [http://galleryhip.com/angular-js-icon.html) <br>
(2) <a href="https://docs.angularjs.org/guide/providers#value-recipe">Angular Document</a> <br>
(3) <a href="http://www.webdeveasy.com/javascript-promises-and-angularjs-q-service/">Webdeveasy: AngularJS Q</a> <br>
(4) <a href="http://www.webdeveasy.com/interceptors-in-angularjs-and-useful-examples/">Webdeveasy: AngularJS Interceptor</a>  </p>]]></content:encoded></item><item><title><![CDATA[Coding The Matrix 3]]></title><description><![CDATA[<p><img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/column_row_space.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_as_vector.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_impl.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/null_space_of_matrix.jpg" alt=""></p>

<p>Null space of a matrix is a vector space</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/vector_space.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions_proof.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/use_standard_generator.jpg" alt=""></p>

<p><em>standard geneartor</em> 를 이용해서 <code>f(x) = M * x</code> 에서의 <code>M</code> 의 컬럼을 알아낼 수 있다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_function_def.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_def_2.jpg" alt=""></p>

<p>어떤 함수 <code>f</code> 가 <code>M * x</code> 형태로 정의되면, <code>f</code> 는 <em>linear function</em> 이다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/def_kernel.jpg" alt=""></p>

<p>어떤 함수 <code>f</code> 의 <em>kernel</em> 은 <em>image</em> 를 <code>0</code> 으로 하는 집합이다. 다시</p>]]></description><link>http://1ambda.github.io/coding-the-matrix-3/</link><guid isPermaLink="false">715b3e8b-1821-4204-98cf-48f2a029e11b</guid><category><![CDATA[coursera]]></category><category><![CDATA[linear algebra]]></category><category><![CDATA[matrix]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 14 Mar 2015 16:41:34 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/column_row_space.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_as_vector.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/matrix_impl.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/null_space_of_matrix.jpg" alt=""></p>

<p>Null space of a matrix is a vector space</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/vector_space.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/solutions_proof.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/use_standard_generator.jpg" alt=""></p>

<p><em>standard geneartor</em> 를 이용해서 <code>f(x) = M * x</code> 에서의 <code>M</code> 의 컬럼을 알아낼 수 있다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_function_def.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/linear_def_2.jpg" alt=""></p>

<p>어떤 함수 <code>f</code> 가 <code>M * x</code> 형태로 정의되면, <code>f</code> 는 <em>linear function</em> 이다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/def_kernel.jpg" alt=""></p>

<p>어떤 함수 <code>f</code> 의 <em>kernel</em> 은 <em>image</em> 를 <code>0</code> 으로 하는 집합이다. 다시 말해서 <code>f(x) = M * x</code> 에 대해 <em>null matrix</em> <code>x</code> 이 <em>kernel</em></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/kernel_one_to_one1.jpg" alt=""></p>

<p><em>linear function</em> <code>f</code> is <strong>one-to-one</strong> iff its kernel is a <em>trivial vector space</em></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/kernel_one_to_one2.jpg" alt=""></p>

<p>위에 나온 속성은 상당히 중요하다. 왜냐하면 <em>trivial kernel</em> 이면, 다시 말해서 <em>null matrix</em> 가 <em>trivial</em> 이면, <code>f</code> 의 <em>image</em> <code>b</code> 는 아무리 많아봐야 하나이기 때문이다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/def_onto.jpg" alt=""></p>

<p><em>image</em> 가 <em>entire co-domain</em> 과 같으면 <strong>onto</strong> 다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/inner_product.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/outer_product.jpg" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/function_composition.jpg" alt=""></p>

<p>두 <em>matrix-vector function</em> 의 <em>composition</em> 은 위처럼 쉽게 증명 가능하다. <code>AB * x</code> 로</p>

<p>이걸 이용하면 <em>matrix-matrix multiplication</em> 의 <em>associativity</em> 도 쉽게 증명 가능하다. <code>(AB)C = A(BC)</code></p>

<p><br></p>

<h3 id="invertible">Invertible</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible2.jpg" alt=""></p>

<p>두 함수가 <em>inverse</em> 관계면 두 매트릭스도 <em>inverse</em> 관계다. 그리고 한 매트릭스의 <em>inverse matrix</em> 가 존재하면 <em>invertible</em> 또는 <em>singular</em> 라 부르며, 아무리 많아봐야 하나의 <em>inverse</em> 만 가진다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way2.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way3.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_way4.jpg" alt=""></p>

<p><em>invertible matrix</em> 가 중요한 이유는, <em>invertible matrix</em> 가 존재하면 <code>f</code> 도 <em>invertible</em> 이고, 그 말은 <code>f</code> 가 <strong>one-to-one, onto</strong> 라는 소리다. 따라서 <code>f(u) = b</code> 에 대해 적어도 하나의 솔루션이 존재하고 (<em>onto</em>), 아무리 많아봐야 하나의 솔루션이 존재한다는 뜻이다 (<em>one-to-one</em>)</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_product_matrix1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/invertible_product_matrix2.jpg" alt=""></p>

<p>함수처럼 매트릭스도 <code>A</code>, <code>B</code> 가 <em>invertible</em> 일때만 <code>AB</code> 도 그러하다. </p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/identity_invertible1.jpg" alt=""></p>

<p><code>AB</code> 에 대해 <code>A</code>, <code>B</code> 가 서로의 <em>inverse</em> 면 <code>AB</code> 는 <em>identity matrix</em> 지만 그 역은 성립하지 않는다.</p>

<p>위 그림의 <code>A</code> 에서 볼 수 있듯이 <em>null space</em> 가 <em>trivial</em> 하지 않기 때문에 <em>one to one</em> 이 아니어서 <code>A</code> 는 <em>invertible</em> 이 아니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/identity_invertible2.jpg" alt=""></p>

<p><code>AB</code>, <code>BA</code> 가 모두 <em>identity matrix</em> 여야 <code>A</code>, <code>B</code> 가 서로 <em>inverse</em> 다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/3-matrix/identity_invertible3.jpg" alt=""></p>

<p>매트릭스 <code>M</code> 이 <em>one-to-one</em> 인지는 <em>trivial kernel</em> 인지를 판별하면 된다. <code>f(x) = M * x</code> 는 <em>linear function</em> 이기 때문에 <em>trivial kernel</em> 이면 <code>M</code> 도 <em>one-to-one</em> 이다.</p>

<p><em>onto</em> 인지는 어떻게 알 수 있을까?</p>

<p><br></p>

<h3 id="summary">Summary</h3>

<p>지금 까지의 내용을 정리하면</p>

<ol>
<li><code>u1</code> 이 <code>a * x = b</code> 의 솔루션일때, <code>V</code> 를 <code>a * x = 0</code> 의 솔루션 셋이라 하면, <code>u1 + V</code> 는 <code>a * x = b</code> 의 솔루션 셋이다. 다시 말해서 <code>V</code> 는 <em>null matrix</em>  </li>
<li><code>f(x)</code> 가 <code>M * x</code> 형태로 나타낼 수 있으면 <em>linear function</em> 이다.  </li>
<li><em>trivial kernel</em> 이면 <em>linear function</em> <code>f</code> 는 <em>one-to-one</em> 이고, <em>linear function</em> <code>f</code> 가 <em>one-to-one</em> 이면 <em>trivial kernel</em> 을 가진다.  </li>
</ol>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://colorsark.deviantart.com/art/3D-Cube-342632998">Title image</a> <br>
(2) <strong>Coding the Matrix</strong> by <em>Philip Klein</em>  </p>]]></content:encoded></item><item><title><![CDATA[Cloud Computing, Paxos]]></title><description><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>대부분의 분산 서버 벤더들은 <code>99.99999%</code> 의 <em>reliability</em> 를 보장하지만, <code>100%</code>는 아닙니다. 왜그럴까요? 그들이 못해서가 아니라 <em>consensus</em> 문제 때문입니다.</p>

<blockquote>
  <p>The fault lies in the impossibility of consensus</p>
</blockquote>

<p><em>Consensus</em> 문제가 중요한 이유는, 많은 분산 시스템이 <em>consensus</em> 문제이기 때문입니다. </p>

<ul>
<li>Perfect Failure Detection</li>
<li>Leader Election</li>
<li>Agreement (harder than consensus)</li>
</ul>

<p><br></p>

<p>일반적으로 서버가 많으면</p>]]></description><link>http://1ambda.github.io/cloud-computing-paxos/</link><guid isPermaLink="false">fa427789-33eb-4728-913a-ab4b1cfbf14e</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[paxos]]></category><category><![CDATA[consensus]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 07 Mar 2015 19:44:32 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>대부분의 분산 서버 벤더들은 <code>99.99999%</code> 의 <em>reliability</em> 를 보장하지만, <code>100%</code>는 아닙니다. 왜그럴까요? 그들이 못해서가 아니라 <em>consensus</em> 문제 때문입니다.</p>

<blockquote>
  <p>The fault lies in the impossibility of consensus</p>
</blockquote>

<p><em>Consensus</em> 문제가 중요한 이유는, 많은 분산 시스템이 <em>consensus</em> 문제이기 때문입니다. </p>

<ul>
<li>Perfect Failure Detection</li>
<li>Leader Election</li>
<li>Agreement (harder than consensus)</li>
</ul>

<p><br></p>

<p>일반적으로 서버가 많으면 다음의 일들을 해야합니다.</p>

<ul>
<li><strong>Reliable Multicast:</strong> Make sure that all of them receive the same updates in the same order as each other</li>
<li><strong>Membership/Failure Detection:</strong> To keep their own local lists where they know about each other, and when anyone leaves or fails, everyone is updated simultaneously</li>
<li><strong>Leader Election:</strong> Elect a leader among them, and let everyone in the group know about it</li>
<li><strong>Mutual Exclusion:</strong> To ensure mutually exclusive access to a critical resource like a file</li>
</ul>

<p>이 문제들은 대부분 <em>consensus</em> 와 연관되어 있습니다. 더 직접적으로 연관되어 있는 문제들은</p>

<ul>
<li>The ordering of messages</li>
<li>The up/down status of a suspected failed process</li>
<li>Who the leader is</li>
<li>Who has access to the critical resource</li>
</ul>

<p><br></p>

<h3 id="consensusproblem">Consensus Problem</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_problem.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_problem2.png" alt=""></p>

<p>모든 프로세스(노드, 서버)가 같은 <em>value</em> 를 만들도록 해야 하는데, 몇 가지 제약조건이 있습니다.</p>

<ul>
<li><strong>validity:</strong> if everyone propose same value, then that's what's decided</li>
<li><strong>integrity:</strong> decided value must have been proposed by some process</li>
<li><strong>non-triviality:</strong> there is at least one initial system state that leads to each of the all-<code>0</code>'s or all-<code>1</code>'s outcomes</li>
</ul>

<p><em>non-triviality</em> 는 쉽게 말해서, 모두 <code>0</code> 이거나 모두 <code>1</code> 일 수 있는 상태가 있어야 한다는 뜻입니다. 왜냐하면 항상 <code>0</code> 이거나 <code>1</code> 만 나오면 <em>trivial</em> 하기 때문입니다. 별 의미가 없죠.</p>

<p><br></p>

<h3 id="models">Models</h3>

<p><em>consensus</em> 문제는 분산 시스템 모델에 따라 달라집니다. 모델은 크게 2가지로 나눌 수 있는데</p>

<p>(1) Synchronous Distributed System Model</p>

<ul>
<li>Each message is received within bounded time</li>
<li>Drift of each process' local clock has a known bound</li>
<li>Each step in a process takes <code>lb &lt; time &lt; ub</code></li>
</ul>

<p>동기 시스템 모델에서는 <em>consensus</em> 문제를 풀 수 있습니다.</p>

<p>(2) Asynchronous Distributed System Model</p>

<ul>
<li>Nobounds on process execution</li>
<li>The drift rate of a clock is arbitrary</li>
<li>No bounds on message transmission delay</li>
</ul>

<p>일반적으로 비동기 분산 시스템 모델이 더 일반적입니다, 그리고 더 어렵죠. 비동기를 위한 프로토콜은 동기 모델 위에서 작동할 수도 있으나, 그 역은 잘 성립하지 않습니다.</p>

<p>비동기 분산 시스템 모델에서는 <em>consensus</em> 문제는 풀 수 <strong>없습니다</strong></p>

<ul>
<li>Whatever protocol/algorithm you suggest, there is always a worst-case possible execution with failures and message delays that prevens the system from reaching consensus</li>
<li>Powerful result(see the <strong>FLP</strong> proof)</li>
<li>Subsequently, safe and <strong>probabilistic</strong> solution have become popular (e.g Paxos)</li>
</ul>

<p><br></p>

<h3 id="paxosinsyncronoussystems">Paxos in Syncronous Systems</h3>

<p>동기 시스템이라 가정합니다. 따라서</p>

<ul>
<li>bounds on message dealy</li>
<li>bounds on upper bound on clock drift rates</li>
<li>bounds on max time for each process step</li>
<li>processes can fail by stopping</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_in_sync_system.png" alt=""></p>

<ul>
<li>아무리 많아야 <code>f</code> 개의 프로세서에서 <em>crash</em> 가 나고</li>
<li>모든 프로세서는 <em>round</em> 단위로 동기화 되고, 동작하며</li>
<li><em>reliable communication</em> 을 통해 서로 통신합니다</li>
</ul>

<p><em>value_i^r</em> 을 <em>round</em> <code>r</code> 의 시작에 <code>P_i</code> 에게 알려진 <em>value</em> 의 집합이라 라 하겠습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos2.png" alt=""></p>

<p><code>f+1</code> 라운드 후에 모든 <em>correct</em> 프로세스는 같은 값의 집합을 가지게 되는데, 귀류법으로 쉽게 증명할 수 있습니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consensus_in_async.png" alt=""></p>

<p>비동기 환경에서는, 아주아주아주아주아주 느린 프로세서와 <em>failed</em> 프로세서를 구분할 수 없기 때문에, 나머지 프로세서들이 이것을 결정하기 위해 영원히 기다려야 할지도 모릅니다. 이것이 기본적인 <em>FLP Proof</em> 의 아이디어입니다. 그렇다면, <em>consensus</em> 문제를 정말 풀기는 불가능한걸까요?</p>

<p>풀 수 있습니다. 널리 알려진 <em>consensus-solving</em> 알고리즘이 있습니다. 실제로는 불가능한 <em>consensus</em> 문제를 풀려는 것이 아니라, <em>safety</em> 와 <em>eventual liveness</em> 를 제공합니다. 야후의 <em>zookeeper</em> 나 구글의 <em>chubby</em> 등이 이 알고리즘을 이용합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/yes_we_can_with_paxos.png" alt=""></p>

<p><em>safety</em> 는 서로 다른 두개의 프로세서가 다른 값을 제출하지 않는것을 보장하고, (<em>No two non-faulty processes decide different values</em>) <em>eventual liveness</em> 는 운이 좋다면 언젠가는 합의에 도달한다는 것을 말합니다. 근데 실제로는 꽤 빨리 <em>consensus</em> 문제를 풀 수 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos_simple.png" alt=""></p>

<p>본래는 최적화때문에 더 복잡한데, 위 슬라이드에서는 간략화된 <em>paxos</em> 가 나와있습니다. <em>paxos</em> 의 <em>round</em> 마다 고유한 <em>ballot id</em> 가 할당되고, 각 <em>round</em> 는 크게 3개의 비동기적인 <em>phase</em> 로 분류할 수 있습니다.</p>

<ul>
<li><strong>election:</strong> a leader is elected</li>
<li><strong>bill:</strong> leader proposes a value, processes ack</li>
<li><strong>law:</strong> leader multicasts final value</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/election.png" alt=""></p>

<p>먼저 <em>potential leader</em> 가 <em>unique ballot id</em> 를 고르고, 다른 프로세서들에게 보냅니다. 다른 프로세스들의 반응에 의해서 선출될 수도 있고, 선출되지 않으면 새로운 라운드를 시작합니다. </p>

<ul>
<li>Because becoming a leader requires a majority of votes, and any two majorities intersect in at least one process, and each process can only vote once.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/bill.png" alt=""></p>

<p>리더가 다른 프로세스들에게 <code>v</code> 를 제안하고, 프로세스들은 지난 라운드에 <code>v'</code> 를 결정했었으면 <code>v=v'</code> 를 이용해 값을 결정합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/decision.png" alt=""></p>

<p>만약 리더가 <em>majority</em> 의 긍정적인 반응을 얻으면 모두에게 그 결정을 알리고 각 프로세서는 합의된 내용을 전달받고, 로그에 기록하게 됩니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos_no_return.png" alt=""></p>

<p>사실 이 과정은 응답을 리더가 받는 단계에서 결정되는 것이 아니라, 프로세서들이 <em>proposed value</em> 를 듣는순간 결정됩니다. 따라서 리더에서 <em>failure</em> 가 일어나도, 이전에 결정되었던 <code>v'</code> 을 이용할 수 있습니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxos_safety.png" alt=""></p>

<p>이전에도 언급했듯이 <em>safety</em> 는 두개의 서로 다른 프로세서의 의해서 다른 값이 선택되지 않음을 보장합니다. 이는 잠재적 리더가 있다 하더라도 현재 리더와, 잠재적 리더에게 응답하는 <em>majority</em> (반수 이상) 을 교차하면 적어도 하나는 <code>v'</code> 를 응답하기 때문에 <em>bill phase</em> 에서 정의한대로 이전 결과인 <code>v'</code> 가 사용됩니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/paxsos_liveness.png" alt=""></p>

<p>그림에서 볼 수 있듯이 영원히 끝나지 않을수도 있지만, 실제로는 꽤 빠른시간 내에 합의에 도달합니다. (eventualy-live in async systems)</p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://ook.co/solutions/cloud-computing/">Title Image</a> <br>
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></content:encoded></item><item><title><![CDATA[Cloud Computing, Multicast]]></title><description><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p><em>multicast</em> 는 클라우드 시스템에서 많이 사용됩니다. <em>Cassandra</em> 같은 분산 스토리지에서는 <em>write/read</em> 메세지를 <em>replica gorup</em> 으로 보내기도 하고, <em>membership</em> 을 관리하기 위해서 사용하기도 합니다</p>

<p>그런데, 이 <em>multicast</em> 는 <em>ordering</em> 에 따라서 <em>correctness</em> 에 영향을 줄 수 있기 때문에 매우 중요합니다. 자주 쓰이는 기법으로 <em>FIFO</em>, <em>Casual</em>, <em>Total</em> 이 있는데 하나씩 살펴보겠습니다.</p>]]></description><link>http://1ambda.github.io/cloud-computing-multicast/</link><guid isPermaLink="false">1aa1fadb-da2f-4163-af61-a68ed5cef2ac</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[multicast]]></category><category><![CDATA[virtual synchrony]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 07 Mar 2015 17:20:18 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p><em>multicast</em> 는 클라우드 시스템에서 많이 사용됩니다. <em>Cassandra</em> 같은 분산 스토리지에서는 <em>write/read</em> 메세지를 <em>replica gorup</em> 으로 보내기도 하고, <em>membership</em> 을 관리하기 위해서 사용하기도 합니다</p>

<p>그런데, 이 <em>multicast</em> 는 <em>ordering</em> 에 따라서 <em>correctness</em> 에 영향을 줄 수 있기 때문에 매우 중요합니다. 자주 쓰이는 기법으로 <em>FIFO</em>, <em>Casual</em>, <em>Total</em> 이 있는데 하나씩 살펴보겠습니다.</p>

<p><br></p>

<h3 id="ordering">Ordering</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_FIFO.png" alt=""></p>

<p><em>FIFO</em> 를 이용한다면, 보낸 순서대로 도착하게 됩니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_casual.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_casual_example.png" alt=""></p>

<p><em>casual ordering</em> 에서는 반드시 <em>casuality-obeying order</em> 로 전달해야 합니다. 예를 들어 위 그림에서는 <code>M1:1 -&gt; M3:1</code> 이기 때문에 반드시 그 순서대로 받아야 합니다. <em>concurrent event</em> 는 어떤 순서로 받아도 상관 없습니다.</p>

<p><br></p>

<p><em>casual ordering</em> 이면 <em>FIFO ordering</em> 입니다. 왜냐하면 같은 프로세스에서 보낸 <em>casuality</em> 를 따르면 그게 바로 <em>FIFO</em> 이기 때문입니다. 역은 성립하지 않습니다.</p>

<p>일반적으로는 <em>casual ordering</em> 을 사용합니다. 서로 다른 친구로부터 댓글이 달렸는데, 늦게 달린 친구의 댓글이 먼저 보인다면 당연히 말이 되지 않습니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_total.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Ordering_total_example.png" alt=""></p>

<p><em>total ordering</em> 은 <em>atomic broadcast</em> 라 부르는데, 모든 프로세스가 같은 순서로 메시지를 받는것을 보장합니다.</p>

<ul>
<li>Since <em>FIFO/Casual</em> are orthogonal to <em>Total</em>, can have hybrid ordering protocol too (e.g <em>FIFO-total</em>, <em>Casual-total</em></li>
</ul>

<p><br></p>

<h3 id="fifoorderingimpl">FIFO Ordering Impl</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl2.png" alt=""></p>

<ul>
<li>각 프로세스는 <em>seq number</em> 로 구성된 벡터를 유지하고, </li>
<li>프로세스에서 메시지를 보낼때 마다 자신의 <em>seq number</em> 를 하나 증가 시켜서 보냅니다</li>
<li>메시지를 받았을때, <strong>자신의 벡터 내에 있는 값 + 1</strong> 일 경우에만 벡터 값을 +1 한뒤 전달하고, 아니면 +1 인 값이 올 때까지 버퍼에 넣고 기다립니다</li>
</ul>

<p>예제를 보면</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl_example.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/FIFO_impl_example2.png" alt=""></p>

<p><br></p>

<h3 id="totalorderingimpl">Total Ordering Impl</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/total_impl1.png" alt=""></p>

<p><em>sequencer-based approach</em> 입니다. 먼저 하나의 프로세스가 <em>sequencer</em> 로 선출된 뒤, 어떤 프로세스가 메세지를 보낼때마다 그룹 뿐만 아니라 <em>sequencer</em> 에게 보내게 됩니다.</p>

<p>이 <em>sequencer</em> 는 글로벌 시퀀스 <code>S</code> 를 유지하면서, 메시지 <code>M</code> 을 받을때마다 <code>S++</code> 해서 <code>&lt;M, S&gt;</code> 로 멀티캐스트를 보냅니다.</p>

<p>각 프로세스에서는 <em>local</em> 에 글로벌 시퀀스 <code>Si</code> 를 유지합니다. 만약 프로세스가 메세지를 받는다면 <code>Si + 1 = S(M)</code> 값을 글로벌 시퀀서로부터 받을때까지 기다리고, 받은 후에야 <code>Si++</code> 하고 전달합니다.</p>

<p><br></p>

<h3 id="casualorderingimpl">Casual Ordering Impl</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl2.png" alt=""></p>

<p>자료구조 자체는 같으나, <em>casuality</em> 를 검사하기 위해 <em>sender</em> 가 <em>vector</em> 전체를 보냅니다. <em>receiver</em> 는 메세지를 받으면 다음 두 조건을 만족하기 전까지 버퍼에 넣습니다</p>

<ul>
<li><code>M[j]</code> = <code>P_i[j] + 1</code></li>
<li><code>M[k]</code> &lt;= <code>P_i[k]</code>, (<code>k != j</code>)</li>
</ul>

<p>두번째 조건을 해석하면, 자신의 벡터도 다음 프로세스에게 전달해야 하기 때문에 <code>M[k]</code> 이후의 벡터만 가지고 있어야 전달할 수 있다는 뜻입니다. (<code>M[j]</code> 는 제외)</p>

<p>이 두 조건이 만족되야만 <code>P_i[j] = M[j]</code> 로 세팅하고 <code>M</code> 을 전달합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl_example1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/casual_impl_example2.png" alt=""></p>

<p><br></p>

<h3 id="reliablemulticast">Reliable Multicast</h3>

<p><em>reliable</em> 이란, 루즈하게 말하자면 모든 <em>receiver</em> 가 메세지를 받는다는 뜻입니다. <em>ordering</em> 과는 <em>orthogonal</em> 하기 때문에 <em>Reliable-FIFO</em>, 등등 구현이 가능합니다. 더 엄밀한 정의는</p>

<ul>
<li>need all <strong>correct</strong> (<em>non-faulty</em>) processes to receive the same set of multicasts as all other correct processes</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/reliable_multicast_impl1.png" alt=""></p>

<p>단순히 <em>reliable unicast</em> 를 여러개 보내는것 만으로는 부족합니다. 왜냐하면 <em>sender</em> 에서 <em>failure</em> 가 일어날 수 있기 때문입니다</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/reliable_multicast_impl2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/reliable_multicast_impl3.png" alt=""></p>

<p>비효율적이지만, <em>reliable</em> 합니다.</p>

<p><br></p>

<h3 id="virtualsynchrony">Virtual Synchrony</h3>

<p><em>virtual sinchrony</em> 혹은 <em>view synchrony</em> 라 불리는데, 이것은 <em>failure</em> 에도 불구하고 <em>multicast ordering</em> 과 <em>reliability</em> 를 얻기 위해 <em>membership protocol</em> 을 <em>multicast protocol</em> 과 같이 사용합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/view.png" alt=""></p>

<p>각 프로세스가 관리하는 <em>membership list</em> 를 <em>view</em> 라 부릅니다. <em>virtual synchrony</em> 프로토콜은 이런 <em>view change</em> 가 <em>correct process</em> 에 올바른 순서대로 전달됨을 보장합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/vsync_multicast.png" alt=""></p>

<p><em>Virtual Synchrony</em> 프로토콜은 다음을 보장합니다.</p>

<ul>
<li>the set of multicasts delivered in a given view is the same set at all correct processes that were in that view</li>
<li>the sender of the multicast message also belongs to that view</li>
<li>if a process <code>P_i</code> doesn't not deliver a multicast <code>M</code> in view <code>V</code> while other processes in the view <code>V</code> delivered <code>M</code> in <code>V</code>, then <code>P_i</code> will be <strong>forcibly removed</strong> from the next view delivered after <code>V</code> at the other processes</li>
</ul>

<p>다시 말해서, <em>multicast</em> 메세지는 같이 전달된 <em>view</em> 내에 있던 다른 프로세스에서 모두 동일합니다. 그리고 <em>view</em> <code>V</code> 내에 있는 어떤 프로세스가 <code>M</code> 을 전달하지 못할 경우, 다른 프로세스의 <em>next view</em> 에서 제거됩니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example3.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example4.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example5.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example6.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example7.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/virtual_synchrony_example8.png" alt=""></p>

<p><br></p>

<ul>
<li>Called <strong>"virtual synchrony"</strong> since in spite of running on an asynchronous network, it gives the appearance of a synchronous network underneath that obeys the same ordering at all processes</li>
</ul>

<p>그러나 <em>consensus</em> 를 구현하는데는 쓸 수 없습니다. <em>partitioning</em> 에 취약하기 때문입니다.</p>

<p>정리하자면 <em>multicast</em> 는 클라우드 시스템에서 중요한 요소입니다. 필요에 따라서 <em>ordering</em>, <em>reliability</em>, <em>virtual synchorny</em> 를 구현할 수 있습니다.</p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://ook.co/solutions/cloud-computing/">Title Image</a> <br>
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></content:encoded></item><item><title><![CDATA[Cloud Computing, Snapshots]]></title><description><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>이번시간에는 <em>Distributed Snapshot</em> 에 대해서 배웁니다. 클라우드 환경에서 각 어플리케이션(혹은 서비스) 는 여러개의 서버 위에서 돌아갑니다. 각 서버는 <em>concurrent events</em> 를 다루며, 서로 상호작용합니다. 이런 환경에서 <em>global snapshot</em> 을 캡쳐할 수 있다면</p>

<ul>
<li><strong>check pointing:</strong> can restart distributed application on failure</li>
<li><strong>garbage collection of objects:</strong> object at servers that don't</li></ul>]]></description><link>http://1ambda.github.io/cloud-computing-snapshot/</link><guid isPermaLink="false">7d51c274-e6e6-41dd-a37e-b548da6e711c</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[snapshot]]></category><category><![CDATA[Chandy-Lamport]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 07 Mar 2015 13:57:56 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>이번시간에는 <em>Distributed Snapshot</em> 에 대해서 배웁니다. 클라우드 환경에서 각 어플리케이션(혹은 서비스) 는 여러개의 서버 위에서 돌아갑니다. 각 서버는 <em>concurrent events</em> 를 다루며, 서로 상호작용합니다. 이런 환경에서 <em>global snapshot</em> 을 캡쳐할 수 있다면</p>

<ul>
<li><strong>check pointing:</strong> can restart distributed application on failure</li>
<li><strong>garbage collection of objects:</strong> object at servers that don't have any other objects(ay any servers) with pointers to them</li>
<li><strong>deadlock detection:</strong> useful in database transaction systems</li>
<li><strong>termination of computation:</strong> useful in batch computing systems like Folding@Homes, SETI@Home</li>
</ul>

<p><em>global snapshot</em> 은 두 가지를 포함합니다.</p>

<p>(1) Individual state of each process 
(2) Individual state of each communication channel </p>

<p><em>global snapshot</em> 을 만드는 한가지 방법은 모든 프로세스의 <em>clock</em> 을 동기화 하는 것입니다. 그래서 모든 프로세스에게 <em>time</em> <code>t</code> 에서의 자신의 상태를 기록하도록 요구할 수 있습니다. 그러나</p>

<ul>
<li>Time synchorization always has error</li>
<li>Doesn't not record the state of meesages in the channels</li>
</ul>

<p>지난 시간에 보았듯이, <em>synchronization</em> 이 아니라 <em>casuality</em> 로도 충분합니다. 프로세스가 <strong>명령을 실행하거나</strong>, <strong>메시지를 받거나</strong>, <strong>메시지를 보낼때마다</strong> <em>global system</em> 가 변합니다. 이를 저장하기 위해서 <em>casuality</em> 를 기록하는 방법을 알아보겠습니다.</p>

<p><br></p>

<h3 id="chandylamportalgorithm">Chandy-Lamport Algorithm</h3>

<p>시작 전에 <em>system model</em> 을 정의하면</p>

<ul>
<li>N Processes in the system</li>
<li>There are two uni-directional communication channels between each ordered process pair <code>P_j -&gt; P_i</code>, <code>P_i -&gt; P_j</code></li>
<li>communication channels are <strong>FIFO</strong> ordered</li>
<li><strong>No failure</strong></li>
<li>All messages arribe intact, and are not duplicated</li>
</ul>

<p><em>requirements</em> 는</p>

<ul>
<li><em>snapshot</em> 때문에 <em>application</em> 의 작업에 방해가 일어나서는 안됩니다</li>
<li>각 프로세스는 자신의 <em>state</em> 를 저장할 수 있어야 합니다</li>
<li><em>global state</em> 는 분산회되어 저장됩니다 (collected in a distributed manner)</li>
<li>어떤 프로세스든지, <em>snapshot</em> 작업을 시작할 수 있습니다</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport1.png" alt=""></p>

<ul>
<li>프로세스 <code>P_i</code> 가 <em>market</em> 메세지를 만들고, 자신을 제외한 다른 <code>N-1</code> 개의 프로세스에게 보냅니다</li>
<li>동시에 <code>P_i</code> 는 <em>incoming channel</em> 을 레코딩하기 시작합니다</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport2.png" alt=""></p>

<p>(1) 만약 <code>P_i</code> 가 <em>marker</em> 메시지를 처음 받는다면</p>

<ul>
<li>만약메시지를 받은 프로세스 <code>P_i</code> 에서는 자신의 <em>state</em> 를 기록하고</li>
<li>자신을 제외한 프로세스들에게 <em>marker</em> 보내고</li>
<li>는 <em>incoming channel</em> 을 레코딩하기 시작합니다</li>
</ul>

<p>(2) <code>P_i</code> 가 이미 <em>market</em> 메세지를 받은적이 있다면</p>

<ul>
<li>이미 해당 채널의 모든 메세지를 기록중이었으므로, 레코딩을 끝냅니다</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport3.png" alt=""></p>

<p>이 알고리즘은 모든 프로세스가 자신의 <em>state</em> 와 모든 <em>channel</em> 을 저장하면 종료됩니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example3.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example4.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example5.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Example6.png" alt=""></p>

<p><br></p>

<h3 id="consistentcuts">Consistent Cuts</h3>

<p><em>Chandy-Lamport</em> 알고리즘은 <em>casuality</em> 를 보장합니다. 이에 대해 증명하기 전에 먼저, <em>consistent cut</em> 이란 개념을 보고 가겠습니다.</p>

<ul>
<li><p><strong>Cut:</strong> time frontier at each process and at each channel. Events at the process/channel that happen before the cut are <strong>in the cut</strong> and happening after the cut are <strong>out of the cut</strong></p></li>
<li><p><strong>Consistent Cut:</strong> a cut that obeys casuality. A cut <code>C</code> is a consistent cut iff for each pair of event <code>e</code> <code>f</code> in the system, such that event <code>e</code> is in the cur <code>C</code> and if <code>f -&gt; e</code></p></li>
</ul>

<p>다시 말해서 <code>e</code> 가 <code>C</code> 내에 있고, <code>f -&gt; e</code> 라면 <code>f</code> 도 <code>C</code> 에 있어야만 <em>consistent cut</em> 이란 뜻입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consistent_cut1.png" alt=""></p>

<p><code>F</code> 가 <em>cut</em> 내에 있지만, 올바르게 캡쳐되어 메시지 큐 내에서 전송중임을 <em>snapshot</em> 에서 보장합니다. 하지만 <code>G -&gt; D</code> 같은 경우는, <code>D</code> 가 <em>cut</em> 내에 있지만 <code>G</code> 가 그렇지 않아 <em>inconsistent cut</em> 입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/consistent_cut2.png" alt=""></p>

<p><em>Chandy-Lamport Global Snapshot</em> 알고리즘은 항상 <em>consistent cut</em> 을 만듭니다. 왜 그런가 증명을 보면</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Proof1.png" alt=""></p>

<p><code>ei -&gt; ej</code> 를 보장한다는 말은 스냅샷 안에 두 이벤트가 있다는 뜻입니다. 따라서 <code>ej -&gt; &lt;P_j records its state&gt;</code> 일때 당연히 <code>ei -&gt; &lt;P_i records its state&gt;</code> 와 같은 말입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/Chandy_Lamport_Proof2.png" alt=""></p>

<p>만약 <code>ej -&gt; &lt;P_j records its state&gt;</code> 일때 <code>&lt;P_i records its state&gt; -&gt; ei</code> 라 합시다.</p>

<p>그러면 <code>ei -&gt; ej</code> 로 가는 <em>regular app message</em> 경로를 생각해 봤을때, <code>P_i</code> 가 먼저 자신의 상태를 기록하기 시작했으므로 <em>marker</em> 메세지가 먼저 날라갈겁니다. (FIFO) 그러면 위에서 말한 <code>ei -&gt; ej</code> 경로를 타고 <em>marker</em> 메세지가 먼저 가게되고 <code>P_j</code> 는 자신의 상태를 먼저 기록하게 됩니다. 따라서 <code>P_j</code> 에서 <code>ej</code> 보다 자신의 상태를 기록하는 것이 먼저이므로 <code>ej</code> 는 <em>out of cut</em> 이고, 모순입니다.</p>

<p><br></p>

<h3 id="safetyandliveness">Safety and Liveness</h3>

<p>분산시스템의 <em>correctness</em> 와 관련해서 <em>safety</em> 와 <em>liveness</em> 란 개념이 있습니다. 이 둘은 주로 혼동되어 사용되는데, 둘을 구별하는 것은 매우 중요합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/liveness.png" alt=""></p>

<ul>
<li>distributed computation will terminate eventually </li>
<li>every failure is eventually deteced by some non-faulty process</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/safety.png" alt=""></p>

<ul>
<li>there is no deadlock in a distributed transaction system</li>
<li>no object is orphaned</li>
<li><strong>accuracy</strong> in failure detector</li>
<li>no two processes decide on different values</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/liveness_and_safety.png" alt=""></p>

<p><em>failure detector</em> 나 <em>concensus</em> 의 경우에서 볼 수 있듯이 <em>completeness</em> 와 <em>accuracy</em> 두 가지를 모두 충족하긴 힘듭니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/language_of_global_state.png" alt=""></p>

<p><em>global snapshot</em> 은 한 상태 <code>S</code> 이고, 여기서 다른 스냅샷으로의 이동은 <em>casual step</em> 을 따라 이동하는 것입니다. 따라서 <em>liveness</em> 와, <em>safety</em> 와 관련해 다음과 같은 특징이 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week5/using_global_snapshot.png" alt=""></p>

<p><em>Chandy-Lamport</em> 알고리즘은 <em>stable</em> 한지를 검사하기 위해 사용할 수도 있습니다. 여기서 <em>stable</em> 하다는 것은, 한번 참이면 그 이후에는 계속 참인 것을 말합니다. 이는 알고리즘이 <em>casual correctness</em> 를 가지기 때문입니다.</p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://ook.co/solutions/cloud-computing/">Title Image</a> <br>
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></content:encoded></item><item><title><![CDATA[Coding The Matrix 2, Vector Space]]></title><description><![CDATA[<p><img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""></p>

<h3 id="linearcombinations">Linear Combinations</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/linear_combinations.png" alt=""></p>

<p><code>b</code> 와 <code>v1, ..., vn</code> 이 주어졌을때 </p>

<ul>
<li><code>a1, ..., an</code> 을 찾을 수 있을까요? </li>
<li>있다면 <em>unique solution</em> 인지 어떻게 알 수 있을까요?</li>
</ul>

<p><br></p>

<h3 id="span">Span</h3>

<ul>
<li>The set of all linear combinations of some vectors <code>v1, ..., vn</code> is called <strong>span</strong> of these vector</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/span.png" alt=""></p>

<p>이브가 만약 위와 같은식을 만족한다는 사실을 알고 있다면, 패스워드의 모든</p>]]></description><link>http://1ambda.github.io/coding-the-matrix-2/</link><guid isPermaLink="false">5f630834-a38f-4833-a4a3-8d465a1c0b31</guid><category><![CDATA[coursera]]></category><category><![CDATA[linear algebra]]></category><category><![CDATA[vector space]]></category><category><![CDATA[span]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 04 Mar 2015 16:28:24 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://th06.deviantart.net/fs71/PRE/i/2012/348/f/a/3d_cube_by_colorsark-d5nztba.jpg" alt=""></p>

<h3 id="linearcombinations">Linear Combinations</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/linear_combinations.png" alt=""></p>

<p><code>b</code> 와 <code>v1, ..., vn</code> 이 주어졌을때 </p>

<ul>
<li><code>a1, ..., an</code> 을 찾을 수 있을까요? </li>
<li>있다면 <em>unique solution</em> 인지 어떻게 알 수 있을까요?</li>
</ul>

<p><br></p>

<h3 id="span">Span</h3>

<ul>
<li>The set of all linear combinations of some vectors <code>v1, ..., vn</code> is called <strong>span</strong> of these vector</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/span.png" alt=""></p>

<p>이브가 만약 위와 같은식을 만족한다는 사실을 알고 있다면, 패스워드의 모든 <em>span</em> <code>{a1, ..., an}</code> 에 대해서 적절한 <em>response</em> 를 추출할 수 있습니다. 증명은 위처럼 간단합니다.</p>

<p><br></p>

<p>Let <code>V</code> be a set of vectors if <code>v1, ..., vn</code> are vectors such that <code>V</code> = Span <code>{v1, ..., vn}</code> then</p>

<ul>
<li>we say <code>{v1, ..., vn}</code> is a generating set for <code>V</code></li>
<li>we refer to the vectors <code>v1, ..., vn</code> as generators for <code>V</code></li>
</ul>

<p><code>[x, y, z]</code> = <code>x[1,0,0] + y[0,1,0] + z[0,0,1]</code> 을 <code>R^3</code> 의 <em>standard generator</em> 라 부릅니다. </p>

<p><br></p>

<h3 id="geometryofsetsofvectors">Geometry of Sets of Vectors</h3>

<ul>
<li><em>Span of the empty set:</em> just the origin, <strong>Zero-dimensional</strong></li>
<li><em>Span</em> <code>{[1,2], [3,4]}</code>: all points in the plane, <strong>Two-dimensional</strong></li>
<li><em>Span</em> <code>{[1,0,1.65], [0,1,1]}</code> is a plain in three dimensions</li>
</ul>

<p><code>k</code> 벡터의 <em>span</em> 은 <em>k-dimensional</em> 일까요? 아닙니다.</p>

<ul>
<li>Span <code>{[0, 0]}</code> 은 <em>zero-dimensional</em> 입니다.</li>
<li>Span <code>{[1,3], [2,6]}</code> 은 <em>one-dimensional</em> 입니다. </li>
<li>Span <code>{[1,0,0], [0,1,0], [1,1,0]}</code> 은 <em>two-dimensional</em> 입니다.</li>
</ul>

<p>그러면 어떤 벡터 <code>v</code> 가 있을때 <em>dimensionality</em> 를 어떻게 알아낼 수 있을까요?</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/geometry_of_sets.png" alt=""></p>

<p>위 그림에서 볼 수 있듯이 <em>origin</em> 을 포함하는 <em>geometry object</em> 를 표현하는 방법은 두가지 입니다. 각각은 나름의 쓰임새가 있습니다.</p>

<p>(1) <em>span</em> of some vectors <br>
(2) 우변이 <code>0</code> 인 <em>linear equation system</em> 의 집합</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/two_representation1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/two_representation2.png" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/common_representation1.png" alt=""></p>

<p><em>field</em> 의 서브셋은 3가지 속성을 만족합니다. <em>field</em> 를 <code>R</code> 이라 하면</p>

<ul>
<li>subset contains the zero vector</li>
<li>if subset contains <code>v</code> then it contains <code>av</code> for every scala <code>a</code></li>
<li>if subset contains <code>u</code> and <code>v</code> then it contains <code>u+v</code></li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/common_representation2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/common_representation3.png" alt=""></p>

<p><code>F^D</code> 의 세가지 속성을 만족하는 <em>subset</em> 을 <strong>vector space</strong> 라 부릅니다. 그리고 <code>U</code> 가 <em>vector space</em> 고 <em>vector space</em> <code>V</code> 의 <em>subset</em> 일때, <code>U</code> 를 <code>V</code> 의 <em>subspace</em> 라 부릅니다.</p>

<p>뒤에서 배울테지만 모든 <code>R^D</code> 의 <em>subspace</em> 는 <em>span</em> <code>{v1, ..., vn}</code> 과 <code>{x: a1 * x = 0, ..., an * x = 0}</code> 의 형태로 쓸 수 있습니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/abstract_vector_space.png" alt=""></p>

<p>우리는 벡터에 대해 <em>sequence</em> 나, <em>function</em> 을 정의하지 않았습니다. 단순한 <em>operator</em> 와 공리를 만족하는지, 그리고 <em>property</em> <code>V1, V2, V3</code> 정도만 따졌습니다. 벡터에 대한 이런 추상적 접근은 많은 장점이 있습니다. 그러나 이 수업에서는 사용하지 않겠습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/convex_hull.png" alt=""></p>

<p><br></p>

<h3 id="vectorspace">Vector Space</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/exclude_origin_line.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/exclude_origin_plain.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_space.png" alt=""></p>

<p>벡터 <code>c</code> 와 벡터 스페이스 <code>V</code> 에 대해 <code>c + V</code> 와 같은 형태를 <em>affine space</em> 라 부릅니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination.png" alt=""></p>

<p><code>u1, u2, u3</code> 를 담고있는 <em>plain</em> 을 <code>u1 + V</code> 형태로 표현하고 싶습니다. 어떻게 해야할까요?</p>

<p><code>V</code> 를 <em>span</em> <code>{a, b}</code> 라 하고 <code>a = u2 - u1</code>, <code>b = u3 - u1</code> 라 하면 <code>u1 + V</code> 는 <em>plain</em> 의 변환이지만, 그 자체로서 <em>plain</em> 입니다</p>

<ul>
<li><em>span</em> <code>{a, b}</code> 는 <code>0</code> 을 포함하므로 <code>u1</code> + <em>span</em> <code>{a, b}</code> 는 <code>u1</code> 를</li>
<li><em>span</em> <code>{a, b}</code> 는 <code>u2 - u1</code> 도 을 포함하므로 <code>u1</code> + <em>span</em> <code>{a, b}</code> 는 <code>u2</code> 를</li>
<li><em>span</em> <code>{a, b}</code> 는 <code>u3 - u1</code> 도 을 포함하므로 <code>u1</code> + <em>span</em> <code>{a, b}</code> 는  <code>u3</code> 를 포함합니다.</li>
</ul>

<p>따라서 <code>u1</code> + <em>span</em> <code>{a, b}</code> 는 <code>u1, u2, u3</code> 를 모두 포함하는 평면입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination2.png" alt=""></p>

<p>더 간단히 <code>ru1 + au2 + bu3</code> (<code>r + a + b = 1</code>) 로 <em>affine combination</em> 을 표현할 수 있습니다. 그리고 더 <em>formal</em> 하게 정의하면,</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination3.png" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_equation.png" alt=""></p>

<p><em>affine space</em> 를 <em>a solution set of a system of linear equations</em> 으로 표현할 수 있습니다. 그런데, 역으로 이 솔루션이 <em>affine space</em> 일까요?</p>

<p>반례를 하나 들어보면 <code>1x = 1, 2x = 1</code> 일때 솔루션은 없습니다. 그러나 벡터 스페이스 <code>V</code> 는 <em>zero vector</em> 를 가져야 하므로 <em>affine space</em> <code>u + V</code> 는 적어도 하나의 <em>vector</em> 는 가져아합니다. 모순이 발생합니다.</p>

<ul>
<li><strong>Theorem:</strong> <em>solution set of a linear system</em> 은 <em>empty</em> 거나 <em>affine space</em> 입니다. 증명은 아래와 같습니다.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination_proof1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination_proof2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/affine_combination_proof3.png" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/number_of_solutions.png" alt=""></p>

<p>지금까지 증명한 것은, <code>u1</code> 이 <em>linear system</em> 의 솔루션일때, <code>u1 + v</code> (<code>v</code> in <code>V</code>) 도 솔루션이란 사실입니다. 여기서 <code>V</code> 는 <em>homogeneous linear system</em> 입니다. (우변이 <code>0</code> 인)</p>

<p>따라서 </p>

<ul>
<li><em>unique solution</em> 을 가질때는 <code>V</code> 가 <code>0</code> 을 해로 가질 때이고</li>
<li><em>GF(2)</em> 의 솔루션 수는 <code>0</code> 이거나, <code>V</code> 와 같습니다.</li>
</ul>

<p><br></p>

<h3 id="checksumfunction">Checksum function</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/checksum1.png" alt=""></p>

<p><em>corrupted</em> 파일이 올바른 파일로 인식될 경우는 오리지널 바이너리 <code>p</code> 에 대해 손상된 파일 <code>p+e</code> 가 위 슬라이드의 방정식을 만족할 경우입니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/coding-the-matrix/2-vector-space/checksum2.png" alt=""></p>

<p>이 확률은 모든 가능한 <code>n</code> 벡터에 대해 존재하는 솔루션의 수 이므로 굉장히 낮습니다.</p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://colorsark.deviantart.com/art/3D-Cube-342632998">Title image</a> <br>
(2) <strong>Coding the Matrix</strong> by <em>Philip Klein</em>  </p>]]></content:encoded></item><item><title><![CDATA[Pattern Discovery 3]]></title><description><![CDATA[<p><img src="https://m1.behance.net/rendition/modules/7116731/disp/d18c13cd5b49bf40b41e6ef0610b26d3.png" alt=""></p>

<p>이번 시간에 배울 주제는 <em>Sequential Pattern Mining</em> 입니다.</p>

<ul>
<li>GSP (Generalized Sequential Patterns)</li>
<li>Vertical Format-Based Mining: <strong>SPADE</strong></li>
<li>Pattern-Growth Methods: <strong>PrefixSpan</strong></li>
<li>Mining Closed Sequential Patterns: <strong>CloSpan</strong>
Constrain-Based Sequential Pattern Mining</li>
</ul>

<p><em>sequential pattern mining</em> 은 다양한 곳에 사용됩니다.</p>

<ul>
<li>customer shopping sequences</li>
<li>medial treatments</li>
<li>web click streams, calling patterns</li>
<li>program execution sequences (software engineering)</li></ul>]]></description><link>http://1ambda.github.io/pattern-discovery-3/</link><guid isPermaLink="false">9d993973-15d9-4611-bb12-119343656a18</guid><category><![CDATA[coursera]]></category><category><![CDATA[pattern discovery]]></category><category><![CDATA[gSpan]]></category><category><![CDATA[closeGraph]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 03 Mar 2015 16:02:54 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://m1.behance.net/rendition/modules/7116731/disp/d18c13cd5b49bf40b41e6ef0610b26d3.png" alt=""></p>

<p>이번 시간에 배울 주제는 <em>Sequential Pattern Mining</em> 입니다.</p>

<ul>
<li>GSP (Generalized Sequential Patterns)</li>
<li>Vertical Format-Based Mining: <strong>SPADE</strong></li>
<li>Pattern-Growth Methods: <strong>PrefixSpan</strong></li>
<li>Mining Closed Sequential Patterns: <strong>CloSpan</strong>
Constrain-Based Sequential Pattern Mining</li>
</ul>

<p><em>sequential pattern mining</em> 은 다양한 곳에 사용됩니다.</p>

<ul>
<li>customer shopping sequences</li>
<li>medial treatments</li>
<li>web click streams, calling patterns</li>
<li>program execution sequences (software engineering)</li>
<li>biological sequences (DNA)</li>
</ul>

<p><em>time-series DB</em> 와는 다릅니다. 이건 일정 간격으로 로그가 저장된 것이고, <em>sequential pattern</em> 은 <em>time stamp</em> 가 붙은 것이라 보면 됩니다. 어찌 보면 [Process Mining][http://1ambda.github.io/process-mining-week1/] 이라 볼 수도 있겠습니다.</p>

<p><em>sequential pattern</em> 은 크게 <em>gapped</em> 와 <em>non-gapped</em> 로 나누어집니다. 전자는 패턴 사이의 <em>gap</em> 을 허용하고, 후자는 허용하지 않습니다. 모든 시퀀스가 중요하다는 뜻입니다. 예를 들어 웹사이트에서 <em>click stream</em> 사이의 <em>gap</em> 은 정말 중요할 수 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/sequential_pattern_mining.png" alt=""></p>

<p><em>sequential pattern mining</em> 은 주어진 시퀀스에서 빈번한 서브시퀀스의 집합을 찾아냅니다. <em>element</em> (<code>()</code>) 또는 <em>event</em> 라 부르는 단위가 <em>items</em> 를 담고 있습니다. 그리고 <code>()</code> 로 묶인 <em>item</em> 의 순서는 중요하지 않습니다.</p>

<p><br></p>

<h3 id="gsp">GSP</h3>

<p><em>GSP</em> 는 <em>apriori-based sequential pattern mining</em> 기법입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/GSP.png" alt=""></p>

<p><em>singleton</em> 시퀀스를 기반으로 <em>length 1, 2</em> 의 <em>candidates</em> 를 만들고, <em>apriori pruning</em> 을 적용합니다. 그러면, <code>36 + 15 = 51</code> 의 <em>candidates</em> 를 얻을 수 있습니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/GSP2.png" alt=""></p>

<p>데이터베이스를 지속적으로 스캔해가면서 <em>minimum support</em> 를 통과하지 못하는 것들을 제거하고 위 과정을 반복하는 것이 <em>GSP Mining</em> 입니다.</p>

<p><br></p>

<h3 id="spade">SPADE</h3>

<p><em>SPADE (Sequential Pattern Mining in Vertical Data)</em></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/SPADE.png" alt=""></p>

<p><em>SID</em> 뿐만 아니라 <em>element ID, EID</em> 를 이용해서 테이블을 좌측처럼 하나 만듭니다. 그리고 이 테이블을 이용해서 우측 상단 테이블처럼 <code>a</code>, <code>b</code> 등이 어느 <em>SID, EID</em> 셋에서 나타나는지를 파악합니다. 패턴의 길이를 늘려가면서, 즉 테이블을 계속 조인해 나가면 패턴의 <em>support</em> 를 구할 수 있습니다.</p>

<p><br></p>

<h3 id="prefixspan">PrefixSpan</h3>

<p><em>Pattern-Growth</em> 기반의 알고리즘인 <em>PrefixSpan</em> 을 살펴보겠습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/prefix_span1.png" alt=""></p>

<p>먼저 <em>length-1</em> 패턴을 찾고 이를 기반으로 <em>projected DB</em> 를 만들어가며 마이닝을 진행합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/prefix_span2.png" alt=""></p>

<p>단계가 지나면 지날수록 <em>candidate</em> 가 생겨나는 비율이 줄고, <em>projected DB</em> 자체도 줄어든다는 장점이 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/prefix_span3.png" alt=""></p>

<p>다만 <em>projected DB</em> 에서 많은 중복이 발생하기 때문에 이를 해결하기 위해 <em>pseudo projection</em> 을 이용할 수 있습니다. </p>

<p><br></p>

<h3 id="clospan">CloSpan</h3>

<p><em>CloSpan</em> 은 <em>closed sequential pattern</em> 을 마이닝하는 알고리즘입니다.</p>

<p><em>closed pattern</em> 을 다시 복습해 보면</p>

<blockquote>
  <p>closed pattern: A pattern(itemset) <code>X</code> is closed if <code>X</code> is frequent, and there exists no super pattern <code>Y</code> ⊃ <code>X</code>, with the same support as <code>X</code></p>
</blockquote>

<p>예를 들어 <code>&lt;abc&gt;:20, &lt;abcd&gt;:20, &lt;abcde&gt;:15</code> 라면 <code>&lt;abcd&gt;</code> <code>&lt;abcde&gt;</code> 는 <em>closed pattern</em> 입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/clo_span.png" alt=""></p>

<p><em>closed pattern</em> 을 마이닝하는 이유는 이전에도 말했듯이 중복된 패턴을 피하기 위함입니다. 위 그림처럼 <em>redundant search space</em> 를 <em>pruning</em> 할 수 있습니다.</p>

<p><br></p>

<h3 id="constraintbased">Constraint-Based</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/constraint_based_mining.png" alt=""></p>

<ul>
<li><strong>Data anti monotonic:</strong> <code>S</code> 가 제약조건 <code>c</code> 를 위반했을때, 나머지 부분인 <code>s</code> 를 더해도 여전히 위반이라면 <code>s</code> 를 제거할 수 있습니다.</li>
<li><strong>Sunccint:</strong> 제약조건 <code>c</code> 를 기준으로 데이터를 직접 조작합니다. 예를 들어 <code>S</code> 가 <code>{i-phone, MacAir}</code> 를 반드시 포함해야 한다고 할때, 그렇지 못하면 <code>S</code> 를 제거할 수 있습니다</li>
<li><strong>Convertible:</strong> 아이템을 정렬해서 제약조건을 <em>anti-monotonic</em> 이나 <em>monotonic</em> 등으로 바꿉니다. </li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/time_based_constraints.png" alt=""></p>

<ul>
<li><em>order constaint</em> 는 <em>anti-monotonic</em> 입니다</li>
<li><em>min, max gap</em> 제약조건은 <em>succinct</em> 입니다.</li>
<li><em>max span</em> 제약조건은 처음과 마지막 <em>element</em> 의 시간 간격입니다. 이것도 <em>succinct</em> 입니다</li>
<li><em>window size</em> 제약조건은 한 <em>element</em> 내부에서 <em>event</em> 발생 회수를 제한하는 조건입니다.</li>
</ul>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/episode_pattern_mining.png" alt=""></p>

<p>정규표현식과 <em>episode</em> 는 <em>sequential pattern</em> 의 다른 표현 방법입니다.</p>

<p><br></p>

<h3 id="graphpatternmining">Graph Pattern Mining</h3>

<p>이번 시간에 배울 내용은 다음과 같습니다.</p>

<ul>
<li>Apriori-Based Graph Pattern Mining</li>
<li><strong>gSpan:</strong> A Pattern-Growth-Based Method</li>
<li><strong>CloseGraph:</strong> Mining Closed Graph Pattern</li>
<li>Graph Indexing</li>
<li>Top-K Large Structural Patterns in a Massive Network</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/graph_support.png" alt=""></p>

<p><em>Graph</em> 에서 <em>support</em> 란 <em>subgraph</em> 가 나타나는 수 입니다. </p>

<p>그래프 패턴 마이닝을 위해서 다양한 방법을 이용할 수 있습니다.</p>

<p>(1) Generation of candidate subgraphs</p>

<ul>
<li>Apriori (<strong>FSG</strong>) vs Pattern Growth(<strong>gSpan</strong>)</li>
</ul>

<p>(2) Search Order</p>

<ul>
<li>Breadth vs Depth</li>
</ul>

<p>(3) Elimination of duplicate subgraphs</p>

<ul>
<li>Passive vs Active (e.g <strong>gSpan</strong>)</li>
</ul>

<p>(4) Support calculation</p>

<ul>
<li>Store embeddings (e.g <strong>GASTON, FFSM, MoFA</strong>)</li>
</ul>

<p>(5) Order of Pattern Discovery</p>

<ul>
<li>Path -> Tree -> Graph (<strong>GASTON</strong>)</li>
</ul>

<p><br></p>

<h3 id="aprioribasedapproach">Apriori-Based Approach</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/apriori_based_approache.png" alt=""></p>

<p><em>Apriori Property</em> 에 의해서, 어떤 그래프가 <code>G</code> 가 빈번한 경우는, <em>*모든 *</em>서브그래프들도 빈번할 경우뿐입니다. </p>

<p>따라서 <code>k</code> 개의 <em>edge, vertex</em> 를 가진 <em>frequent</em> 서브그래프에서 공통된 엣지가 많은 그래프를 골라 <code>k+1</code> 개의 <em>edge, vertex</em> 그래프를 만듭니다. 그리고 여기서 이 그래프의 <strong>모든 서브 그래프가</strong> <em>frequent</em> 한지 검사하여 <em>pruning</em> 을 진행할 수 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/vertex_edge_growing.png" alt=""></p>

<p><em>vertex</em> 기반으로 확장해 나가는 알고리즘으로 <em>AGM (Apriori-based Graph Mining)</em> 이 있습니다. <em>edge</em> 를 확장해 나가는 알고리즘으로는 <em>FSG (Frequent Sub Graphs)</em> 가 있는데, 일반적으로 더 작은 컴포넌트인 <em>edge</em> 를 확장시켜 나가는 방법이 더 효율적이라고 알려져 있습니다.</p>

<p><br></p>

<h3 id="gspanapatterngrowthapproach">gSpan: A Pattern Growth Approach</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/pattern_growth_approach_gSpan.png" alt=""></p>

<p>먼저 <code>k</code>-<em>edge</em> 그래프를 보고, 여기에 하나의 <em>edge</em> 를 더해 <code>k+1</code> <em>edge</em> 그래프도 빈번하다면 이 과정을 계속 반복해 나아갑니다. 이 방법은 많은 수의 <em>subgraph</em> 가 중복된다는 단점이 있습니다. </p>

<p>이 문제를 해결하기 위해 <em>gSpan</em> 에서는 생성할 <em>subgraph</em> 의 순서를 미리 정의해 놓고 <em>depth-first search</em> 를 이용해서 <em>graph</em> 를 <em>sequence</em> 처럼 펼칩니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/gspan_example.png" alt=""></p>

<p>위 그림에서는 가장 작은 인덱스를 먼저 선택하는 <em>DFS</em> 를 이용해서 우측처럼 시퀀스를 만들었습니다. </p>

<p><br></p>

<h3 id="closegraph">CloseGraph</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/closed_graph.png" alt=""></p>

<p><code>n</code> 개의 <em>edge</em> 를 가진 그래프에는 <code>2^n</code> 개의 서브그래프가 존재합니다. 정말 어마어마한 숫자입니다. 이런 <em>explosion</em> 문제를 해결하기 위해 <em>closed frequent subgraph</em> 를 이용합니다.</p>

<ul>
<li>A frequent graph <code>G</code> is <strong>closed</strong> if there exists no supergraph of <code>G</code> that carries the same support as <code>G</code>'</li>
</ul>

<p><em>loseless compression</em> 이기 때문에 결과는 <em>complete</em> 합니다. 따라서 <em>closed graph pattern</em> 을 마이닝 하면 좀 더 효율적입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/close_graph_algorithm.png" alt=""></p>

<p><code>G</code> 가 있을 때마다 <code>G1</code> 이 존재한다면 다른 <em>supergraph</em> 를 살펴볼 필요가 없습니다. 이는 <code>G1</code> 이 <code>G</code> 를 커버할 수 있기 때문입니다. 아래는 다른 알고리즘과의 성능 비교입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/close_graph_performance.png" alt=""></p>

<p><br></p>

<h3 id="graphindex">Graph Index</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/graph_indexing.png" alt=""></p>

<p>그림에서 볼 수 있듯이 <em>path index</em> 는 <code>(a)</code> <code>(b)</code> 를 쿼리 <code>Q</code> 에 대해 필터링 하지 못할 수 있습니다. 따라서 그래프를 직접 인덱싱하는 것이 필요한데, 문제는 그래프를 인덱싱할때 서브그래프가 너무 많다는 것입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/gIndex.png" alt=""></p>

<p>따라서 <em>frequent substructure</em> 만 인덱스 하되, <em>size-increasing support threshold</em> 를 이용하면 됩니다. 즉 사이즈가 증가할수록 <em>min support</em> 도 올리는 것인데, 이는 큰 그래프일수록 작은 그래프에서 이미 <em>indexed</em> 되었을 수 있기 때문입니다.</p>

<p>그리고 <em>discriminative substructure</em> 를 인덱싱해야합니다. 이는 기존과 비슷한 그래프를 인덱싱 할 필요는 없기 때문이지요. <em>discriminative</em> 그래프를 선택하기 위해서 슬라이드처럼 새로운 그래프 <code>x</code> 가 기존의 인덱싱된 그래프 <code>f1, f2, ...,</code> 을 얼마나 커버하는지를 계산하여 작으면 인덱싱합니다.</p>

<p><br></p>

<h3 id="spidermine">Spider Mine</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/spider_mine1.png" alt=""></p>

<p><em>pattern fusion</em> 과 비슷하게, 작은 컴포넌트인 <em>spider</em> 가 모여 결국에는 큰 컴포넌트를 만든다는 기본적인 아이디어로부터 시작합니다.</p>

<p><em>r-Spider</em> 는 <em>vertex</em> <code>u</code> 로부터 <code>r</code> 홉 안에 도달할 수 있는 <em>frequent</em> 패턴입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/spider_mine2.png" alt=""></p>

<p>알고리즘이 수행되는 동안 <em>spider mine</em> 알고리즘은 <em>large pattern</em> 을 유지하고 <em>small pattern</em> 을 <em>pruning</em> 합니다. 그 이유는 작은 패턴일수록 <em>random draw</em> 에서 <em>hit</em> 할 확률이 낮고, 했다 하더라도 여러번 <em>hit</em> 할 확률은 더 낮기 때문입니다. </p>

<p><br></p>

<h3 id="patternbasedclassification">Pattern-Based Classification</h3>

<p>이번 챕터에서 배울 내용은 다음과 같습니다.</p>

<ul>
<li>Pattern-Based Classification</li>
<li>Associative Classification</li>
<li>Discriminative Pattern-Based Classification</li>
<li>Direct Mining of Discriminative Patterns</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/pattern_based_why.png" alt=""></p>

<p><em>frequent pattern mining</em> 과 <em>classification</em> 을 조합하면 더 심도있고, 다양한 데이터에 대한 분석이 가능합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/pattern_based_example.png" alt=""></p>

<p><br></p>

<h3 id="associativeclassificationcbacmar">Associative Classification: CBA, CMAR</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/classification_CBA.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/CMAR.png" alt=""></p>

<p><br></p>

<h3 id="discriminativeclassification">Discriminative Classification</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/discriminative1.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/discriminative2.png" alt=""></p>

<p>당연한 이야기지만 <em>single item</em> 보다는 <code>k</code> 개의 아이템셋이 더 많은 <em>information gain</em> 을 만듭니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/discriminative3.png" alt=""></p>

<p>그리고 위 슬라이드에서 볼 수 있듯이, <em>frequent, but not too frequent</em>  한 패턴이 <em>discriminative</em> 하게 적용됨을 알 수 있습니다. (<em>info gain</em> 이 더 많다는 뜻)</p>

<p><br></p>

<h3 id="ddpmine">DDP Mine</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/DDPMine1.png" alt=""></p>

<p><em>frequent pattern mining</em> 후에 <em>discriminative pattern</em> 을 얻는 것은 계산적으로 비쌉니다. 따라서 바로 <em>discriminative pattern</em> 을 얻을 수 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/DDPMine2.png" alt=""></p>

<p>알고리즘은 이렇습니다. 매 이터레이션마다 가장 <em>discriminative power</em> 가 큰 <em>feature</em> <code>f</code> 를 고르고, <code>D</code> 에서 <code>f</code> 에 의해 커버 되는 인스턴스 <code>D</code> 를 제거합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week3/DDPMine3.png" alt=""></p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="https://www.behance.net/gallery/625042/Icon-and-pattern-with-a-marketing-theme">Title image</a> <br>
(2) <strong>Pattern Discovery</strong> by <em>Jiawei Han</em> </p>]]></content:encoded></item><item><title><![CDATA[Articles]]></title><description><![CDATA[<h3 id="scala">Scala</h3>

<p><strong>Scalaz</strong></p>

<ul>
<li><a href="http://1ambda.github.io/easy-scalaz-1-state-and-state/">Easy Scalaz 1, State</a></li>
<li>[Easy Scalaz 2, Monad Transformer]</li>
<li>[Easy Scalaz 3, IO]</li>
<li>[Easy Scalaz 4, Validation]</li>
<li>[Easy Scalaz 5, Free]</li>
<li>[Easy Scalaz 6, Trampoline]</li>
<li>[Easy Scalaz 7, Task] </li>
</ul>

<p><strong>Monocle</strong></p>

<p><a href="http://1ambda.github.io/scala-monocle-tutorial/">Scala Lens Library, Monocle</a></p>

<p><strong>Functional Programming in Scala</strong> by <em>Martin Odersky</em></p>

<p><a href="http://1ambda.github.io/functional-programming-in-scala-chapter-1/">Chapter 1</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-2/">Chapter 2</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-3/">Chapter 3</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-4/">Chapter</a></p>]]></description><link>http://1ambda.github.io/articles/</link><guid isPermaLink="false">9666f26e-e434-403f-95b1-8e667199693c</guid><category><![CDATA[1ambda]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 28 Feb 2015 16:50:51 GMT</pubDate><content:encoded><![CDATA[<h3 id="scala">Scala</h3>

<p><strong>Scalaz</strong></p>

<ul>
<li><a href="http://1ambda.github.io/easy-scalaz-1-state-and-state/">Easy Scalaz 1, State</a></li>
<li>[Easy Scalaz 2, Monad Transformer]</li>
<li>[Easy Scalaz 3, IO]</li>
<li>[Easy Scalaz 4, Validation]</li>
<li>[Easy Scalaz 5, Free]</li>
<li>[Easy Scalaz 6, Trampoline]</li>
<li>[Easy Scalaz 7, Task] </li>
</ul>

<p><strong>Monocle</strong></p>

<p><a href="http://1ambda.github.io/scala-monocle-tutorial/">Scala Lens Library, Monocle</a></p>

<p><strong>Functional Programming in Scala</strong> by <em>Martin Odersky</em></p>

<p><a href="http://1ambda.github.io/functional-programming-in-scala-chapter-1/">Chapter 1</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-2/">Chapter 2</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-3/">Chapter 3</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-4/">Chapter 4</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-5/">Chapter 5</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-6/">Chapter 6</a> <br>
<a href="http://1ambda.github.io/functional-programming-in-scala-chapter-7/">Chapter 7</a>  </p>

<p><strong>Reactive Programming</strong> by <em>Martin Odersky</em></p>

<p><a href="http://1ambda.github.io/reactive-programming-1/">Chapter 1</a> - Monads, Random Generators <br>
<a href="http://1ambda.github.io/reactive-programming-2/">Chapter 2</a> - Stateful Object <br>
<a href="http://1ambda.github.io/reactive-programming-3/">Chapter 3</a> - Try, Future, Promise <br>
<a href="http://1ambda.github.io/reactive-programming-4/">Chapter 4</a> - Observable, Rx, Scheduler <br>
<a href="http://1ambda.github.io/reactive-programming-5/">Chapter 5</a> - Actor   </p>

<p><strong>Articles</strong></p>

<p><a href="http://1ambda.github.io/new-to-play-framework-2/">new to Play Framework2</a> <br>
<a href="http://1ambda.github.io/partial-functions-scala/">Partial Functions, Scala</a>  </p>

<h3 id="haskell">Haskell</h3>

<p><strong>Introduction to Functional Programming using Haskell</strong></p>

<p><a href="http://1ambda.github.io/haskell-intro1">Chapter 1</a> - Basics <br>
<a href="http://1ambda.github.io/haskell-intro2">Chapter 2</a> - List Comprehension <br>
<a href="http://1ambda.github.io/haskell-intro3">Chapter 3</a> - Recursion, Higher Order Function <br>
<a href="http://1ambda.github.io/haskell-intro4">Chapter 4</a> - Monad <br>
<a href="http://1ambda.github.io/haskell-intro5">Chapter 5</a> - IO Monad <br>
<a href="http://1ambda.github.io/haskell-intro6">Chapter 6</a> - Type and Class <br>
<a href="http://1ambda.github.io/haskell-intro7">Chapter 7</a> - The Countdown Problem <br>
<a href="http://1ambda.github.io/haskell-intro8">Chapter 8</a> - Lazy Evaluation, Strict <br>
<a href="http://1ambda.github.io/haskell-intro9">Chapter 9</a> - Induction <br>
<a href="http://1ambda.github.io/a-poor-mans-concurrency-monad">Poor Man's Concurrency Monad</a></p>

<h3 id="machinelearning">Machine Learning</h3>

<p><strong>Machine Learning</strong> by <em>Andrew Ng</em>, Coursera</p>

<p><a href="http://1ambda.github.io/machine-learning-week-1/">Chapter 1</a> - Linear Regression <br>
<a href="http://1ambda.github.io/machine-learning-week-2/">Chapter 2</a> - Gradient Descent <br>
<a href="http://1ambda.github.io/machine-learning-week-3/">Chapter 3</a> - Logistic Regression <br>
<a href="http://1ambda.github.io/machine-learning-week-4/">Chapter 4</a> - Neural Network <br>
<a href="http://1ambda.github.io/machine-learning-week-5/">Chapter 5</a> - Back Propagation <br>
<a href="http://1ambda.github.io/machine-learning-week-6/">Chapter 6</a> - Practical Advices <br>
<a href="http://1ambda.github.io/machine-learning-week-7/">Chapter 7</a> - Support Vector Machine <br>
<a href="http://1ambda.github.io/machine-learning-week-8/">Chapter 8</a> - K-means, PCA Details <br>
<a href="http://1ambda.github.io/machine-learning-week-9/">Chapter 9</a> - Anomaly Detection, Recommender System <br>
<a href="http://1ambda.github.io/machine-learning-week-10/">Chapter 10</a> - Stochastic Gradient, Synthetic Data, Ceiling Analysis  </p>

<h3 id="algorithm">Algorithm</h3>

<p><strong>Algorithm: Design and Analysis Part 1</strong> by <em>Tim Roughgarden</em></p>

<p>(1) <a href="http://1ambda.github.io/divide-and-conquer/">Divide and Conquer</a> <br>
(2) <a href="http://1ambda.github.io/randomized-selection/">Randomized Selection</a> <br>
(3) <a href="http://1ambda.github.io/graphs-the-contraction-algorithm/">Graphs, The Contraction Algorithm</a> <br>
(4) <a href="http://1ambda.github.io/graph-search-and-connectivity/">Graph Search and Connectivity</a> <br>
(5) <a href="http://1ambda.github.io/dijkstra-heap-balanced-tree/">Dijkstra, Heap, Red-Black Tree</a> <br>
(6) <a href="http://1ambda.github.io/hash-table-universal-hashing-bloom-filters/">Hash Table, Universal Hashing, Bloom filters</a>  </p>

<p><strong>Algorithms, Part 1</strong> by <em>Robert Sedgewick</em></p>

<p>(1) <a href="http://1ambda.github.io/union-find-algorithms-week-1/">Union Find</a> <br>
(2) <a href="http://1ambda.github.io/analysis-of-algorithms/">Analysis of Algorithms</a> </p>

<p><strong>Algorithms, Part 2</strong> by <em>Robert Sedgewick</em></p>

<p>(1) <a href="http://1ambda.github.io/graph-challenges-minimum-spanning-trees">Spanning Tree, Shortest Paths</a> <br>
(2) <a href="http://1ambda.github.io/radix-sort-suffix-sort">Radix Sort, Suffix Sort</a> <br>
(3) <a href="http://1ambda.github.io/r-way-ternary-search-tries/">R-way, Ternary Tries</a> <br>
(4) <a href="http://1ambda.github.io/substring-search/">KMP, Boyer-Moore, Rabin-Karp</a> <br>
(5) <a href="http://1ambda.github.io/maximum-flow/">Maximum Flow (Ford-Fulkerson)</a> <br>
(6) <a href="http://1ambda.github.io/algorithm-data-compression/">Data Compression, Huffman, LZW</a>   </p>

<h3 id="artificialintelligence">Artificial Intelligence</h3>

<p><strong>Artificial Intelligence (CS188)</strong> by <em>Dan Klein, Pieter Abbeel</em></p>

<p>(1) <a href="http://1ambda.github.io/artificial-intelligence-1">Intro</a> <br>
(2) <a href="http://1ambda.github.io/artificial-intelligence-2">Search</a>  </p>

<p><strong>Artificial Intelligence Planning</strong> by <em>Dr.Gerhard Wickler</em>, <em>Prof. Austin Tate</em></p>

<p>(1) <a href="http://1ambda.github.io/ai-planning-1">Intro</a> <br>
(2) <a href="http://1ambda.github.io/ai-planning-2">A*, STRIPS, forward and backward search</a> <br>
(3) <a href="http://1ambda.github.io/ai-planning-3">PSP, PoP</a> <br>
(4) <a href="http://1ambda.github.io/ai-planning-4">STN, HTN</a>  </p>

<h3 id="cloudcomputing">Cloud Computing</h3>

<p><strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera</p>

<p>(1) <a href="http://1ambda.github.io/cloud-computing-1-1/">MapReduce</a> <br>
(2) <a href="http://1ambda.github.io/cloud-computing-gossip-protocol/">Gossip Protocol</a> <br>
(3) <a href="http://1ambda.github.io/cloud-computing-membership-protocol/">Membership Protocol</a> <br>
(4) <a href="http://1ambda.github.io/cloud-computing-p2p-systems/">P2P Systems</a> <br>
(4) <a href="http://1ambda.github.io/cloud-computing-snapshot/">Global Snapshot</a> <br>
(4) <a href="http://1ambda.github.io/cloud-computing-multicast/">Multicast</a> <br>
(4) <a href="http://1ambda.github.io/cloud-computing-paxos/">Paxos</a>  </p>

<h3 id="dataanalysis">Data Analysis</h3>

<p><strong>Pattern Discovery</strong> by <em>Jiawei Han</em>, Coursera</p>

<p><a href="http://1ambda.github.io/pattern-discovery-1/">Chapter 1</a> - Apriori, FP Growth <br>
<a href="http://1ambda.github.io/pattern-discovery-2/">Chapter 2</a> - Null-invariant, Pattern-Fusion, Constaint   </p>

<p><strong>Intro to Computational Thinking and Data Science</strong>, edx</p>

<p><a href="http://1ambda.github.io/edx-600-2x-1/">Chapter 1</a> - Modeling <br>
<a href="http://1ambda.github.io/edx-600-2x-2/">Chapter 2</a> - Monte Carlo Simulation <br>
<a href="http://1ambda.github.io/edx-600-2x-3/">Chapter 3</a> - Optimization Problem <br>
<a href="http://1ambda.github.io/edx-600-2x-4/">Chapter 4</a> - State Modeling, Hierarchical Clustering   </p>

<p><strong>Coding The Matrix</strong> by <em>Philip Klein</em>, Coursera</p>

<p><a href="http://1ambda.github.io/coding-the-matrix-1/">Chapter 1</a> - Function, Field, Vector <br>
<a href="http://1ambda.github.io/coding-the-matrix-w/">Chapter 2</a> - Vector Space <br>
<a href="http://1ambda.github.io/coding-the-matrix-e/">Chapter 3</a> - Matrix  </p>

<h3 id="processmining">Process Mining</h3>

<p><strong>Process Mining</strong> by <em>Wil Van der Alast</em>, Coursera</p>

<p><a href="http://1ambda.github.io/process-mining-week1/">Week 1</a> - Process Mining Intro <br>
<a href="http://1ambda.github.io/process-mining-week2/">Week 2</a> - Alpha Algorithm <br>
<a href="http://1ambda.github.io/process-mining-week3/">Week 3</a> - Metric, C-nets <br>
<a href="http://1ambda.github.io/process-mining-week4/">Week 4</a> - Conformance Checking, Dotted Chart <br>
<a href="http://1ambda.github.io/process-mining-week5/">Week 5</a> - Decision, Social, Organization Mining  </p>

<h3 id="java">Java</h3>

<p><strong>Articles</strong></p>

<p><a href="http://1ambda.github.io/java-interview-questions-collection-framework/">Java Interview Questions - Collection Framework</a>  </p>

<h3 id="javascript">Javascript</h3>

<p><a href="http://1ambda.github.io/javascript-object-inheritance/">Javascript Inheritance Details</a> <br>
<a href="http://1ambda.github.io/angular-providers/">Angular, Providers</a>  </p>]]></content:encoded></item><item><title><![CDATA[Cloud Computing, P2P Systems]]></title><description><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>P2P 시스템의 기술들은 <em>cloud computing</em> 의 많은 분야에서 활용됩니다. 뒤에서 배울 <em>Chord P2P hashing</em> 같은 경우는 <em>Cassandra</em>, <em>Voldmort</em> 등의 <em>key-value store</em> 에서 쓰이고 있습니다. </p>

<p><br></p>

<h3 id="napster">Napster</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/napster.png" alt=""></p>

<p>최초에 <em>peer</em> 는 서버에게 메세지를 보내 P2P 시스템에 가입했다는 사실을 알립니다.</p>

<p><em>Napster</em> 에서는 중앙에 서버를 두어, 파일이 저장된 <em>peer</em> 를 기록합니다. 각 <em>peer</em> 는 파일이</p>]]></description><link>http://1ambda.github.io/cloud-computing-p2p-systems/</link><guid isPermaLink="false">6e527ab7-0598-4177-b199-dd4ef466f537</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[P2P]]></category><category><![CDATA[Napster]]></category><category><![CDATA[Gnutella]]></category><category><![CDATA[BitTorrent]]></category><category><![CDATA[FastTrack]]></category><category><![CDATA[Chord]]></category><category><![CDATA[Pastry]]></category><category><![CDATA[Kelips]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 28 Feb 2015 16:18:25 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>P2P 시스템의 기술들은 <em>cloud computing</em> 의 많은 분야에서 활용됩니다. 뒤에서 배울 <em>Chord P2P hashing</em> 같은 경우는 <em>Cassandra</em>, <em>Voldmort</em> 등의 <em>key-value store</em> 에서 쓰이고 있습니다. </p>

<p><br></p>

<h3 id="napster">Napster</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/napster.png" alt=""></p>

<p>최초에 <em>peer</em> 는 서버에게 메세지를 보내 P2P 시스템에 가입했다는 사실을 알립니다.</p>

<p><em>Napster</em> 에서는 중앙에 서버를 두어, 파일이 저장된 <em>peer</em> 를 기록합니다. 각 <em>peer</em> 는 파일이 어디있는지 검색하기 위해 중앙 서버에 질의해야 합니다. 그림에서 볼 수 있듯이, 각 파일은 서버가 아니라 <strong>클라이언트</strong> 에 저장되어 있습니다. 파일이 어느 클라이언트(<em>peer</em>) 에 저장되어있는지 알게되면, <em>ping</em> 을 날려 살아있는지 확인 후 파일을 다운 받습니다. </p>

<p><em>Napster</em> 의 문제점은</p>

<ul>
<li>중앙 서버로의 요청이 너무나 많습니다.</li>
<li><p>서버가 다운되면, 시스템이 멈춥니다.</p>

<p><br></p></li>
</ul>

<h3 id="gnutella">Gnutella</h3>

<p><em>Gnutella</em> 는 <em>Napster</em> 시스템에서 <strong>서버</strong>를 제거했습니다. 각 클라이언트 (<em>peer</em>) 는 파일이 어디 저장되어있는지 파악하기 위해 서로 통신하지요. 이처럼 클라이언트가 서버처럼 행동하기때문에 <em>servent</em> 라 부르기도 합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella.png" alt=""></p>

<p>위 슬라이드에서 알 수 있듯이, 각 피어는 근처에 있는 피어로의 링크를 가지고 있습니다. 이 링크는 <em>overlay graph</em> 라 부르기도 합니다.</p>

<p><em>gnutella</em> 에서 피어간 통신에 사용되는 주요 메세지 타입은</p>

<ul>
<li><strong>Query:</strong> search</li>
<li><strong>QueryHit:</strong> reponse to query</li>
<li><strong>Ping:</strong> to probe network for other peers</li>
<li><strong>Pong:</strong> reply to ping, contains address of another peer</li>
<li><strong>Push:</strong> used to initiate file transfer</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella_header.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella_search_ttl.png" alt=""></p>

<p>위 그림에서 <code>TTL = 2</code> 이기 때문에 <em>query</em> 메세지는 <em>2-hop</em> 까지만 전파됩니다. 그리고 <em>gnutella</em> 에서는 각 피어가 최근에 퍼트린 <em>query</em> 메세지 리스트를 유지하고 있기 때문에 같은 메세지를 다시 전파하지 않습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella_queryhit_msg.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/gnutella_queryhit_msg_ex.png" alt=""></p>

<p>피어가 보낸 <em>query</em> 에 대해 해당하는 파일을 가지고 있다는 응답은 <em>query hit</em> 메세지를 통해 전달됩니다.</p>

<p><em>gnutella</em> 에서는 과도한 트래픽을 방지하기 위해 다음의 방법을 사용합니다.</p>

<ul>
<li>to avoid duplicate transmissions, each peer maintains a list of recently received messages</li>
<li>query forwarded to all neighbors except peer from which received</li>
<li>each query (identified by <code>DescriptorID</code>) forwarded only once</li>
<li><em>QueryHit</em> routed back only to peer from which <em>Query</em> received with same <code>DescriptorID</code></li>
<li>for flooded messages, duplicates with same <code>DescriptorID</code> and <em>Payload descriptor</em> are dropped</li>
<li><em>QueryHit</em> with <code>DescriptorID</code> for which <em>Query</em> not seen is dropped</li>
</ul>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/after_receiving_queryhit.png" alt=""></p>

<p><em>QueryHit</em> 메세지를 <em>requestor</em> 가 받으면 최적의 <em>responder</em> 를 고르고,  <strong>HTTP</strong> 를 이용해서 몇번의 통신을 한 뒤 파일을 전송받습니다. 여기서 <em>gnutella</em> 가 <em>HTTP</em> 를 이용하는 이유는, HTTP 가 <em>standard</em>, <em>well-debugged</em>, <em>widely used</em> 이기 때문입니다.</p>

<p>그런데 만약, <em>responder</em> 가 방화벽(<em>firewall</em>) 뒤에 있으면 어떻게 될까요? 일반적으로 방화벽은 <em>incomming message</em> 를 필터링 합니다. <em>gnutella</em> 는 이럴 경우 대비해 <em>push</em> 를 만들어 놓았습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/dealing_with_firewalls.png" alt=""></p>

<p><em>query hit</em> 메세지를 받은 후에 <em>requestor</em> 가 보내는 <em>HTTP</em> 메세지에 <em>responder</em> 가 응답하지 않으면 <em>overlay link</em> (이미 연결되어있는) 을 통해서 <em>push</em> 메세지를 <em>requestor</em> 가 보냅니다. <em>responder</em> 는 방화벽 뒤에 있어도, <em>overlay link</em> 를 통해 받은 <em>push</em> 메세지를 확인하고 파일 전송을 시작합니다.</p>

<p>만약 <em>requestor</em> 가 방화벽 뒤에 있다면, <em>gnutella</em> 프로토콜로는 파일을 전송 받을 수 없습니다.</p>

<p><br></p>

<p><em>gnutella</em> 에서 생기는 문제점은 </p>

<ul>
<li><em>ping/pong</em> constituted 50% traffic: use multiplex, cache and reduce freq of <em>ping/pong</em></li>
<li>modem-conncted hosts do not have enough bandwidth for passing gnutella traffic: use a central server to act as proxy for such peers. or use <strong>FastTrack System</strong></li>
<li>large number of <em>free loaders</em></li>
<li>flooding causes excessive traffic: use <strong>Structured P2P system</strong> e.g <strong>Chord System</strong></li>
</ul>

<p><br></p>

<h3 id="fasttrac">FastTrac</h3>

<p><em>FastTrac</em> 은 <em>Kazza</em>, <em>KazzaLite</em>, <em>Grokster</em> 라는 기술을 기반으로 한 <em>Napster</em> <em>Gnutella</em> 의 하이브리드입니다. </p>

<p><em>healthier participants</em> 를 이용하겠다는 기본적인 아이디어로부터 출발했습니다. <em>gnutella</em> 와 비슷하지만 노드중 일부가 <em>supernode</em> 가 되어, 특별한 역할을 수행합니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/fast_trac.jpg" alt=""></p>

<ul>
<li><em>supernode</em>는 <em>Napster server</em> 와 비슷하게 근처에 있는 노드의 <code>&lt;file name, peer point&gt;</code> 리스트를 저장합니다</li>
<li><em>supernode</em> 의 멤버십은 시간이 지나면서 변합니다</li>
<li>어떤 노드도 <em>supernode</em> 가 될 수 있습니다. 그러기 위해서는 <em>reputation</em> 을 얻어야 합니다</li>
<li>각 노드는 데이터를 탐색하기 위해 <em>supernode</em> 에 질의합니다</li>
</ul>

<p>이 <em>reputation system</em> 은 <em>Kazaalite</em> 처럼 <em>upload</em> 한 파일의 양으로 결정할 수도 있고, 경제학적인 원리를 적용한 방법도 있습니다</p>

<p><br></p>

<h3 id="bittorrent">BitTorrent</h3>

<p>이전에 언급했듯이 <strong>다운만 받는 peer</strong> 도 존재할 수 있습니다. <em>BitTorrent</em> 는 업로드 하는 <em>peer</em> 에게 보상을 해 주어, <em>peer</em> 들의 업로드를 더 이끌어 낼 수 있습니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/bit_torrent_network.jpg" alt=""></p>

<p><em>BitTorrent</em> 네트워크 구성은 위 슬라이드와 같습니다.</p>

<ul>
<li><strong>Tracker:</strong> 파일당 하나씩 존재하며 <em>heartbeat</em> 를 받아 <em>peer</em> 의 <em>join</em>, <em>leave</em> 를 관리합니다.</li>
<li><strong>Seed:</strong> 전체 파일을 가지고 있는 <em>peer</em> </li>
<li><strong>Leecher:</strong> 파일의 일부분을 가지고 있는 <em>peer</em> </li>
</ul>

<p><em>BitTorrent</em> 에서는 블럭단위로 파일을 전송하는데, 이 때 사용하는 몇 가지 규칙이 있습니다.</p>

<ul>
<li><em>Local Rarest First:</em> 파일을 다운받을때, 귀한 블럭부터 먼저 받습니다</li>
<li><em>Tit for tat:</em> 업로드 하는 만큼, 다운로드 <em>bandwidth</em> 를 할당받습니다. 다시 말해서 업로드를 많이해야 빠르게 받을 수 있습니다</li>
<li><em>Choking:</em> 동시에 업로드하는 <em>neighbor</em> 수를 제한해서 <em>bandwidth</em> 가 너무 많이 사용되지 않도록 합니다. <em>best neighbor</em> 를 선택하여 <em>unchoked set</em> 을 유지하고, 주기적으로 이 집합을 재평가합니다. 이외의 다른 <em>peer</em> 는 <em>choked set</em> 입니다. </li>
</ul>

<p><em>optimistic unchoke</em> 기법은 주기적으로 랜덤한 <em>neighbor</em> 를 <em>unchoke</em> 해서, <em>unchoked set</em> 을 <em>fresh</em> 하게 유지합니다. 여기서 <em>random choice choking</em> 을 쓰는 이유는</p>

<ul>
<li>To avoid the sysem from getting stuck where only a few peers receive service</li>
</ul>

<p><br></p>

<h3 id="dht">DHT</h3>

<p>지금까지 본 <em>Napster</em>, <em>Gnutella</em>, <em>FastTrac</em> 은 일종의 <em>DHT, Distribute Hash Table</em> 입니다.</p>

<p><em>DHT</em> 에서의 <em>performance concerns</em> 는</p>

<ul>
<li>load balancing</li>
<li>fault-tolerance</li>
<li>efficiency of lookup and inserts</li>
<li>locality</li>
</ul>

<p>우리가 배울 <em>Chord</em> 는 이런 구조가 적용된 <em>structured peer to peer system</em> 입니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/performance_comparison_nap_gnu.jpg" alt=""></p>

<p><em>Napster</em> 는 <em>peer</em> 의 경우 파일을 저장하지 않기 때문에 메모리가 많이 들지 않지만, <em>server</em> 에서 많은 메모리를 요구합니다. 서버로 질의가 가기때문에 <em>lookup latency</em> 나 <em>lookup</em> 을 위한 메세지 수 자체는 많지 않지만, 서버의 부하가 상당히 심할 수 있습니다.</p>

<p>반면 <em>Gnutella</em> 에서는 서버가 없습니다. 그렇기 때문에 피어는 파일이 저장되어있는 주변 피어의 목록을 가지고 있어야 하는데, <code>N</code> 만큼의 이웃이 주변에 있을 수 있습니다. 따라서 한 피어에서 필요한 메모리 양은 <code>O(N)</code> 입니다.</p>

<p>그리고 네트워크가 직선으로 구성되어 있다고 할때, <em>lookup latency</em> 는 <code>O(N)</code> (<code>N-1</code>) 이고 룩업을 위한 메세지 수도 <code>O(N)</code> (<code>2(N-1)</code>) 입니다.</p>

<p>반면 <em>Chord</em> 는 모두 <code>O(log N)</code> 입니다. 이론적으로 <em>constant</em> 는 아니지만, <em>real world</em> 에서는 상당히 낮은 수가 될 수 있습니다.</p>

<p><br></p>

<h3 id="chord">Chord</h3>

<p><em>Chord</em> 는 <em>Berkeley</em> 와 <em>MIT</em> 에서 개발된 <em>P2P</em> 프로토콜입니다.<em>latency</em> 와 <em>message cost of routing</em> (<em>lookups</em>/<em>inserts</em>) 를 줄이기 위해 지능적으로 <em>neighbor</em> 를 선택하고 <em>Consistent Hashing</em> 기법을 사용합니다.</p>

<p><em>Consistent Hasing</em> 값은 <em>peer</em> 에 부여되는 주소값으로</p>

<ul>
<li>IP 와 Port로 <em>SHA1</em> 로 해싱해서 160 비트 스트링을 만들고 </li>
<li><code>m</code> 비트로 절단해서 사용합니다</li>
<li><em>peer</em> 의 <em>ID</em> 라 불리기도 하는데, 이 값은 당연히 최대 <code>2^m - 1</code> 입니다</li>
<li>해싱값이므로 <em>unique</em> 하진 않지만 충돌이 일어날 확률은 굉장히 적습니다</li>
<li>그리고 이 값이 <code>2^m</code> 개의 점이 되어 하나의 원을 구성합니다</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/ring_of_peers.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_finger_table.png" alt=""></p>

<p>각 노드는 (반) 시계방향으로의 <em>successor</em> 를 가지고 있고, 다른 노드를 가리키기 위한 <em>finger table</em> 을 가지고 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_file_saving.png" alt=""></p>

<p>파일도 마찬가지로 <em>SHA-1</em> 으로 해싱해서, 160 비트로 짜른 뒤 <code>mod 2^m</code> 연산해서, 같은 값이거나 그보다 큰 값을 가지는 <em>peer</em> 에 저장합니다.</p>

<p>만약 균일하게 해싱된다면 <code>K</code> 개의 키, <code>N</code> 개의 피어에서 파일은 각 피어당 <code>K/N</code> 개씩 저장되므로 피어당 걸리는 부하는 <code>O(K/N)</code> 입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_search_process.png" alt=""></p>

<p>위 그림에서 <code>N80</code> 피어가 <code>K42</code> 파일을 찾을때, </p>

<ul>
<li><em>finger table</em> 에 <code>42</code> 가 없으므로 최대한 먼 <code>N16</code> 에 질의하고, </li>
<li><code>N16</code> 은 <code>N32</code> 와 <code>N80</code> 밖에 모르므로 <code>N32</code> 를 거쳐 <code>N45</code> 로 질의합니다.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_search_analysis.png" alt=""></p>

<p><em>chrod search</em> 는 <code>O(log N)</code> 의 시간이 듭니다. 증명에 대한 <em>intuition</em> 은 쉽습니다.</p>

<p>만약 현재 <code>Here</code> 에서 <code>Key</code> 를 모른다고 합시다. 그러면 그 거리의 <code>1/2</code> 만큼은 점프를 해야합니다. 그것보다 더 적게 점프하면 거리를 <code>d</code> 라 합시다. <em>finger table entry</em> 값은 2배씩 증가하기 때문에, <code>2d</code> 만큼 점프할 수 있는 엔트리가 있어야 하고, 그럼 애초부터 <code>2d</code> 만큼 점프했어야 했기 때문에 모순입니다.</p>

<p><code>log(N)</code> 만큼의 점프 뒤에는 <em>key</em> 까지의 거리는 아무리 멀어봐야 <code>2^m / N</code> 입니다. 균일하게 분포되는 해싱을 쓴다 가정하면, 이 사이에는 적은 수의 노드만 있습니다. 따라서 <code>O(logN)</code> 만큼만 더 점프한다면 높은 확률로 <em>key</em> 를 찾을 수 있습니다. <code>O(logN) + O(logN) = O(logN)</code> 이므로, <em>search</em> 는 <code>O(logN)</code> 입니다.</p>

<p><em>insertion</em> 도 <em>searching</em> 과 마찬가지로 <code>O(logN)</code> 입니다. 그러나 이 성능은 <em>finger table</em> 과 <em>successor</em> 가 잘못되지 않았을 경우에만 참입니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_multiple_successor.png" alt=""></p>

<p><em>chrod</em> 는 <em>successor</em> 한개만 가질땐 <em>failure</em> 에 취약하기 때문에, 위 그림처럼 다수개의 <em>successor</em> 를 가질 수 있습니다. 이 경우 성능은 어떻게될까요?</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/multiple_successor_analysis.png" alt=""></p>

<p><code>2log(N)</code> 개의 <em>successor</em> 를 유지할 경우를 한번 생각해 봅시다. <code>50%</code> 씩 <em>failure</em> 가 발생하면</p>

<ul>
<li>하나의 노드에서 유지하는 <em>successor</em> 중, 적어도 하나의 <em>successor</em> 가 살아있을 확률은</li>
</ul>

<p><img src="http://latex.codecogs.com/gif.latex?1%20-%20%28%7B1%20%5Cover%202%7D%29%5E%7B2logN%7D%20%3D%201%20-%20%7B1%20%5Cover%20N%5E2%7D" alt=""></p>

<ul>
<li>위 확률은 모든 살아있는 노드(<code>50%</code>) 에서 참일때, 다시 말해서 모든 노드에서 적어도 하나의 <em>successor</em> 가 존재할 확률은 <code>N</code> 이 매우 클때</li>
</ul>

<p><img src="http://latex.codecogs.com/gif.latex?%281%20-%20%7B1%20%5Cover%20N%5E2%7D%29%5E%7BN/2%7D%20%3D%20e%5E%7B-%7B1%5Cover%202N%7D%7D%20%5Capprox%201" alt=""></p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_joining.png" alt=""></p>

<ul>
<li>a new peer affects <code>O(logN)</code> other finger entires in the system, on average</li>
<li>number of messages per peer join <code>O(logN * logN)</code></li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/chord_stabilization_protocol.png" alt=""></p>

<p><em>join</em>, <em>leave</em>, <em>failure</em> 등 <em>churn</em> 이 자주 일어나므로 <em>loop</em> 가 있는지 없는지 검사하기 위해 주기적으로 <em>stabilization protocol</em> 를 사용합니다.</p>

<p><br></p>

<h3 id="pastry">Pastry</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/pastry_routing.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/pastry_locality.png" alt=""></p>

<p><em>Pastry</em> 는 <em>chord</em> 처럼 <em>node</em> 에 <em>id</em> 를 부여합니다. <em>routing table</em> 은 <em>prefix matching</em> 에 기반하기 때문에 <code>log(N)</code> 의 성능을 보여줍니다. 그리고 짧은 <em>prefix</em> 일 수록 가까이에 있을 확률이 높습니다.</p>

<p><br></p>

<h3 id="kelips">Kelips</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/kelips.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/kelips2.png" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/kelips3.png" alt=""></p>

<p><em>Kelips</em> 는 <em>1-hop lookup</em> 을 보여줍니다. 이럴 수 있는 이유는 위 그림에서 보듯이 <em>affinity group</em> 이란걸 사용하기 때문입니다. 루트 <code>N</code> 에 가까운 숫자 <code>k</code> 를 정하고, 이 수로 <code>mod</code> 연산을 해, 그룹을 만듭니다. 각각의 그룹은 내에 있는 모든 노드는 서로 어떤 파일을 저장하는지 알고 있습니다. 그리고 각 노드는 다른 그룹으로의 링크를 하나씩 가지고 있습니다. 따라서 어딜가든 거의 1번 혹은 2번 내에 <em>lookup</em> 이 가능합니다.</p>

<p><em>chord</em> 에 비해 메모리를 더 잡아먹긴 합니다. <code>O(logN)</code> 보단 많은 양이지만, 그렇게 많지도 않습니다. 메모리가 귀하다면 <em>chord</em> 나 <em>pastry</em> 를, 그렇지 않고 <em>lookup</em> 속도가 중요하다면 <em>kelips</em> 를 사용하면 됩니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week3/kelips4.png" alt=""></p>

<p><em>membership</em> 은 <em>gossip-based</em> 프로토콜로 관리할 수 있습니다. </p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://ook.co/solutions/cloud-computing/">Title Image</a> <br>
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></content:encoded></item><item><title><![CDATA[Java Interview Questions, Collection Framework]]></title><description><![CDATA[<p><img src="http://4.bp.blogspot.com/_b6abT-2H2yE/TSTixbyU8GI/AAAAAAAAAUU/LcqDidb_liw/s1600/screen-capture-1.png" alt=""></p>

<p><br></p>

<h3 id="general">General</h3>

<p>(1) <strong>Explain Collections Hierarchy?</strong></p>

<p><img src="http://2.bp.blogspot.com/-M0M8nv5s2lQ/U3BcbRQcRvI/AAAAAAAAAec/oBBmQCPDm9Y/s1600/Collection-Classes.tif" alt=""></p>

<p><img src="http://4.bp.blogspot.com/-o9Jk4Z4Tohs/U3Be46CxGTI/AAAAAAAAAeo/Wq8-hhZ8dCA/s1600/Collection-Classes_Map.tif" alt=""></p>

<p align="center">(<a href="http://www.java-redefined.com">http://www.java-redefined.com</a>)</p>

<p>크게 보면 <em>Collection</em> 과 <em>Map</em> 인터페이스로 구분되어 있습니다. </p>

<ul>
<li><code>Map</code> 은 <em>key-value pair</em> 컨테이너이기 때문에 단일 원소에 대한 컨테이너인 <code>Collection</code> 과 호환되지 않습니다.</li>
<li><code>Set</code> 은 중복된 원소를 허용하지 않습니다.</li>
<li><code>Set</code> 과 <code>Map</code> 에 정렬 기능이 필요하면 <code>SortedSet</code>,  <code>SortedMap</code> 인터페이스 구현체인 <code>TreeMap</code>, <code>TreeSet</code></li></ul>]]></description><link>http://1ambda.github.io/java-interview-questions-collection-framework/</link><guid isPermaLink="false">617c586a-498c-458f-aad2-67156cb56b52</guid><category><![CDATA[collection]]></category><category><![CDATA[java]]></category><category><![CDATA[interview]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 22 Feb 2015 16:27:11 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://4.bp.blogspot.com/_b6abT-2H2yE/TSTixbyU8GI/AAAAAAAAAUU/LcqDidb_liw/s1600/screen-capture-1.png" alt=""></p>

<p><br></p>

<h3 id="general">General</h3>

<p>(1) <strong>Explain Collections Hierarchy?</strong></p>

<p><img src="http://2.bp.blogspot.com/-M0M8nv5s2lQ/U3BcbRQcRvI/AAAAAAAAAec/oBBmQCPDm9Y/s1600/Collection-Classes.tif" alt=""></p>

<p><img src="http://4.bp.blogspot.com/-o9Jk4Z4Tohs/U3Be46CxGTI/AAAAAAAAAeo/Wq8-hhZ8dCA/s1600/Collection-Classes_Map.tif" alt=""></p>

<p align="center">(<a href="http://www.java-redefined.com">http://www.java-redefined.com</a>)</p>

<p>크게 보면 <em>Collection</em> 과 <em>Map</em> 인터페이스로 구분되어 있습니다. </p>

<ul>
<li><code>Map</code> 은 <em>key-value pair</em> 컨테이너이기 때문에 단일 원소에 대한 컨테이너인 <code>Collection</code> 과 호환되지 않습니다.</li>
<li><code>Set</code> 은 중복된 원소를 허용하지 않습니다.</li>
<li><code>Set</code> 과 <code>Map</code> 에 정렬 기능이 필요하면 <code>SortedSet</code>,  <code>SortedMap</code> 인터페이스 구현체인 <code>TreeMap</code>, <code>TreeSet</code> 등을 이용할 수 있습니다.</li>
</ul>

<p>(2) How do you remove an entry from a collection? and subsequently what is difference between <code>Collection.remove()</code> and <code>Iterator.remove()</code>, which one you will use, while removing elements during iteration?</p>

<p>아래에서 언급하겠지만 <em>fail-fast</em> 와 관련된 문제입니다. 만약 순회하고 있지 않다면 <code>Collection.remove()</code> 를 사용해도 상관 없지만</p>

<p><em>iterator</em> 를 이용해서 순회하는 동안 컬렉션의 <code>remove()</code> 메소드를 이용하면 <code>ConcurrentModificationException</code> 예외가 발생합니다.  따라서 <code>Iterator.remove()</code> 를 이용해야 합니다. <a href="http://stackoverflow.com/questions/14200489/collection-iterator-remove-vs-collection-remove">SO 답변</a>에서도 그 이유를 찾을 수 있습니다.</p>

<pre><code class="java">// invalid
List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3, 4));  
for (int el : l) {  
  if (el &lt; 3) {
      l.remove(el);
  }
}

// correct way
Iterator&lt;Integer&gt; it = l.iterator();  
while (it.hasNext()) {  
  int el = it.next();
  if (el &lt; 3) {
      it.remove();
  }
}
</code></pre>

<p><br></p>

<h3 id="listinterfacerelated">List interface related</h3>

<ul>
<li><code>List</code> 는 중복된 원소를 허용하며 <em>ordered elements</em> 를 담는 컨테이너입니다. 때때로 <em>Sequence</em> 라 불리기도 합니다. </li>
</ul>

<p>(1) <code>Vector</code> vs <code>ArrayList</code> vs <code>LinkedList</code></p>

<ul>
<li><code>Vector</code> 의 모든 메소드는 <em>동기화 (synchronized)</em> 됩니다. <code>ArrayList</code> 는 <em>thread-unsafe</em> 합니다.</li>
<li><code>Vector</code> 는 <em>JDK</em> 첫 릴리즈부터 포함되어있던 레거시 클래스고, <code>ArrayList</code> 는 <em>JDK 1.2</em> 에서 컬렉션 프레임워크 도입과 함께 추가되었습니다.</li>
<li><em>default</em> 로 <code>Vector</code> 는 두배씩 사이즈가 커지는 반면, <code>ArrayList</code> 는 <em>50%</em> 씩 증가합니다.</li>
<li><code>LinkedList</code> 도 <em>thread-unsafe</em> 하기 때문에 대신 <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html">ConcurrentLinkedQueue</a> 나 <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/LinkedBlockingDeque.html">LinkedBlockingDeque</a> 를 이용할 수 있습니다.</li>
</ul>

<p>(2) What is different between <code>Iterator</code> and <code>ListIterator</code></p>

<ul>
<li><code>Iterator</code> 를 이용해 <code>Set</code> 등 컬렉션을 순회할 수 있지만 <code>ListIterator</code> 는 <code>List</code> 밖에 못 합니다</li>
<li><code>Iterator</code> 는 <em>forward-only</em> 지만, <code>ListIterator</code> 는 양방향 순회가 가능합니다</li>
<li><code>ListIterator</code> 는 <em>add</em>, <em>replace</em>, <em>getting index position</em> 등의 기능이 더 있습니다. </li>
</ul>

<p>참고로 <em>iterator</em> 를 이용해 리스트를 순회하는 방법은</p>

<pre><code class="java">List&lt;String&gt; strList = new ArrayList&lt;&gt;();  
Iterator&lt;String&gt; it = strList.iterator();

while(it.hasNext()){  
  String obj = it.next();
  System.out.println(obj);
}
</code></pre>

<p><br></p>

<h3 id="setinterfacerelated">Set interface related</h3>

<p><code>Set</code> 은 <em>uniqueness of elements</em> 를 보장합니다. 따라서 중복된 원소를 허용하지 않습니다. 만약 <em>ordering</em> 이 있는 <code>Set</code> 을 사용하고 싶다면 구현체로 <code>TreeSet</code> 을 선택하면 됩니다.</p>

<p>(1) <strong>How HashSet store elements?</strong></p>

<p><code>HashSet</code> 은 <em>uniqueness</em> 를 보장하기 위해 내부적으로 <code>Map</code> 을 이용합니다. <em>key-value</em> 를 저장하나, 모든 <em>value</em> 를 같게끔 하죠.</p>

<pre><code class="java">private transient HashMap&lt;E, Object&gt; map;  
// This is added as value for each key
private static final Object PRESENT = new Object();

public boolean add(E e) {  
  return map.put(e, PRESENT) == null;
}
</code></pre>

<p>(2) Can a null element added to a <code>TreeSet</code> or <code>HashSet</code>?</p>

<p><code>HashMap</code>, <code>HashSet</code> 은 하나의 <em>null-key</em> 를 허용하지만, <code>TreeSet</code>, <code>TreeMap</code> 은 <em>null-key</em> 를 허용하지 않습니다. </p>

<p><code>TreeMap</code> 은 <code>NavigableMap</code> 의 구현이고, <code>TreeSet</code> 은 내부적으로 <code>NavigableMap</code> 을 사용합니다. 그런데 <code>NavigableMap</code> 이 <em>null-key</em> 를 허용하지 않기 때문에, <code>TreeSet</code>, <code>TreeMap</code> 도 그렇습니다.</p>

<p><br></p>

<h3 id="mapinterfacerelated">Map interface related</h3>

<p><code>Map</code> 은 <em>key-value pair</em> 를 저장하기 위해 사용합니다. <code>Map</code> 인터페이스 구현체로 <code>HashMap</code>, <code>LinkedHashMap</code>, <code>HashTable</code>, <code>EnumMap</code>, <code>IdentityHashMap</code>, <code>Properties</code> 가 있습니다.</p>

<p>(1) Difference between <code>HashMap</code> and <code>HashTable</code></p>

<ul>
<li><code>HashTable</code> 은 <em>동기화 (synchronized)</em> 되지만, <code>HashMap</code> 은 그렇지 않습니다.</li>
<li><code>HashTable</code> 은 <em>null-key</em> 나 <em>null-value</em> 를 허용하지 않습니다.</li>
<li><code>HashMap</code> 의 <em>iterator</em> 는 <strong>fail-fast</strong> 인 반면 <code>HashTable</code> 의 <em>enumerator</em> 는 그렇지 않습니다.</li>
</ul>

<p>참고로, <em>iterator</em> 는 <em>iteration</em> 동안 <em>caller</em> 가 <code>remove</code> 메소드를 이용해서 원소를 제거할 수 있지만, <em>enumerator</em> 를 이용할때는 원소를 추가하거나 제거할 수 없습니다. 이런 기능 차이 때문에 <em>enumerator</em> 가 기본적인 기능만 가지고 있고 더 빠릅니다. 또 다른 차이점은 <em>enumerator</em> 는 <code>Stack</code>, <code>Vector</code> 처럼 레거시 클래스에 대해 사용합니다.</p>

<p>(2) What are <code>IdentityHashMap</code> and <code>WeakHashMap</code>?</p>

<p>이부분은 <a href="http://howtodoinjava.com/2013/07/09/useful-java-collection-interview-questions/#identityHashMap_weakHashMap_differences">원문</a>을 첨부합니다.</p>

<blockquote>
  <p><strong>IdentityHashMap</strong> is similar to HashMap except that <strong>it uses reference equality when comparing elements</strong>. IdentityHashMap class is not a widely used Map implementation. While this class implements the Map interface, it intentionally violates Map’s general contract, which mandates the use of the equals() method when comparing objects. IdentityHashMap is designed for use only in the rare cases wherein reference-equality semantics are required.</p>
  
  <p><strong>WeakHashMap</strong> is an implementation of the Map interface that <strong>stores only weak references to its keys</strong>. Storing only weak references allows a key-value pair to be garbage collected when its key is no longer referenced outside of the WeakHashMap. This class is intended primarily for use with key objects whose equals methods test for object identity using the == operator. Once such a key is discarded it can never be recreated, so it is impossible to do a look-up of that key in a WeakHashMap at some later time and be surprised that its entry has been removed.</p>
</blockquote>

<p><br></p>

<h3 id="morequestions">More Questions</h3>

<p>(1) What do you understand by iterator <strong>fail-fast</strong> property?</p>

<p><strong>fail-fast iterator</strong> 는 <em>iteration</em> 이 시작된 이후로 <em>collection</em> 이 변경되는걸 알아채는 순간 <code>ConcurrentModificationException</code> 을 던지면서 멈춥니다. 여기서 <em>변경</em> 이란 한 스레드가 컬렉션을 순회하는 동안, 컬렉션에 있는 원소의 삭제, 변경 혹은 추가가 일어나는 것을 말합니다.</p>

<p><em>fail-fast</em> 는 <em>modification count</em> 란 것을 유지하고 있다가, <em>iteration thread</em> 가 <em>modification count</em> 의 변경을 알아채면 예외를 던지는 방식으로 구현됩니다.</p>

<p>(2) What is difference between <strong>fail-fast</strong> and <strong>fail-safe</strong></p>

<p><strong>fail-safe iterator</strong> 는 복사본에 대해 컬렉션 순회를 진행하기 때문에 원본에 변경이 일어나도 멈추지 않습니다. 일반적으로 <code>java.util.concurrent</code> 에 있는 클래스들의 (e.g <code>ConcurrentHashMap</code> 이나 <code>CopyOnWriteArrayList</code>) <em>iterator</em> 가 <em>fail-safe</em> 입니다.</p>

<p>(3) How to avoid <code>ConcurrentModificationException</code> while iterating a collection?</p>

<ul>
<li>먼저 <em>fail-safe iterator</em> 를 사용할 수 있는지 확인합니다 <em>JDK 1.5</em> 이상을 사용한다면, <code>ConcurrentHashMap</code> 이나 <code>CopyOnWriteArrayList</code> 를 사용할 수 있습니다.</li>
</ul>

<p>위 방법이 불가능하면 다음을 고려할 수 있으나, 퍼포먼스가 떨어질 수 있다는 점을 유의해야 합니다. </p>

<ul>
<li><em>list</em> 를 <em>array</em> 로 바꾸어, 순회합니다</li>
<li><em>list</em> 를 순회하는 동안 <em>synchronized block</em> 을 이용해 <em>lock</em> 을 겁니다.</li>
</ul>

<p>(4) What is difference between Synchronized Collection and Concurrent Collection?</p>

<p><em>Java 5</em> 와 함께 <code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code>, <code>BlockingQueue</code> 등의 <em>concurrent collection</em> 클래스들이 추가 되었습니다. 이 클래스들은 <em>synchronized collection</em> 보다 성능이 더 나은데, 이는 일부분에만 <em>lock</em> 을 걸기 때문입니다. 더 자세한 내용은 <a href="http://javarevisited.blogspot.kr/2011/04/difference-between-concurrenthashmap.html">여기로</a></p>

<p>(5) What is <code>Comparable</code> and <code>Comparator</code>?</p>

<p>자바에서 <code>TreeSet</code> 이나 <code>TreeMap</code> 처럼 <em>automatic sorting</em> 기능이 있는 모든 컬렉션은 <code>compare</code> 메소드를 사용합니다. </p>

<p>이 때 <em>element class</em> 는 정렬을 위해 <code>Comparator</code> <strong>또는</strong> <code>Comparable</code> 인터페이스를 반드시 구현해야 합니다. <em>wrapper class</em> 인 <code>Integer</code>, <code>Double</code> 등이 <code>Comparable</code> 인터페이스를 구현하는 이유가 바로 이것입니다.</p>

<p><code>Comparable</code> 은 원소가 컬렉션에 추가될때 자동적으로 정렬되도록 (<em>natural sorting</em>) 하기 위해 사용하고, <code>Comparator</code> 는 추가적인 정렬방법을 이용하기 위해 정의할 수 있습니다. <a href="http://www.java2blog.com/2013/02/difference-between-comparator-and.html">여기</a>서 가져온 예제를 보면</p>

<pre><code class="java">// Comparable
public class Country implements Comparable&lt;Country&gt;{  
       @Override
    public int compareTo(Country country) {
        return (this.countryId &lt; country.countryId ) ? -1: (this.countryId &gt; country.countryId ) ? 1:0 ;
}} 

// Comparator

Country indiaCountry=new Country(1, "India");  
Country chinaCountry=new Country(4, "China");  
Country nepalCountry=new Country(3, "Nepal");  
Country bhutanCountry=new Country(2, "Bhutan");  
        
List&lt;Country&gt; listOfCountries = new ArrayList&lt;Country&gt;();  
listOfCountries.add(indiaCountry);  
listOfCountries.add(chinaCountry);  
listOfCountries.add(nepalCountry);  
listOfCountries.add(bhutanCountry); 

Collections.sort(listOfCountries,new Comparator&lt;Country&gt;() {  
  @Override
  public int compare(Country o1, Country o2) {
    return o1.getCountryName().compareTo(o2.getCountryName());
  }
});
</code></pre>

<p><br></p>

<h3 id="references">References</h3>

<p>(1) <a href="http://howtodoinjava.com/2013/07/09/useful-java-collection-interview-questions/#why_map_not_extend_collection">Useful Java Collection Interview Questions</a> <br>
(2) <a href="http://websphereemerge.blogspot.kr/">Title Image</a> <br>
(3) <a href="http://www.java-redefined.com/2014/05/java-collection-interview-questions.html">http://www.java-redefined.com</a> <br>
(4) <a href="http://www.java2blog.com/2013/02/difference-between-comparator-and.html">http://www.java2blog.com/</a> <br>
(5) <a href="http://www.javatpoint.com/java-collections-interview-questions">http://www.javatpoint.com</a> <br>
(6) <a href="http://stackoverflow.com/questions/14200489/collection-iterator-remove-vs-collection-remove">SO:  Iterator.remove() vs Collection.remove()</a></p>]]></content:encoded></item><item><title><![CDATA[Cloud Computing, Membership Protocol]]></title><description><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>왜 <em>membership</em> 이란 개념이 클라우드 컴퓨팅에 필요할까요? </p>

<p>한 노드가 <em>OS</em>, <em>Disk</em>, <em>Network</em> 등 때문에 10년 (120개월) 마다 한 번씩 고장난다고 합시다. 그러면 120개의 노드를 가지고 있다면 1개월마다  한 번씩입니다. 이정도는 참을만하죠? 그런데, 12,000 개의 서버를 가지고 있다면 <em>MTTF (mean time to failure)</em> 는 7.2 시간마다 한번씩입니다. 이건 큰</p>]]></description><link>http://1ambda.github.io/cloud-computing-membership-protocol/</link><guid isPermaLink="false">146da27a-1df0-44d0-a8e1-3020c05f0d22</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[membership]]></category><category><![CDATA[SWIM]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 22 Feb 2015 07:02:52 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<p>왜 <em>membership</em> 이란 개념이 클라우드 컴퓨팅에 필요할까요? </p>

<p>한 노드가 <em>OS</em>, <em>Disk</em>, <em>Network</em> 등 때문에 10년 (120개월) 마다 한 번씩 고장난다고 합시다. 그러면 120개의 노드를 가지고 있다면 1개월마다  한 번씩입니다. 이정도는 참을만하죠? 그런데, 12,000 개의 서버를 가지고 있다면 <em>MTTF (mean time to failure)</em> 는 7.2 시간마다 한번씩입니다. 이건 큰 문제입니다. </p>

<p>따라서 머신이 멀쩡한지 아닌지를 수동이 아니라 자동으로 판단하고 보고해줄 시스템이 필요합니다. <em>membership</em> 이 필요한 것이죠. 이 대상은</p>

<p>(1) Process <em>group</em>-based systems</p>

<ul>
<li>Clouds / Datacenters</li>
<li>Replicated servers</li>
<li>Distributed databases</li>
</ul>

<p>(2) Cash-stop / Fail stop process failures</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/membership1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/membership2.jpg" alt=""></p>

<p>멤버십 프로토콜은 다음처럼 구성되어 있습니다.</p>

<ul>
<li>멤버쉽 리스트 (<em>complete</em>, <em>almost-complete</em>, <em>partial-random</em>)</li>
<li><em>dissemination</em> mechanism to inform about joins, leavs, and failures of processes</li>
<li><em>failure detector</em></li>
</ul>

<p><br></p>

<h3 id="failuredetector">Failure Detector</h3>

<p><em>distributed failure detector</em> 를 평가할 수 있는 지표는</p>

<ul>
<li><strong>Completeness:</strong> each failure is detected</li>
<li><strong>Accuracy:</strong> there is no mistaken detection</li>
<li><strong>Speed:</strong> time to first detection of a failure</li>
<li><strong>Scale:</strong> equal load on each member. network message load</li>
</ul>

<p>안타깝게도 <em>completeness</em> 와 <em>accuracy</em> 를 <em>lossy network</em> 에서 동시에 추구할 수 없다는 사실이 밝혀졌습니다. (<em>Chandra and Toueg</em>) </p>

<p>현실적으로는</p>

<ul>
<li><em>completeness:</em> 100% guaranteed</li>
<li><em>accuracy:</em> partial / probabilistic guarantee</li>
</ul>

<p><br></p>

<p>(1) Centralized Heartbeating</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/centralized_heartbeating.jpg" alt=""></p>

<p>중앙 집중형이기 때문에 <em>load</em> 가 한쪽으로만 쏠린다는 단점이 있습니다.</p>

<p>(2) Ring Heartbeating</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/ring_heartbeating.jpg" alt=""></p>

<p>링 형태로 구성되었기때문에 동시에 발생하는 다수개의 <em>failure</em> 를 탐지하지 못합니다.</p>

<p>(3) All To All Heartbeating</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/all2all_heartbeating.jpg" alt=""></p>

<p>우선 <em>equal load</em> 라는 장점이 있습니다. 개별 노드당 오버헤드가 큰 것처럼 보이는데, 뒤에서 다시 한번 보겠지만 사실 그렇게 크지 않습니다. </p>

<p>(4) Gossip-Style Membership</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/gossip_heartbeating1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/gossip_heartbeating2.jpg" alt=""></p>

<p><em>accuracy</em> 가 높다는 장점이 있습니다.</p>

<p>동작 방식은 이렇습니다. <em>hearbeat</em> 가 <code>T_fail</code> 초 후에도 증가하지 않으면, 해당 멤버는 <em>failure</em> 를 일으킨 것으로 판별됩니다. 그리고 멤버 리스트에서는 <code>T_cleanup</code> 초 후에 제거됩니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/why_cleanup_time1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/why_cleanup_time2.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/why_cleanup_time3.jpg" alt=""></p>

<p>왜 바로 제거하지 않고, <code>T_cleanup</code> 초 후에 제거할까요? 이는 위 슬라이드에서 볼 수 있듯이 <code>3</code> 번 노드가 <em>failure</em> 를 일으켰을때, <code>2</code> 번 노드의 멤버 리스트에서 바로 제거한다면 <code>1</code> 번 노드로부터 업데이트를 받아 멤버 리스트에 <em>failure</em> 가 발생하지 않은것처럼 추가될 수 있기 때문입니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/gossip_membership_analysis.jpg" alt=""></p>

<p><code>T_gossip</code> 이 줄면, <em>bandwidth</em> 를 많이 잡아먹는 대신, <em>detection time</em> 이 줄어듭니다. <em>trade-off</em> 라 보면 되겠습니다.</p>

<p>그리고 <code>T_fail, T_cleanup</code> 이 증가하면 <em>false positive rate</em> 는 줄어드는 대신, 당연히 <em>detection time</em> 이 늘어납니다.</p>

<p><br></p>

<p>그러면 위에 나온 것 중 어느것이 가장 좋은 <em>failure detector</em> 일까요? 앞서 언급했던 기준들을 이용해서 살펴보겠습니다.</p>

<ul>
<li><em>Completeness:</em> guarantee always</li>
<li><em>Accuracy:</em> a prob of mstake in time T <code>PM(T)</code></li>
<li><em>Speed:</em> <code>T</code> time units</li>
<li><em>Scale:</em> <code>N*L</code> Compare this across protocols</li>
</ul>

<p>(1) All-To-All Heartbeating</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/performance_all2all.jpg" alt=""></p>

<p><em>work load</em> 가 <code>N</code> 에 비례합니다.</p>

<p>(2) Gossip-Style Heartbeating</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/performance_gossip.jpg" alt=""></p>

<p><code>tg</code> 를 <code>O(n)</code> 의 <em>gossip message</em> 를 보내는데 걸리는 <em>gossip period</em> 라 했을때, 한 <em>round</em> 에서의 전파 시간인 <code>logN</code> 을 곱해 <code>T = logN * tg</code> 입니다. 이때 오버헤드 <code>L = N/tg</code> 이므로, <code>L = N * logN / T</code> 입니다. </p>

<p>오버헤드가 <em>all-to-all heartbeating</em> 보다 훨씬 높죠? 이는 <em>accuracy</em> 가 더 높기 때문입니다. 앞에서 <em>all-to-all</em> 가 더 비용이 많이 들것 같지만 실제로는 그렇지 않다고 했었는데, 이런 이유에서입니다.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/suboptimal_worstcase.jpg" alt=""></p>

<ul>
<li><em>worst case load per member</em> <code>L*</code> 라 하고</li>
<li><code>P_ml</code> 을 독립적인 메시지 손실양 이라고 했을때, </li>
</ul>

<p><code>L*</code> 을 <code>T, PM(T), P_ml</code> 의 함수로 표시하면 </p>

<p><img src="http://latex.numberempire.com/render?L%2A%20%3D%20%7B%20log%28PM%28T%29%29%20%5Cover%20log%28P_ml%29%20%7D%20%2A%20%7B1%20%5Cover%20T%20%7D&amp;sig=b21744720873bd544c3b394bd827b158" alt=""></p>

<p>메시지 손실 <code>P_ml</code> 이 높을수록, 오버헤드 <code>L*</code> 는 당연히 작아져야 하고, <code>PM(T)</code> 가 높을수록 <em>false-positive</em> 가 많으므로 오버헤드가 높습니다. 수식을 보면 변수 <code>N</code> 이 없는데, 이는 <em>scale-free</em> 함을 보여줍니다.</p>

<p>그리고 <em>all-to-all</em> 이나 <em>gossip-based</em> 는 <strong>suboptimal</strong> 입니다. 왜냐하면 </p>

<ul>
<li><code>L = O(N/T)</code></li>
<li>try to achieve simultaneous detection at all processes</li>
<li>fail to distinguish <strong>failure detection</strong> and <strong>dissemination components</strong></li>
</ul>

<p>따라서 두개의 컴포넌트를 분리하고, <em>non heatbeat-based failure detection</em> 을 이용하면 됩니다.</p>

<p><br></p>

<h3 id="swimfailuredetector">SWIM Failure Detector</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/SWIM_intro.jpg" alt=""></p>

<p><em>SWIM</em> 은 <em>probabilistic failure detector protocol</em> 입니다. </p>

<p><em>period</em> <code>T</code> 동안 프로세스(노드) <code>pi</code> 는 <code>pj</code> 를 랜덤하게 골라 <em>ping</em> 을 보냅니다. <em>ack</em> 가 오면, 남은 <em>period</em> 동안 아무것도 하지 않습니다. 그러나 위 슬라이드에서 볼 수 있듯이 <code>pj</code> 가 응답하지 않으면 랜덤하게 <code>K</code> 개의 프로세스를 선택해서, <em>ping</em> 을 날리고, 이를 통해 <em>indirect</em> 한 방법으로 <code>pj</code> 의 응답을 검사합니다.</p>

<p><em>SWIM</em> 의 퍼포먼스는 <em>heartbeat</em> 와 비교했을때 어떨까요?</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/SWIM_vs_heartbeating.jpg" alt=""></p>

<p><code>X</code> 축은 <strong>process load</strong>, <code>Y</code> 축은 <em>first detection time</em> 입니다. <em>false-positive rate</em> 와 <em>message loss rate</em> 는 고정되어있다고 가정합니다.</p>

<p><em>heartbeat</em> 의 경우에는 앞서 봤듯이 <em>detection time</em> 읖 높이면 <em>work load</em> 가 낮아지고 (= <em>low bound on the bandwidth</em>), 반대로 <em>detection time</em> 을 낮추면, <em>work load</em> 가 높아집니다. 반면 <em>SWIM</em> 은 둘다 적죠.</p>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/SWIM_parameters.jpg" alt=""></p>

<p>슬라이드에서 볼 수있듯이 <em>first detection time</em>, <em>process load</em> 는 <em>constant</em> 입니다. <em>process load</em> 의 경우에는 <em>15% packet loss</em> 가 있을때 <em>optimal</em> 의 8배인 <code>8L*</code> 보다 적습니다.</p>

<p><em>false positive rate</em> 는 <code>K</code> 를 증가시켜서 줄일 수 있습니다. <code>K</code> 가 증가함에 따라 <em>false positive rate</em> 는 지수적으로 감소합니다. </p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/SWIM_accuracy_load.jpg" alt=""></p>

<p><del>쿨하게 페이퍼를 보시라는 교수님</del></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/SWIM_detection_time.jpg" alt=""></p>

<p>어째서 <em>expected detection time</em> 이 <code>1 / e-1</code> 일까요? 하나의 프로세스가 죽었을때, 핑 되려면 다른 프로세스의 멤버쉽 리스트에 있어야 하고, 랜덤하게 선택되야 합니다. </p>

<p>랜덤하게 선택될 확률은 <code>1/N</code> 이고, 선택되지 않을 확률은 <code>1 - 1/N</code> 입니다. 다른 <code>N-1</code> 개의 프로세스에 의해 모두 선택되지 않을 확률은 <code>(1-1/N)^N-1</code> 이고, <code>1</code> 에서 이 값을 빼면 선택될 확률입니다. 그리고 익히 알려진 바대로 <del>응?</del> <code>N</code> 이 매우 커지면 이 값은 <code>1-e^-1</code> 과 같습니다.</p>

<p>그리고 확률론을 잘 안다면 <del>응?</del> 이 값에 기대값을 취하면 <code>e / e-1</code> 이 됩니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/time_bounded_completeness.jpg" alt=""></p>

<p>여기에 간단한 트릭을 이용하면 <em>worst case</em> 로 <code>O(N)</code>, 정확히는 <code>2N-1</code> <em>period</em> 내에 <em>failure</em> 가 발견되도록 할 수 있습니다. <em>membership list</em> 를 순회하다가, 마지막에 도달하면 랜덤하게 재배열 하는 것입니다. </p>

<p>그러면 최악의 경우 2번째 멤버에 대해 <em>ping</em> 을 날릴때 첫번째 멤버에 <em>failure</em> 가 발생하고, 재 배열했을때 첫번째 멤버가 마지막에 있다면 <code>(N-1) + (N)</code> 의 <em>period</em> 가 걸립니다. 그리고 이것은 <em>accuracy</em> 등 다른 <em>failure detector</em> 의 속성들을 그대로 유지한채 <em>worst case</em> 시간을 줄이는 결과를 만듭니다.</p>

<p><br></p>

<h4 id="disseminationandsuspicion">Dissemination and Suspicion</h4>

<p><em>dissemiantion</em> 방법으로</p>

<p>(1) <strong>Multicast</strong> (Hardware / IP)</p>

<ul>
<li>unreliable</li>
<li>multiple simultaneous multicasts</li>
</ul>

<p>(2) <strong>Point-To-Point</strong> (TCP / UDP)</p>

<ul>
<li>expensive</li>
</ul>

<p>(3) <strong>Zero extra message:</strong> Piggyback on Failure Detector messages</p>

<ul>
<li>Infection-style Dissemination (like <em>SWIM</em>)</li>
</ul>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/infection_style_dissemination.jpg" alt=""></p>

<p>슬라이드에서 볼 수 있듯이 <em>infection style dissemination</em> 은 <code>λ log(N)</code> <em>protocol periods</em> 후에 <code>N^-(2λ-2)</code> 개의 프로세스만 업데이트되지 않습니다. 바꿔말하면 <code>O(logN)</code> 후에 대부분의 프로세스는 발견돈 <em>failure</em> 정보를 업데이트 한다는 뜻입니다. </p>

<p>여기서 <code>λ</code> 는 <em>consistency level</em> 을 결정하는 상수입니다. 어떤 경우에도 <em>SWIM detector</em> 는 <em>failure</em> 를 <code>2N-1</code> 내에 발견하기 때문에 <em>completeness</em> 100% 가 보장됩니다.</p>

<p><br></p>

<h3 id="suspicionmechanism">Suspicion Mechanism</h3>

<p><em>false positive</em> 가 발생하는 이유는</p>

<ul>
<li>perturbed processes</li>
<li>package losses (e.g from congestion)</li>
</ul>

<p><em>SWIM</em> 에서 사용했던 <em>indirect pinging</em> 도 이 문제를 해결하지 못할 수 있습니다. (e.g <em>correlated message losses near pinged host</em>)</p>

<p>먼저 <em>failure</em> 가 발견되었을때 다른 노드들에게 알리기 전에 먼저 <em>suspect</em> 한다면 <em>false positive</em> 비율을 줄일 수 있습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/suspicon_mechanism_state_machine.jpg" alt=""></p>

<p>그림이 좀 복잡한데, 프로세스(노드) <code>pi</code> 기준으로 <em>state</em> 가 어떻게 변하는지를 나타낸 그림이라고 보면 됩니다. <code>pj</code> 에게 핑을 날려 응답하지 않으면 <em>suspected</em> 상태로 변하고, 여기서 <em>timeout</em> 되면 <em>failed</em> 되어 <code>pj</code> 가 <em>failure</em> 라고 <em>dissemination</em> 하는 상태가 됩니다.</p>

<p>한 가지 발생할 수 있는 문제점은 <em>suspected</em> 상태에서 <em>alive</em> 상태로 반복적으로 전환될 수 있다는 점입니다. 이러한 혼란을 피하기 위해 <em>incarnation number</em> 를 사용할 수 있습니다.</p>

<p>프로세스 <code>pj</code> 가 <em>suspected</em> 메세지를 받았을때, <em>incarnation number</em> 를 증가시킬 수 있는 것은 <code>pj</code> 만 가능합니다. 그리고 <em>increase incarnation number</em> 메시지를 받은 다른 프로세스들은 <em>alive</em> <code>pj</code> 메시지를 전달합니다.</p>

<p>높은 숫자의 <em>incarnation number</em> 가 더 우선합니다. 그리고 <em>suspect</em> 와 <em>alive</em> 같은 값이라면 <em>suspect</em> 메시지로 처리됩니다. 그리고 <em>failed</em> 메시지는 다른 어떤 메시지보다 더 높은 우선순위를 가지고 있습니다.</p>

<p><br></p>

<h3 id="summary">Summary</h3>

<ul>
<li>failures the norm, not the exception in datacenters</li>
<li>every distributed system uses a failure detector</li>
<li>many distributed systems use a membership service</li>
<li>ring failure detection underlies <em>IBM SP2</em> and many other similar clusters</li>
<li>Gossip-style failure detection underlies AWS EC2/S3 (rumored)</li>
</ul>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://ook.co/solutions/cloud-computing/">Title Image</a> <br>
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></content:encoded></item><item><title><![CDATA[Cloud Computing, Gossip Protocol]]></title><description><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<h3 id="multicast">Multicast</h3>

<p>이번시간에 배울 내용은 <em>Gossip Protocol</em> (혹은 <em>Epidemic Protocol</em>) 입니다.</p>

<p>기존에는 특정 그룹에게 메세지를 보내기 위해 <em>multicast</em> 를 이용했지만, 클라우드 컴퓨티 환경에서는</p>

<ul>
<li>프로세스가 죽어 노드가 크래쉬를 일으킬수도</li>
<li>네트워크 문제때문에 패킷이 딜레이되거나, 드랍될 수 있고</li>
<li>노드가 빠르게 증가합니다.</li>
</ul>

<p>그러나 멀티캐스트는 <em>fault-tolerance</em> 와 <em>scalability</em> 측면에서 부족한 부분이 많았습니다. 이런 문제를 해결하기 위해</p>]]></description><link>http://1ambda.github.io/cloud-computing-gossip-protocol/</link><guid isPermaLink="false">791b3276-2b13-469d-96ff-21b0b279bfd2</guid><category><![CDATA[coursera]]></category><category><![CDATA[cloud computing]]></category><category><![CDATA[gossip]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sat, 21 Feb 2015 05:41:54 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://ook.co/wp-content/uploads/cloudcomputing.png" alt=""></p>

<h3 id="multicast">Multicast</h3>

<p>이번시간에 배울 내용은 <em>Gossip Protocol</em> (혹은 <em>Epidemic Protocol</em>) 입니다.</p>

<p>기존에는 특정 그룹에게 메세지를 보내기 위해 <em>multicast</em> 를 이용했지만, 클라우드 컴퓨티 환경에서는</p>

<ul>
<li>프로세스가 죽어 노드가 크래쉬를 일으킬수도</li>
<li>네트워크 문제때문에 패킷이 딜레이되거나, 드랍될 수 있고</li>
<li>노드가 빠르게 증가합니다.</li>
</ul>

<p>그러나 멀티캐스트는 <em>fault-tolerance</em> 와 <em>scalability</em> 측면에서 부족한 부분이 많았습니다. 이런 문제를 해결하기 위해 다양한 방법이 도입되었는데</p>

<p>(1) <strong>Centralized:</strong> 중앙 서버에서 <em>TCP, UDP</em> 패킷을 날립니다. 간단한 구현이지만 중앙서버의 오버헤드가 높고, 수천개의 노드가 있을때 <em>latency</em> 가 생깁니다. 노드의 수를 <code>N</code> 이라 했을때, 모든 노드에 메시지가 전달되는데 <code>O(N)</code> 시간이 걸리지요.</p>

<p>(2) <strong>Tree-Based:</strong> 전달 받은 노드에서, 다시 패킷을 전달하여 경로가 <em>tree</em> 형태로 구성됩니다. <em>balanced tree</em> 라면 어떤 그룹에 패킷이 전달되는데 <code>O(logN)</code> 의 시간이 걸립니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/tree_based_multicast.jpg" alt=""></p>

<p>이 방법의 단점은 </p>

<ul>
<li><em>tree</em> 를 구성하고 유지하는데 필요한 오버헤드</li>
<li><em>root</em> 에 가까운 곳에서 <em>failure</em> 가 발생했을때의 파급력</li>
</ul>

<p>일반적으로 <em>tree-based multicast</em> 프로토콜에서는 <em>spanning tree</em> 를 구성해서 최단비용으로 패킷을 전달합니다. 그리고 메시지가 올바르게 전달되었는지 <em>ACK</em> 또는 <em>NAK</em> 를 이용하는데 <em>SRM</em> 이던 <em>RMTP</em> 던 여전히 <code>O(N)</code> 만큼의 <em>ACK/NAK</em> 오버헤드가 발생합니다.</p>

<p><br></p>

<h3 id="gossip">Gossip</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/gossip_example1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/gossip_example2.jpg" alt=""></p>

<p>가십 프로토콜은 위 그림처럼 작동합니다.</p>

<ul>
<li>주기적으로 랜덤한 타겟을 골라 <em>gossip message</em> 를 전송합니다</li>
<li>그리고 이것을 받아 <em>infected</em> 상태가 된 노드도 똑같이 행동합니다.</li>
</ul>

<p>이걸 <em>Push gossip</em> 이라 부릅니다. <em>multiple message</em> 를 가십하기 위해 랜덤 서브셋을 선택하거나, <em>recently-received</em> 메시지를 를 선택하거나, <em>higher priority one</em> 을 고를 수 있습니다.</p>

<p>어떤 가십 메시지에 대해 대부분의 노드가 <em>infected</em> 되었을때 <em>push gossip</em> 은 비효율적입니다. 이때는 <em>uninfected</em> 노드가, 새로운 가십메시지가 있는지 주변 노드에게 물어보는 <strong>pull gossip</strong> 이 오버헤드가 더 적습니다.</p>

<ul>
<li><strong>Pull gossip:</strong> Periodically poll a few random selected processes for new multicast meesages that you haven't received</li>
</ul>

<p><br></p>

<h3 id="gossipanalysis">Gossip Analysis</h3>

<p>가십프로토콜은 다음의 특징을 가집니다.</p>

<ul>
<li><strong>lightweight</strong> in large groups</li>
<li>spreads a multicast quickly</li>
<li>highly <em>fault-tolerant</em></li>
</ul>

<p>이를 위해 간단한 증명을 해보도록 하겠습니다.</p>

<ul>
<li>전체 <code>n+1</code> 의 <em>population</em> 에 대해 </li>
<li><em>uninfected individuals</em> 의 수를 <code>x</code></li>
<li><em>infected individuals</em> 의 수를 <code>y</code> </li>
<li><em>individual pair</em> 간의 <em>contract rate</em> 를 <code>β</code> 라 하면</li>
</ul>

<p>항상 <code>x + y = n + 1</code> 이고, 시작상태에서는 <code>x_0 = n, y_0 = 1</code> 입니다. 그리고 시간이 지날때마다 <em>uninfected</em> <code>y</code> 는 다음처럼 감소합니다.</p>

<p><img src="http://latex.codecogs.com/gif.latex?%5Cfrac%7B%5Cmathrm%7Bd%7D%20x%7D%7B%5Cmathrm%7Bd%7D%20t%7D%20%3D%20-%5Cbeta%20xy" alt=""></p>

<p>그러면 이 수식으로부터 다음을 이끌어 낼 수 있습니다.</p>

<p><img src="http://latex.codecogs.com/gif.latex?x%20%3D%20%7B%20n%28n&plus;1%29%20%5Cover%20%7Bn%20&plus;%20e%5E%7B%5Cbeta%28n&plus;1%29t%7D%7D%7D" alt=""></p>

<p><img src="http://latex.codecogs.com/gif.latex?y%20%3D%20%7B%20%28n&plus;1%29%20%5Cover%20%7B1%20&plus;%20ne%5E%7B-%5Cbeta%28n&plus;1%29t%7D%7D%7D" alt=""></p>

<p>그리고 <em>infected node</em> 가 랜덤하게 <code>b</code> 개의 노드를 고른다 하면 <code>β</code> 는 </p>

<p><img src="http://latex.codecogs.com/gif.latex?%5Cbeta%20%3D%20%7Bb%20%5Cover%20b%7D" alt=""></p>

<p>그리고 시간 <code>t</code> 를 가십이 진행되는 <em>round</em> 라 보고 <code>t = clog(n)</code> 이라 치환하겠습니다. 다음을 이끌어낼 수 있습니다.</p>

<p><img src="http://latex.codecogs.com/gif.latex?y%20%5Capprox%20%28n&plus;1%29%20-%20%7B1%20%5Cover%20n%5E%7Bcb-2%7D%7D" alt=""></p>

<p>이 식으로부터 <em>gossip protocol</em> 이 <em>low latency</em>, <em>reliability</em>, <em>lightweight</em> 하다는 것을 알 수 있습니다.</p>

<p>(1) <strong>low latency</strong></p>

<p><code>c, b</code> 를 <code>n</code> 과 독립적으로 아주 작은 숫자로 세팅하면 <code>clog(n)</code> <em>round</em> 이므로 적은 시간 내에 메시지가 전파됩니다.</p>

<p>(2) <strong>reliability</strong></p>

<p><code>n</code> 이 매우 크면 <code>1 / n^{cb-2}</code> 가 <code>0</code> 에 가까워지므로, <code>1 / n^{cb-2}</code> 만큼의 노드를 제외한 모든 노드가 <em>infected</em> 된다는 것을 알 수 있습니다.</p>

<p>(3) <strong>lightweight</strong></p>

<p>각 노드는 <code>cb log(n)</code> 만큼의 <em>gossip message</em> 만 전파합니다. 이론적으로는 <code>log(N)</code> 은 상수가 아니지만, 실제로는 아주 천천히 증가하는 숫자기에 작은 숫자처럼 생각할 수 있습니다.</p>

<p><br></p>

<h3 id="faulttolerance">Fault-Tolerance</h3>

<p><em>50% packet loss</em> 를 생각해 봅시다. <code>b</code> 를 <code>2/b</code> 로 치환하면 됩니다. 그러면 이전과 같은 <em>reliability</em> <em>0% packet loss</em> 를 위하 두배의 <em>round</em> 만큼만 더 진행하면 됩니다.</p>

<p><em>node failure</em> 는 어떨까요? 50% 노드에서 <em>failure</em> 가 발생한다면 <code>n, b</code> 을 <code>2/n, 2/b</code> 으로 치환하면 됩니다. 이는 <em>contract rate</em> 에서 가십 메시지를 전달하는 <code>n</code> 중 <code>2/n</code> 의 노드만 살아있고, 선택되는 <code>b</code> 중 <code>b/2</code> 노드만 살아있기 때문입니다. 이 경우에도 상수만 곱하면 이전과 같은 <em>reliability</em> 를 얻을 수 있습니다.</p>

<p><em>failure</em> 와 관련해서 한 가지 생각해 볼 문제가 있습니다. 모든 노드가 죽는것이 가능할까요? 물론 가능합니다 초기에 모든 노드가 죽으면요. 그러나 <em>improbable</em> 입니다. 일단 몇개의 노드가 <em>infected</em> 되면, 이후에는 퍼지는 속도가 훨씬 더 빠르기 때문입니다. 루머나 바이러스가 퍼질 수 있는 이유를 생각하면 이해하기 쉽습니다.</p>

<p><br></p>

<h3 id="pullgossip">Pull Gossip</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/pull_gossip_analysis.jpg" alt=""></p>

<p>그림에서 볼 수 있듯이, 어떤 형태의 가십 프로토콜이던 <code>2/N</code> 까지 전달할때는 <code>O(logN)</code> 만큼의 시간이 걸립니다. 그 이후에는 <em>pull gossip</em> 이 훨씬 빠르죠.</p>

<p><code>i</code> <em>round</em> 후에 남아있는 <em>uninfected node</em> 의 수를 <code>p_i</code> 라 합시다. <em>pull gossip</em> 을 이용할때 다음 단계에서도 <em>uninfected</em> 일 확률은 </p>

<p><img src="http://latex.codecogs.com/gif.latex?p_%7Bi&plus;1%7D%20%3D%20p_i%5E%7Bk&plus;1%7D" alt=""></p>

<p>이는 <code>p_i</code> 자체가 <em>uninfected</em> 여야 하고, 이 노드가 선택하는 <code>k = b</code> 만큼의 노드도 <em>uninfected</em> 여야 하는데, 이 확률은 극히 낮습니다. 슬라이드에서 보듯이 <em>super-exponential</em> 하고, 그렇기 때문에 <em>second half</em> 부터는 <em>pull gossip</em> 이 <code>O(log(logN))</code> 입니다.</p>

<p><br></p>

<h3 id="topologyawaregossip">Topology-Aware Gossip</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/topology_aware_gossip.jpg" alt=""></p>

<p>만약 <em>uninfected node</em> 를 <em>uniformly random</em> 하게 고른다면 위 그림에서 라우터의 오버헤드는 <code>O(N)</code> 이 됩니다. 더 정확하게는 <em>round</em> 마다 <code>b * (2/n)</code> 이 될겁니다. </p>

<p>이를 해결하기 위해, 서브넷에 <code>n_i</code> 개의 노드가 있을때 자신이 속한 서브넷에 있는 <em>uninfected node</em> 를 더 자주 고르게, 확률을 <code>1 - (1/n_i)</code> 가 되도록 합니다. 그러면, 현재 서브넷에 있는 노드를 선택할 확률이 1 에 가까우므로 <code>O(logN)</code> 시간 내에 전파되고, 라우터의 오버헤드는 <code>(n_i) / (n_i)</code> 가 되어, <code>O(1)</code> 이 됩니다. </p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="http://ook.co/solutions/cloud-computing/">Title Image</a> <br>
(2) <strong>Cloud Computing Concept 1</strong> by <em>Indranil Gupta</em>, Coursera  </p>]]></content:encoded></item><item><title><![CDATA[Pattern Discovery 2]]></title><description><![CDATA[<p><img src="https://m1.behance.net/rendition/modules/7116731/disp/d18c13cd5b49bf40b41e6ef0610b26d3.png" alt=""></p>

<p>패턴 마이닝을 통해 만들어지는 수많은 <em>pattern</em>, <em>rule</em> 이 모두 유용한 것은 아닙니다. 따라서 <em>interestingness measure</em> 을 위해 객관적이거나, 주관적인 평가방법을 이용할 수 있습니다.</p>

<p>(1) <strong>Objective interestingness measures</strong></p>

<ul>
<li>support, confidence, correlation</li>
</ul>

<p>(2) <strong>Subjective interestingness measures</strong></p>

<ul>
<li><em>Query-based:</em> relevant to a user's particular request</li>
<li><em>Against one's knowledge-base:</em> unexpected, freshness, timeliness</li>
<li><em>Visualization tools:</em> Multi-dimensional,</li></ul>]]></description><link>http://1ambda.github.io/pattern-discovery-2/</link><guid isPermaLink="false">eae33e61-9556-4292-99f1-9b45d93ceb62</guid><category><![CDATA[coursera]]></category><category><![CDATA[pattern discovery]]></category><category><![CDATA[data mining]]></category><category><![CDATA[lift]]></category><category><![CDATA[pattern-fusion]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 20 Feb 2015 02:49:15 GMT</pubDate><content:encoded><![CDATA[<p><img src="https://m1.behance.net/rendition/modules/7116731/disp/d18c13cd5b49bf40b41e6ef0610b26d3.png" alt=""></p>

<p>패턴 마이닝을 통해 만들어지는 수많은 <em>pattern</em>, <em>rule</em> 이 모두 유용한 것은 아닙니다. 따라서 <em>interestingness measure</em> 을 위해 객관적이거나, 주관적인 평가방법을 이용할 수 있습니다.</p>

<p>(1) <strong>Objective interestingness measures</strong></p>

<ul>
<li>support, confidence, correlation</li>
</ul>

<p>(2) <strong>Subjective interestingness measures</strong></p>

<ul>
<li><em>Query-based:</em> relevant to a user's particular request</li>
<li><em>Against one's knowledge-base:</em> unexpected, freshness, timeliness</li>
<li><em>Visualization tools:</em> Multi-dimensional, interactive examination</li>
</ul>

<p>이 방법중, 먼저 객관적인 방법에 대해 좀 더 알아보겠습니다.</p>

<p><br></p>

<h3 id="liftchisquared">Lift, χ²(Chi-squared)</h3>

<p><em>confidence</em> 는 두 변수가 관련있는지 말해주지만, <em>positive</em> 혹은 <em>negative</em> 관계인지 말해주지 않습니다. 이를 판별하기 위해 <em>lift</em> 를 이용할 수 있죠</p>

<p><img src="http://latex.codecogs.com/gif.latex?lift%28B%2C%20C%29%20%5C%5C%20%5C%5C%20%3D%20%7Bc%28B%20-%3E%20C%29%20%5Cover%20s%28C%29%7D%20%5C%5C%20%5C%5C%20%5C%5C%20%3D%20%7Bs%28B%20%5Ccup%20C%29%20%5Cover%20%7Bs%28B%29%20%5Ctimes%20s%28C%29%7D%7D" alt=""></p>

<p><code>Lift(B, C)</code> 는 <code>B</code> 와 <code>C</code> 가 얼마나 관련있는지를 말해줍니다. 수식을 보면 알겠지만</p>

<ul>
<li><code>Lift(B, C) = 1</code> 이면 <code>B</code> 와 <code>C</code> 는 <em>independent</em></li>
<li><code>&gt; 1</code> 이면 <em>positive correlated</em></li>
<li><code>&lt; 1</code> 이면 <em>negative correlated</em></li>
</ul>

<p><br></p>

<p><em>correlated events</em> 를 판별하는 다른 방법은 <code>χ²</code> 를 이용하는 것입니다.</p>

<p><img src="http://latex.codecogs.com/gif.latex?%5Cchi%5E2%20%3D%20%5Csum%20%7B%28observed%20-%20expected%29%5E2%20%5Cover%20expected%7D" alt=""></p>

<ul>
<li><code>χ² = 0</code> 이면 <em>independent</em></li>
<li><code>χ² &gt; 1</code> 이면 <em>correlated</em> 이며 <em>positive</em> 인지 <em>negative</em> 인지는 <em>expected</em> 값과 비교하면 알 수 있습니다.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/null_transaction.jpg" alt=""></p>

<p>그러나 <em>lift</em> 와 <em>chi-squared</em> 가 항상 좋은 평가지표는 아닙니다. 위 테이블을 보면 <code>Lift(B, C) = 8.44</code> 입니다.</p>

<p><img src="http://latex.codecogs.com/gif.latex?lift%28B%2C%20C%29%20%5C%5C%20%5C%5C%20%3D%20%7B%28100/102100%29%20%5Cover%20%7B%281100/102100%29%20*%20%281100/102100%29%7D%7D%20%5C%5C%20%5C%5C%20%3D%208.4380" alt=""></p>

<p>이는 <code>~B and ~C</code> 부분의 숫자가 <code>B, C</code> 보다 월등히 높아서 그런데, 이런 영역을 <em>null transaction</em> 이라 부릅니다. </p>

<p><code>B, C</code> 는 같이 일어날 확률이 상당히 낮지만, <em>null transaction</em> 때문에 높은것처럼 보입니다.</p>

<p><br></p>

<h3 id="nullinvariantmeasures">Null Invariant Measures</h3>

<p><em>lift</em> 와 <em>chi-squared</em> 는 많은 수의 <em>null transaction</em> 이 있을 때 좋은 평가 지표가 될 수 없습니다. </p>

<p>이를 해결하기 위해 <em>null transaction</em> 에 영향을 받지 않는 <em>null-invaraint measures</em> 를 사람들이 만들어 두었습니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/null_invariant_measures.jpg" alt=""></p>

<p><em>null invariance</em> 는 <em>massive transaction data</em> 를 마이닝할때 아주 중요합니다. <em>null transaction</em> 이 아주 많을 수 있기 때문이죠. </p>

<p>그러면 이 많은 <em>measures</em> 중 어떤것이 가장 나을까요? 예제 데이터로 한번 비교해 봅시다. <code>m</code> 은 <em>milk</em>, <code>c</code> 는 <em>coffee</em> 입니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/comparison_of_measures.jpg" alt=""></p>

<blockquote>
  <p>Kulc holds firm and is in balance of both directional implications</p>
</blockquote>

<p>여기에 <em>imbalance ratio</em> 라는 개념을 도입할 수 있습니다.</p>

<ul>
<li><strong>imbalance ratio:</strong> measure the imbalance of two itemsets <code>A</code> and <code>B</code> in rule implications</li>
</ul>

<p><img src="http://latex.codecogs.com/gif.latex?IR%28A%2C%20B%29%20%5C%5C%20%5C%5C%20%3D%20%7B%7B%7Cs%28A%29%20-%20s%28B%29%7D%20%5Cover%20s%28A%29%20&plus;%20s%28B%29%20-%20s%28A%5Ccup%20B%29%7D" alt=""></p>

<p><em>Kulc</em> 와 <em>IR</em> 을 이용하면 조금 더 데이터를 자세히 살펴볼 수 있죠.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/IR.jpg" alt=""></p>

<ul>
<li>D4 is <em>neutral</em>, <em>balanced</em></li>
<li>D5 is <em>neutral</em>, but <em>imbalanced</em></li>
<li>D6 is <em>neutral</em>, but very <em>imbalanced</em></li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/DBLP_example.jpg" alt=""></p>

<p><code>ID 5</code> 를 보면, <em>Kulc</em> 는 아이템 <code>A, B</code> 가 상당한 연관성이 있지만, <em>imbalance</em> 하므로 <code>0.562</code> 의 값을 돌려주는 것을 볼 수 있습니다.</p>

<p><br></p>

<h2 id="5miningdiversepatterns">5. Mining Diverse Patterns</h2>

<p>이번 시간에 배울 주제들은 다음과 같습니다.</p>

<ul>
<li>Mining Multiple-Level Associations</li>
<li>Mining Multi-Dimensional Associations</li>
<li>Mining Quantitative Associations</li>
<li>Mining Negative Correlations</li>
<li>Mining Compressed and Redundancy-Aware Patterns</li>
<li>Mining Long/Colossal Patterns</li>
</ul>

<p><br></p>

<h3 id="multilevelassociations">Multi-Level Associations</h3>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/multi_level_items.jpg" alt=""></p>

<p><em>item</em> 은 하위 계층으로 다시 분류될 수 있습니다. 이럴때는 단순히 <em>uniform min support</em> 를 이용하는 것보다, 아래 계층으로 내려갈수록 <em>reduced min support</em> 를 이용하는 편이 더 낫습니다.</p>

<p>그리고 한번의 여러 단계(<em>multi-level</em>) 을 마이닝하기 위해 <em>shared multi-level mining</em> 이란 기법을 이용할 수 있습니다.  이건 뒷부분에서 더 살펴보겠습니다.</p>

<p><em>multi-level association</em> 마이닝의 문제점은 <em>redundant rules</em> 을 만들 수 있다는 점입니다. 따라서 필터링 기법이 필요합니다. <code>level 1</code> 에서 발견된 룰을, <code>level 2</code> 에서 다시 검사하지 않는것 처럼요</p>

<ul>
<li><code>milk -&gt; wheat bread [s=8%, c=70%]</code></li>
<li><code>2% milk -&gt; wheat breadk [s=2%, c=72%]</code></li>
</ul>

<p>아이템에 따라서 <em>customized min support</em> 가 필요한 경우도 있습니다. 우유나 빵은 그렇지 않아도 상관 없지만, <em>diamond</em>, <em>watch</em> 등은 커스터마이징이 꼭 필요합니다. 고가의 아이템이니까요. 이 경우 <em>group-based individualized min-support</em> 를 이용하면 됩니다.</p>

<ul>
<li><code>{diamon, watch}: 0.05%; {bread, milk}: 5%;, ...</code></li>
</ul>

<p><br></p>

<h3 id="multidimensionalassociations">Multi-Dimensional Associations</h3>

<p><em>multi-dimensional</em> 의 예는</p>

<p>(1) <strong>inter-dimension association rules</strong> (no repeated pred)</p>

<p><code>age(X, "18-25") ∩ occupation(X, "student") =&gt; buys(X, "coke")</code></p>

<p>(2) <strong>hybrid-dimension association rules</strong> (repeated pred)</p>

<p><code>age(X, "18-25") ∩ buys(X, "popcorn") =&gt; buys(X, "coke")</code></p>

<p><em>attribute</em> 는 <em>categorical</em> 이거나 <em>quantitative</em> 일 수 있습니다. </p>

<p><br></p>

<h3 id="quantitativeassociations">Quantitative Associations</h3>

<p><em>numerical attribute</em> (e.g <em>age, salary</em>) 를 마이닝 하기 위해 다양한 <em>method</em> 를 사용할 수 있습니다.</p>

<p>(1) static discretization based on prefefined concept hierarchies. data cube-based aggregation</p>

<p>(2) dynamic discretization based on data distribution</p>

<p>(3) clustering: distance-based association. first one-dimensional clustering, then association</p>

<p>(4) deviation analysis</p>

<p><br></p>

<h3 id="negativecorrelations">Negative Correlations</h3>

<p><em>rare pattern</em> 과 <em>negative pattern</em> 은 다릅니다.</p>

<p>(1) <strong>Rare patterns</strong></p>

<ul>
<li>아주 낮은 <em>support</em> 지만, 롤렉스 시계를 사는 행위처럼 중요할 수 있습니다</li>
<li><em>individualized</em>, <em>group-based min support</em> 를 다양한 아이템 그룹에 설정해서 마이닝합니다.</li>
</ul>

<p>(2) <strong>Negative patterns</strong></p>

<ul>
<li>자동차를 동시에 2개 사는것처럼, 같이 일어나는 경우가 드뭅니다 (<em>unlikely to happen together</em>)</li>
</ul>

<p><br></p>

<p><em>negative pattern</em> 은 어떻게 마이닝할까요? 한가지 방법은 <em>lift</em> 에서 사용했던 <em>support-based definition</em> 을 이용하는 것입니다.</p>

<ul>
<li><code>s(A ∪ B) &lt;&lt; s(A) X s(B)</code></li>
</ul>

<p>이 정의는 작은 <em>transaction dataset</em> 에서는 통하지만, 데이터 크기가 커지면 적용되지 않습니다.</p>

<p>(1) 전체 200개의 트랜잭션에 대해</p>

<ul>
<li><code>s(A∪B) = 0.005, s(A) x s(B) = 0.25, s(A∪B) &lt;&lt; s(A) X s(B)</code></li>
</ul>

<p>(2) 전체 10^5 개의 트랜잭션에 대해</p>

<ul>
<li><code>s(A∪B) = 1/10^5, s(A) x s(B) = 1/10^3 X 1/10^3, s(A∪B) &gt;&gt; s(A) X s(B)</code></li>
</ul>

<p>이전에 봤었던 <em>null transaction</em> 때문입니다. <em>support-based definition</em> 은 <em>not null-invariant</em> 입니다.</p>

<p>이를 해결하기 위해 <em>Kulczynski measure-based definition</em> 을 이용하면</p>

<p><img src="http://latex.codecogs.com/gif.latex?%28P%28A%7CB%29%20&plus;%20P%28B%7CA%29%29%20/%202%20%3C%20%5Cepsilon" alt=""></p>

<p>여기서 <code>ɛ</code> 는 <em>negative pattern threshold</em> 를 의미합니다. 만약 위 수식이 <code>ɛ</code> 보다 작으면 <em>negatively correlated</em> 란 뜻이지요. </p>

<p><br></p>

<h3 id="compressedpatterns">Compressed Patterns</h3>

<p>때로는 너무 많아 의미가 없는 <em>scattered pattern</em> 때문에 <em>compressed pattern</em> 을 마이닝 할 필요가 있습니다. </p>

<p><em>compressed pattern</em> 인 <em>closed pattern</em> 과 <em>max pattern</em> 의 정의를 복습해보면</p>

<ul>
<li><strong>closed pattern:</strong> A pattern <code>x</code> is <strong>closed</strong> if <code>x</code> is frequent, and there exists no super pattern <code>Y ⊃ X</code> with the same support as <code>X</code></li>
<li><strong>max pattern:</strong> A pattern <code>X</code> is a <strong>max pattern</strong>. if <code>X</code> is frequent and there exists no frequent super-pattern <code>Y ⊃ X</code></li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/compressed_pattern.jpg" alt=""></p>

<p>예를 들어 위 그림에서 <code>P1, 2, 3, 4, 5</code>는 모두 <em>closed</em> 고, <code>P3</code> 는 <em>max pattern</em> 입니다. <em>P3</em> 만 남기자니 <em>information loss</em> 가 너무 많고, 다 남기자니 엣지가 없습니다. <code>P2, P3, P4</code> 정도면 적당할 것 같습니다.</p>

<p>이 적당한 정도를 결정하기 위해 <em>pattern distance measure</em> 을 사용할 수 있습니다.</p>

<p><img src="http://latex.codecogs.com/gif.latex?Dist%28P_1%2C%20P_2%29%20%3D%201%20-%20%7B%7CT%28P_1%29%20%5Ccap%20T%28P_2%29%7C%20%5Cover%20%7CT%28P_1%29%20%5Ccup%20T%28P_2%29%7C%7D" alt=""></p>

<p>그리고 이 <em>distance</em> 값을 이용해 <em>δ-cluserting</em> 을 합니다. </p>

<ul>
<li><strong>δ-clustering:</strong> For each pattern <code>P</code>, find all patterns which can be expressed by <code>P</code> and whose distance to within <code>δ</code> (<em>δ-cover</em>)</li>
</ul>

<p><br></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/redundancy_aware_top_k.jpg" alt=""></p>

<p><em>Redundancy-Aware Top-k pattern</em> 이란 기법도 있습니다.</p>

<p><code>(a)</code> 가 본래 패턴이고, <em>traditional top-k</em> 기법으로는 가장 컴팩트한(진한) 3개의 패턴만 남깁니다. 따라서 우측 클러스터는 버려지죠.</p>

<p>이를 막기 위해 클러스터별로 하나씩 남기는 <code>(d)</code> <em>summarization</em> 을 이용할 수도 있으나, 이건 중요한 것만을 돌려주지 않습니다. </p>

<p>따라서 두 방법을 조합한 <code>(b)</code>, 중복을 허용하는 <em>redundancy-aware top-k</em> 를 이용하면 적절한 패턴을 남기고, 나머지는 버릴 수 있습니다.</p>

<p>이를 위해 <em>MMS (Maximal Marginal Significance)</em> 메소드를 사용할 수 있습니다.</p>

<p><br></p>

<h3 id="colossalpatterns">Colossal Patterns</h3>

<p><em>long pattern mining</em> 은 소셜 네트워크 분석이나, 바이오인포메틱스, 소프트웨어 엔지니어링등 다양한 분야에서 필요로 합니다. 그러나, 지금까지 우리가 본건 길이가 10 보다 적은 패턴을 마이닝하는 기법들이었습니다.</p>

<p><em>long pattern</em> 을 분석하기 어려운 이유는 지난시간에 봤듯이 <em>downward closure property</em> 때문입니다. <em>frequent pattern</em> 의 <em>sub-pattern</em> 은 적어도 그만큼은 빈번하기 때문에, 패턴의 길이가 길고 <em>frequent</em> 하다면, 그 수많은 서브패턴을 분석해야 하는 것이지요.</p>

<p><em>BFS (e.g Apriori)</em>, <em>DFS (e.g FPgrowth)</em> 등 무엇을 이용하든 수 많은 패턴을 검색해야 하고, <em>combinatorial explosion</em> 과 마주할 수 밖에 없습니다.</p>

<p><code>40C20</code> 컴비네이션의 경우 기존에 존재하는 가장 빠른 마이닝 알고리즘들(e.g FP-Close, LCM)도 계산을 완료하지 못하는 경우가 많습니다. 그러나 놀랍게도 <em>pattern-fusion</em> 알고리즘은 1초만에 결과를 돌려줍니다.</p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/pattern_fusion1.jpg" alt=""></p>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/pattern_fusion2.jpg" alt=""></p>

<p>즉, 작은 <em>core pattern</em> 을 모아 <em>colossal pattern</em> 을 만들어 낸다는 것이지요.</p>

<ul>
<li><strong>core patterns</strong> of a colossal pattern <code>α</code>: A set of subpatterns of <code>α</code> that cluster around <code>α</code> by sharing a similar support</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/robustness_of_colossal_pattern.jpg" alt=""></p>

<p><em>core pattern</em> 에 대한 더 엄밀한 정의는 위와 같습니다.</p>

<p><em>frequent pattern</em> <code>α</code> 에 대해, <em>sub-pattern</em> 인 <code>β</code> 는  다음을 만족하면 <em>τ-core pattern</em> 입니다.</p>

<p><img src="http://latex.codecogs.com/gif.latex?%7B%7CD_%5Calpha%7C%20%5Cover%20%7CD_%5Cbeta%7C%7D%20%5Cgeq%20%5Ctau%5C%20%28where%5C%20%5Ctau%5C%20is%5C%20core%5C%20ratio%29" alt=""></p>

<p>그리고 패턴 <code>α</code> 에서 <code>d</code> 만큼의 아이템을 제거해도, 여전히 <em>τ-core pattern of α</em> 이면 <code>α</code> 를 <em>(d, τ)-robust</em> 라 부릅니다. 따라서 <code>d</code> 만큼의 아이템이 있거나 없어도, 코어패턴이므로 전체 숫자는 <code>2^d</code> 만큼의 코어패턴을 만들 수 있습니다.</p>

<p>그러므로 <em>colossal pattern</em> 이라면, 정말 많은 수의 <em>core pattern</em> 을 만들 수 있습니다. 그리고 이런 <em>core pattern</em> 은  <em>distance</em> 가 충분히 작으므로 <em>dense ball</em> 형태로 뭉칩니다. 결과적으로 <em>random pattern space</em> 에서 패턴을 뽑으면, <em>dense ball</em> 내의 패턴일 확률이 굉장히 높습니다.</p>

<p>이를 기반으로한 <em>Pattern-Fusion Algorithm</em> 은</p>

<ol>
<li><p><strong>Initialize (creating initial pool)</strong>: </p></li>
<li><p>Use an existing algorithm to min all frequent patterns up to a small size (e.g 3)</p></li>
<li><p><strong>Iteration (iterative pattern fusion):</strong> </p></li>
<li><p>At each iteration, <code>K</code> seed patterns are randomly picked from the current pattern pool</p></li>
<li>For each seed pattern thus picked, we find all the patterns within a bounding ball centered at the seed pattern</li>
<li>All these patterns found are fused tohether to generate a set of super-patterns</li>
<li><p>All the super-patterns thus generated form a new pool for the next iteration</p></li>
<li><p><strong>Termination:</strong></p></li>
<li><p>when the current poll contains no more than <code>K</code> patterns at the beginning of an iteration</p></li>
</ol>

<p><br></p>

<h2 id="6constraintbasedmining">6. Constraint-Based Mining</h2>

<p>이번시간에 배울 내용은 다음과 같습니다.</p>

<ul>
<li>Different Pruning Strategies</li>
<li>Constrainted Mining with Pattern Anti-Monotonicity</li>
<li>Constrainted Mining with Pattern Monotonicity</li>
<li>Constrainted Mining with Data Anti-Monotonicity</li>
<li>Constrainted Mining with Succinct Constraints</li>
<li>Constrainted Mining with Convertible Constraints</li>
<li>Hanlding Multiple Constraints</li>
</ul>

<p>왜 <em>Constraint-Based Mining</em> 이 필요할까요? 데이터셋에 있는 <strong>all</strong> 패턴을 <strong>autonomously</strong> 하게 찾는것은 불가능합니다. 이는 <em>compressed pattern mining</em> 에서 언급했듯이, 너무 많은 패턴이 있기 때문이지요. 특히 데이터셋이 커지면 사용자가 관심 없는 데이터가 기하급수적으로 늘어납니다.</p>

<p>따라서 패턴 마이닝은 사용자가 무엇을 원하는지 <em>data mining query language</em> 나 <em>GUI</em> 를 통해서 직접 명령을 내리는 <em>interactive</em> 한 과정이 되야 합니다.</p>

<p><em>constraints</em> 를 이용하면 다음과 같은 장점이 있습니다.</p>

<ul>
<li><strong>user flexibility:</strong> provides <strong>constraints</strong> on what to be mined</li>
<li><strong>optimization:</strong> explores such constraints for efficient mining</li>
</ul>

<p><br></p>

<h3 id="differentpruning">Different Pruning</h3>

<p><em>constraints</em> 에 따라 <em>pruning strategy</em> 달라집니다.</p>

<p>(1) <strong>pattern space pruning constraints</strong></p>

<ul>
<li><em>anti-monotonic:</em> if constraint <code>c</code> is violated, its further mining can be terminated</li>
<li><em>monotonic:</em> if <code>c</code> is satisfied, no need to check <code>c</code> agina</li>
<li><em>succinct:</em> <code>c</code> can be enforced by directly manipulating the data</li>
<li><em>convertible:</em> <code>c</code> can be converted to monotonic or anti-monotonic if items can be propery ordered in processing</li>
</ul>

<p>(2) <strong>data space pruning constraints</strong></p>

<ul>
<li><em>data succinct:</em> data space can be pruned at the initial pattern mining process</li>
<li><em>data anti-monotonic:</em> if a transaction <code>t</code> doesn't satisfy <code>c</code>, then <code>t</code> can be pruned to reduce data processing effort</li>
</ul>

<p><br></p>

<h3 id="antimonotonicity">Anti-Monotonicity</h3>

<p><em>constaint</em> <code>C</code> 는 다음의 경우에 <em>anti-monotone</em> 이라고 말합니다.</p>

<ul>
<li>If an itemset <code>S</code> <strong>violates</strong> constraint <code>C</code>, so does any of its superset</li>
<li>That is, mining on itemset <code>S</code> can be terminated</li>
</ul>

<p>예를 들어서 다음의 제약조건은 <em>anti-monotone</em> 입니다</p>

<ul>
<li><code>sum(S.price) &lt;= v</code></li>
<li><code>range(S.profit) &lt;= 15</code> </li>
<li><code>support(S) &gt;= k</code></li>
</ul>

<p>따라서 <em>Apriori pruning</em> 은 본질적으론 <em>anti-monotonic constaint</em> 에 기반합니다.</p>

<p>반대로 <code>sum(S.price) &gt;= v</code> 는 <em>not anti-monotone</em> 입니다.</p>

<p><br></p>

<h3 id="monotonicity">Monotonicity</h3>

<p><em>itemset</em> <code>S</code> 가 <em>constaint</em> <code>c</code> 를 만족할때, <code>S</code> 의 <em>superset</em> 도 그러하다면 <code>c</code> 는 <em>monotone</em> 이라 부릅니다. 다음은 모두 <em>monotone</em> 입니다.</p>

<ul>
<li><code>sum(S.price) &gt;= v</code></li>
<li><code>min(S.price) &lt;= v</code></li>
<li><code>range(S.profit) &gt;= 15</code></li>
</ul>

<p><br></p>

<h3 id="dataantimonotonicity">Data Anti-Monotonicity</h3>

<p><em>data anti-monotone</em> 는 <em>transaction</em> 기반으로 <em>pruning</em> 을 진행해 나아갑니다. 정의는 이렇습니다.</p>

<ul>
<li>In the mining process, if a data entry <code>t</code> cannot satisfy a pattern <code>p</code> under <code>c</code>, <code>t</code> cannot satisfy <code>p</code>'s superset either</li>
</ul>

<p>다음은 모두 <em>data anti-monotone</em> 입니다.</p>

<ul>
<li><code>sum(S.price) &gt;= v</code> </li>
<li><code>min(S.price) &lt;= v</code></li>
<li><code>range(S.profit) &gt;= 25</code></li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/pattern-discovery/week2/data_anti_monotone.jpg" alt=""></p>

<p><br></p>

<h3 id="succinctconstaints">Succinct Constaints</h3>

<p><em>succintness</em> 는 <em>data space</em> 와 <em>pattern space</em> 를 모두 <em>pruning</em> 합니다.</p>

<blockquote>
  <p>if the constaint <code>c</code> can be enforced by directly manipulating the data</p>
</blockquote>

<p>(1) To find those patterns without item <code>i</code></p>

<p><em>pattern space pruning</em> 처럼 <code>i</code> 을 DB 에서 제거합니다.</p>

<p>(2) To find those patterns containing item <code>i</code></p>

<p><em>data space pruning</em> 처럼 <em>i-projected</em> DB 만 마이닝 합니다.</p>

<p>(3) <code>min(S.price) &lt;= v</code> is succinct</p>

<p><code>price &lt;= v</code> 에서 시작해서, <em>high-price item</em> 을 제거해 나가기 때문에 <em>pattern + data space pruning</em> 입니다.</p>

<p>(4) <code>sum(S.price) &gt;= v</code> is not succinct</p>

<p><em>itemset</em> <code>S</code> 의 <em>sum</em> 이 점점 크기때문에, 미리 제거할 수 없습니다.</p>

<p><br></p>

<h3 id="convertibleconstaints">Convertible Constaints</h3>

<blockquote>
  <p>Convert tough constaints into (anti-) monotone by proper ordering of items in transactions</p>
</blockquote>

<p><code>avg(S.profit) &gt; 20</code> 같은 경우는 <em>anti-monotone</em> 도 <em>monotone</em> 도 아닙니다. </p>

<ul>
<li>만약 현재 만족한다고 했을때, 아주 작은 <code>profit*</code> 을 가지는 아이템을 추가하면 <em>violation</em> 이고,</li>
<li>만약 현재 위반한다고 했을때, 아주 큰 값을 추가하면 <em>satisfaction</em> 이기 때문입니다.</li>
</ul>

<p>이런 <em>constaint</em> 에 대해서도 <em>pruning advantage</em> 를 얻고자 하는것이 바로 <em>convertible constaints</em> 의 목적입니다. 가능하면 <em>anti-monotone</em> 이 더 선호되는데, 이는 <em>monotone</em> 일 경우 검사만 하지 않고, <em>anti-monotone</em> 일 경우 <em>super-pattern</em> 을 날려버릴 수 있기 때문입니다.</p>

<ul>
<li>만약 <code>c: avg(S.profit &gt; 20)</code> 에 대해서 </li>
<li><em>itemset</em> 을 내림차순으로 <code>S: {a, g, f, b, h, d, c, e}</code> 정렬하고 </li>
<li><code>avg(ab) = 20</code>, <code>g = 20</code> 이면</li>
</ul>

<p><em>constaint</em> <code>C</code> 는 <em>anti-monotone</em> 이라 할 수 있습니다. 왜냐하면 패턴 내부가 <code>profit</code> 을 기준으로 내림차순으로 되어서, 어떤 <em>item entry</em> 를 뽑아도 <code>c</code> 를 만족할 수 없기 때문입니다.</p>

<p>아쉽게도 이 방법은 <em>level-wise candidate generation</em> 을 하는 <em>Apriori</em> 알고리즘엔 적용되지 않습니다.</p>

<p><br></p>

<h3 id="hanldingmultipleconstaints">Hanlding Multiple Constaints</h3>

<p>다수개의 <em>constaints</em> 를 사용하는것은 좋으나, <em>item ordering</em> 에서 충돌이 생길 수 있습니다. 이럴땐 먼저 하나의 <em>constaint</em> 기준으로 정렬하고, 나머지는 <em>projected databases</em> 를 마이닝할때 하면 좋습니다.</p>

<p>예를 들어 다음 두개의 <em>constaints</em> 가 있을때</p>

<ul>
<li><code>c1: avg(S.profit) &gt; 20</code></li>
<li><code>c2: avg(S.price) &lt; 50</code></li>
</ul>

<p><code>c1</code> 이 더 강력한 <em>pruning power</em> 가 있다고 생각하고, <code>c1</code> 먼저  <em>anti-monotone</em> 으로 변경 한 후, 각 <em>projected-DB</em> 에서 트랜잭션을 오름차순으로 정렬해 <code>c2</code> 를 마이닝에 이용합니다.    </p>

<p><br></p>

<h3 id="refs">Refs</h3>

<p>(1) <a href="https://www.behance.net/gallery/625042/Icon-and-pattern-with-a-marketing-theme">Title image</a> <br>
(2) <strong>Pattern Discovery</strong> by <em>Jiawei Han</em> </p>]]></content:encoded></item></channel></rss>