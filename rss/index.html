<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Old Lisper]]></title><description><![CDATA[Lisp, Emacs, Scala]]></description><link>http://1ambda.github.io/</link><generator>Ghost 0.5</generator><lastBuildDate>Fri, 10 Oct 2014 14:33:01 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Programming Language, Week1]]></title><description><![CDATA[<p><strong>Programming Language</strong> by <em>Dan Grossman</em>, Coursera</p>

<p><em>Coursera</em> PL 클래스인데 과제 마감기한도 까다롭고, 동료평가도 있고, 여러모로 조금 빡세다. 유일한 낙은 언어의 다양한 특징들을 탐구하기 위해 <strong>ML</strong> 을 사용하고 <del>오오 갓 ML</del> , emacs 를 사용한다는 건데.. 잘 버틸수 있을까 의심스럽다. 무려 첫 강의부터 대략 300분이 넘는 동영상을 올려주시는 교수님 -_-;</p>

<p>미국 CS 전공자들은 모두 이렇게 빡세게 배우는가요 ㅠㅠ?</p>

<p><code>SML/nj</code> 와 Emacs 에 <code>sml-mode</code> 설치 후 시작한다. <code>c-c, c-s</code> 는 <code>REPL</code> 을 켠다. </p>

<h3 id="mlvariablebindingsandexpressions">ML Variable Bindings and Expressions</h3>

<pre><code class="sml">(* This is a comment. *)

val x = 34;  
(*: static env: x : int *)
(*: dynamic env: x --&gt; 34 *)
val y = 35 : int;  
val z = (x + y) + (y + 2);  
</code></pre>

<p>각 라인마다, <em>dynamic environment</em> 에 바인딩을 하나씩 추가한다. 따라서 세번 째 라인에서 <code>x</code> 와 <code>y</code> 를 <code>z</code> 를 바인딩하기 위해 사용할 수 있다.</p>

<p>그리고, <em>dynamic env</em> 에 바인딩을 추가하기 전에 <em>static enviornment</em> 에 <em>Type</em> 을 추가한다. 맨 처음엔 <code>x: int</code> 가 추가되고 <code>y</code> 와 값이 바인딩 되기 전에는 <code>x: int, y: int</code> 가 <em>static env</em> 에 추가된다.</p>

<p>따라서 매 라인마다 <em>type checking</em> 이 먼저 일어나고 그 후에야 프로그램이 <em>evaluated (excuted)</em> 된다. </p>

<p><em>ML</em> 에서 <code>if</code> 는 다음과 같이 작성할 수 있다. 다르 언어와 비슷하다.</p>

<pre><code class="sml">val abs_of_z = if z &lt; 0 then 0 - z else z;  
</code></pre>

<p>여기서 잠깐 <em>Syntax</em> 와 <em>Semantics</em> 를 정리하자면</p>

<blockquote>
  <p><strong>Syntax</strong> is just how you write something<br/></p>
  
  <p><strong>Semantics</strong> is what that something means<br/>
  - <em>Type-checking</em> (before program runs)<br/>
  - <em>Evaluation</em> (as program runs)  </p>
</blockquote>

<p><em>variable binding</em> 에서는, <em>type checking</em> 은 <em>static environment</em> 를 확장하고, <em>evaluation</em> 은 <em>dynamic environment</em> 를 확장한다.</p>

<h3 id="rulesforexpressions">Rules for Expressions</h3>

<p><em>expression</em> 은 <em>sub-expression</em> 을 가질 수 있기 때문에, <em>expression</em> 을 해석 하는데 있어서 3가지가 꼭 필요하다.</p>

<p>(1) <strong>Syntax</strong> <br />
(2) <strong>Type-checking rules:</strong> produces a type of fails <br />
(2) <strong>Evaluation rules:</strong> produces a value</p>

<p>다시 말하면 <em>Syntax</em> 와 <em>Semantics</em> 가 필요하단 이야기다.</p>

<h4 id="variables">Variables</h4>

<blockquote>
  <p><strong>Syntax:</strong> sequence of letters, digits, _, not starting with digit</p>
  
  <p><strong>Type-checking:</strong> look up type in current statix env if
  non there, fail</p>
  
  <p><strong>Evaluation:</strong> look up value in current dynamic env</p>
</blockquote>

<h4 id="addition">Addition</h4>

<p>Addition 의 경우에는 <em>sub-exp</em> 가 있을 수 있다.</p>

<blockquote>
  <p><strong>Syntax:</strong> <code>e1</code> + <code>e2</code> where <code>e1</code> and <code>e2</code> are expressions</p>
  
  <p><strong>Type-checking:</strong> if <code>e1</code> and <code>e2</code> have type <em>int</em> then <em>int</em></p>
  
  <p><strong>Evaluation:</strong> if <code>e1</code> evaluates to <code>v1</code> and <code>e2</code> evaluates to <code>v2</code>, then sum of <code>v1</code> and <code>v2</code></p>
</blockquote>

<h4 id="values">Values</h4>

<p>모든 <em>value</em> 는 <em>expression</em> 이다. 그러나 모든 <em>expression</em> 이 <em>value</em> 인 것은 아니다. 그리고,</p>

<blockquote>
  <p>Every value evaluates to itself in <strong>zero steps</strong></p>
</blockquote>

<p>참고로, <code>()</code> 는 <code>unit</code> 타입을 가진다.</p>

<h4 id="conditional">Conditional</h4>

<blockquote>
  <p><strong>Syntax:</strong> if <code>e1</code> then <code>e2</code> else <code>e3</code> where if, then, and else are keywords and <code>e1</code> <code>e2</code> and <code>e3</code> are sub-expressions</p>
  
  <p><strong>Type-checking:</strong> <code>e1</code> must have type <code>bool</code>. <code>e2</code> and <code>e3</code> can have any type, but they must have the same type</p>
  
  <p><strong>Evaluation:</strong> first evaluate <code>e1</code> to <code>v1</code>, if it's true evaluate <code>e2</code> and that resut is the whole expressions's result else evaluate <code>e3</code></p>
</blockquote>

<h3 id="replanderrors">REPL and Errors</h3>

<h4 id="use">use</h4>

<p><code>use</code> 는 특정 파일을 읽어 <em>binding</em> 하고 <code>it: unit</code> 을 돌려주는데, 이건 무시해도 된다. 그리고 같은 파일을 <code>use</code> 할때는 항상 <code>REPL</code> 을 다시 시작하자. <code>C-d</code>, <code>C-c, C-s</code></p>

<h4 id="error">Error</h4>

<p>대부분의 에러는 <em>syntax</em>, <em>type-checking</em>, <em>evaluation</em> 의 문제다.</p>

<h3 id="shadowing">Shadowing</h3>

<p>같은 변수에 대한 <em>multiple binding</em> 은 <em>poor style</em> 이다. 그러나 이를 통해 <em>environment</em> 와 <em>binding</em> 이 어떻게 동작하는지 알 수 있다.</p>

<pre><code class="sml">val a = 10;  
val b = a * 2  
val a = 5; (* this is not an assignment statement *)  
(* a -&gt; 5, b -&gt; 20 *)
val c = 2;  
(* a -&gt; 5, b -&gt; 20, c -&gt; 20 *)
</code></pre>

<p><code>val a = 5</code> 문장은, 할당하는게 아니라 <code>a</code> 를 <em>shadowing</em> 한다. <em>ML</em> 에서는 <em>mutate</em> 할 수 없다. 매번 새롭게 <em>dynamic env</em> 를 만든다.</p>

<pre><code class="sml">val d = a  
(* ..., d -&gt; 5 *)
val a =  a + 1  
(* ..., a -&gt; 6 *)
val f = a * 2  
</code></pre>

<p><code>use</code> 를 이용하면, 기존의 <code>a</code> 의 값이 <code>&lt;hidden-value&gt;</code> 로 나오는 것을 확인 할수 있다.</p>

<pre><code class="sml">val a = 1;  
val b = a;  
val a = 2;  
</code></pre>

<p>다음과 같은 예제가 있을 때, <code>b</code> 는 <code>1</code> 이다. <em>eagerly evaluated</em> 되어 바인딩 후에는 <code>value</code> 를 만든 <em>expression</em> 과는 관련이 없어진다. 다시 말해  바인딩 후에는 <code>a</code> 와 <code>b</code>는 상관이 없다.</p>

<p>그리고 위에서 언급 했듯이 <strong>ML</strong> 에서는 <em>assign to</em> 가 없고, 앞의 <code>a</code> 는 뒤의 <code>a</code> 에가 있는 <em>dynamic env</em> 에 의해서 가려질 뿐이다.</p>

<p>그렇기 때문에 <em>REPL</em> 을 재시작 하지 않고서 같은 파일을 여러번 <code>use</code> 하면 문제가 생길 수 있다고 교수님이 누차 말한 것</p>

<h3 id="functionsinformally">Functions Informally</h3>

<pre><code class="sml">fun pow (x: int, y: int) =  
  if y = 0
  then 1
  else x * pow(x, y-1)

fun cube(x: int)  
  pow(x, 3)
</code></pre>

<p>이 경우 두 함수 모두 타입은 <code>fn: int -&gt; int</code> 다. 타입을 이름 뒤에 사용하는것도 그렇고, 함수 타입도 그렇고 스칼라와 문법이 비슷한 것 같다.</p>

<p><code>*</code> 가 타입에 있을때는 곱셈이 아니라 <code>,</code> 같은 역할을 한다. 따라서 다음과 같이 <code>pow</code> 를 호출할 수 있다.</p>

<pre><code class="sml">val x : int * int = (2, 3)  
val y = pow x  
</code></pre>

<p>참고로, 함수를 사용한 후 정의하는 것은 불가능하다. 따라서 사용하는 <em>expression</em> 위에 함수를 정의해야 한다.</p>

<h4 id="recursion">Recursion</h4>

<p>재귀에 대해서도 간단히 언급을 하는데, 문제를 간단한 방법으로 나누어 푸는 좋은 기술이라고..</p>

<h3 id="functionsformally">Functions Formally</h3>

<p>우리가 <strong>Function</strong> 이 무엇인지 PL 에서 정의하려면 위에서 언급했듯이 <em>syntax</em> 와 <em>semantics</em> 가 필요하다. </p>

<blockquote>
  <p><strong>Syntax:</strong> <code>fun x0 (x1: t1, ... , xn: tn) = e</code></p>
  
  <p><strong>Evaluation:</strong> A function is a value. <code>x0</code> is added to <em>dynamic env</em></p>
  
  <p><strong>Type-checking:</strong> <code>(t1 *, ..., * tn) -&gt; t</code></p>
</blockquote>

<p>타입체킹이 조금 복잡한데, <code>e</code> 가 <code>t</code> 타입을 가지는지 검사하고, 파라미터도 마찬가지로 올바른 타입을 가지는지 검사한다.</p>

<p>다른 언어와 마찬가지로 <code>t1</code> 등의 파라미터는 <code>e</code> 를 위한 <em>environment</em> 에만 추가된다.</p>

<p><code>x0</code> 이 <em>dynamic</em>, <em>static env</em> 에 추가되므로 이후의 코드에서 <em>recursion</em> 을 사용할 수 있다.</p>

<h4 id="functioncalls">Function calls</h4>

<p><em>Function calls</em> 의 <em>syntax</em> 는 <code>e0 (e1, ..., en)</code> 이다. 만약에 인자가 하나라면 괄호(parentheses) 는 없어도 된다.</p>

<p>참고로 <strong>ML</strong> 에서는 <strong>variable numbers of arguments</strong> 를 함수에서 받을 수 없다. 인자의 개수가 정해져야 한다.</p>

<p><em>type-checking</em> 의 경우에는 , <code>e0</code> 이 <code>(t1 * ... * tn) -&gt; t</code> 인지 검사하고 <code>en</code> 이 <code>tn</code> 타입을 가지면, <code>e0</code> 은 <code>t</code> 타입이다. </p>

<p><em>Evaluation</em> 스텝은 다음과 같다.</p>

<p>(1) evaluate <code>e0</code> to <code>fun x0(x1: t1, ... , x: tn) = e</code> <br />
(2) evaluate arguments <code>e1</code>, ... , <code>en</code> to <code>v1</code>, ..., <code>vn</code> <br />
(3) extend <em>dynamic env</em> mapping <code>x1</code> to <code>v1</code> , ... , <code>xn</code> to <code>vn</code></p>

<p>두 번째 스텝에서는 <em>eager evaluation</em> 이 사용되는데 <code>pow(2, 2+2)</code> 같은 경우 인자가 <code>2, 4</code> 가 된다. </p>

<p>세 번째 스텝에서는 <em>dynamic environment</em> 를 확장하는데, 현재 함수인 <code>x0</code> 과 인자들인 <code>xn</code> 을 포함하도록 한다. 따라서 <em>recursion</em> 이 가능하다.</p>

<p>사실은 스칼라의 그것과 같은데 교재에 나온 설명이 너무 함축적이어서 이해하기가 어렵다.</p>

<h3 id="pairsandothertuples">Pairs and Other Tuples</h3>

<p>위에서 잠깐 보았던 <code>t1 * t2</code> 같은 것들이 <em>Pair</em> 다. 다른말로 <em>2-tuples</em> 라 부른다. </p>

<p><em>Syntax</em> 는 <code>(e1, e2)</code> 로 <em>Type-checking</em> 은 <code>e1</code> 과 <code>e2</code> 가 올바른 타입을 가졌는지 검사한다.</p>

<p><em>Pair</em> 에 접근할때는 <code>#1 e</code> 또는 <code>#2 e</code> 와 같은 <em>Syntax</em> 를 사용하고, <code>e</code>가 <code>t1 * t2</code> 타입인지, 그 후에 <code>#1 e</code> 가 <code>t1</code> 또는 <code>#2 e</code> 가 <code>t2</code> 타입을 가졌는지 검사한다.</p>

<pre><code class="sml">fun su_two_pairs (pr1: int * int, pr2: int* int) =  
  (#1 pr1) + (#2 pr1) + (#1 pr2) + (#2 pr2)
</code></pre>

<p>의 경우에는 타입이 <code>(int * int) * (int * int) -&gt; int</code> 된다. 그리고 다른 언어와 마찬가지로 <em>tuple</em> 도 겹칠 수 있다.</p>

<pre><code class="sml">val x1 = (7, (true, 9)) // int * (bool * int )  
val x2 = #1 (#2 x1) // true  
</code></pre>

<h3 id="introducinglists">Introducing Lists</h3>

<p><em>Tuple</em> 은 여러 타입을 가질 수 있지만, 정해진 갯수만큼의 element 만 저장할 수 있다. 반면 <em>List</em> 는 하나의 타입만 가져야 하지만, 원소의 갯수가 변할 수 이다.</p>

<p>빈 리스트는 <code>[]</code> 와 같이 만든다. <code>[3, 4, 5]</code> 는 <code>int list</code> 다. <code>[(1+2), 3, 7]</code> 과 같이 초기화하면 <code>[3, 3, 7]</code> 이 나온다. 리스트는 그 자체로 <em>value</em> 다.</p>

<p><code>::</code> 는 <em>cons</em> 라 발음하고, 다음과 같이 쓸 수 있다.</p>

<pre><code class="sml">val x = [3, 4, 5]  
val y = 2 :: x  
</code></pre>

<p><em>cons</em> 뒤에 오는것은 <code>List</code> 여야 한다. 리스트가 비었는지 검사하기 위해 <code>null</code> 을, <em>head</em> 를 얻기 위해 <code>hd</code> 를, <em>tail</em> 을 얻기 위해 <em>tl</em> 을 이용한다. 따라서 <code>tl [3, 4, 5]</code> 는 <code>[4, 5]</code> 를 돌려준다.</p>

<p>그리고 다른 함수형 언어와 마찬가지로 <code>tl [9]</code> 는 <code>[]</code>(<em>nil</em>) 이다.</p>

<p>리스트는 다양한 타입을 가질 수 있기 때문에 <code>(int * int) list</code> 같은 것도 타입이 될 수 있다. <code>[(3, 4), (5, 6)]</code> 처럼.</p>

<p><code>null</code> 은 <code>fn: a list -&gt; bool</code> 타입이고, 
<code>hd</code> 는 <code>fn: a list -&gt; a</code>, 
<code>tl</code> 은 <code>fn: a list -&gt; a list</code></p>

<p><code>[]: a list</code> 는 좀 특이한데, 다양한 타입이 될 수 있다. <code>3 :: []</code>, <code>false :: []</code> 이라던지.</p>

<h3 id="listfunctions">List Functions</h3>

<p>리스트를 조작하는 간단한 함수를 <em>ML</em> 로 몇 개 짜보자.</p>

<pre><code class="sml">fun pow(x: int, y: int) =  
    if y = 0 then 1 else x * pow(x, y - 1);

fun cube(x: int) =  
    pow(x, 3);

fun sum_list(xs: int list) =  
    if null xs
    then 0
    else hd xs + sum_list(tl xs)

fun product_list(xs: int list) =  
    if null xs
    then 1
    else hd xs * product_list(tl xs)

fun countdown(x: int) =  
    if x = 0
    then []
    else x :: countdown(x - 1)

fun append(xs: int list, ys: int list) =  
    if null xs
    then ys
    else (hd xs) :: append(tl xs, ys)

fun sum_pair_list(xs: (int * int) list) =  
    if null xs
    then 0
    else (#1 (hd xs)) + (#2 (hd xs)) + sum_pair_list(tl xs)

fun firsts(xs: (int * int) list) =  
    if null xs
    then []
    else #1 (hd xs) :: firsts(tl xs)

fun seconds(xs: (int * int) list) =  
    if null xs
    then []
    else #2 (hd xs) :: seconds(tl xs)

fun sum_pair_list(xs: (int * int) list) =  
    if null xs
    then 0
    else sum_list(firsts xs) + sum_list(seconds xs)

fun factorial(n : int) =  
    product_list(countdown(n))
</code></pre>

<p>참고로 <code>#</code> 이 <code>+</code> 이나 <code>::</code> 보다 우선순위가 높다.</p>

<h4 id="listrecursion">List Recursion</h4>

<p>재귀에 대해 생각할땐, 항상 명심해야 하는게 있는데 <strong>탈출 조건</strong> 이다. 따라서 empty-list 에 대해선 어떤걸 돌려줄지, non-empty-list 에 대해서는 무엇을 처리해야 할지 항상 생각해야 한다.</p>

<h3 id="letexpressions">Let Expressions</h3>

<p><code>let</code> 은 <em>local variable</em> 을 바인딩하는 법이다.</p>

<blockquote>
  <p><strong>Syntax:</strong> <code>let b1 b2 ... bn in e end</code>. Each <code>b1</code> is any <em>binding</em> and <code>e</code> is any expression</p>
  
  <p><strong>Type-checking:</strong> Type of whole let-expression is the type of e. Type-check each <code>b1</code> and <code>e</code> in a staic env that includes the previous bindings</p>
  
  <p><em>*Evaluation: *</em> evaluate each <code>b1</code> and <code>e</code> in a dynamic env that includes the previous bindings. Result of whole expression is result of evaluating <code>e</code></p>
</blockquote>

<pre><code class="sml">fun silly () =  
    let
      val x = 3
    in
      (let val x = 2 in x + 1 end) + (let val y = x + 1 in y + 1 end)
    end
</code></pre>

<p>여기서 <em>Scope</em> 의 개념이 나온다.</p>

<blockquote>
  <p><strong>Scope:</strong> Where a binding is in the environment</p>
</blockquote>

<h4 id="nestedfunctions">Nested Functions</h4>

<p><em>Function</em> 은 <em>binding</em> 이다. 따라서 <code>let</code> 내부에서 <em>local binding</em> 할 수 있다.</p>

<pre><code class="sml">fun count_from_1 (x: int) =  
    let
    fun count (from: int, to: int) =
        if from == to
        then []
        else from :: count(from + 1, to)
    in
    count(1, x)
    end
</code></pre>

<p>이렇게 하면 <em>top-level</em> 에서 <code>count</code> 는 사라진다. 그리고 엄밀히 말해서 <code>count</code> 가 가진 <em>environment</em> 에는 <code>to</code> 가 있기 때문에, <code>to</code> 를 인자로 가질 필요가 없다.</p>

<pre><code class="sml">fun count_from_1 (x: int) =  
    let
    fun count (from: int) =
        if from = x
        then []
        else from :: count(from + 1)
    in
    count(1)
    end
</code></pre>

<h3 id="letandefficiency">Let and Efficiency</h3>

<p>가장 큰 숫자를 찾는 다음의 함수를 고려 해 보자</p>

<pre><code class="sml">fun bad_max (xs : int list) =  
  if null xs
  then 0
  else if null (tl xs)
  then hd xs
  else if hd sx &gt; bad_max(tl xs)
  then hd xs
  else bad_max(tl xs)
</code></pre>

<p>이 함수는 <code>[1, 2, ... , 30]</code> 과 같은 리스트에 굉장히 나쁜 성능 <em>exponentially (2^30)</em> 을 보여준다. <code>bad_max(tl xs)</code> 를 두번 호출하기 때문이다. 따라서 <code>max(tl xs)</code> 를 변수로 놓아 캐싱하면</p>

<pre><code class="sml">fun good_max (xs: int list) =  
    if null xs then 0
    else if null (tl xs) then hd xs
    else
    let
        val res = good_max(tl xs)
    in
        if hd xs &gt; res then hd xs
        else res

    end
</code></pre>

<p><code>bad_max</code> 의 <code>if-then-else</code> 가 10^-7 정도의 시간이 든다고 하면, <code>[1, 2, ..., 55]</code> 는 100년이 넘게 걸린다. 따라서 재귀를 구현하는데 있어서 <em>local binding</em> 은 필수다.</p>

<h3 id="options">Options</h3>

<p>참고로, <code>good_max</code> 는 리스트가 모두 음수일때 <code>0</code> 을 돌려준다. 이건 리스트가 비었을때 <code>0</code> 을 돌려주기 때문에 생기는 문제인데, <code>0</code> 말고 다른 무언갈 돌려줄 수 없을까?</p>

<p><em>SML</em> 도 <em>Scala</em> 처럼 <em>Option</em> 을 지원한다.(물론 <em>SML</em> 이 먼저..) <code>NONE</code> 은 <code>a option</code> 타입이고, <code>SOME e</code> 는 <code>t option</code> 이다. <code>t</code> 는 <code>e</code> 의 타입.</p>

<p><em>Option</em> 을 이용해 <code>max</code> 를 리팩토링 해 보면,</p>

<pre><code class="sml">fun max1 (xs: int list) =  
  if null xs NONE
  else 
    let val res = max(tl xs)    
    in if isSome res andalso isVal res &gt; hd xs then res
       else Some(hd xs) 
    end
</code></pre>

<p>그런데, 이 <code>max1</code> 또한 문제가 있다. 사실 <code>[]</code> 는 리스트가 오름차순으로 구성되어있을때 (<code>[1, 2, 3, 4]</code>) 맨 마지막 호출에서만 오는데, 매번 <code>isSome</code> 으로 검사하니까 비효율적이다. 다시 리팩토링하면</p>

<pre><code class="sml">fun max2 (xs: int list) =  
    if null xs then NONE
    else
    let
        fun max_non_empty(ys: int list) =
        if null (tl ys) then hd ys
        else
            let val res = max_non_empty(tl ys)
            in if hd xs &gt; res then hd ys
               else res
            end
    in
        SOME (max_non_empty xs)
    end
</code></pre>

<p><del>교수님 <code>let in end</code> 는 제발그만 가..가독성이</del></p>

<h3 id="booleansandcomparisonoperations">Booleans and Comparison Operations</h3>

<p>다른 언어의 <em>&amp;&amp; (and)</em> 와 <em>|| (or)</em> <em>! (not)</em> 은 <em>SML</em> 에서는 <code>ansalso</code>, <code>orelse</code>, <code>not</code> 이다.</p>

<p>그리고 <code>andalso</code>, <code>orelse</code> 연산자는 다른 언어처럼 <em>Short circuiting</em> 을 제공한다. 함수가 아니다.   </p>

<p><code>andalso</code> 와 <code>orelse</code>, <code>not</code> 은 다음처럼 쓸 수도 있다.</p>

<pre><code class="sml">(* andalso *)
if e1  
then e2  
else false

(* orelse *)
if e1  
then true  
else e2

(* not *)
if e1  
then false  
else true  
</code></pre>

<p><code>if-then-else</code> 만 가지고도 할 수 있으나, 그냥 <code>andalso</code> 와 <code>orelse</code>, <code>not</code> 을 쓰는게 코드를 읽는 사람의 정신 건강에 좋다. </p>

<h4 id="comparisons">Comparisons</h4>

<p>비교의 경우엔 <code>==</code> 가 아니라 <code>=</code> 를 쓴다. <code>!=</code> 가 아니라 <code>&lt;&gt;</code> 를 쓴다. </p>

<p>그리고 <code>3.0 &gt; 2</code> 와 같은 비교는 안된다.<code>3.0</code> 은 <code>real</code> 이고, <code>2</code> 는 <code>int</code> 다 <code>Real.fromInt</code> 를 이용하자.</p>

<h3 id="nomutation">No Mutation</h3>

<p>교수님이 <em>A valuable non-feature</em> 라고 이야기 하시는데, 기능이 없는게 장점이라고.. <em>SML</em> 에서는 아래의 두 코드가 같다. (<em>inditinguishable</em>)</p>

<pre><code class="sml">fun sort_pair(pr: int * int) =  
  if #1 pr &lt; #2 pr then pr
  else (#2 pr, #1 pr)

fun sort_pair(pr: int * int) =  
  if #1 pr &lt; #2 pr then (#1 pr, #2pr)
  else (#2 pr, #1 pr)
</code></pre>

<p>위가 더 나은 <em>style</em> 이라고 주장할 순 있지만, 다르다고 말할 순 없다. 그러나 <em>mutable compound data</em> 를 다루는 다른 언어에서는 위 두 함수는 다르다</p>

<p>예를 들어서 <em>mutable data</em> 를 다루는 언어라 가정하고 다음의 코드를 고려 해 보자.</p>

<pre><code class="sml">val x = (3, 4)  
val y = sort_pair x

(* somehow mutate #1 x to hold 5 *)

val z = #1 y  
</code></pre>

<p>이제 <code>z</code> 의 값은 무엇일까? <code>sort_pair</code> 구현에 따라 다르다. <code>then</code> 에서 <code>pr</code> 을 돌려줬다면, <code>5</code> 일거고, <code>(#1 pr, #2 pr)</code> 을 돌려줬다면 <code>3</code> 일거다. 그러나 <em>ML</em> 에선 문제가 안된다. <em>immutable</em> 하니까. <del>오오 immutable 오오</del></p>

<blockquote>
  <p>But <strong>without mutation</strong>, we can implement either way <br/><br/>
  - No code can ever distinguishe aliasing vs identical copies <br />
  - No need to think about aliasing: focus on other things <br />
  - Can use aliasing, which saves space, without danger</p>
</blockquote>

<p><em>ML</em> 에서는 <code>tl</code> 이 상수 시간내에 이뤄진다. 첫번째 원소를 제외한 나머지를 가리키기만 하면 되니까. 어차피 그 데이터는 <em>immutable</em> 이니까 그냥 쓰기만 하면 된다. 변경이 필요하면, 그 때 새로 만들면 된다.</p>

<h3 id="javamutation">Java Mutation</h3>

<pre><code class="java">public String[] getAllowedUsers() {  
  // return a references of allowedUsers
}
</code></pre>

<p><code>allowedUsers</code> 자체가 <code>private</code> 여도, 다음과 같은 코드에 취약하다.</p>

<pre><code class="java">p.getAllowedUsers()[0] = p.currentUser();  
p.useTheResource();  
</code></pre>

<p>따라서 위의 <code>getAllowedUsers</code> 는 <em>copy</em> 를 돌려줘야한다. </p>

<p><em>ML</em> 같은 <em>immutable</em> 한 언어에서는 <em>Reference (Alias)</em> vs <em>Copy</em> 는 문제가 안된다.</p>

<h3 id="piecesofalanguage">Pieces of a Language</h3>

<p>언어를 배울때는 다음의 다섯가지를 고려해야한다.</p>

<p>(1) <strong>Syntax:</strong> How do you write language constructs? <br />
(2) <strong>Semantics:</strong> What do programs mean? (Evaluation rules) <br />
(3) <strong>Idioms:</strong> What are typical patterns for using language features to express your computation <br />
(4) <strong>Libraries:</strong> What facilities does the language provide <strong>standard</strong>? <br />
(5) <strong>Tools:</strong> What do language implementations provide to make your job easier? (REPL debugger..)  </p>

<p>다시 말하면 다섯가지를 모두 배워야 한다. 언어의 코어부터 그 확장인 라이브러리와 툴까지. 그러나 이 코스에서는 <em>Semantics</em> 와 <em>Idioms</em> 에 집중한다. <em>ML</em> 을 고른것도 그 이유고, 이걸 잘 이해하게 되면 <em>Libraries</em> 가 어떻게 구성되었는지 더 잘 이해할 수 있다.</p>

<h3 id="summary">Summary</h3>

<p>처음엔 재귀가 어려웠는데, 시간이 지날수록 재귀가 얼마나 재밌고 강력한지 알게 된다. 함수를 <em>building block</em> 처럼 조립하는것도 너무 재밌고</p>

<p>Lisp 을 이용했으면 개인적 취향에 맞아 더 재밌게 배울 수 있었을텐데. 나중에 수업이 모두 끝났을때 <em>ML</em> 을 고른 이유를 느낄 수 있었으면 좋겠다.</p>

<p>그리고 Emacs <em>sml-mode</em> 가 좀.. 음.. 빈약한데 더 좋은걸 찾아야겠다. <em>MELPA</em> 엔 없던데.. 테스팅 프레임워크도 좀 찾아서 해보고. </p>]]></description><link>http://1ambda.github.io/programming-language-week1/</link><guid isPermaLink="false">30e30421-f55b-48df-b96b-a19a661c143f</guid><category><![CDATA[coursera]]></category><category><![CDATA[programming language]]></category><category><![CDATA[ml]]></category><category><![CDATA[emacs]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 10 Oct 2014 06:26:00 GMT</pubDate></item><item><title><![CDATA[Machine Learning, Week 2]]></title><description><![CDATA[<p><strong>Machine Learning</strong> by Andrew Ng, <em>Coursera</em></p>

<h2 id="linearregressionwithmultiplevariables">Linear Regression with Multiple Variables</h2>

<h3 id="mutiplefeatures">Mutiple Features</h3>

<p>변수가 적을때는 <em>Hypothesis</em> 가 간단하다. 많으면 어떻게 될까? <em>Feature</em> 가 <code>N+1</code> 개라면,</p>

<p><img src='http://bt22dr.files.wordpress.com/2013/05/04_2.png?w=300&amp;h=19'  align="center" />  </p>

<p align="center"><a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com</a></p>

<p>편의상 <code>x_0 = 1</code> 이라 두면, <em>Hypothesis</em> 는 <em>Zero-based index</em> 인 <code>n+1</code> 벡터 <code>h</code> 와 <code>x</code> 의 곱이다. 따라서 <code>h(x) = h_t * x</code> 로 표기할 수 있다. 이걸 <strong>Mutivariate linear regression</strong> 이라 부른다.</p>

<h3 id="gradientdescentformultiplevariables">Gradient Descent for Multiple Variables</h3>

<p><em>Cost function</em> 은 다음과 같다. 변수의 subscript 는 <code>j</code> 번째 <em>Feature</em> 를, superscript 는 <code>i</code> 번째 데이터임을 말한다.</p>

<p><img src='http://bt22dr.files.wordpress.com/2013/05/04_6.png'  align="center" />  </p>

<p align="center">(<a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com/</a>)</p>  

<p><br/></p>

<p>다음은 <em>Gradient Descent</em> 알고리즘을 구하는 정의다.</p>

<p><img src='http://bt22dr.files.wordpress.com/2013/05/04_7.png?w=300&amp;h=104'  align="center" />  </p>

<p align="center">(<a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com/</a>)</p>  

<p><br/></p>

<p>따라서</p>

<p><img src='http://bt22dr.files.wordpress.com/2013/05/04_8.png?w=630&amp;h=354'  align="center" />  </p>

<p align="center">(<a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com/</a>)</p>

<h3 id="featurescaling">Feature Scaling</h3>

<p><em>Feature</em> 간 데이터 크기가 많이 차이가 나면, <em>Gradient Descent</em> 에서 등고선 간 간격이 좁으므로, <em>Global optima</em> 를 찾는데 오래걸릴 수 있다. 따라서 <em>Feature</em> 값을 <code>m</code> 으로 나누거나  -1 과 1 사이로 <em>scaliing</em> 할 수 있다. 거꾸로 말하면, <em>Feature scaling</em> 을 이용하면 <em>Gradient descent</em> 가 결과값을 더 빠르게 찾는다.</p>

<p><img src='http://i.stack.imgur.com/4RBjR.png'  align="center" /></p>

<p>또한 <strong>Mean normalization</strong> 을 이용할 수 있는데, 모든 <em>feature</em> 에서 평균을 빼서, 평균을 0 으로 만드는 방법이다.</p>

<p>더 일반적인 방법은 <em>mean normalization</em> 을 하고, 거기에 <code>max-min</code> 또는 <em>standard deviation</em> 으로 나누는 방법이다.</p>

<h3 id="learningrate">Learning Rate</h3>

<p>디버깅 팁 중 하나는, 우리가 작성한 <em>Gradient descent</em> 알고리즘이 매 <em>interation</em> 마다 줄어들어야 한다는 것이다.</p>

<p><img src='http://d37rcl8t6g8sj5.cloudfront.net/wp-content/uploads/gradient_descent_error_by_iteration.png'  align="center" />  </p>

<p align="center">(<a href='http://spin.atomicobject.com/' >http://spin.atomicobject.com</a>)</p>

<p>그리고, 어느 지점에선가 <em>converged</em> 되는지 검사하기 위해 <em>automatic convergence test</em> 를 사용할 수 있다. 예를 들어 한 이터레이션에서, 10^-3 보다 적게 줄어드는지 검사한다거나.</p>

<p>만약에 <em>gradient descent</em> 값이 증가하면, 더 작은 <em>learning rate</em> 를 사용해라. 그렇다고 너무 작은 값을 사용하면 <em>gradient descent</em> 가 느리게 수렴할 수 있다. <em>learning rate</em> 가 너무 크면, 심지어 수렴하지 않을 수도 있다.</p>

<p>따라서 <em>learning rate</em> 를 <code>0.001</code>, <code>0.003</code>, <code>0.01</code>, <code>0.03</code>, <code>0.1</code>, <code>0.3</code>, <code>1</code> 처럼 작은 것부터 선택하되, 천천히 늘려가는 것이 좋다.</p>

<h3 id="polynomialregression">Polynomial Regression</h3>

<p>집값을 예측하기 위해 두개의 <em>feature</em>, <code>frontage</code> 와 <code>depth</code> 가 있다고 하자. 두 값을 곱해 <code>area</code> 라는 새로운 <em>feature</em> 를 만들면, <em>Hypothesis</em> 가 간단해진다. 따라서 기존의 <em>feature</em> 를 이용 할 수 있는지도 잘 알아보는 게 좋다.</p>

<p>자 이제, 집 값(Housing prices) 을 예측하기 위해 <em>Size(Area)</em> 라는 <em>feature</em> 를 이용한다 하자. <em>training set</em> 이 다음과 같을때, </p>

<p><img src='http://www.holehouse.org/mlclass/01_02_Introduction_regression_analysis_and_gr_files/Image.png'  align="center" />  </p>

<p align="center"><a href='http://www.holehouse.org/mlclass' >http://www.holehouse.org/mlclass</a></p>  

<p><br/></p>

<p><em>hypothesis</em> 를 <em>quadratic</em> 로 세우면 어느 지점부터는 예측된 값이 감소하므로 <em>traning set</em> 과 일치하지 않는다. 따라서 <em>cubic</em> 다항식을 이용해 볼 수 있겠는데, <em>feature</em> 가 <code>size</code> 하나 뿐이므로, <em>hypothesis</em> 는 <code>size</code> 를 이용한 삼차식이 되겠다.</p>

<p><img src='http://www.holehouse.org/mlclass/04_Linear_Regression_with_multiple_variables_files/Image%20' [10].png" align="center" />  </p>

<p align="center"><a href='http://www.holehouse.org/mlclass' >http://www.holehouse.org/mlclass</a></p>

<p>이 경우 <code>size</code> 하나로 3개의 <em>feature</em> 를 만들었으니, <em>scaling</em> 이 문제가 될 수 있다.</p>

<p>이 전에 앞서서 <em>feature</em> 가 두개인 <em>hypothesis</em> (quadratic) 은 말이 안된다고 했는데, 두개지만 <em>square</em> 모델을 사용하면 우리가 가진 <em>training set</em> 과 얼추 맞아 떨어지는 모델을 찾을 수 있다. 그림이 없어서 대충 식을 첨부하면,</p>

<p><code>h(x) = y0 + y1(size) + y2 * square(size)</code></p>

<p>여기서 <code>y</code> 는 강의에서 말하는 <code>0(theta)</code> 라 보면 된다.</p>

<h3 id="nomalequation">Nomal Equation</h3>

<p><em>gradient descent</em> 는 반복하면서 특정 값에 수렴해 가는 알고리즘 이었지만 <strong>normal equation</strong> 은 그냥 <code>J(0)</code> 식을 풀어버려 값을 찾아낸다.</p>

<p>예를 들어서 <code>J(0)</code> 가 <code>0(theta)</code> 에 대해  <em>quadratic</em> 이면, <code>0</code> 에 대해 미분해서 최저점을 찾아내면 된다. 문제는, <code>0</code> 가 여러개 일때, 모든 <code>0_j</code> 에 대해 <em>cost function</em> 을 풀어야 한다는 것이다. <em>partial derivative</em> 를 이용해서 해를 찾으면 된다.</p>

<p><img src='http://www.longhaiqiang.com/wp-content/uploads/2013/08/Snip20130817_44.png'  align="center" />  </p>

<p align="center">(<a href='http://www.longhaiqiang.com/' >http://www.longhaiqiang.com/</a>)</p>  

<p><br/></p>

<p>행렬을 이용할 수도 있다. 자세한 건 강의 내용을 보자, <em>design matrix</em> 라고 부르는 <code>X</code> 를 만들어서 아래의 식을 구하면 된다. 사실 <code>X</code> 는 그냥 <em>feature</em> 들을 있는 그대로 행렬로 만들면 된다. 맨 앞에 <code>x0</code> 만 추가해서. </p>

<p><img src='http://www.longhaiqiang.com/wp-content/uploads/2013/08/Snip20130817_41.png'  align="center" />  </p>

<p align="center">(<a href='http://www.longhaiqiang.com/' >http://www.longhaiqiang.com/</a>)</p>

<p>참고로, 저 식을 <em>Octave</em> 에서는 다음과 같이 계산한다.</p>

<pre><code class="octave">pinv(X`*X)*X`*y  
</code></pre>

<p><br/></p>

<p><em>normal equation</em> 을 이용할때는 <em>feature scaling</em> 을 하지 않아도 괜찮다. <em>gradient descent</em> 와 비교해 보자면,</p>

<blockquote>
  <p><strong>Gradient Descent:</strong> <br/>
  (1) <em>learning rate</em> 를 골라야 한다. 
  (2) <em>feature scaling</em> 을 해야할 필요가 있다. <br />
  (3) <em>interation</em> 을 해야하므로 알고리즘이 제대로 돌아가는지 체크해야할 필요가 있다. <br />
  (4) 대신 <code>n</code> 이 커도 잘 돌아간다.</p>
  
  <p><strong>Normal Equation:</strong> <br/>
  (1) <em>learning rate</em> 를 고를 필요가 없다. <br />
  (2) <em>feature scaling</em> 을 해야할 필요가 없다. <br />
  (3) <em>interation</em> 을 하지 않는다. <br />
  (4) <code>n</code> 이 커질경우 굉장히 느려지고 <code>(X^TX)^-1)</code> 을 계산해야 한다.</p>
</blockquote>

<p>따라서 <code>n</code> 이 너무 크지 않으면, 100~1000 정도까지는, <em>normal equation</em> 을 쓰는편이 낫다.</p>

<h3 id="nomalequationnoninvertibility">Nomal Equation Noninvertibility</h3>

<p>만약에, 우리가 가진 <code>X</code> 가 <em>non-invertible</em> 하다면 어떻게 될까? <em>invertible matrix</em> 란, 아래를 만족시키는 <code>B</code> 가 존재하는 행렬이다. <code>I</code> 는 <em>identity matrix</em> 다.</p>

<p><img src='http://upload.wikimedia.org/math/7/3/3/7334597613ae1773c19e1ed1289349db.png'  align="center" />  </p>

<p align="center">(<a href='http://en.wikipedia.org/wiki/Invertible_matrix' >http://en.wikipedia.org/wiki/Invertible_matrix</a>)</p>

<p>만약 저런 <code>B</code> 가 존재하지 않아 <em>non-invertible</em> 한 행렬을 <strong>sigular matrix</strong>, <strong>degenerate matrix</strong> 라 부른다.</p>

<p>우리가 계산해야 할 행렬이 <em>non-invertible</em> 이라면, 두 가지 경우가 있을 수 있는데, </p>

<p>(1) Redundant features(linearly dependent) e.g <code>x1 = (3.28) * x2</code> <br />
(2) too many features e.g <code>m &lt;= n</code></p>

<p>이럴 때는 몇몇 <em>feature</em> 를 삭제하고, <em>regulaization</em> 을 하면 된다. </p>

<h3 id="costfunctionoctave">Cost Function: Octave</h3>

<p><em>cost function</em> 을 구현 해 보면</p>

<pre><code class="matlab">function J = costFunctionJ(X, y, theta)

m = size(X, 1) % number of training examples  
predictions= X * theta; % predictions of hypothesis on all m examples  
sqrErros = (predictions-y).^2;

J = 1 / (2*m) * sum(sqrErros);  
</code></pre>

<p><em>R</em> 이나 이런것들은 행렬연산이 참 쉬운것 같다.</p>

<h3 id="vectorization">Vectorization</h3>

<p><em>Vectorization</em> 을 이용하면, <code>for loop</code> 을 제거할 수 있는데, 예를 들어</p>

<p><img src='http://i.ytimg.com/vi/jRr2XuZOWB8/hqdefault.jpg'  align="center" /></p>

<p>이건 행렬 곱셈이 한번에 이루어진다는 것을 이용한 방법이다. 따라서 <em>gradient descent</em> 알고리즘에서 <code>theta</code> 를 <code>for-loop</code> 으로 구하는 것이 아니라, <em>vectorization</em> 을 이용하면 한번에 계산할 수 있다.</p>

<p>이게 그림을 구하기가 어려운데, 아래첨자(sub-script) 를 이렇게 기술한다고 하자. <code>x_0</code> 그럼, <em>grandient descent</em> 알고리즘 식에서 <em>learning rate</em> 뒷부분이 <em>vector</em> 가 되는데 그 이유는 <code>theta</code> 와 마찬가지로 <code>j</code> 에 대한 나열이기 때문이다.</p>

<p><img src='http://2.bp.blogspot.com/-ZxJ87cWjPJ8/TtLtwqv0hCI/AAAAAAAAAV0/9FYqcxJ6dNY/s1600/gradient+descent+algorithm+OLS.png'  align="center" /></p>

<p>구글에 검색하니까 1번으로 뜨는게 <em>vectorization(parallel computing)</em> 이더라. 병렬 연산에 많이 사용되나보다.</p>

<h3 id="refenrences">Refenrences</h3>

<p>(1) <a href='http://stats.stackexchange.com/questions/111467/is-it-necessary-to-scale-the-target-value-in-addition-to-scaling-features-for-re' >StackExchange</a> <br />
(2) <a href='http://bt22dr.wordpress.com/' >http://bt22dr.wordpress.com/</a> <br />
(3) <a href='http://spin.atomicobject.com/2014/06/24/gradient-descent-linear-regression/' >http://spin.atomicobject.com</a> <br />
(4) <a href='http://www.holehouse.org/mlclass/01_02_Introduction_regression_analysis_and_gr.html' >http://www.holehouse.org/mlclass/</a> <br />
(5) <a href='http://www.longhaiqiang.com/' >http://www.longhaiqiang.com/</a>  </p>]]></description><link>http://1ambda.github.io/machine-learning-week-2/</link><guid isPermaLink="false">78e8635f-a298-477a-8823-0c2738c21251</guid><category><![CDATA[coursera]]></category><category><![CDATA[machine lerning]]></category><category><![CDATA[gradient descent]]></category><category><![CDATA[normal equation]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 08 Oct 2014 10:50:00 GMT</pubDate></item><item><title><![CDATA[Functional Programming in Scala, Chapter 4]]></title><description><![CDATA[<p>2014-10-07, <strong>Functional Programming in Scala</strong>, Coursera</p>

<h2 id="typesandpatternmatching">Types and Pattern Matching</h2>

<h3 id="functionsasobjects">Functions as Objects</h3>

<blockquote>
  <p>In fact function values are treated as objects in Scala</p>
</blockquote>

<pre><code class="scala">trait Function1[A, B] {  
  def apply(x: A): B
}
</code></pre>

<p>결국, <code>function</code> 은 <code>apply</code> 메소드를 가진 오브젝트다.</p>

<p>예를 들어서 <code>(x: Int) =&gt; x * x</code> 는 다음과 같이 <code>Function1</code> ` <em>trait</em> 를 구현한 클래스 된다.</p>

<pre><code class="scala">{
  class AnonFun extends Function1[Int, Int] (
    def apply(x: Int) = x * x
  }

  new AnonFun
}

// or using anonymous class syntax
// trait can be instanciated

new Function1[Int, Int] {  
  def apply(x: Int) = x * x
}
</code></pre>

<p>따라서 이런 정의를 보면, <code>f(a, b)</code> 는 <code>f.apply(a, b)</code> 다. 그런데 만약 메소드인 <code>def apply</code> 자체도 오브젝트일까? 그렇지 않다. 만약 <code>apply</code> 자체도 오브젝트라면, 그 오브젝트도 <code>apply</code> 메소드를 가지고 있어야 하고, 또 다시 그렇게 반복될 수 있다.</p>

<h4 id="functionsandmethods">Functions and Methods</h4>

<p>따라서 <code>def f(x: Int): Int = ...</code> 메소드 자체는 <strong>Function</strong> 이 아니다. (<em>Method != Function</em>) 그러나 </p>

<blockquote>
  <p>If <code>f</code> is used in a place where a <code>Function</code> type is expected, it is converted automatically to the function value</p>
</blockquote>

<p>예를 들어, <code>(x: Int) = f(x)</code> 는 다음과 같이 확장된다.</p>

<pre><code class="scala">new Function1[Int Int] {  
 def apply(x: Int) = f(x)
}
</code></pre>

<p>이렇게 <em>Method</em> 가 <em>Function</em> 으로 변환되는 과정을 <em>lambda calculus</em> 에서는 <strong>eta-expansion</strong> 이라 부른다. </p>

<p>그리고 위에서 보았겠지만 <code>apply</code> 메소드는, 오브젝트에 있을때 오브젝트 이름 자체로 호출될 수 있도록 해준다. 예를들어 지난 시간에 만들었던 <code>List</code> <em>trait</em> 에 대해서,</p>

<pre><code class="scala">trait List[T] {  
  def isEmpty: Boolean
  def head: T
  def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {  
  def isEmpty = false
}

class Nil[T] extends List[T] {  
  def isEmpty = true
  def head = throw new NoSuchElementException("Nil.head")
  def tail = throw new NoSuchElementException("Nil.tail")
}
</code></pre>

<p>아래와 같은 호출을 원한다면</p>

<pre><code class="scala">val e = List()  
val e3 = List(3)  
val e34 = List(3, 4)  
</code></pre>

<p>다음과 같이 <code>List</code> <em>Object</em> 와 <code>apply</code> <em>Method</em> 를 정의할 수 있다. </p>

<pre><code class="scala">object List {  
  def apply() = new Nil
  def apply(x: Int) = new Cons(x, new Nil)
  def apply(x: Int, y: Int) = new Cons(x, new Cons(y, new Nil))
}
</code></pre>

<h3 id="subtypingandgenerics">Subtyping and Generics</h3>

<p>지난시간에는 <em>Polymorphism</em> 의 두가지 형태에 대해 배웠었다. 하나는 <strong>Subtyping</strong> 이고, 다른 하나는 <strong>Generics</strong> 다. 기억을 더듬어 보면</p>

<blockquote>
  <p><strong>Subtyping:</strong> Instance of a subclass can be passed to a base class <br />
  <strong>Generics:</strong> Instance of a function or class are created  by type parameterazation</p>
</blockquote>

<p>이 중에서 <em>subtyping</em> 은 OOP 에서 먼저 온 것이고, <em>generics</em> 는 <em>FP</em> 에서 먼저 온 것이라는 이야기 까지 했다.</p>

<h4 id="typebounds">Type Bounds</h4>

<p><code>assertAllPos</code> 메소드가 있다고 하자. <code>IntSet</code> 을 취해서, 모든 Element 가 양수면 <code>IntSet</code> 을 리턴하고 아니면 예외를 던진다. 다음과 같이 정의할 수 있겠다.</p>

<p><code>def assertAllPos(s: IntSet): IntSet</code></p>

<p>근데, 만약에 이 메소드가 <code>Empty</code> 를 받으면 <code>Empty</code> 를, <code>NonEmpty</code> 를 받으면 <code>NonEmpty</code> 를 돌려주게 하려면 어떻게 해야할까? 메소드를 2개를 더 만들어야 할까? <em>Type Bound</em> 를 이용해 문제를 해결할 수 있다.</p>

<p><code>def assertAllPos[S &lt;: IntSet](r: S): S = ...</code></p>

<p>여기서 <code>S &lt;: IntSet</code> 은 <code>S</code> 가 <code>IntSet</code> 의 서브타입임을 말하고, 이것을 <strong>Upper bound</strong> 라 부른다(<code>IntSet</code> 기준). 즉 <code>S</code> 의 상위 타입을 지정하는 것이다. </p>

<p>반대로 <code>S :&gt; IntSet</code> 도 있을 수 있다. 이것은 <strong>Lower bound</strong> 라 부르며(<code>IntSet</code> 기준), 이 메소드가 <code>IntSet</code> 의 상위 타입 <code>S</code> 를 이용한다는 것을 컴파일 타임에 지정한다. <code>S</code> 는 <code>IntSet</code>, <code>AnyRef</code>, <code>Any</code> 가 될 수 있다. 정리 하자면,</p>

<blockquote>
  <p><code>S &lt;: T</code> means: <strong>S is a subtype of T</strong> <br />
  <code>S :&gt; T</code> means: <strong>S is a supertype of T, or T is a subtype of S</strong></p>
</blockquote>

<p><strong>Mixed Bound</strong> 도 있다. <code>[S &gt;: NonEmpty &lt;: IntSet]</code></p>

<h4 id="covariance">Covariance</h4>

<p>그런데, <code>NonEmpty &lt;: IntSet</code> 일때 <code>List[NonEmpty] &lt;: List[IntSet]</code> 이면, <strong>Covariant</strong> 하다고 말한다. 직관적으로 보면 그럴듯 하다. </p>

<p>이거 정말 문제가 없을까? <code>List</code> 말고 자바의 <code>Array</code> 를 예로 들어보자.</p>

<pre><code class="java">NonEmpty[] a =  
  new NonEmpty[]{new NonEmpty(1, Empty, Empty)}

IntSet[] b = a  
b[0] = Empty  
NonEmpty s = a[0]  
</code></pre>

<p><code>b[0] = Empty</code> 가 문제가 된다. 여기서 런타임 예외가 발생하는데, 자바에서는 배열이 생성될때, 이 배열이 어떤 타입으로 생성되었는지 내부적으로 태그를 붙인다. 그런데, <code>NonEmpty</code> 로 태그가 붙은 배열에 호환되지 않는 <code>Empty</code> 를 넣고 있기 때문이다.</p>

<p>자바 1.5 이전에는 Generics 가 없었기 때문에 정렬을 위해서는 <code>sort(Object[] a)</code> 처럼 주어야 했는데, 이를 위해서는 자바의 배열이 <strong>Covariant</strong> 여야 했다.</p>

<h4 id="theliskovsubstitutionprinciple">The Liskov Substitution Principle</h4>

<p><strong>Liskov Substitution Princile(리스코프 치환원칙)</strong> 은 언제 한 타입이 다른 타입의 서브타입이 될 수 있는지 말해준다.</p>

<blockquote>
  <p>If <code>A &lt;: B</code>, then everything one can to do with a value of type <code>B</code> one should also be able to do with a value of type <code>A</code></p>
</blockquote>

<p>자 이제, Scala 에서 위의 코드를 작성하면 어디서 에러가 나는지 확인 해 보자.</p>

<pre><code class="scala">val a: Array[NonEmpty] = Array(new NonEmpty(1, Empty, Empty))  
val b Array[IntSet] = a  
b(0) = Empty  
val s: NonEmpty = a(0)  
</code></pre>

<p><code>val b: Array[IntSet] = a</code> 에서 컴파일 타임 에러가 난다. 왜냐하면 Scala 의 <code>Array</code> 는 <strong>Not</strong> <em>covariant</em> 이기 때문이다.</p>

<h3 id="variance">Variance</h3>

<p>어떤 타입은 <em>covariant</em> 고 어떤 타입은 그렇지 않은걸까? 엄격히 말해서, elements 들의 <em>mutation</em> 을 허용하는 타입은 <em>not-covariant</em> 여야 한다. </p>

<p>반면 <em>immutable types</em> 은 조건이 갖춰지면 <em>covariant</em> 일 수 있다. 위에서 <code>List</code> 는 되고, <code>Array</code>는 안되었던 것처럼.</p>

<p><code>C[T]</code> 가 있고, <code>A &lt;: B</code> 일때 다음과 같은 정의를 내릴 수 있다.</p>

<ul>
<li><code>C[A] &lt;: C[B]</code> 이면, <strong>C is covariant</strong>, <code>C[+A]</code> 로 표시</li>
<li><code>C[A] &gt;: C[B]</code> 이면, <strong>C is contravariant</strong>, <code>C[-A]</code> 로 표시  </li>
<li><code>C[A]</code> 와 <code>C[B]</code> 가 상관이 없으면, <strong>C is non-variant</strong>, , <code>C[A]</code> 로 표시</li>
</ul>

<p>그렇다면 다음과 같은 두개의 타입이 있을때, 어떤것이 서브타입이고 어떤  것이 슈퍼타입일까?</p>

<pre><code class="scala">type A = IntSet =&gt; NonEmpty  
type B = NonEmpty =&gt; IntSet  
</code></pre>

<p>설명을 조금 자세히 하면, 함수의 파라미터는 <em>Contravariant</em> 하고, 함수의 리턴타입은 <em>Covariant</em> 하다. <code>Function1[-A, +B]</code> 를 보면 알 수 있다. 따라서 <code>A &lt;: B</code> 다. 왜 그럴까? 여기 <a href='https://twitter.github.io/scala_school/type-basics.html' #variance">Scala School</a> 의 예제를 좀 보자.</p>

<pre><code class="scala">class Animal {  
  val sound = "rustle" 
  def name = "animal"
}

class Bird extends Animal {  
  override val sound = "call"
  def name = "bird"
}
class Chicken extends Bird {  
  override val sound = "cluck" 
  def name = "chicken"
}
</code></pre>

<p>이때, <code>val getTweet: (Bird =&gt; String)</code> 에 <code>(c: Chicken =&gt;  c.chicken</code> 과 같이 넘겨주고, 나중에 <code>getTweet(new Bird)</code> 를 호출하면 에러가 난다. 반면 <code>a: Animal =&gt; a.name</code> 을 주고, <code>getTweek(new Bird)</code> 는 상관 없다. 어차피 <code>Bird</code> 는 <code>Animal</code> 이니까</p>

<p>따라서 함수의 파라미터는 현재와 같은 타입이거나, 혹은 그 슈퍼타입이어야 한다, 다시말해서 <strong>Contravariant</strong> 해야 한다.</p>

<h4 id="variancechecks">Variance Checks</h4>

<p><code>Array</code> 의 경우 <code>update</code> 연산이 문제가 될 수 있다는걸 위에서 논의 했었는데, 이걸 정리하자면</p>

<blockquote>
  <p>*The problematic combination is <br />
  <strong>the covariant type parameter T</strong> <br />
  <strong>which appears in parameter position of method <code>update</code></strong></p>
</blockquote>

<p>즉 <em>covariant</em> 타입 <code>T</code> 가 <code>update</code> 연산에 나타날때 문제가 된다. 그래서 Scala 는 컴파일 타임에 이런 문제가 생기지 않는지 검사를 한다.</p>

<blockquote>
  <p><em>covariant</em> type parameters can only appear in method results <br />
  <em>contravariant</em> type parameters can only appear in method parameters <br />
  <em>invariant</em> type parameters can appear anywhere  </p>
</blockquote>

<p><code>Function1</code> <em>Trait</em> 는 그래서 사실 이런 모양이다.</p>

<pre><code class="scala">package scala  
trait Function1[-T, +U] {  
  def apply(x: T): U
}
</code></pre>

<p><code>T</code> 는 <em>contravariant</em> 이므로 파라미터에만, <code>U</code> 는 <em>covaraint</em> 이므로 리턴타입에만 나타난다. 이제 지난시간에 만들었던 <code>Nil</code> 클래스를 <em>Object</em> 로 만들어 보자.</p>

<pre><code class="scala">trait List[+T] {  
  def isEmpty: Boolean
  def head: T
  def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {  
  def isEmpty = false
}

object Nil extends List[Nothing] {  
  def isEmpty = true
  def head = throw new NoSuchElementException("Nil.head")
  def tail = throw new NoSuchElementException("Nil.tail")
}
</code></pre>

<p><code>Nil</code> 이 <code>List[Nothing]</code> 을 상속하게 해, 모든 리스트의 서브타입이 될 수 있도록 했다. 그러나 이것만으로는 부족하다. <code>trait List[T]</code> 로 만들면, <code>List[Something]</code> 과 <code>List[Nothing]</code> 과는 아무 관련이 없는 <em>non-variant</em> 다. 따라서 <code>List[+T]</code> 로 만들어, <code>List[Nothing] &lt;: List[Something]</code> 이 되도록 해야한다.</p>

<p>이제, 다음과 같은 <code>prepend</code> 메소드를 고려 해 보자.</p>

<pre><code class="scala">trait List[+T] {  
  ...
  def preprend(elem: T): List[T] = new Cons(elem, this)
  ...
}
</code></pre>

<p>이 경우에는 <em>covariant</em> <code>T</code> 가 파라미터에 나오므로, 컴파일이 실패한다. 그러나 우리의 <code>List</code> 는 <em>immutable</em> 한데, 이 경우 파라미터에 <code>T</code> 가 나오면 안되나?</p>

<h4 id="prependviolateslsp">Prepend Violates LSP</h4>

<pre><code class="scala">val xs = new List[IntSet]  
xs.prepend(Empty)

val ys = new List[NonEmpty]  
xs.prepend(Empty) // compilation fail  
</code></pre>

<p>따라서, <code>List[IntSet]</code> 으로 할 수 있는걸 <code>List[NonEmpty]</code>로 할 수 없으니, <strong>LSP</strong> 에 따라서, <code>List[NonEmpty]</code> 는 <code>List[IntSet]</code> 의 서브타입이 될 수 없다.</p>

<p><code>List</code> 는 <em>covariant</em> 하고, <code>update</code> 연산이 있는것도 아니므로 <code>immutable</code> 한데, <code>prepend</code> 메소드의 타입체킹이 문제다. 어떻게 하면 <em>covaraint</em> 타입 <code>T</code> 를 메소드 파라미터로 나타나게 할 수 있을까? <strong>Lower Bound</strong> 를 이용하면 된다.</p>

<pre><code class="scala">def prepend[U :&gt; T](elem: U): List[U] = new Cons(elem, this)  
</code></pre>

<p>이 경우 <code>List[NonEmpty].prepend(Empty)</code> 의 리턴값은 <code>List[IntSet]</code> 이 될것이다. 따라서 룰을 정리하면</p>

<blockquote>
  <p>(1) <strong>covariant type parameters</strong> may appear in <strong>lower bounds</strong> of method type parameters <br />
  (2) <strong>contravariant type parameters</strong> may appear in <strong>upper bounds</strong> of method</p>
</blockquote>

<h3 id="objectseverywhere">Objects Everywhere</h3>

<h4 id="pureobjectorientation">Pure Object Orientation</h4>

<p><em>Pure OO language</em> 는 모든 <em>value</em> 가 <em>object</em> 다. 스칼라는 얼핏 보기에 <em>primitive type</em> 을 사용하는 것 같지만 잘 보면 <code>scala.Boolean</code>, <code>scala.Int</code> 처럼 기본 타입이 클래스화 되어있다. (참고로 <code>Int</code> 는 성능을 위해 32-bit Integer 로 되어있다.)</p>

<p><code>scala.Boolean</code> 대신, 직접 만든 <code>Boolean</code> 을 사용해 보자.</p>

<pre><code class="scala">abstract class cBoolean {

  def IfThenElse[T](t: T, e: T): T

  def &amp;&amp;(other: cBoolean) = IfThenElse(other, False)
  def ||(other: cBoolean) = IfThenElse(True, other)
  def unary_! : cBoolean = IfThenElse(False, True)

  def ==(other: cBoolean) = IfThenElse(other, other.unary_!)
  def !=(other: cBoolean) = IfThenElse(other.unary_!, other)

  def &lt;(other: cBoolean) = IfThenElse(False, other)
  def &gt;(other: cBoolean) = IfThenElse(other.unary_!, False)
}

object True extends cBoolean {  
  def IfThenElse[T](t: T, e:T) = t
}

object False extends cBoolean {  
  def IfThenElse[T](t: T, e:T) = e
}
</code></pre>

<p>그럼 과연, <em>primitive type</em> 없이 언어의 모든 부분을 클래스와 오브젝트로 구성하는것이 가능할까? <code>Boolean</code> 은 우리가 <code>cBoolean</code> 으로 대체했다. <code>Int</code> 부터 더 자그마한 <code>Nat</code>, 즉 자연수 범위부터 시작해보자.</p>

<blockquote>
  <p>Can it be represented as a class from first principles (i.e not using primitie ints)</p>
</blockquote>

<pre><code class="scala">abstract class Nat {  
  def isZero: Boolean
  def predecessor: Nat
  def successor = new Succ(this)
  def + (that: Nat): Nat
  def - (that: Nat): Nat
}

object Zero extends Nat {  
  def isZero = true
  def predecessor = throw new RuntimeException("Zero.predecessor");
  def + (that: Nat) = that
  def - (that: Nat) = {
    if (that.isZero) this
    else throw new RuntimeException("Zero.-")
  }
}

class Succ(n: Nat) extends Nat {  
  def isZero = false
  def predecessor: Nat = n
  def + (that: Nat) = new Succ(n + that)
  def - (that: Nat) = if(that.isZero) this else n - that.predecessor
}
</code></pre>

<p>숫자가 없을때 숫자를 추상화(abstraction) 할 방법을 찾아야 하는데, 놀랍게도 인스턴스의 중첩을, 숫자로 표현했다. 개인적으로 기가막힌다. 4강 초반부에서 집합을 predicate function 의 접합(<code>||</code>, <code>&amp;&amp;</code>)으로 표현했을때도 놀라웠는데.. </p>

<p>위 코드에서 <code>Succ.-</code> 메소드 같은 경우 <code>new Succ(n - that)</code> 을 할 수 있는데, <code>n</code> 이 <code>Zero</code> 즉, 현재 <code>Succ</code> 인스턴스가 1인 경우를 고려해야 한다. 이 경우 런타임 예외가 발생하므로, <code>n - that.predecessor</code> 가 적절하다. 여기에 <code>that</code> 이 <code>Zero</code> 일 경우를 고려하면 된다.</p>

<p>테스트를 작성할 경우 <code>Zero</code> 를 제외하고는 나머지는 다 인스턴스라서, 비교가 어렵다. 그래서 다음과 같은 연속적인 <code>predecessor</code> 를 호출할 수 있는데,</p>

<pre><code class="scala">  val one = Zero.successor
  val two = one + one
  val three = two + one
  val four = three + one

  "One + One" should "be Two" in {
    assert(two.predecessor.predecessor == Zero)
  }

  "two + two" should "be four" in {
    assert(four.predecessor.predecessor.predecessor.predecessor == Zero)
  }
</code></pre>

<p>아래와 같은 테스트용 유틸리티 함수를 만들면 편하다. (아니면 <code>==</code>를 오버라이딩 하거나.)</p>

<pre><code class="scala">  def number = {
    def count(n: Int, succ: Nat): Int = {
      if (succ == Zero) n
      else count(n + 1, succ.predecessor)
    }

    count(0, this)
  }
</code></pre>

<p>이렇게, 실제 타입에 대한 <em>primitive value</em> 없이 <em>abstraction</em> 만으로 타입을 구성할 수 있다. 위에서 구현한 <code>Nat</code> 클래스를 기술적으로는 <strong>Peano numbers</strong> 라 부른다. 다시 말해서,</p>

<blockquote>
  <p>The properties of the natural numbers can e derived from the <strong>Peano axioms</strong></p>
</blockquote>

<p>자세한건 <a href='http://en.wikipedia.org/wiki/Natural_number' #Peano_axioms">여기</a>로</p>

<h3 id="decomposition">Decomposition</h3>

<p>프로그래밍의 많은 부분이 <em>Decomposition</em> 이다. 타입을 비교하고 타입에 따라 처리하는 일들. 다음과 같은 아주 자그마한 컴파일러가 있다고 해 보자. </p>

<pre><code class="scala">object Decomposition {  
  def eval(e: Expr): Int = {
    if (e.isNumber) e.numValue
    else if (e.isSum) eval(e.leftOp) + eval(e.rightOp)
    else throw new Error(s"unknown Expr $e")
  }
}

trait Expr {  
  def isNumber: Boolean
  def isSum: Boolean
  def numValue: Int
  def leftOp: Expr
  def rightOp: Expr
}

class Number(n: Int) extends Expr {  
  def isNumber = true
  def isSum = false
  def numValue = n
  def leftOp = throw new Error("Number.leftOp")
  def rightOp = throw new Error("Number.righOp")
}

class Sum(l: Expr, r: Expr) extends Expr {  
  def isNumber = false
  def isSum = true
  def numValue = throw new Error("Sum.numValue")
  def leftOp = l
  def rightOp = r
}
</code></pre>

<p>다음과 같은 테스트코드를 작성하면, 잘 돌아간다.</p>

<pre><code class="sclaa">  import Decomposition._

  "Sum(Number(3), Number(4))" should "be eql 7" in {
    val three = new Number(3)
    val four = new Number(4)
    val sum = new Sum(three, four)

    assert(eval(sum) == 7)
  }
</code></pre>

<p>위에서, <code>isNumber</code> 과 같은 것들을 <strong>Classification</strong>, <code>rightOp</code>, <code>numValue</code> 같은 것들을 <strong>Accessor</strong> 라 부른다. </p>

<p>문제는 만약 <code>Prod</code> 나 <code>Var</code> 같은 클래스들이 <code>Expr</code> 을 상속했을 때 새로운 <strong>Classification</strong> 과 <strong>Accessor</strong> 를 작성 해야 한다는 거다. 무려 <strong>25</strong> 개나! 단 두개의 클래스만 추가했을 뿐인데..</p>

<p>일반적으로 새롭게 클래스를 정의했을때 메소드는 <em>quadratic</em> 으로 증가한다. 이건 큰 문제다. </p>

<p>이걸 해결하는 한가지 방법은, <em>Type Cast</em> 와 <em>Type Test</em> 를 이용하는거다. 자바에서 사용하는 아래의 두 메소드는</p>

<pre><code class="java">x instansceOf T  
(T) x
</code></pre>

<p>스칼라에서 다음과 같다.</p>

<pre><code>x.isInstanceOf[T]  
x.asInstanceOf[T]  
</code></pre>

<p>이 방법을 이용하면 <code>eval</code> 함수에서 <code>if (e.isInstanceOf[Number])</code> 와 같이 비교할 수 있기 때문에 <em>Classification Method</em> 가 필요없다. 그러나, 타입캐스팅에 실패했을 경우 런타임 에러가 발생할 수 있다. 다른 방법은 없을까?</p>

<h4 id="objectorienteddecomposition">Object-Oriented Decomposition</h4>

<p>다른 한 가지 방법은, <code>eval</code> 에서 타입체킹을 하는게 아니라 각 클래스에 <code>eval</code> 메소드를 만드는거다.</p>

<pre><code class="scala">trait Expr {  
  def eval: Int
}
</code></pre>

<p>이 방법의 문제는 <code>Expr</code> 에 새로운 메소드를 추가했을때 <em>Hierarchy</em> 내에 있는 모든 클래스에 같은 메소드를 작성해야 한다는 것이다.</p>

<p>게다가 <code>a * b + a * c</code> 를 <code>a * (b + 3)</code> 로 축약하기가 어렵다. 이건 <em>Non-local simplification</em> 이기 때문에, sub-tree 를 모두 테스트하고 접근해야한다. <em>OO Decomposition</em> 은 <code>eval</code> 메소드 구현엔 좋지만, 이런 점에선 문제가 있다.</p>

<h3 id="patternmatching">Pattern Matching</h3>

<p>우리는 <em>Decomposition</em> 을 해결하기 위해서 3가지 방법을 시도해봤다.</p>

<p>(1) <em>Classification</em> and <em>acess</em> methods: <strong>quadratic explosion</strong> <br />
(2) <em>Type tests</em> and <em>Type casts</em>: <strong>unsafe</strong>, <strong>low-level</strong> <br />
(3) <em>OO Decomposition</em>: <strong>need to touch all classes to add a new method</strong>, <strong>does not work always</strong>  </p>

<h4 id="functionaldecompositionwithpatternmatching">Functional Decomposition with Pattern Matching</h4>

<p>사실 <em>Classification</em> 이나 <em>Access</em> 의 목적은 다음의 두가지라 봐도 충분하다.</p>

<blockquote>
  <p>(1) Which subclass was used? <br />
  (2) What were the arugmnets of the constructor?</p>
</blockquote>

<p>따라서 Scala 에서는 <strong>Pattern Matching</strong>, 그리고 그 과정에서 사용하는 <strong>Case class</strong> 를 통해 <em>Decomposition</em> 을 우아하게 자동화 한다. </p>

<pre><code class="scala">trait Expr  
case class Number(n: Int) extends Expr  
case class Sum(l: Expr, r: Expr) extends Expr

def eval(e: Expr): Expr = {  
  e match {
    case Number(n) =&gt; n
    case Sum(e1, e2) =&gt; eval(e1) + eval(e2)
  }
}
</code></pre>

<p>(1) 패턴에서 사용하는 <em>Variable(변수)</em> 는 소문자로 시작해야 한다. 
(2) <em>Variable</em> 은 두번 사용될 수 없다. <code>Sum(a, a)</code> 는 잘못된 패턴이다. <br />
(3) <em>Constant(상수)</em> 는 대문자로 시작해야 하는데, 예외는 <code>null</code>, <code>true</code>, <code>false</code> </p>

<p><code>Expr</code> <em>Trait</em> 내부에 <code>eval</code> 을 삽입하는 것도 가능하다</p>

<pre><code class="scala">trait Expr {  
  def eval: Int = {
    this match {
      case Number(n) =&gt; n
      case Sum(e1, e2) =&gt; e1.eval + e2.eval
    }
  }
}
</code></pre>

<p><em>Object-Oriented Decomposition</em> 과 <em>Functional Decomposition</em> 모두 장단이 있는데, 만약 메소드를 많이 만드는 경우라면 <em>Functional Decomposition</em> 이 더 우월하다. 매 클라스마다 메소드를 만들 필요가 없기 때문이다. 반대로, 클래스를 많이 만드는 경우라면, <em>OO Decomposition</em> 이 더 낫다. 클래스를 만들때마다 매번 <code>eval</code> 함수를 수정 할 필요 없기 <code>eval</code> 을 가진 클래스를 만들면 된다.</p>

<h3 id="lists">Lists</h3>

<p>Scala 에서 <code>List</code> 와 <code>Array</code> 는 크게 두가지 면에서 다르다, 먼저 <code>List</code> 는 <em>immutable</em> 이고, <em>recursive</em> 인 반면 <code>Array</code> 는 <em>mutable</em>, <em>flat</em> 하다.</p>

<pre><code class="scala">List("apple", "oranges", "pears")  
"apple" :: ("oranges" :: ("pears" :: Nil))

List()  
Nil  
</code></pre>

<h4 id="rightassociativity">Right Associativity</h4>

<p>좀 더 편하게 하기 위해서, Scala 는 다음과 같은 문법을 제공한다.</p>

<pre><code class="scala">A :: (B :: C)  
A :: B :: C  
</code></pre>

<p>이는 Scala 에서 <code>:</code> 로 끝나는 <em>operator</em> 는 <strong>Right-associative</strong> 이기 때문이다.</p>

<p>또한 <code>:</code> 로 끝나는 <em>operator</em> 에서는, 우측에 오는것이 본래의 <em>operand</em> 다</p>

<blockquote>
  <p>Operators ending in <code>:</code> are also difference in the they are seen as method calls of the right-hand operand</p>
</blockquote>

<p>따라서 다음의 세 라인은 모두 같다.</p>

<pre><code class="scala">1 :: 2 :: 3 :: 4 :: Nil  
1 :: (2 :: (3 :: (4 :: Nil)))  
Nil.::(4).::(3).::(2).::(1)  
</code></pre>

<p>그러므로 <code>::</code> 를 <code>prepend</code> 메소드라 보면 된다.</p>

<h4 id="listpatterns">List Patterns</h4>

<p><code>::</code>(Cons) 연산자를 이용하면 다음과 같은 패턴이 가능하다.</p>

<pre><code class="scala">1 :: 2 :: xs  
x :: Nil  
List(x) // same as x :: nil  
List() // Nil  
List(2 :: xs)  
</code></pre>

<h4 id="sortinglists">Sorting Lists</h4>

<p><strong>Insertion Sort</strong> 는 재귀를 이용하면 다음과 같이 구현할 수 있다.</p>

<pre><code class="scala">  def isort(xs: List[Int]): List[Int] = {
    xs match {
      case Nil =&gt; List()
      case y :: ys =&gt; insert(y, isort(ys))
    }
  }

  def insert(x: Int, xs: List[Int]): List[Int] = {
    xs match {
      case Nil =&gt; List(x)
      case y :: ys =&gt; {
        if (x &lt; y)  x :: xs
        else y :: insert(x, ys)
      }
    }
  }
</code></pre>

<h3 id="references">References</h3>

<p>(1) <a href='https://twitter.github.io/scala_school/type-basics.html' #variance'>https://twitter.github.io/scala_school/type-basics.html#variance</a>  </p>]]></description><link>http://1ambda.github.io/functional-programming-in-scala-chapter-4/</link><guid isPermaLink="false">fa146b4b-9c91-4762-ae3f-55f9179f16d9</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><category><![CDATA[variant]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 07 Oct 2014 08:06:00 GMT</pubDate></item><item><title><![CDATA[Machine Learning, Week 1]]></title><description><![CDATA[<p><strong>Machine Learning</strong> by Andrew Ng, <em>Coursera</em></p>

<h3 id="whatismachinelearning">What is Machine Learning?</h3>

<blockquote>
  <p>Field of study that gies computers the abiliry to learn without being explicitly programmed. (1959, Arthur Samuel)</p>
  
  <p><strong>Well-posed Learning Problem:</strong> A computer program is said to <em>learn</em> from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E (1998, Tom Michell)</p>
</blockquote>

<p>체크메이트를 예로 들면, 수천번의 체스 게임은 <em>E</em> 에 해당하고 게임 속에서 체크메이트는 <em>T</em> 에, <em>P</em> 는 다음 게임에서 이길 확률로 볼 수 있다.</p>

<p>다른 예로, 이메일을 분류하는 스팸검사기가 있다고 할때 </p>

<ul>
<li><em>E</em>: Wathing you label emails as spam or not spam.  </li>
<li><em>T</em>: Classifying emails as spam or not spam.  </li>
<li><em>P</em>: The number(or fraction) of emails correctly classified as spam/not spam.  </li>
</ul>

<h3 id="supervisedlearning">Supervised Learning</h3>

<blockquote>
  <p><strong>Given the rihgt answer</strong> for each example in the data</p>
</blockquote>

<p>즉, 주어진 정답이 있을때 사용할 수 있다. 이런 문제들은 많은데, <em>Regression</em> 이나 <em>Classification</em> 등이 있다.</p>

<ul>
<li><strong>Regression:</strong> Predict continuous valued output  </li>
<li><strong>Classification:</strong> Discrete valued output (0 or 1)  </li>
</ul>

<p>단순히 1개 혹은 2개의 attribute 를 사용할 수 있지만, infinite number of features(attribute) 를 사용하는 <em>Support Vector Machine</em> 같은 알고리즘도 있다.</p>

<h3 id="unsupervisedlearning">Unsupervised Learning</h3>

<p>즉 모든 데이터에 attribute 는 있지만 주어진 정답이 없을때 사용한다. 다시 말해서, 여러 집단으로 분류될때 미리 컴퓨터에게 이건 <code>type1</code> 이야 등의 정보를 제공하지 않는다. </p>

<p>예를 들어서, 다음의 두가지 예는 <em>Unsupervised leanring</em> 이 아니라 <em>Supervised learning</em> 이다.</p>

<blockquote>
  <p>(1) <strong>Given email labeled as spam/not spam</strong>, learn a spam filter<br/><br/>
  (2) <strong>Given a dataset of patients diagnosed as either having diabetes or not</strong>, learn to classify new patients as having diabetes or not</p>
</blockquote>

<p><strong>Clustering</strong> 이라 불리는데, DNS Clustering, Social network analysis, market segmentation 등에 쓰인다.</p>

<p><strong>Cocktail party problem</strong> 은 2명이 동시에 말하고, 이걸 서로 다른 위치에 있는 마이크가 녹음한다고 할 때 이 소리를 구분할 수 있는가 하는 문제다. 이것 또한 <em>Unsupervised lerning</em> 으로 해결할 수 있다.</p>

<h3 id="modelrepresentation">Model Representation</h3>

<p><img src='http://mercris.files.wordpress.com/2012/07/genericmlatwork.png'  />  </p>

<p align="center">(<a href='http://mercris.files.wordpress.com/2012/07/genericmlatwork.png' >http://mercris.files.wordpress.com/2012/07/genericmlatwork.png</a>)</p>

<p><em>Traning Set</em> 을 넣고 <em>Learning Algorithm</em> 을 돌리면 <em>Hypothesis</em> 가 나오는데, 이건 사실 함수라 보면 된다. 여기에 새로운 <em>Input X</em> 를 넣으면 <em>Estimated Y</em> 가 나온다.</p>

<p>참고로, 변수가 하나인 <em>Linear regression</em> 은 <strong>Univariate linear regression</strong> 이라 부른다.</p>

<h3 id="costfunction">Cost Function</h3>

<p>예를 들어서 다음과 같은 데이터셋이 있을때, </p>

<p><img src='http://mercris.files.wordpress.com/2012/07/screen-shot-2012-07-17-at-2-12-05-pm.png?w=584'  align="center" />  </p>

<p align="center"><a href='http://mercris.files.wordpress.com/2012/07/screen-shot-2012-07-17-at-2-12-05-pm.png?w=584' >http://mercris.files.wordpress.com/2012/07/screen-shot-2012-07-17-at-2-12-05-pm.png?w=584</a></p>

<p><em>H(hypothesis)</em> 가 다음처럼 나온다면 </p>

<p><img src='http://s0.wp.com/latex.php?latex=h_%7B%5Ctheta%7Dx+%3D+%5Ctheta_%7B0%7D+%2B+%5Ctheta_%7B1%7Dx&amp;bg=ffffff&amp;fg=333333&amp;s=0'  align="center" /></p>

<p>여기서 <code>0 (Theta)</code> 는 <em>parameter</em> 라고 부른다. 
문제는, 상수를 어떻게 찾느냐인데, 아이디어는 간단하다. training set <code>(x, y)</code> 에 가까운 <code>h(x)</code> 를 찾으면 된다.</p>

<p>따라서 다음과 같은 식을 만들 수 있고,</p>

<p><img src='http://s0.wp.com/latex.php?latex=J%28%5Ctheta_%7B0%7D%2C+%5Ctheta_%7B1%7D%29+%3D+%5Cdfrac+%7B1%7D%7B2m%7D+%5Csum+%5Climits_%7Bi%3D1%7D%5E%7Bm%7D+%28h_%7B%5Ctheta%7D+%28x%5E%7B%28i%29%7D%29+-+y%5E%7B%28i%29%7D%29%5E2&amp;bg=ffffff&amp;fg=333333&amp;s=0'  align="center" /> </p>

<p><code>J(01, 02)</code> 를 최소화 하는 <code>(01, 02)</code> 를 찾으면 된다. 이 식을 <strong>cost function</strong> 또는 <strong>squred error function</strong> 이라 부른다. 여기서 <code>1/2m</code> 으로 나누는 이유에 대해 좀 궁금해서 구글링 해봤는데, <code>1/m</code> 으로 나누는 이유는 <em>squared error</em> 에 대해 <em>mean</em> 을 얻기 위한거고, <code>1/2</code> 로 다시 나누는 이유는 미분했을때 나오는 <code>2</code> 를 제거하기 위해서다. <a href='http://stackoverflow.com/questions/21099289/cant-understand-the-cost-function-for-linear-regression' >SO 답변</a> 을 첨부하면,</p>

<blockquote>
  <p>The cost function is</p>
  
  <p>J(theta<em>0, theta</em>1) = 1/(2m) * sum<em>(i=1)^m [ h</em>theta(x^i) - y^i ]^2
  By h<em>theta(x^i) we denote what model outputs for x^i, so h</em>theta(x^i) - y^i is its error (assuming, that y^i is a correct output).</p>
  
  <p>Now, we calculate the square of this error [ h_theta(x^i) - y^i ]^2 (which removes the sign, as this error could be both positive and negative) and sum it over all samples, and to <strong>bound it somehow we normalize it - simply by dividing by m,</strong> so we have mean (because we devide by number of samples) squared (because we square) error (because we compute an error):</p>
  
  <p>1/m * sum<em>(i=1)^m [ h</em>theta(x^i) - y^i ]^2
  <strong>This 2 which appears in the front is used only for simplification of the derivative</strong>, because when you will try to minimize it, you will use the steepest descent method, which is based on the derivative of this function. Derivative of a^2 is 2a, and our function is a square of something, so this 2 will cancel out. This is the only reason of its existance.</p>
</blockquote>

<p>이 <em>cost function</em> 은 <em>regression</em> 문제를 위해 자주 쓰이는 기법이다. </p>

<h3 id="costfunctionintuition1">Cost Function: Intuition 1</h3>

<p><em>Cost function</em> 에서 만약에 <code>0_0</code> 이 제로라면 <code>0_1</code> 만 찾으면 된다. 따라서 다음과 같은 실제 데이터에서</p>

<p><img src='http://cfile3.uf.tistory.com/image/2275174452D612AE06C75B'  />  </p>

<p align="center">(<a href='http://mapository.tistory.com/59' >http://mapository.tistory.com/59</a>)</p>

<p><code>J(0_1)</code> 을 찾아보면, 다음과 같은 이차함수가 나온다.</p>

<p><img align="center" src='http://cfile29.uf.tistory.com/image/234E894A52D6113D1F8267'  />  </p>

<p align="center">(<a href='http://mapository.tistory.com/59' >http://mapository.tistory.com/59</a>)</p>

<p>당연히 이차함수이므로, 기울기가 0이 되는 지점은 <code>J(0_1)</code> 을 미분해서 찾으면 된다. (이래서 아까 1/2가 있던 것)</p>

<h3 id="costfunctionintuition2">Cost Function: Intuition 2</h3>

<p><em>Parameter</em> 가 <code>0_1</code> 만 있었을때는, (<code>0_0</code> = 0) <code>J(0_1)</code> 이 이차함수였지만, <code>J(0_0, 0_1)</code> 일때는 다음과 같은 모양을 보여준다.</p>

<p><img align="center" src='http://cfile2.uf.tistory.com/image/2232CA4C52D611111DDFCD'  />  </p>

<p align="center">(<a href='http://mapository.tistory.com/59' >http://mapository.tistory.com/59</a>)</p>

<p>여기서 <code>J(0_0, 0_1)</code> 값을 제외하고 <code>(0_0, 0_1)</code> 을 평면으로 나타내면 아래 사진에서 우측과 같은 여러 궤도가 나온다.</p>

<p><img src='http://cfile24.uf.tistory.com/original/2107074652D6134E0ECB0F'  align="center" />  </p>

<p align="center">(<a href='http://mapository.tistory.com/59' >http://mapository.tistory.com/59</a>)</p>

<p>여기서 같은 궤도에 있는 <code>(0_0, 0_1)</code> 쌍은, 같은 <code>J</code> 함수를 만든다. 그리고 재밌는 사실은 궤도가 가장 좁은 타원의 중심에 있는 <code>(0_0, 0_1)</code> 가 가장 작은 <code>J(0_0, 0_1)</code> 를 만들어 낸다.</p>

<h3 id="gradientdescent">Gradient Descent</h3>

<p><em>Gradient Descent</em> 알고리즘은 <em>Linear Regression</em> 에만 쓸 수 있는건 아니고, 범용적인 알고리즘이다. <em>cost function</em> 의 최소값을 찾기 위해 사용할 수 있는데, 다음과 같은 <code>J</code> 가 있을때,</p>

<p><img src='http://cfile28.uf.tistory.com/image/2401353E52D618322EDFB5'  align="center" />  </p>

<p align="center">(<a href='http://mapository.tistory.com/59' >http://mapository.tistory.com/59</a>)</p>

<p>높이를 비교해 가며 점점 낮은쪽으로 이동해 가면서 <code>J</code> 의 최소값을 찾을 수 있다. 식은 다음과 같은데,</p>

<p><img src='http://2.bp.blogspot.com/-AdV-O-MoZHE/TtLibFTaf9I/AAAAAAAAAVM/aOxUGP7zl98/s1600/gradient+descent+algorithm+OLS.png'  align="center" />  </p>

<p align="center">(<a href='http://econometricsense.blogspot.kr/2011_11_01_archive.html' >http://econometricsense.blogspot.kr/2011_11_01_archive.html</a>)</p>

<p>여기서 <code>:=</code> 는 <em>assignment</em> 다. <code>a(alpha)</code> 는 <em>learning rate</em> 라 부른다. 이때 <code>(0_0, 0_1)</code> 은 동시에 업데이트 되야한다. <strong>(Simultaneous update)</strong></p>

<h3 id="gradientdescentintuition">Gradient Descent: Intuition</h3>

<p>이제 저 식을 분해하기 위해 <code>J(0_1)</code> 처럼 <em>parameter</em> 하나만 놓고 보면, 이차원 함수가 나올테다. 만약 현재 <code>0_1</code> 이 이차함수의 최저점 우측에 있다면, <code>J(0_1)</code> 을 미분한 값<strong>(Slope, 기울기)</strong> 에 양수 <code>a</code> 를 곱한 값을 <code>0_1</code> 에서 뻬면서 갱신하면 <code>0_1</code> 은 점점 최저점 쪽으로 간다, </p>

<p>반대로 <code>0_1</code> 이 <code>J(0_1)</code> 의 좌측에 위치한다면 우측으로 이동하고, 아래는 그걸 요약한 그림이다.</p>

<p><img src='http://i.ytimg.com/vi/ud4o8AYe9tI/hqdefault.jpg'  align="center" /></p>

<p>따라서 <em>learning late</em> <code>a</code> 가 너무 작으면 <em>Gradient descent</em> 가 너무 느려진다. 왜냐하면 <code>0</code> 의 차이가 점점 작이지기 때문에 최저점에 도착할때 까지 너무 많은 step 이 필요하다.</p>

<p>반대로 너무 크면 최저점을 넘어갈 수 있다. 심지어 최저점에서 점점 더 멀어질 수 있다.</p>

<blockquote>
  <p>if <code>a</code> is too small, <em>gradient descent</em> can be slow <br/><br/>
  if <code>a</code> is too large, <em>gradient desscent</em> can overshoot the minimum, It may fail to converge, or even diverge</p>
</blockquote>

<p>그런데 이 <em>gradient descent</em> 알고리즘의 문제는 <strong>local optimum</strong> 수 있다는 점이다. 왜냐하면 <strong>local optimum</strong> 에서도 <code>J</code> 의 derivative 가 <code>0</code> 이기 때문이다.</p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Extrema_example.svg/2000px-Extrema_example.svg.png'  align="center" /><p align="center"><a href='http://en.wikipedia.org/wiki/Backpropagation' >http://en.wikipedia.org/wiki/Backpropagation</a></p></p>

<h3 id="gradientdescentforlinearregression">Gradient Descent For Linear Regression</h3>

<p>이제 <em>cost function</em> 을 <em>gradient descent</em> 에 집어넣고, 정리하자. <code>0_0(Theta zero)</code>, 과 <code>0_1(Theta one)</code> 대해서 시그마 내부 제곱을 각각 미분해서 정리하면,</p>

<p><img src='http://pingax.com/wp-content/uploads/2013/11/Convergence-300x107.png'   align="center" />  </p>

<p align="center">(<a href='http://pingax.com/linear-regression-with-r-step-by-step-implementation-part-1/' >http://pingax.com/linear-regression-with-r-step-by-step-implementation-part-1/</a>)</p>

<p>참고로 <strong>Convex function</strong> 은 <em>Bowl shaped</em> 처럼 <em>local optima</em> 가 없는 <code>h</code>(Hypothesis) 를 말한다. 따라서 <em>convex function</em> 을 선택할 수 있다면, 하는편이 낫다.</p>

<p><strong>Batch</strong> <em>gradient descent</em> 는 모든 training example 을 사용하는 <em>gradient descent</em> 를 말한다. (시그마에서)</p>

<p>어떤 경우에는 <em>gradient descent</em> 같은 interative algorithm 없이도 <code>min J(0_0, 0_1)</code> 를 풀 수 있다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://mercris.wordpress.com/' >http://mercris.wordpress.com/</a> <br />
(2) <a href='http://mapository.tistory.com/' >http://mapository.tistory.com/</a> <br />
(3) <a href='http://econometricsense.blogspot.kr/' >http://econometricsense.blogspot.kr</a> <br />
(4) <a href='http://pingax.com/' >http://pingax.com/</a></p>]]></description><link>http://1ambda.github.io/machine-learning-week-1/</link><guid isPermaLink="false">bf54bf16-5f85-4773-bc9c-658c74a10ecf</guid><category><![CDATA[coursera]]></category><category><![CDATA[machine lerning]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 06 Oct 2014 03:59:07 GMT</pubDate></item><item><title><![CDATA[Content-Type vs Accept, HTTP Header]]></title><description><![CDATA[<p>이 <a href='http://webmasters.stackexchange.com/questions/31212/difference-between-accept-and-content-type-http-headers' >답변</a> 이 젤 심플하다. </p>

<blockquote>
  <p>As you correctly note, the <strong>Accept</strong> header is used by HTTP clients to tell the server what content types they'll accept. The server will then send back a response, which will include a <strong>Content-Type</strong> header telling the client what the content type of the returned content actually is.</p>
  
  <p>However, as you may have noticed, HTTP requests can also contain <strong>Content-Type</strong> headers. Why? Well, think about POST or PUT requests. With those request types, the client is actually sending a bunch of data to the server as part of the request, and the <strong>Content-Type</strong> header tells the server what the data actually is (and thus determines how the server will parse it).</p>
  
  <p>In particular, for a typical POST request resulting from an HTML form submission, the Content-Type of the request will normally be either <strong>application/x-www-form-urlencoded</strong> or <strong>multipart/form-data</strong>.</p>
</blockquote>

<p>Request Header의 <code>Accept</code> 는 클라이언트가 <em>어떤 컨텐츠 타입을 받길 원하는가</em> 이고, <code>Content-Type</code> 은 어떤 컨텐츠 타입을 <em>실제로 보내는가</em> 를 기록한다. </p>

<p><code>PUT</code> 이나 <code>POST</code> 를 생각해 보면 Response Header 뿐만 아니라, Request Header 에도 <code>Content-Type</code> 이 포함될 수 있는데, HTML FORM 에서 생성되는 전형적인 <code>Content-Type</code> 은 <code>application/x-www-form-urlencoded</code> 와 <code>multipart/form-data</code> 다.</p>

<p>RFC 2616 원문을 보고 싶으면 이리로, <a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html' #sec14.1">Accept</a>, <a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html' #sec14.17">Content-Type</a></p>

<p><code>application/x-www-form-urlencoded</code> 는 <a href='http://www.w3.org/TR/html401/interact/forms.html' >Spec</a> 에 스페이스를 <code>+</code> 로 바꾸고, key-valur pair 사이를 <code>&amp;</code>로 분리하는 등의 일을 하는데, 큰 문제점이 하나 있다. 바로 non-alphanumeric bytes 가 <code>%HH</code> 로 변경되는데, 1byte 를 3bytes 로 바꾸면, 커다란 파일이나, 바이너리 혹은 non-ASCII 로 구성된 파일들을 보낼때 마다 굉장히 비효율적인 인코딩을 하게 된다.</p>

<p>그래서 나온게 바로 <code>multipart/form-data</code> 인데, 이건 데이터에 나타나지 않는 특별한 패턴, <strong>boundary</strong> 를 찾아 각 key-valur pair 를 <strong>part</strong> 로 나눈다. 각 파트마다 <strong>Content-Disposition</strong> 이라는 <strong>Content-Type</strong> 필드를 가지고 있고, 여기에 나온 MIME type 에 따라 적절한 인코딩을 한다. </p>

<pre><code class="html">&lt;FORM action="http://server.com/cgi/handle"  
       enctype="multipart/form-data"
       method="post"&gt;
   &lt;P&gt;
   What is your name? &lt;INPUT type="text" name="submit-name"&gt;&lt;BR&gt;
   What files are you sending? &lt;INPUT type="file" name="files"&gt;&lt;BR&gt;
   &lt;INPUT type="submit" value="Send"&gt; &lt;INPUT type="reset"&gt;
&lt;/FORM&gt;  
</code></pre>

<p>다음과 같은 Form 을 보낸다고 하면, 실제로는</p>

<pre><code>  Content-Type: multipart/form-data; boundary=AaB03x

   --AaB03x
   Content-Disposition: form-data; name="submit-name"

   Larry
   --AaB03x
   Content-Disposition: form-data; name="files"; filename="file1.txt"
   Content-Type: text/plain

   ... contents of file1.txt ...
   --AaB03x--
</code></pre>

<p>만약에 파일을 하나 더 보낸다면</p>

<pre><code>   Content-Type: multipart/form-data; boundary=AaB03x

   --AaB03x
   Content-Disposition: form-data; name="submit-name"

   Larry
   --AaB03x
   Content-Disposition: form-data; name="files"
   Content-Type: multipart/mixed; boundary=BbC04y

   --BbC04y
   Content-Disposition: file; filename="file1.txt"
   Content-Type: text/plain

   ... contents of file1.txt ...
   --BbC04y
   Content-Disposition: file; filename="file2.gif"
   Content-Type: image/gif
   Content-Transfer-Encoding: binary

   ...contents of file2.gif...
   --BbC04y--
   --AaB03x--
</code></pre>

<p>그렇다고 해서 <code>multipart/form-data</code> 가 항상 좋은건 아니다. 간단한 alpha-numeric 이라면 <strong>boundary</strong> 를 찾고 MIME 인코딩 하고 디코딩 하는 과정 대신 그냥 <code>application/x-www-form-urlencoded</code> 로 보내면 된다.</p>

<p>참고로, <code>Content-Type</code> 이 <code>text</code> 일 경우에는 문자 인코딩을 지정하기 위해 <code>charset</code> 을 사용할 수 있다. <code>text/plain; charset=utf-8</code> 처럼</p>

<p><a href='http://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data' >SO 답변</a> 에는 두 가지 컨텐츠 타입 뿐 아니라 <code>application/xml</code> 이나 <code>application/json</code> 을 이용해서도 binary 나 non-ascii 를 보낼수 있단다. </p>

<h3 id="applicationoctetstream">application/octet-stream</h3>

<p><code>Content-Type</code> 에 들어갈 수 있는 MIME 타입에는 <code>application/octet-stream</code> 이라는 arbitrary binary data 를 위한 값이 있다. 따라서</p>

<pre><code>Content-Type: application/octet-stream  
Content-Disposition: attachment; filename="picture.png"  
</code></pre>

<p>이건, 뭔진 모르겠지만 파일 이름은 <code>picture.png</code> 고 저장해줘, 라는 뜻이다.</p>

<pre><code>Content-Type: image/png  
Content-Disposition: attachment; filename="picture.png"  
</code></pre>

<p>이 요청은 이건 <code>png</code> 고, <code>picture.png</code> 라는 이름으로 저장해줘, 라는 뜻이다.</p>

<pre><code>Content-Type: image/png  
Content-Disposition: inline; filename="picture.png"  
</code></pre>

<p>이 요청은, 이건 <code>png</code> 인데 방법을 안다면 보여줘, 라는 뜻이다.</p>

<h3 id="contentencoding">Content-Encoding</h3>

<p><code>Content-Encoding</code> 은 그럼 무엇일까? <a href='http://en.wikipedia.org/wiki/HTTP_compression' >HTTP Compression</a> 을 보면, 클라이언트가 받길 기대하는 Encoding 의 목록이라고 나와있다. 문자열 인코딩이 아니라, <code>gzip</code> 이나 <code>bzip2</code>, <code>deflate</code> 같은 압축 방법이다. </p>

<p>먼저 클라이언트가 다음과 같이 요청을 보내면</p>

<pre><code>GET /encrypted-area HTTP/1.1  
Host: www.example.com  
Accept-Encoding: gzip, deflate  
</code></pre>

<p>서버가 다음과 같이 보낼 수 있다. </p>

<pre><code>HTTP/1.1 200 OK  
Date: mon, 4 Oct 2014 22:38:34 GMT  
Server: Apache/1.3.3.7 (Unix)  (Red-Hat/Linux)  
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT  
Accept-Ranges: bytes  
Content-Length: 438  
Connection: close  
Content-Type: text/html; charset=UTF-8  
Content-Encoding: gzip  
</code></pre>

<p>그럼 클라이언트는 <code>Content-Encoding</code> 필드를 파악한 뒤, 압축을 풀거나 하면 된다. </p>

<h3 id="transferencoding">Transfer-Encoding</h3>

<p><em>end-to-end</em> 인 <code>Content-Encoding</code> 과는 반대로 <code>Transfer-Encoding</code> 은 <code>hop-toh-top</code> 이다. <a href='http://stackapps.com/questions/916/why-content-encoding-gzip-rather-than-transfer-encoding-gzip' >SO 답변</a>을 그대로 가져오면</p>

<blockquote>
  <p>Transfer-Encoding is hop-by-hop, while Content-Encoding is end-to-end.</p>
  
  <p>This means that if there is a proxy involved, anywhere, the proxy will see the TE gzip, unzip it, and not necessarily forward the request as TE gzip.</p>
  
  <p>So, the choices are</p>
  
  <p>CE gzip and always know what you will be getting, requiring logic to decompress the response.</p>
  
  <p>TE gzip and never know what you will be getting requiring logic to decide whether to decompress the response and the logic to decompress it when required.</p>
  
  <p>The logical choice is CE gzip.</p>
</blockquote>

<p>요약하자면, <code>CE(Content-Encoding)</code> 은 <code>gzip</code>(예를들어) 되어 올걸 알기 때문에  압축을 풀 로직이 필요한 반면, <code>TE(Content-Encoding)</code> 은 중간에 <code>gzip</code> 을 풀 수 있는 프록시가 있다면, 풀려서 올수도 있고 아닐 수도 있기 때문에 압축을 푸는 로직은 물론, 풀어야 하는지 아닌지를 결정할 수 있는 로직도 필요하다. </p>

<p>아래는 RFC 2616(HTTP 1.1) 에서 <strong>Roy T. Fielding</strong> 이 작성한 글</p>

<blockquote>
  <p>changing content-encoding on the fly in an inconsistent manner (neither "never" nor "always) makes it impossible for later requests regarding that content (e.g., PUT or conditional GET) to be handled correctly. This is, of course, why performing on-the-fly content-encoding is a stupid idea, and why I added Transfer-Encoding to HTTP as the proper way to do on-the-fly encoding without changing the resource.</p>
</blockquote>

<h3 id="transferencodingchunked">Transfer-Encoding: Chunked</h3>

<p><a href='http://en.wikipedia.org/wiki/Chunked_transfer_encoding' >Chunked transfer encoding</a> 에 보면, HTTP Response 를 여러번 보낼 수 있는 방법이 있다. 바로 <code>Content-Length</code> 대신 <code>Transfer-Encoding</code> 에 <code>chunked</code> 값을 넣어 보내다가 final chunked(empty) 가 오면 끝난다.</p>

<p>예를들어, 서버가 다음과 같은 데이터를 보내면 (2라인씩 쌍지어 첫줄은 데이터의 길이, 두번째는 실제 데이터 chunk 다)</p>

<pre><code>4\r\n  
Wiki\r\n  
5\r\n  
pedia\r\n  
e\r\n  
 in\r\n\r\nchunks.\r\n
0\r\n  
\r\n
</code></pre>

<p>클라이언트는 다음과 같이 해석한다. 각 chunk 는 <code>CLRF</code> 로 끝나며 이건 길이에 포함되지 않는다. final chunk 는 길이가 <code>\r\n</code> 로만 표시된다.</p>

<pre><code>Wikipedia in

chunks.  
</code></pre>

<p><a href='http://en.wikipedia.org/wiki/Chunked_transfer_encoding' #rationale">여기</a> 보면 이걸 쓰는 이유가 몇 가지 나오는데,</p>

<p>(1) HTTP persistent connection 을 만들 수 있고 <br />
(2) 마지막에 부가적인 헤더를 첨부할 수 있으며 <br />
(3) <code>Content-Encoding</code> 과 같이 쓰일 수 있다.</p>

<h3 id="summary">Summary</h3>

<p>HTTP 헤더를 좀 살펴 보았다. <a href='http://en.wikipedia.org/wiki/HTTP/2' >HTTP 2.0</a> 나 <a href='http://en.wikipedia.org/wiki/SPDY' >SPDY</a> 도 좀 살펴보자.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://www.w3.org/TR/html401/interact/forms.html' #h-17.13.4">HTML Form Specification</a> <br />
(2) <a href='http://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data' >form-data vs x-www-urlencoded</a> <br />
(3) <a href='http://stackoverflow.com/questions/20508788/do-i-need-content-type-application-octet-stream-for-file-download' >application/octet-stream</a> <br />
(4) <a href='http://stackapps.com/questions/916/why-content-encoding-gzip-rather-than-transfer-encoding-gzip' >why-content-encoding-gzip-rather-than-transfer-encoding-gzip</a> <br />
(5) <a href='http://stackoverflow.com/questions/11641923/transfer-encoding-gzip-vs-content-encoding-gzip' >Transfer-Encoding vs Content-Encoding</a></p>]]></description><link>http://1ambda.github.io/content-type-vs-accept-http-header/</link><guid isPermaLink="false">44d146f0-65e4-42e0-ac79-93f0a672a238</guid><category><![CDATA[Accept]]></category><category><![CDATA[content-type]]></category><category><![CDATA[HTTP]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 05 Oct 2014 08:55:05 GMT</pubDate></item><item><title><![CDATA[PUT vs POST, REST API]]></title><description><![CDATA[<h3 id="idempotent">idempotent</h3>

<p><code>PUT</code> 과 <code>POST</code> 를 이해하려면, <strong><a href='http://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation' >idempotent</a></strong> 라는 개념의 도입이 필요하다. 한글로 직역하면 <em>멱등의</em> 정도 되시겠다. 수학적으로 이해하는 편이 쉬운데, </p>

<p><em>f(x) = f(f(x))</em></p>

<p>라 보면 된다. 다시 말해 몇 번이고 같은 <em>연산</em> 을 반복해도 같은 값이 나온다는 것. 이건 fault-tolerant API 를 디자인 하는데 있어서 굉장히 중요한 요소다.</p>

<p>예를 들어보자. 클라이언트가 <code>POST /dogs</code> 를 요청했는데, 어떤 이유로간에 요청이  time-out (408) 되었다고 해 보자. 클라이언트는 요청이 전달되었으나 네트워크가 끊어졌는지, 아니면 요청조차 전달이 되지 않았는지 알 수 없다.</p>

<p>이 때, 클라이언트가 원하는 operation 이 <strong>idempotent</strong> 하다면 다시 요청해도 상관 없다. 항상 같은 결과를 만드니까. 그러나 <code>POST</code> 는 <strong>idempotent</strong> 하지 않다.</p>

<h3 id="post">POST</h3>

<p><code>POST</code> 는 클라이언트가 <em>리소스의 위치를 지정하지 않았을때</em> 리소스를 생성하기 위해 사용하는 연산이다. 예를들어</p>

<pre><code class="json">POST /dogs HTTP/1.1

{ "name": "blue", "age": 5 }

HTTP/1.1 201 Created  
</code></pre>

<p>따라서 이 연산을 수행하면 <code>/dogs/2</code> 에 생기고, 그 다음번엔 <code>/dogs/3</code> 등 매번 다른곳에 새로운 리소스가 생성될 수 있으므로, 이 연산은 <strong>idempotent 하지 않다</strong>.</p>

<h3 id="put">PUT</h3>

<p>반면 리소스의 위치가 명확히 지정된 다음의 요청을 고려해 보자.</p>

<pre><code class="json">PUT /dogs/3 HTTP/1.1

{ "name": "blue", "age": 5 }
</code></pre>

<p><code>/dogs</code> 의 프로퍼티가 <code>name</code> 과 <code>age</code> 뿐이라면, 이건 몇 번을 수행하더라도, 같은 결과를 보장한다. 다시 말해 <strong>idempotent</strong> 하다.</p>

<p>그리고 위에 예에서 알 수 있듯이 <code>PUT</code> 은 <em>리소스의 위치가 지정되었을때</em> <strong>생성</strong> 또는 <strong>업데이트</strong> 를 위해 사용할 수 있다. </p>

<h3 id="patch"> PATCH</h3>

<p><code>PUT</code> 이 리소스의 모든 프로퍼티를 업데이트 하기 위해 사용된다면, <code>PATCH</code> 는 부분만을 업데이트하기 위해 사용한다. <code>PUT</code> 과 마찬가지로 리소스의 위치를 클라이언트가 알고 있을 때 사용한다.</p>

<p><a href='http://stackoverflow.com/questions/630453/put-vs-post-in-rest' >SO</a> 에는 3개의 메소드를 다음과 같이 요약하는 답변이 있다.</p>

<p>(1) <strong>POST</strong> to a URL <strong>creates a child resouce</strong> at a server defiend URL <br />
(<a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html' #sec9.5">RFC 2616 POST</a>) <br />
(2) <strong>PUT</strong> to a URL <strong>create/replaces the resource</strong> in is entirely at the client defined URL <br />
(<a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html' #sec9.6">RFC 2616 PUT</a>) <br />
(3) <strong>PATCH</strong> to a URL <strong>updates part of the resource</strong> at that client defined URL <br />
(<a href='http://tools.ietf.org/html/rfc5789' >RFC 5789: Patch Method for HTTP</a>)</p>

<h3 id="responsecode">Response Code</h3>

<p><code>POST</code> 이나 <code>POST</code> 요청이 리소스를 새로 생성할 경우엔 리소스의 위치를 response header 의 <strong>Location</strong> field 에 담아 <em>201 Created</em> 를 보낼 수 있다. 그러나 not-identifiable 한 리소스를 생성할 경우엔 <em>200 OK</em> 또는 <em>204 No Content</em> 를 보낼수도 있다.  </p>

<p><a href='http://www.w3.org/Protocols' 이나 <code>POST</code> /rfc2616/rfc2616-sec9스의tml#sec9.5">원문</a>을 첨부하자면, </p>

<blockquote>
  <p>The action performed by the POST method might not result in a resource that can be identified by a URI. In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result. <br/><br/>
  If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header (see section 14.30).</p>
</blockquote>

<p>Async 하게 서버가 처리한다면, 요청은 수락 되었으나 아직 커밋되지 않았음을 알리기 위해 <em>202 Accepted</em> 를 보내야 한다. (if the operation has not been commited yet)</p>

<p>아래 사진은, response code decision tree</p>

<p><br/> <br />
<a href='http://i.stack.imgur.com/whhD1.png' ><img src='http://i.stack.imgur.com/whhD1.png'  /></a><p align="center">(<a href='http://i.stack.imgur.com/whhD1.png' >http://i.stack.imgur.com/whhD1.png</a>)</p> <br />
<br/></p>

<h3 id="safemethods">Safe Methods</h3>

<p>리소스를 수정하지 않는 메소드들, <code>OPTIONS</code>, <code>GET</code>, <code>HEAD</code> 등을 <em>safe</em> 하다고 말한다. 대부분의 경우 <em>idempotent</em> 하면 <em>safe</em> 하다. 물론 예외도 있는데 <code>DELETE</code> 는 <em>idempotent</em> 하지만 리소스를 변경하므로 <em>safe</em> 하지 않다. 자세한 내용은 <a href='http://tools.ietf.org/html/rfc7231' #section-4.2">RFC 7231: Safe Methods</a> 를 보자. 참고로 <a href='http://tools.ietf.org/html/rfc7231' #section-4.2.1">RFC 7231</a> 은 <code>PUT</code>, <code>DELETE</code> 와 <em>safe methods</em> 를 <em>idempotent</em> 하다고 정의한다.</p>

<p><code>HEAD</code> 는 Response-Body 없이 Header 만 얻기 위해 사용하고, <code>OPTIONS</code> 는 해당 리소스에 대해 가능한 operation 이 무엇인지 응답을 얻기 위해 사용한다. 만약 <code>OPTIONS</code> 에 대한 응답이 온다면 response <code>Allow</code> 에 가능한 operation 이 와야한다. <a href='http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html' >RFC2616</a> 에는 다음과 같이 나와있다.</p>

<blockquote>
  <p>The <code>OPTIONS</code> method represents a request for information about the communication options available on the request/response chain identified by the Request-URI. This method allows the client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval. <br/><br/>
  Responses to this method are not cacheable.</p>
</blockquote>

<h3 id="cacheablemethods">Cacheable Methods</h3>

<p>왜 <code>OPTIONS</code> 메소드에 대한 응답은 캐시가 불가능한걸까? SO 에서 이 <a href='http://stackoverflow.com/questions/13073313/http-options-not-cacheable' >답변</a> 이 제일 나은것 같아서 가져왔다.</p>

<blockquote>
  <p>The <code>OPTIONS</code> HTTP request returns the available methods which can be performed on a resource. (The objects methods)</p>
  
  <p>I can not say for certain why you can not cache the response, but its most likely a precaution. Caching would have little value for the <code>OPTIONS</code> http method.</p>
  
  <p>A Resource is "any information that can be given a name", that name is its URI. the response from the OPTIONs request is only a list of methods that can be requested on this resource (e.g. "GET PUT POST" maybe the response). To actually get at the information stored, you must use the GET method.</p>
  
  <p>History, more than anything; OPTIONS was defined that way to start with. The underlying reason is that HTTP caches are defined in terms of representations, which means the way you get something out of the cache is GET. This is why OPTIONS, PROPFIND, etc. caching are problematic.</p>
</blockquote>

<p>다시 말해서, 리소스는 주어진 URI 에 대한 정보인데 <code>OPTIONS</code> 는 정보를 가지고 오는 것이 아니라, 정보에 대해 어떤 연산이 가능한지를 알려준다. HTTP 에서는 정보에 대해 캐싱하므로, <code>GET</code> 이나 <code>HEAD</code> 같이 정보를 돌려주는 연산만 캐싱할 수 있다.</p>

<h3 id="traceconnect">Trace, Connect</h3>

<p><code>TRACE</code> 는 클라이언트가 방금 보낸 요청을 다시 달라고, 서버에게 요청하는 것이고 <code>CONNECT</code> 는 HTTP 터널링을 할때 쓰인다. 중간의 프록시 서버를 위해서는 <code>CONNECT</code> 로 요청하고, 마지막 프록시에서 end-point 로는 <code>GET</code> 또는 <code>CONNECT</code> 를 날린다. <code>HTTPS</code> 라면 <code>CONNECT</code> 를, <code>HTTP</code> 라면 둘 중 아무거나 써도 상관 없다. 더 자세한건 <a href='http://stackoverflow.com/questions/11697943/when-should-one-use-connect-and-get-http-methods-at-http-proxy-server' >SO 답변</a> 으로</p>

<p>원문을 첨부하면,</p>

<blockquote>
  <p><strong>CONNECT:</strong> This method could allow a client to use the web server as a proxy.</p>
  
  <p><strong>TRACE:</strong> This method simply echoes back to the client whatever string has been sent to the server, and is used mainly for debugging purposes. This method, originally assumed harmless, can be used to mount an attack known as Cross Site Tracing, which has been discovered by Jeremiah Grossman (see links at the bottom of the page).</p>
</blockquote>

<h3 id="summary">Summary</h3>

<p>HTTP 메소드에 대해서 알아보았는데, 조금 더 찾아보니 HTTP 는 0.9 -> 1.0 -> 1.1 순으로 변화했다고 한다. 0.9 에선 <code>GET</code> 을 이용한 Read-only 버전이었고 1.0 에 들어와서야 <code>HEAD</code>, <code>POST</code> 등을 이용해 서버로 데이터 전송이 가능해졌다.   HTTP 1.1 (RFC 2616) 에 와서야 <code>DELETE</code>, <code>PUT</code> 등이 추가되면서 변경, 삭제까지 가능해졌다.</p>

<p>다음번에 HTTP 를 또 살펴 볼 일이 생긴다면, <a href='http://tools.ietf.org/html/rfc7234' >RFC 7243: Caching</a> 과 <a href='http://tools.ietf.org/html/rfc7235' >RFC 7235: Authentication</a> 에 대해서 보지 않을까 싶다.</p>

<h3 id="references">References</h3>

<p>(1) <a href='http://restcookbook.com/HTTP%20Methods/put-vs-post/' >REST Cookbook: PUT vs POST</a> <br />
(2) <a href='http://stackoverflow.com/questions/2342579/http-status-code-for-update-and-delete' >HTTP status code for UPDATE and DELETE</a> <br />
(3) <a href='http://stackoverflow.com/questions/630453/put-vs-post-in-rest/18243587' #18243587">PUT vs POST in REST</a> <br />
(4) <a href='http://restcookbook.com/HTTP%20Methods/idempotency/' >REST Coookbook: idempotency</a> <br />
(5) <a href='http://zacstewart.com/2012/04/14/http-options-method.html' >HTTP OPTIONS Method</a> <br />
(6) <a href='https://www.mnot.net/blog/2012/10/29/NO_OPTIONS' >NO OPTIONS</a> <br />
(7) <a href='http://www.mkexdev.net/Article/Content.aspx?parentCategoryID=1&amp;categoryID=11&amp;ID=119' >HTTP History</a> <br />
(8) <a href='http://stackoverflow.com/questions/13073313/http-options-not-cacheable' >HTTP OPTIONS not cacheable</a> <br />
(9) <a href='http://stackoverflow.com/questions/11697943/when-should-one-use-connect-and-get-http-methods-at-http-proxy-server' >CONNECT vs GET in proxy</a></p>]]></description><link>http://1ambda.github.io/put-vs-post-restful-api/</link><guid isPermaLink="false">cfc3ba0b-d27f-4ce2-8a41-61b7eab5b4c1</guid><category><![CDATA[post]]></category><category><![CDATA[put]]></category><category><![CDATA[REST]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 05 Oct 2014 05:23:28 GMT</pubDate></item><item><title><![CDATA[Partial Functions, Scala]]></title><description><![CDATA[<h3 id="case">Case?</h3>

<p><code>case</code> 는 <code>match</code> 가 없어도 쓰일 수 있다. 예를 들어</p>

<pre><code class="scala">val m1 = Map(1 -&gt; "one", 2 -&gt; "two")  
m1 foreach { case(k, v) =&gt; println(s"k -&gt; v" }  
</code></pre>

<p>사실, <code>case</code> 가 들어간 문장은 <code>function</code> 이다. Scala Doc 을 보면, <code>scala.collection.immutable.Map</code> 의 <code>foreach</code> 는 다음처럼 정의되어 있다.</p>

<pre><code class="scala">def foreach(f: ((A, B)) =&gt; Unit): Unit  
</code></pre>

<h3 id="mapvscollect">Map vs Collect</h3>

<p>여기 재미난 예제가 하나 더 있다. <code>map</code> 과 <code>collect</code> 가 서로 다른 결과를 보여준다.</p>

<pre><code class="scala">scala &gt; val l = List(490, "Nexus5")  
scala &gt; l map { case i: Int =&gt; i * 1000 }

scala.MatchError: Nexus5 (of class java.lang.String)  
  at $anonfun$1.apply(&lt;console&gt;:9)
  at $anonfun$1.apply(&lt;console&gt;:9)
  at scala.collection.immutable.List.map(List.scala:276)
</code></pre>

<p>문자열인 <code>"Nexus5"</code> 를 만나면 <code>MatchError</code> 가 발생한다. 반면 <code>collect</code> 는 </p>

<pre><code class="scala">scala &gt; val l = List(490, "Nexus5")  
scala &gt; l collect { case i: Int =&gt; i * 1000 }  
res11: List[Int] = List(49000)  
</code></pre>

<p>왜 그럴까? <code>scala.collection.immutable.List</code> 의 <code>collect</code> 정의를 한번 보자.</p>

<pre><code class="scala">def collect[B](pf: PartialFunction[A, B]): Map[B]  
</code></pre>

<p><code>function</code> 이 아니고 <code>PartialFunction</code> 을 취한다.</p>

<h3 id="partialfunction">Partial Function</h3>

<p><em>Partial Function</em> 을 이해하는 쉬운 방법은, 일반 <em>Function</em> 을 <em>Total Function</em> 으로 이해하면 된다. 즉, 일반 <em>Function</em> 이 주어진 인자에 대해 모든 값을 취한다면, <em>Partial Function</em> 은 주어진 타입에 대해서 특정 값만 취할 수 있다. Scala School 의 원문을 첨부하면</p>

<blockquote>
  <p>A function works for every argument of the defined type. In other words, a function defined as (Int) => String takes any Int and returns a String.
  </br> <br />
  A Partial Function is only defined for certain values of the defined type. A Partial Function (Int) => String might not accept every Int.
  <br/></p>
</blockquote>

<pre><code class="scala">val onlyOne : PartialFunction[Int, String] = { case 1 =&gt; "one" }

onlyOne.isDefinedAt(1) // true  
onlyOne.isDefinedAt(2) // false  
</code></pre>

<p><code>onlyOne</code> 은 <code>Int</code> 를 인자로 받지만, 그 중에서도 <code>1</code> 만 취해 <code>"one"</code> 을 돌려주는 <code>PartialFunction[Int, String]</code> 이다.</p>

<p><code>PartialFunction</code> 또한 compose 될 수 있다.</p>

<pre><code class="scala">val onlyOne : PartialFunction[Int, String] = { case 1 =&gt; "one" }  
val onlyTwo : PartialFunction[Int, String] = { case 2 =&gt; "two" }  
val wildcard : PartialFunction[Int, String] = { case _ =&gt; "else" }

val partial = onlyOne orElse onlyTwo orElse wildcard  
</code></pre>

<h3 id="case">Case!</h3>

<p>처음엔 <code>case</code> 가 <code>Function</code> 을 만든다고 했지만, 사실 <code>PartialFunction</code> 을 정의한다. <code>map</code> 나 <code>filter</code> 는 <code>Function</code> 을 받지만, <code>PartialFunction</code> 은 <code>Function</code> 의 subtype 이므로 파라미터로 넘겨줄 수 있다.</p>

<pre><code class="scala">case class Car(model: String, price: Int)

val list = List(Car("H", 3000), Car("A", 2800))

list filter { case Car(model, price) =&gt; price &lt; 2900 }

// List[Car] = List(Car("A", 2800))
</code></pre>

<h3 id="references">References</h3>

<p>(1) <a href='http://blog.bruchez.name/2011/10/scala-partial-functions-without-phd.html' >http://blog.bruchez.name/2011/10/scala-partial-functions-without-phd.html</a> <br />
(2) <a href='https://twitter.github.io/scala_school/pattern-matching-and-functional-composition.html' >https://twitter.github.io/scala_school/pattern-matching-and-functional-composition.html</a></p>]]></description><link>http://1ambda.github.io/partial-functions-scala/</link><guid isPermaLink="false">38ff8181-481c-4535-8106-52584a473c95</guid><category><![CDATA[scala]]></category><category><![CDATA[partial function]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 03 Oct 2014 16:28:12 GMT</pubDate></item><item><title><![CDATA[new to Play Framework 2]]></title><description><![CDATA[<p><em>Play Framework</em> 를 배우기로 마음먹었다. 새로운 무언가를 마주쳤을때, 어떻게 해결할까를 위주로 서술했다.</p>

<h3 id="installation">Installation</h3>

<p>우선 설치를 해야했다. <em>Play</em> 를 배포하는 Typesafe 의 <a href='https://typesafe.com/platform/getstarted' >Getting Started</a> 에 들어가서, 확인해보니 <strong>activator</strong> 라는 제품으로 <em>Play</em> 를 감싸 편하게 개발할 수 있도록 해주는 플랫폼을 만들어 놨다. </p>

<p><a href='https://www.playframework.com/documentation/2.3.x/Installing' >Installing Play</a> 를  참조해서 <strong>activator</strong> 설치 후에, <strong>PATH</strong> 에 추가했다. <a href='https://www.playframework.com/documentation/2.3.x/NewApplication' >Creating New Application</a> 와 <a href='https://www.playframework.com/documentation/2.3.x/PlayConsole' >Activator Console Usage</a> 을 참조해서 새 프로젝트를 생성하고, <strong>activator</strong> 의 기본적인 사용법을 익혔다.</p>

<pre><code class="scala">$ activator new example-app play-scala
$ cd example-app
$ ./activator run
</code></pre>

<p><strong>activator</strong> 는 <strong>sbt</strong> 위에서 돌아가는 또 다른 콘솔이기 때문에, 이렇게도 쓸 수 있다.</p>

<pre><code class="scala">$ sbt
[example-app] $ compile
[example-app] $ test
[example-app] $ run
</code></pre>

<p>IDE intergration 을 하려고 <a href='https://www.playframework.com/documentation/2.3.x/PlayConsole' >https://www.playframework.com/documentation/2.3.x/PlayConsole</a> 를 따라했는데 잘 안됀다. 나는 emacs 를 쓰는데 <code>ensime</code> 과 <code>activator</code> 가 디펜던시 충돌이 있는 것 같다. <code>ensime</code> 을 쓰지 않기로 결정했다. 구글링 해보니 <code>ensime-sbt</code> 0.17 에서 해결한단다. 지금은 0.15-SNAPSHOT 인데 1-2 달 걸린다고 하고 자세한건 <a href='https://github.com/sbt/sbt/issues/1592' >https://github.com/sbt/sbt/issues/1592</a> 여기 참조.</p>

<h3 id="directorystructure">Directory Structure</h3>

<p>이제 뭘 하려면 파일을 수정해야 하는데, <strong>activator</strong> 가 생성해주는 파일이 생각보다 많아서 무엇을 수정해야하는지 좀 난감했다. <a href='https://www.playframework.com/documentation/2.3.x/NewApplication' >Anatomy of a Play Application</a> 을 참조해서 디렉토리 구조를 살펴봤다.</p>

<pre><code>app                      → Application sources  
 └ assets                → Compiled asset sources
    └ stylesheets        → Typically LESS CSS sources
    └ javascripts        → Typically CoffeeScript sources
 └ controllers           → Application controllers
 └ models                → Application business layer
 └ views                 → Templates
build.sbt                → Application build script  
conf                     → Configurations files and other non-compiled resources (on classpath)  
 └ application.conf      → Main configuration file
 └ routes                → Routes definition
public                   → Public assets  
 └ stylesheets           → CSS files
 └ javascripts           → Javascript files
 └ images                → Image files
project                  → sbt configuration files  
 └ build.properties      → Marker for sbt project
 └ plugins.sbt           → sbt plugins including the declaration for Play itself
lib                      → Unmanaged libraries dependencies  
logs                     → Standard logs folder  
 └ application.log       → Default log file
target                   → Generated stuff  
 └ scala-2.10.0            
    └ cache              
    └ classes            → Compiled class files
    └ classes_managed    → Managed class files (templates, ...)
    └ resource_managed   → Managed resources (less, ...)
    └ src_managed        → Generated sources (templates, ...)
test                     → source folder for unit or functional tests  
</code></pre>

<p><code>build.sbt</code> 에 빌드 스크립트가, <code>project/plugins.sbt</code> 에 디펜던시가 나열되어 있었고 <code>lib</code> 폴더 내에 unmanaged 디펜던시를 넣게끔 되어 있었다. <code>build.properties</code> 는 <strong>sbt</strong> 버전이 기록되어있다. </p>

<p>로그같은 경우는 <code>logs</code> 폴더가 따로 있고, 여기 내에 <code>application.log</code> 파일에 디폴트로 로그가 쌓인다. </p>

<p><code>conf</code> 밑에는 <code>application.conf</code> 에 데이터베이스 커넥션이나, 로거 세팅등 <em>Play</em> 에서 사용하는 세팅이 적게끔 되어있다. <code>routes</code> 는 URL 세팅이 담겨있다. 새로운 API를 추가하면, 아마 여기에도 추가해야 할 것 같다.</p>

<p><code>app</code> 은 다른 웹 프레임워크처럼 <code>views</code>, <code>controllers</code>, <code>models</code> 와 같은 디렉터리가 있다. <code>views</code> 밑에 템플릿 파일들을 보면 파일 이름이 <code>main.scala.html</code>, <code>index.scala.html</code> 과 같은데, 이건 조금 더 살펴봐야겠다.</p>

<p><em>Play</em> 는 LESS 나 Stylus, Coffee 처럼 pre-processor 의 소스코드를 <code>app/assets</code> 하위에 놓고, 빌드 스크립트를 이용해서 <code>public</code> 으로 컴파일 되도록 해 놓았다.</p>

<h3 id="helloworld">Hello World</h3>

<p>이제 준비는 다 되었으니, <strong>Hello Wolrd</strong> 를 찍을 차례다. 다 됐고, <code>views</code> 폴더 밑에 있는 파일을 수정해야겠다. <code>localhost:9000</code> 를 입력했을때 나오는 컨트롤러와 뷰를 찾기 위해서 <code>conf/routes</code> 를 확인하니, 아래와 같았다.</p>

<pre><code class="scala"># Routes
# This file defines all application routes (Higher priority routes first)
# ~~~~

# Home page
GET     /                           controllers.Application.index

# Map static resources from the /public folder to the /assets URL path
GET     /assets/*file               controllers.Assets.at(path="/public", file)  
</code></pre>

<p><code>GET /</code> 했을때, <code>controllers/Application.scala</code> 파일로 간다.</p>

<pre><code class="scala">// controllers/Application.scala

package controllers

import play.api._  
import play.api.mvc._

object Application extends Controller {

  def index = Action {
    Ok(views.html.index("Your new application is ready."))
  }
}
</code></pre>

<p><code>views/index.scala.html</code> 에 <code>"Your new application is ready."</code> 를 전달한다. <code>Action</code> 과 <code>Ok</code> 은 무엇인지 몰라서 구글링 해보니 <a href='https://www.playframework.com/documentation/2.3.x/ScalaActions' >What is Action</a> 이라는 문서가 있다. 이 문서에 의하면 <code>Action</code> 은 <code>play.api.mvc.Request</code> 를 받아 <code>play.api.mvc.Response</code> 를 만드는 함수다.</p>

<pre><code class="scala">Action {  
  Ok("Hello world")
}
</code></pre>

<p>이 경우 <code>Ok</code> 는 <strong>HTTP Status 200</strong> 과 <code>text/plain</code> 컨텐츠를 담고있는 <code>play.api.mvc.Response</code> 를 만들어 낸다. 그리고 <code>play.api.mvc.Action</code> 의 컴패니온 오브젝트는 다양한 헬퍼를 제공하는데, 아래가 그 예다.</p>

<pre><code class="scala">Action { request =&gt;  
  Ok("Got request [" + request + "]")
}

Action(parse.json) { implicit request =&gt;  
  Ok("Got request [" + request + "]")
}
</code></pre>

<p>근데 그 전에, <code>implicit</code> 에 대해서 이해가 안됀다. <a href='http://stackoverflow.com/questions/10375633/understanding-implicit-in-scala' >Understanding implicit in Scala</a> 라는 SO(Stackoverflow) 질문에서 <a href='http://pietrowski.info/2009/07/scala-implicit-conversion/' >Scala Implicit Conversion</a> 이라는 블로그도 찾아냈다. </p>

<p><strong>Implicit conversion</strong> 은, 쉽게 말해서 <code>A</code> 가 필요할때 <code>B</code> 가 있고, 타입이 맞지 않는다면, <code>A -&gt; B</code> 를 해줄 수 있는 <code>implicit function value</code> 을 찾는다. (물론 <code>A</code> 와 <code>B</code>에 대한 컴패니온 오브젝트도 찾아서, 변환할 수 있으면 변환도 할거고). <code>function</code> 대신 <code>def</code> 를 사용해도 <strong>eta-expanded</strong> 될 것이므로 문제 없다. SO 의 원문도 첨부하면</p>

<blockquote>
  <p>When the compiler finds an expression of the wrong type for the context, it will look for an implicit Function value of a type that will allow it to typecheck. So if an A is required and it finds a B, it will look for an implicit value of type B => A in scope (it also checks some other places like in the B and A companion objects, if they exist). Since defs can be "eta-expanded" into Function objects, an implicit def xyz(arg: B): A will do as well.</p>
</blockquote>

<p><br/> <br />
이제, 컨트롤러를 일단 해결 했으니 <code>views/index.scala.html</code> 로 넘어가자.</p>

<pre><code class="scala">@(message: String)

@main("Welcome to Play") {

    @play20.welcome(message)

}
</code></pre>

<p><code>controlers/Application.scala</code> 컨트롤러에서 넘어온 문자열 값 <code>"Your new application is ready"</code> 가 <code>message</code> 변수에 들어가고 <code>@</code> 가 <em>Play</em> 템플릿 엔진에서 사용하는 문법 인것 같다. <code>@main</code> 은 아마 <code>views/main.scala.html</code> 을 <em>include</em> 하는 문법 같다. <code>main.scala.html</code> 의 내용은 아래와 같다.</p>

<pre><code class="html">@(title: String)(content: Html)

&lt;!DOCTYPE html&gt;

&lt;html&gt;  
    &lt;head&gt;
        &lt;title&gt;@title&lt;/title&gt;
        &lt;link rel="stylesheet" media="screen" href='http://1ambda.github.io/@routes.Assets.at' ("stylesheets/main.css")"&gt;
        &lt;link rel="shortcut icon" type="image/png" href='http://1ambda.github.io/@routes.Assets.at' ("images/favicon.png")"&gt;
        &lt;script src='http://1ambda.github.io/@routes.Assets.at' ("javascripts/hello.js")" type="text/javascript"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        @content
    &lt;/body&gt;
&lt;/html&gt;  
</code></pre>

<p>조금 난해하긴 한데, <code>@main</code> 이 <code>main.scala.html</code> 를 부르는거라 생각하면, 두개의 인자를 <code>main.scala.html</code> 에서 받으므로 <code>index.scala.html</code> 의 <code>@main</code> 부분 에서도 두개를 넘겨줘야 한다. 하나는 컨트롤러에서 받은 <code>message</code> 고 두번째 인자는 <code>main(message)</code> 가 리턴하는 함수에 넘겨줄 <code>content</code> 변수를 <code>play20.welcome</code> 를 통해서 만들어 낸다. 아직 왜 커링을 이용하는진 모르겠다.</p>

<p>찾아보니 <code>target/scala-2.11/twirl/main/views/html/index.template.scala</code> 에서 <code>play20.welcome</code> 을 호출한다. 아마 빌트인 라이브러리인가 보다. </p>

<p>템플릿 엔진에 대해 이해하기 전에, 일단 <code>welcome</code> API 부터 만들어 보자. 구글에서 검색하니 <a href='https://github.com/playforscala/sample-applications/' >Play for Scala, Sample Application</a> 라는 프로젝트가 있어서 참고했다.</p>

<p>결국 내가 <code>GET /welcome</code> 를 만들려면, <code>controllers/Application.scala</code> 에 메소드를 아래와 같이 추가한 뒤 </p>

<pre><code class="scala">def welcome(name: String) = Action {  
  Ok("welcome " + name)
}
</code></pre>

<p>해당 API 를 <code>conf/routes</code> 에 추가한다.</p>

<pre><code>GET    /welcome            controllers.Application.welcome(name: String)  
</code></pre>

<p>만약 <em>HTML</em> 을 렌더링하고 싶다면 <code>welcome.scala.html</code> 을 아래처럼 만들고</p>

<pre><code class="html">@(name: String)

&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
  &lt;title&gt;Welcome Page&lt;/title&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome, &lt;em&gt;name&lt;/em&gt;&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;  
</code></pre>

<p>컨트롤러의 <code>welcome</code> 메소드를 다음과 같이 수정한다.</p>

<pre><code class="scala">// Application.scala

def welcome(name: String) = Action {  
  Ok(views.html.welcome(name))
}
</code></pre>

<h3 id="templateengine">Template Engine</h3>

<p><a href='https://www.playframework.com/documentation/2.3.x/ScalaTemplates' >Scala Tempaltes</a> 링크에서 <em>Play</em> 템플릿 엔진에 대한 기본적인 이해를 할 수 있었다. 다른 언어와 다른점은, 템플릿 엔진 문법을 열고 닫고 할 필요 없이 스칼라는 <code>@</code> 한번만 이용해도 <code>if</code> 블럭같은 멀티라인 코드를 처리할 수 있다는 것.</p>

<pre><code class="html">@if(items.isEmpty) {
  &lt;h1&gt;Nothing to display&lt;/h1&gt;
} else {
  &lt;h1&gt;@items.size items!&lt;/h1&gt;
}
</code></pre>

<h3 id="restapiget">REST API : GET</h3>

<p>이제 기본적인 무언가를 만들 준비가 됐다. 구글에서 <em>scala play example github</em> 을 검색해서 나온 <a href='https://github.com/playforscala/sample-applications/blob/master/ch02-your-first-play-application/first-sample/' >예제 프로젝트</a>를 참고해서 만들어 보자.</p>

<p><code>conf/routes</code> 에 API 를 정의하고,</p>

<pre><code class="scala">GET /phones/:model.json controllers.Phones.show(model String)  
</code></pre>

<p><strong>Model</strong> 을 정의하자.</p>

<pre><code class="scala">// app/models/Phone.scala

case class Phone(model: String, brand: String, price: Int)  
</code></pre>

<p>이제 <code>app/controllers/Phones.scala</code> 컨트롤러를 만들면 된다. </p>

<pre><code class="scala">package controllers

import play.api._  
import play.api.mvc._

import models.Phone

object Phones extends Controller {

  def show(model: String) = Action {
    Ok(s"{ Model : ${model} }")
  }
}
</code></pre>

<p>근데, 잠깐! 어떻게 <em>Model</em> 을 <em>Json</em> 으로 변환하는지 모른다. <em>scala play json</em> 이라고 검색해보니 <a href='https://www.playframework.com/documentation/2.3.x/ScalaJson' >Scala Json</a> 이라는 문서가 나오긴 한다.</p>

<p><code>play.api.lib.json</code> 패키지에 있는 <code>JsValue</code> 를 만들면, <code>Ok</code> 를 이용해서 날릴 수 있다. <code>JsValue</code> 를 만들기 위해선 <code>Json.toJson</code> 을 사용하면 되는데, <strong>Primitive Type</strong> 이나 <strong>Collection</strong> 은 디폴트로 지원해 준다. 따라서 <code>Json.toJson("Fiver")</code> 혹은 <code>Json.toJson(Seq(1, 2, 3, 4))</code> 와 같이 사용할 수 있다.</p>

<p>그런데 문제는 우리가 만든 클래스는 디폴트로 <code>JsValue</code> 로 바꿀수 없다. <code>Json.toJson</code> 은 인자로 받은 것을 <code>JsValue</code> 로 변환하기 위해 <code>Json.toJson[T](T)(implicit writes: Writes[T])</code> 를 사용하는데, 우리가 만든 <code>Phone</code> 을 위한 <code>Writes[Phone]</code> 은 없기 때문에 만들어 줘야 한다.</p>

<pre><code class="scala">// controllers.Phones.scala

...
  def show(model: String) = Action {
    Ok(Json.toJson(Phone(model, "Samsung", 4900)))
  }

  implicit val phoneWrites = new Writes[Phone] {
    def writes(phone: Phone) = Json.obj(
      "model" -&gt; phone.model,
      "brand" -&gt; phone.brand,
      "price" -&gt; phone.price
    )
  }
...
</code></pre>

<p><code>Phones</code> 컨트롤러 내부에 위와 같이 작성하면, <code>/phones/samsung.json</code> 과 입력했을때 <code>{"model":"samsung","brand":"Samsung","price":4900}</code> 와 같은 <code>application/json</code> response 가 돌아온다. 코드는 간단하다, <code>Writes[Phone]</code> 을 만드는데, 여기 내부에 <code>Phone</code> 을 받아 <code>JsValue</code> 를 돌려줄수 있는 <code>writes</code> 함수를 <code>Json.obj</code> 를 이용해서 만들면 된다. </p>

<p>컨트롤러에 <code>Writes[Phone]</code> 이 있어야되는지 의문이다 모델에 있어야만 할 것 같다. 그리고 구글링 해서 나온 <a href='https://gist.github.com/ayush/2428013' >Gist: Play 2.0 Marshalling</a>를 따라가면 더 나은 버전이 있는데, 일단은 이걸로 족하다. 나중에 더 고치자.</p>

<p>이제 단순히 컨트롤러에서 직접 생성하는 대신, <em>Repository</em> 역할을 해줄 <code>Phone</code> 의 <em>Companion Object</em> 를 <code>models/Phone.scala</code> 에 만들자.</p>

<pre><code class="scala">object Phone {  
  var phones = Set(
    Phone("Nexus5", "Google", 459000),
    Phone("Galaxy Note4", "SamSung", 996000),
    Phone("G3 Pro", "LG", 681000)
  )
}
</code></pre>

<p>이제 컨트롤러에서 호출할 메소드를 만들면 되는데, 이름을 짓는법이 걱정이다. <code>getAll</code> 과 같은 이름도 나쁘진 않을텐데, 정해진 스탠다드가 있지 않을까? <em>DAO method name convention</em> 을 검색해 보았다. <a href='http://stackoverflow.com/questions/20447582/standard-naming-convention-for-dao-methods' >SO 답변</a> 을 보니, <strong>Spring Data JPA</strong> 의 메소드 컨벤션을 따르는것도 괜찮다고 해서 그러기로 했다. </p>

<p><code>find*</code> 는 <em>Select</em> 를 수행하는 메소드의 이름이다. <code>get</code> 은 보통 getter 와 혼동할 여지가 있기 때문에 <code>find</code> 가 더 나은것 같다. 나머지는 직관적인 <code>create</code>, <code>update</code>, <code>delete</code> 를 사용하기로 했다. </p>

<p>이제 <code>models/Phone.scala</code> 을 다시 작성해 보면</p>

<pre><code class="scala">package models

case class Phone(model: String, brand: String, price: Int) {  
  override def toString = "[%s : ], - %s".format(model, brand, price)
}

object Phone {  
  var phones = Set(
    Phone("nexus5", "Google", 459000),
    Phone("note4", "SamSung", 996000),
    Phone("g3", "LG", 681000)


  def findByModel(model: String) = phones.find(_.model == model)
}
</code></pre>

<p>컨트롤러는, </p>

<pre><code class="scala">  def get(model: String) = Action {
    Ok(Json.toJson(Phone.findByModel(model)))
  }
</code></pre>

<p>잘 동작한다. 있으면 뿌려주고, 없으면 <code>null</code> 을 Response 에 담아 보낸다. 난 <code>null</code> 대신 <em>HTTP status 404</em> 가 왔으면 좋겠다. 컨트롤러의 <code>get</code> 메소드를 다음처럼 고친다.</p>

<pre><code class="scala">  def get(model: String) = Action {
    Phone.findByModel(model).map { model =&gt;
      Ok(Json.toJson(model))
    }.getOrElse(NotFound)
  }
</code></pre>

<p>이제 <code>/phones.json</code> API 를 만들어 보자. 컨트롤러 내에 <code>list</code> 메소드를, <em>Phone</em> 컴패니언 오브젝트 내에 <code>findAll</code> 메소드를 추가한다.</p>

<pre><code class="scala">// models/Phone.scala

object Phone {  
  var phones = Set[Phone]()

  def findByModel(model: String) = phones.find(_.model == model)
  def findAll = phones.toList
}


// controllers/Phones.scala

  def list = Action {
    Ok(Json.toJson(Phone.findAll))
  }
</code></pre>

<p>갑자기 궁금해진게 있다. 내가 <code>var phones = Set[Phone]()</code> 처럼 empty <em>Repository</em> 를 만들면, <code>GET /phones.json</code> 을 요청했을때 <code>200 OK</code> 와  <code>[]</code>, 즉 빈 배열이 돌아오는데 이게 <em>REST API</em> 에서 적절한 응답일까? <em>REST get all resources empty</em> 라고 검색하니 SO 에서 <a href='http://stackoverflow.com/questions/13366730/proper-rest-response-for-empty-table' >Proper response for empty table?</a> 이라는 질문이 있다.</p>

<p><em>204 (No Content)</em> 와 <em>404 (Not Found)</em> 중 어떤걸 응답 코드로 사용해야 하냐는 질문에 <em>200 (OK)</em> 가 더 적절하다고 말한다. 왜냐하면, 요청된 리소스인 Collection 은 존재하나, 그 내부가 비었기 때문이다. </p>

<p>유저 몇명을 삭제해서 Collection 이 <em>비었을때</em> <strong>404</strong> 를 보낸다면 <strong>/users</strong> 라는 API 가 삭제된 것으로 오인할 수 있다.</p>

<p><strong>204</strong> 같은 경우, request 는 처리 되었으나 응답할 필요가 없는 <em>delete</em> 같은 요청의 응답코드로 사용되는 것이 적절하다. 원문을 첨부하면,</p>

<blockquote>
  <p><strong>Why not 404 (Not Found)?</strong> <br/><br/>
  The 404 status code should be reserved for situations, in which a resource is not found. In this case, your resource is a collection of users. This collection exists but it's currently empty. Personally, I'd be very confused as an author of a client for your application if I got a 200 one day and a 404 the next day just because someone happened to remove a couple of users. What am I supposed to do? Is my URL wrong? Did someone change the API and neglect to leave a redirection. <br/><br/>
  <strong>Why not 202 (No Content)?</strong> <br/><br/>
  A 204 is supposed to indicate that some operation was executed successfully and no data needs to be returned. This is perfect as a response to a DELETE request or perhaps firing some script that does not need to return data. In case of api/users, you usually expect to receive a representation of your collection of users. Sending a response body one time and not sending it the other time is inconsistent and potentially misleading.</p>
</blockquote>

<h3 id="restapipost">REST API : POST</h3>

<p>이제 <em>POST</em> 요청을 처리하기 위해 컨트롤러에 <code>add</code> 메소드를, 레포지터리에 <code>create</code> 메소드를 추가해 보자.</p>

<p>일단 <code>conf/routes</code> 에 라우팅을, 컨트롤러에 메소드를 추가한다.</p>

<pre><code>// conf/routes

`POST    /phones/:model.json         controllers.Phones.add(model: String)

// controllers/Phones.scala

  def add(model: String) = Action { request =&gt;

  }
</code></pre>

<p>이 <em>POST</em> 요청 핸들러를 작성하려면 내가 모르는것은 2가지다.</p>

<p><em>(1) Request body 에서 파라미터 추출</em> <br />
<em>(2) 추출한 파라미터를 암시적으로 <code>Phone</code> 인스턴스로 변경</em>  </p>

<p>일단, 검색을 해보니 여러 문서를 찾았다.</p>

<p>(1) <a href='https://www.playframework.com/documentation/2.3.x/ScalaJson' >ScalaJson</a> <br />
(2) <a href='https://www.playframework.com/documentation/2.3.x/ScalaJsonHttp' >ScalaJsonHttp</a> <br />
(3) <a href='https://www.playframework.com/documentation/2.3.x/ScalaJsonCombinators' >ScalaJsonCombinators</a>  </p>

<p>놀랍게도 이걸 다 이해해야 한다. 스칼라의 JSON 처리는, 아니 <em>Play</em> 의 JSON 처리는 <em>직관적이지 못한 것 같다.</em> 일단 예제 코드를 보면</p>

<pre><code class="scala">  def add() = Action(BodyParsers.parse.json) { request =&gt;
    val phoneRes = request.body.validate[Phone]
    phoneRes.fold(
      errors =&gt; {
        BadReques
      },
      phone =&gt; {
        Phone.create(phone)
      }
    )
  }

  implicit val phoneReads: Reads[Phone] = (
    (JsPath \ "model").read[String] and
    (JsPath \ "brand").read[String] and
    (JsPath \ "price").read[Int]
  )(Phone.apply _)
</code></pre>

<p>요약하자면, <code>Action(BodyParsers.parse.json</code> 을 이용하면, <em>Content-Type</em> 으로 <code>application/json</code> 혹은 <code>text/json</code> 을 받아들이고, Request Body 에 있는 값들을 파싱해서 <code>JsValue</code> 를 만들어 낸다.</p>

<p>그리고 <code>validate[Phone]</code> 를 이용해서 <code>implicit Reads[Phone]</code> 을 호출하여, validation 한 결과값을 얻는다. </p>

<p>그리고 이 값을 처리하기 위해 <code>fold</code> 메소드를 사용하는데, 첫 인자는 validation 에 실패했을 경우, 후자는 성공했을 경우의 로직을 적으면 된다.</p>

<p>정정하겠다. <em>Play</em> 의 JSON 처리는 처음보면 난해하지만, Static Typing 에서 필요한 instance converting 과 validation 을 잘 섞은 <em>깔끔한 방법</em> 이다.</p>

<p><code>phoneReads</code> 를 만드는 과정이 좀 난해하긴 한데, <a href='https://www.playframework.com/documentation/2.3.x/ScalaJsonCombinators' >여기</a> 를 좀더 참고하면 <code>JsPath</code> 와 <code>and</code> 를 이용해서 만드는건 사실 <code>FunctionalBuilder[Reads]#CanBuild3[String, String, Int]</code> 다. 이것 자체가 중요한것은 아니고, 이건 사실 바디파서로부터 뽑혀 나온 것들을 스칼라 타입으로 바꾼 것들을 담고 있는 통이고, 여기에 <code>Phone.apply</code> 를 호출해서 <code>Phone</code> 을 하나 만들 수 있다. </p>

<p><code>Writes[Phone]</code> 도 <code>JsPath</code> 를 이용해서 만들 수 있다.</p>

<pre><code class="scala">  implicit val phoneWirtes: Writes[Phone] = (
    (JsPath \ "model").write[String] and
    (JsPath \ "brand").write[String] and
    (JsPath \ "price").write[Int]
  )(unlift(Phone.unapply))
</code></pre>

<p>이 두개의 <code>Reads[T]</code> 와 <code>Writes[T]</code> 를 mixin 하면 <code>Format[T]</code> 가 된다. </p>

<pre><code class="scala">  val phoneWirtes: Writes[Phone] = (
    (JsPath \ "model").write[String] and
    (JsPath \ "brand").write[String] and
    (JsPath \ "price").write[Int]
  )(unlift(Phone.unapply))

  val phoneReads: Reads[Phone] = (
    (JsPath \ "model").read[String] and
    (JsPath \ "brand").read[String] and
    (JsPath \ "price").read[Int]
  )(Phone.apply _)

  implicit val phoneFormat: Format[Phone] =
    Format(phoneReads, phoneWirtes)
</code></pre>

<p>더 나아가서, 우리의 조그만 어플리케이션의 경우에는 <code>Reads</code> 와 <code>Writes</code> 가 다르지 않으므로 <code>Combinator</code> 를 이용해서 바로 <code>Format</code> 을 만들 수 있다.</p>

<pre><code class="scala">  implicit val phoneFormat: Format[Phone] = (
    (JsPath \ "model").format[String] and 
    (JsPath \ "brand").format[String] and
    (JsPath \ "price").format[Int]
  ) (Phone.apply, unlift(Phone.unapply))
</code></pre>

<p><code>Writes[Phone]</code> 이 <code>Phone</code> 을 이용해서 <code>Js.Value</code> 를 만들어준다는건 알겠는데, <code>unlift</code> 가 무엇인지 궁금하다. Scala Doc 에서 <a href='http://docs.scala-lang.org/overviews/quasiquotes/unlifting.html' >unlifting</a> 과 <a href='http://docs.scala-lang.org/overviews/quasiquotes/lifting.html' >lifting</a> 에 관한 링크를 찾아냈다. </p>

<p>쉽게 말해서 <strong>lifting</strong> 은 함수가 리턴해주는 타입에 대해 <code>Option</code> 을 씌워주는 것이고, <strong>unlifting</strong> 은 벗겨주는 것이다. <code>Phone.unapply</code> 는 <code>Phone =&gt; Option[(String, String, Int)]</code> 이므로, <code>unlift</code> 를 적용하면 <code>Phone =&gt; (String, String, Int)</code> 가 됀다. </p>

<p><strong>lifting</strong> 과 <strong>partial function</strong> 에 관한건 <a href='http://stackoverflow.com/questions/17965059/what-is-lifting-in-scala' >SO: What is lifting in Scala</a> 으로, <em>Play</em> 의 <strong>JSON API</strong> 에 관한건 <a href='http://mandubian.com/2012/10/01/unveiling-play-2-dot-1-json-api-part2-writes-format-combinators/' >Unveiling Play2 JSON API</a> 로</p>

<p>이제 구현을 요약하자면, <code>models/Phone.scala</code> 의 <code>create</code> 메소드는</p>

<pre><code class="scala">  def create(phone: Phone) = {
    phones = phones + phone
  }
</code></pre>

<p><code>controllers/Phones.scala</code> 의 <code>add</code> 메소드는</p>

<pre><code class="scala">  def add() = Action(BodyParsers.parse.json) { request =&gt;
    val phoneRes = request.body.validate[Phone]
    phoneRes.fold(
      errors =&gt; {
        BadRequest(Json.obj("status" -&gt;"404", "message" -&gt; JsError.toFlatJson(errors)))
      },
      phone =&gt; {
        Phone.create(phone)
        Created
      }
    )
  }
</code></pre>

<h3 id="summary">Summary</h3>

<p><em>Play</em> 에 대해 아무것도 모르는 상태에서, 간단한 엔티티를 하나 만들고 <em>POST</em>, <em>GET</em> API 를 만들어 보았다. 에러 핸들링도 없고, 부족한게 많지만 차차 붙여 나가면 될테다. </p>]]></description><link>http://1ambda.github.io/new-to-play-framework-2/</link><guid isPermaLink="false">e5700aaa-706e-4829-aef5-8c46a2dbf652</guid><category><![CDATA[scala]]></category><category><![CDATA[play framework]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Thu, 02 Oct 2014 12:50:48 GMT</pubDate></item><item><title><![CDATA[Functional Programming in Scala, Chapter 3]]></title><description><![CDATA[<p>2014-09-29, <strong>Functional Programming in Scala</strong>, Coursera</p>

<h3 id="31classhierarchies">3.1 Class Hierarchies</h3>

<h4 id="abstractclasses">Abstract Classes</h4>

<p><strong>abstract class</strong> 는 다른 언어의 그것과 같다.</p>

<pre><code class="scala">abstract class IntSet {  
  def contains(x: Int): Boolean
  def incl(x: Int): IntSet
}

object EmptySet extends IntSet {  
  def contains(x: Int) = false
  def incl(x: Int) = new NonEmptySet(x, EmptySet, EmptySet)
}

class NonEmptySet(elem: Int, left: IntSet, right: IntSet) extends IntSet {  
  def contains(x: Int) = {
    if (x &lt; elem) left contains x
    else if (x &gt; elem) right contains x
    else true
  }

  def incl(x: Int) = {
    if (x &lt; elem) new NonEmptySet(elem, left incl x, right)
    else if (x &gt; elem) new NonEmptySet(elem, left, right incl x)
    else this
  }
}
</code></pre>

<p>여기서 재밌는 점은 <code>incl</code> 을 수행할때 새로운 서브트리를 매번 만든다는 것인데, 이건 이 프로그램이 <code>immutable</code> 하다는 것을 말한다. </p>

<p>이전의 데이터들을 변경하지 않으므로 <strong>persistent data structures</strong> 라 볼 수 있다.</p>

<p>클래스에서는 다른 언어와 마찬가지로 <strong>override</strong> 를 이용해서 existing 혹은 non-abstract definition 을 서브클래스에서 <strong>재정의(redefined)</strong> 할 수 있다.  </p>

<h4 id="objectdefinitions">Object Definitions</h4>

<p><code>object</code> 키워드를 이용하면 <strong>singleton object</strong> 를 만든다. 그리고 <strong>singleton object</strong> 는 value 이기 때문에, 그 자체로 evaluate 된다. 다시말해 evaluation step 이 수행 될 필요가 없다.</p>

<pre><code class="scala">object EmptySet extends IntSet {  
  def contains(x: Int) = false
  def incl(x: Int) = new NonEmptySet(x, EmptySet, EmptySet)
}
</code></pre>

<h4 id="exercisee">Exercisee</h4>

<blockquote>
  <p>Write a method <code>union</code> for forming the union of two sets. You should implement the following abstract class</p>
</blockquote>

<pre><code class="scala">  def union(other: IntSet): IntSet = {
    ((left union right) union other) incl elem
  }
</code></pre>

<p>해석하면 terminal node 의 경우, union 연산이 <code>other incl elem</code> 이 된다. 게다가 매번의 <code>left union right</code> 연산은 현재보다 더 작은 단위를 호출하고, <code>(left union right) union other</code> 은 적어도 좌측 operand 가 적어도 현재보다 1개 작은 elem 을 가지고 있기 때문에 최소한 자기 자신을 다시 호출하지 않는다는 것을 알 수 있다. 따라서 이런 점을 고려하면 함수는 언젠가 끝난다는 것을 알 수 있다.</p>

<h4 id="dynamicbinding">Dynamic Binding</h4>

<blockquote>
  <p>Object-oriented language implement dynamic method dispatch. This means that the code invoked by a method call depends on the runtime type of the object that contains the method</p>
</blockquote>

<p>이렇게 보면, <strong>Dynamic dispatch</strong> 는 <em>* higher-orher functions</em>* 와 유사한데, 둘 다 static 타임에 어떤 함수가 실행될 지 알 수 없다. 그럼 둘을 섞으면 어떻게 될까?</p>

<h3 id="32howclassesareorganized">3.2 How Classes Are Organized</h3>

<p>스칼라에서 class 들은 <strong>package</strong> 로 관리된다. 스칼라에서 자동으로 임포트하는 것들은</p>

<ul>
<li>All members of package <code>scala</code> like scala.Int  </li>
<li>All members of package <code>java.lang</code> like java.lang.Object  </li>
<li>All members of the singleton object  <code>scala.Predef</code> like scala.Predef.require  </li>
</ul>

<h4 id="trait">Trait</h4>

<blockquote>
  <p>A trait is declared like an abstract class, just with trait instead of abstract class</p>
</blockquote>

<pre><code class="scala">trait Planar {  
  def height: Int
  def width: Int
  def surface = height * width
}
</code></pre>

<p><strong>Trait</strong> 는 자바의 <strong>Interface</strong> 와 비슷하지만, fields 와 concrete methods 를 포함할 수 있다는 점에서 더 강력하다. 반면 <strong>Trait</strong> 는 parameter 를 가질 수 없다.</p>

<h4 id="scalashierarchy">Scala's Hierarchy</h4>

<p><img src='http://librairie.immateriel.fr/baw/9780596155957/httpatomoreillycomsourceoreillyimages322250.png'  /></p>  

<p align="center">(<a href='http://librairie.immateriel.fr/fr/read_book/9780596155957/ch07s04' #scalas-type-hierarchy'>http://librairie.immateriel.fr/fr/read_book/9780596155957/ch07s04#scalas-type-hierarchy</a>)</p>

<p>그림을 보면 알겠지만, 가장 상위에 <code>scala.Any</code> 가 있고, 그 아래로 기본 타입들은 <code>scala.AnyVal</code> 아래에 위치한다. 스칼라의 <code>Double</code> 은 자바의 <code>double</code> 와 일치한다. <code>java.lang.Double</code> 과는 다르다. <code>java.lang.Double</code> 은 아래 설명을 보면 알겠지만, <code>AnyRef</code> 하위에 위치한다. </p>

<p>레퍼런스 타입은 <code>scala.AnyRef</code> 아래에 위치 한다. 그리고 <code>scala.AnyRef</code> 는 자바의 <code>java.lang.Object</code> 와 동일하다. 모든 스칼라 오브젝트들은 <code>scala.AnyRef</code> 를 하위에 위치한다. 받는다.</p>

<p>정리하자면 primitive type 은 <code>scala.AnyVal</code> 하위에 있고, object 는 <code>scala.AnyRef</code> 하위에 있다고 보면 된다.  </p>

<p>그리고 하위에 보면 <code>scala.Nothing</code> 과 <code>scala.Null</code> 이 <strong>Trait</strong> 로 존재하는 걸 확인할 수 있다.</p>

<p><br/>  </p>

<p><img src='http://docs.scala-lang.org/resources/images/classhierarchy.img_assist_custom.png'  /></p>  

<p align="center"><a href='http://docs.scala-lang.org/tutorials/tour/unified-types.html' >http://docs.scala-lang.org/tutorials/tour/unified-types.html</a></p>

<p>그림이 좀 작긴 한데, 자세히 보면 dotted arrow  가 있는걸 볼 수 있다. 이건 해당 타입이 화살표가 이어진 곳에 있는 타입으로 자동으로 converted 될 수 있는지의 여부다. 따라서 아래와 같은 <strong>REPL</strong> 실행 결과를 얻을 수 있다.</p>

<pre><code class="scala">scala&gt; val a: Byte = 1  
a: Byte = 1

scala&gt; val b: Short = a  
b: Short = 1

scala&gt; b  
res0: Short = 1

scala&gt; val c: Byte = b  
&lt;console&gt;:9: error: type mismatch;  
 found   : Short
 required: Byte
       val c: Byte = b
                     ^
</code></pre>

<h4 id="toptypes">Top Types</h4>

<p><code>Any</code> 은 모든 타입의 베이스 타입으로, <code>==</code>, <code>!=</code>, <code>equals</code>, <code>hashCode</code>, <code>toString</code> 등의 메소드를 포함하고 있다.</p>

<h4 id="thenothingtype">The Nothing Type</h4>

<p><br/>  </p>

<p><img src='http://docs.scala-lang.org/resources/images/classhierarchy.img_assist_custom.png'  /></p>  

<p align="center"><a href='http://docs.scala-lang.org/tutorials/tour/unified-types.html' >http://docs.scala-lang.org/tutorials/tour/unified-types.html</a></p>

<p><code>Nothing</code> 은 Scala's type hierarchy 가장 아래쪽에 위치하는데, <strong>모든 타입의 subtype</strong> 이다. <code>Nothing</code> 은 또한 값이 없는데, 다음의 두 가지 경우 유용하다.</p>

<p>(1). To signal abnormal termination <br />
(2). As an element type of empty collections. ex) <code>Set[Nothing]</code></p>

<p>참고로, <code>Exception</code> 의 타입도 <code>Nothing</code> 이다.</p>

<h3 id="null">Null</h3>

<p><code>Null</code> 은 모든 <code>scala.AnyRef</code> 하위에 있는 타입의 서브타입이다.</p>

<blockquote>
  <p>Every reference class type also has null as a value.</p>
</blockquote>

<p><code>null</code> 의 type 이 바로 <code>Null</code> 이다. <code>Null</code> 은 <code>java.lang.Object</code>, 즉 <code>scala.AnyRef</code> 를 상속받는 모든 클래스의 서브타입이기 때문에 <code>scala.AnyVal</code> 과는 incompatible 하다.</p>

<pre><code class="scala">scala&gt; null  
res1: Null = null

scala&gt; val a:String = null  
a: String = null

scala&gt; val b: Int =  null  
&lt;console&gt;:7: error: an expression of type Null is ineligible for implicit conversion  
       val b: Int =  null
</code></pre>

<p>참고로 <code>if (true) 1 else false</code> 의 타입은 <code>AnyVal</code> 인데 <code>1</code>과 <code>false</code> 의 공통적인 상위 타입은 <code>AnyVal</code> 이기 때문이다.</p>

<h3 id="33polymorphism">3.3 Polymorphism</h3>

<p>대부분의 함수형 언어에서 기본적인 데이터 구조는 <strong>immutable linked list</strong> 다. 이건 <strong>Nil</strong> 과 <strong>Cons</strong> 로 구성되어 있는데, <strong>Nil</strong> 은 empty list 를, <strong>Cons</strong> 는 element 를 담고있는 부분을 말한다. 리습의 그것과 같다. </p>

<p><br/>  </p>

<p><img src='http://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Cons-cells.svg/525px-Cons-cells.svg.png'  /></p><p align="center"><a href='http://en.wikipedia.org/wiki/Cons' >http://en.wikipedia.org/wiki/Cons</a></p>

<p>이번시간엔, <code>Cons</code> 와 <code>Nil</code> 들을 구현해 보자.</p>

<pre><code class="scala">trait List[T] {  
  def isEmpty: Boolean
  def head: T
  def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {  
  def isEmpty = false
}

class Nil[T] extends List[T] {  
  def isEmpty = true
  def head = throw new NoSuchElementException("Nil.head")
  def tail = throw new NoSuchElementException("Nil.tail")
}
</code></pre>

<p>여기서 클래스에 있는 파라미터, <code>val head: T</code> 를 <strong><em>Value Parameter</em></strong> 라 부른다. <code>val</code> 의 경우에는 자동으로 <strong>public getter</strong> 를 만들어 준다.</p>

<p>그리고 <code>[T]</code> 에서 <code>T</code> 는 <strong><em>Type Parameter</em></strong> 다. 타입 파라미터는 클래스 뿐만 아니라 함수에도 적용할 수 있는데, </p>

<p><code>def signleton[T](elem:T) = new Cons[T](elem, new Nil[T])</code></p>

<p>는 정상적으로 컴파일 된다. 물론 스칼라는 강력한 <strong><em>Type Inference</em></strong> 를 지원하기 때문에</p>

<p><code>singleton[Boolean](true)</code> 대신 스칼라 컴파일러는 type inference 를 이용해서 <code>singleton(true)</code> 혹은 <code>singleton(1)</code> 를 받아들인다.</p>

<h4 id="typesandevaluation">Types and Evaluation</h4>

<blockquote>
  <p>Type parameters do not affect evaluation in Scala</p>
</blockquote>

<p>재밌게도 Scala 프로그램이 evaluation 될 때  <code>[T]</code> 와 같은 <strong>Type parameters</strong> 는 전혀 영향을 미치지 않는다. 왜냐하면 Scala 가 evaluation 전에 모든 <strong>Type parameters</strong> 와 <strong>Type arguments</strong> 를 제거하기 때문이다. </p>

<p>이 과정은 <strong><em>Type erasure</em></strong> 로 불린다. Java, Scala, Haskell, ML, OCaml 등은 <strong><em>Type erasure</em></strong> 를 이용하고, 런타임에도 <strong>Type parameters</strong> 를 유지하는 언어는 C++, C#, F# 등이 있다.  </p>

<h4 id="polymorphism">Polymorphism</h4>

<p><strong>Polymorphism</strong> 은 <em>"in many forms"</em> 라는 뜻이다. 프로그래밍에서는 다음과 같은 의미를 가진다.</p>

<blockquote>
  <p>(1) the function can be applied to arguments of many types or <br/>
  (2) the type can have instances of many types</p>
</blockquote>

<p>이 정의로부터 두 가지 사실을 끌어낼 수 있는데,</p>

<blockquote>
  <p>(1) <strong>subtyping:</strong> instances of a subclass can be passed to a base class  <br/>
  (2) <strong>generics:</strong> instances of a function or class are created by type parameterization</p>
</blockquote>

<p>사실 <strong>subtyping</strong> 은 OOP 언어에서 먼저 온 것이고, <strong>generics</strong> 는 함수형 언어에서 온 것이나, Scala 는 모두 사용한다.</p>

<p>중요한 내용이므로 다시 한 번 정리 하면 <strong>다형성</strong> 이란, 다양한 형태를 가지고 있다는 뜻인데, 프로그래밍에서는 다음과 같은 의미를 지닌다.</p>

<p>(1) 함수는 다양한 타입의 인자를 받아들일 수 있다. <br />
(2) 타입은 다양한 타입의 인스턴스를 가질 수 있다.</p>

<p>따라서 함수나 클래스의 인스턴스는 <strong><em>type parameterization</em></strong> 을 통해 생성될 수 있으며, 하위 클래스의 인스턴스는 상위 클래스로서 동작할 수 있다.</p>

<h4 id="exercise">Exercise</h4>

<blockquote>
  <p>Write a function <code>nth</code> that takes an interger <code>n</code> and <code>a</code> list and selects the n'th element of the list<br/> <br/>
  If index is outside the range from 0 up the length of the list minus one, a <code>IndexOutOfBoundsException</code> should be thrown</p>
</blockquote>

<pre><code class="scala">def nth[T](n: Int, list: List[T]): T = {  
  if (list.isEmpty) throw new IndexOutOfBoundsException("out of bound index")
  else if (n == 0) list.head
  else nth(n - 1, list.tail)
}
</code></pre>]]></description><link>http://1ambda.github.io/functional-programming-in-scala-chapter-3/</link><guid isPermaLink="false">3853d556-1f59-4c73-b4b3-8ec4ffb80c4a</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 30 Sep 2014 12:26:11 GMT</pubDate></item><item><title><![CDATA[Functional Programming in Scala, Chapter 2]]></title><description><![CDATA[<p>2014-09-27, <strong>Functional Programming in Scala</strong>, Coursera</p>

<h3 id="21higherorderfunctions">2.1 Higher-Order Functions</h3>

<h4 id="higherorderfunctions">Higher-Order Functions</h4>

<p>Functional PL 에서는 함수를 <em>first-class</em> 로 다루는데, 이는 함수를 파라미터로 넘기거나 결과로 리턴할 수 있다는 소리다. </p>

<p>이렇게 함수를 파라미터로 받거나, 혹은 함수를 리턴하는 함수를 <strong>Higher order functions</strong> 라 부른다.</p>

<h4 id="functiontypes">Function Types</h4>

<blockquote>
  <p>type A => B is the type of a function that thaks an arg of type A and return a result of type B.</p>
</blockquote>

<h4 id="anonymousfunctions">Anonymous Functions</h4>

<blockquote>
  <p>The type of the parameter can be omittered if it can be infferred by the compiler</p>
</blockquote>

<h3 id="22currying">2.2 Currying</h3>

<p>2.1 에서 우리는 <strong>Higher Order Functions</strong> 를 만들었다. 다음과 같은 Tail-Recursive 버전의 <code>sum</code> 이 있다고 하자.</p>

<pre><code class="scala">def TailRecursiveSum(f: Int =&gt; Int, a: Int, b: Int): Int = {  
  def loop(a: Int, acc: Int): Int = {
    if (a &gt; b) acc
    else loop(a + 1, f(a) + acc)
  }
  loop(a, 0);
}

def sumInts(a: Int, b: Int) =  sum(x =&gt; x, a, b)  
def sumCubes(a: Int, b: Int) =  sum(x =&gt; x * x * x, a, b)  
def sumFactorials(a: Int, b: Int) =  sum(fact, a, b)  
</code></pre>

<pre><code>
</code></pre>

<p><code>a</code> 와 <code>b</code>는 <code>sumInts</code> 와 <code>sumCubes</code> 로 부터 <code>sum</code> 으로 변하지 않고 넘어간다. 제거할 수 없을까? <br />
답은 간단하다. <code>sum</code> 이 <code>a, b</code> 를 받는 함수를 리턴하면 된다.</p>

<pre><code class="scala">def sum(f: Int =&gt; Int): (Int, Int) =&gt; Int = {  
  def sumF(a: Int, b: Int): Int = {
    def loop(a: Int, acc: Int): Int = {
      if (a &gt; b) acc
      else loop(a + 1, f(a) +  acc)
    }
    loop(a, 0)
  }
  sumF
}
</code></pre>

<p>그러면 이렇게 인자를 숨길 수 있다.</p>

<pre><code class="scala">def sumInts = Currying.sum(x =&gt; x)  
assert(sumInts(1, 10) == 55)  
</code></pre>

<p><code>sum</code> 이 인자로 받은 <code>f</code> 를 적용한 새로운 함수 <code>sumF</code> 를 돌려주므로 다음과 같이 호출도 가능하다.</p>

<pre><code class="scala">def cube = (x: Int) =&gt; x * x * x  
sum(cube)(1, 10)  
</code></pre>

<p>함수를 리턴하는 함수는 유용하기 때문에, 스칼라에서는 이를 위한 특별한 문법을 제공한다. 다음의 두 함수 <code>sum1</code>과 <code>sum2</code> 는 동일하다.</p>

<pre><code class="scala">def sum1(f: Int =&gt; Int): (Int, Int) =&gt; Int = {  
  def sumF(a: Int, b: Int): Int = {
    if (a &gt; b) 0
    else f(a) + sum(a + 1, b)
  }
}

def sum2(f: Int =&gt; Int)(a: Int, b: Int): Int = {  
  if (a &gt; b) 0
  else f(a) + sum2(f)(a + 1, b)
}
</code></pre>

<h4 id="expansionofmultipleparameterlists">Expansion of Multiple Parameter Lists</h4>

<p><code>def f(args1)...(argsn) = E</code> 가 있을때 이건 다음과 같이 함수로 감싸고 그 함수를 다시 돌려주면, 원 함수 <code>f</code> 에서 파라미터를 하나 줄일 수 있다.</p>

<p><code>def f(args1)...(argsn-1) = { def g(argn) = E; g }</code> 만약 익명함수로 표현한다면,</p>

<p><code>def f(args1)...(argsn-1) = (argsn =&gt; E)</code> 와 같이 표현할 수 있다. 따라서 이와 같이 함수로 감싸 원 함수 <code>f</code> 에서 파라미터를 반복적으로 줄이다 보면 </p>

<p><code>def f(args1)...(argsn) = E</code> 는 인자를 1개씩 받는 N개의 익명함수로 표현할 수 있다.</p>

<p><code>def f = (args1 =&gt; (args2 =&gt; ...(argn =&gt; E) ...))</code> 이러한 스타일을 <strong>currying</strong> 이라 부른다.</p>

<h4 id="morefunctiontypes">More Function Types</h4>

<p>그렇다면, 위에서 본 <code>sum</code> 함수의 타입은 무엇일까? <code>def sum(f: Int =&gt; Int)(a: Int, b: Int): Int</code></p>

<p><code>(Int =&gt; Int) =&gt; Int, Int =&gt; Int</code> 로 표현할 수 있다. 근데 스칼라에서 <strong>functional types associate to the right.</strong> 이므로,</p>

<p><code>(Int =&gt; Int) =&gt; (Int, Int =&gt; Int)</code> 와 동일하다.</p>

<h4 id="exercise">Exercise</h4>

<blockquote>
  <p>(1). Write a <code>product</code> function that calculates the product of the value of a function for the points on a given interval</p>
</blockquote>

<pre><code class="scala">def product(f: Int =&gt; Int)(a: Int, b: Int): Int = {  
  if (a &gt; b) 1
  else f(a) * product(f)(a + 1, b)
}
</code></pre>

<blockquote>
  <p>(2). Write <code>factorial</code> in terms of <code>product</code></p>
</blockquote>

<pre><code class="scala">def factorial(n: Int): Int = {  
  product(x =&gt; x)(1, n)
}
</code></pre>

<blockquote>
  <p>(3). Can you write a more general funtion, which generalizes both <code>sum</code> and <code>product</code> </p>
</blockquote>

<pre><code class="scala">def mapReduce(f: Int =&gt; Int, combine: (Int, Int) =&gt; Int, init: Int)(a: Int, b: Int): Int = {  
  if (a &gt; b) init
  else combine(f(a), mapReduce(f, combine, init)(a + 1, b))
}

def sumUsingMapReduce(f: Int =&gt; Int)(a: Int, b: Int) =  
  mapReduce(f, (x: Int, y: Int) =&gt; x + y, 0)(a, b)

def productUsingMapReduce(f: Int =&gt; Int)(a: Int, b: Int) =  
  mapReduce(f, (x: Int, y: Int) =&gt; x * y, 1)(a, b)
</code></pre>

<h3 id="23examplefindingfixedpoints">2.3 Example: Finding Fixed Points</h3>

<h4 id="findingafixedpointofafunction">Finding a fixed point of a function</h4>

<blockquote>
  <p>A number is called a <strong>fixed point</strong> of a function f  if <code>f(x) = x</code> </p>
</blockquote>

<p>어떤 <code>f</code> 들에 대해서는 <code>f(x)</code> 를 반복적으로 적용하면서 변하지 않거나 변화량이 충분히 작아질때를 찾아 <strong>fixed point</strong> 를 찾을 수 있다.</p>

<p>1장에서 만들었던 제곱근을 구하는 함수로 돌아가 보자. 사실 이 함수는 <strong>fixed point</strong> 와 관련이 있다. <code>sqrt(x) = y</code> 라고 했을때 <code>y * y = x</code> 이므로 <code>y = x / y</code> 다. 따라서 <code>sqrt(x)</code> 는 함수 <code>y = x / y</code> 를 꾸준히 적용해서 찾아낼 수 있으므로 <code>y = x / y</code> 의 <strong>fixed point</strong> 다.</p>

<p>다음과 같은 <code>fixedPoint</code> 함수가 있다고 하자.</p>

<pre><code class="scala">val tolerance = 0.0001 // = 1.0E-4  
def isCloseEnough(x: Double, y: Double) = {  
  abs((x - y) / x) / x &lt; tolerance
}

def fixedPoint(f: Double =&gt; Double)(firstGuess: Double): Double = {  
  def iterate(guess: Double): Double = {
    val next = f(guess)
    if (isCloseEnough(guess, next)) next
    else iterate(next)
  }
  iterate(firstGuess)
}
</code></pre>

<p>이 함수를 이용해서 </p>

<p><code>sqrt(x: Int) = fixedPoint(y =&gt; x / y)(1.0)</code> </p>

<p>와 같은 제곱근을 구하는 함수를 만들어 볼 수 있겠다. 그러나 <code>sqrt(2)</code>
 를 실행하면 <code>guess</code> 값이 <code>1.0</code>과 <code>2.0</code> 사이를 널뛰기 하면서 무한 루프를 돈다.</p>

<p>이건 <code>guess</code> 값이 너무나 많이 변하기 때문인데, <code>f</code> 를 적용하는 시퀀스에서 연속적인 두개의 <code>guess</code> 값의 평균을 구하는 <code>f</code> 를 만듦으로서 이 문제를 피할 수 있다. (잘못된 해석일 수 있으므로 원문을 첨부한다.)</p>

<pre><code class="scala">One way to control such oscillations is to prevent the estimation from varying too much. This is done by averaging successive values of the original sequence  
</code></pre>

<h4 id="functionsasreturnvalues">Functions as return values</h4>

<p>여태까지는 함수를 인자로 사용했을때 언어에서 어떤 이점을 얻을 수 있는가에 대한 설명이었고, 이제부터는 함수를 리턴값으로 사용할때의 장점을 알아 보자. </p>

<p>아까와 같이 averaging 함으로써 stabilizing 하는 기법을 <strong>Average Damping</strong> 이라 부르는데, 아래와 같은 함수를 만들어서 인자로 넘길 수 있다.</p>

<p><code>def avgDamp(f: Double =&gt; Double)(x: Doube) = (x + f(x)) / 2</code></p>

<p>따라서 <code>sqrt</code> 함수는 다음과 같이 새로 작성할 수 있다.</p>

<pre><code class="scala">def avgDamp(f: Double =&gt; Double)(x: Double) = (x + f(x)) / 2  
def sqrt(x: Double): Double = fixedPoint(avgDamp(y =&gt; x / y))(1)  
</code></pre>

<p><code>avgDamp</code> 는 <code>x</code> 를 다시 인자로 받는 함수를 돌려준다. 원래라면 <code>def</code> 를 이용해서 새로 함수를 만들고 리턴했어야 하나, 스칼라에서 지원해주는 문법을 이용해서 <code>(x: Double)</code> 을 추가하는 것 만으로 편하게 만들었다.</p>

<p>이번장에선 Higher order function 을 이용해서 함수를 combine 하면 더 강력한 <strong>abstraction(추상화)</strong> 를 얻을 수 있다는 법을 배웠다. 비록 이 방법이 항상 좋은건  아니지만 배우면 다 쓸데가 있기 마련이다.</p>

<p>덤으로 하나 더 정리하자면, <strong>Currying</strong> 은 함수의 인자를 반복적으로 쪼개어 익명 함수로 만든 뒤 재활용 할 수 있도록 만드는 기술이라 보면 된다. 왜냐면 N개의 인자가 있다고 가정할때, 이전에는 1개의 함수에 다양한 인자를 줘야했지만, 커링을 이용하면 N개의 함수로 쪼갤 수 있고, 각각의 리턴되는 함수를 저장할 수 있으므로 각각을 재활용 할 수 있다.</p>

<h3 id="25functionsanddata">2.5 Functions and Data</h3>

<p>이번 장에서는 클래스를 사용한다. 유리수 계산을 하기 위해 <code>def add(n1: Int, d1: Int, n2: Int, d2: Int): Int</code> 와 같은 함수를 만드는 것이 아니라, 데이터를 추상화 하기 위한 방법으로 다음과 같은 클래스를 만들 수 있다.</p>

<pre><code class="scala">class Rational(x: Int, y: Int) {  
  def numer = x
  def denom = y

  def add(that: Rational) = {
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }
}
</code></pre>

<p>참고로, 스칼라는 <strong>type</strong> 과 <strong>value</strong> 를 서로 다른네임스페이스에서 관리하기 때문에 충돌할 걱정을 할 필요가 없다.</p>

<h4 id="exercise">Exercise</h4>

<blockquote>
  <p>(1). In your worksheet, add a method <code>neg</code> to class Rational that is used like this <code>x.neg // -x</code></p>
  
  <p>(2). Add a method sub to subtract two rational numbers</p>
  
  <p>(3). With the values of x, y, z as given in the previous slide, what is the result of <code>x - y - z</code></p>
</blockquote>

<pre><code class="scala">class Rational(x: Int, y: Int) {  
  def numer = x
  def denom = y

  def add(that: Rational) = {
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }

  def sub(that: Rational) = {
    add(that.neg)
  }

  def neg = new Rational(-numer, denom)
}
</code></pre>

<h3 id="26morefunwithrationals">2.6 More Fun With Rationals</h3>

<p>이전에 만든 <code>Rational</code> 클래스는 약분된 형태로 표현되지 않기 때문에 이런 기능을 추가할 필요가 있다.</p>

<blockquote>
  <p>reduce them to their smallest numerator and denominator by dividing both with a divisor</p>
</blockquote>

<p>다양한 방법으로 구현할 수 있겠지만, 가장 쉬운 방법은 <code>Rational</code> 오브젝트가 생성될때 약분 하는 방법이다. </p>

<pre><code class="scala">  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
  private val g = abs(gcd(x, y))

  def numer = x / g
  def denom = y / g
</code></pre>

<h4 id="selfreference">Self-reference</h4>

<p>그리고, <code>less</code>, <code>max</code> 와 같은 함수도 만들어 볼 수 있다. <code>max</code> 가 <strong>self-referencing</strong> 을 위해 <code>this</code> 키워드를 사용한다는 점에 주목하자.</p>

<pre><code class="scala">  def less(that: Rational) = numer * that.denom &lt; that.numer * denom
  def max(that: Rational) = if (this.less(that)) that else this
</code></pre>

<h4 id="precondition">Pre-condition</h4>

<p><code>new Rational(1, 0)</code> 을 시도하면 <code>0</code> 으로 나눌수 없기 때문에 에러를 뿜는다. 검사하기 위해 <code>require</code> 함수를 사용할 수 있다.</p>

<p><code>require(y &gt; 0, "denum must be != 0</code></p>

<p><code>assert</code> 도 사용할 수 있는데, <code>require</code> 와는 차이가 있다. <code>AssertionError</code> 가 나오고, <code>require</code> 에서는 <code>IllegalArgumentException</code> 이 나온다. 그래서 서로 다른 의도로 쓰이게끔 만들어졌다는걸 알 수 있다. (오역이 있을 수 있기 때문에 원문을 첨부한다.)</p>

<blockquote>
  <p>The reflects a difference in intent </br><br/>
  - <code>require</code> is used to enforce a precondition on the caller of a function <br/>
  - <code>assert</code> is used as to check the code of the function itself</p>
</blockquote>

<p>만약 예외를 테스트한다면 <code>scalatest</code> 에서는 <code>intercept</code> 를 이용하면 된다.</p>

<pre><code class="scala">  "Rational(1, 0)" should "throw IllegalArgumentException" in {
    intercept[IllegalArgumentException] {
      new Rational(1, 0)
    }
  }
</code></pre>

<h4 id="constructor">Constructor</h4>

<p>스칼라에서는 암시적(implicitly) 인 생성자를 도입했는데, 다시 말해 코드상에 없어도 <strong>Primary Constructor</strong> 가 존재하는데, 이 <strong>Primary Constructor</strong> 는 클래스의 파라미터를 받아서 클래스 바디의 모든 문장을 실행한다. 만약 다른 생성자를 만들고 싶으면, 다음과 같이 작성하면 된다.</p>

<p><code>def this(x: Int) = this(x, 1)</code></p>

<p>우측에 나오는 <code>this</code> 는 <strong>implicit primary constructor</strong> 다.</p>

<h4 id="exercise">Exercise</h4>

<blockquote>
  <p>Modify the <code>Rational</code> class so that rational numbers are kept unsimplified internally, but the simplification is applied when numbers are converted to strings. Do clients observe the same behavior when interacting with rational class? </br></p>
</blockquote>

<p>primary constructor 에서 약분을 하지 않고, <code>toString</code> 에서 약분을 할때 과연 제대로 되겠느냐인데, 답은 <strong>아니오</strong> 다. integer overflow 를 생각하면 쉽다. 최대한 약분할 수 있을때 먼저 해버리는것이 낫다. 커다란 수 <code>a</code> ... <code>z</code> 에 대해서 연산 해버리면, 마지막 <code>toString</code> 에서만 약분이 될텐데. 제대로 되지 않을 가능성이 있다.</p>

<blockquote>
  <p>Yes for small sizes of denominators and nominators and small numbers of operations</p>
</blockquote>

<h3 id="27evaluationandoperators">2.7 Evaluation and Operators</h3>

<h4 id="classesandsubstitutions">Classes and Substitutions</h4>

<p>(단어 오역이 있을 수 있어서 용어를 그대로 씀)</p>

<p>함수에서 <strong>subtitution</strong> 에 기반한 <strong>compuation model</strong> 을 이용했는데, 사실 이건 클래스를 인스턴스 할때도 똑같이 적용된다. 즉 <code>new C(x1, ... ,xn)</code> 은 <code>new C(v1, ..., vn)</code> 과 같다.</p>

<p>그렇다면, 다음과 같이 클래스가 인자 n 개를 받는 함수를 정의했을때 <code>def f(y1, ... , yn) = b</code> 이런 식은 어떻게 평가될까?</p>

<p><code>new C(v1, ..., vm).f(w1, ... , wn)</code></p>

<p>(1). 클래스의 <strong>formal parameter</strong> <code>x1, ..., xn</code> 이 <strong>actual parameter</strong> <code>v1, ... , vm</code> 으로 <strong>substitution</strong> 된다.<br/></p>

<p>(2). 함수 <code>f</code> 의 <strong>formal parameter</strong> <code>y1, ... , yn</code> 이 <strong>actual parameter</strong> <code>w1, ... , wn</code> 으로 <strong>substitution</strong> 된다. <br/></p>

<p>(3) <code>new Class(v1, ... , vm)</code> 이 <code>this</code> 로 치환되고</p>

<p>(4) <code>f</code> 의 바디 <code>b</code> 가 평가된다.</p>

<p>따라서 이를 식으로 표현하면, 다음과 같이 쓸 수 있다.</p>

<p><code>[v1/x1, ... , vm/xm][w1/y1, ... , wn/yn][new C(v1, ..., vm)/this]b</code> </p>

<p>그러면, 예제를 통해서 살펴보자.</p>

<pre><code class="scala">new Rational(1, 2).less(new Rational(2, 3))  
</code></pre>

<p>이건 다음과 같이 평가된다.</p>

<pre><code class="scala">[1/2, 2/y][new Rational(2, 3)/that][new Rational(1, 2)/this] this.numer * that.denom &lt; that.numer * this denom
</code></pre>

<p>결국 이건 아래와 같다.</p>

<pre><code class="scala">new Rational(1, 2).numer * new Rational(2, 3).denom &lt; new Rational(2, 3).numer * new Rational(1, 2).denom

// 1 * 3 &lt; 2 * 2
// true
</code></pre>

<h4 id="operators">Operators</h4>

<p><code>Int</code> 의 경우에는 <code>+</code> 를 사용하면 <code>3 + 5</code> 와 같이 표현할 수 있지만 <code>Rational</code> 의 경우에는 <code>r.add(r2)</code> 와 같이 사용해야 했다. 뭔가 불편하다.</p>

<p>스칼라에는 이런 문제를 해결하기 위해 <strong>Infix Notation</strong> 이 있다. 함수의 인자가 하나라면, 괄호를 생략하는 것이다. 바이너리 오퍼레이터처럼 보일 수 있도록.</p>

<pre><code class="scala">r add s // r.add(s)  
r less s // r less s  
r max s // r max s  
</code></pre>

<h4 id="relaxedidentifiers">Relaxed Identifiers</h4>

<p>스칼라에서는 <strong>operator</strong> 또한 <strong>identifier</strong> 가 될 수 있다. 스칼라에서 <strong>identifier</strong> 룰은 아래와 같다</p>

<blockquote>
  <p>(1). <strong>Alphanumeric:</strong> starting with a letter, followed by a sequence of letters or numbers <br/></p>
  
  <p>(2). <strong>Symbolic:</strong> starting with an operator symbol, followed by other character operator symbols <br/></p>
  
  <p>(3). The underscore character <code>_</code> counts as a letter <br/></p>
  
  <p>(4). Alphanumeric identifiers can also end in an underscore, followed by some operator symbols</p>
</blockquote>

<p>따라서 <code>*</code>, <code>+?%&amp;</code>, <code>vector_++</code>, <code>counter_=</code> 모두 유효한 identifier 들이다. </p>

<p>이제 이런 symbolic identifier 들을 이용해서 <code>Rational</code> 클래스의 함수 이름들을 산술연산 처럼 보이도록 변경해 보자.</p>

<pre><code class="scala">class Rational(x: Int, y: Int) {  
  require(y &gt; 0, "denom != 0")

  // secondary constructor
  def this(x: Int) = this(x, 1)

  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
  private val g = abs(gcd(x, y))

  def numer = x / g
  def denom = y / g

  def &lt; (that: Rational) = numer * that.denom &lt; that.numer * denom
  def max(that: Rational) = if (this &lt; that) that else this

  def + (that: Rational) = {
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }

  def - (that: Rational) = {
    this + -that
  }

  def unary_- = new Rational(-numer, denom)
}
</code></pre>

<p>재밌는 점은 <code>neg</code> 를 <strong>unary operator</strong> <code>-</code> 로 만들기 위해 <code>unary_</code> 를 이용해서 <code>unary_-</code> 로 정의했다는 것이다. </p>

<p>참고로, return 값을 주기 위해서 <code>unary-_: Rational</code> 과 같이 정의하면 에러가 난다. <code>:</code> 가 포함된 identifier 로 인식하기 때문에 <code>unary-_ :</code> 로 스페이스를 꼭 주어야 한다.</p>

<h4 id="precedencerules">Precedence Rules</h4>

<p>그렇다면 <code>x * x + y</code> 와 같은 경우 <code>*</code> 가 먼저 계산되어야 하는데, 이런건 어떻게 해결할까? 우리가 만든건 정수 연산자가 아니라 함수인데.</p>

<p>이를 위해 스칼라는 다음과 같은 룰을 만들어 두었다.</p>

<blockquote>
  <p>The precedence of an operator is determined by its first character. The following table lists the characters in increasing order of priority precedence</p>
</blockquote>

<pre><code class="scala">(all letters) // Alphanumeric
|
^
&amp;
&lt; &gt;  
= !
:
+ -
* / %
(all other special characters)
</code></pre>

<p>identifier 의 첫글자가 미리 정의된 테이블에 있다면 우선순위가 정해지는 룰이다.</p>]]></description><link>http://1ambda.github.io/functional-programming-in-scala-chapter-2/</link><guid isPermaLink="false">20cff111-9852-407f-9222-acac9d6733e0</guid><category><![CDATA[scala]]></category><category><![CDATA[coursera]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 29 Sep 2014 16:09:24 GMT</pubDate></item><item><title><![CDATA[Scala for the Impatient, Chapter 1, 2, 3]]></title><description><![CDATA[<h3 id="chapter1">Chapter 1</h3>

<p>(1). 스칼라의 REPL 은 엄밀히 말해서 인터프리터가 아니다. 입력받은 코드를 자바 바이트코드로 컴파일 한 후 자바 가상머신에서 실행시킨뒤 결과를 돌려준다.</p>

<p>(2). 스칼라는 문자열을 위한 추가적인 연산들을 제공하기 위해 <code>java.lang.String</code> 오브젝트를 <code>StringOps</code> 오브젝트로 변환한다. <code>"Hello".intersect("World")</code> 가 그 예다. 따라서 ScalaDoc 을 보려면 <code>SpringOps</code> 클래스를 살펴보는 편이 정신 건강에 좋다.</p>

<p>마찬가지로 <code>Int</code>, <code>Double</code> 등에도 편의 메소드를 추가한 <code>RichInt</code>, <code>RichDouble</code>, <code>RichChar</code> 등을 제공한다. <code>1.to(10)</code> 에서 <code>1</code> 은 <code>RichInt</code> 로 변환된 뒤에 <code>to</code> 메소드를 적용한다.</p>

<p>참고로 스칼라에서는 숫자간 타입 변환을 위해 캐스팅이 아니라 메소드를 사용한다. <code>99.44.toInt</code>, <code>99.toChar</code>, <code>"99.44".toDouble</code></p>

<p>(3). 스칼라에는 <code>++</code> 연산자가 없다.</p>

<p>(4). 스칼라에는 Static Method 대신 <strong>Singleton Object</strong> 와 <strong>Companion Object</strong> 가 있다.</p>

<p>(5). 오브젝트를 수정하지 않는, 인자가 없는 메소드는 괄호를 사용하지 않는다. </p>

<p><code>"Hello".distinct</code> </p>

<p>(6). ScalaDoc 에서 <strong>implicit</strong> 로 태그된 메소드는 자동변환이다. 예를들어 <code>BigInt</code> 오브젝트는 필요할때 자동으로 <code>int</code> 와 <code>long</code> 을 <code>BigInt</code> 로 바꾼다.</p>

<h3 id="chapter2">Chapter 2</h3>

<p>(1). 스칼라에서는 <strong>구문(Statement)</strong> 이 아니라 모든 것을 <strong>식(Expression)</strong> 으로 취급한다. 그런데, <code>else</code> 가 없는 <code>if</code> 문은 값이 없을 수 있는데, 스칼라에서는 <code>Unit</code> 클래스를 도입해서 해결한다. <code>Unit</code> 은 <strong>값 없음</strong> 을 뜻하는 <code>()</code> 을 값으로 가진다.</p>

<p>(2). 스칼라에서 <strong>할당(assignment)</strong> 은 <code>Unit</code> 타입의 값을 가진다. 따라서 할당을 묶어서 사용하지 않는다.</p>

<p><code>x = y = z = 1 // no</code></p>

<p>(3) <code>for</code> 루프에서 인덱스가 필요하면, <code>until</code> 을 사용하면 된다.</p>

<pre><code class="scala">val str = "lambda"  
var sum = 0  
for (index &lt; - 0until str.length)  
  sum += index
</code></pre>

<p>(4). <code>return</code> 이 없는 삶에 익숙해지자, 익명함수를 사용할 경우 리턴값이 쓸모가 없다. <code>break</code> 쯤으로 여기는 것이 마음 편하다.</p>

<p>(5). 재귀 함수는 타입을 반드시 명시해야 한다. <strong>ML</strong> 이나 <strong>하스켈</strong> 같은 일부 언어는 <strong><a href='http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system' >힌들리-밀너</a></strong> 알고리즘을 이용하여 재귀함수의 타입을 추론할 수 있지만, 이 알고리즘은 객체지향과는 잘 안맞는다.</p>

<p>(6). 가변인자가 필요하면, <code>*</code> 를 사용하자. 배열을 풀어헤치기 위해 사용하는 <code>_*</code> 는 <strong>Splat operator</strong> 다</p>

<pre><code class="scala">def sum(args: Int*) = {  
  var sum = 0;
  for(arg &lt;- args) sum += arg
  sum
}

sum(1 to 5: _*)

def recursiveSum(args: Int*): Int = {  
  if (args.length == 0) 0
  else args.head + recursiveSum(args.tail : _*)
}
</code></pre>

<p>참고로, <code>Object</code> 타입의 가변인자를 받으면 <code>42.asInstanceOf[AnyRef]</code> 처럼 직접 변환해야 한다.</p>

<p>(7). <strong>=</strong> 가 없는 함수는 <strong>Unit</strong> 리턴 타입을 가지며, <strong>프로시저</strong> 라 불린다. 값을 리턴하지 않기 때문에, 사이드 이펙트만를 위해 사용한다. 프로시저에서 <code>Unit</code> 을 직접 명시할수도 있다.</p>

<pre><code class="scala">def proc(str: String) {  
  ...
  ... // side effect
  ...
}
</code></pre>

<p>(8). <code>lazy val</code> 을 이용하면, <code>def</code> 처럼 해당 변수가 사용되기 전까지 평가되지 않는다.</p>

<pre><code class="scala">lazy val words = scala.io.Source.fromFile("words.txt").mkString  
</code></pre>

<p>그런데, <code>lazy</code> 로 선언되면 값을 접근할때 마다 스레드세이프하게 초기화가 되었는지 확인하는 검사가 필요하므로 비용이 든다.</p>

<p>(8). 스칼라에는 체크예외가 없다. 모두 런타임 예외다. 그리고, <code>throw</code> 는 <code>Nothing</code> 을 값으로 가지는데, <code>if</code> 문에서는 <code>Nothing</code> 대신 다른 분기의 타입으로 식의 값이 정해진다.</p>

<h3 id="chapter3">Chapter 3</h3>

<p>(1). 고정길이 배열이 필요하면 <code>Array</code> 로 사용하면 된다. 만약 초기값이 필요없으면 <code>new</code> 를 사용하고, 아니면 <code>new</code> 를 제외한다.</p>

<pre><code class="scala">val nums = new Array[Int](10)  
val strs = Array[String]("Hello", "World")  
</code></pre>

<p>고정 배열은 JVM 내부에서 자바의 일반 배열로 처리된다.</p>

<p>(2). 가변빌이 배열이 필요하면 <code>ArrayBuffer</code> 를 사용하면 된다. 자바의 <code>ArrayList</code> 라 보면 된다. </p>

<pre><code class="scala">val ab = ArrayBuffer[Int]()  
ab += 1  
ab += (2, 3)  
ab ++= Array(4, 5)  
</code></pre>

<p><code>ArrayBuffer</code> 끝에 원소를 삽입하고 삭제하는건 성능이 괜찮지만, 중간에 삽입하고 삭제하면 기존의 원소를 옮겨야 하므로 성능이 떨어진다는 점에 주의하자. </p>

<p>만약 <code>Array</code> 를 <code>ArrayBuffer</code> 로 만들려면 <code>toBuffer</code> 메소드를, <code>ArrayBuffer</code> 를 <code>Array</code> 로 만들려면 <code>toArray</code> 를 호출하면 된다.</p>

<p>(3). <code>until</code> 은 <code>RichInt</code> 클래스에 속한다. 만약 0부터 10까지 2씩 건너뛰고 싶으면</p>

<p><code>0 to (10, 2)</code> </p>

<p>거꾸로 순회하고 싶으면</p>

<p><code>(0 to 10).reverse</code></p>

<p>(4). 만약 <code>ArrayBuffer</code> 에 있는 음수 중, 처음 것만 제외하고 모두 삭제하고 싶을때 Flag 를 사용하면 다음과 같은 코드를 만들 수 있다.</p>

<pre><code class="scala">val first = true  
val n = arr.length  
var i = 0

while(i &lt; n) {  
  if (arr(i) &gt;= 0) i += 1
  else {
    if (first) { first = false; i += 1}
    else {
      arr.remove(i); n -= 1
    }
  }
}
</code></pre>

<p>그런데, 배열 버퍼 중간에 있는 원소를 삭제하는건 비효율적이기 때문에, 차라리 인덱스를 보존하고 한꺼번에 옮겨 자르는 편이 더 낫다.</p>

<pre><code class="scala">val indexes = for(i until arr.length if arr(i) &gt;= 0 || first) yield {  
  if (a &lt; 0) first = false;
  i
}

for(j until indexes.length) {  
  arr(j) == arr(indexes(j))
}

arr.trimEnd(arr.length - indexes.length)  
</code></pre>

<p>(4). <strong>for comprehension</strong> 의 <code>guard</code> 와 <code>yield</code> 를 사용하든, <strong>collection</strong> 의 <code>filter</code> 와 <code>map</code>을 사용하든 하는일은 같다.</p>

<p>(5). <code>ArrayBuffer</code> 나 <code>Array</code> 는 <code>max</code>, <code>min</code>, <code>sum</code> 과 같은 메소드 들을 가지고 있다. 그리고 <code>min</code>, <code>max</code> 혹은 <code>scala.util.Sorting.quickSort</code> 에 들어갈 컬렉션의 원소타입들은 반드시 비교 연산을 가지고 있어야 하는데, <strong>숫자</strong>, <strong>문자열</strong>, <strong>Ordered Trait</strong> 을 가지는 타입이 해당된다.</p>

<p>(6). 컬렉션의 원소를 이쁘게 출력하고 싶으면 <code>mkString</code> 을 이용하자.</p>

<pre><code class="scala">Array(1, 2, 3).mkString(" and ")  
// "1 and 2 and 3"
Array(1, 2, 3).mkString("&lt;", ", ", "&gt;")  
//  "&lt;1, 2, 3&gt;"
</code></pre>

<p>(7) <code>Array</code> 의 <code>toString</code> 은 <code>ArrayBuffer</code> 와는 달리 쓸모가 없다.</p>

<pre><code class="scala">scala&gt; Array(1, 2, 3).toString  
// res28: String = [I@412d54b3
</code></pre>

<p>(8). ScalaDoc 을 여행하다보면 기기묘묘한 것들을 만날 수 있다.</p>

<p><code>def appendAll(xs: TraversableOnce[A]): Unit</code> 같은 경우, <code>xs</code> 는 <code>TraversableOnce</code> 트레이트를 구현하는 콜렉션이라 보면 된다.. 스칼라의 모든 컬렉션은  <code>TraversableOnce</code> 또는 흔하게 볼 수 있는 컬렉션의 트레이트로 <code>TraversableIterable</code> 이 있다.</p>

<p><code>def += (elem: A): ArrayBuffer.this.type</code> 의 경우 체이닝이 가능하도록 자기 자신을 리턴하는 메소드다. 이를테면 <code>b += 4 += 5.</code> 처럼</p>

<p><code>def copyToArray[B &gt;: A] (xs: Array[B]): Unit</code> 의 경우 <code>ArrayBuffer[A]</code> 의 모든 원소를 <code>Array[B]</code> 로 복사하는데 <code>B</code>는 <code>A</code> 의 하위 타입이다. <code>ArrayBuffer[Int]</code>,   <code>Array[Any]</code> 처럼</p>

<p>(9). 자바처럼 당연히 컬럼이 고정되지 않은 다차원 배열도 만들 수 있다. </p>

<pre><code class="scala">val triangle = new Array[Array[Int]](10)  
for(i &lt;- 0 to triangle.length)  
  triangle(i) = new Array[Int](i + 1)
</code></pre>

<p>만약 컬럼이 고정된 다차원 배열을 만든다면 <code>ofDim</code> 메소드를 이용하면 된다. 접근하려면 괄호를 두번 사용한다.</p>

<pre><code class="scala">val matrix = Array.ofDim[Double](3, 4)

maxtric(0)(1)  
</code></pre>

<p>(10). 스칼라 배열은 자바 배열로 구현되므로, 당연히 주고 받을 수 있다. <code>java.util.List</code> 를 받거나 리턴하는 자바 메소드를 호출하면 스칼라 코드에서 <code>ArrayList</code> 를 사용할 수 있지만, 이것 대신 <code>scala.collection.JavaConversions</code> 에 속한 메소드들을 임포트하면, 스칼라 버퍼를 자동으로 자바 리스트로 변환할 수 있다. </p>

<p>아래 예제에서 자바의 <code>java.lang.ProcessBuilder</code> 는 <code>List&lt;String&gt;</code> 을 받는 생성자를 가지고 있는데, <code>JavaConversions.bufferAsJavaList</code> 를 임포트하면 스칼라 버퍼가 <code>java.util.List</code> 인터페이스를 구현한 자바 클래스 오브젝트로 감싸진다.</p>

<pre><code class="scala">iport scala.collection.JavaConversions.bufferAsJavaList  
import scala.collection.mutable.ArrayBuffer

val command = ArrayBuffer("ls", "-al" "/home/user")  
val processBuilder(command)  
</code></pre>

<p>반대로 자바 메소드가 <code>java.util.List</code> 리턴하면 <code>Buffer</code> 로 자동으로 변환할 수 있다. 아래 예제에서 <code>cmd == command</code> 다. 바로 <code>ArrayBuffer</code> 로 받지 않는다는 점에 주의하자. <code>Buffer</code> 만 보장한다.</p>

<pre><code class="scala">import scala.collection.JavaConversions.asScalaBuffer  
import scala.collection.mutable.ArrayBuffer  
sd  
val cmd: Buffer[String] = pb.command()  
</code></pre>

<p>참고로, 스칼라의 컬렉션은 <code>immutable</code> 이 기본이고, 자바의 컬렉션은 <code>mutable</code> 이 기본이다.</p>]]></description><link>http://1ambda.github.io/scala-for-the-impatient-chapter-1-2-3/</link><guid isPermaLink="false">d3535bd4-9f25-4ff0-bec0-74124cfc98fd</guid><category><![CDATA[scala]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Fri, 26 Sep 2014 10:31:09 GMT</pubDate></item><item><title><![CDATA[Algorithm I, Chapter 1]]></title><description><![CDATA[<p>Algorithm Part 1, Coursera</p>

<h3 id="unionfind">Union Find</h3>

<h4 id="dynamicconnectivity">Dynamic Connectivity</h4>

<p>N 개의 오브젝트가 있을때, </p>

<ul>
<li><strong>Union command:</strong> connect two objects  </li>
<li><strong>Find/connected query:</strong> is there a path connecting the two objects?</li>
</ul>

<p>이렇게 두 경로가 연결되어있는지 아닌지를 판별하는 알고리즘은 다양하게 활용될 수 있다.</p>

<ul>
<li>Pixels in adigital photo  </li>
<li>Computers in a network  </li>
<li>Friends in a social network  </li>
<li>Transistors in a computer chip  </li>
</ul>

<h4 id="modeling">Modeling</h4>

<p>connection 에서 몇개의 성질들을 뽑아낼 수 있는데,</p>

<ul>
<li><strong>Reflexive:</strong> <em>p</em> is connected to <em>p</em>  </li>
<li><strong>Symetric:</strong> if <em>p</em> is connected to <em>q</em>, then <em>q</em> is connected to <em>p</em>  </li>
<li><strong>Transitive:</strong> if <em>p</em> is connected to <em>q</em> and <em>q</em> is connected to <em>r</em>, then <em>p</em> is also connected to <em>r</em>  </li>
<li><strong>Connected Components:</strong> mamximum set of objects that are mutually connected</li>
</ul>

<p>이제 연산들을 정의해 보면</p>

<ul>
<li><strong>Find query:</strong> Check if two objects are in the same component  </li>
<li><strong>Union command:</strong> Replace components containing two objects with their union</li>
</ul>

<p>연산을 구현할때는 아래의 3가지 요소를 고려해야한다.</p>

<ol>
<li>Number of objects N can be huge  </li>
<li>Number of operations M can be huse  </li>
<li>Find queries and union command may be intermixed</li>
</ol>

<pre><code class="java">;; initialize union-find data structure with N objects (0 to N-1)
class UF(int N) 

;; add connection between p and q
void union(int p, int q)

;; are p and q in the same component?
boolean connected(int p, int q)

;; component identifier for p (0 to N-1)
int find(int p)

;; number of components
int count()  
</code></pre>

<h3 id="quickfind">Quick-find</h3>

<p>Dynamic Connectivity 를 푸는 한 방법으로 <strong>eager approache</strong> 를 사용하는 <strong>Quick-find</strong> 가 있다. </p>

<p>데이터 구조는 배열을 사용하며 <code>int id[]</code>, 만약 <em>p</em> 와 <em>q</em> 가 연결되어있다면 똑같은 값을 가진다. 따라서</p>

<ul>
<li><strong>connected:</strong> <em>p</em> 와 <em>q</em> 가 같은 값을 가지는지 살핀다.  </li>
<li><strong>union:</strong> <code>id[p]</code> 와 같은 가지는 모든 인덱스의 값을 <code>id[q]</code> 로 바꾼다  </li>
</ul>

<p>구현은 다음과 같다.</p>

<pre><code class="java">// UnionFind.java
public interface UnionFind {  
    public void union(int p, int q);
    public boolean connected(int p, int q);
}

// QuickFind.java
public class QuickFind implements UnionFind {

    private int[] id;

    public QuickFind(int N) {
        this.id = new int[N];

        for(int i = 0; i &lt; this.id.length; i++) {
            this.id[i] = i;
        }
    }

    public void union(int p, int q) {
        if (!connected(p, q)) {
            int pValue = id[p];

            // replace id values same as p's into the value of q
            for(int i = 0; i &lt; this.id.length; i++) {
                if (id[i] == pValue) {
                    id[i] = id[q];
                }
            }
        }
    }

    public boolean connected(int p, int q) {
        return id[p] == id[q];
    }

}

// QuickFindTest.java
import static org.hamcrest.CoreMatchers.*;  
import static org.junit.Assert.*;

import org.junit.Before;  
import org.junit.Test;


public class QuickFindTest {

    private UnionFind uf;

    @Before
    public void setup() {
        uf = new QuickFind(10);
    }

    @Test
    public void testConnected() {
        assertThat(uf.connected(0, 1), is(false));
    }

    @Test
    public void testUnion() {
        assertThat(uf.connected(0, 1), is(not(true)));

        uf.union(0, 1);
        uf.union(0, 2);

        assertThat(uf.connected(0, 1), is(true));
        assertThat(uf.connected(1, 2), is(true));
    }
}
</code></pre>

<p><code>find(connected)</code> 연산은 <strong>O(1)</strong>, <code>union</code> 연산은 <strong>O(n)</strong> 의 복잡도를 가진다. 강좌에서는 각각 <strong>2 array accesses</strong>, <strong>at most 2N+1 array accesses</strong> 로 표현했다. 따라서 <strong>Quick-find</strong> 의 Cost Model 은 아래와 같다. (Order of growth of number of array accesses)</p>

<ul>
<li><strong>initialize:</strong> N  </li>
<li><strong>union:</strong> N  </li>
<li><strong>conncected:</strong> 1</li>
</ul>

<p>이런 <strong>Quick-find</strong> 방법 문제점은 <code>union</code> 연산이 너무 비싸다는 것이다. N개의 오브젝트에 대해 N번의 Union 연산을 수행하면 <strong>N^2</strong>, 즉 Quadratic(제곱)의 비용이 드는데, 이건 큰 문제다.</p>

<blockquote>
  <p>Quadratic algorithms don't scale with technology.</p>
</blockquote>

<p>컴퓨터가 10배 빨라지고, 메모리도 10 배만큼 늘었다고 하자. <strong>quadratic algorithm</strong> 으로는 문제의 사이즈가 10배가 되면, 걸리는 시간은 100배가 된다. 연산 시간이 10배 빨라졌으므로 문제를 해결하려면 여전히 10배의 시간이 걸린다. 즉 기술이 10배나 발전해도, 문제의 사이즈에 해당하는 시간이 여전히 걸리는 것이다. </p>

<p><strong>Quick-find</strong> 접근 법은, <strong>find</strong> 연산만 빠르다.</p>

<h3 id="quickunion">Quick-union</h3>

<p><strong>Quick-union</strong> 은 알고리즘 디자인적으로 <strong>lazy approach</strong> 라 볼 수 있다. <strong>Quick-find</strong> 와 같은 자료 구조(배열)을 사용하나 자료 구조에 대한 interpretation 이 다르다. </p>

<p align=""><br/><img src='http://www.timgittos.com/images/pa1/quick-union-overview.png'  />(<a href='http://www.timgittos.com/learning/princeton-algorithms-part-1/week-1/' >http://www.timgittos.com/learning/princeton-algorithms-part-1/week-1/</a>)<br/></p>

<p>이 경우 연산은 각각 아래와 같이 생각할 수 있다.</p>

<ul>
<li><strong>find:</strong> Check if <em>p</em> and <em>q</em> have the same root  </li>
<li><strong>union:</strong> To mege components containing <em>p</em> and <em>q</em>, set the id of <em>p</em>'s root to the id of <em>q</em>'s root</li>
</ul>

<p>구현은 아래와 같다. </p>

<pre><code class="java">// UnionFind.java
// same as above

// QuickUnion.java
public class QuickUnion implements UnionFind {

    private int[] id;

    public QuickUnion(int N) {
        this.id = new int[N];

        for(int i = 0; i &lt; N; i++) {
            this.id[i] = i;
        }
    }

    public int getRoot(int n) {
        int root = id[n];

        while(root != id[root]) {
            root = id[root];
        }

        return root;
    }

    public void union(int p, int q) {
        if (!connected(p, q)) {
            int pRoot = this.getRoot(p);
            int qRoot = this.getRoot(q);
            id[pRoot] = qRoot;
        }
    }

    public boolean connected(int p, int q) {
        return getRoot(p) == getRoot(q);
    }
}
</code></pre>

<pre><code class="java">// QuickUnionTest.java
import static org.hamcrest.CoreMatchers.is;  
import static org.hamcrest.CoreMatchers.not;  
import static org.junit.Assert.assertThat;  
import static org.mockito.Mockito.*;

import org.junit.Before;  
import org.junit.Test;  
import org.mockito.Mockito;

public class QuickUnionTest {

    UnionFind uf;

    @Before
    public void setup() {
        uf = new QuickFind(10);
    }

    @Test
    public void testGetRoot() {
        QuickUnion spy = Mockito.spy(new QuickUnion(5));

        assertThat(spy.getRoot(0), is(0));
        assertThat(spy.getRoot(1), is(1));
        assertThat(spy.getRoot(2), is(2));
        assertThat(spy.getRoot(3), is(3));
        assertThat(spy.getRoot(4), is(4));

        spy.union(0, 1);
        assertThat(spy.getRoot(0), is(1));
        assertThat(spy.getRoot(1), is(1));

        spy.union(2, 3);
        spy.union(4, 2);
        assertThat(spy.getRoot(2), is(3));
        assertThat(spy.getRoot(3), is(3));
        assertThat(spy.getRoot(4), is(3));
    }

    @Test
    public void testConnected() {
        // initial     : 0 1 2 3 4
        // union(0, 1) : 1 1 2 3 4
        // union(2, 3) : 1 1 3 3 4
        // union(3, 1) : 1 1 3 1 4

        //   1   4
        //  0 3
        //    2 

        QuickUnion spy = Mockito.spy(new QuickUnion(5)); 
        when(spy.getRoot(1)).thenReturn(1);
        when(spy.getRoot(0)).thenReturn(1);
        when(spy.getRoot(3)).thenReturn(1);
        when(spy.getRoot(2)).thenReturn(1);
        when(spy.getRoot(4)).thenReturn(4);

        assertThat(spy.connected(0, 4), is(not(true)));
        assertThat(spy.connected(1, 4), is(not(true)));
        assertThat(spy.connected(2, 4), is(not(true)));
        assertThat(spy.connected(3, 4), is(not(true)));

        assertThat(spy.connected(0, 1), is(true));
        assertThat(spy.connected(0, 2), is(true));
        assertThat(spy.connected(0, 3), is(true));
        assertThat(spy.connected(1, 2), is(true));
        assertThat(spy.connected(1, 3), is(true));
        assertThat(spy.connected(2, 3), is(true));
    }

    @Test
    public void testUnion() {
        QuickUnion spy = Mockito.spy(new QuickUnion(5));
        when(spy.getRoot(0)).thenReturn(0);
        when(spy.getRoot(1)).thenReturn(1);
        when(spy.getRoot(2)).thenReturn(2);
        when(spy.getRoot(3)).thenReturn(3);
        when(spy.getRoot(4)).thenReturn(4);

        spy.union(0, 1);
        when(spy.getRoot(0)).thenReturn(1);
        spy.union(2, 3);
        when(spy.getRoot(2)).thenReturn(3);
        spy.union(2, 0);
        when(spy.getRoot(2)).thenReturn(1);
        when(spy.getRoot(3)).thenReturn(1);

        verify(spy, times(1)).connected(0, 1);
        verify(spy, times(1)).connected(2, 3);
        Mockito.reset(spy);

        assertThat(spy.connected(0, 1), is(true));
        assertThat(spy.connected(2, 3), is(true));
        assertThat(spy.connected(2, 0), is(true));
        assertThat(spy.connected(1, 3), is(true));
        assertThat(spy.connected(0, 3), is(true));
    }   
}
</code></pre>

<p>이 경우 <strong>Cost Model</strong> 은 아래와 같다.</p>

<ul>
<li><code>getRoot</code>: depth of <code>n</code> array accesses. <strong>O(n)</strong> in worst case   </li>
<li><code>connected</code>: depth of <code>q</code> and <code>p</code> array accesses. <strong>O(n)</strong> in worst case</li>
<li><code>union</code>: depth of <code>q</code> and <code>p</code> array accesses. <strong>O(n)</strong> in worse case</li>
</ul>

<p><strong>Quick-find</strong> 의 defect 는 
- <code>union</code> is too expensive <br />
- Trees are flat but too expensive keep them flat.</p>

<p><strong>Quick-union</strong> 의 defect 는 
- Trees can get tall <br />
- <code>find(connected)</code> is too expensive (could be N array accesses)</p>

<h3 id="quickunionimprovement">Quick-union Improvement</h3>

<h4 id="1weightedquickunion">1. Weighted Quick-union</h4>

<p>기본 아이디어는 간단하다. <code>union</code> 연산을 수행할때 낮은 트리가 높은 트리에 속하게 함으로써 <strong>Worst case</strong> 를 방지하는 것이다. (마치 Balanced Tree 처럼)</p>

<p align=""><br/><img src='http://my.csdn.net/uploads/201206/12/1339479587_5986.png'  />(<a href='http://my.csdn.net/uploads/201206/12/1339479587_5986.png' >http://my.csdn.net/uploads/201206/12/1339479587_5986.png</a>)<br/></p>

<p>다른것은 모두 같지만, 트리의 크기를 비교해야 하기 때문에 트리의 크기를 저장할 배열이 필요하며, 이런 트리 크기를 비교하고 변경할 로직이 <code>union</code> 메소드에 추가되어야 한다.</p>

<pre><code class="java">// UnionFind.java is same as above
// QuickUnion.java is same as above
// WeightedQuickUnion.java

public class WeightedQuickUnion extends QuickUnion {

    int treeSize[];

    public WeightedQuickUnion(int N) {
        super(N);

        this.treeSize = new int[N];

        for(int i = 0; i &lt; this.treeSize.length; i++)  {
            this.treeSize[i] = 1;
        }
    }

    // for debug
    public int getTreeSize(int index) {
        return treeSize[index];
    }

    @Override
    public void union(int p, int q) {
        if(!connected(p, q)) {
            int qRoot = getRoot(q);
            int pRoot = getRoot(p);

            if (treeSize[qRoot] &gt;= treeSize[pRoot]) {
                id[pRoot] = qRoot;
                treeSize[qRoot] += treeSize[pRoot];
            } else {
                id[qRoot] = pRoot;
                treeSize[pRoot] += treeSize[qRoot];
            }

        }
    }
}
</code></pre>

<pre><code class="java">WeightedQuickUnionTest.java  
import static org.hamcrest.CoreMatchers.*;  
import static org.junit.Assert.*;

import org.junit.Test;  
import org.mockito.Mockito;

public class WeightedQuickUnionTest {

    WeightedQuickUnionTest spy;

    @Test
    public void testUnion() {
        WeightedQuickUnion spy = Mockito.spy(new WeightedQuickUnion(5));

        assertThat(spy.connected(0, 1), is(not(true)));
        // 0 1 -&gt; 1 1
        spy.union(0, 1);
        assertThat(spy.connected(1, 0), is(true));
        assertThat(spy.getTreeSize(0), is(1));
        assertThat(spy.getTreeSize(1), is(2));

        // 1 1 2 -&gt; 1 1 1 
        spy.union(0, 2);
        assertThat(spy.connected(0, 1), is(true));
        assertThat(spy.connected(1, 2), is(true));
        assertThat(spy.connected(0, 2), is(true));

        assertThat(spy.getRoot(0), is(1));
        assertThat(spy.getRoot(1), is(1));
        assertThat(spy.getRoot(2), is(1));

        // 1 1 1 4 4
        spy.union(3, 4);
        assertThat(spy.connected(1, 3), is(false));
        assertThat(spy.connected(4, 3), is(true));

        // 1 1 1 4 1
        spy.union(2,  4);
        assertThat(spy.connected(4, 3), is(true));
        assertThat(spy.getRoot(4), is(1));
        assertThat(spy.getRoot(3), is(1));
    }
}
</code></pre>

<p>이 때 <strong>Cost Model</strong> 은</p>

<ul>
<li><code>find</code>: taks time proportional to depth of <em>p</em> and <em>q</em> <strong>O(logN)</strong></li>
<li><code>union</code>: take constant time, given roots (without roots <strong>O(logN)</strong>)</li>
</ul>

<p>같은 사이즈의 트리끼리 merged 도야 depth 가 1 깊어지므로 N개의 원소에 대해 <strong>Weighted Quick-union</strong> 이 구성하는 트리는 아무리 깊어봐야(at most) <strong>lg <em>N</em></strong> 이다. </p>

<h4 id="2pathcompression">2. Path Compression</h4>

<p>또 다른 <strong>Quick-union</strong> 개선 방안은, <strong>Path Compression</strong> 으로 루트를 탐색할때마다, 루트값을 새로 고쳐 써 다음번에 탐색할때 탐색 시간을 줄이는 방법이다.</p>

<pre><code class="java">// WeightedQuickUnion.java

...
...
    public int getRoot(int n) {

        int root = id[n];

        while(root != id[root]) {
            id[root] = id[id[root]];
            root = id[root];
        }

        return root;
    }
...
...
</code></pre>

<p><strong>WQUPC(Weighted Quick-union with path compression)</strong> 은 <a href='http://upload.wikimedia.org/math/6/b/3/6b3721001c02b39a0da7d57a129e7661.png' >iterated logarithm (<strong>lg*<em>N</em></strong>)</a> 의 복잡도를 가진 다는 것이 증명 되었다. <strong>WQUPC</strong> 는 실제로 데이터를 읽어 들이는 비용도 있기 때문에 이론적으로는 linear 하지 않으나, 실제로는 linear 할 수 있다. </p>

<p><strong><em>N</em></strong> 개의 오브젝트를 초기화 하고 여기에 대해 <strong><em>M</em></strong> 번의 <code>union-find</code> 연산을 수행한다면 <strong>Worst case</strong> 에 대해 복잡도를 정리해 보면</p>

<ul>
<li><strong>Quick-find:</strong> M * N  </li>
<li><strong>Quick-union:</strong> M * N  </li>
<li><strong>Weighted Quick-union:</strong> N + M <em>logN</em> (array 를 balanced 하게 만든다.)  </li>
<li><strong>Quick-union with path compression:</strong> N + M <em>logN</em> (array 를 flat 하게 만든다.)  </li>
<li><strong>WQUPC:</strong> N + M lg*<em>N</em></li>
</ul>

<p>이렇게 보면 알고리즘의 복잡도는 별거 없어보이는데, 사실 무지막지하게 큰 차이다. 10^9 개의 오브젝트에 대해서 10^9 연산을 할 경우 <strong>Quick-find</strong> 를 사용할때 30년이 걸린다면 <strong>WQUPC</strong> 는 6초만에 해결할 수 있다. 다시 말해, 알고리즘은 슈퍼컴퓨터도 별 도움이 되지 못하는 문제를 해결할 수 있다.</p>

<h3 id="applicationsofunionfind">Applications of Union-find</h3>

<ul>
<li>Percolation  </li>
<li>Dynmaic Connectivity  </li>
<li>Lear common ancestor  </li>
<li>Kruskal's minimum spanning tree</li>
<li>and so on  </li>
</ul>

<h4 id="percolation">Percolation</h4>

<p align=""><br/><img src='http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolates.png'  />(<a href='http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation.html' >http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation.html</a>)<br/></p>

<p><strong>Percolation</strong> 이란, <em>N</em>-by-<em>N</em> 의 Grid 에서 각 opened-site 는 확률 <em>p</em> blocked-site 는 <em>1-p</em> 의 확률을 가진다. 이 모델은 주로 물리 시스템을 모델링하기위해 사용된다.</p>

<p>이론상 <em>N</em> 이 충분히 크면 </p>

<ul>
<li><em>p</em> > <em>p*</em> 인 지점에서는 almost certainly percolates 하고  </li>
<li><em>p</em> &lt; <em>p*</em> 인 지점에서는 alomost certainly does not percolate 하다.</li>
</ul>

<p align=""><br/><img src='http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation-threshold20.png'  /> (<a href='http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation.html' >http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation.html</a>)<br/></p>

<p>문제는 그런 <em>p*</em> 값이 무엇이냐 하는건데, 수학적으로는 찾을 길이 없고, 컴퓨터 시뮬레이션으로는 <strong>Union-find algorithm</strong> 을 이용하면 구할 수 있다. 유명한 방법으로 <strong>Monte Carlo simulation</strong> 이 있는데, <em>N</em>-by-<em>N</em> Grid 를 blocked site 로 채우고, 랜덤하게 open site 를 만들면서 top 과 bottom 이 percolate 되는지 매번 확인한다. 연결되면, vacancy percentage 가 <em>p*</em> 에 대한 추정값이다.</p>

<p>구현 방법은 각 site 를 노드로 생각하고, top 과 bottom 을 그룹으로 묶어(virtual site) top 이 bottom 과 연결되는지 매번 체크하면 된다. 자세한 내용은 <a href='http://www.cs.princeton.edu/courses/archive/fall14/cos226/assignments/percolation.html' >여기</a>를 참조</p>]]></description><link>http://1ambda.github.io/union-find-algorithms-week-1/</link><guid isPermaLink="false">df59dca1-76f2-4e0c-be10-96e24881af0d</guid><category><![CDATA[Algorithm]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 22 Sep 2014 05:49:05 GMT</pubDate></item><item><title><![CDATA[Deadlock]]></title><description><![CDATA[<p>데드락 그 자체보다는, 데드락을 어떻게 해결하는가가 더 중요한 것 같다.</p>

<h3 id="deadlocknecessaryconditions">Deadlock Necessary Conditions</h3>

<p><strong>Deadlock</strong> 은 <strong>Coffman conditions</strong> 으로 알려진 아래 4개의 조건들이 모두 동시에 일어날때 발생한다. 만약 조건 중 하나라도 막을 수 있다면, <strong>Deadlock</strong> 이 발생하지 않는다. </p>

<ol>
<li><p><strong>Mutual Exclusion:</strong> at least one resource must be held in a non-shareable mode. Only one process can use the resource at any given instant of time  </p></li>
<li><p><strong>Resource Holding:</strong> a process is currently holding at least one resource and requesting additional resources which are held by other processes</p></li>
<li><p><strong>No Preemption:</strong> a resource can be released only voluntarily by the process holding it, after that process has completed its task</p></li>
<li><p><strong>Circular Wait:</strong> a process must be waiting for a resource which is being held by another process, which in turn is waiting for the first process to release the resource.</p></li>
</ol>

<p><a href='http://en.wikipedia.org/wiki/Deadlock' >위키피디아</a> 에 의하면 최근의 운영체제 시스템도 데드락이 발생하는걸 예방할수는 없고, 발생한다 하더라도 서로 다른 해결 방식을 취한다고 한다. 대부분의 경우 데드락을 예방하기 위해서 <strong>Circular Wait</strong> 조건을 방지하려고 하는데, 대표적인 데드락 방지 방법은 다음의 4가지다.</p>

<ol>
<li><strong>Ignoring Deadlock</strong>  </li>
<li><strong>Detection</strong> and <strong>Recovery</strong>  </li>
<li><strong>Prevention</strong>  </li>
<li><strong>Avoidance</strong></li>
</ol>

<h3 id="deadlockhandling">Deadlock Handling</h3>

<h4 id="1ignoringdeadlock">1. Ignoring Deadlock</h4>

<p>가장 마음 편한 방법이다. <strong>Deadlock</strong> 이 발생하지 않으리라 생각하며, 발생해도 무시한다. <a href='http://en.wikipedia.org/wiki/Ostrich_algorithm' >Ostrich Algorithm</a> 이라고도 알려져 있는데, 쉽게 말해서 <strong>Convenience</strong> 와 <strong>Correctness</strong> 를 교환하는 방법이다. 데이터 손실이나, 데드락 발생 간격이 허용될만큼 충분히 작다면, 이를 해결하기 위해 궂이 성능을 낮출 필요가 없다는 것이다. poor worst-case performance 알고리즘의 대표적인 예로 <strong>Standard ML</strong> 의 type-checking 알고리즘이 있다고 한다.</p>

<h4 id="2detection">2. Detection</h4>

<p><strong>Deadlock</strong>이 발생할 수 있다고 보고, 감지한 뒤 해결하는 방법이다. <strong>Deadlock</strong>을 감지하기 위해서 recourse allocation 과 process states 를 추적 해야 한다. <strong>finite state-model</strong> 등을 이용해서 termination 조건을 결정하는 방법을 사용한다고 위키에 나와있다. (오토마타는 컴파일러뿐 아니라 여러 분야에서 중요한 것 같다.)</p>

<p>(1). <strong>Deadlock</strong> 을 발견한 뒤에는 <strong>Process Termiantion</strong> 을 통해 해결할 수 있다. 그러나 단순히 모든 프로세스를 종료 하게 되면, 진행중이던 computation 과 같은 리소스 들이 낭비되기 때문에 어떤 프로세스를 종료해야 가장 리소스 낭비가 적을지 결정해야 하는데, 이 부분이 쉽지 않다. 해당 프로세스를 종료 했을 때 <strong>Deadlock</strong> 이 풀릴지 아닐지를 계산하고, priority 와 process age 를 고려해야 하기 때문에 복잡하다.</p>

<p>(2). 다른 대안으로 <strong>Deadlock</strong>이 풀릴 때 까지 <strong>Resource Preemption</strong> 을 사용할 수 도 있다.</p>

<h4 id="3prevention">3. Prevention</h4>

<p><strong>Coffman conditions</strong> 중 하나를 방지하면 된다. (참 쉽죠?) </p>

<p>(1). <strong>Mutual exclusion</strong> 조건을 제거한다는건, 어느 프로세스도 resource 에 대해 배타적인 접근 권한을 가지지 못한다는 건데, 놀랍게도 <strong>spooled</strong> 될 수 없는 리소스에 대해서는 이러한 방법을 사용하지 못한다. 게다가 spooled resources 라 하더라도 <strong>Deadlock</strong> 은 여전히 발생할 수 있다. <strong><a href='http://en.wikipedia.org/wiki/Non-blocking_algorithm' >Non-blocking synchronization</a></strong> 알고리즘이 <strong>mutual exclusion</strong> 을 피할 수 있는 방법인데, 이 알고리즘은 스레드의 execution 이 indifinitely postponed 되는걸 막는다. <a href='http://www.slideshare.net/zzapuno/kgc2013-3' >여기</a> 에 의하면, 정해진 시간당 최소한 하나의 호출이 완료될 때 <strong>Lock-free</strong> 하다고 볼 수 있으며 충돌과는 관계 없이 모든 호출이 완료되면 <strong>Wait-free</strong> 하다고 한다. 아래는 위키를 인용</p>

<blockquote>
  <p>In computer science, a non-blocking algorithm ensures that threads competing for a shared resource do not have their execution indefinitely postponed by mutual exclusion. A non-blocking algorithm is lock-free if there is guaranteed system-wide progress regardless of scheduling; wait-free if there is also guaranteed per-thread progress.</p>
</blockquote>

<p>(2). <strong>Resource holding</strong> 조건의 경우에는 프로세스에게 <strong>시작 전에 필요한 모든 리소스를 요청</strong>하도록 함으로써 해결할 수 있는데, 말이 쉽지 시작 전에 사용할 모든 리소스를 파악하는 것도 어려우며, 모든 리소스를 사용할거라는 이유만으로 미리 할당하는 것은 비효율적이다. </p>

<p>다른 방법으로는 프로세스가 아무런 리소스를 가지고 있지 않을때만 리소스를 요청하도록 하는 방법이 있다. 따라서 프로세스들은 처음에 가지고 있는 모든 리소스를 release 해야만 이후에 필요한 리소스를 요청할 수 있다. 이 방법 또한 리소스가 덜 사용되므로 비효율적이다. 또한 자주 사용되는 리소스를 사용하는 프로세스는 무기한 대기할 수 있어 기아상태를 낳을 수 있다. <strong><a href='http://en.wikipedia.org/wiki/Serializing_tokens' >Serializing token</a></strong> 이 <strong>All-or-none</strong> 알고리즘으로 알려져 있다.</p>

<p><strong>Serializing token</strong> 와 <strong>Mutexex</strong> 는 shared resource 를 동시에 접근하는걸 막는다는 점에서 비슷하지만, <strong>Serializing tokens</strong> 은 해당 스레드가 blocked 혹은 asleep 상태일때는 다른 스레드의 shared resource 에 대한 접근을 막지 못한다. 따라서 <strong>Timeslicing</strong>, <strong>Preemption</strong>, <strong>Concurrent Execution</strong> 에 대해서는 <strong>Mutexes</strong> 처럼 동작하지만 <strong>Voluntary Blocking</strong> 에 대해서는 다른 스레드의 리소스 접근을 허용할 수 있다.</p>

<p>그럼에도 불구하고, <strong>Mutexes</strong> 가 <strong>Deadlock</strong> 이나 <strong>Priority Inversion</strong> 등 해결하기 어려운 문제를 발생시킬 수 있기 때문에, <strong>Deadlock</strong> 이 발생하지 않고, 코드를 간결하게 만드는 <strong>Serializing Tokens</strong> 을 이용하기도 한다. 아래는 위키 인용</p>

<blockquote>
  <p>Serializing tokens allow programmers to write multiprocessor-safe code without themselves or the lower level subsystems needing to be aware of every single entity that may also be holding the same token.</p>
  
  <p>In fact, the fact that tokens do not deadlock coupled with the fact that there is no expectation of atomicity for earlier acquired tokens when later operations block leads to a great deal of code simplification. If you look at FreeBSD-5, you will notice that FreeBSD-5 passes held mutexes down the subroutine stack quite often, in order to allow some very deep procedural level to temporarily release a mutex in order to switch or block or deal with a deadlock. There is a great deal of code pollution in FreeBSD-5 because of this (where some procedures must be given knowledge of the mutexes held by other unrelated procedures in order to function properly).</p>
</blockquote>

<p>(3). 어떤 프로세스든 최소 일정시간동안은 리소스를 보유해야 하기 때문에 <strong>No preempition</strong> 조건을 막기는 어렵거나 불가능할 수 있다. 게다가 리소스가 대해 <strong>Preemption System</strong> 의 경우에는 inconsistent processing outcome 이나, thrashing 이 발생할 수 있다.</p>

<p>일반적으로 잠긴(locked out) 리소스에 대한 preemption 은 <strong>rollback</strong> 을 의미하는데, 이건 오버헤드가 무지 크므로 주의해야 한다. preemption 을 허용하는 알고리즘에는 <strong><a href='http://en.wikipedia.org/wiki/Lock-free_and_wait-free_algorithms' >lock-free and wait-free algorithms</a></strong> 과 <strong><a href='http://en.wikipedia.org/wiki/Optimistic_concurrency_control' >optimistic concurrency control</a></strong> 이 있다.</p>

<p>(4). <strong>Circular Wait</strong> 을 방지하는 방법은, 크리티컬 섹션에서 인터럽트를 불가능하게 만들고 resource 에 대해 order 를 만들어 두어, 순서대로 얻어야만 상위 레벨의 resource 를 얻도록 하는 방법이 있다. <a href='http://en.wikipedia.org/wiki/Dining_philosophers_problem' #Resource_hierarchy_solution">식사하는 철학자</a> 문제에서 다익스트라가 제안한 방법이기도 하다.</p>

<p>그러나 이 방법은 하위 레벨의 리소스를 점유하기 위해서는, 상위 레벨의 리소스를 release 해야 하기 때문에 오버헤드가 생긴다. 특히 대용량 데이터베이스에 접근하는 어플리케이션의 경우, low-level 레코드를 얻기 위해 high-level 레코드를 방출하는 경우가 발생할 수 있는데, 극심한 비효율을 야기할 것이다.</p>

<h4 id="4aviodance">4. Aviodance</h4>

<p>리소스에 대해 특정 정보를 알 수 있는 경우, 리소스를 할땅 할 때마다 시스템이 <strong>Deadlock</strong> 을 야기할 수 있는 unsafe 한 상태로 넘어가는지 검사하여 <strong>Deadlock</strong> 을 피할 수 있다. 이를 위해서는 최소한 다음의 조건들을 알아야 한다.</p>

<ul>
<li>resources currently available</li>
<li>resources currently allocated to each process</li>
<li>resources that will be required and release by these processes in the future</li>
</ul>

<p>대표적인 알고리즘이 <strong><a href='http://en.wikipedia.org/wiki/Banker%27s_algorithm' >Banker's algorithm</a></strong> 이다. 새로운 프로세스가 시스템에 등록될때는, 어떤 리소스가 요구될지 미리 기록해야 하며 이 리소스들은 시스템이 가진 리소스를 초과하지 않아야 한다. 리소스가 할당 될때도, 시스템이 가진 총량을 넘을 수 없으며 사용 가능한 한도 내에 있어야 리소스가 프로세스에게 할당이 된다. 그러나 프로세스가 얼마만큼의 리소스가 필요할지 사전에 정확하게 예측하는건 어려운 일이다.</p>

<p><strong>Wait/Die</strong> 또는 <strong>Wound/Wait</strong> 이라 불리는 알고리즘도 있다. 타임스탬프를 이용해서 어느 프로세스가 오래되었는지 판별한 뒤에 다음과 같은 알고리즘을 적용할 수 있다. 알파벳 O 는 오래된 프로세스, Y 는 신규 프로세스다</p>

<ol>
<li><p><strong>Wait/Die</strong>  </p>

<ul><li>O needs a resource held by Y : O Waits</li>
<li>Y needs a resource held by O : Y dies</li></ul></li>
<li><p><strong>Wound/Die</strong>  </p>

<ul><li>O needs a resource held by Y : Y dies</li>
<li>Y needs a resource held by O : Y waits</li></ul></li>
</ol>]]></description><link>http://1ambda.github.io/deadlock/</link><guid isPermaLink="false">6e81bd41-1934-419f-b475-b148af68c7ab</guid><category><![CDATA[Operating System]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Mon, 22 Sep 2014 00:40:26 GMT</pubDate></item><item><title><![CDATA[Practical Common Lisp, Chapter 7]]></title><description><![CDATA[<h3 id="macrosstandardcontrolconstrucs">MACROS : STANDARD CONTROL CONSTRUCS</h3>

<blockquote>
  <p>All programmers should be used to the idea that the definition of a language can include a standard library of functionality that is implemented in terms of the "core" language functionality that could have benn implemented by any programmer on top of the language if it hand't been defined as part of the standard library.</p>
</blockquote>

<p>다른 언어에서 특정 기능이 부족할때 새로운 클래스나 메소드를 정의함으로서 standard library 를 확장할 수 있지만, Lisp 은 이 방법 외에도 <strong>Macro</strong> 라는 조금 다른 방식을 제공한다.</p>

<p>각 매크로는<code>s-exp</code> 가 어떻게 lisp forms 으로 확장될지를 결정하는 자신만의 <strong>Syntax</strong> 를 정의할 수 있다. 이런 <strong>Macro</strong> 의 기능으로 인해서 <strong>Language</strong> 자체의 <strong>Syntax</strong> 가 확장될 수 있다. 대표적인 예가 <code>WHEN</code>, <code>DOLIST</code>, <code>LOOP</code> 와 같은 control constructs 와 <code>DEFUN</code>, <code>DEFPARAMETER</code> 과 같은 definitinal forms 들이다.</p>

<h4 id="whenandunless">WHEN and UNLESS</h4>

<p><code>(if condition then-form [else-form])</code> 은 <code>then-form</code> 과 <code>else-form</code> 이 single lisp form 이어야 한다는 제한을 가지고 있다. </p>

<p>그렇기 때문에 스팸 메일을 받았을때, 폴더에 저장하고, 데이터베이스에 업데이트 하려고 할 때 <code>if</code> 구문을 다음과 같이 작성하면, 제대로 작동하지 않는다. </p>

<pre><code class="lisp">(if (spam-p current-message)
    (file-in-spam-folder current-message)
    (update-spam-database current-message))
</code></pre>

<p>이 코드의 경우 <code>update-spam-database</code> 함수는 <code>if-then</code> 이 아니라 <code>else-then</code> 에 붙어있는 form 으로 인식되어 의도했던 바 대로 실행되지 않는다.</p>

<p><code>progn</code> 을 이용하면, 여러 form 을 묶을 수 있기 때문에 다음과 같이 작성하면 제대로 동작한다.</p>

<pre><code class="lisp">(if (spam-p current-message)
    (progn
      (file-in-spam-folder current-message)
      (update-spam-database current-message)))
</code></pre>

<p>그러나 매번 <code>progn</code> 을 써야한다는 사실이 귀찮고, <code>if</code> 와 <code>progn</code> 의 조합으로 해당 역할을 해낼 수 있다는걸 깨달았으므로, 다음과 같은 인터페이스를 가지는 <code>when</code> 매크로를 작성해보자.</p>

<pre><code class="lisp">(when (spam-p current-message)
  (file-in-spam-folder current-message)
  (update-spam-database current-message))

(defmacro when (condition &amp;rest body)
  `(if ,condition (progn ,@body)))

(defmacro unless (condition &amp;rest body)
  `(if (not ,condition) (progn ,@body)))
</code></pre>

<h4 id="cond">COND</h4>

<p><code>if</code> 같은 경우도, 중첩되면 보기가 싫어질 수 있다.</p>

<pre><code class="lisp">(if a
    (do-x)
    (if b
        (do-y)
        (do-z)))
</code></pre>

<p>이를 위해서 <code>cond</code> 매크로를 만들어 보자.</p>

<pre><code class="lisp">(defmacro cond (&amp;rest body)
  (when body
    (let ((clause (first body)))
      `(if ,(first clause) (progn ,@(rest clause))
           (cond1 ,@(rest body))))))
</code></pre>

<h4 id="andorandnot">AND, OR, and NOT</h4>

<p><code>AND</code> 와 <code>OR</code> 같은 경우 <strong>short-circuit</strong> 을 구현하기 위해서는, 두번 째 인자를 평가하지 않아야 하는데, 일반 함수로는 인자의 평가 시기를 조절하기 불가능하고, 매크로를 이용하면 그럴 수 있다.</p>

<pre><code class="lisp">;; AND and OR macros
(defmacro and1 (x &amp;rest other)
  `(if ,(not other)
       ,x
       (if ,x (and1 ,@other) nil)))

(defmacro or1 (x &amp;rest other)
  `(if ,(not other)
       ,x
       (if ,x ,x (or1 ,@other))))
</code></pre>

<h4 id="looping">Looping</h4>

<p>Lisp 의 25가지 special operators 는 직접적으로 Looping 을 지원하지 <strong>않기</strong> 때문에 Lisp 의 모든 looping control constructs 는 이 specical operator 를 이용해 만든 Macro 다.</p>

<p><code>DO</code> 는 강력하지만, less expressie 하기 때문에 <code>DO</code> 위에 만들어진 <code>DOTIMES</code> 와 <code>DOLIST</code> 를 제공한다. <code>LOOP</code> 는 non-lispy, english-like 스타일의 문법을 제공한다.</p>

<h4 id="dolistanddotimes">DOLIST and DOTIMES</h4>

<p>아래는 <code>DOLIST</code> 와 <code>DOTIMES</code> 의 문법과 사용법이다.</p>

<pre><code class="lisp">;; syntax
(dolist (var list-form)
  body-form*)

(dotimes (var count-form)
  body-form*)

;; example
(dolist (x '(1 2 3)) (princ x) (princ x)) ;; 112233
(dotimes (x 4) (princ x) (princ x)) ;; 00112233
(dotimes (x 4) (print x) (if (= (/ x 2) 0) (return))) ;; 0 1 2
(dotimes (x 20)
       (dotimes (y 20)
         (format t "x: ~d, y: ~d~%" x y)))
</code></pre>

<h4 id="do">DO</h4>

<p><code>DO</code> 의 Syntax 와 사용법은 아래와 같다.</p>

<pre><code class="lisp">;; Syntax
(do (variable-definitions*)
    (end-test-form result-form*)
  statement*)

;; Usage : fibonacci
(do ((n 0 (+1 n))
     (cur 0 next
     (next 1 (+ cur next)))
    ((=10 n) cur))

;; Usage: omiited result-form
;; same as (dotimes (i 4) (print i))
(do ((i 0 (1+ i)))
    ((&gt;= i 4))
   (print i))
</code></pre>]]></description><link>http://1ambda.github.io/practical-common-lisp-chapter-7/</link><guid isPermaLink="false">24b1d760-68b1-4861-b657-28f45fccdcc8</guid><category><![CDATA[Lisp]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 17 Sep 2014 17:18:47 GMT</pubDate></item><item><title><![CDATA[Functional Programming in Scala, Chapter 1]]></title><description><![CDATA[<p>2014-09-16, <strong>Functional Programming in Scala</strong>, Coursera</p>

<h3 id="11programmingparadigms">1.1 Programming Paradigms</h3>

<h4 id="imperativeprogramming">Imperative Programming</h4>

<ul>
<li>modifying mutable variables  </li>
<li>using assignment  </li>
<li>and control str such as if-then-else, loop breakl continue, return  </li>
</ul>

<p>절차적인 프로그래밍은 폰 노이만 구조랑 비슷한데, </p>

<ul>
<li>Mutable var = memory cells  </li>
<li>variable deferences = load instructions  </li>
<li>var assginment = store instsruction  </li>
<li>control structure = jumps  </li>
</ul>

<p>그런데 이런 instruction 들이 <code>word</code> 로 구성되어있으므로, 문제는  </p>

<blockquote>
  <p>"Scaling up, How can we avoid conceptualizign programs word by word?"</p>
</blockquote>

<p>결국 pure Imperative Programming 은 폰노이만 구조처럼 제한을 받는다고 볼 수 있다.</p>

<blockquote>
  <p>"One tends to conceptualize data structures word-by-words"</p>
</blockquote>

<p>그렇기 때문에 컬렉션, 다항식, 문자열과 같은 high-level abstraction 을 정의할 방법이 필요한데, 이상적으로는 <strong>Theory</strong> 를 만들면 해결할 수 있다. Theory 는 다음을 포함하는데</p>

<ul>
<li>one or more data types  </li>
<li>operations on these types  </li>
<li>laws that describe the relationships between values and opertions</li>
</ul>

<p>그러나, 일반적으로 <strong>Theory</strong> 는 mutation 에 대해서는 describe 하지 않지만 Imperative Programming 에서는 mutation 때문에 theories 가 부서질(break) 수 있음. 따라서 다음과 같은 것들이 필요하다. </p>

<ul>
<li>Concentrate on defining theories for operators expressed as function  </li>
<li>avoid mutations  </li>
<li>have powerful way to abstract and compose functions  </li>
</ul>

<p>정리하자면, Imperative Programming 에서는 high-level abstraction 을 위해 theory 를 이용할 수 있는데, Imperative Programming 에서는 mutation variable 을 이용하므로 theory 의 law 를 break 할 수 있다. 따라서 이런 단점을 해결하기 위해 나온 것이 Functional Programming 이다.</p>

<p>Functional Programming 에서는 상태가 Immutable 이기 때문에 <strong>Theory</strong> 를 구성하는 operator 를 만드는 것에 집중할 수 있다.</p>

<h4 id="functionalprogramming">Functional Programming</h4>

<ul>
<li>without mutable variables, assignments, loops  </li>
<li>focuses on functions</li>
</ul>

<p>FP offers the folloing benefits</p>

<ul>
<li>simpler reasoning principles  </li>
<li>better modularity  </li>
<li>good for exploiting parallelism fo mlticore and clod compting  </li>
</ul>

<h3 id="12elementsofprogramming">1.2 Elements of Programming</h3>

<h4 id="expression">Expression</h4>

<p>대다수의 언어들은 <strong>expression</strong> 과 관련해서 다음의 기능들을 제공한다</p>

<ul>
<li>primitive expressions, representing the simplest elements  </li>
<li>ways to combine expressions  </li>
<li>ways to abstract expressions, which introduce a name for an expression by which it can then be referred to.</li>
</ul>

<h4 id="evaluation">Evaluation</h4>

<p><strong>Non-primitive</strong> expression 은 최종적으로 value 를 만들기 전까지 다음과 같은 방식으로 evaluated 된다</p>

<ol>
<li>Take the leftmost operator  </li>
<li>Evaluate its operands (left before right)  </li>
<li>Apply the operator to the operands</li>
</ol>

<p><strong>A name</strong> is evaluatd by replacing it with the right hand side of its definition.</p>

<p>그러나 모든 expression 이 finite value 를 가지는 것은 아니다. </p>

<pre><code class="scala">def loop: Int = loop  
</code></pre>

<h4 id="evaluationoffunctionapplications">Evaluation of Function Applications</h4>

<p>Applications of parameterized functions 은 다음과 같은 방식으로 evaluated 된다. operator 와 얼추 비슷하다</p>

<p>(1) Evaluate all function arguments, from left to right <br />
(2.1) Replace the function application by the function's right-hand side, and, at the same time <br />
(2.2) Replace the formal parameters of the function by the actual arguments</p>

<pre><code class="scala">def square(x: Int) = x * *  
def sumOfSquares(x: Int, : Int) = square(x) + square(x)

sumOfSquares(3, 2+2)

// sumOfSquares(3, 4) : step (1) 
// square(3) + square(4) : step (2) 
// 3 * 3 + square(4) : step (1), (2)
// 9 + square(4)
// 9 + 4 * 4
// 9 + 16
// 25
</code></pre>

<p>인자를 먼저 평가하지 않을 경우 <code>square(2+2)</code> 가 <code>(2*2) + (2*2)</code> 로 reduced 되어 더 많은 계산을 야기할 수 있다.</p>

<h4 id="thesubstitutionmodel">The substitution model</h4>

<p>이렇게 Evaluation 해 나가는 과정을 <strong>The substitution model</strong> 이라 부른다. 이 모델의 근간이 되는 아이디어는 <strong>reducing an expression to a value</strong> 이고, <strong>side-effect</strong> 가 없는 한 모든 expressions 에 적용할 수 있다. 참고로 이 모델은 Functional Programming 의 근간이 되는 <strong>lambda-calculus</strong> 사용한 것이다.</p>

<h4 id="callbyvaluecallbyname">Call-by-value, Call-by-name</h4>

<p><code>square(4)</code> 처럼 <code>sumOfSquares</code> 의 인자가 먼저 평가되는 방식을 <strong>Call-by-value</strong>, <code>square(2+2)</code> 처럼 나중에 인자가 평가되는 방식을 <strong>Call-by-name</strong> 이라 부른다. </p>

<p>두 가지 방식 아래 조건이 지켜지는 한 모두 expression 을 value 로 reduce 한다</p>

<ul>
<li>the reuced expression consists of pure functions, and  </li>
<li><p>both evaluations terminate</p></li>
<li><p><strong>Call-by-value</strong> has the advantage that it evaluates every function argument only once  </p></li>
<li><strong>Call-by-name</strong> has the advantage that a function argument is not evaluated if the corresponding parameter is unused in the evaluation of the function body  </li>
</ul>

<h4 id="examples">Examples</h4>

<pre><code class="scala">def test(x: Int, y: Int) = x *x  
</code></pre>

<p>위와 같은 함수가 있다고 할때, <code>test(3, 4)</code> 는 똑같은 속도지만 <code>test(2+2, 3)</code> 은  <strong>Call-by-value</strong> 가, <code>test(2, 3+2)</code> 는 <strong>Call-by-name</strong> 이 더 빠르다</p>

<h3 id="13evaluationstrategiesandtermination">1.3 Evaluation Strategies and Termination</h3>

<p>But what if termination is not guaranteed?</p>

<pre><code class="scala">def test (x: Int, y: Int) = x * x  
def loop () = loop  
</code></pre>

<p>위의 예제에서 <code>test(3, loop)</code> 라는 expressions 은 <strong>Call-by-name</strong> 방식으로 평가될 수 있지만, <strong>Call-by-value</strong> 방식으로는 아니다. </p>

<p>Scala 은 일반적으로 re-computation 을 피하기 위해 <strong>Call-by-value</strong> 을 사용한다. 그러나 <code>def constOne(x: Int, y: =&gt; Int) = 1</code> 처럼 function parameter 가 <code>=&gt;</code> 로 시작하면 해당 인자는 <strong>Call-by-name</strong> 을 이용한다.</p>

<pre><code class="scala">def constOne(x: Int, y: =&gt; Int) = 1  
def loop() = loop

constOne(1+2, loop) // will be evaluated  
constOne(loop, 1+2) // will not be evaluated  
</code></pre>

<h3 id="14conditionalsandvaluedefinitions">1.4 Conditionals and Value Definitions</h3>

<h4 id="conditionalexpression">Conditional Expression</h4>

<pre><code class="scala">def abs(x: Int) = if (x &gt;= 0) x else -x  
</code></pre>

<p>In the above example, <code>x &gt;= 0</code> is a predicate, of type Boolean. and <code>If-else</code> is an expression not a statement</p>

<h4 id="shortcircuitevaluation">short-circuit evaluation</h4>

<p>Boolean 을 위한 Rule 을 다시 만들수 있다.</p>

<pre><code>!true      --&gt; false
!false     --&gt; true
true &amp;&amp; e  --&gt; e  
false &amp;&amp; e --&gt; false  
true || e  --&gt; true  
false || e --&gt; e  
</code></pre>

<p><code>&amp;&amp;</code> 와 <code>||</code> 의 경우에는 언제나 오른쪽 operand 가 평가되야 하는건 아닌데, 이러한 expression 을 보고 <strong>short-circuit evaluation</strong> 을 사용한다고 말한다.</p>

<h4 id="valuedefinitions">Value Definitions</h4>

<pre><code class="scala">def x loop(): Booelan = loop  
</code></pre>

<p>위의 식이 평가되는걸 보면 <code>def</code> 는 <strong>Call-by-value</strong> 를 이용하는걸 알 수 있다. 반대로 <code>val</code> 은 <strong>Call-by-value</strong> 를 사용한다. <code>val x = loop</code> 식을 평가하면, 무한 루프가 도는것을 확인할 수 있다. </p>

<h4 id="exercise">Exercise</h4>

<p><code>&amp;&amp;</code> 와 <code>||</code> 없이 <code>and</code> 함수를 구현하려다 보면, 다음과 같이 구현하는 경우가 있는데, </p>

<pre><code class="scala">def and(x: Boolean, y: Boolean = if (x) y else false  
</code></pre>

<p>이 경우 <code>and(false, loop)</code> 를 평가하면 올바르게 동작하지 않고 무한루프에 걸린다 따라서 두번 째 인자가 <strong>Call-by-name</strong> 을 이용해 평가되도록, 아래와 같이 작성해야 한다.</p>

<pre><code class="scala">def and(x: Boolean, y: =&gt; Booelan) = if (x) y else false  
def or(x: Boolean, y: =&gt; Boolean) = if (x) true else y  
</code></pre>

<h3 id="15examplesquarerootswithnewtonsmethod">1.5 Example: square roots with Newton's method</h3>

<p>일단 시작 전에 먼저 말하자면, Scala 에서 recursive function 의 경우에는 explicit return type 이 필요하다.</p>

<p><a href='http://kevin0960.tistory.com/entry/%EA%B3%A0%EC%B0%A8-%EB%B0%A9%EC%A0%95%EC%8B%9D%EC%9D%98-%ED%95%B4-%EA%B5%AC%ED%95%98%EA%B8%B0-%EB%89%B4%ED%8A%BC-%EB%9E%A9%EC%8A%A8%EB%B2%95-Newton-Rahpson' >뉴튼-랩슨 법</a>을 이용해서 제곱근을 구하는 Scala 코드를 작성하면</p>

<pre><code class="scala">  def abs(x: Double) = if (x &lt; 0) -x else x
  def sqrt(x: Int): Double = sqrtIter(1.0, x)
  def sqrtIter(guess: Double, x: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)

  def isGoodEnough(guess: Double, x: Double): Boolean =
    abs(guess * guess - x) / x &lt; 0.0001

  def improve(guess: Double, x: Double) =
    (guess + x / guess) / 2
</code></pre>

<p>실수에 대해 작업할때는 엄청나게 커다란 수와 작은 수에 대해 테스트를 해 보아야 한다. 만약 <code>isGoodEnough</code> 의 구현이 <code>abs(guess * guess -x ) &lt; 0.0001</code> 이라면 큰수에 대해서는 non-termination 이, 작은 수에 대해서는 invalid 한 값이 나올수 있다.</p>

<p>참고로, <strong>scalatest</strong> 에서는 <strong>floating point number</strong> 에 대한 테스틀 위해 다음과 같은 인터페이스를 지원한다.</p>

<pre><code class="scala">sevenDotOh should equal (6.9 +- 0.2)  
sevenDotOh should === (6.9 +- 0.2)  
sevenDotOh should be (6.9 +- 0.2)  
sevenDotOh shouldEqual 6.9 +- 0.2  
sevenDotOh shouldBe 6.9 +- 0.2  
</code></pre>

<h3 id="16blocksandlexicalscope">1.6 Blocks and Lexical Scope</h3>

<p>위에서 작성한 <code>sqrt</code> 를 block scope 를 이용하면 <code>x</code> 를 파라미터로 넘기는것을 제거해 간단히 만들 수 있다. </p>

<pre><code class="scala">  def abs(x: Double) = if (x &lt; 0) -x else x
  def sqrt(x: Int): Double = {

    def sqrtIter(guess: Double): Double =
      if (isGoodEnough(guess, x)) guess
      else sqrtIter(improve(guess))

    def isGoodEnough(guess: Double, x: Double): Boolean =
      abs(guess * guess - x) &lt; 0.0001

    def improve(guess: Double) =
      (guess +  x / guess) / 2

    sqrtIter(1.0)
  }
</code></pre>

<h4 id="semicolons">Semicolons</h4>

<p>Scala 에서 세미콜론은 옵션이지만 이와 관련된 이슈가 있다.</p>

<pre><code class="scala">someLongExp  
+ someOtherExp
</code></pre>

<p>이건 다음과 같이 interpreted 될 것이다.</p>

<pre><code class="scala">someLongExp;  
+ someOtherExp
</code></pre>

<p>Expression 이 분리 되는 것을 방지하기 위해 다음과 두 가지 방법을 이용할 수 있다.</p>

<pre><code class="scala">someLongExp +  
someOtherExp

// or

(someLongExp
+ someOtherExp)
</code></pre>

<h3 id="17tailrecursion">1.7 Tail Recursion</h3>

<pre><code class="scala">  def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)

  def factorial(n: Int): Int =
    if (n == 0) 1 else n * factorial(n - 1);
</code></pre>

<p>다음과 같은 재귀 함수가 있을때, 자세히 보면 <code>factorial(4)</code> 의 경우 Expression 이 점점 길어진다. <code>(4 * 3 * 2 * (1 * 1)</code></p>

<p>반대로 <code>gcd(3, 2)</code> 의 경우 계산과정을 살펴보면 <code>gcd(3, 2)</code>, <code>gcd(2, 1)</code> 로 진행된다. 식이 점점 길어지는게 아니라, 함수에서 변수만 바뀌는걸 알 수 있다. 이 경우 저장해야할 지역변수가 없기 때문에 stack frame 을 재활용 할 수 있으며, 이런 Recursive call 을 <strong>Tail Recursion</strong> 이라 부른다. 영문 설명을 보면,</p>

<p>If a function calls itself as its last action, the function's stack frame can e reused. This is called <strong>Tail Recursion</strong></p>

<blockquote>
  <p>Tail recursive functions are iterative processes</p>
</blockquote>

<p>In general, if the last action of a function consists of calling a function (which may be the same), one stack frame would be sufficient for both functions. Such calls are called <strong>tail-calls</strong></p>

<p><strong>tail-recursion</strong> 버전의 <code>factorial</code> 은 다음과 같다.</p>

<pre><code class="scala">  def tailFactorial(n: Int) = {
    def loop(acc: Int, n: Int): Int =
      if (n == 0) acc else loop(acc * n, n-1)
    loop(1, n);
  }
</code></pre>]]></description><link>http://1ambda.github.io/functional-programming-in-scala-chapter-1/</link><guid isPermaLink="false">13422f6a-c277-4a2f-8db9-682eeaca0144</guid><category><![CDATA[scala]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 16 Sep 2014 12:00:01 GMT</pubDate></item></channel></rss>