<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Old Lisper]]></title><description><![CDATA[Lisp, Emacs, FP]]></description><link>http://1ambda.github.io/</link><generator>Ghost 0.5</generator><lastBuildDate>Wed, 17 Sep 2014 17:20:26 GMT</lastBuildDate><atom:link href="http://1ambda.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Practical Common Lisp, Chapter 7]]></title><description><![CDATA[<h3 id="macrosstandardcontrolconstrucs">MACROS : STANDARD CONTROL CONSTRUCS</h3>

<blockquote>
  <p>All programmers should be used to the idea that the definition of a language can include a standard library of functionality that is implemented in terms of the "core" language functionality that could have benn implemented by any programmer on top of the language if it hand't been defined as part of the standard library.</p>
</blockquote>

<p>다른 언어에서 특정 기능이 부족할때 새로운 클래스나 메소드를 정의함으로서 standard library 를 확장할 수 있지만, Lisp 은 이 방법 외에도 <strong>Macro</strong> 라는 조금 다른 방식을 제공한다.</p>

<p>각 매크로는<code>s-exp</code> 가 어떻게 lisp forms 으로 확장될지를 결정하는 자신만의 <strong>Syntax</strong> 를 정의할 수 있다. 이런 <strong>Macro</strong> 의 기능으로 인해서 <strong>Language</strong> 자체의 <strong>Syntax</strong> 가 확장될 수 있다. 대표적인 예가 <code>WHEN</code>, <code>DOLIST</code>, <code>LOOP</code> 와 같은 control constructs 와 <code>DEFUN</code>, <code>DEFPARAMETER</code> 과 같은 definitinal forms 들이다.</p>

<h4 id="whenandunless">WHEN and UNLESS</h4>

<p><code>(if condition then-form [else-form])</code> 은 <code>then-form</code> 과 <code>else-form</code> 이 single lisp form 이어야 한다는 제한을 가지고 있다. </p>

<p>그렇기 때문에 스팸 메일을 받았을때, 폴더에 저장하고, 데이터베이스에 업데이트 하려고 할 때 <code>if</code> 구문을 다음과 같이 작성하면, 제대로 작동하지 않는다. </p>

<pre><code class="lisp">(if (spam-p current-message)
    (file-in-spam-folder current-message)
    (update-spam-database current-message))
</code></pre>

<p>이 코드의 경우 <code>update-spam-database</code> 함수는 <code>if-then</code> 이 아니라 <code>else-then</code> 에 붙어있는 form 으로 인식되어 의도했던 바 대로 실행되지 않는다.</p>

<p><code>progn</code> 을 이용하면, 여러 form 을 묶을 수 있기 때문에 다음과 같이 작성하면 제대로 동작한다.</p>

<pre><code class="lisp">(if (spam-p current-message)
    (progn
      (file-in-spam-folder current-message)
      (update-spam-database current-message)))
</code></pre>

<p>그러나 매번 <code>progn</code> 을 써야한다는 사실이 귀찮고, <code>if</code> 와 <code>progn</code> 의 조합으로 해당 역할을 해낼 수 있다는걸 깨달았으므로, 다음과 같은 인터페이스를 가지는 <code>when</code> 매크로를 작성해보자.</p>

<pre><code class="lisp">(when (spam-p current-message)
  (file-in-spam-folder current-message)
  (update-spam-database current-message))

(defmacro when (condition &amp;rest body)
  `(if ,condition (progn ,@body)))

(defmacro unless (condition &amp;rest body)
  `(if (not ,condition) (progn ,@body)))
</code></pre>

<h4 id="cond">COND</h4>

<p><code>if</code> 같은 경우도, 중첩되면 보기가 싫어질 수 있다.</p>

<pre><code class="lisp">(if a
    (do-x)
    (if b
        (do-y)
        (do-z)))
</code></pre>

<p>이를 위해서 <code>cond</code> 매크로를 만들어 보자.</p>

<pre><code class="lisp">(defmacro cond (&amp;rest body)
  (when body
    (let ((clause (first body)))
      `(if ,(first clause) (progn ,@(rest clause))
           (cond1 ,@(rest body))))))
</code></pre>

<h4 id="andorandnot">AND, OR, and NOT</h4>

<p><code>AND</code> 와 <code>OR</code> 같은 경우 <strong>short-circuit</strong> 을 구현하기 위해서는, 두번 째 인자를 평가하지 않아야 하는데, 일반 함수로는 인자의 평가 시기를 조절하기 불가능하고, 매크로를 이용하면 그럴 수 있다.</p>

<pre><code class="lisp">(defmacro (a b)
</code></pre>

<h4 id="looping">Looping</h4>

<p>Lisp 의 25가지 special operators 는 직접적으로 Looping 을 지원하지 <strong>않기</strong> 때문에 Lisp 의 모든 looping control constructs 는 이 specical operator 를 이용해 만든 Macro 다.</p>

<p><code>DO</code> 는 강력하지만, less expressie 하기 때문에 <code>DO</code> 위에 만들어진 <code>DOTIMES</code> 와 <code>DOLIST</code> 를 제공한다. <code>LOOP</code> 는 non-lispy, english-like 스타일의 문법을 제공한다.</p>

<h4 id="dolistanddotimes">DOLIST and DOTIMES</h4>

<p>아래는 <code>DOLIST</code> 와 <code>DOTIMES</code> 의 문법과 사용법이다.</p>

<pre><code class="lisp">;; syntax
(dolist (var list-form)
  body-form*)

(dotimes (var count-form)
  body-form*)

;; example
(dolist (x '(1 2 3)) (princ x) (princ x)) ;; 112233
(dotimes (x 4) (princ x) (princ x)) ;; 00112233
(dotimes (x 4) (print x) (if (= (/ x 2) 0) (return))) ;; 0 1 2
(dotimes (x 20)
       (dotimes (y 20)
         (format t "x: ~d, y: ~d~%" x y)))
</code></pre>

<h4 id="do">DO</h4>

<p><code>DO</code> 의 Syntax 와 사용법은 아래와 같다.</p>

<pre><code class="lisp">;; Syntax
(do (variable-definitions*)
    (end-test-form result-form*)
  statement*)

;; Usage : fibonacci
(do ((n 0 (+1 n))
     (cur 0 next
     (next 1 (+ cur next)))
    ((=10 n) cur))

;; Usage: omiited result-form
;; same as (dotimes (i 4) (print i))
(do ((i 0 (1+ i)))
    ((&gt;= i 4))
   (print i))
</code></pre>]]></description><link>http://1ambda.github.io/top-level-form-common-lisp/</link><guid isPermaLink="false">24b1d760-68b1-4861-b657-28f45fccdcc8</guid><category><![CDATA[Lisp]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 17 Sep 2014 17:18:47 GMT</pubDate></item><item><title><![CDATA[Functional Programming in Scala, Chapter 1]]></title><description><![CDATA[<p>2014-09-16, <strong>Functional Programming in Scala</strong>, Coursera</p>

<h3 id="11programmingparadigms">1.1 Programming Paradigms</h3>

<h4 id="imperativeprogramming">Imperative Programming</h4>

<ul>
<li>modifying mutable variables  </li>
<li>using assignment  </li>
<li>and control str such as if-then-else, loop breakl continue, return  </li>
</ul>

<p>절차적인 프로그래밍은 폰 노이만 구조랑 비슷한데, </p>

<ul>
<li>Mutable var = memory cells  </li>
<li>variable deferences = load instructions  </li>
<li>var assginment = store instsruction  </li>
<li>control structure = jumps  </li>
</ul>

<p>그런데 이런 instruction 들이 <code>word</code> 로 구성되어있으므로, 문제는  </p>

<blockquote>
  <p>"Scaling up, How can we avoid conceptualizign programs word by word?"</p>
</blockquote>

<p>결국 pure Imperative Programming 은 폰노이만 구조처럼 제한을 받는다고 볼 수 있다.</p>

<blockquote>
  <p>"One tends to conceptualize data structures word-by-words"</p>
</blockquote>

<p>그렇기 때문에 컬렉션, 다항식, 문자열과 같은 high-level abstraction 을 정의할 방법이 필요한데, 이상적으로는 <strong>Theory</strong> 를 만들면 해결할 수 있다. Theory 는 다음을 포함하는데</p>

<ul>
<li>one or more data types  </li>
<li>operations on these types  </li>
<li>laws that describe the relationships between values and opertions</li>
</ul>

<p>그러나, 일반적으로 <strong>Theory</strong> 는 mutation 에 대해서는 describe 하지 않지만 Imperative Programming 에서는 mutation 때문에 theories 가 부서질(break) 수 있음. 따라서 다음과 같은 것들이 필요하다. </p>

<ul>
<li>Concentrate on defining theories for operators expressed as function  </li>
<li>avoid mutations  </li>
<li>have powerful way to abstract and compose functions  </li>
</ul>

<p>정리하자면, Imperative Programming 에서는 high-level abstraction 을 위해 theory 를 이용할 수 있는데, Imperative Programming 에서는 mutation variable 을 이용하므로 theory 의 law 를 break 할 수 있다. 따라서 이런 단점을 해결하기 위해 나온 것이 Functional Programming 이다.</p>

<p>Functional Programming 에서는 상태가 Immutable 이기 때문에 <strong>Theory</strong> 를 구성하는 operator 를 만드는 것에 집중할 수 있다.</p>

<h4 id="functionalprogramming">Functional Programming</h4>

<ul>
<li>without mutable variables, assignments, loops  </li>
<li>focuses on functions</li>
</ul>

<p>FP offers the folloing benefits</p>

<ul>
<li>simpler reasoning principles  </li>
<li>better modularity  </li>
<li>good for exploiting parallelism fo mlticore and clod compting  </li>
</ul>

<h3 id="12elementsofprogramming">1.2 Elements of Programming</h3>

<h4 id="expression">Expression</h4>

<p>대다수의 언어들은 <strong>expression</strong> 과 관련해서 다음의 기능들을 제공한다</p>

<ul>
<li>primitive expressions, representing the simplest elements  </li>
<li>ways to combine expressions  </li>
<li>ways to abstract expressions, which introduce a name for an expression by which it can then be referred to.</li>
</ul>

<h4 id="evaluation">Evaluation</h4>

<p><strong>Non-primitive</strong> expression 은 최종적으로 value 를 만들기 전까지 다음과 같은 방식으로 evaluated 된다</p>

<ol>
<li>Take the leftmost operator  </li>
<li>Evaluate its operands (left before right)  </li>
<li>Apply the operator to the operands</li>
</ol>

<p><strong>A name</strong> is evaluatd by replacing it with the right hand side of its definition.</p>

<p>그러나 모든 expression 이 finite value 를 가지는 것은 아니다. </p>

<pre><code class="scala">def loop: Int = loop  
</code></pre>

<h4 id="evaluationoffunctionapplications">Evaluation of Function Applications</h4>

<p>Applications of parameterized functions 은 다음과 같은 방식으로 evaluated 된다. operator 와 얼추 비슷하다</p>

<p>(1) Evaluate all function arguments, from left to right <br />
(2.1) Replace the function application by the function's right-hand side, and, at the same time <br />
(2.2) Replace the formal parameters of the function by the actual arguments</p>

<pre><code class="scala">def square(x: Int) = x * *  
def sumOfSquares(x: Int, : Int) = square(x) + square(x)

sumOfSquares(3, 2+2)

// sumOfSquares(3, 4) : step (1) 
// square(3) + square(4) : step (2) 
// 3 * 3 + square(4) : step (1), (2)
// 9 + square(4)
// 9 + 4 * 4
// 9 + 16
// 25
</code></pre>

<p>인자를 먼저 평가하지 않을 경우 <code>square(2+2)</code> 가 <code>(2*2) + (2*2)</code> 로 reduced 되어 더 많은 계산을 야기할 수 있다.</p>

<h4 id="thesubstitutionmodel">The substitution model</h4>

<p>이렇게 Evaluation 해 나가는 과정을 <strong>The substitution model</strong> 이라 부른다. 이 모델의 근간이 되는 아이디어는 <strong>reducing an expression to a value</strong> 이고, <strong>side-effect</strong> 가 없는 한 모든 expressions 에 적용할 수 있다. 참고로 이 모델은 Functional Programming 의 근간이 되는 <strong>lambda-calculus</strong> 사용한 것이다.</p>

<h4 id="callbyvaluecallbyname">Call-by-value, Call-by-name</h4>

<p><code>square(4)</code> 처럼 <code>sumOfSquares</code> 의 인자가 먼저 평가되는 방식을 <strong>Call-by-value</strong>, <code>square(2+2)</code> 처럼 나중에 인자가 평가되는 방식을 <strong>Call-by-name</strong> 이라 부른다. </p>

<p>두 가지 방식 아래 조건이 지켜지는 한 모두 expression 을 value 로 reduce 한다</p>

<ul>
<li>the reuced expression consists of pure functions, and  </li>
<li><p>both evaluations terminate</p></li>
<li><p><strong>Call-by-value</strong> has the advantage that it evaluates every function argument only once  </p></li>
<li><strong>Call-by-name</strong> has the advantage that a function argument is not evaluated if the corresponding parameter is unused in the evaluation of the function body  </li>
</ul>

<h4 id="examples">Examples</h4>

<pre><code class="scala">def test(x: Int, y: Int) = x *x  
</code></pre>

<p>위와 같은 함수가 있다고 할때, <code>test(3, 4)</code> 는 똑같은 속도지만 <code>test(2+2, 3)</code> 은  <strong>Call-by-value</strong> 가, <code>test(2, 3+2)</code> 는 <strong>Call-by-name</strong> 이 더 빠르다</p>

<h3 id="13evaluationstrategiesandtermination">1.3 Evaluation Strategies and Termination</h3>

<p>But what if termination is not guaranteed?</p>

<pre><code class="scala">def test (x: Int, y: Int) = x * x  
def loop () = loop  
</code></pre>

<p>위의 예제에서 <code>test(3, loop)</code> 라는 expressions 은 <strong>Call-by-name</strong> 방식으로 평가될 수 있지만, <strong>Call-by-value</strong> 방식으로는 아니다. </p>

<p>Scala 은 일반적으로 re-computation 을 피하기 위해 <strong>Call-by-value</strong> 을 사용한다. 그러나 <code>def constOne(x: Int, y: =&gt; Int) = 1</code> 처럼 function parameter 가 <code>=&gt;</code> 로 시작하면 해당 인자는 <strong>Call-by-name</strong> 을 이용한다.</p>

<pre><code class="scala">def constOne(x: Int, y: =&gt; Int) = 1  
def loop() = loop

constOne(1+2, loop) // will be evaluated  
constOne(loop, 1+2) // will not be evaluated  
</code></pre>

<h3 id="14conditionalsandvaluedefinitions">1.4 Conditionals and Value Definitions</h3>

<h4 id="conditionalexpression">Conditional Expression</h4>

<pre><code class="scala">def abs(x: Int) = if (x &gt;= 0) x else -x  
</code></pre>

<p>In the above example, <code>x &gt;= 0</code> is a predicate, of type Boolean. and <code>If-else</code> is an expression not a statement</p>

<h4 id="shortcircuitevaluation">short-circuit evaluation</h4>

<p>Boolean 을 위한 Rule 을 다시 만들수 있다.</p>

<pre><code>!true      --&gt; false
!false     --&gt; true
true &amp;&amp; e  --&gt; e  
false &amp;&amp; e --&gt; false  
true || e  --&gt; true  
false || e --&gt; e  
</code></pre>

<p><code>&amp;&amp;</code> 와 <code>||</code> 의 경우에는 언제나 오른쪽 operand 가 평가되야 하는건 아닌데, 이러한 expression 을 보고 <strong>short-circuit evaluation</strong> 을 사용한다고 말한다.</p>

<h4 id="valuedefinitions">Value Definitions</h4>

<pre><code class="scala">def x loop(): Booelan = loop  
</code></pre>

<p>위의 식이 평가되는걸 보면 <code>def</code> 는 <strong>Call-by-value</strong> 를 이용하는걸 알 수 있다. 반대로 <code>val</code> 은 <strong>Call-by-value</strong> 를 사용한다. <code>val x = loop</code> 식을 평가하면, 무한 루프가 도는것을 확인할 수 있다. </p>

<h4 id="exercise">Exercise</h4>

<p><code>&amp;&amp;</code> 와 <code>||</code> 없이 <code>and</code> 함수를 구현하려다 보면, 다음과 같이 구현하는 경우가 있는데, </p>

<pre><code class="scala">def and(x: Boolean, y: Boolean = if (x) y else false  
</code></pre>

<p>이 경우 <code>and(false, loop)</code> 를 평가하면 올바르게 동작하지 않고 무한루프에 걸린다 따라서 두번 째 인자가 <strong>Call-by-name</strong> 을 이용해 평가되도록, 아래와 같이 작성해야 한다.</p>

<pre><code class="scala">def and(x: Boolean, y: =&gt; Booelan) = if (x) y else false  
def or(x: Boolean, y: =&gt; Boolean) = if (x) true else y  
</code></pre>

<h3 id="15examplesquarerootswithnewtonsmethod">1.5 Example: square roots with Newton's method</h3>

<p>일단 시작 전에 먼저 말하자면, Scala 에서 recursive function 의 경우에는 explicit return type 이 필요하다.</p>

<p><a href='http://kevin0960.tistory.com/entry/%EA%B3%A0%EC%B0%A8-%EB%B0%A9%EC%A0%95%EC%8B%9D%EC%9D%98-%ED%95%B4-%EA%B5%AC%ED%95%98%EA%B8%B0-%EB%89%B4%ED%8A%BC-%EB%9E%A9%EC%8A%A8%EB%B2%95-Newton-Rahpson' >뉴튼-랩슨 법</a>을 이용해서 제곱근을 구하는 Scala 코드를 작성하면</p>

<pre><code class="scala">  def abs(x: Double) = if (x &lt; 0) -x else x
  def sqrt(x: Int): Double = sqrtIter(1.0, x)
  def sqrtIter(guess: Double, x: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)

  def isGoodEnough(guess: Double, x: Double): Boolean =
    abs(guess * guess - x) / x &lt; 0.0001

  def improve(guess: Double, x: Double) =
    (guess + x / guess) / 2
</code></pre>

<p>실수에 대해 작업할때는 엄청나게 커다란 수와 작은 수에 대해 테스트를 해 보아야 한다. 만약 <code>isGoodEnough</code> 의 구현이 <code>abs(guess * guess -x ) &lt; 0.0001</code> 이라면 큰수에 대해서는 non-termination 이, 작은 수에 대해서는 invalid 한 값이 나올수 있다.</p>

<p>참고로, <strong>scalatest</strong> 에서는 <strong>floating point number</strong> 에 대한 테스틀 위해 다음과 같은 인터페이스를 지원한다.</p>

<pre><code class="scala">sevenDotOh should equal (6.9 +- 0.2)  
sevenDotOh should === (6.9 +- 0.2)  
sevenDotOh should be (6.9 +- 0.2)  
sevenDotOh shouldEqual 6.9 +- 0.2  
sevenDotOh shouldBe 6.9 +- 0.2  
</code></pre>

<h3 id="16blocksandlexicalscope">1.6 Blocks and Lexical Scope</h3>

<p>위에서 작성한 <code>sqrt</code> 를 block scope 를 이용하면 <code>x</code> 를 파라미터로 넘기는것을 제거해 간단히 만들 수 있다. </p>

<pre><code class="scala">  def abs(x: Double) = if (x &lt; 0) -x else x
  def sqrt(x: Int): Double = {

    def sqrtIter(guess: Double): Double =
      if (isGoodEnough(guess, x)) guess
      else sqrtIter(improve(guess))

    def isGoodEnough(guess: Double, x: Double): Boolean =
      abs(guess * guess - x) &lt; 0.0001

    def improve(guess: Double) =
      (guess +  x / guess) / 2

    sqrtIter(1.0)
  }
</code></pre>

<h4 id="semicolons">Semicolons</h4>

<p>Scala 에서 세미콜론은 옵션이지만 이와 관련된 이슈가 있다.</p>

<pre><code class="scala">someLongExp  
+ someOtherExp
</code></pre>

<p>이건 다음과 같이 interpreted 될 것이다.</p>

<pre><code class="scala">someLongExp;  
+ someOtherExp
</code></pre>

<p>Expression 이 분리 되는 것을 방지하기 위해 다음과 두 가지 방법을 이용할 수 있다.</p>

<pre><code class="scala">someLongExp +  
someOtherExp

// or

(someLongExp
+ someOtherExp)
</code></pre>

<h3 id="17tailrecursion">1.7 Tail Recursion</h3>

<pre><code class="scala">  def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)

  def factorial(n: Int): Int =
    if (n == 0) 1 else n * factorial(n - 1);
</code></pre>

<p>다음과 같은 재귀 함수가 있을때, 자세히 보면 <code>factorial(4)</code> 의 경우 Expression 이 점점 길어진다. <code>(4 * 3 * 2 * (1 * 1)</code></p>

<p>반대로 <code>gcd(3, 2)</code> 의 경우 계산과정을 살펴보면 <code>gcd(3, 2)</code>, <code>gcd(2, 1)</code> 로 진행된다. 식이 점점 길어지는게 아니라, 함수에서 변수만 바뀌는걸 알 수 있다. 이 경우 저장해야할 지역변수가 없기 때문에 stack frame 을 재활용 할 수 있으며, 이런 Recursive call 을 <strong>Tail Recursion</strong> 이라 부른다. 영문 설명을 보면,</p>

<p>If a function calls itself as its last action, the function's stack frame can e reused. This is called <strong>Tail Recursion</strong></p>

<blockquote>
  <p>Tail recursive functions are iterative processes</p>
</blockquote>

<p>In general, if the last action of a function consists of calling a function (which may be the same), one stack frame would be sufficient for both functions. Such calls are called <strong>tail-calls</strong></p>

<p><strong>tail-recursion</strong> 버전의 <code>factorial</code> 은 다음과 같다.</p>

<pre><code class="scala">  def tailFactorial(n: Int) = {
    def loop(acc: Int, n: Int): Int =
      if (n == 0) acc else loop(acc * n, n-1)
    loop(1, n);
  }
</code></pre>]]></description><link>http://1ambda.github.io/scala-chapter-1/</link><guid isPermaLink="false">13422f6a-c277-4a2f-8db9-682eeaca0144</guid><category><![CDATA[scala]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 16 Sep 2014 12:00:01 GMT</pubDate></item><item><title><![CDATA[MySQL Derived Table, Correlated Query]]></title><description><![CDATA[<h3 id="correlatedvsnoncorrelated">Correlated vs Non-Correlated</h3>

<p>아래는 <strong>Non-Correlated</strong> 쿼리다. 즉 내부(Inner) 쿼리가 외부(Outer) 쿼리를 참조하지 않는다.</p>

<pre><code class="mysql">SELECT name  
FROM city  
WHERE population &gt; (SELECT population  
                    FROM city
                    WHERE name = 'new york');
</code></pre>

<p>반면 아래는 <strong>Correlated</strong> 쿼리다. 내부 쿼리가 <code>co.code</code> 로 외부 쿼리를 참조한다.</p>

<pre><code class="mysql">SELECT name  
FROM country as co  
WHERE EXISTS (SELECT *  
              FROM city
              WHERE population &gt; 900 AND co.code = country_code);
</code></pre>

<p><strong>Correlated Query</strong> 는 이렇게 외부 쿼리에 대한 참조를 가지고 있기 때문에 외부 쿼리의 각 <strong>Row</strong> 마다 서브쿼리가 실행되고, 결국 성능은 떨어진다. 다시 말해 일반적인 서브 쿼리<strong>(Non-Correlated)</strong> 라면 <code>N + M</code> 번 만큼 연산을 수행하지만, <strong>Correlated</strong> 서브쿼리라면 <code>N x M</code> 만큼의 연산을 수행한다.</p>

<p>이런 <strong>Correlated Query</strong> 는 <strong>Join</strong> 구문을 이용한 쿼리로 변경할 수 있다.</p>

<pre><code class="mysql">SELECT DISTINCT country.name  
FROM country  
JOIN city ON country.code = city.country_code  
WHERE city.population &gt; 900;  
</code></pre>

<h3 id="derivedtable">Derived Table</h3>

<p>이런 성능 저하 때문에 일반적으로는 Correlated Subquery 대신에 <strong>Derived Table</strong> 을 사용한다. <code>FROM</code> 혹은 <code>JOIN</code> 구문에서 사용하는 서브쿼리를 <strong>Derived Table</strong> 이라 부른다. 본질적으로 <strong>Derived Table</strong> 은 실제 존재하는 테이블이 아니라, 쿼리 내에서만 존재하는 <strong>Inline View</strong> 다.</p>

<pre><code class="mysql">SELECT LastName, FirstName  
FROM  
    (SELECT * FROM Employee
     WHERE State = "NY") AS EmployeeDerivedTable
WHERE LastName = "Smith"  
ORDER BY FirstName  
</code></pre>

<h3 id="references">References</h3>

<ol>
<li><p><a href='http://sarahdba.blogspot.kr/2009/08/examples-of-bad-queries.html' >Example of bad queries</a></p></li>
<li><p><a href='http://www.programmerinterview.com/index.php/database-sql/derived-table-vs-subquery/' >Derived Table vs Subquery</a></p></li>
<li><p><a href='http://stackoverflow.com/questions/17268848/difference-between-subquery-and-correlated-subquery' >Difference between subquery and correlated subquery</a></p></li>
</ol>]]></description><link>http://1ambda.github.io/mysql-derived-table/</link><guid isPermaLink="false">94d49870-33be-4d17-abd5-1d04f6ff0f22</guid><category><![CDATA[mysql]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Tue, 19 Aug 2014 12:59:57 GMT</pubDate></item><item><title><![CDATA[Javascript Inheritance]]></title><description><![CDATA[<h2 id="prototypeinheritance">Prototype Inheritance?</h2>

<p>자바스크립트는 프로토타입 방식의 상속을 사용한다고들 말합니다. 프로토타입이란 무엇이고, 클래스 기반 상속과는 어떻게 다른지, 그리고 주의해야 할 점은 무엇인지 알아보겠습니다. 이 글에서 다루는 키워드는 아래와 같습니다.</p>

<ul>
<li>.constructor</li>
<li>.__proto__</li>
<li>.prototype</li>
<li>Object.create</li>
<li>new</li>
<li>Object, Function</li>
</ul>

<p>먼저 예제부터 보시겠습니다.</p>

<pre><code class="javascript">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create

// Shape - superclass (1)
function Shape() {  
  this.x = 0;
  this.y = 0;
}

// superclass method (2)
Shape.prototype.move = function(x, y) {  
    this.x += x;
    this.y += y;
    console.info("Shape moved.");
};

// Rectangle - subclass (3)
function Rectangle() {  
  Shape.call(this); // call super constructor.
}

// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype); (4)  
Rectangle.prototype.constructor = Rectangle; (5)

var rect = new Rectangle();

rect instanceof Rectangle // true.  
rect instanceof Shape // true.

rect.move(1, 1); // Outputs, "Shape moved."  
</code></pre>

<p>(1). 먼저 <code>Shape</code> 이라는 함수를 만듭니다. 자바스크립트에서는 객체를 생성하기 위한 함수를 <code>Constructor(생성자)</code> 라고 부르며, 생성자임을 알아볼 수 있게 첫 글자를 <strong>대문자</strong>로 작성하는 것이 관례입니다. 이렇게 만들어진 생성자는 <code>new</code> 를 통해 호출할 수 있습니다. 물론 생성자는 그 자체로서 함수이기 때문에 <code>Shape()</code> 과 같이 호출도 가능합니다. 그러나 <code>new</code> 가 있는것과 없는것은 조금 차이가 있습니다. 아래에서 알아보겠습니다.</p>

<p>(2). 생성자에 존재하는 <code>prototype</code> 속성, 즉 <code>Shape.prototype</code> 에 <code>move</code> 란 메소드를 추가하고 있습니다. 생성자의 <code>prototype</code> 속성에 추가된 모든 것들은 이 생성자를 통해 생성된 모든 객체에서 사용 가능합니다. 그러나, 생성자의 <code>prototype</code> 이 아니라, 인스턴스에 추가된 속성들은 그 인스턴스만 사용할 수 있습니다.</p>

<pre><code class="javascript"> var s1 = new Shape();
s1.move(3, 3);

s1.isShape = true;

var s2 = new Shape();  
console.log (s2.isShape) // undefined  
console.log (typeof s2.isShape === "undefined") // true  
</code></pre>

<p>(3). <code>Rectangle</code> 이라는 새로운 생성자를 정의하고 있습니다. 그리고 이 생성자 내에서 <code>Shape.call(this)</code> 를 호출하여, <code>new Rectangle()</code> 을 통해 만들어지는 모든 인스턴스가 <code>Shape</code> 처럼 <code>this.x</code> 와 <code>this.y</code> 를 가지고, 0으로 초기화 하도록 합니다. 이 과정이 끝나면 다음과 같은 결과가 나옵니다.</p>

<pre><code class="javascript">function Rectangle() {  
    Shape.call(this);
}

var r1 = new Rectangle();  
console.log (r1.x); // 0  
console.log (r2.y); // 0  
</code></pre>

<p>그러나 이 시점에서 <code>r1</code> 은 <code>move</code> 란 메소드를 사용할 수 없습니다. <code>Shape.move</code> 는 있지만 이 <code>move</code> 메소드를 상속받은것은 아닙니다. <code>Rectangle</code> 은 단지 <code>this.x</code>, <code>this.y</code> 란 멤버변수를 상속받은 것 뿐입니다.</p>

<pre><code class="javascript">console.log (r1.move); // undefined  
</code></pre>

<p>(4). 드디어 <code>Rectangle.prototye</code> 에 <code>Shape.prototype</code> 을 연결해 주어 <code>r1</code> 에서도 <code>Shape.prototype</code> 에 정의된 메소드들을 사용할 수 있게끔 해줍니다. </p>

<pre><code class="javascript">r1.move(2, 2);  
console.log(r1.x); // 2  
console.log(r1.y); // 2  
</code></pre>

<p>여기서 Rectangle.prototype = Shape.prototype 을 하지않고 새롭게 Object.create 해주는 이유는, <code>Rectangle.prototype</code> 에 새로운 속성을 추가했을때, <code>Shape.prototype</code> 에 추가되도록 하지 않기 위함입니다. 다시 말해, <code>Rectangle</code> 에 추가한 것은, <code>Rectangle</code> 에만 추가되라는 것이지요.  </p>

<p><code>Rectangle.prototype = new Shape();</code> 처럼 <code>new</code> 를 사용하게 되면, 생성자를 호출하게 되어 <code>Rectangle.prototype</code> 에 인스턴스 변수인 <code>this.x</code> 와 <code>this.y</code> 가 추가됩니다.   이것은 우리가 원하지 않은 동작이기에, 일반적으로 <code>new</code> 를 이용해서 프로토타입을 생성하지 않습니다.</p>

<p>(5). <code>Object.create(Shape.prototype)</code> 으로 생성한 객체는 <code>constructor</code> 값으로 <code>Shape</code> 를 가지고 있습니다. 이 객체를 이제, <code>Rectangle.prototype</code> 에서 사용하므로 값을 변경해 줍니다. </p>

<h3 id="__proto__"><strong>proto</strong></h3>

<p><code>__proto__</code> 속성은 자바스크립트에서 상속의 핵심입니다. 모든 객체들은 자신의 속성을 찾다가 실패하면, <code>__proto__</code> 를 통해 더 검색을 시도합니다. 무슨말인고 하니, 다음과 같은 코드가 있을때</p>

<pre><code class="javascript">var r1 = new Rectangle();

r1.move(1, 1);  
</code></pre>

<p>실제로 <code>Rectangle</code> 은 <code>move</code> 라는 메소드를 인스턴스 멤버로도, 프로토타입 멤버로도 가지고 있지 않습니다. 다시 말해서, 아래와 같은 코드를 작성한 적이 없단 말이지요.</p>

<pre><code class="javascript">// Method per instance
function Rectangle() {  
    this.move = function(_x, _y) { this.x = _x; this.y = _y; };
}

// Method for specific instance
r1.move = function(_x, _y) { this.x = _x; this.y = _y; };

// Prototype method
Rectangle.prototype.move = function(_x, _y) { this.x = _x; this.y = _y; };  
</code></pre>

<p>이런 작업을 해 준 적이 없는데, 어떻게 <code>move</code> 메소드를 찾는걸까요? 우리는 <code>move</code> 를 <code>Shape.prototype</code> 에만 추가했는데요! 비결은 아래와 같습니다.</p>

<ol>
<li><p><code>r1</code> 인스턴스 자체에 <code>move</code> 메소드가 인스턴스에 없기 때문에 <code>r1.__proto__</code> 에서 탐색하게 됩니다.</p></li>
<li><p>인스턴스가 가지고 있는 <code>__proto__</code> 의 값은, 생성자의 프로토타입, 즉 <code>Rectangle.prototype</code> 입니다. 따라서 이곳을 검색합니다. 그러나 <code>Rectangle</code> 프로토타입에도 <code>move</code> 메소드는 없습니다.</p></li>
<li><p><code>Rectangle.prototype.__proto__</code> 를 검색합니다. <code>Rectangle.prototype</code> 은 <code>Object.create(Shape.prototype)</code> 을 통해 생성되었고, 이것은 인스턴스 멤버가 없는 <code>Shape</code> 인스턴스 이기 때문에, <code>Rectangle.prototype.__proto__</code> 의 값은 <code>Shape.prototype</code> 이 됩니다. </p></li>
<li><p><code>Shape.prototype</code> 에는 <code>move</code> 가 있기 때문에, 이를 실행합니다.</p></li>
<li><p>만약 <code>Shape.prototype</code> 에도 <code>move</code> 가 없다면, <code>Shape.prototype.__proto__</code> 를 탐색합니다. 모든 객체는 Default 값으로 <code>Object</code> 를 상속받으며, <code>Shape</code> 도 마찬가지입니다. <code>Shape</code> 은 <code>Object</code> 를 상속받았기 때문에 <code>Shape.prototype.__proto__</code> 는 <code>Object.prototype</code> 을 가리킵니다. 여기서 메소드를 검색합니다.</p></li>
<li><p>만약 <code>Object.prototype</code> 에도 없다면, <code>Object.prototype.__proto__</code> 를 검색하나, 이 값은 <code>null</code> 이기 때문에 멤버 검색에 실패하고 <code>undefined</code> 를 돌려줍니다.</p></li>
</ol>

<p>다른 예제지만, 이미지를 통해 보는것도 이해에 도움이 될 듯 하여 이미지를 같이 첨부합니다.</p>

<p><br/>  </p>

<p>  
<img src='http://mckoss.com/jscript/Prototype.gif'  />  
</p>  

<p align="center">  
(<a href='http://mckoss.com/jscript/object.htm' >http://mckoss.com/jscript/object.htm</a>)
</p>  

<p><br/></p>

<h3 id="objectfunction">Object, Function</h3>

<p>자바스크립트의 모든 함수는 <code>Function</code> 의 인스턴스입니다. 무슨 말인고 하니, 사용자가 정의한 함수들은 <code>__proto__</code> 값으로 <code>Function.prototype</code> 을 가진다는 뜻이지요.</p>

<pre><code class="javascript">function example() {};

example.__proto__ === Function.prototype; // true  
</code></pre>

<p>그리고 <code>Function</code> 은 <code>Object</code> 를 상속합니다. 다시 말해, </p>

<pre><code class="javascript">example.__proto__.__proto__ == Object.prototype  
</code></pre>

<p>그리고 이전에 언급했듯이, <code>Object.prototype.__proto__</code> 는 <code>null</code> 입니다.</p>

<pre><code class="javascript">Object.prototype.__proto__ === null // true  
</code></pre>

<p>그리고 <code>Object</code> 그 자체는, <code>Function</code> 을 상속합니다.</p>

<pre><code class="javascript">Object.__proto__ === Function.prototype // true  
</code></pre>

<p>그래서 <code>Function</code> 과 <code>Object</code> 를 설명할때, 아래와 같은 그림으로 설명할 수 있습니다. 아래 그림에서 빨간 선으로 이어진 <code>[[Prototype]]</code> 은 <code>__proto__</code> 입니다.</p>

<p><br/>  </p>

<p align="center">  
<img src='http://i.stack.imgur.com/rcGmc.png'  />  
</p>  

<p align="center">  
(<a href='http://iwiki.readthedocs.org/en/latest/javascript/js_core.html' #inheritance'>http://iwiki.readthedocs.org/en/latest/javascript/js_core.html#inheritance</a>)
</p>  

<p><br/></p>

<h3 id="prototypeinhertancevsclassicalinheritance">Prototype Inhertance vs Classical Inheritance</h3>

<p>"그래요. 프로토타입 기반 상속이란 이런거군요!. 근데 이거 왜 하는건가요?"</p>

<p>제 짧은 지식으로 어줍잖게 대답하는 것보다, 링크로 연결해드리는게 더 나을것 같아서 관련 링크를 적어놓습니다. 꼭 읽어보셨으면 좋겠습니다.</p>

<ol>
<li><p><a href='http://stackoverflow.com/questions/19633762/classical-inheritance-vs-protoypal-inheritance-in-javascript' >classical-inheritance-vs-protoypal-inheritance-in-javascript</a></p></li>
<li><p><a href='http://aaditmshah.github.io/why-prototypal-inheritance-matters/' #toc_6">why-prototypal-inheritance-matters</a></p></li>
<li><p><a href='http://stackoverflow.com/questions/2800964/benefits-of-prototypal-inheritance-over-classical' >benefits-of-prototypal-inheritance-over-classical</a></p></li>
<li><p><a href='http://stackoverflow.com/questions/1450582/classical-vs-prototypal-inheritance' >classical-vs-prototypal-inheritance</a></p></li>
</ol>

<h3 id="newvsobjectcreate">new vs Object.create</h3>

<p>위에서 잠깐 언급했듯이 일반적으로는 프로토타입 객체를 만들기 위해서 <code>Object.create()</code>를 사용한다고 했었습니다. <code>new</code> 대신에요. 왜 그런가 <code>Object.create</code> 의 동작을 한번 알아보겠습니다.</p>

<ol>
<li><code>Object.create</code> 는 첫 번째 인자로 프로토타입을 받습니다.  </li>
<li>빈 객체를 하나 만들고, 이 객체의 <code>__proto__</code> 에 인자로 받은 프로토타입 객체를 연결합니다.  </li>
<li>프로토타입이 연결된 객체를 리턴합니다.</li>
</ol>

<p>아마 코드는 아래와 비슷할 겁니다. 간단한 설명을 위해 두번째 인자는 생략하겠습니다.</p>

<pre><code class="javascript">Object.prototype.create == function(proto) {  
  var obj = {};
  obj.__proto__ = proto;
  return obj;
}
</code></pre>

<p>따라서 어떠한 경우에도 생성자를 호출하지 않으므로 다음과 같은 코드가 생성자에 있을 경우 호출되지 않을겁니다.</p>

<pre><code class="javascript">function Shape() {  
  this.x = 0;
  this.y = 0;

  console.log("This is constructor for Shape");
}

var created = Object.create(Shape.prototype);  
var newed  = new Shape(); // "This is constructor for Shape" 

console.log( created.x ); // undefined  
console.log( newed.x ); // 0;  
</code></pre>

<p><code>new</code> 를 이용해 생성한 객체만 생성자가 호출되어, <strong>"This is constructor for Shape"</strong> 가 출력되고 <code>this.x = 0</code> 이 실행됩니다. </p>

<p><code>new Shape()</code> 의 로직은 아마 다음과 비슷할 겁니다. (더 자세한 내용은 <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new' >MDN: new Operator</a> 를 보시면 되겠습니다.)</p>

<ol>
<li>새로운 오브젝트를 생성하고,  </li>
<li>이 오브젝트의 <code>__proto__</code> 에 생성자의 프로토타입 객체를 연결합니다.  </li>
<li>생성자를 호출하고, 리턴합니다.</li>
</ol>

<pre><code class="javascript">// new Shape();

{
  var obj = {};
  obj.__proto__ = Shape.prototype;
  return Shape.apply(obj, arguments) || obj; 
}
</code></pre>

<p>이렇게 <code>new</code> 연산자는 생성자를 호출하기 때문에, 새롭게 사용할 프로토타입 객체에 의도치 않은 속성이 추가될 수 있습니다. 위의 예에서 <code>Rectangle</code> 에서 새롭게 사용할 프로토타입 객체는, 다시 말해 <code>Rectangle.prototype</code> 에 들어갈 객체는 단순히 <code>__proto__</code> 값으로 <code>Shape.prototype</code> 만 가지고 있으면 됩니다. </p>

<p>만약 <code>Object.create</code> 대신 <code>new</code> 를 사용하게 되면 <code>Rectangle.prototype.x</code> 와 <code>Rectangle.prototype.y</code> 가 <code>0</code> 으로 초기화되게 됩니다. 이는 원치 않았던 부작용입니다. 이런 이유에서 일반적인 경우에는 <code>new</code> 대신 <code>Object.create</code> 를 프로토타입 객체 생성에 사용해야 합니다. 아래처럼요</p>

<pre><code class="javascript">// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype);  
</code></pre>

<h3 id="constructor">.constructor</h3>

<p>모든 프로토타입 객체들은, <code>constructor</code> 란 프로퍼티가 있습니다. 이 값은 생성자를 가리킵니다. 그러므로 아래 코드는 <code>true</code> 를 출력합니다.</p>

<pre><code class="javascript">Rectangle.prototype.constructor === Rectangle // true  
</code></pre>

<p>우리의 예제인 <code>Rectangle</code> 에서도 위에 있는 코드처럼 프로토타입의 <code>constructor</code> 값을 초기화 하고 있습니다. 왜 그래야 할까요?</p>

<p>사실 <code>.constructor</code> 값은 별로 의미있는 값은 아닙니다. 만약 우리가 <code>constructor</code> 값으로 어떤 종류의 객체인지 판별한다면, 의미는 있겠지요. 그러나 일반적으로는 <code>instanceof</code> 를 사용합니다.</p>

<pre><code class="javascript">function Shape() { this.x = 0; }

var s1 = new Shape();

console.log( s1.__proto__.constrctor === Shape) // true  
console.log( s1 instanceof Shape) // true  
</code></pre>

<p>그럼 이렇게 <code>constructor</code> 를 비교하는 작업을 <code>instanceof</code> 내부에서 사용하느냐, 그것도 아닙니다. <code>instanceof</code> 는 <code>s1.__proto__</code> 와 <code>Shape.prototype</code> 을 비교합니다.</p>

<p><code>.constructor</code> 는 사실 정말로 쓸모가 없을지도 모르겠습니다. 그러나 자바스크립트 표준이 프로토타입 객체의 <code>constructor</code> 프로퍼티는 생성자를 가르켜야 한다고 말하는 한, 적어도 세팅은 해주는게 나쁘지 않다는게 제 생각입니다. 아래는 관련된 논의입니다. </p>

<p>Link : <strong><a href='http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property' >What it the significance of the javascript constructor property</a></strong></p>

<p>다시 우리의 예제로 돌아와서, 코드를 살펴보겠습니다.</p>

<pre><code class="javascript">// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype); (1)  
Rectangle.prototype.constructor = Rectangle; (2)  
</code></pre>

<p><code>Rectangle.prototype.constuctor</code> 를 다시 세팅해 주는 이유는, 이 값이 <code>Shape</code> 이기 때문입니다. <code>Rectangle.protoype</code> 은 <code>__proto__</code> 를 <code>Shape.prototype</code> 으로 가지는 오브젝트고, 따라서 (1) 라인에서 코드를 실행시켰을 때는 다음과 같은 결과가 나옵니다.</p>

<p><code>console.log( Rectangle.prototype.constructor ); // Shape</code></p>

<p>왜냐 하면 <code>Rectangle.prototype</code> 에는 <code>constructor</code> 가 없기 때문에 <code>Rectangle.prototype.__proto__</code> 에서 <code>constructor</code> 를 찾는데, <code>Rectangle.prototype.__proto__</code> 는 <code>Shape.prototype</code> 이기 때문이지요. </p>

<p>기본적으로 우리가 생성자를 만들면, 자바스크립트는 다음과 같이 프로토타입 객체를 만들고 이 프로토타입 객체의 <code>constructor</code> 를 세팅해 줍니다.</p>

<pre><code class="javascript">function Shape() { this.x = 0; }

console.log( Shape.prototype.constructor ); // Shape;  
</code></pre>

<p><code>Rectangle.prototype.constructor</code> 는 본래 처음 <code>Rectangle</code> 생성자를 만들었을때는 <code>Rectangle</code> 이었겠지만, (1) 라인의 코드를 실행 시킨 순간 <code>Shape</code> 으로 변경되고, 더 정확히 이 값은 <code>Rectangle.prototype.__proto__.consturctor</code> 에서 옵니다. 결국 값이 바뀌었기 때문에 원래대로 돌려주어야 하므로 아래와 같은 코드를 작성해준 것입니다.</p>

<pre><code class="javascript">Rectangle.prototype.constructor = Rectangle;  
</code></pre>

<p>자 이제, 아래 그림이 완벽히 이해되실 겁니다. </p>

<p><br/>  </p>

<p align="center">  
<img src='http://i.stack.imgur.com/UfXRZ.png'  />  
</p>  

<p align="center">  
(<a href='http://dmitrysoshnikov.com/ecmascript/javascript-the-core/' >http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a>)
</p>  

<p><br/></p>]]></description><link>http://1ambda.github.io/javascript-object-inheritance/</link><guid isPermaLink="false">57da5ecb-1d40-4b48-a3bb-09654e4574ac</guid><category><![CDATA[javascript]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Sun, 10 Aug 2014 03:54:29 GMT</pubDate></item><item><title><![CDATA[CLOS, Common Lisp Object System]]></title><description><![CDATA[<p>CLOS Brief Guide based on</p>

<ol>
<li><a href='http://www.aiai.ed.ac.uk/' ~jeff/clos-guide.html'>http://www.aiai.ed.ac.uk/~jeff/clos-guide.html</a>  </li>
<li><a href='http://www.cs.northwestern.edu/academics/courses/325/readings/clos.php' >http://www.cs.northwestern.edu/academics/courses/325/readings/clos.php</a>  </li>
<li><a href='http://cl-cookbook.sourceforge.net/clos-tutorial/' >http://cl-cookbook.sourceforge.net/clos-tutorial/</a>  </li>
<li><a href='http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html' >http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html</a></li>
</ol>

<p>Full source code : <a href='https://github.com/1ambda/CLOS/blob/master/concept.lisp' >Here</a></p>

<h3 id="1classof">1. class-of</h3>

<p>Built-in Classes</p>

<ul>
<li>SYMBOL</li>
<li>STRING</li>
<li>INTEGER</li>
<li>CONS</li>
<li>VECTOR</li>
<li>and so on</li>
</ul>

<p><br/>  </p>

<h3 id="2defstruct">2. defstruct</h3>

<p><code>defstruct</code> automatically define access-function and constructor</p>

<pre><code class="lisp">(defstruct cat 
  (name)
  (age))

(setf c1 (make-cat :name 'blue :age 6))
(cat-age c1) ;; 6
(cat-name c1) ;; BLUE
</code></pre>

<p><br/></p>

<p>What defined by <code>defstruct</code> is <code>STRUCTURE-CLASS</code></p>

<pre><code class="lisp">(class-of c1)

;; #&lt;STRUCTURE-CLASS CAT)
</code></pre>

<p><br/></p>

<h3 id="3defclass">3. defclass</h3>

<p>defclass gives you more controll. You can specify <strong>initform</strong>, <strong>initarg</strong>, <strong>accessor</strong> and so on.</p>

<pre><code class="lisp">;; syntax
(DEFCLASS class-name (superclass-name*)
  (slot-description*)
  class-option*)

(defclass person ()
  ((name :initarg :name
         :initform 'bill
         :accessor person-name)
   (age :initarg :age
        :initform 26
        :accessor person-age)))

(setf p1 (make-instance 'person :name 'bob :age 26))
</code></pre>

<p><br/></p>

<p>What defined by <code>defclass</code> is <code>STANDARD-CLASS</code> which subclasses <code>STANDARD-OBJECT</code></p>

<pre><code class="lisp">(class-of p1)
(find-class 'person)

;; #&lt;STANDARD-CLASS PERSON&gt;
</code></pre>

<p><br/></p>

<h3 id="4slot">4. Slot</h3>

<p>Class defined by <code>defclass</code> can have slots. Slot is member-variable.</p>

<pre><code class="lisp">(setf p1 (make-instance 'person :name 'bob :age 26''))
(slot-value p1 'name)

;; BOB
</code></pre>

<p><br/></p>

<p><code>describe</code> function can be used to show instance or classes information</p>

<pre><code class="lisp">(describe p1) ;; instance information
;; #&lt;PERSON {1002E70513}&gt;
;;   [standard-object]
;; 
;; Slots with :INSTANCE allocation:
;;   NAME  = HOON
;;   AGE   = 26

(describe 'person) ;; class information
;; COMMON-LISP-USER::PERSON
;;   [symbol]
;; 
;; PERSON names the standard-class #&lt;STANDARD-CLASS PERSON&gt;:
;;   Class precedence-list: PERSON, STANDARD-OBJECT, SB-PCL::SLOT-OBJECT, T
;;   Direct superclasses: STANDARD-OBJECT
;;   No subclasses.
;;   Direct slots:
;;     NAME
;;       Initargs: :NAME
;;       Readers: PERSON-NAME
;;       Writers: (SETF PERSON-NAME)
;;     AGE
;;       Initargs: :AGE
;;       Readers: PERSON-AGE
;;       Writers: (SETF PERSON-AGE)
</code></pre>

<p><br/></p>

<h3 id="5slotoptioninheritance">5. Slot Option Inheritance</h3>

<p><code>initform</code> Slot options can be overrided. But <code>initarg</code> and <code>accessor</code> can't</p>

<pre><code class="lisp">(defclass teacher (person)
  ((subject :accessor teacher-subject
        :initarg :subject
        :initform "None")))

(defclass math-teacher (teacher)
  ((subject :initform "Mathmatics")))

(defvar t1 nil)
(defvar m1 nil)

(setf t1 (make-instance 'teacher :name 'bob :age 25))
(setf m1 (make-instance 'math-teacher :name 'john :age 25))

(describe t1)

;; #&lt;TEACHER {10040F9363}&gt;
;;   [standard-object]
;; 
;; Slots with :INSTANCE allocation:
;;   NAME     = BOB
;;   AGE      = 25
;;   SUBJECT  = "None"


(describe m1)

;; #&lt;MATH-TEACHER {10040FE653}&gt;
;;   [standard-object]
;; 
;; Slots with :INSTANCE allocation:
;;   NAME     = JOHN
;;   AGE      = 25
;;   SUBJECT  = "Mathmatics"
</code></pre>

<p><br/></p>

<h3 id="6multipleinheritance">6. Multiple Inheritance</h3>

<p>CLOS supports <strong>Multiple Inheritance</strong>. But I'm not going to discuss.</p>

<p>If you are interested in how CLOS solves diamond problem, see <a href='http://en.wikipedia.org/wiki/Multiple_inheritance' >Wiki</a></p>

<blockquote>
  <p>Common Lisp CLOS attempts to provide both reasonable default behavior and the ability to override it. By default, the method with the most specific argument classes is chosen; then in the order in which parent classes are named in the subclass definition. However, the programmer can override this, by giving a specific method resolution order or stating a rule for combining methods. This is called method combination, which may be fully controlled. The MOP (metaobject protocol) also provides means to modify the inheritance, dynamic dispatch, class instantiation, and other internal mechanisms without affecting the stability of the system.</p>
</blockquote>

<p>Basically, There are two rules about inheritance.</p>

<ol>
<li>Each class is more specific than its superclasses.  </li>
<li>For a given class, superclasses listed earlier are more specific than those listed later.</li>
</ol>

<p>The second rule is useful in case of</p>

<pre><code class="lisp">(defclass a (b c) ...)
</code></pre>

<p><br/> <br />
<code>initform</code> or <code>method</code> are can be from both class <code>b</code> and class <code>c</code>. But class 'b' precedes class 'c', class 'c''s <code>method' or</code>initform` will be selected.</p>

<p><br/>  </p>

<h3 id="7genericfunction">7. Generic function</h3>

<p>In common lisp, class have only <strong>data</strong>. That means <strong>code (method)</strong> is separeted from class and is <strong>not</strong> tired to any class contrary to popular object-oriented language like Java, C++. This is why we call it <strong>generic</strong> method or function.</p>

<pre><code class="lisp">;; inherit standard object
(defclass person ()
  ((name :accessor person-name
     :initarg :name)
   (age :accessor person-age
    :initarg :age)))

;; inherit person
(defclass teacher (person)
  ((subject :accessor teacher-subject
        :initarg :subject
        :initform "nothing")))

;; inherit teacher
(defclass math-teacher (teacher)
  ((subject :initform "math")))

;; create instance
(setf t1 (make-instance 'teacher :name 'bob :age 25))
(setf m1 (make-instance 'math-teacher :name 'john :age 25))

;; call method

(work t1)
;; BOB is teaching nothing

(work m1)
;; JOHN is teaching math
</code></pre>

<p><br/> <br />
Calling method like this is somewhat different from other languages. In Java, methods are binded in a class. So we can call methods <code>Class.method(args)</code>. This is <strong>Single dispatch</strong>. According to <a href='http://en.wikipedia.org/wiki/Dynamic_dispatch' #Single_and_multiple_dispatch">wikipedia</a></p>

<blockquote>
  <p>If the decision of which version of a method to call is based entirely on the class of the object x, then this is known as single dispatch because an implementation is chosen based on a single type — the type of the instance. Single dispatch is supported by many object-oriented languages, including statically typed languages such as C++ and Java, and dynamically typed languages such as Smalltalk and Objective-C.</p>
</blockquote>

<p>But in Common Lisp, Method is invoked like <code>(method classes args)</code>. CLOS select which method will be called based on <strong>classes</strong>. This is <strong>Multiple dispatch</strong>.</p>

<blockquote>
  <p>In some languages such as Common Lisp and Dylan, methods or functions can also be dynamically dispatched based on the run-time type of arguments. Expressed in pseudocode, the code manager.handle(y) could call different implementations depending on the types of both objects manager and y. This is known as multiple dispatch.</p>
</blockquote>

<p><br/>  </p>

<h3 id="8methodcombination">8. Method Combination</h3>

<p>More than one method are applicable to a given set of arguments, the applicable methods are called <strong>single effective method</strong>. Common Lisp comes with predefined <strong>standard method combination</strong>. Also, It is possible to define new kinds of method combination. Standard method combination consists of</p>

<ul>
<li>primary</li>
<li>:before</li>
<li>:after</li>
<li>:around</li>
</ul>

<pre><code class="lisp">(defgeneric work (teacher)
  (:documentation "do something based on their job"))

(defmethod work ((t1 teacher))
  (format t "~a is teaching ~a"
    (slot-value t1 'name)
    (slot-value t1 'subject)))

(defmethod work ((t1 math-teacher))
  (format t "~a's major is math~%"
    (slot-value t1 'name))
  (call-next-method))

(setf t1 (make-instance 'teacher :name 'bob :age 25))
(setf m1 (make-instance 'math-teacher :name 'john :age 25))

(work m1)
;; BOB is teaching nothing

(work t1)
;; JOHN's major is math
;; JOHN is teaching math
</code></pre>

<p><br/> <br />
If <code>around</code>, <code>before</code>, <code>after</code> keyword is not specified, the generic method is <strong>Primary</strong> method which is responsible for providing primary implementation. Above <code>work</code> methods are primary. <code>call-next-method</code> indicates that control should be passaed from this method to the method specialized on superclass as arguments.</p>

<pre><code class="lisp">(setf t1 (make-instance 'teacher :name 'bob :age 25))
(setf m1 (make-instance 'math-teacher :name 'john :age 25))

(defgeneric work (teacher)
  (:documentation "do something based on their job"))

(defmethod work ((t1 teacher))
  (format t "~a is teaching ~a~%"
    (slot-value t1 'name)
    (slot-value t1 'subject)))

(defmethod work :before ((t1 teacher))
  (format t "~a is preparing the class~%"
    (slot-value t1 'name)))

(defmethod work :after ((t1 teacher))
  (format t "~a has done his class~%"
    (slot-value t1 'name)))

(defmethod work :around ((t1 teacher))
  (format t "start around for teacher class~%")
  (let ((result (call-next-method)))
    (format t "end around for teacher class~%")
    result))

(defmethod work ((t1 math-teacher))
  (format t "~a's major is math~%"
    (slot-value t1 'name))
  (call-next-method))

(work t1)
;; start around for teacher class
;; BOB is preparing the class
;; BOB is teaching nothing
;; BOB has done his class
;; end around for teacher class
;; NIL

(work m1)
;; start around for teacher class
;; JOHN is preparing the class
;; JOHN's major is math
;; JOHN is teaching math
;; JOHN has done his class
;; end around for teacher class
;; NIL
</code></pre>

<p><br/> <br />
These <code>:before</code>, <code>:after</code>, <code>:around</code> are auxiliary methods. Superclass's auxiliary methods are automatically called when you invoke subclass's a primary method. Of course, we can define subclass's auxiliary methods.</p>

<pre><code class="lisp">(defmethod work :before ((t1 math-teacher))
  (format t "Math teacher ~a is preparing the math class~%"
    (slot-value t1 'name)))

(defmethod work :after ((t1 math-teacher))
  (format t "Math teacher ~a has done his math class~%"
    (slot-value t1 'name)))

(defmethod work :around ((t1 math-teacher))
  (format t "start around for math-teacher class~%")
  (let ((result (call-next-method)))
    (format t "end around for math-teacher class~%")
    result))

(work m1)
;; start around for math-teacher class
;; start around for teacher class
;; Math teacher JOHN is preparing the math class
;; JOHN is preparing the class
;; JOHN's major is math
;; JOHN is teaching math
;; JOHN has done his class
;; Math teacher JOHN has done his math class
;; end around for teacher class
;; end around for math-teacher class
;; NIL
</code></pre>]]></description><link>http://1ambda.github.io/clos-common-lisp-object-system/</link><guid isPermaLink="false">f45536c4-b80f-424f-9134-3a3cd7e46f1d</guid><category><![CDATA[Lisp]]></category><dc:creator><![CDATA[1ambda]]></dc:creator><pubDate>Wed, 23 Jul 2014 01:27:33 GMT</pubDate></item></channel></rss>