
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>Easy Scalaz 4, Yoneda and Free Monad</title>
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Easy Scalaz 4, Yoneda and Free Monad">
  <meta name="twitter:description" content="Free[F, A] 를 이용하면 Functor F 를 Monad 인스턴스로 만들 수 있습니다. 그런데, Coyoneda[G, A] 를 이용하면 아무 타입 G 나 Functor 인스턴스로 만들 수 있으므로 어떤 타입이든 (심지어 방금 만든 case class 조차) 모나드 인스턴스로 만들 수 있습니다. Free 를 이용하면 사용자는 자신만의 Composable DSL 을 구성하고,">
  <meta name="twitter:creator" content="@yourTwitterUsername">
  <meta name="twitter:image" content="">
  <meta name="twitter:url" content="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/">
  <meta name="twitter:domain" content="http://1ambda.github.io">


  <link rel="author" href="https://plus.google.com/101105410053351451441?rel=author">

  <link rel="shortcut icon" href="../favicon.ico">

  <link rel="stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Droid+Serif">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:600,300">
  <link rel="stylesheet" type="text/css" href="../assets/stylesheets/xpressio.css">
  <link rel="stylesheet" type="text/css" href="../assets/1ambda/1ambda.css">
  <script type="text/javascript" src="../assets/1ambda/modernizr.js">
  </script>
  <script type="text/javascript" src="../assets/1ambda/detectizr.min.js">
  </script>

  <!--load css if windows -->
  <script type="text/javascript">
    if (Modernizr.windows) {
      file = location.pathname.split( "/" ).pop();
      link = document.createElement( "link" );
      link.href = "/assets/1ambda/1ambda_windows.css";
      link.type = "text/css";
      link.rel = "stylesheet";
      link.media = "screen,print";
      document.getElementsByTagName("head")[0].appendChild( link );
    }
  </script>


  <link rel="stylesheet" href="../assets/highlight/styles/github.css">
<script src="../assets/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  <link rel="canonical" href="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/">
    <meta name="referrer" content="origin">
    
    <meta property="og:site_name" content="Old Lisper">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Easy Scalaz 4, Yoneda and Free Monad">
    <meta property="og:description" content="Free[F, A] 를 이용하면 Functor F 를 Monad 인스턴스로 만들 수 있습니다. 그런데, Coyoneda[G, A] 를 이용하면 아무 타입 G 나 Functor 인스턴스로 만들 수 있으므로 어떤 타입이든 (심지어 방금 만든 case class 조차) 모나드 인스턴스로 만들 수 있습니다. Free 를 이용하면 사용자는 자신만의 Composable DSL 을 구성하고,">
    <meta property="og:url" content="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/">
    <meta property="article:published_time" content="2015-12-06T08:34:34.617Z">
    <meta property="article:modified_time" content="2015-12-06T09:24:41.699Z">
    <meta property="article:tag" content="scala">
    <meta property="article:tag" content="monad">
    <meta property="article:tag" content="monoid">
    <meta property="article:tag" content="scalaz">
    <meta property="article:tag" content="free">
    <meta property="article:tag" content="trampoline">
    <meta property="article:tag" content="yoneda">
    <meta property="article:tag" content="coyoneda">
    <meta property="article:tag" content="free monoid">
    <meta property="article:tag" content="free monad">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Easy Scalaz 4, Yoneda and Free Monad">
    <meta name="twitter:description" content="Free[F, A] 를 이용하면 Functor F 를 Monad 인스턴스로 만들 수 있습니다. 그런데, Coyoneda[G, A] 를 이용하면 아무 타입 G 나 Functor 인스턴스로 만들 수 있으므로 어떤 타입이든 (심지어 방금 만든 case class 조차) 모나드 인스턴스로 만들 수 있습니다. Free 를 이용하면 사용자는 자신만의 Composable DSL 을 구성하고,">
    <meta name="twitter:url" content="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="1ambda">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="scala, monad, monoid, scalaz, free, trampoline, yoneda, coyoneda, free monoid, free monad">
    
    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Article",
    "publisher": "Old Lisper",
    "author": {
        "@type": "Person",
        "name": "1ambda",
        "image": "//www.gravatar.com/avatar/aa2032ba2302419e3c2ede54f1fbf687?d=404&s=250",
        "url": "http://1ambda.github.io/author/1ambda/",
        "sameAs": "http://1ambda.github.io",
        "description": "Functional, Scala, Akka, Rx and Haskell"
    },
    "headline": "Easy Scalaz 4, Yoneda and Free Monad",
    "url": "http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/",
    "datePublished": "2015-12-06T08:34:34.617Z",
    "dateModified": "2015-12-06T09:24:41.699Z",
    "keywords": "scala, monad, monoid, scalaz, free, trampoline, yoneda, coyoneda, free monoid, free monad",
    "description": "Free[F, A] 를 이용하면 Functor F 를 Monad 인스턴스로 만들 수 있습니다. 그런데, Coyoneda[G, A] 를 이용하면 아무 타입 G 나 Functor 인스턴스로 만들 수 있으므로 어떤 타입이든 (심지어 방금 만든 case class 조차) 모나드 인스턴스로 만들 수 있습니다. Free 를 이용하면 사용자는 자신만의 Composable DSL 을 구성하고,"
}
    </script>

    <meta name="generator" content="Ghost 0.7">
    <link rel="alternate" type="application/rss+xml" title="Old Lisper" href="http://1ambda.github.io/rss/">

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52181619-1', '1ambda.github.io');
  ga('send', 'pageview');
</script>
  
</head>
<body>

  <!-- You can safely delete this line if your theme does not require jQuery -->
<script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>

  
<header class="site_width text center padding_top_big margin_bottom_big">
  
  <h1 class="blog_title margin_bottom_small"><a href="http://1ambda.github.io">Old Lisper</a></h1>
  <h4 class="text book">Functional Programming World</h4>
  <div class="social border solid top_small bottom_small padding_medium">
  <h6 class="text book color c_black_medium without_margin padding_right_big">
    <a href="http://1ambda.github.io/articles/"><i class="fa fa-files-o"></i> <span class="margin_left_small desktop">Article</span></a>
  </h6>
  <h6 class="text book color c_black_medium without_margin padding_right_big">
    <a href="http://kr.linkedin.com/in/1ambda" target="_blank"><i class="fa fa-linkedin"></i> <span class="margin_left_small desktop">Linkedin</span></a>
  </h6>
  <h6 class="text book color c_black_medium without_margin padding_right_big">
    <a href="http://github.com/1ambda" target="_blank"><i class="fa fa-github"></i> <span class="margin_left_small desktop">GitHub</span></a>
  </h6>
  <h6 class="text book color c_black_medium without_margin">
    <a href="http://1ambda.github.io/oh-my-github" target="_blank"><i class="fa fa-bar-chart-o"></i> <span class="margin_left_small desktop">oh-my-github</span></a>
  </h6>
</div>
</header>

<main class="site_width" role="main">
  <article class="post tag-scala tag-monad tag-monoid tag-scalaz tag-free tag-trampoline tag-yoneda tag-coyoneda tag-free-monoid tag-free-monad">


    <header class="text center margin_bottom_medium">
      <h5 class="text book small uppercase color c_black_light margin_bottom_small">Posted in <a href="../tag/scala/">scala</a>, <a href="../tag/monad/">monad</a>, <a href="../tag/monoid/">monoid</a>, <a href="../tag/scalaz/">scalaz</a>, <a href="../tag/free/">free</a>, <a href="../tag/trampoline/">trampoline</a>, <a href="../tag/yoneda/">yoneda</a>, <a href="../tag/coyoneda/">coyoneda</a>, <a href="../tag/free-monoid/">free monoid</a>, <a href="../tag/free-monad/">free monad</a></h5>
      <h1 class="margin_bottom_medium">Easy Scalaz 4, Yoneda and Free Monad</h1>
      <h5 class="text book small uppercase color c_black_light margin_bottom_small"><time datetime="2015-12-06">Sunday, December 06, 2015</time>
      <br><br>
       <a href="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/#disqus_thread">Comment</a>
      </h5>
    </header>

    <section>
      <p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png" alt=""></p>

<p><code>Free[F, A]</code> 를 이용하면 Functor <code>F</code> 를 Monad 인스턴스로 만들 수 있습니다. 그런데, <code>Coyoneda[G, A]</code> 를 이용하면 아무 타입 <code>G</code> 나 Functor 인스턴스로 만들 수 있으므로 어떤 타입이든 (심지어 방금 만든 <em>case class</em> 조차) 모나드 인스턴스로 만들 수 있습니다.</p>

<p><code>Free</code> 를 이용하면 사용자는 자신만의 <em>Composable DSL</em> 을 구성하고, 구성한 모나딕 연산을 실행하는 해석기를 작성하게 됩니다. 즉, <strong>연산의 생성</strong> 과 <strong>연산의 실행</strong> 을 분리하여 다루게 됩니다. 이는 <em>side-effect</em> 를 실행 시점으로 미룰 수 있다는 뜻입니다. (실행용 해석기와 별도로 테스트용 해석기를 작성하는 것도 가능합니다)</p>

<p>그러면, 제가 가장 좋아하는 <a href="http://tpolecat.github.io/assets/sbtb-slides.pdf">Programs as Values: Fure Functional JDBC Programming</a> 예제로 시작해보겠습니다.</p>

<h2 id="ifwehaveamonad">If We Have a Monad</h2>

<p>JDBC 를 쌩으로 사용한다면, 다음과 같은 코드를 작성해야 할텐데</p>

<pre><code class="language-scala">// ref - http://tpolecat.github.io/

case class Person(name: String, age: Int)

def getPerson(rs: ResultSet): Person {  
  val name = rs.getString(1)
  val age  = rs.getInt(2)
}
</code></pre>

<p>다음과 같은 문제점이 있습니다.</p>

<ul>
<li><em>managed resource</em> 인 <code>ResultSet</code> 을 프로그래머가 다룰 수 있습니다. 어디에 저장이라도 하고 나중에 사용한다면 문제가 될 수 있습니다.</li>
<li><code>rs.get*</code> 은 <em>side-effect</em> 를 만들어 내므로 테스트하기 쉽지 않습니다.</li>
</ul>

<p>접근 방식을 바꿔보는건 어떨까요? 프로그램을 실행해서 <em>side-effect</em> 를 즉시 만드는 대신</p>

<ul>
<li>어떤 연산을 수행할지를 <em>case class</em> 로 만들고 이것들을 조합해 어떤 연산을 수행할지 나타낸뒤에</li>
<li>연산의 조합을 번역해 실행하는 해석기(<em>interpreter</em>) 를 만들어 보겠습니다.</li>
</ul>

<p>먼저 연산부터 정의하면,</p>

<pre><code class="language-scala">sealed trait ResultSetOp[A]

final case class GetString(index: Int) extends ResultSetOp[String]  
final case class GetInt(index: Int)    extends ResultSetOp[Int]  
final case object Next                 extends ResultSetOp[Boolean]  
final case object Close                extends ResultSetOp[Unit]  
</code></pre>

<p>이 때 만약 <code>ResultSetOp[A]</code> 가 모나드라면 다음과 같이 작성할 수 있습니다.</p>

<pre><code class="language-scala">def getPerson: ResultSetOp[Person] = for {  
  name &lt;- GetString(1)
  age  &lt;- GetInt(2)
} yield Person(name, age)

// Application Operation `*&gt;`  (e.g `1.some *&gt; 2.some== 2.some)
// See, http://eed3si9n.com/learning-scalaz/Applicative.html
def getNextPerson: ResultSetOp[Person] =  
  Next *&gt; getPerson

def getPeople(n: Int): ResultSet[List[Person]] =  
  getNextPerson.repicateM(n) // List.fill(n)(getNextPerson).sequence

def getAllPeople: ResultSetIO[Vector[Person]] =  
  getPerson.whileM[Vector](Next)
</code></pre>

<p><code>ResultSetIO</code> 는 모나드가 아니므로 위와 같이 작성할 수 없습니다.</p>

<h3 id="writingyourowndsl">Writing Your own DSL</h3>

<p>놀랍게도, <code>ResultSetIO</code> 를 모나드로 만들 수 있습니다. <code>flatMap</code>, <code>unit</code> 구현 없이 얻을 수 있는 공짜 모나드입니다. 방법은 이렇습니다.</p>

<ul>
<li><code>Free[F[_], ?]</code> 는 <code>Functor</code> <code>F</code> 에 대해 <code>Monad</code> 입니다</li>
<li><code>Coyoneda[S[_], ?]</code> 는 아무 타입 <code>S</code> 에 대해 <code>Functor</code> 입니다. </li>
</ul>

<p>따라서 <code>Free[Coyoneda[S, A], A</code> 는 아무 타입 <code>S</code> 에 대해서 모나드입니다. </p>

<pre><code class="language-scala">import scalaz.{Free, Coyoneda}, Free._

// ResultSetOpCoyo is the Functor
type ResultSetOpCoyo[A] = Coyoneda[ResultSetOp, A] 

// ResultSetIO is the Monad
type ResultSetIO[A] = Free[ResultSetOpCoyo, A]

// same as
// type ResultSetIO2[A] = Free[({ type λ[α] = Coyoneda[ResultSetOp, α]})#λ, A]
</code></pre>

<p>따라서 다음처럼 작성할 수 있습니다.</p>

<pre><code class="language-scala">val next                 : ResultSetIO[Boolean] = Free.liftFC(Next)  
def getString(index: Int): ResultSetIO[String]  = Free.liftFC(GetString(index))  
def getInt(index: Int)   : ResultSetIO[Int]     = Free.liftFC(GetInt(index))  
def close                : ResultSetIO[Unit]    = Free.liftFC(Close)  
</code></pre>

<p>여기서 <code>Free.listFC</code> 는 타입 <code>ResultSetOp</code> 를 바로 <code>ResultSetIO</code> 로 리프팅 해주는 헬퍼 함수입니다. (<code>F</code> = <em>Free</em>, <code>C</code> = <em>Coyoneda</em>)</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Free.scala#L30

/** A version of `liftF` that infers the nested type constructor. */
def liftFU[MA](value: =&gt; MA)(implicit MA: Unapply[Functor, MA]): Free[MA.M, MA.A] =  
  liftF(MA(value))(MA.TC)

/** A free monad over a free functor of `S`. */
def liftFC[S[_], A](s: S[A]): FreeC[S, A] =  
    liftFU(Coyoneda lift s)
</code></pre>

<p><code>liftFU[MA]</code> 에서, <code>MA = Coyoneda[ResultSetOp, A]</code> 로 보면 <code>Free[MA.M, MA.A]</code> 는 <code>Free[Coyoneda[ResultSetOp, A], A]</code> 가 됩니다. (<a href="https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Unapply.scala#L51">Unapply.scala</a>)</p>

<p>이를 이용해서 <code>get*</code> 를 작성해 보면</p>

<pre><code class="language-scala">import scalaz._, Scalaz._

def getPerson: ResultSetIO[Person] = for {  
  name &lt;- getString(1)
  age  &lt;- getInt(2)
} yield Person(name, age)

def getNextPerson: ResultSetIO[Person] =  
  next *&gt; getPerson

def getPeople(n: Int): ResultSetIO[List[Person]] =  
  getNextPerson.replicateM(n) // List.fill(n)(getNextPerson).sequence

def getPersonOpt: ResultSetIO[Option[Person]] =  
  next &gt;&gt;= {
    case true  =&gt; getPerson.map(_.some)
    case false =&gt; none.point[ResultSetIO]
  }

def getAllPeople: ResultSetIO[Vector[Person]] =  
  getPerson.whileM[Vector](next)
</code></pre>

<h3 id="dslinterpreter">DSL Interpreter</h3>

<p>이제 <code>RestSetOp</code> 로 작성한 연산 (일종의 프로그램) 을 실행하려면, <code>ResetSetOp</code> 명령(<em>case class</em>) 을, 로직(<em>side-effect</em> 를 유발할 수 있는) 으로 변경해야 합니다. </p>

<p><code>NaturalTransformation</code> 을 이용할건데, <code>F ~&gt; G</code> 는 <code>F</code> 를 <code>G</code> 로 변경하는 변환(<em>Transformation</em>) 을 의미합니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/package.scala#L113

/** A [[scalaz.NaturalTransformation]][F, G]. */
type ~&gt;[-F[_], +G[_]] = NaturalTransformation[F, G]

// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/NaturalTransformation.scala#L14
/** A universally quantified function, usually written as `F ~&gt; G`,
  * for symmetry with `A =&gt; B`.
  *
  * Can be used to encode first-class functor transformations in the
  * same way functions encode first-class concrete value morphisms;
  * for example, `sequence` from [[scalaz.Traverse]] and `cosequence`
  * from [[scalaz.Distributive]] give rise to `([a]T[A[a]]) ~&gt;
  * ([a]A[T[a]])`, for varying `A` and `T` constraints.
  */
trait NaturalTransformation[-F[_], +G[_]] {  
  self =&gt;
  def apply[A](fa: F[A]): G[A]

  def compose[E[_]](f: E ~&gt; F): E ~&gt; G = new (E ~&gt; G) {
    def apply[A](ea: E[A]) = self(f(ea))
  }

  def andThen[H[_]](f: G ~&gt; H): F ~&gt; H =
    f compose self
}
</code></pre>

<p>이제, <code>ResultSetOp</code> 를 <code>IO</code> 로 변경하는 해석기를 작성하면, (<a href="http://eed3si9n.com/learning-scalaz/IO+Monad.html">Learning Scalaz - IO</a>)</p>

<pre><code class="language-scala">import scalaz.effect._

private def interpret(rs: ResultSet) = new (ResultSetOp ~&gt; IO) {  
    def apply[A](fa: ResultSetOp[A]): IO[A] = fa match {
      case Next         =&gt; IO(rs.next)
      case GetString(i) =&gt; IO(rs.getString(i))
      case GetInt(i)    =&gt; IO(rs.getInt(i))
      case Close        =&gt; IO(rs.close)
      // more... 
    }
}

def run[A](a: ResultSetIO[A], rs: ResultSet): IO[A] =  
  Free.runFC(a)(interpret(rs))
</code></pre>

<h2 id="whyfree">Why Free?</h2>

<p><code>Free</code> 가 제공하는 가치는 다음과 같습니다. (Ref - <a href="http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern">StackExchange</a>)</p>

<ul>
<li>It is a lightweight way of <strong>creating a domain-specific language that gives you an AST</strong>, and then having <strong>one or more interpreters</strong> to <strong>execute the AST</strong> however you like</li>
<li>The free monad part is just a handy way to get an AST that you can assemble using Haskell's standard monad facilities (like do-notation) without having to write lots of custom code. This also ensures that your DSL is composable</li>
<li>You could then interpret this however you like: run it against a live database, run it against a mock, just log the commands for debugging or even try optimizing the queries</li>
</ul>

<p>즉, <code>Free</code> 는 우리는 자신만의 Composable 한 DSL 을 구축하고, 필요에 따라 이 DSL 다른 방식으로 해석할 수 있도록 도와주는 도구입니다. </p>

<h2 id="free">Free</h2>

<p>(<code>Free</code> 와 <code>Yoneda</code> 는 난해할 수 있으니, <code>Free</code> 를 어떻게 사용하는지만 알고 싶다면 <a href="http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/#reasonablypricedmonad">Reasonably Priced Monad</a> 로 넘어가시면 됩니다.)</p>

<p>어떻게 <code>F</code> 가 <code>Functor</code> 이기만 하면 <code>Free[F[_], ?]</code> 가 모나드가 되는걸까요? 이를 알기 위해선, 모나드가 어떤 구조로 이루어져 있는지 알 필요가 있습니다.</p>

<h3 id="monad">Monad</h3>

<blockquote>
  <p>A monad is just a monoid in the category of endofunctors, what's the problem?</p>
</blockquote>

<p><del>의사양반 이게 무슨소리요!</del></p>

<p>이제 <code>Monoid</code> 와 <code>Functor</code> 가 무엇인지 알아봅시다.</p>

<h2 id="monoid">Monoid</h2>

<p>어떤 집합 <code>S</code> 에 대한 닫힌 연산 <code>*</code>, 집합 내의 어떤 원소 <code>e</code> 가 다음을 만족할 경우 모노이드라 부릅니다.</p>

<ul>
<li><code>e * a = a = a * e</code> (<em>identity</em>)</li>
<li><code>(a * b) * c = a * (b * c)</code> (<em>associativity</em>)</li>
</ul>

<p>일반적으로 <code>e</code> 를 항등원이라 부릅니다. <code>Option[A]</code> 도 <code>None</code> 을 항등원으로 사용하고, <em>associativity</em> 를 만족하는 <code>A</code> 의 연산을 사용하면 모노이드입니다. 따라서 <code>A</code> 가 모노이드면 <code>Option[A]</code> 도 모노이드입니다. (활용법은 <a href="http://www.slideshare.net/oxbow_lakes/practical-scalaz">Practical Scalaz</a> 참조)</p>

<pre><code class="language-scala">&gt; load.ivy("org.scalaz" % "scalaz-core_2.11" % "7.2.0-M5")
&gt; import scalaz._, Scalaz._


&gt; 1.some |+| 2.some
res11: Option[Int] = Some(3)  
&gt; 1.some |+| none
res12: Option[Int] = Some(1)  
&gt; none[Int] |+| 1.some
res13: Option[Int] = Some(1)  
</code></pre>

<h2 id="functor">Functor</h2>

<p><code>Functor</code> 는 일반적으로 다음처럼 정의되는데, 이는 <code>Functor F</code> 가 <code>F</code> 에서 값을 꺼내, 함수를 적용해 값을 변경할 수 있다는 것을 의미합니다.</p>

<blockquote>
  <p>A functor may go from one category to a different one</p>
</blockquote>

<pre><code class="language-scala">trait Functor[F[_]] {  
  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]
}
</code></pre>

<p>그리고 <code>Functor</code> 는 <em>identity function</em> 을 항등원으로 사용하면, 모노이드입니다.</p>

<ul>
<li><code>F.map(x =&gt; x) == F</code> </li>
<li><code>F map f map g == F map (f compose g)</code></li>
</ul>

<p>이 때, 변환의 인풋과 아웃풋이 같은 카테고리라면 이 <code>Functor</code> 를 <em>endo-functor</em> 라 부릅니다. </p>

<blockquote>
  <p>A functor may go from one category to a different one, an endofunctor is a functor for which start and target category are the same.</p>
</blockquote>

<h2 id="monad">Monad</h2>

<p>그럼 다시 처음 문장으로 다시 돌아가면, </p>

<blockquote>
  <p>Monads are just monoids in the category of endofunctors</p>
</blockquote>

<p>이 것의 의미를 이해하려면 모나드가 무엇인지 알아야 합니다.</p>

<pre><code class="language-scala">trait Monad[F[_]] {  
  def point[A](a: A): F[A]
  def join[A](ffa: F[F[A]): F[A]
  ...
}
</code></pre>

<p>일반적으로는 <code>point</code> (=<code>return</code>) 와 <code>bind</code> (= <code>flatMap</code>) 으로 모나드를 정의하나, <code>join</code>, <code>map</code> 으로도 <code>bind</code> 를 정의할 수 있습니다.</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

trait Monad[F[_]] {  
  def point[A](a: A): F[A]
  def bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]

  def map[A, B](fa: F[A])(f: A =&gt; B): F[B] = 
    bind(fa)(a =&gt; point(f(a))    
  def join[A](ffa: F[F[A]): F[A] = 
    bind(ffa)(fa =&gt; fa)
}

trait Monad[F[_]] {  
  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]
  def point[A](a: A): F[A]
  def join[A](ffa: F[F[A]): F[A] /* flatten*/

  def bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B] = 
    join(map(fa)(f))
}
</code></pre>

<p><code>map</code>, <code>point</code>, <code>join</code> 관점에서 모나드를 바라보면,</p>

<ul>
<li><strong>(endo)functor</strong> <code>T : X → X</code></li>
<li><strong>natural transformation</strong> <code>μ : T × T → T</code> (where <code>×</code> means functor composition (also known as <code>join</code> in Haskell)</li>
<li><strong>natural transformation</strong>  <code>η : I → T</code> (where <code>I</code> is the identity endofunctor on <code>X</code> also known as <code>return</code> in Haskell)</li>
</ul>

<p>이때 위 연산들이 모노이드 법칙을 만족합니다.</p>

<ul>
<li><code>e * a = a = a * e</code> (<em>identity</em>)</li>
<li><p><code>(a * b) * c = a * (b * c)</code> (<em>associativity</em>)</p></li>
<li><p><code>μ(η(T)) = T = μ(T(η))</code> (<em>identity</em>)</p></li>
<li><code>μ(μ(T × T) × T)) = μ(T × μ(T × T))</code> (<em>associativity</em>)</li>
</ul>

<p>스칼라 코드로 보면,</p>

<pre><code class="language-scala">&gt; import scalaz._, Scalaz._

&gt; val A = List(1, 2)
List[Int] = List(1, 2)

// identity left-side: μ(η(T)) = T
&gt; A.map(x =&gt; Monad[List].point(x)).flatten
List[Int] = List(1, 2)

// identity right-side: μ(T(η)) = T
&gt; Monad[List].point(A).flatten
List[Int] = List(1, 2)

// associativity
&gt; val T = List(1, 2, 3, 4)
T: List[Int] = List(1, 2, 3, 4)  
&gt; val TT = T.map(List(_))
TT: List[List[Int]] = List(List(1), List(2), List(3), List(4))

// associativity left-side: μ(μ(T × T) × T))
&gt; TT.flatten.map(List(_))
res30: List[List[Int]] = List(List(1), List(2), List(3), List(4))  
&gt; TT.flatten.map(List(_)).flatten
res31: List[Int] = List(1, 2, 3, 4)

// associativity right-side: μ(T × μ(T × T))
&gt; List(TT.flatten)
res34: List[List[Int]] = List(List(1, 2, 3, 4))  
&gt; List(TT.flatten).flatten
res35: List[Int] = List(1, 2, 3, 4)  
</code></pre>

<p>따라서 <em>Monad</em>는 <em>(endo)Functor</em> 카테고리에 대한 <em>Monoid</em> 입니다.</p>

<h2 id="freemonoid">Free Monoid</h2>

<p><em>Free Monad</em> 가 <code>bind</code>, <code>point</code> 에 대한 구현 없이, 모나드가 되듯이 <em>Free Monoid</em> 또한 연산과 항등원에 대한 구현 없이 <em>구조적</em> 으로 모노이드입니다. </p>

<p>항등원과 연산을 <code>Zero</code>, <code>Append</code> 라는 이름으로 <em>구조화</em> 하면,</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

sealed trait FreeMonoid[+A]  
final case object Zero extends FreeMonoid[Nothing]  
final case class Value[A](a: A) extends FreeMonoid[A]  
final case class Append[A](l: FreeMonoid[A], r: FreeMonoid[A]) extends FreeMonoid[A]  
</code></pre>

<p>모노이드는 <em>associativity</em> 를 만족하므로, <code>Append</code> 를 우측 결합으로 바꾸고, <code>Zero</code> 로 끝나도록 하면</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

sealed trait FreeMonoid[+A]  
final case object Zero extends FreeMonoid[Nothing]  
final case class Append[A](l: A, r: FreeMonoid[A]) extends FreeMonoid[A]  
</code></pre>

<p><code>List</code> 와 동일한 구조임을 알 수 있습니다. 실제로, 리스트는 <em>concatenation</em> 연산, <code>Nil</code> 항등원에 대해 모노이드입니다.</p>

<h2 id="freemonad">Free Monad</h2>

<p>이제까지의 내용을 정리하면</p>

<ul>
<li>Monad is a monoid of functors</li>
<li>Then, <strong>Free Monad is a free Monoid of functors</strong> </li>
</ul>

<p>따라서 <em>Free Monad</em> 는 <em>Functor</em> 의 <em>List</em> 라 볼 수 있습니다.</p>

<p>모나드의 <code>point</code>, <code>join</code> 을 <em>구조화</em> (<em>타입화</em>) 하면, </p>

<pre><code class="language-scala">def point[A](a: A): F[A]  
def join[A, B](ffa: F[F[A]): F[A]

sealed trait Free[F[_], A]  
case class Point[F[_], A](a: A) extends Free[F, A]             // == Return  
case class Join[F[_], A](ffa: F[Free[F, A]]) extends Free[F, A] // == Suspend  
</code></pre>

<p><code>map</code> 을 타입화 하는 대신, <code>F</code> 가 <code>Functor</code> 라면 다음처럼 <code>Free.point</code>, <code>Free.flatMap</code> 을 작성할 수 있습니다.</p>

<pre><code class="language-scala">sealed trait Free[F[_], A] {  
  def point[F[_]](a: A): Free[F, A] = Point(a)
  def flatMap[B](f: A =&gt; Free[F, B])(implicit functor: Functor[F]): Free[F, B] =
    this match {
      case Point(a)  =&gt; f(a)
      case Join(ffa) =&gt; Join(ffa.map(fa =&gt; fa.flatMap(f)))
    }
  def map[B](f: A =&gt; B)(implicit functor: Functor[F]): Free[F, B] =
    flatMap(a =&gt; Point(f(a)))
}

case class Point[F[_], A](a: A) extends Free[F, A]  
case class Join[F[_], A](ff: F[Free[F, A]]) extends Free[F, A]  
</code></pre>

<p><code>fa.flatMap(f)</code> 의 결과가 <code>Free[F, B]</code> 고 <code>ffa.map</code> 의 결과로 들어가므로, <code>ffa.map(_ flatMap f)</code> 의 결과는 <code>F[Free[F, B]</code> 입니다. 이걸 <code>Free[F, B]</code> 로 바꾸려면 <code>Join</code> 을 이용하면 됩니다.</p>

<p><strong>이런 이유에서, <code>F</code> 가 <code>Functor</code> 면 <code>Free[F, A]</code> 는 <code>Monad</code> 입니다.</strong></p>

<p>이제 리프팅과 실행을 위한 헬퍼 함수를 만들면,</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

import scalaz.{Functor, Monad, ~&gt;}

def liftF[F[_], A](a: =&gt; F[A])(implicit F: Functor[F]): Free[F, A] =  
  Join(F.map(a)(Point[F, A]))

def foldMap[F[_], M[_], A](fm: Free[F, A])(f: F ~&gt; M)  
                          (implicit FI: Functor[F], MI: Monad[M]): M[A] = 
  fm match {
    case Point(a) =&gt; MI.pure(a)
    case Join(ffa) =&gt; MI.bind(f(ffa))(fa =&gt; foldMap(fa)(f))
  }
</code></pre>

<p>여기서 <code>F ~&gt; M</code> 는 <code>F</code> 를 <code>M</code> 으로 변환해주는, <em>NaturalTransformation</em> 입니다.</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

type ~&gt;[-F[_], +G[_]] = NaturalTransformation[F, G] 

trait NaturalTransformation[-F[_], +G[_]] {  
  self =&gt;
  def apply[A](fa: F[A]): G[A]

  def compose[E[_]](f: E ~&gt; F): E ~&gt; G = new (E ~&gt; G) {
    def apply[A](ea: E[A]) = self(f(ea))
  }
}
</code></pre>

<p><code>MI.bind(f(ffa))</code> 의 결과는 <code>M[Free[F, A]]</code> 이므로 여기에서 <code>bind</code> (= <code>flatMap</code>) 로 <code>fa</code> 를 얻어, 재귀적으로 <code>foldMap</code> 을 호출합니다.</p>

<h3 id="scalazfreeimplementation">Scalaz Free Implementation</h3>

<pre><code class="language-scala">def flatMap[B](f: A =&gt; Free[F, B])(implicit functor: Functor[F]): Free[F, B] =  
    this match {
      case Point(a)  =&gt; f(a)
      case Join(ffa) =&gt; Join(ffa.map(fa =&gt; fa.flatMap(f)))
    }
</code></pre>

<p>Scalaz 에서는 <code>flatMap</code> 호출시 Stack 비용이 생각보다 크므로, <code>flatMap</code> 자체도 타입화하고 있습니다. 즉, Stack 대신에 Heap 을 사용합니다. </p>

<p><code>Point</code> 대신, <code>Return</code>, <code>Join</code> 대신 <code>Suspend</code>, <code>FlatMap</code> 대신 <code>GoSub</code> 라는 타입 이름으로 구현되어 있습니다. (이해를 돕기 위해 7.x 대신, 6.0.4 버전을 차용)</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/release/6.0.4/core/src/main/scala/scalaz/Free.scala

final case class Return[S[+_], +A](a: A) extends Free[S, A]  
final case class Suspend[S[+_], +A](a: S[Free[S, A]]) extends Free[S, A]  
final case class Gosub[S[+_], A, +B](a: Free[S, A],  
                                     f: A =&gt; Free[S, B]) extends Free[S, B]
sealed trait Free[S[+_], +A] {  
  final def map[B](f: A =&gt; B): Free[S, B] =
    flatMap(a =&gt; Return(f(a)))

  final def flatMap[B](f: A =&gt; Free[S, B]): Free[S, B] = this match {
    case Gosub(a, g) =&gt; Gosub(a, (x: Any) =&gt; Gosub(g(x), f))
    case a           =&gt; Gosub(a, f)
  }
}
</code></pre>

<h3 id="trampoline">Trampoline</h3>

<p><code>Free</code> 를 이용하면, Stackoverflow 를 피할 수 있습니다. 이는 <code>Free</code> 가 <code>flatMap</code> 체인에서 스택 대신 힙을 이용하는 것을 응용한 것인데요,</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/release/6.0.4/core/src/main/scala/scalaz/Free.scala

/** A computation that can be stepped through, suspended, and paused */
type Trampoline[+A] = Free[Function0, A]  
</code></pre>

<p>이때 <code>Function0</code> 도 <code>Functor</code> 이므로, </p>

<pre><code class="language-scala">implicit Function0Functor: Functor[Function0] = new Functor[Function0] {  
  def fmap[A, B](f: A =&gt; B)(fa: Function0[A]): Function0[B] = 
    () =&gt; f(fa)
}
</code></pre>

<p><code>Free[Function0, A]</code> 도 모나드입니다. </p>

<p>이제 스칼라에서 스택오버플로우가 발생하는 <em>mutual recursion</em> 코드를 만들어 보면,</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

def isOdd(n: Int): Boolean = {  
  if (0 == n) false
  else isEven(n -1)
}

def isEven(n: Int): Boolean = {  
  if (0 == n) true
  else isOdd(n -1)
}

isOdd(10000) // stackoverflow  
</code></pre>

<p>이제 <code>Trampoline</code> 을 이용하면</p>

<pre><code class="language-scala">// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

import scalaz._, Scalaz._, Free._

def isOddT(n: Int): Trampoline[Boolean] =  
  if (0 == n) return_(false)
  else suspend(isEvenT(n - 1))

def isEvenT(n: Int): Trampoline[Boolean] =  
  if (0 == n) return_(true)
  else suspend(isOddT(n - 1))

scala&gt; isOddT(2000000).run  
res7: Boolean = false

scala&gt; isOddT(2000001).run  
res8: Boolean = true  
</code></pre>

<p><code>return_</code> 과 <code>suspend</code> 는 다음처럼 정의되어 있습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Free.scala#L15

trait FreeFunctions {

  ...
  def return_[S[_], A](value: =&gt; A)(implicit S: Applicative[S]): Free[S, A] =
    Suspend[S, A](S.point(Return[S, A](value)))

  def suspend[S[_], A](value: =&gt; Free[S, A])(implicit S: Applicative[S]): Free[S, A] =
    Suspend[S, A](S.point(value))
</code></pre>

<h2 id="yonedacoyoneda">Yoneda, Coyoneda</h2>

<p>포스트의 시작 부분에서 <code>Coyoneda</code> 에 대한 언급을 기억하시나요?</p>

<ul>
<li><code>Free[F[_], ?]</code> 는 <code>Functor</code> <code>F</code> 에 대해 <code>Monad</code> 입니다</li>
<li><code>Coyoneda[S[_], ?]</code> 는 아무 타입에 대해 <code>Functor</code> 입니다. </li>
</ul>

<p><code>Coyoneda</code> 가 어떻게 <code>Functor</code> 를 만들어내는지 확인해 보겠습니다. 이 과정에서 <em>dual</em> 인 <code>Yoneda</code> 도 같이 살펴보겠습니다. (같은 <em>Category</em> 내에서, <em>morphism</em> 방향만 다른 경우)</p>

<p>먼저, <code>Yoneda</code>, <code>Coyoneda</code> 의 기본적인 내용을 훑고 가면</p>

<ul>
<li><code>Yoneda</code>, <code>Coyoneda</code> 는 <code>Functor</code> 입니다</li>
<li><code>Yoneda[F[_], A]</code>, <code>Coyoneda[F[_], A]</code> 는 <code>F[A]</code> 와 <em>isomorphic</em> 입니다 (<code>F</code> 가 <code>Functor</code> 일 경우)</li>
<li><code>Yoneda[F, A]</code> 에서 <code>F[A]</code> 로의 <em>homomorphism</em> 은 <code>F</code> 가 <code>Functor</code> 가 아닐 경우에도 존재합니다</li>
<li><code>F[A]</code> 에서 <code>Coyoneda[F, A]</code> 로의 <em>homomorphism</em> 은 <code>F</code> 가 <code>Functor</code> 가 아닐 경우에도 존재합니다 (중요)</li>
<li><code>Yoneda</code>, <code>Coyoneda</code> 모두 <code>Functor</code> 가 필요한 시점을 미루고, <code>Functor.map</code> 의 체인을, 일반 함수의 체인으로 표현합니다. 결국엔 <code>Functor</code> 가 필요합니다 (중요)</li>
</ul>

<p><img src="https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/4-yoneda-and-free/iso_vs_homo_morphism.png" alt=""></p>

<p><br></p>

<p>(Image - <a href="http://evolvingthoughts.net/2010/08/homology-and-analogy/">http://evolvingthoughts.net/2010/08/homology-and-analogy/</a>)</p>

<p>즉 <code>Coyoneda[F[_], A]</code> 가  <code>F</code> 와 상관없이 <code>Functor</code> 인 이유는, <code>F[A] -&gt; Coyoenda[F[_], A]</code> 로의 변환이 <code>F</code> <code>Functor</code> 인 것과 상관이 없으며 <code>Coyoneda</code> 자체가 <code>Functor</code> 인스턴스이기 때문입니다.</p>

<p>추상은 간단합니다. <code>Functor[F]</code> 가 <code>F[A] -&gt; F[B]</code> 로의 변환을 <code>f: A =&gt; B</code> 만 가지고 해 낼 수 있다는 점을 역이용하면 됩니다. <code>F[A]</code> 에 <code>Functor.map(f)</code> 를 적용하는 것이 아니라, 값 <code>A</code> 가 있을 때 <code>f(a)</code> 를 적용한 뒤에, <code>F[B]</code> 를 만들면 됩니다. 다시 말해</p>

<ul>
<li><code>Functor[F]</code> 는 <code>F[A]</code> 와 <code>f: A =&gt; B</code>, <code>g: B = &gt; C</code> 가 가 있을 때 <code>Functor[F].map(f compose g)</code> 대신</li>
<li><code>f compose g</code> 를 먼저 하고, 이것의 결과값인 <code>C</code> 를 이용해 <code>F[C]</code> 를 만들면 됩니다. 그러면 <code>Functor[F].map</code> 연산을 함수의 컴포지션으로 해결할 수 있습니다.</li>
</ul>

<h3 id="yoneda">Yoneda</h3>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Yoneda.scala

abstract class Yoneda[F[_], A] { yo =&gt;  
  def apply[B](f: A =&gt; B): F[B]

  def run: F[A] = apply(a =&gt; a)

  def map[B](f: A =&gt; B): Yoneda[F, B] = new Yoneda[F, B] {
    override def apply[C](g: (B) =&gt; C): F[C] = yo(f andThen g)
  }
}

/** `F[A]` converts to `Yoneda[F, A]` for any functor `F` */
def apply[F[_]: Functor, A](fa: F[A]): Yoneda[F, A] = new Yoneda[F, A] {  
  override def apply[B](f: A =&gt; B): F[B] = Functor[F].map(fa)(f)
}

/** `Yoneda[F, A]` converts to `F[A` for any `F` */
def from[F[_], A](yo: Yoneda[F, A]): F[A] =  
  yo.run

/** `Yoneda[F, _]` is a functor for any `F` */
implicit def yonedaFunctor[F[_]]: Functor[({ type  λ[α] = Yoneda[F,α]})#λ] =  
  new Functor[({type λ[α] = Yoneda[F, α]})#λ] {
    override def map[A, B](ya: Yoneda[F, A])(f: A =&gt; B): Yoneda[F, B] =
      ya map f
  }
</code></pre>

<p><code>Yoneda[F[_], ?]</code> 는 그 자체로 <code>Functor</code> 이나 이를 만들기 위해선 <code>F</code> 가 <code>Functor</code> 여야 합니다. 반면 <code>Yoneda[F, A] -&gt; F[A]</code> 로의 변환은 <code>F</code> 가 <code>Functor</code> 이던 아니던 상관 없습니다.</p>

<h3 id="coyoneda">Coyoneda</h3>

<p>그렇다면, <em>dual</em> 인 <code>Coyoneda</code> 는 어떨까요? <code>Yoneda</code> <code>F[A]</code> 를 <code>Functor</code> 로 부터 얻는것이 아니라, <em>Identity</em> 를 이용해, 처음부터 <code>F[A]</code> 를 가지고 있습니다. 이로 부터 얻어지는 결론은 놀랍습니다.</p>

<pre><code class="language-scala">sealed abstract class Coyoneda[F[_], A] { coyo =&gt;  
  type I
  val fi: F[I]
  val k: I =&gt; A

  final def map[B](f: A =&gt; B): Aux[F, I, B] =
    apply(fi)(f compose k)

  final def run(implicit F: Functor[F]): F[A] =
    F.map(fi)(k)
}

type Aux[F[_], A, B] = Coyoneda[F, B] { type I = A }

def apply[F[_], A, B](fa: F[A])(_k: A =&gt; B): Aux[F, A, B] =  
  new Coyoneda[F, B] {
    type I = A
    val k = _k
    val fi = fa
  }

/** `F[A]` converts to `Coyoneda[F, A]` for any `F` */
def lift[F[_], A](fa: F[A]): Coyoneda[F, A] = apply(fa)(identity[A])

/** `Coyoneda[F, A]` converts to `F[A]` for any Functor `F` */
def from[F[_], A](coyo: Coyoneda[F, A])(implicit F: Functor[F]): F[A] =  
  F.map(coyo.fi)(coyo.k)

/** `CoyoYoneda[F, _]` is a functor for any `F` */
implicit def coyonedaFunctor[F[_]]: Functor[({ type  λ[α] = Coyoneda[F,α]})#λ] =  
  new Functor[({type λ[α] = Coyoneda[F, α]})#λ] {
    override def map[A, B](ca: Coyoneda[F, A])(f: A =&gt; B): Coyoneda[F, B] =
      ca.map(f)
  }
</code></pre>

<p>따라서 <code>Coyoneda[F[_], ?]</code> 를 만들기 위해서 <code>F</code> 가 <code>Functor</code> 일 필요가 없습니다. </p>

<p><a href="http://stackoverflow.com/questions/24000465/step-by-step-deep-explain-the-power-of-coyoneda-preferably-in-scala-throu">Stackoverflow - The Power of (Co)yoneda</a> 에선 다음처럼 설명합니다.</p>

<pre><code class="language-haskell">newtype Yoneda f a = Yoneda { runYoneda :: forall b . (a -&gt; b) -&gt; f b }

instance Functor (Yoneda f) where  
  fmap f y = Yoneda (\ab -&gt; runYoneda y (ab . f))

data CoYoneda f a = forall b . CoYoneda (b -&gt; a) (f b)

instance Functor (CoYoneda f) where  
  fmap f (CoYoneda mp fb) = CoYoneda (f . mp) fb
</code></pre>

<blockquote>
  <p>So instead of appealing to the <code>Functor</code> instance for <code>f</code> during definition of the <code>Functor</code> instance for <code>Yoneda</code>, it gets <strong>"defered"</strong> to the construction of the <code>Yoneda</code> itself. Computationally, it also has the nice property of turning all <code>fmaps</code> into compositions with the "continuation" function (<code>a -&gt; b</code>).</p>
  
  <p>The opposite occurs in <code>CoYoneda</code>. For instance, <code>CoYoneda f</code> is still a <code>Functor</code> whether or not <code>f</code> is. Also we again notice the property that <code>fmap</code> is nothing more than composition along the eventual continuation.</p>
  
  <p><strong>So both of these are a way of "ignoring" a <code>Functor</code> requirement for a little while, especially while performing <code>fmap</code>s.</strong></p>
</blockquote>

<h2 id="reasonablypricedmonad">Reasonably Priced Monad</h2>

<p><em>for comprehension</em> 내에서는 단 하나의 모나드 밖에 쓸 수 없습니다. <del>단칸방 세입자 모나드</del> <em>Monad Transformer</em> 등을 사용하긴 하는데 불편하기 짝이 없지요.</p>

<p><em>Rúnar Bjarnason</em> 은 <a href="https://www.parleys.com/tutorial/composable-application-architecture-reasonably-priced-monads">Composable application architecture with reasonably priced monads
</a> 에서 <code>Coproduct</code> 를 이용해 <code>Free</code> 를 조합하는 법을 소개합니다. (<strong>이 비디오는 꼭 보셔야합니다!</strong>)</p>

<p>요약하면 <code>Free</code> 를 이용해 생성한 서로 다른 두개의 모나드는 같은 <em>for comprehension</em> 내에서 사용할 수 없습니다. 이 때 <code>Coproduct</code> 를 이용해서 하나의 타입으로 묶고, 타입 자동 주입을 위해 <code>Inject</code> 를 이용하면 많은 코드 없이도, 편리하게 <code>Free</code> 를 이용할 수 있다는 것입니다.</p>

<p>예를 들어 다음과 처럼 두개의 프리 모나드 <code>Interact</code>, <code>Auth</code> 가 있을 때</p>

<pre><code class="language-scala">// Interact
trait InteractOp[A]  
final case class Ask(prompt: String) extends InteractOp[String]  
final case class Tell(msg: String)   extends InteractOp[Unit]

type CoyonedaInteract[A] = Coyoneda[InteractOp, A]  
type Interact[A] = Free[CoyonedaInteract, A]

def ask(prompt: String) = liftFC(Ask(prompt))  
def tell(msg: String) = liftFC(Tell(msg))  
</code></pre>

<pre><code class="language-scala">// Auth
case class User(userId: UserId, permissions: Set[Permission])

sealed trait AuthOp[A]  
final case class Login(userId: UserId, password: Password) extends AuthOp[Option[User]]  
final case class HasPermission(user: User, permission: Permission) extends AuthOp[Boolean]

type CoyonedaAuth[A] = Coyoneda[AuthOp, A]  
type Auth[A] = Free[CoyonedaAuth, A]

def login(userId: UserId, password: Password): FreeC[F, Option[User]] =  
  liftFC(Login(userId, password))

def hasPermission(user: User, permission: Permission): FreeC[F, Boolean] =  
  liftFC(HasPermission(user, permission))
</code></pre>

<pre><code class="language-scala">// Log

sealed trait LogOp[A]  
final case class Warn(message: String)  extends LogOp[Unit]  
final case class Error(message: String) extends LogOp[Unit]  
final case class Info(message: String)  extends LogOp[Unit]

type CoyonedaLog[A] = Coyoneda[LogOp, A]  
type Log[A] = Free[CoyonedaLog, A]

object Log {  
  def warn(message: String)  = liftFC(Warn(message))
  def info(message: String)  = liftFC(Info(message))
  def error(message: String) = liftFC(Error(message))
</code></pre>

<p>다음처럼 같은 <em>for comprehension</em> 구문에서 사용할 수 없습니다.</p>

<pre><code class="language-scala">// doesn't compile

for {  
  userId &lt;- ask("Insert User ID: ")
  password &lt;- ask("Password: ")
  user &lt;- login(userId, password)
  _ &lt;- info(s"user $userId logged in")
  hasPermission &lt;- user.cata(
    none = point(false),
    some = hasPermission(_, "scalaz repository")
  )
  _ &lt;- warn(s"$userId has no permission for scalaz repository")
} yield hasPermission
</code></pre>

<p>이 때 <code>Coproduct</code> 를 이용하면, 가능합니다.</p>

<pre><code class="language-scala">// combine free monads
type Language0[A] = Coproduct[InteractOp, AuthOp, A]  
type Language[A] = Coproduct[LogOp, Language0, A]  
type LanguageCoyo[A] = Coyoneda[Language, A]  
type LanguageMonad[A] = Free[LanguageCoyo, A]  
def point[A](a: =&gt; A): FreeC[Language, A] = Monad[LanguageMonad].point(a)

// combine interpreters
val interpreter0: Language0 ~&gt; Id = or(InteractInterpreter, AuthInterpreter)  
val interpreter: Language ~&gt; Id = or(LogInterpreter, interpreter0)

// run a program
def main(args: Array[String]) {  
  def program(implicit I: Interact[Language], A: Auth[Language], L: Log[Language]) = {
    import I._, A._, L._

    for {
      userId &lt;- ask("Insert User ID: ")
      password &lt;- ask("Password: ")
      user &lt;- login(userId, password)
      _ &lt;- info(s"user $userId logged in")
      hasPermission &lt;- user.cata(
        none = point(false),
        some = hasPermission(_, "scalaz repository")
      )
      _ &lt;- warn(s"$userId has no permission for scalaz repository")
    } yield hasPermission
  }

  program.mapSuspension(Coyoneda.liftTF(interpreter))
}
</code></pre>

<p>여기서 <code>or</code> 과 <code>lift</code> 는 라이브러리 코드라 생각하시면 됩니다. 이제 변화된 프리 모나드 부분을 보면,</p>

<pre><code class="language-scala">object Auth {  
  type UserId = String
  type Password = String
  type Permission = String

  implicit def instance[F[_]](implicit I: Inject[AuthOp, F]): Auth[F] =
    new Auth
}

class Auth[F[_]](implicit I: Inject[AuthOp, F]) {  
  import Common._
  def login(userId: UserId, password: Password): FreeC[F, Option[User]] =
    lift(Login(userId, password))

  def hasPermission(user: User, permission: Permission): FreeC[F, Boolean] =
    lift(HasPermission(user, permission))
}

class Interact[F[_]](implicit I: Inject[InteractOp, F]) {  
  import Common._

  def ask(prompt: String): FreeC[F, String] =
    lift(Ask(prompt))

  def tell(message: String): FreeC[F, Unit] =
    lift(Tell(message))
}

object Interact {  
  implicit def instance[F[_]](implicit I: Inject[InteractOp, F]): Interact[F] =
    new Interact
}

class Log[F[_]](implicit I: Inject[LogOp, F]) {  
  import Common._

  def warn(message: String)  = lift(Warn(message))
  def info(message: String)  = lift(Info(message))
  def error(message: String) = lift(Error(message))
}

object Log {  
  implicit def instant[F[_]](implicit I: Inject[LogOp ,F]) =
    new Log
}
</code></pre>

<p>이제, <code>Common</code> 을 보면</p>

<pre><code class="language-scala">object Common {  
  import scalaz.Coproduct, scalaz.~&gt;

  def or[F[_], G[_], H[_]](f: F ~&gt; H, g: G ~&gt; H): ({type cp[α] = Coproduct[F,G,α]})#cp ~&gt; H =
    new NaturalTransformation[({type cp[α] = Coproduct[F,G,α]})#cp,H] {
      def apply[A](fa: Coproduct[F,G,A]): H[A] = fa.run match {
        case -\/(ff) ⇒ f(ff)
        case \/-(gg) ⇒ g(gg)
      }
    }

  def lift[F[_], G[_], A](fa: F[A])(implicit I: Inject[F, G]): FreeC[G, A] =
    Free.liftFC(I.inj(fa))
}
</code></pre>

<p><code>Coproduct[F, G, A]</code> 는 <strong>둘 중 하나</strong> 를 의미하는 추상입니다. 결과로 <code>F[A] \/ G[A]</code> (<em>scalaz either</em>) 을 돌려줍니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Coproduct.scala

final case class Coproduct[F[_], G[_], A](run: F[A] \/ G[A]) {  
  ...
}

trait CoproductFunctions {  
  def leftc[F[_], G[_], A](x: F[A]): Coproduct[F, G, A] =
    Coproduct(-\/(x))

  def rightc[F[_], G[_], A](x: G[A]): Coproduct[F, G, A] =
    Coproduct(\/-(x))

  ...
}
</code></pre>

<p><code>Inject[F[_], G[_]]</code> 는 <code>F</code>, <code>G</code> 를 포함하는 더 큰 타입인 <code>Coproduct</code> 를 만들때 쓰입니다.</p>

<pre><code class="language-scala">def lift[F[_], G[_], A](fa: F[A])(implicit I: Inject[F, G]): FreeC[G, A] =  
  Free.liftFC(I.inj(fa))

// F == Langauge
class Log[F[_]](implicit I: Inject[LogOp, F]) {  
  def warn(message: String)  = lift(Warn(message))
  def info(message: String)  = lift(Info(message))
  def error(message: String) = lift(Error(message))
}
</code></pre>

<p><code>Inject</code> 는 이렇게 생겼습니다.</p>

<pre><code class="language-scala">// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Inject.scala

sealed abstract class Inject[F[_], G[_]] {  
  def inj[A](fa: F[A]): G[A]
  def prj[A](ga: G[A]): Option[F[A]]
}

sealed abstract class InjectInstances {  
  implicit def reflexiveInjectInstance[F[_]] =
    new Inject[F, F] {
      def inj[A](fa: F[A]) = fa
      def prj[A](ga: F[A]) = some(ga)
    }

  implicit def leftInjectInstance[F[_], G[_]] =
    new Inject[F, ({type λ[α] = Coproduct[F, G, α]})#λ] {
      def inj[A](fa: F[A]) = Coproduct.leftc(fa)
      def prj[A](ga: Coproduct[F, G, A]) = ga.run.fold(some(_), _ =&gt; none)
    }

  implicit def rightInjectInstance[F[_], G[_], H[_]](implicit I: Inject[F, G]) =
      new Inject[F, ({type λ[α] = Coproduct[H, G, α]})#λ] {
        def inj[A](fa: F[A]) = Coproduct.rightc(I.inj(fa))
        def prj[A](ga: Coproduct[H, G, A]) = ga.run.fold(_ =&gt; none, I.prj(_))
      }
}
</code></pre>

<p>따라서 <code>F</code>, <code>G</code> 타입만 맞추어 주면 <code>Inject</code> 인스턴스는 자동으로 생성됩니다.</p>

<p>다음시간에는 <em>side-effect</em> 의 세계로 넘어가 <code>ST</code>, <code>IO</code> 등을 살펴보겠습니다.</p>

<h2 id="previousposts">Previous Posts</h2>

<ul>
<li><a href="http://1ambda.github.io/easy-scalaz-1-state/">Easy Scalaz 1, State</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-2-monad-transformer/">Easy Scalaz 2, Monad Transformer</a></li>
<li><a href="http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/">Easy Scalaz 3, ReaderWriterState with Kleisli</a></li>
</ul>

<h2 id="references">References</h2>

<ul>
<li><a href="http://cs.lth.se/edan40">Haskell Image</a></li>
<li><a href="http://tpolecat.github.io/assets/sbtb-slides.pdf">Programs as Values: Fure Functional JDBC Programming</a></li>
<li><a href="http://blog.higher-order.com/blog/2013/11/01/free-and-yoneda/">Free Monads and the Yoneda Lemma</a></li>
<li><a href="http://stackoverflow.com/questions/24000465/step-by-step-deep-explain-the-power-of-coyoneda-preferably-in-scala-throu">Stackoverflow - The Power of (Co) Yoneda</a></li>
<li><a href="http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern">Stack Exchange - What is the Free Monad + Interpreter Pattern?</a></li>
<li><a href="http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf">Free Monad is Free Monoid + Functor</a></li>
<li><a href="http://underscore.io/blog/posts/2015/04/23/deriving-the-free-monad.html">Underscore - Deriving the Free Monad</a></li>
<li><a href="http://underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html">Underscore - Free Monads Are Simple</a></li>
<li><a href="http://stackoverflow.com/questions/10342876/differences-between-functors-and-endofunctors">Stackoverflow - Difference between functors and endofuctors</a></li>
<li><a href="http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem/3870310#3870310">Stackoverflow - A monad is just monoid in the categy of endofuctors</a></li>
<li><a href="http://evolvingthoughts.net/2010/08/homology-and-analogy/">Isomorphism vs Homomorphism Image</a></li>
<li><a href="https://www.parleys.com/tutorial/composable-application-architecture-reasonably-priced-monads">Composable application architecture with reasonably priced monads
</a>(<a href="https://gist.github.com/runarorama/a8fab38e473fafa0921d">Gist: Code</a>)</li>
</ul>
    </section>

    <footer>
      <section class="author_info margin_top_big">
        <div class="alignleft border rad_circle" style="height: 87px; width: 87px; background-image: url(http://www.gravatar.com/avatar/aa2032ba2302419e3c2ede54f1fbf687?d=404&amp;s=250); background-size: cover;"></div>
        <p class="margin_left_medium text small">Author</p>
        <p class="margin_left_medium text bold"><a href="http://1ambda.github.io">1ambda</a></p>
        <p class="margin_left_medium text small">Functional, Scala, Akka, Rx and Haskell</p>
      </section>
    </footer>


    <div id="disqus_thread" class="margin_top_big"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = '1ambda'; // required: replace example with your forum shortname
  var disqus_identifier = '135';
  var disqus_url = 'http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/';

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
    </article>
</main>


  <script src="../assets/fitvids/jquery.fitvids.js"></script>
<script>
$(document).ready(function(){
  // Target your .container, .wrapper, .post, etc.
  $("section").fitVids();
});
</script>

  <footer class="blog_info margin_top_big padding_medium text center">
    <h5 class="text book small">© 2016 <a href="../">Old Lisper</a>. All rights reserved.</h5>
    <h5 class="text book small"><a href="https://github.com/dreyacosta/velox" target="_blank" class="text bold">Velox theme</a> by <a href="http://dreyacosta.com/">David Rey</a></h5>
    <h5 class="text book small">Proudly published with <a href="http://ghost.org"><span>Ghost</span></a></h5>

  </footer>

  <script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = '1ambda'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function () {
 var s = document.createElement('script'); s.async = true;
 s.type = 'text/javascript';
 s.src = '//' + disqus_shortname + '.disqus.com/count.js';
 (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
 }());
</script>


  </body>
  