<!DOCTYPE html>
<html lang="en" class="js csstransforms3d">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="generator" content="Hugo 0.16" />
    <meta name="description" content="hugo content for 1ambda.github.io">
<meta name="author" content="1ambda">

    <link rel="shortcut icon" href="https://1ambda.github.io/images/favicon.png" type="image/x-icon" />

    
    <title>Reactive Programming 4</title>
    <link href="https://1ambda.github.io/css/nucleus.css" rel="stylesheet">
    <link href="https://1ambda.github.io/css/font-awesome.min.css" rel="stylesheet">
    <link href="https://1ambda.github.io/css/hybrid.css" rel="stylesheet">
    <link href="https://1ambda.github.io/css/featherlight.min.css" rel="stylesheet">
    <link href="https://1ambda.github.io/css/perfect-scrollbar.min.css" rel="stylesheet">
    <link href="https://1ambda.github.io/css/theme.css" rel="stylesheet">
    <link href="https://1ambda.github.io/css/hugo-theme.css" rel="stylesheet">
    <style type="text/css">:root #header + #content > #left > #rlblock_left
    {display:none !important;}</style>
    <link href="https://1ambda.github.io/css/theme-1ambda.css" rel="stylesheet">

  </head>
  <body class="" data-url="/21/scala/reactive-programming-4/">
    <nav id="sidebar">
  <div id="header-wrapper">
    <div id="header">
      <a href="https://1ambda.github.io/home" style="color: white; margin-top:10px;">
  <div> <i class="fa fa-github fa-4x"></i> </div>
</a>
<div style="margin-top:5px; font-size: 25px;">1ambda</div>

      
    </div>
</div>


  <div class="highlightable">
    <ul class="topics">
      
      
      
      

      <li class="dd-item  " data-nav-id="/0/home/">
        <a href="https://1ambda.github.io/0/home/">
          <span>
            
              <b>HOME</b>
            
             
            
           </span>
        </a>
        
      </li>
      
      
      
      

      <li class="dd-item  parent" data-nav-id="/21/scala/">
        <a href="https://1ambda.github.io/21/scala/">
          <span>
            
              <b>-</b>
            
             Scala
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/easy-scalaz-1/">
              <a href="https://1ambda.github.io/21/scala/easy-scalaz-1/">
                <span>Easy Scalaz 1     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/easy-scalaz-2/">
              <a href="https://1ambda.github.io/21/scala/easy-scalaz-2/">
                <span>Easy Scalaz 2     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/easy-scalaz-3/">
              <a href="https://1ambda.github.io/21/scala/easy-scalaz-3/">
                <span>Easy Scalaz 3     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/easy-scalaz-4/">
              <a href="https://1ambda.github.io/21/scala/easy-scalaz-4/">
                <span>Easy Scalaz 4     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/easy-scalaz-5/">
              <a href="https://1ambda.github.io/21/scala/easy-scalaz-5/">
                <span>Easy Scalaz 5     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/easy-scalaz-6/">
              <a href="https://1ambda.github.io/21/scala/easy-scalaz-6/">
                <span>Easy Scalaz 6     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/functional-programming-1/">
              <a href="https://1ambda.github.io/21/scala/functional-programming-1/">
                <span>Functional Programming 1     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/functional-programming-2/">
              <a href="https://1ambda.github.io/21/scala/functional-programming-2/">
                <span>Functional Programming 2     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/functional-programming-3/">
              <a href="https://1ambda.github.io/21/scala/functional-programming-3/">
                <span>Functional Programming 3     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/functional-programming-4/">
              <a href="https://1ambda.github.io/21/scala/functional-programming-4/">
                <span>Functional Programming 4     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/functional-programming-5/">
              <a href="https://1ambda.github.io/21/scala/functional-programming-5/">
                <span>Functional Programming 5     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/functional-programming-6/">
              <a href="https://1ambda.github.io/21/scala/functional-programming-6/">
                <span>Functional Programming 6     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/functional-programming-7/">
              <a href="https://1ambda.github.io/21/scala/functional-programming-7/">
                <span>Functional Programming 7     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/reactive-programming-1/">
              <a href="https://1ambda.github.io/21/scala/reactive-programming-1/">
                <span>Reactive Programming 1     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/reactive-programming-2/">
              <a href="https://1ambda.github.io/21/scala/reactive-programming-2/">
                <span>Reactive Programming 2     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/reactive-programming-3/">
              <a href="https://1ambda.github.io/21/scala/reactive-programming-3/">
                <span>Reactive Programming 3     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item active" data-nav-id="/21/scala/reactive-programming-4/">
              <a href="https://1ambda.github.io/21/scala/reactive-programming-4/">
                <span>Reactive Programming 4     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/21/scala/reactive-programming-5/">
              <a href="https://1ambda.github.io/21/scala/reactive-programming-5/">
                <span>Reactive Programming 5     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      
      

      <li class="dd-item  " data-nav-id="/22/haskell/">
        <a href="https://1ambda.github.io/22/haskell/">
          <span>
            
              <b>- </b>
            
             Haskell
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/22/haskell/intro-to-haskell-1/">
              <a href="https://1ambda.github.io/22/haskell/intro-to-haskell-1/">
                <span>하스켈로 배우는 함수형 언어 1     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/22/haskell/intro-to-haskell-2/">
              <a href="https://1ambda.github.io/22/haskell/intro-to-haskell-2/">
                <span>하스켈로 배우는 함수형 언어 2     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/22/haskell/intro-to-haskell-3/">
              <a href="https://1ambda.github.io/22/haskell/intro-to-haskell-3/">
                <span>하스켈로 배우는 함수형 언어 3     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/22/haskell/intro-to-haskell-4/">
              <a href="https://1ambda.github.io/22/haskell/intro-to-haskell-4/">
                <span>하스켈로 배우는 함수형 언어 4     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/22/haskell/intro-to-haskell-5/">
              <a href="https://1ambda.github.io/22/haskell/intro-to-haskell-5/">
                <span>하스켈로 배우는 함수형 언어 5     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/22/haskell/intro-to-haskell-6/">
              <a href="https://1ambda.github.io/22/haskell/intro-to-haskell-6/">
                <span>하스켈로 배우는 함수형 언어 6     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/22/haskell/intro-to-haskell-7/">
              <a href="https://1ambda.github.io/22/haskell/intro-to-haskell-7/">
                <span>하스켈로 배우는 함수형 언어 7     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/22/haskell/intro-to-haskell-8/">
              <a href="https://1ambda.github.io/22/haskell/intro-to-haskell-8/">
                <span>하스켈로 배우는 함수형 언어 8     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/22/haskell/intro-to-haskell-9/">
              <a href="https://1ambda.github.io/22/haskell/intro-to-haskell-9/">
                <span>하스켈로 배우는 함수형 언어 9     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/22/haskell/poor-mans-concurrency-monad/">
              <a href="https://1ambda.github.io/22/haskell/poor-mans-concurrency-monad/">
                <span>Poor Man&#39;s Concurrency Monad     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      
      

      <li class="dd-item  " data-nav-id="/23/javascript/">
        <a href="https://1ambda.github.io/23/javascript/">
          <span>
            
              <b>- </b>
            
             Javascript
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/23/javascript/javascript-inheritance/">
              <a href="https://1ambda.github.io/23/javascript/javascript-inheritance/">
                <span>Javascript Inheritance     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/23/javascript/tips-for-webpack-and-redux/">
              <a href="https://1ambda.github.io/23/javascript/tips-for-webpack-and-redux/">
                <span>Tips for Webpack and Redux     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/23/javascript/rest-api-put-vs-post/">
              <a href="https://1ambda.github.io/23/javascript/rest-api-put-vs-post/">
                <span>REST API: Put vs Post     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      
      

      <li class="dd-item  " data-nav-id="/24/java/">
        <a href="https://1ambda.github.io/24/java/">
          <span>
            
              <b>- </b>
            
             Java
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/24/java/interview-questions-collection/">
              <a href="https://1ambda.github.io/24/java/interview-questions-collection/">
                <span>Interview Questions: Collection     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      
      

      <li class="dd-item  " data-nav-id="/51/oh-my-github/">
        <a href="https://1ambda.github.io/51/oh-my-github/">
          <span>
            
              <b>- </b>
            
             oh-my-github
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/51/oh-my-github/tutorial/">
              <a href="https://1ambda.github.io/51/oh-my-github/tutorial/">
                <span>10분만에 Github Profile 만들기     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      
      

      <li class="dd-item  " data-nav-id="/91/algorithm/">
        <a href="https://1ambda.github.io/91/algorithm/">
          <span>
            
              <b>- </b>
            
             Algorithm
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/design-and-analysis-part1-1/">
              <a href="https://1ambda.github.io/91/algorithm/design-and-analysis-part1-1/">
                <span>Design and Analysis: Divide &amp; Conquer     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/design-and-analysis-part1-2/">
              <a href="https://1ambda.github.io/91/algorithm/design-and-analysis-part1-2/">
                <span>Design and Analysis: Randomized Selection     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/design-and-analysis-part1-3/">
              <a href="https://1ambda.github.io/91/algorithm/design-and-analysis-part1-3/">
                <span>Design and Analysis: Graph Contraction Algorithm     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/design-and-analysis-part1-4/">
              <a href="https://1ambda.github.io/91/algorithm/design-and-analysis-part1-4/">
                <span>Design and Analysis: Graph Search and Connectivity     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/design-and-analysis-part1-5/">
              <a href="https://1ambda.github.io/91/algorithm/design-and-analysis-part1-5/">
                <span>Design and Analysis: Dijkstra, Heap, Red-Black Tree     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/design-and-analysis-part1-6/">
              <a href="https://1ambda.github.io/91/algorithm/design-and-analysis-part1-6/">
                <span>Design and Analysis: Hash Table, Universal Hashing, Bloom filters     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/algorithm-part1-1/">
              <a href="https://1ambda.github.io/91/algorithm/algorithm-part1-1/">
                <span>Algorithm: Union Find     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/algorithm-part1-2/">
              <a href="https://1ambda.github.io/91/algorithm/algorithm-part1-2/">
                <span>Algorithm: Analysis     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/algorithm-part2-1/">
              <a href="https://1ambda.github.io/91/algorithm/algorithm-part2-1/">
                <span>Algorithm: Spanning Tree, Shortest Paths     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/algorithm-part2-2/">
              <a href="https://1ambda.github.io/91/algorithm/algorithm-part2-2/">
                <span>Algorithm: Radix Sort, Suffix Sort     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/algorithm-part2-3/">
              <a href="https://1ambda.github.io/91/algorithm/algorithm-part2-3/">
                <span>Algorithm: R-way, Ternary Tries     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/algorithm-part2-4/">
              <a href="https://1ambda.github.io/91/algorithm/algorithm-part2-4/">
                <span>Algorithm: KMP, Boyer-Moore, Rabin-Karp     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/algorithm-part2-5/">
              <a href="https://1ambda.github.io/91/algorithm/algorithm-part2-5/">
                <span>Algorithm: Maximum Flow (Ford-Fulkerson)     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/algorithm-part2-6/">
              <a href="https://1ambda.github.io/91/algorithm/algorithm-part2-6/">
                <span>Algorithm: Data Compression, Huffman, LZW     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/artificial-intelligence-cs188-1/">
              <a href="https://1ambda.github.io/91/algorithm/artificial-intelligence-cs188-1/">
                <span>AI (CS188): Intro     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/artificial-intelligence-cs188-2/">
              <a href="https://1ambda.github.io/91/algorithm/artificial-intelligence-cs188-2/">
                <span>AI (CS188): Search     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/artificial-intelligence-planning-1/">
              <a href="https://1ambda.github.io/91/algorithm/artificial-intelligence-planning-1/">
                <span>AI Planning 1: Intro     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/artificial-intelligence-planning-2/">
              <a href="https://1ambda.github.io/91/algorithm/artificial-intelligence-planning-2/">
                <span>AI Planning 2: A*. STRIPS     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/artificial-intelligence-planning-3/">
              <a href="https://1ambda.github.io/91/algorithm/artificial-intelligence-planning-3/">
                <span>AI Planning 3: PSP, PoP     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/91/algorithm/artificial-intelligence-planning-4/">
              <a href="https://1ambda.github.io/91/algorithm/artificial-intelligence-planning-4/">
                <span>AI Planning 4: STN, HTN     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      
      

      <li class="dd-item  " data-nav-id="/92/data-analysis/">
        <a href="https://1ambda.github.io/92/data-analysis/">
          <span>
            
              <b>- </b>
            
             Data Analysis
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/machine-learning-week-1/">
              <a href="https://1ambda.github.io/92/data-analysis/machine-learning-week-1/">
                <span>ML 01: Linear Regression     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/machine-learning-week-2/">
              <a href="https://1ambda.github.io/92/data-analysis/machine-learning-week-2/">
                <span>ML 02: Gradient Descent     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/machine-learning-week-3/">
              <a href="https://1ambda.github.io/92/data-analysis/machine-learning-week-3/">
                <span>ML 03: Logistic Regression     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/machine-learning-week-4/">
              <a href="https://1ambda.github.io/92/data-analysis/machine-learning-week-4/">
                <span>ML 04: Neural Network     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/machine-learning-week-5/">
              <a href="https://1ambda.github.io/92/data-analysis/machine-learning-week-5/">
                <span>ML 05: Back Propagation     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/machine-learning-week-6/">
              <a href="https://1ambda.github.io/92/data-analysis/machine-learning-week-6/">
                <span>ML 06: Practical Advices     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/machine-learning-week-7/">
              <a href="https://1ambda.github.io/92/data-analysis/machine-learning-week-7/">
                <span>ML 07: Support Vector Machine     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/machine-learning-week-8/">
              <a href="https://1ambda.github.io/92/data-analysis/machine-learning-week-8/">
                <span>ML 08: K-means, PCA Details     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/machine-learning-week-9/">
              <a href="https://1ambda.github.io/92/data-analysis/machine-learning-week-9/">
                <span>ML 09: Anomaly Detection, Recommender System     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/machine-learning-week-10/">
              <a href="https://1ambda.github.io/92/data-analysis/machine-learning-week-10/">
                <span>ML 10: Stochastic Gradient, Synthetic Data, Ceiling Analysis     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/intro-to-data-science-1/">
              <a href="https://1ambda.github.io/92/data-analysis/intro-to-data-science-1/">
                <span>Intro to Data Science 1     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/intro-to-data-science-2/">
              <a href="https://1ambda.github.io/92/data-analysis/intro-to-data-science-2/">
                <span>Intro to Data Science 2     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/intro-to-data-science-3/">
              <a href="https://1ambda.github.io/92/data-analysis/intro-to-data-science-3/">
                <span>Intro to Data Science 3     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/intro-to-data-science-4/">
              <a href="https://1ambda.github.io/92/data-analysis/intro-to-data-science-4/">
                <span>Intro to Data Science 4     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/process-mining-1/">
              <a href="https://1ambda.github.io/92/data-analysis/process-mining-1/">
                <span>Process Mining 1: Intro     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/process-mining-2/">
              <a href="https://1ambda.github.io/92/data-analysis/process-mining-2/">
                <span>Process Mining 2: Alpha Algorithm     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/process-mining-3/">
              <a href="https://1ambda.github.io/92/data-analysis/process-mining-3/">
                <span>Process Mining 3: Metric, C-nets     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/process-mining-4/">
              <a href="https://1ambda.github.io/92/data-analysis/process-mining-4/">
                <span>Process Mining 4: Conformance Checking, Dotted Chart     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/process-mining-5/">
              <a href="https://1ambda.github.io/92/data-analysis/process-mining-5/">
                <span>Process Mining 5: Decision, Social, Organization Mining     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/pattern-discovery-1/">
              <a href="https://1ambda.github.io/92/data-analysis/pattern-discovery-1/">
                <span>Pattern Discovery 1: Apriori, FP Growth     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/pattern-discovery-2/">
              <a href="https://1ambda.github.io/92/data-analysis/pattern-discovery-2/">
                <span>Pattern Discovery 2: Null-invariant, Pattern-Fusion, Constaint     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/92/data-analysis/pattern-discovery-3/">
              <a href="https://1ambda.github.io/92/data-analysis/pattern-discovery-3/">
                <span>Pattern Discovery 3: Sequential Pattern Mining     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      
      

      <li class="dd-item  " data-nav-id="/93/cloud-computing/">
        <a href="https://1ambda.github.io/93/cloud-computing/">
          <span>
            
              <b>- </b>
            
             Cloud Computing
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/93/cloud-computing/cloud-computing-1/">
              <a href="https://1ambda.github.io/93/cloud-computing/cloud-computing-1/">
                <span>CC 01: Map Reduce     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/93/cloud-computing/cloud-computing-2/">
              <a href="https://1ambda.github.io/93/cloud-computing/cloud-computing-2/">
                <span>CC 02: Gossip Protocol     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/93/cloud-computing/cloud-computing-3/">
              <a href="https://1ambda.github.io/93/cloud-computing/cloud-computing-3/">
                <span>CC 03: Membership Protocol     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/93/cloud-computing/cloud-computing-4/">
              <a href="https://1ambda.github.io/93/cloud-computing/cloud-computing-4/">
                <span>CC 04: P2P Systems     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/93/cloud-computing/cloud-computing-5/">
              <a href="https://1ambda.github.io/93/cloud-computing/cloud-computing-5/">
                <span>CC 05: Global Snapshot     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/93/cloud-computing/cloud-computing-6/">
              <a href="https://1ambda.github.io/93/cloud-computing/cloud-computing-6/">
                <span>CC 06: Multicast     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/93/cloud-computing/cloud-computing-7/">
              <a href="https://1ambda.github.io/93/cloud-computing/cloud-computing-7/">
                <span>CC 07: Paxos     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
    </ul>
    <hr>
      
    <section id="footer">
      <p>Built with <a href="https://github.com/matcornic/hugo-theme-learn"><i class="fa fa-heart"></i></a> from <a href="http://getgrav.org">Grav</a> and <a href="http://gohugo.io/">Hugo</a></p>
    </section>
  </div>
</nav>

        <section id="body">
        <div id="overlay"></div>

        <div class="padding highlightable">

            <div id="top-bar">
              
                
                
                
              <div id="top-github-link">
                  <a class="github-link" href="https://github.com/1ambda/1ambda.github.io-hugo/edit/master/content/21/scala/reactive-programming-4.md" target="blank">
                    <i class="fa fa-code-fork"></i>
                    Edit this page
                  </a>
              </div>
                
              
              <div id="breadcrumbs" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
                  <span id="sidebar-toggle-span">
                      <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
                        <i class="fa fa-bars"></i>
                      </a>
                  </span>
                
                <span id="toc-menu"><a href=""><i class="fa fa-list-alt"></i></a></span>
                
                
                
                
                  
                
                  
                    
                    
                <a href="https://1ambda.github.io/21/scala/" itemprop="url"><span itemprop="title">Scala</span></a> <i class="fa fa-angle-right"></i>
                    
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                <span itemprop="title"> Reactive Programming 4</span>
              </div>
              
                  <div class="progress">
    <div class="wrapper">
<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#observable-rx">Observable, Rx</a>
<ul>
<li><a href="#from-futures-to-observables">From Futures to Observables</a></li>
<li><a href="#iterable">Iterable</a></li>
<li><a href="#future-vs-observable">Future vs Observable</a>
<ul>
<li><a href="#observable-example">Observable example</a></li>
</ul></li>
<li><a href="#flatmap">flatMap</a></li>
<li><a href="#merge">Merge</a></li>
<li><a href="#concat">Concat</a></li>
<li><a href="#earthquakes-example">Earthquakes example</a>
<ul>
<li><a href="#group-by">group by</a></li>
</ul></li>
<li><a href="#subscription">Subscription</a></li>
<li><a href="#rx-stream">Rx Stream</a>
<ul>
<li><a href="#startwith">startWith</a></li>
<li><a href="#filter">filter</a></li>
<li><a href="#map">map</a></li>
<li><a href="#future-to-observable">Future to Observable</a></li>
<li><a href="#converting-future-to-observable">Converting Future to Observable</a></li>
<li><a href="#notifications">Notifications</a></li>
<li><a href="#blocking">Blocking</a></li>
<li><a href="#observable-to-scalar-types">Observable to Scalar Types</a></li>
<li><a href="#iterable-to-observable">Iterable to Observable</a></li>
</ul></li>
<li><a href="#scheduler">Scheduler</a>
<ul>
<li><a href="#scheduler-to-observable">Scheduler to Observable</a></li>
<li><a href="#range">Range</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>
</div>

              

            </div>
            
    	        <div id="body-inner">
                
                <h1>Reactive Programming 4</h1>
                



<h2 id="observable-rx">Observable, Rx</h2>

<p>지난시간엔 단일 데이터에 대해 <em>latency</em> 를 지원하는 <em>Future, Promise</em> 에 대해서 알아봤다. 이번에는 컬렉션에서 <em>latency</em> 를 지원하는 방법인 <em>Observable</em> 을 배워보자.</p>

<pre><code>                  One           Many
                  
Synchronous     T/Try[T]     Iterable[T]
Asynchronous    Future[T]    Observable[T]
</code></pre>

<h3 id="from-futures-to-observables">From Futures to Observables</h3>

<p><code>Future</code> 의 정의를 다시 보면,</p>

<pre><code class="language-scala">trait Future[T] {
  def onComplete[U](f: Try[T] =&gt; U)
  (implicit ex: ExecutionContext): Unit
}
</code></pre>

<p>여기서 중요한 부분은 콜백 <code>f</code> 를 받아 <code>Unit</code> 을 돌려준다는 것이다.</p>

<pre><code class="language-scala">(Try[T] =&gt; Unit) =&gt; Unit
</code></pre>

<p>이제 <code>=&gt;</code> 를 뒤집고, <code>Unit</code> 을 <code>()</code> 로 표기해서 어떤 <em>intuition</em> 을 얻어보자.</p>

<pre><code class="language-scala">(Try[T] =&gt; Unit) =&gt; Unit
Unit =&gt; (Unit =&gt; Try[T]) // reverse
() =&gt; (()=&gt; Try[T])      // Unit -&gt; ()

Try[T]                   // simplify
</code></pre>

<p>여기서 핵심은 <code>()</code> 는 사이드 이펙트를 위해 존재하므로 그 부분을 제거하면 타<code>Future[T]</code> 의 결과는 <code>Try[T]</code> 와 같다는 것이다.</p>

<blockquote>
<p><code>Future[T]</code> and <code>Try[T]</code> are <strong>dual</strong></p>
</blockquote>

<p><em>duality</em> 란 <a href="http://en.wikipedia.org/wiki/Category_theory">Category Theory</a> 에 의하면</p>

<blockquote>
<p>Every statement, theorem, or definition in category theory has a dual which is essentially obtained by <strong>&ldquo;reversing all the arrows&rdquo;</strong>.</p>
</blockquote>

<p>처음 시작 부분에서 이런 테이블을 봤을텐데, 여기서도 <em>duality</em> 관계가 나타난다.</p>

<pre><code>                  One           Many
                  
Synchronous     T/Try[T]     Iterable[T]
Asynchronous    Future[T]    Observable[T]
</code></pre>

<p>그리고 지난시간에 이메일을 발송하는 코드에서 <code>onComplete</code> 를 몇 번 호출하던 콜백이 받는 <code>Try[T]</code> 는 동일하다는 것을 봤다. 이것은 <code>Future[T]</code> 가 <code>Try[T]</code> 를 돌려주고, 그 값이 일정하다는 사실을 말한다.</p>

<p>이렇게 생각할수도 있다. 콜백 <code>f: Try[T] =&gt; Unit</code> 을 넘기고 <code>Try[T]</code> 를 얻기 위해 <code>asynchronous()</code> 를 사용할 수 있고, <code>Try[T]</code> 를 얻기 전까지 ¸럭되는 <code>synchronous</code> 를 이용할 수도 있다는 식으로</p>

<pre><code class="language-scala">def asynchronous(): Future[T]
def synchronous(): Try[T]
</code></pre>

<h3 id="iterable">Iterable</h3>

<p><code>Observable[T]</code> 를 보기전에 <em>synchronous data stream</em> 인 <code>Iterable[T]</code> 를 좀 살펴보자.</p>

<pre><code class="language-scala">trait Iterable[T] { def iterator(): iterator[T] }
trait Iterator[T] { def hasNext: Boolean; def next(): T }
</code></pre>

<p><code>while (hasNext) next()</code> 처럼 사용할 수 있다.</p>

<p>그리고 <code>Iterable[T]</code> 를 위한 <code>flatMap</code> 도 정의되어 있다. 따라서 <code>Iterable</code> 은 모나드다.</p>

<pre><code class="language-scala">def flatMap[B](f: A =&gt; Iterable[B]): Iterable[B]
</code></pre>

<p>이 <code>Iterator</code> 를 이용해서 디스크에서 파일을 읽는 코드를 작성하면</p>

<pre><code class="language-scala">def ReadLinesFromDisk(path: String): iterator[String] = {
  Source.fromFile(path).getLines()
}

val lines = ReadLinesFromDisk(path)

for (line &lt;- lines) {
  ... DoWork(line) ... // latency
}
</code></pre>

<p>한 라인이 <code>100K</code> 로 어마어마하게 길다면 디스크를 읽기 전까지 기다려야할까? <code>Future</code> 처럼 비동°로 IO 연산을 수행하는 방법을 찾아보자. 이전과 좀 다른점은 지금은 컬렉션을 다루고 있다는 점이다.</p>

<p>이 문제를 해결하기 위해 컬렉션을 순회하는 <code>trait</code> 를 좀 살펴보자. 어떤 일을 해야 하는지 알아야하니까.</p>

<pre><code class="language-scala">trait Iterable[T] {
  def iterator(): Iterator[T]
}

trait Iterator[T] {
  def hasNext: Boolean
  def next(): T
}
</code></pre>

<p><code>Iterable</code>, <code>Iterator</code> 을 좀 간략화 하면,</p>

<ul>
<li><code>Iterable</code> 는 <code>()</code> 를 인자로 받아 <code>Iterator</code> 를 돌려주고</li>
<li><code>Iterator</code> 는 <code>()</code> 를 인자로 받아 <code>Try[Option[T]]</code> 를 돌려준다</li>
</ul>

<p>전체적으로 보면 <code>() =&gt; (() =&gt; Try[Option[T]])</code> 다. 사이드이펙트로 예외를 돌려주거나, <code>None</code> 일수 있거나, 아니면 정상적인 값을 얻을 수 있다는 뜻이다.</p>

<p>타입이 좀 복잡한데, 아까 <em>arrow</em> <code>=&gt;</code> 를 뒤집었던 방법을 다시 사용해서 간단히 만들어 보자. 강의에서는 <em>dualization trick</em> 이라 부른다.</p>

<p>뒤집은 후에는 <code>Try[Option[T]]</code> 를 ¶해해 보자. 예외를 주거나, 아무 값도 주지 않거나(끝나거나), 값을 주거나.</p>

<pre><code class="language-scala">() =&gt; (() =&gt; Try[Option[T]])

// reverse
(Try[Option[T]] =&gt; Unit) =&gt; Unit)

// simplify
( T         =&gt; Unit, // Value
  Throwable =&gt; Unit, // Exception
  ()        =&gt; Unit  // Nothing, Terminate
) =&gt; Unit
</code></pre>

<p>즉, 비동기로 컬렉션을 순회하기 위해서는 이런 작업을 처리해줄 무언가가 필요하다. 스칼라에서는 <code>Observable, Observer, Subscription</code> 이 그 일을 담당한다.</p>

<pre><code class="language-scala">trait Observable[T] {
  def Subscribe(observer: Observer[T]): Subscription
}

trait Observer[T] {
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
  def OnCompleted(): Unit
}

trait Subscription {
  def unsubscribe(): Unit
}
</code></pre>

<p>즉, <code>Observable</code> 에 <code>Try[Option[T]]</code> 에 따라 할일을 지정해 놓은 <code>Observer</code> 를 세팅하고, <code>Subscription</code> 을 얻은 뒤 이후에 필요에 의해 중단해야 하면 <code>unsubscribe</code> 를 호출하는 방식이다. 이는 작업하 대상이 컬렉션이므로 <code>Future</code> 와는 달리, 하나의 값이 아니라 무한한 값들을 얻어올 수 있기 때문.</p>

<h3 id="future-vs-observable">Future vs Observable</h3>

<p>초반에, 이 테이블을 다시 보면 <code>Iterable</code> 과 <code>Observable</code> 이 <em>dual</em> 이다.</p>

<pre><code>                  One           Many
                  
Synchronous     T/Try[T]     Iterable[T]
Asynchronous    Future[T]    Observable[T]
</code></pre>

<p>그리고 이 테이블에 의하면, <code>Future</code> 와 <code>Observable</code> 을 비교해보면 <em>one</em> 과 <em>many</em> 가 의미하는 바를 <em>type</em> 으로 이해할 수 있다.</p>

<pre><code class="language-scala">Observable[T] = (Try[Option[T]] =&gt; Unit) =&gt; Unit
Future[T]     = (Try[T]         =&gt; Unit) =&gt; Unit
</code></pre>

<p>타입을 보면 <code>Future</code> 는 <code>Option</code> 부분이 없지만 <code>Observable</code> 은 있다. 즉 <code>Observable</code> 은 아무런 값도 없다는 사실을 의미하는 타입 <code>Option</code> 을 이용해 <em>종료시점</em> 을 알려줄 수 있기 때문에 <em>multiple values</em> 를 처리할 수 있다.</p>

<p><em>concurrency</em> 측면에선 어떨까? 타입을 살펴보면</p>

<pre><code class="language-scala">object Future {
  def apply[T](body: =&gt; T)
   (implicit executor: ExecutionContext): Future[T]
}

trait Observable[T] {
  def observeOn(scheduler: Scheduler): Observable[T]
}
</code></pre>

<p><code>Observable</code> 의 경우엔 하나의 <code>ExecutionContext</code> 가 아니라 여러개를 가져야 하기 때문에 <code>Scheduler</code> 를 이용한다. 이 부분은 나중에 더 자세히 살펴보자.</p>

<h4 id="observable-example">Observable example</h4>

<pre><code class="language-scala">val ticks: Observable[Long] = Observable.interval(1 seconds)
val evens: Observable[Long] = ticks.filter(s =&gt; s % 2 == 0)
val bufs:  Observable[Seq[Long]] = evens.buffer(2, 1)
val s = bufs.subscribe(b =&gt; println(b))

readLine()
s.unsubscribe
</code></pre>

<p><code>Observable</code> 을 <em>latency</em> 를 지원하는 컬렉션으로 이해하면 쉽다. <code>interval</code>  을 이용해 간격을 지정하거나, 일반 컬렉션처럼 <code>filter</code> 도 사용할 수 있다. <code>evens.buffer</code> 는 그냥 버퍼링이라고 생각하면 된다. 버퍼 크기가 2인 것으로.</p>

<p>이런 것도 가능하다.</p>

<pre><code class="language-scala">val xs = Observable.range(1, 10)
val ys = xs.map(x =&gt; x + 1)
</code></pre>

<p><code>xs</code> 는 비동기 순회를 지원하는 컬렉션이다. <code>filter</code>, <code>map</code>, <code>flatMap</code>, <code>take</code>, <code>zip</code> 등 을 지원한다.</p>

<h3 id="flatmap">flatMap</h3>

<p><img src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/flatMap.png" alt="" />
<p align="center">(<a href="http://reactivex.io/">http://reactivex.io/</a>)</p></p>

<p>색깔의 순서를 봐야할 필요가 있다. <code>Observable</code> 은 비동기 연산이기 때문에 순서가 좀 달라질 수 있다. 구현에도 그런 부분이 나타나 있는데 아래의 코드에서 <code>flatten</code> 이 의미하는 바는 <em>non-deterministic merge</em> 다.</p>

<pre><code class="language-scala">def flatMap(f: T =&gt; Observable[S]): Observable[S] = {
  map(f).flatten()
}
</code></pre>

<p>다른 코드도 좀 보면</p>

<pre><code class="language-scala">val xs: Observable[Int] = Observable(3, 2, 1)

val yss: Observable[Observable[Int]] = 
  xs.map(x =&gt; Observable.Interval(x seconds).map(_ =&gt; x).take(2))
  
val zs: Observalble[Int] = yss.flatten()
</code></pre>

<p><img src="https://camo.githubusercontent.com/1db5afe0637db37bf24a0476deeb4a6af5f846a1/687474703a2f2f692e696d6775722e636f6d2f5a75364f5034442e706e67" alt="" />
<p align="center">(<a href="https://github.com/iirvine">https://github.com/iirvine</a>)</p></p>

<p>위 코드는 <code>x</code> 초 후에 <code>x</code> 2개를 뱉는 <code>Oberservable</code> 을 만든 후 <code>flatten</code> 을 사용해 껍데기를 벗긴다. <code>List(List(1, 2), List(3)).flatten</code> 하면 <code>List(1, 2, 3)</code> 이 되듯이 <code>Observable[Observable].flatten</code> 도 <code>Observable</code> 을 만든다고 생각하면 쉽다.</p>

<h3 id="merge">Merge</h3>

<p><img src="https://camo.githubusercontent.com/7bf59d06b672be32c63b8c2260e68840b408e100/687474703a2f2f692e696d6775722e636f6d2f64376e74576d462e706e67" alt="" />
<p align="center">(<a href="https://github.com/iirvine">https://github.com/iirvine</a>)</p></p>

<p>예외나, 종료 등 어떤 이유에서든지 먼저 끝나는 <code>Observable</code> 에 의해 <code>merge</code> 가 종료된다는 점에 주의하자.</p>

<h3 id="concat">Concat</h3>

<pre><code class="language-scala">val xs: Observable[Int] = Observable(3, 2, 1)

val yss: Observable[Observable[Int]] = 
  xs.map(x =&gt; Observable.Interval(x seconds).map(_ =&gt; x).take(2))
  
val zs: Observalble[Int] = yss.concat
</code></pre>

<p><img src="https://camo.githubusercontent.com/2a578ecf4d5c6890f82ef27a5eb5330e3a613d4c/687474703a2f2f692e696d6775722e636f6d2f4b386a5147316e2e706e67" alt="" />
<p align="center">(<a href="https://github.com/iirvine">https://github.com/iirvine</a>)</p></p>

<p>여기서 재밌는점은 <code>yss</code> 의 첫번째 원소인</p>

<pre><code class="language-scala">Observable.Interval(3 seconds).map(_ =&gt; x).take(2)
</code></pre>

<p>가 끝나기 전까지 다른 원소들이 버퍼링 되므로 주의해야 한다는 점이다. <em>marble diagram</em> 으로 보면</p>

<p><img src="https://camo.githubusercontent.com/126a399bf6587fd5d3a5e23975b3aeb865573269/687474703a2f2f692e696d6775722e636f6d2f62334a6e564d542e706e67" alt="" />
<p align="center">(<a href="https://github.com/iirvine">https://github.com/iirvine</a>)</p></p>

<h3 id="earthquakes-example">Earthquakes example</h3>

<pre><code class="language-scala">def usgs(): Observable[EarthQuake] = { ... }

class EarthQuake {
  ...
  def magnitude: Double
  def location: GeoCoordinate
}

object Magnitude extends Enumeration {
  def apply(magnitude: Double): Magnitude = { ... }
  type Magnitude = Value
  
  val Micro, Minor, Light, Moderate, Strong, Major, Great = Value
}

val major = quakes.
  map(q =&gt; (q.location, Magnitude(q.magnitude))).
  filter { case (loc, mag) =&gt; mag =&gt; Major }
  
major.subscribe({ case (loc, mag) =&gt; 
  println($&quot;Magnitude ${ msg } quake at ${ loc }&quot;)
})
</code></pre>

<p>이런식으로 사용할 수 있다. 더 실제 동작하는 코드는 <a href="https://github.com/headinthebox/CourseraCodeSamplesReactiveProgramming">여기</a>로. 조금 복잡하다.</p>

<p>위치를 <code>GeoCoordinate</code> 로 받기 때문에, 해당 위치의 나라를 돌려준다든지 등으로 개선할 수 있다.</p>

<pre><code class="language-scala">def reverseGeocode(g: GeoCoordinate): Future[Country] = { ... }
</code></pre>

<p>이 함수를 구현하면</p>

<pre><code class="language-scala">val withCountry: Observable[Observable[EarthQuake, Country)]] = 
  usgs().map(q =&gt; {
    val country: Future[Country] = reverseGeocode(q.location)
    Objservable(country.map(country =&gt; (quake, country)))
  })
  
// val merged: Observable[(EarthQuake, Country)] =
//  withCountry.flatten()
val merged: Observable[(EarthQuake, Country)] = withCountry.concat()
</code></pre>

<p>여기서 머징하기 위해 <code>flatten</code> 이나 <code>concat</code> 을 사용할 수 있는데, 언급했듯이 어떤걸 쓰느냐에 따라 순서가 달라질 수 있다. 아래 그¼은 각각 <code>flatten</code>, <code>concat</code> 을 설명한다.</p>

<p><img src="https://camo.githubusercontent.com/d33a97e9d34e395be97256e9993798e4ae24362e/687474703a2f2f692e696d6775722e636f6d2f6258665a5a30532e706e67" alt="" /></p>

<p><img src="https://camo.githubusercontent.com/f8689dc2d0bdd4435a34c5309f54c59b39b85162/687474703a2f2f692e696d6775722e636f6d2f6a3161486e55462e706e67" alt="" />
<p align="center">(<a href="https://github.com/iirvine">https://github.com/iirvine</a>)</p></p>

<h4 id="group-by">group by</h4>

<p><img src="https://camo.githubusercontent.com/f0c975e06586e938d62c8c6c96eac90132cbc591/687474703a2f2f692e696d6775722e636f6d2f6e36543251624b2e706e67" alt="" />
<p align="center">(<a href="https://github.com/iirvine">https://github.com/iirvine</a>)</p></p>

<pre><code class="language-scala">def groupBy[K](keySelector: T =&gt; K): Observable[(K, Observable[T])]
</code></pre>

<p>즉 <code>T</code> 를 받아 키 <code>K</code> 를 만들고, 이것에 따라 <code>Observable</code> 을 그룹짓는다. 이걸 응용하면 나라별로 지진을 취합하는 것이 가능하다.</p>

<pre><code class="language-scala">val byCountry: Observable[(Country, Observable[(EarthQuake, Country)]] = 
  merged.groupBy( case (q, c) =&gt; c }
</code></pre>

<p><img src="https://camo.githubusercontent.com/c5cff5ae933284de2de7ed009c3d4228ea2f1b12/687474703a2f2f692e696d6775722e636f6d2f775852325a4c592e706e67" alt="" />
<p align="center">(<a href="https://github.com/iirvine">https://github.com/iirvine</a>)</p></p>

<p>이제 <code>runningAverage</code> 란 함수가 있다고 해 보자. <code>Observable[Double]</code> 을 받아  업데이트 후 <code>Observable[Double]</code> 을 돌려주는 함수. 그러면 <code>runningAveragePerCountry</code> 는 어떻게 구현할까?</p>

<pre><code class="language-scala">val byCountry: Observable[(Country, Observable[(EarthQuake, Country)]]
def runningAverage(s: Observable[Double]): Observable[Double] = 
  { ... }
val runningAveragePerCountry: Observable[(Country, Observable[Double])] = 
  byCountry.map { case (country, cqs) =&gt; 
    (country, runningAverage(cqs.map(_._1.magnitude))
  }
</code></pre>

<h3 id="subscription">Subscription</h3>

<p>지진 예제를 다시 가져오면, 더이상 관심 없을때 <code>unsubscribe</code> 를 호출할 수 있다.</p>

<pre><code class="language-scala">val quakes: Observable[EarthQuake] = { ... }
val s: Subscription = quakes.Subscribe(...)

s.unsubscribe()
</code></pre>

<p>근데, 생각해보면 여러 곳에서 <em>subscription</em> 할 수 있다. <em>UI</em> °은 경우 그 수가 많을 것이다. 이 경우 <em>unsubscribing</em> 이 <em>cancellation</em> 을 의미하지 않는다. 왜냐하면 다른곳에서 <em>subscribing</em> 하고 있을 수 있기 때문이다.</p>

<p>타입을 좀 보면</p>

<pre><code class="language-scala">trait Subscription {
  def unsubscribe(): Unit
}

object Subscription {
  def apply(unsubscribe: =&gt; Unit): Subscription
}

trait BooleanSubscription extends Subscription {
  def isUnsubscribed: Boolean
}

trait CompositeSubscription extends BooleanSubscription {
  def +=(s: Subscription): this.type
  def -=(s: Subscription): this.type
}

trait MultipleAssignmentSubscription extends BooleanSubscription {
  def subscription: Subscription
  def subscription_=(that: Subscription): this.type
}
</code></pre>

<p>여기서 <code>CompositeSubscription</code> 은 컬렉션처럼 <code>Subscription</code> 을 추가하거나, 제거할 수 있고 <code>unsubscribe</code> 하면 나머지도 모두 취소 된다.</p>

<p><code>MultipleAssignmentSubscription</code> 은 일종의 <em>inner subscription</em> 을 위한 프록시처럼 동작한다. 세팅하고, 교²´할 수 있지만, 항상 내부에는 동작하는 하나의 <code>Subscription</code> 이 있다.</p>

<pre><code class="language-scala">import rx.lang.scala.subscriptions._
import rx.lang.scala.Subscription

val s = Subscription {
  println(&quot;bye, bye&quot;)
}

s.unsubscribe()
s.unsubscribe() // buggy
</code></pre>

<p>이 경우 두번째 <code>unsubscribe()</code> 를 호출했을때 <code>&quot;bye, bye&quot;</code> 가 호출되지 않는다. 먼저 <code>unsubscribe()</code> 를 호출했기 때문이다.</p>

<p>직접 <code>Subscription</code> 을 구현할때는 다수의 스레드에서 저마다 <code>unsubscribe()</code> 를 호출할 수 있기 때문에 이 메소드는 <em>idempotent</em> 하게 구현되야 한다.</p>

<p><code>CompositeSubscription</code> 을 이미 <code>unsubscribe</code> 했을땐, 새로운 <code>Subscription</code> 을 추가한다 하더라도 자동으로 <code>unsubscribe</code> 가 호출된다.</p>

<p><code>MultiAssignmentSubscription</code> 의 경우에는 여러번 할당할 수 있으나, 단 하나의 <code>Subscription</code> 만 가리킨다. 따라서 다음 코드를 실행할 경우 <code>b.unsubscribe</code> 만 호출된다.</p>

<pre><code class="language-scala">val a = Subscription { println(&quot;A&quot;) }
val b = Subscription { println(&quot;B&quot;) }
val m = MultiAssignmentSubscription()

multi.subscription = a
multi.subscription = b
multi.unsubscribe
</code></pre>

<p><code>CompositeSubscription</code> 과 마찬가지로 이미 <code>unsubscribe</code> 되었다면, 할당되는 <code>Subscription</code> 도 자동으로 <code>unsubscribe</code> 된다.</p>

<p><code>CompositeSubscription</code> 이나 <code>MultiAssignment</code> 를 연산을 공유하는 컨테이너라 볼 수 있겠는데, 그럼 여기서 내부의 것만 <code>unsubscribe</code> 하면 어떻게 될까? 당연히 외부의 <code>MultiAssignment</code> 나 <code>Composite</code> 는 알 길이 없으니 <code>isUnsubscribe</code> 는 <code>false</code> 가 된다.</p>

<h3 id="rx-stream">Rx Stream</h3>

<p>자주 보게 될 타입부터 소개하면</p>

<pre><code class="language-scala">object Observable {
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

trait Observable[T] {
  def subscribe(observer: Observer[T]): Subscription
}

trait Observer[T] {
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
  def OnCompleted(): Unit
}

trait Subscription {
  def unsubscribe(): Unit
}
</code></pre>

<p>아무런 알림도 못받는 <code>Observable</code> 을 만드는 <code>never</code> 와, <code>onError</code> 를 호출하는 <code>apply</code> 를 구현해 보자.</p>

<pre><code class="language-scala">def never(): Observable[Nothing] = Observable[Nothing](observer =&gt; {
  Subscription {}
})

def apply[T](error: Throwable): Observable[T] = 
  Observable[T](observer =&gt; {
    observer.onError(error)
    Subscription {}
  }
</code></pre>

<p>이제 이 함수들을 이용해 다양한 함수를 구현해 보자.</p>

<h4 id="startwith">startWith</h4>

<pre><code class="language-scala">object Observable {
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

def switchWith(ss: T*): Observable[T] = {
  Observer[T](observer =&gt; {
    for(s &lt;- ss) observer onNext(s)
    subscribe(observer)
  }
}
</code></pre>

<h4 id="filter">filter</h4>

<p><img src="http://reactivex.io/assets/operators/filter.png" alt="" /></p>

<pre><code class="language-scala">object Observable {
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

def filter(p: T =&gt; Boolean): Observable[T] = {
  Observable[T](observer =&gt; {
    subscribe(
      (t: T) =&gt; { if (p(t)) observer.onNext(t) },
      (e: Throwable) =&gt; { observer.onError(e) },
      () =&gt; { observer.onCompleted() }
    )
  })
}
</code></pre>

<p><br/></p>

<h4 id="map">map</h4>

<p><img src="http://reactivex.io/assets/operators/map.png" alt="" /></p>

<pre><code class="language-scala">object Observable {
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

def map[S](f: T =&gt; S): Observable[S] = {
  Observable[T](observer =&gt; {
    subscribe(
      (t: T) =&gt; { if (p(t)) observer.onNext(f(t)) },
      (e: Throwable) =&gt; { observer.onError(e) },
      () =&gt; { observer.onCompleted() }
    )
  })
}
</code></pre>

<p>그림을 잘 보면 <em>input stream</em> 으로 부터 값을 얻어 함수를 적용하고 <em>output stream</em> 으로 뱉는다. 구현도 마찬가지로 현재의 컨테이너인 <code>Observable</code> 로 부터 값을 얻었을때 함수를 적용하고 어떻게 넘겨줄지를 정의한다.</p>

<p><em>duality</em> 관계인 <code>Iterable</code> 의 <code>map</code> 구현을 보면 더 명확히 알 수 있다.</p>

<pre><code class="language-scala">def map[S](f: T =&gt; S): Iterable[S] = {
  new Iterable[S] {
    val it = this.iterator()
    def iterator: Iterator[S] = new Iterator[S] {
      def hasNext: Boolean = { it.hasNext }
      def next(): S = { f(it.next()) }
    }
  }
}
</code></pre>

<h4 id="future-to-observable">Future to Observable</h4>

<p><code>Future[T]</code> 를 얻어 <code>Observable[T]</code> 로 바꿔보자. <code>T</code> 를 <code>List[T]</code> 로 바꾸듯이. 그럴려면 <code>Subject</code> 를 알아야 하는데, 이건 지난시간에 배운 <code>Promise</code> 비슷한 역할을 한다.</p>

<pre><code class="language-scala">import scala.concurrent.ExecutionContext.Implicits.global

def race[T](left: Future[T], right: Future[T]): Future[T] = {  
  val p = Promise[T]()

  left  onComplete { p.tryComplete(_) }
  right onComplete { p.tryComplete(_) }

  p.future
}
</code></pre>

<p><code>Promise</code> 로 부터 <code>Future</code> 를 얻고, <code>Future.onComplete</code> 에 콜백을 넘기면, 완료되었을때 <code>Promise.complete</code> 에 의해 호출된다. <code>Promise</code> 는 <code>Future</code> 를 위한 대리자? 프록시쯤으로 볼 수 있다.</p>

<p><code>Observable</code> 과 <code>Subject</code> 도 비슷한 관계다.</p>

<p><img src="https://camo.githubusercontent.com/bf2c5f3f0d9cadd2b62b347d91be4f4024bd5c8d/687474703a2f2f692e696d6775722e636f6d2f4879644b49374c2e706e67" alt="" />
<p align="center">(<a href="https://github.com/iirvine">https://github.com/iirvine</a>)</p></p>

<p>코드로 이해해 보자.</p>

<pre><code class="language-scala">val channel = PublishSubject[Int]()

val a = channel.subscribe(x =&gt; println(&quot;a: &quot; + x))
val b = channel.subscribe(x =&gt; println(&quot;b: &quot; + x))

channel.onNext(42)
a.unsubscribe()

channel.onNext(4711)
channel.onComplete()

val c = channel.subscribe(x =&gt; println(&quot;c: &quot; + x))
channel.onNext(13)
</code></pre>

<p><img src="https://camo.githubusercontent.com/52f18665a6534224028549d548f23833f3abab10/687474703a2f2f692e696d6775722e636f6d2f5671507a6b42372e706e67" alt="" />
<p align="center">(<a href="https://github.com/iirvine">https://github.com/iirvine</a>)</p></p>

<p><code>Subject</code> 는 일종의 채널이라 보면 된다. 위 코드에서 흥미로운 점은 <code>onComplete</code> (<code>!</code> 로 표시) 가 호출 된 뒤에 옵저버 <code>c</code> 를 <code>Subject</code> 에 추가했음에도 <code>c</code> 도 <code>onComplete</code> 가 호출된 것을 알고 있다는 사실이다.</p>

<p><br/></p>

<pre><code class="language-scala">val channel = ReplaySubject[Int]()

val a = channel.subscribe(x =&gt; println(&quot;a: &quot; + x))
val b = channel.subscribe(x =&gt; println(&quot;b: &quot; + x))

channel.onNext(42)
a.unsubscribe()

channel.onNext(4711)
channel.onComplete()

val c = channel.subscribe(x =&gt; println(&quot;c: &quot; + x))
channel.onNext(13)
</code></pre>

<p><img src="https://camo.githubusercontent.com/5a105a4004a31498e930295235501c0963ae7fe0/687474703a2f2f692e696d6775722e636f6d2f577770466d34752e706e67" alt="" /></p>

<p><code>ReplaySubject</code> 의 경우에는 <code>c</code> 에도 모든 데이터를 받는다. 이는 <code>ReplaySubject</code> 가 히스토리를 캐싱하고있기 때문이다.</p>

<p>다양한 종류의 <code>Subject</code> 를 그림으로 보면</p>

<p><img src="https://camo.githubusercontent.com/ee926edb502552b7b50a1858ae4baf601d19b26b/687474703a2f2f692e696d6775722e636f6d2f78424a5874596d2e706e67" alt="" />
<p align="center">(<a href="https://github.com/iirvine">https://github.com/iirvine</a>)</p></p>

<h4 id="converting-future-to-observable">Converting Future to Observable</h4>

<pre><code class="language-scala">object Observable {
  def apply[T](f: Future[T]): Observable[T] = {
    val as = AsyncSubject[T]()
    
    f onComplete {
      case Failure(e) =&gt; { as.onError(e) }
      case Success(c) =&gt; { as.onNext(c); as.onCompleted() }
    }
    
    as
  }
}
</code></pre>

<p>복잡하게 생각하지 말고 그냥 <code>Promise</code> 랑 비슷한 일을 한다고 이해면 쉽다.</p>

<h4 id="notifications">Notifications</h4>

<p>지난 시간에 <code>Future</code> 가 <code>Try</code> 를 이용하는걸 봤다. <code>Future[Try[T]</code> 처럼.  <code>Notification</code> 도 이와 비슷하다. <code>Observable[Notification[T]]</code> 처럼 사용한다.</p>

<pre><code class="language-scala">abstract class Try[+T]
case class Success[T](elem: T) extends Try[T]
case class Failure(t: Throwable) extends Try[Nothing]

abstract class Notification[+T]
case class OnNext[T](elem: T) extends Notification[T]
case class OnError(t: Throwable) extends Notification[Nothing]
case object onCompleted extends Notification[Nothing]

def materialize: Observable[Notification[T]] = { ... }
</code></pre>

<p>차이라면, <em>종료</em> 를 알려주는 <code>onCompleted</code> 가 있다는 것이다. <code>materialize</code> 는 <code>Observable[T]</code> 를 감싸 <code>Observable[Notification[T]]</code> 로 만든다.</p>

<p><img src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/materialize.png" alt="" /></p>

<h4 id="blocking">Blocking</h4>

<p>권할만한 방법은 아니지만, 만약에, 만약에 블러킹이 필요하다면 이런식으로 코드를 작성할 수도 있다는 것 지난시간에 배웠다.</p>

<pre><code class="language-scala">val f: Future[String] = { ... }
val text: String = Await.result(f, 10 seconds)
</code></pre>

<p><code>Observable</code> 도 마찬가지다.</p>

<p><img src="https://camo.githubusercontent.com/f71128934e19a648745cd6d02664cdc887b55db6/687474703a2f2f692e696d6775722e636f6d2f66683745746f692e706e67" alt="" /></p>

<pre><code class="language-scala">val xs: Observable[Long] = Observable.interval(1 seconds).take(5)
val ys: List[Long] = xs.toBlockingObservable.toList

println(ys)

// all Rx operators are non-blocking
val zs: Observable[Long] = xs.sum
val s: Long = zs.toBlockingObservable.single
</code></pre>

<h4 id="observable-to-scalar-types">Observable to Scalar Types</h4>

<p><code>Observable</code> 내에 있는 값들을 계산하기 위해 <code>reduce</code> 를 사용할 수 있다. <code>fold</code> 와 비슷하달까</p>

<p><img src="https://camo.githubusercontent.com/c2f1c7ca45a71649a8f64c515c282835ef543b1d/687474703a2f2f692e696d6775722e636f6d2f5130636a64395a2e706e67" alt="" /></p>

<pre><code class="language-scala">def reduce(f: (T, T) =&gt; T): Observable[T]
</code></pre>

<p>재밌는 사실은 리턴타입이 원소가 <code>Observable</code> 을 돌려주기 때문에 <code>Future</code> 와 비슷다는 것이다.</p>

<h4 id="iterable-to-observable">Iterable to Observable</h4>

<p>잘못된 구현을 먼저 보자.</p>

<pre><code class="language-scala">def from[T](seq: Iterable[T]): Observable[T] = 
  Observable(o =&gt; {
    seq.foreach(s =&gt; o.onNext(s)) // What if seq is infinite?
    o.onCompleted // What if seq fails?
    Subscription {}
  })
</code></pre>

<p>이 구현의 문제점은, <code>Iterable</code> 이 무한하거나, 실패하면 어떻게 처리할지 전혀 고려하지 않았다는 것이다. 게다가 빈 <code>Subscription</code> 을 돌려주기 때문에, <code>unsubscribe</code> 할 수도 없다.</p>

<p>이 문제를 풀기 위해서는 <em>scheduler</em> 가 필요하다.</p>

<h3 id="scheduler">Scheduler</h3>

<p>우선 돌아가는 코드를 만들기 전에 테스트 케이스부터 작성하자</p>

<pre><code class="language-scala">// factory method
object Observable {
  def apply[T](subscribe: Observer[T] =&gt; Subscription): Observable[T]
}

def from[T](seq: Iterable[T]): Observable[T] = { ... }

// infinite seq
def nats(): Iterable[Int] = new Iterable[Int] {
  val i = -1
  def iterator: Iterator[Int] = new Itertor[Int] {
    def hasNext: Boolean = { true }
    def next(): Int = { i += 1; i }
  }
}

val infinite: Iterable[Int] = nats()
val subscription = from(infinite).subscribe(x =&gt; println(x))

subscription.unsubscribe()
</code></pre>

<p>만약 <code>from</code> 이 위에서 본 것처럼 구현되어 있다면 <code>subscription.unsubscribe()</code> 에 도달하지 못한다. 따라서 <em>iteration</em> 을 진행하는 것과는 다른 컨텍스트를 도입해 <code>unsubscribe</code> 를 호출해야 한다. 그래서 스케쥴러가 필요하다.</p>

<p><code>Future</code> 에서는 <code>ExecutionContext</code> 가 있었지만, <code>Observable</code> 은 복수개의 컨텍스트를 조작해야 하므로 스케쥴러를 써야한다.</p>

<pre><code class="language-scala">object Future[
  def apply[T](body: =&gt; T)
   (implicit executor: ExecutionContext): Future[T]
}

trait Observable[T] {
  def observeOn(scheduler: Scheduler): Observable[T]
}

// Runnable == Java's Runnable
trait ExecutionContext {
  def execute(runnable: Runnable): Unit
}

// '=&gt; Unit' == Runnable
trait Scheduler {
  def schedule(work: =&gt; Unit) Subsciption
}

// example
val scheduler = Scheduler.newThreadScheduler
val subscription = scheduler.schedule {
  println(&quot;Hello World!&quot;)
}
</code></pre>

<p><code>Future</code> 는 <code>Runnable</code> 을 취소할 수 있는 방법이 없지만, <code>Scheduler</code> 는 <code>Subscription</code> 을 리턴하기 때문에 취소할 수 있다. 그러나 일단 작업이 시작되면 취소할 수 있는 방법은 없다. 아래 예제를 보자</p>

<pre><code class="language-scala">def from[T](seq: Iterable[T])
    (implicit s: Scheduler): Observable[T] = {
   
  Observable[T](o =&gt; {
    s.schedule {
      seq.foreach(x =&gt; observer.onNext(x))
      observer.onCompleted()
    }
  }
}
</code></pre>

<p><code>onNext</code> 가 호출되기 전, 아주 잠깐동안만 작업을 취소할 수 있는 기회가 있다. 다시 말해서, 이터레이션이 통채로 스케쥴링 되기 때문에 좀 별로라는 것이다. 매 이터레이션마다 취소할 기회가 있는 <code>from</code> 을 구현하고 싶다.</p>

<p><code>scheduler</code> 의 다른 시그니쳐를 좀 보자.</p>

<pre><code class="language-scala">trait Scheduler {
  def schedule(work: =&gt; Unit): Subscription
  
  def schedule(work: Scheduler =&gt; Subscription): Subscription
  
  def schedule(work: (=&gt; Unit) =&gt; Unit): Subscription
}
</code></pre>

<p>두번째 시그니쳐를 보자. <code>schedule</code> 함수가 하는 일이 <code>Scheduler</code> 를 받아 등록하고 <code>Subscription</code> 을 돌려주는 일이라면 그것 자체를 <code>work</code> 로 받고, 해당 <code>work</code> 에서 한번씩만 이터레이션 한다면 매 이터레이션에서 취소할 기회를 가질 수 있다.</p>

<p>이건 사실 세번째 시그니쳐와 동일한데 이유는 뒤에서 보겠다.</p>

<p><code>from</code> 의 새로운 구현을 보면</p>

<pre><code class="language-scala">def from[T](seq: Iterable[T])
    (implicit) scheduler: Scheduler): Observable[T] = {
    
  Observable[T](o =&gt; {
    val it = seq.iterator()
    
    scheduler.schedule(self =&gt; {
      if (it.hasNext) { o.onNext(it.next()); self() }
      else { o.onCompleted() }
    }
  }
}
</code></pre>

<p><del>으사양반 이게 무슨 개소리요!</del></p>

<p>조금 난해한데, <code>it.hasNext</code> 가 있어서 다음 이터레이션으로 넘어갈 수 있으면 <code>self()</code> 를 호출해 자기 자신을 스케쥴링다. 따라서 매 이터레이션마다 사용 가능한 <code>Subscription</code> 이 있으므로 취소할 수 있는 기회가 생긴다.</p>

<p><img src="https://camo.githubusercontent.com/216556caf19e30587d4697466b4244b33f182f76/687474703a2f2f692e696d6775722e636f6d2f78683546576a382e706e67" alt="" /></p>

<p>물론 <code>Subscription</code> 이 갱신되는데 어떻게 하나의 레퍼런스로 그게 가능하느냐 하는 질문이 나올 수 있는데, 우리는 이미 <code>MultipleAssignmentSubscription</code> 을 배웠다. <code>schedule</code> 함수의 내부를 보자.</p>

<pre><code class="language-scala">def schedule(work: (=&gt; Unit) =&gt; Unit): Subscription = {
  val subs = new MultipleAssignmentSubscription()
  
  schedule(scheduler =&gt; {
    def loop(): Unit = {
      subs.Subscription = scheduler.schedule {
        work { loop() }
      }
    }
    
    loop()
    subs
  })
  
  subs
}

def from[T](seq: Iterable[T])
    (implicit) scheduler: Scheduler): Observable[T] = {
    
  Observable[T](o =&gt; {
    val it = seq.iterator()
    
    scheduler.schedule(self =&gt; {
      if (it.hasNext) { o.onNext(it.next()); self() }
      else { o.onCompleted() }
    }
  }
}
</code></pre>

<p>즉, <code>self</code> 가 바로 <code>loop</code> 다. 자기 자신을 스케쥴링하는 함수인데,
<code>work -&gt; loop -&gt; work -&gt; loop -&gt; ...</code> 을 반복하면서 더 이터레이션할 멤버가 없거나, <code>unsubscribe</code> 하기 전까지 재귀적으로 돈다.</p>

<h4 id="scheduler-to-observable">Scheduler to Observable</h4>

<p>돌려주는 값 없이 행위 그 자체만 보면, 스케쥴러 그 자체는 <code>Observable[Unit]</code> 에 대응된다.</p>

<pre><code class="language-scala">object Observable {
  def apply() (implicit s: Scheduler): Observable[Unit] = {
    Observable(o =&gt; {
      s.schedule(self =&gt; {
        o.onNext(()); self
      })
    })
  }
}

implicit val s = Scheduler.NewThreadScheduler
val ticks: Observable[Unit] = Observable()
</code></pre>

<p>이게 실제로 어떻게 동작하나 보면</p>

<pre><code class="language-scala">object Observable {
  def apply(s: Observer[T] =&gt; Subscription) = new Observable[T] {
    def subscribe(o: Observer[T]): Subscription = { Magic(s(o)) }
  }
}

val subs = Observable(o =&gt; F(o)).subscribe(observer)

// = conceptually
val subs = Magic(F(observer))
</code></pre>

<p>여기서 <code>F</code> 나 <code>Magic</code> 는 임의의 함수라 생각하면 된다. (그런게 있나보다 하자.)</p>

<p>이걸 왜 이야기하냐 하면 <em>auto unsubscribe</em> 가 가능하기 때문이다. 스케쥴링 하는 행위를 <em>observable</em> 로 변경할 수 있다면, 스케쥴링이 불가능할때 <em>unsubscribe</em> 하도록 만드는 것이다.</p>

<p><code>F</code> 가 <code>observer.onCompleted</code> 나 <code>observer.OnError</code> 를 호출한다면, <code>Magic</code> 함수에 의해 자동으로 <code>unsubscribe</code> 가 호출된다. 이로인해 다음에 호출되는 <code>onNext</code> 는 아무런 영향도 미치지 않게 된다.</p>

<p>이럴 수 있는 이유는 <code>Observable</code> 을 생성하는 방식이 <em>Rx Contract</em> 을 만족하기 때문이다. (따라서 직접 <code>Observable, Observer</code> 를 만들지 말고 팩토리 메소드를 사용해야한다)</p>

<pre><code class="language-scala">(onNext)*(onCompleted + onError)?
</code></pre>

<p><code>onNext</code> 는 여러번 호출될 수 있으나 겹치지 않고, <code>onCompleted</code> 나 <code>OnError</code> 는 옵션이지만 (무한한 시퀀스가 존재하기때문) 호출된다면 둘 중 단 한개만, 단 한번 호출되야한다는 것이다. 아까 본 코드를 다시 나열해서 어떻게 그렇게 되나 살펴보자.</p>

<pre><code class="language-scala">object Observable {
  def apply() (implicit s: Scheduler): Observable[Unit] = {
    Observable(o =&gt; {
      s.schedule(self =&gt; {
        o.onNext(()); self
      })
    })
  }
}

def schedule(work: (=&gt; Unit) =&gt; Unit): Subscription = {
  val subs = new MultipleAssignmentSubscription()
  
  schedule(scheduler =&gt; {
    def loop(): Unit = {
      subs.Subscription = scheduler.schedule {
        work { loop() }
      }
    }
    
    loop()
    subs
  })
  
  subs
}


implicit val s = Scheduler.NewThreadScheduler
val ticks: Observable[Unit] = Observable()

ticks.subscribe(observer)
</code></pre>

<p>여기서 <code>ticks.subscribe(observer)</code> 를 계속 풀면</p>

<pre><code class="language-scala">Observable({ o =&gt; scheduler.schedule {
  self =&gt; o.onNext(()); self()
}}).subscribe(observer)

// unfold create
scheduler.schedule {
  self =&gt; observer.onNext(()); self()
}

// unfold schedule
val m = new MultipleAssignmentSubscription()

schedule(scheduler =&gt; {
  def loop(): Unit = {
    m.Subscription = scheduler.schedule {
      { self =&gt; observer.onNext(()); self() }({ loop() })
    }
  }
  
  loop()
  m
})

// `self` is a continuation
val m = new MultipleAssignmentSubscription()

schedule(scheduler =&gt; {
  def loop(): Unit = {
    m.Subscription = scheduler.schedule {
      { observer.onNext(()); loop() }
    }
  }
  
  loop()
  m
})

// extract loop
val m = new MultipleAssignmentSubscription()

def loop(): Unit = {
    m.Subscription = scheduler.schedule {
      { observer.onNext(()); loop() }
    }
}

schedule(scheduler =&gt; {
  loop()
  m
})

// apply loop
schedule(scheduler =&gt; {
  m.Subscription = scheduler.schedule {
      { observer.onNext(()); loop() }
  }
    
  m
})
</code></pre>

<p>즉 매 스케쥴링마다, <em>subscription</em> 을 갱신하고, 작업을 진행한뒤, 자기 자신을 다시 스케쥴링 한다.</p>

<h4 id="range">Range</h4>

<p>이렇게 응용할 수 있다.</p>

<pre><code class="language-scala">implicit val scheduler: Scheduler = Scheduler.NewThreadScheduler

def range(start, Int, count: Int): 
  (implicit s: Scheduler) Observable[Int] = {
  
  Observable(o =&gt; {
    var i = 0
    Observable().subscribe(u =&gt; {
      if (i &lt; count) { o.onNext(start + i); i += 1 }
      else { o.onCompleted() }
    })
  })
}

val xs = range(1, 10)
    xs.subscribe(x =&gt; println(x))
    println(&quot;range out&quot;)
</code></pre>

<p>즉 <code>Observable()</code> 은 일종의 무한히 반복되는 스케쥴러고 여기에 액션을 추가해 원하는 작업을 해낼 수 있다. 그리고 작업이 완료되면 자동으로 <em>unsubscribe</em> 를 수행한다. 이제 무한히 긴 스트림을 <code>Observable</code> 로도 다룰 수 있게 되었다.</p>

<h3 id="references">References</h3>

<p>(1) <em>Reactive Programming</em> by <strong>Martin Ordersky</strong><br />
(2) <a href="http://reactivex.io/">http://reactivex.io/</a><br />
(3) <a href="https://github.com/iirvine/principles-of-reactive-programming/blob/master/notes/week-4/002-basic-combinators-on-observable-collections.md">https://github.com/iirvine</a></p>

<br/>
<br/>
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = '1ambda';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


      
      </div>
    </div>

    <div id="navigation">
        <a class="nav nav-prev" href="../reactive-programming-3"> <i class="fa fa-chevron-left"></i></a>
        <a class="nav nav-next" href="../reactive-programming-5" style="margin-right: 0px;"><i class="fa fa-chevron-right"></i></a>
    </div>

    </section>
    <div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
      <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
    </div>
    <script src="https://1ambda.github.io/js/jquery-2.x.min.js"></script>
    <script src="https://1ambda.github.io/js/clipboard.min.js"></script>
    <script src="https://1ambda.github.io/js/perfect-scrollbar.min.js"></script>
    <script src="https://1ambda.github.io/js/perfect-scrollbar.jquery.min.js"></script>
    <script src="https://1ambda.github.io/js/jquery.sticky-kit.min.js"></script>
    <script src="https://1ambda.github.io/js/featherlight.min.js"></script>
    <script src="https://1ambda.github.io/js/html5shiv-printshiv.min.js"></script>
    <script src="https://1ambda.github.io/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="https://1ambda.github.io/js/modernizr.custom.71422.js"></script>
    <script src="https://1ambda.github.io/js/learn.js"></script>
    <script src="https://1ambda.github.io/js/hugo-learn.js"></script>
    
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-52181619-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>


  </body>
</html>


