<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>21s on Old Lisper</title>
    <link>https://1ambda.github.io/21/</link>
    <description>Recent content in 21s on Old Lisper</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Sat, 25 Jun 2016 00:01:56 +0900</lastBuildDate>
    <atom:link href="https://1ambda.github.io/21/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Scala</title>
      <link>https://1ambda.github.io/21/scala/</link>
      <pubDate>Sat, 25 Jun 2016 00:01:56 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/</guid>
      <description>

&lt;h1 id=&#34;scala&#34;&gt;Scala&lt;/h1&gt;

&lt;h2 id=&#34;easy-scalaz&#34;&gt;Easy Scalaz&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;easy-scalaz-1&#34;&gt;Easy Scalaz 1&lt;/a&gt; - State&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;easy-scalaz-2&#34;&gt;Easy Scalaz 2&lt;/a&gt; - Monad Transformer&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;easy-scalaz-3&#34;&gt;Easy Scalaz 3&lt;/a&gt; - ReaderWriterState with Kleisli&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;easy-scalaz-4&#34;&gt;Easy Scalaz 4&lt;/a&gt; - (Co)Yoneda, Free, Trampoline&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;easy-scalaz-5&#34;&gt;Easy Scalaz 5&lt;/a&gt; - Playing with Monoids&lt;/li&gt;
&lt;li&gt;[Easy Scalaz 7] - Stream (TODO)&lt;/li&gt;
&lt;li&gt;[Easy Scalaz 6] - ST, IO (TOOD)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;functional-programming-in-scala&#34;&gt;Functional Programming in Scala&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;functional-programming-1&#34;&gt;Chapter 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;functional-programming-2&#34;&gt;Chapter 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;functional-programming-3&#34;&gt;Chapter 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;functional-programming-4&#34;&gt;Chapter 4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;functional-programming-5&#34;&gt;Chapter 5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;functional-programming-6&#34;&gt;Chapter 6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;functional-programming-7&#34;&gt;Chapter 7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reactive-programming-in-scala&#34;&gt;Reactive Programming in Scala&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;reactive-programming-1&#34;&gt;Chapter 1&lt;/a&gt; - Monads, Random Generators&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;reactive-programming-2&#34;&gt;Chapter 2&lt;/a&gt; - Stateful Object&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;reactive-programming-3&#34;&gt;Chapter 3&lt;/a&gt; - Try, Future, Promise&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;reactive-programming-4&#34;&gt;Chapter 4&lt;/a&gt; - Observable, Rx, Scheduler&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;reactive-programming-5&#34;&gt;Chapter 5&lt;/a&gt; - Actor&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;concurrent-programming-in-scala&#34;&gt;Concurrent Programming in Scala&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.amazon.com/Learning-Concurrent-Programming-Aleksandar-Prokopec/dp/1783281413/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1433256276&amp;amp;sr=1-1&amp;amp;keywords=concurrent+programming+in+scala&#34;&gt;Ref - Concurrent Programming in Scala&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/1ambda/scala/tree/master/concurrent-programming-in-scala/src/main/scala/thread&#34;&gt;Chapter2 (external)&lt;/a&gt; - Thread, Volatile, JMM&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/1ambda/scala/tree/master/concurrent-programming-in-scala/src/main/scala/forkjoin&#34;&gt;Chapter3 (external)&lt;/a&gt; - Fork-Join Framework, Lock-Free Programming, Lazy Values, Concurrent Collections&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/1ambda/scala/tree/master/concurrent-programming-in-scala/src/main/scala/future&#34;&gt;Chapter4 (external)&lt;/a&gt; - Future, Async&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/1ambda/scala/tree/master/concurrent-programming-in-scala/src/main/scala/parallel&#34;&gt;Chapter5 (external)&lt;/a&gt; - Parallel Collection&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/1ambda/scala/tree/master/concurrent-programming-in-scala/src/main/scala/reactive&#34;&gt;Chapter6 (external)&lt;/a&gt; - Rx&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/1ambda/scala/tree/master/concurrent-programming-in-scala/src/main/scala/stm&#34;&gt;Chapter7 (external)&lt;/a&gt; - STM&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Easy Scalaz 1</title>
      <link>https://1ambda.github.io/21/scala/easy-scalaz-1/</link>
      <pubDate>Wed, 06 Jan 2016 00:37:23 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/easy-scalaz-1/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;about-type-classes&#34;&gt;About Type Classes&lt;/h2&gt;

&lt;p&gt;프로그래머가 하는 행위를 극도로 단순화해서 표현하면 &lt;strong&gt;저수준&lt;/strong&gt; 의 데이터를 &lt;strong&gt;고수준&lt;/strong&gt; 데이터로 변환하는 일입니다.&lt;/p&gt;

&lt;p&gt;여기서 저수준이란, &lt;em&gt;Stream&lt;/em&gt;, &lt;em&gt;Byte&lt;/em&gt;, &lt;em&gt;JSON&lt;/em&gt;, &lt;em&gt;String&lt;/em&gt; 등 현실세계의 데이터를, 고수준이라 함은 비즈니스 로직, 제약조건 등이 추가된 도메인 객체, 모델 등 데이터를 말합니다.&lt;/p&gt;

&lt;p&gt;이로 인해&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;저수준을 고수준으로 변환하는건 조건이 충족되지 않은 데이터와 연산 과정에서 일어나는 시스템 오류를 처리해야하기 때문에 힘든일입니다&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;갖은 고생 끝에 데이터를 고수준으로 끌어올린 뒤에야, 그 데이터를 프로그래머 자신의 세상에서 마음껏 주무를 수 있습니다&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;프로그래머가 작업을 끝낼 시점이 되면, 데이터를 저수준으로 변환해서 저장 또는 전송해야 하는데, 이미 제약조건이 충족 되었기 때문에 이는 손쉬운 일입니다&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;따라서 핵심은 다음의 두가지 입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;쉽게 고수준으로 변환할 수 있는가 (&lt;strong&gt;연산&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;변환된 고수준 데이터가 얼마나 다루기 편한가 (&lt;strong&gt;추상&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로그래머가 &lt;em&gt;적절한 연산&lt;/em&gt; 을 선택하면 힘들이지 않고 변환을 해낼것이고, &lt;em&gt;적절한 추상 (혹은 모델링)&lt;/em&gt; 을 한다면 직관적인 코드로 데이터를 주무를 수 있게 되는데, 이 것을 도와주는 것이 바로 &lt;strong&gt;타입 클래스&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;타입 클래스를 이용하면,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if null&lt;/code&gt;  을 Option 으로,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S =&amp;gt; (S, A)&lt;/code&gt; 을 State[S, A] 로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if if if&lt;/code&gt; 를 Applicative 로&lt;/li&gt;
&lt;li&gt;&lt;em&gt;fail-slow&lt;/em&gt;, &lt;em&gt;fail-fast&lt;/em&gt; 로직은 ValidationNel 과 Either 로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F[G[A]]&lt;/code&gt; 을 &lt;code&gt;G[F[A]]&lt;/code&gt; 로의 변경은 Traversal 로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setC{applyB{getA}}&lt;/code&gt; 를 getA &amp;gt; applyB &amp;gt; setC 로(Kleisli)
표기할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 연산을 각각의 타입으로 표시하기 때문에 로직을 파악하고, 분 하기 쉽습니다. 그리고 연산을 작성하는 과정이 타입을 조합하는 과정과 동일하기 때문에 컴파일러의 도움을 받을수 있구요.&lt;/p&gt;

&lt;p&gt;타입클래스는 &lt;strong&gt;연산이 어떠해야 하는지&lt;/strong&gt; 를 다루기 때문에 연산을 조합할 수 있는 다양한 함수들이 포함되어 있습니다. 이것을 이용하면 직관적인 방식으로 데이터를 다룰 수 있는데, 예를 들어 다음은 코드 실행과정에서 예외 발생 시에만 롤백을 수행하고, 예외를 돌려주는 코드입니다. (간략화 하였습니다.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;\/.fromTryCatch {
  val result = runQuery;
  commit;
  result
} leftMap(err =&amp;gt; rollback; err};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 &lt;code&gt;if null&lt;/code&gt;  보다  &lt;code&gt;Option&lt;/code&gt; 을 쓰는것이 더 편하고 익숙하다면, &lt;code&gt;Applicative&lt;/code&gt; 부터 천천히 시작해보는건 어떨까요?&lt;/p&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.haskell.org/Typeclassopedia&#34;&gt;Typeclassopedia Image - Haskell Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Easy Scalaz 2</title>
      <link>https://1ambda.github.io/21/scala/easy-scalaz-2/</link>
      <pubDate>Tue, 05 Jan 2016 00:16:24 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/easy-scalaz-2/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;state-monad&#34;&gt;State Monad&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;State&lt;/code&gt; 를 설명하는 수많은 문구들이 있지만, 타입만큼 간단한건 없습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;State[S, A] :: S =&amp;gt; (S, A)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;A state transition, representing a &lt;strong&gt;function&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉 &lt;code&gt;S&lt;/code&gt; 를 받아 &lt;code&gt;(S, A)&lt;/code&gt; 를 돌려주는 함수를, 타입클래스 &lt;code&gt;State[S, A]&lt;/code&gt; 로 표현합니다.&lt;/p&gt;

&lt;p&gt;더 엄밀히는, (&lt;em&gt;scalaz&lt;/em&gt;  구현에서는) &lt;code&gt;type State[S, A] = StateT[Id, S, A] where Id[+X] = X&lt;/code&gt; 인데 이것은 나중에 &lt;code&gt;StateT&lt;/code&gt; 에서 다시 보겠습니다.&lt;/p&gt;

&lt;p&gt;우선 기억해둘 것은 &lt;code&gt;State&lt;/code&gt; 가 &lt;strong&gt;함수&lt;/strong&gt; 를 나타낸다는 사실입니다. 상태 &lt;code&gt;S&lt;/code&gt; 를 변경하면서 &lt;code&gt;A&lt;/code&gt; 를 만들어내는 함수를 말이지요. 즉, &lt;code&gt;State&lt;/code&gt; 는 더도 말고 덜도 말고, 상태를 조작하는 &lt;strong&gt;함수&lt;/strong&gt; 입니다. 여기에 모나드라고 하니, &lt;code&gt;flatMap&lt;/code&gt; 같은 몇몇 함수가 추가된 것 뿐이지요.&lt;/p&gt;

&lt;h3 id=&#34;state-basics&#34;&gt;State Basics&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;State&lt;/code&gt; 코드를 들춰보면, 아래와 같이 생겼습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object State extends StateFunctions {
  def apply[S, A](f: S =&amp;gt; (S, A)): State[S, A] = new StateT[Id, S, A] {
    def apply(s: S) = f(s)
  }
}

trait StateFunctions extends IndexedStateFunctions {
  def constantState[S, A](a: A, s: =&amp;gt; S): State[S, A] = State((_: S) =&amp;gt; (s, a))
  def state[S, A](a: A): State[S, A] = State((_ : S, a))
  def init[S]: State[S, S] = State(s =&amp;gt; (s, s))
  def get[S]: State[S, S] = init
  def gets[S, T](f: S =&amp;gt; T): State[S, T] = State(s =&amp;gt; (s, f(s)))
  def put[S](s: S): State[S, Unit] = State(_ =&amp;gt; (s, ()))
  def modify[S](f: S =&amp;gt; S): State[S, Unit] = State(s =&amp;gt; {
    val r = f(s);
    (r, ())
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;State.apply&lt;/code&gt; 에 상태 &lt;code&gt;S&lt;/code&gt; 를 조작하는 함수 &lt;code&gt;f&lt;/code&gt; 를 먹이면 &lt;code&gt;StateT&lt;/code&gt; 가 나오고&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StateT.apply&lt;/code&gt; 에 초기 상태 &lt;code&gt;S&lt;/code&gt; 를 먹이면 최종 결과물인 &lt;code&gt;(S, A)&lt;/code&gt; 가 나옵니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 코드를 조금 만 더 따라가다 보면 &lt;code&gt;apply&lt;/code&gt; 의 &lt;em&gt;alias&lt;/em&gt; 로 &lt;code&gt;run&lt;/code&gt; 이라는 함수가 제공되는걸 알 수 있습니다. &lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/StateT.scala#L10&#34;&gt;(Scalaz StateT.scala #L10)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;flatMap&lt;/code&gt; 으로 상태 조작함수 &lt;code&gt;f&lt;/code&gt; 여러개를 엮다가 하다가 마지막에 &lt;code&gt;run&lt;/code&gt; 으로 실행시킬것 같다는 느낌이 들죠?&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;StateFunctions&lt;/code&gt; &lt;em&gt;trait&lt;/em&gt; 로 제공되는 함수를 사용해 볼까요? 그냥 써보면 재미 없으니, Github 에서 각 Repository 마다 존재하는 &lt;em&gt;star&lt;/em&gt; 를 가져오는 것을 간단히 모델링 해보겠습니다. 매번 네트워크 요청을 통해 가져오면 느리니까, &lt;code&gt;Map[String, Int]&lt;/code&gt; 타입의 캐시도 포함시켜서요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scalaz._, Scalaz._ /* import all */

type Cache = Map[String, Int]

&amp;quot;create, run State&amp;quot; in {
  val s: State[Cache, Int] = State { c =&amp;gt; (c, c.getOrElse(&amp;quot;1ambda/scala&amp;quot;, 0))}
  val c: Cache = Map(&amp;quot;1ambda/scala&amp;quot; -&amp;gt; 1)

  // def run(s: S): (S, A)
  val (c1, star1) = s.run(c)
  val (c2, star2) = s.run(Map.empty)

  (c1, star1) shouldBe (Map(&amp;quot;1ambda/scala&amp;quot; -&amp;gt; 1), 1)
  (c2, star2) shouldBe (Map(), 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 작은 코드에서 우리가 다루는 상태는 &lt;code&gt;Cache&lt;/code&gt; 입니다. 아직은 &lt;code&gt;State { c =&amp;gt; ... }&lt;/code&gt; 에서 받은 &lt;code&gt;c: Cache&lt;/code&gt; 를 수정하지 않기 때문에 &lt;code&gt;run&lt;/code&gt; 에서 돌려주는 상태 (&lt;em&gt;State&lt;/em&gt;) 는 &lt;code&gt;run&lt;/code&gt; 에 넘긴 것과 동일합니다. 그런고로 &lt;code&gt;c == c1 == c2&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;이번엔 상태를 변경하는 함수를 만들어 보겠습니다. 캐시에서 데이터를 가져오면, 캐시를 그대로 돌려주고 미스가 발생하면 캐시에 레포지토리 URL 을 추가하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def getStargazer(url: String): State[Cache, Int] = State { c =&amp;gt;
  c.get(url) match {
    case Some(count) =&amp;gt; (c, count)
    case None        =&amp;gt; (c.updated(url, 0), 0)
  }
}

&amp;quot;getStargazer&amp;quot; in {
  val c: Cache = Map(&amp;quot;1ambda/scala&amp;quot; -&amp;gt; 1)

  val s1 = getStargazer(&amp;quot;1ambda/haskell&amp;quot;)
  val (c1, star) = s1.run(c)

  (c1, star) shouldBe (c.updated(&amp;quot;1ambda/haskell&amp;quot;, 0), 0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;State&lt;/code&gt; 는 모나드기 때문에, &lt;code&gt;for&lt;/code&gt; 내에서 이용할 수 있습니다. 아래에서 더 자세히 살펴³´겠습니다.&lt;/p&gt;

&lt;h3 id=&#34;state-monad-applicative-and-functor&#34;&gt;State Monad, Applicative and Functor&lt;/h3&gt;

&lt;p&gt;모나드는 &lt;code&gt;return&lt;/code&gt; 과 &lt;code&gt;bind&lt;/code&gt; 를 가지고 특정한 규칙을 만족하는 타입 클래스를 말하는데요, &lt;em&gt;scala&lt;/em&gt; 에서는 &lt;code&gt;bind&lt;/code&gt; 는 &lt;code&gt;flatMap&lt;/code&gt; 이란 이름으로 제공되는 것 아시죠?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Monad[A] {
  // sometimes called `unit`
  def return(a: A): M[A]
  def flatMap[B](f: A =&amp;gt; M[B]): M[B]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;scalaz&lt;/em&gt; 에선 &lt;code&gt;Monad&lt;/code&gt; 는 아래의 두 타입클래스를 상속받아 구현됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Applicative.point&lt;/code&gt; (= &lt;code&gt;return&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bind.bind&lt;/code&gt; (= &lt;code&gt;bind&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Bind[F[_]] extends Apply[F] { self =&amp;gt;
  ...
  def bind[A, B](fa: F[A])(f: A =&amp;gt; F[B]): F[B]
  ...
}

trait Applicative[F[_]] extends Apply[F] { self =&amp;gt;
  ...
  def point[A](a: =&amp;gt; A): F[A]
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;게다가 &lt;code&gt;Apply&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 를 상속받으므로&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Apply[F[_]] extends Functor[F] { self =&amp;gt;
  def ap[A,B](fa: =&amp;gt; F[A])(f: =&amp;gt; F[A =&amp;gt; B]): F[B]
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;scalaz&lt;/em&gt; 에서 &lt;code&gt;State&lt;/code&gt; 는 &lt;code&gt;Functor&lt;/code&gt; 이면서, &lt;code&gt;Applicative&lt;/code&gt; 이고, &lt;code&gt;Monad&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;아래는 &lt;a href=&#34;https://github.com/tpolecat/doobie&#34;&gt;doobie&lt;/a&gt; 를 만든 &lt;a href=&#34;https://github.com/tpolecat&#34;&gt;@tpolecat&lt;/a&gt; 의 블로그에서 가져온 &lt;em&gt;scalaz&lt;/em&gt; 타입 클래스 계층인데, 이 그림을 보면 왜 그런지 알 수 있습니다. (&lt;a href=&#34;http://tpolecat.github.io/assets/scalaz.svg&#34;&gt;http://tpolecat.github.io/assets/scalaz.svg&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/scalaz.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;State&lt;/code&gt; 가 모나드라는 사실을 알았으니, 위에서 작성했던 &lt;code&gt;getStargazer&lt;/code&gt; 함수를 다시 작성해보겠습니다. &lt;em&gt;for comprehension&lt;/em&gt; 을 사용할건데요,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;먼저 &lt;code&gt;State[Cache, Int]&lt;/code&gt; 의 상태인 &lt;code&gt;Cache&lt;/code&gt; 를 얻어와야 하므로 &lt;code&gt;get&lt;/code&gt; 을 이용하고&lt;/li&gt;
&lt;li&gt;상태를 변경해야 하므로 &lt;code&gt;modify&lt;/code&gt; 를 호출하겠습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// State helper functions defined in `StateFunctions` trait
def state[S, A](a: A): State[S, A] = State((_ : S, a))
def init[S]: State[S, S] = State(s =&amp;gt; (s, s)) /* 상태 S 를 아웃풋 A 위치로 꺼냄 */
def get[S]: State[S, S] = init
def gets[S, T](f: S =&amp;gt; T): State[S, T] = State(s =&amp;gt; (s, f(s)))
def put[S](s: S): State[S, Unit] = State(_ =&amp;gt; (s, ()))
def modify[S](f: S =&amp;gt; S): State[S, Unit] = State(s =&amp;gt; {
  /* 상태 S 를 변경하는 함수를 받아, 적용하고 A 위치에 `()` 를 돌려줌 */
  val r = f(s);
  (r, ())
})

def getStargazer(url: String): State[Cache, Int] = State { c =&amp;gt;
  c.get(url) match {
    case Some(count) =&amp;gt; (c, count)
    case None        =&amp;gt; (c.updated(url, 0), 0)
  }
}

def getStargazerWithFor(url: String): State[Cache, Int] =
  for {
    c &amp;lt;- State.get[Cache]
    optCount = c.get(url)
    _ &amp;lt;- modify { c: Cache =&amp;gt;
      // same as `if (optCount.isDefined) c else c.updated(url, 0)`
      optCount match {
        case Some(count) =&amp;gt; c
        case None        =&amp;gt; c.updated(url, 0)
      }
    }
  } yield optCount.getOrElse(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;when-to-use-state&#34;&gt;When to use State&lt;/h3&gt;

&lt;p&gt;그러면, 언제 &lt;code&gt;State&lt;/code&gt; 가 필요할까요? 하나의 &lt;strong&gt;상태&lt;/strong&gt; (&lt;em&gt;State&lt;/em&gt;) 를 지속적으로 변경, 공유하면서 연산을 실행할 때 사용할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Building computations from sequences of operations that require a shared state.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를 들어 HTTP 요청과 응답, 트랜잭션 등을 &lt;code&gt;State&lt;/code&gt; 로 다루면서 연산을 조합해서 사용할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HttpRequest, HttpResponse, HttpSession&lt;/li&gt;
&lt;li&gt;Database Transaction&lt;/li&gt;
&lt;li&gt;Random Number Generator&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;github-service-example&#34;&gt;Github Service Example&lt;/h3&gt;

&lt;p&gt;그러면 위에서 보았던 &lt;code&gt;Cache&lt;/code&gt; 에 약간의 기능을 추가해 볼까요? 캐시 히트, 미스도 저장하고 캐시 히트는 최대 5분까지만 인정하기로 하지요. 오래된 캐시를 삭제하는 기능을 빼고 만들어 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type URL = String
type StarCount = Int

case class Timestamped(count: StarCount, time: DateTime)

case class Cache(hits: Int, misses: Int, map: Map[URL, Timestamped]) {
  def get(url: URL): Option[Timestamped] = map.get(url)
  def update(url: URL, timestamp: Timestamped): Cache = {
    val m = map + (url -&amp;gt; timestamp)
    this.copy(map = m)
  }
}

object Cache {
  def empty = Cache(0, 0, Map())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 &lt;code&gt;State&lt;/code&gt; 가 없¤면, 우리가 다루는 상태인 &lt;code&gt;Cache&lt;/code&gt; 를 명시적으로 넘겨주고, 리턴받기 위해 이렇게 코드를 작성해야 할테지요. 여기서 &lt;code&gt;c1&lt;/code&gt; 대신 &lt;code&gt;c&lt;/code&gt; 를 쓰는 오타라도 발생한다면..&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def stargazerCount(url: URL, c: Cache): (Cache, StarCount) = {
  val (c1, optCount) = checkCache(url, c)

  optCount match {
    case Some(count) =&amp;gt; (c1, count)
    case None =&amp;gt; retrieve(url, c1)
  }
}

def checkCache(url: URL, c: Cache): (Cache, Option[StarCount]) =
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&amp;gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&amp;gt;
      (c.copy(misses = c.misses + 1), None)
  }

def retrieve(url: URL, c: Cache): (Cache, StarCount) = {
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def stale(then: DateTime): Boolean = DateTime.now &amp;gt; then + 5.minutes
def getStarCountFromWebService(url: URL): StarCount = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;여기에 &lt;code&gt;State&lt;/code&gt; 를 하나씩 적용해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def stargazerCount(url: URL, c: Cache): (Cache, StarCount) = {
  val (c1, optCount) = checkCache(url, c)

  optCount match {
    case Some(count) =&amp;gt; (c1, count)
    case None =&amp;gt; retrieve(url, c1)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;먼저 &lt;code&gt;State&lt;/code&gt; 타입을 적용하고, 그 후에 &lt;code&gt;for&lt;/code&gt; 문을 적용한 뒤에, &lt;code&gt;State.state&lt;/code&gt; 를 이용해서 조금 더 깔끔하게 바꾸면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// applying State
def stargazerCount(url: URL): State[Cache, StarCount] =
  checkCache(url) flatMap { optCount =&amp;gt;
    optCount match {
      case Some(count) =&amp;gt; State { c =&amp;gt; (c, count) }
      case None        =&amp;gt; retrieve(url)
    }
  }

// use for-comprehension
def stargazerCount2(url: URL): State[Cache, StarCount] = for {
  optCount &amp;lt;- checkCache(url)
  count &amp;lt;- optCount match {
    case Some(count) =&amp;gt; State[Cache, StarCount] { c =&amp;gt; (c, count) }
    case None        =&amp;gt; retrieve(url)
  }
} yield count

// State.state
def stargazerCount(url: URL): State[Cache, StarCount] = for {
  optCount &amp;lt;- checkCache(url)
  count &amp;lt;- optCount
    .map(State.state[Cache, StarCount])
    .getOrElse(retrieve(url))
} yield count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;checkCache&lt;/code&gt; 함수에도 적용해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def checkCacheOrigin(url: URL, c: Cache): (Cache, Option[StarCount]) =
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&amp;gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&amp;gt;
      (c.copy(misses = c.misses + 1), None)
  }

def checkCache1(url: URL): State[Cache, Option[StarCount]] = State { c =&amp;gt;
  c.get(url) match {
    case Some(Timestamped(count, time)) if !stale(time) =&amp;gt;
      (c.copy(hits = c.hits + 1), Some(count))
    case _ =&amp;gt;
      (c.copy(misses = c.misses + 1), None)
  }
}

/**
 *  Has potential bug.
 *  Always use `State.gets` and `State.modify`.
 */
def checkCache2(url: URL): State[Cache, Option[StarCount]] = for {
  c &amp;lt;- State.get[Cache]
  optCount &amp;lt;- State.state {
    c.get(url) collect { case Timestamped(count, time) if !stale(time) =&amp;gt; count }
  }
  _ &amp;lt;- State.put(optCount ? c.copy(hits = c.hits + 1) | c.copy(misses = c.misses + 1))
} yield optCount

def checkCache(url: URL): State[Cache, Option[StarCount]] = for {
  optCount &amp;lt;- State.gets { c: Cache =&amp;gt;
    c.get(url) collect { case Timestamped(count, time) if !stale(time) =&amp;gt; count }
  }
  _ &amp;lt;- State.modify { c: Cache =&amp;gt;
    optCount ? c.copy(hits = c.hits + 1) | c.copy(misses = c.misses + 1)
  }
} yield optCount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;checkCache2&lt;/code&gt; 는 &lt;code&gt;State.get&lt;/code&gt; &lt;code&gt;State.put&lt;/code&gt; 때문에 버그가 발생할 수 있습니다. &lt;code&gt;get&lt;/code&gt; 으로 꺼낸 뒤에 &lt;code&gt;put&lt;/code&gt; 으로 넣으면, 이전에 어떤 상태가 있었든지, 덮어 씌우기 때문에 주의가 필요합니다. 일반적으로는 &lt;code&gt;put&lt;/code&gt; 대신 &lt;code&gt;modify&lt;/code&gt; 를 이용합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def init[S]: State[S, S] = State(s =&amp;gt; (s, s))
def get[S]: State[S, S] = init
def put[S](s: S): State[S, Unit] = State(_ =&amp;gt; (s, ()))

def gets[S, T](f: S =&amp;gt; T): State[S, T] = State(s =&amp;gt; (s, f(s)))
def modify[S](f: S =&amp;gt; S): State[S, Unit] = State(s =&amp;gt; {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;마지막으로 &lt;code&gt;retrieve&lt;/code&gt; 함수도 수정해볼까요&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def retrieveOrigin(url: URL, c: Cache): (Cache, StarCount) = {
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def retrieve1(url: URL): State[Cache, StarCount] = State { c =&amp;gt;
  val count = getStarCountFromWebService(url)
  val timestamp = Timestamped(count, DateTime.now)
  (c.update(url, timestamp), count)
}

def retrieve(url: URL): State[Cache, StarCount] = for {
  count &amp;lt;- State.state { getStarCountFromWebService(url) }
  timestamp = Timestamped(count, DateTime.now)
  _ &amp;lt;- State.modify[Cache] { _.update(url, timestamp) }
} yield count
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/mpilquist/scalaz-state-monad&#34;&gt;State Monad in Scalaz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tpolecat.github.io/assets/scalaz.svg&#34;&gt;Scalaz Typeclass Hierarchy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cs.lth.se/edan40&#34;&gt;Haskell Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fpinscala/fpinscala/wiki/Chapter-11:-Monads&#34;&gt;fpinscala - Monad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.haskell.org/All_About_Monads#The_IO_monad&#34;&gt;Haskell Monad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Easy Scalaz 3</title>
      <link>https://1ambda.github.io/21/scala/easy-scalaz-3/</link>
      <pubDate>Sat, 25 Jun 2016 00:16:24 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/easy-scalaz-3/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;monad-transformer&#34;&gt;Monad Transformer&lt;/h2&gt;

&lt;p&gt;지난 시간엔 &lt;em&gt;State Monad&lt;/em&gt; 를 다루었습니다. 그러나 &lt;em&gt;State&lt;/em&gt; 만 이용해서는 유용한 프로그램을 작성할 수 없습니다. 우리가 다루는 연산은 &lt;em&gt;Option&lt;/em&gt;, &lt;em&gt;Future&lt;/em&gt; 등 다양한 &lt;em&gt;side-effect&lt;/em&gt; 가 필요하기 때문인데요,&lt;/p&gt;

&lt;p&gt;서로 다른 &lt;code&gt;Monad&lt;/code&gt; 를 조합할 수 있다면 좋겠지만, 아쉽게도  &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Applicative&lt;/code&gt; 와 달리 모나드는 &lt;em&gt;composing&lt;/em&gt; 이 불가능합니다. &lt;a href=&#34;http://tonymorris.github.io/blog/posts/monads-do-not-compose&#34;&gt;Monad Do Not Compose&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;여러 모나드를 조합해서 사용하려면 &lt;em&gt;Monad Transformer&lt;/em&gt; 가 필요합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Monad transformers are useful for enabling interaction between different types of monads by &amp;ldquo;nesting&amp;rdquo; them into a higher-level monadic abstraction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Monad Transformer&lt;/em&gt; 란 여러 모나드의 &lt;em&gt;effect&lt;/em&gt; 를 엮어 새로운 모나드를 만들때 쓸 수 있습니다. 예를 들어&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;어떤 임의의 모나드 M 을 사용하면서 &lt;code&gt;State&lt;/code&gt; 효과를 주고 싶을 때 &lt;code&gt;StateT&lt;/code&gt; 를 이용할 수 있습니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State&lt;/code&gt; 를 다루면서, &lt;code&gt;for&lt;/code&gt; 내에서 &lt;code&gt;Option&lt;/code&gt; 처럼 로직을 다루고 싶다면, &lt;code&gt;OptionT[State, A]&lt;/code&gt; 를 이용할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대략 감이 오시죠? (&lt;code&gt;State&lt;/code&gt; 에 대한 자세한 설명은 &lt;a href=&#34;http://1ambda.github.io/easy-scalaz-1-state/&#34;&gt;Easy Scalaz 1 - State&lt;/a&gt; 을 참조)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;scalaz&lt;/em&gt; 에는 기본적으로 여러 모나드 트랜스포머가 정의되어 있습니다. (&lt;a href=&#34;https://github.com/scalaz/scalaz/tree/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz&#34;&gt;scalaz.core.*&lt;/a&gt;) &lt;code&gt;ListT&lt;/code&gt;, &lt;code&gt;MaybeT&lt;/code&gt; 등등. 이번 글에서는 아래 3개의 모나드 트랜스포머만 다룰 예정입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/scalaz/scalaz/blob/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz/OptionT.scala&#34;&gt;Scalaz - OptionT.scala&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/scalaz/scalaz/blob/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz/EitherT.scala&#34;&gt;Scalaz - EitherT.scala&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/scalaz/scalaz/blob/de0516dffadb4ccd2066fe2b132a6d2ba6e38bc0/core/src/main/scala/scalaz/StateT.scala&#34;&gt;Scalaz - StateT.scala&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-problem&#34;&gt;The Problem&lt;/h2&gt;

&lt;p&gt;모나드 트랜스포머를 설명하기 위해, 사용자의 Github Repository 에 어느 언어가 쓰였는지를 알려주는 &lt;code&gt;findLanguage&lt;/code&gt; 함수를 작성해보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// ref - https://softwarecorner.wordpress.com/2013/12/06/scalaz-optiont-monad-transformer/

import scalaz._, Scalaz._

case class User(name: String, repositories: List[Repository])
case class Repository(name: String, languages: List[Language])
case class Language(name: String, line: Long)

object GithubService {
  def findLanguage(users: List[User],
                    userName: String,
                    repoName: String,
                    langName: String): Option[Language] =
    for {
      u &amp;lt;- users          find { _.name === userName }
      r &amp;lt;- u.repositories find { _.name === repoName }
      l &amp;lt;- r.languages    find { _.name === langName }
    } yield l
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;List[User]&lt;/code&gt; 를 받아 해당 유저의 레포지토리에서 특정 언어가 있는지, 없는지를 검사하는 간단한 함수입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val u1 = User(
  &amp;quot;1ambda&amp;quot;, List(
    Repository(&amp;quot;akka&amp;quot;, List(
      Language(&amp;quot;scala&amp;quot;, 4990),
      Language(&amp;quot;java&amp;quot;,  12801)
    )),

    Repository(&amp;quot;scalaz&amp;quot;, List(
      Language(&amp;quot;scala&amp;quot;, 1451),
      Language(&amp;quot;java&amp;quot;,  291)
    ))
  )
)

val u2 = User(
  &amp;quot;2ambda&amp;quot;, List()
)

val users = List(u1, u2)

// spec
&amp;quot;findLanguage&amp;quot; in {
  val l1 = findLanguage(users, &amp;quot;1ambda&amp;quot;, &amp;quot;akka&amp;quot;, &amp;quot;scala&amp;quot;)
  val l2 = findLanguage(users, &amp;quot;1ambda&amp;quot;, &amp;quot;akka&amp;quot;, &amp;quot;haskell&amp;quot;)
  val l3 = findLanguage(users, &amp;quot;1ambda&amp;quot;, &amp;quot;rx-scala&amp;quot;, &amp;quot;scala&amp;quot;)
  val l4 = findLanguage(users, &amp;quot;adbma1&amp;quot;, &amp;quot;rx-scala&amp;quot;, &amp;quot;scala&amp;quot;)

  l1.isDefined shouldBe true
  l2.isDefined shouldBe false
  l3.isDefined shouldBe false
  l4.isDefined shouldBe false
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그런데, 요구사항이 갑자기 변경되어 많이 쓰이는 언어도 찾아내야 합니다. &lt;strong&gt;검사한 것 중 1000 줄이 넘는 언어리¤트를 상태로 다루면&lt;/strong&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type LangState = State[List[Language], Option[Language]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;findLanguage&lt;/code&gt; 를 다시 작성하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findLanguage2(users: List[User],
                  userName: String,
                  repoName: String,
                  langName: String): LangState =
  for {
    u &amp;lt;- users.find(_.name === userName).point[LangState]
    r  &amp;lt;- u.repositories.find(_.name === repoName).point[LangState]
    l &amp;lt;- r.languages.find(_.name === langName).point[LangState]
    _ &amp;lt;- modify(langs: List[Language] =&amp;gt; if (l.line &amp;gt;= 1000) l :: langs else langs)
  } yield song
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;당연히 컴파일이 되지 않습니다. 이는 &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt; 이 각각 &lt;code&gt;User&lt;/code&gt;, &lt;code&gt;Repository&lt;/code&gt;, &lt;code&gt;Language&lt;/code&gt; 가 아니라 &lt;code&gt;Option[User]&lt;/code&gt;, &lt;code&gt;Option[Repository]&lt;/code&gt;, &lt;code&gt;Option[Language]&lt;/code&gt; 이기 때문입니다. 패턴 매칭을 적용하면 아래와 같은 코드가 만들어집니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findLanguage(users: List[User],
                  userName: String,
                  repoName: String,
                  langName: String): LangState[Option[Language]] =
  for {
    optUser &amp;lt;- (users.find { _.name === userName }).point[LangState]
    optRepository &amp;lt;- (
      optUser match {
        case Some(u) =&amp;gt; u.repositories.find(_.name === repoName)
        case None =&amp;gt; none[Repository] // same as Option.empty[Repository]
      }).point[LangState]
    optLanguage &amp;lt;- (optRepository match {
      case Some(r) =&amp;gt; r.languages.find(_.name === langName)
      case None    =&amp;gt; none[Language]
    }).point[LangState]
    _ &amp;lt;- modify { langs: List[Language] =&amp;gt; optLanguage match {
      case Some(l) if l.line =&amp;gt; 1000 =&amp;gt; l :: langs
      case _                         =&amp;gt; langs
    }}
  } yield optLanguage
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드에서 중복되는 부분을 발견할 수 있는데요, 바로 &lt;code&gt;State[S, Option[A]]&lt;/code&gt; 에 대해 매번 패턴 매칭을 수행하는 부분이 중복입니다. 이를 제거하기 위해 새로운 모나드 &lt;code&gt;LangStateOption&lt;/code&gt; 을 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sacla&#34;&gt;case class LangStateOption[A](run: LangState[Option[A]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 모나드를 구현하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit val LangStateOptionMonad = new Monad[LangStateOption] {
  override def point[A](a: =&amp;gt; A): LangStateOption[A] =
    LangStateOption(a.point[Option].point[LangState])

  override def bind[A, B](fa: LangStateOption[A])(f: (A) =&amp;gt; LangStateOption[B]): LangStateOption[B] =
    LangStateOption(fa.run.flatMap { (o: Option[A]) =&amp;gt; o match {
      case Some(a) =&amp;gt; f(a).run
      case None    =&amp;gt; (none[B]).point[LangState] /* same as `(None: Option[B]).point[LangState]` */
    }})
}

// findLanguage impl
def findLanguage3(users: List[User],
                  userName: String,
                  repoName: String,
                  langName: String): LangStateOption[Language] =
  for {
    u &amp;lt;- LangStateOption((users.find { _.name === userName }).point[LangState])
    r &amp;lt;- LangStateOption((u.repositories.find { _.name === repoName }).point[LangState])
    l &amp;lt;- LangStateOption((r.languages.find { _.name === langName }).point[LangState])
    _ &amp;lt;- LangStateOption((modify { langs: List[Language] =&amp;gt;
      if (l.line &amp;gt;= 1000) l :: langs else langs
    }) map (_ =&amp;gt; none[Language]))
  } yield l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 잘 보셔야 할 두 가지 부분이 있습니다&lt;/p&gt;

&lt;p&gt;A. 우리가 임의의 모나드와 &lt;code&gt;Option&lt;/code&gt; 을 엮은 새로운 모나드를 생성한다면, &lt;code&gt;LangStateOption&lt;/code&gt; 타입만 다르고 모두 동일한 형태의 코드를 가지게 됩니다.&lt;/p&gt;

&lt;p&gt;그런고로 &lt;em&gt;scalaz&lt;/em&gt; 에서는 &lt;code&gt;Option&lt;/code&gt; 과 임의의 모나드 &lt;code&gt;M&lt;/code&gt; 을 조합한 타입을 &lt;code&gt;OptionT[M[_], A]&lt;/code&gt; 로 제공합니다.&lt;/p&gt;

&lt;p&gt;B. &lt;code&gt;State&lt;/code&gt; 와 &lt;code&gt;Option&lt;/code&gt; 을 엮어서 &lt;code&gt;State[S, Option[A]]&lt;/code&gt; 를 엮을 경우 &lt;code&gt;State&lt;/code&gt; 가 먼저 실행되고, 그 후에야 &lt;code&gt;Option&lt;/code&gt; 이 효과를 발휘합니다. (&lt;code&gt;fa.run.flatMap { o =&amp;gt; ...&lt;/code&gt;}&lt;/p&gt;

&lt;p&gt;따라서 어떤 모나드 트랜스포머와, 모나드를 엮냐에 따라서 의미가 달라집니다. 예를 들어 &lt;em&gt;scalaz&lt;/em&gt; 에서 제공해주는 모나드 트랜스포머 &lt;code&gt;OptionT&lt;/code&gt; 와 &lt;code&gt;StateT&lt;/code&gt; 에 대해&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OptionT[LangState, A]&lt;/code&gt; 는 &lt;code&gt;run: LangState[Option[A]]&lt;/code&gt; 이기 때문에 &lt;em&gt;optional value&lt;/em&gt; 를 돌려주는 &lt;em&gt;state action&lt;/em&gt; 을 의미하고&lt;/li&gt;
&lt;li&gt;반면 &lt;code&gt;StateT[Option, List[Language], A]]&lt;/code&gt; 는 &lt;code&gt;run: Option[State[List[Language], A]]&lt;/code&gt; 기 때문에 존재하지 않을 수 있는 (&lt;code&gt;None&lt;/code&gt;) 일 수 있는 &lt;em&gt;state action&lt;/em&gt; 을 의미합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;monadtrans&#34;&gt;MonadTrans&lt;/h2&gt;

&lt;p&gt;지금까지 우리가 했던 일을 살펴보면,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;M[A]&lt;/code&gt; -&amp;gt; &lt;code&gt;M[N[A]]&lt;/code&gt; -&amp;gt; &lt;code&gt;NT[M[N[_]], A]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉 하나의 모나드 &lt;code&gt;M&lt;/code&gt; 이 있을때 &lt;code&gt;A&lt;/code&gt; 를 &lt;code&gt;N[A]&lt;/code&gt; 로 &lt;em&gt;lifting&lt;/em&gt; 하는 &lt;code&gt;N&lt;/code&gt; 을 위한 모나드 트랜스포머를 &lt;code&gt;NT&lt;/code&gt; 를 정의했습니다. &lt;em&gt;scalaz&lt;/em&gt; 에서 사용된 모나드 트랜스포머 구현인 &lt;code&gt;MonadTrans&lt;/code&gt;, &lt;code&gt;OptionT&lt;/code&gt; 을 보면 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/MonadTrans.scala
trait MonadTrans[F[_[_], _]] {
  def liftM[G[_]: Monad, A](g: G[A]): F[G, A]

  ...
}

// OptionT `liftM` implementation (F == Option)
// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/OptionT.scala#L213

def liftM[G[_], A](a: G[A])(implicit G: Monad[G]): OptionT[G, A]) =
  OptionT[G, A](G.map[A, Option[A]](a) { (a: A) =&amp;gt;
    a.point[Option]
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Monad Transformer&lt;/strong&gt; 또한 &lt;strong&gt;Monad&lt;/strong&gt; 기 때문에 또 다른 &lt;strong&gt;Monad Transformer&lt;/strong&gt; 와 중첩이 가능합니다. 예를 들어&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// ref - http://www.slideshare.net/StackMob/monad-transformers-in-the-wild
type VIO[A] = ValidationT[IO, Throwable, A]
def doIO: VIO[Option[String]
val r = OptionT[VIO, String] = optionT[VIO](doIO)

// OptionT[ValidationT[IO, Throwable, A]
// == IO[Validation[Throwable, Option[A]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;optiont&#34;&gt;OptionT&lt;/h2&gt;

&lt;p&gt;이제 모나드 트랜스포머가 무엇인지 알았으니, &lt;code&gt;OptionT&lt;/code&gt; 를 사용해 볼까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/OptionT.scala

final case class OptionT[F[_], A](run: F[Option[A]]) {
  self =&amp;gt;

  private def mapO[B](f: Option[A] =&amp;gt; B)(implicit F: Functor[F]) = F.map(run)(f)

  def map[B](f: A =&amp;gt; B)(implicit F: Functor[F]): OptionT[F, B] = new OptionT[F, B](mapO(_ map f))

  def flatMap[B](f: A =&amp;gt; OptionT[F, B])(implicit F: Monad[F]): OptionT[F, B] = new OptionT[F, B](
    F.bind(self.run) {
      case None    =&amp;gt; F.point(None: Option[B])
      case Some(z) =&amp;gt; f(z).run
    }
  )

  def flatMapF[B](f: A =&amp;gt; F[B])(implicit F: Monad[F]): OptionT[F, B] = new OptionT[F, B](
    F.bind(self.run) {
      case None    =&amp;gt; F.point(none[B])
      case Some(z) =&amp;gt; F.map(f(z))(b =&amp;gt; some(b))
    }
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OptionT&lt;/code&gt; 는 두 가지 방법으로 생성할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;val ma: M[A]&lt;/code&gt; 가 있을 때 &lt;code&gt;ma.liftM[OptionT]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;val oa: Option[A]&lt;/code&gt; 가 있을 때 &lt;code&gt;OptionT(oa.point[M])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// type LangState[A] = State[List[Language], A]
val l = Language(&amp;quot;lisp&amp;quot;, 309)
val os1: OptionT[LangState, Language] = l.point[LangState].liftM[OptionT]
val os2: OptionT[LangState, Language] = OptionT(l.some.point[LangState])

os1 === os2
os1.run === os2.run
os1.run.runZero[List[Language]] === os2.run.runZero[List[Language]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;findLanguage&lt;/code&gt; 함수를 &lt;code&gt;OptionT&lt;/code&gt; 로 작성할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findLanguage(users: List[User],
                  userName: String,
                  repoName: String,
                  langName: String): OptionT[LangState, Language] =
  for {
    u &amp;lt;- OptionT((users.find { _.name === userName }).point[LangState])
    r &amp;lt;- OptionT((u.repositories.find { _.name === repoName }).point[LangState])
    l &amp;lt;- OptionT((r.languages.find { _.name === langName }).point[LangState])
    _ &amp;lt;- modify { langs: List[Language] =&amp;gt;
      if (l.line &amp;gt;= 1000) l :: langs else langs
    }.liftM[OptionT]
  } yield l
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sequencing-optiont&#34;&gt;Sequencing OptionT&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;findLanguage&lt;/code&gt; 를 이용해서, findLanguage&lt;strong&gt;s&lt;/strong&gt; 를 작성하는 것이 가능할까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class LanguageLookup(userName: String, repoName: String, langName: String)

// Option[List[Language]] 를 돌려주는 All or Nothing 버전
def findLanguages(users: List[User],
                     lookups: List[LanguageLookup]): OptionT[LangState, List[Language]] = ???

// List[Option[Language]] 를 돌려주는 덜 엄격한 버전
def findLanguages(users: List[User],
                     lookups: List[LanguageLookup]): LangState[List[Option[Language]]] = ???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;일단 &lt;code&gt;OptionT[LangState, List[Language]]&lt;/code&gt; 를 돌려주는 것 부터 작성해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findLanguages1(users: List[User],
                   lookups: List[LanguageLookup]): OptionT[LangState, List[Language]] =
  lookups map { lookup =&amp;gt;
    findLanguage(users, lookup.userName, lookup.repoName, lookup.langName)
  }

// compile error
Error:(87, 13) type mismatch;

 found   : List[scalaz.OptionT[LangState, Language]]
 required: scalaz.OptionT[LangState,List[Language]]
    lookups map { lookup =&amp;gt;
            ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;우리는 &lt;code&gt;OptionT[LangState, List[Language]]&lt;/code&gt; 를 돌려줘야 하는데, 단순히 &lt;code&gt;map&lt;/code&gt; 만 적용해서는 &lt;code&gt;List[OptionT[LangState, Language]]&lt;/code&gt; 밖에 못 얻습니다. 따라서 &lt;code&gt;Traversable.traverseU&lt;/code&gt; 를 이용하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findLanguages1(users: List[User],
                   lookups: List[LanguageLookup]): OptionT[LangState, List[Language]] =
  lookups.traverseU { lookup =&amp;gt;
    findLanguage(users, lookup.userName, lookup.repoName, lookup.langName)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;traverseU(f)&lt;/code&gt; 가 하는 일은&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;map(f)&lt;/code&gt;: 함수 &lt;code&gt;f&lt;/code&gt; 를 적용합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List[OptionT[LangState, Language]]&lt;/code&gt; 를 &lt;code&gt;OptionT[LangState, List[Language]]&lt;/code&gt; 를 변환합니다. &lt;strong&gt;Option 모나드의 효과를 적용하면서요&lt;/strong&gt; (&lt;strong&gt;sequence&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 &lt;code&gt;F[G[B]]&lt;/code&gt; 를 &lt;code&gt;G[F[B]]&lt;/code&gt; 로 변경하는 함수를 &lt;code&gt;sequence&lt;/code&gt; 라 부릅니다. (&lt;code&gt;F&lt;/code&gt; 는 &lt;em&gt;Monad&lt;/em&gt;, &lt;code&gt;G&lt;/code&gt; 는 &lt;em&gt;applicative&lt;/em&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;final def sequence[G[_], B](implicit ev: A === G[B], G: Applicative[G]): G[F[B]] = {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 후 &lt;code&gt;sequence&lt;/code&gt; 를 호출하는 함수가 바로 위에서 보았던 &lt;code&gt;traverse&lt;/code&gt; 입니다. 그런데, 더 높은 추상에서 보면 방금 말했던 것과는 반대로, &lt;code&gt;sequence&lt;/code&gt; 가 &lt;em&gt;identity&lt;/em&gt; 함수를 &lt;code&gt;map&lt;/code&gt; 한 &lt;code&gt;traverse&lt;/code&gt; 입니다. &lt;strong&gt;scalaz&lt;/strong&gt; 에도 실제로 이렇게 구현되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/syntax/TraverseSyntax.scala#L25

  final def traverse[G[_], B](f: A =&amp;gt; G[B])(implicit G: Applicative[G]): G[F[B]] =
    G.traverse(self)(f)

  /** Traverse with the identity function */
  final def sequence[G[_], B](implicit ev: A === G[B], G: Applicative[G]): G[F[B]] = {
    val fgb: F[G[B]] = ev.subst[F](self)
    F.sequence(fgb)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위에서 &lt;code&gt;traverse&lt;/code&gt; 가 아니라 &lt;code&gt;traverseU&lt;/code&gt; 를 호출한 이유는 &lt;code&gt;OptionT&lt;/code&gt; 에 대한 타입추론을 이용하기 위해서 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;이제 덜 엄격한 &lt;code&gt;findLanguages&lt;/code&gt; 함수를 작성해보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def findLanguages2(users: List[User],
                   lookups: List[LanguageLookup]): LangState[List[Option[Language]]] =
  lookups.traverseS { lookup =&amp;gt;
    findLanguage(users, lookup.userName, lookup.repoName, lookup.langName).run
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;traverseS&lt;/code&gt; 는 &lt;em&gt;state&lt;/em&gt; 버전의 &lt;code&gt;traverse&lt;/code&gt; 입니다. &lt;code&gt;map&lt;/code&gt; 을 적용한 &lt;code&gt;List[OptionT[LangState, Language]]&lt;/code&gt; 에 대해 &lt;code&gt;LangState[List[Option[Language]]&lt;/code&gt; 를 돌려줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;/** A version of `traverse` specialized for `State` */
final def traverseS[S, B](f: A =&amp;gt; State[S, B]): State[S, F[B]] = F.traverseS[S, A, B](self)(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;State[S, A]&lt;/code&gt; 에 대해서&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;State[S, Option[List[A]]&lt;/code&gt; 를 얻고 싶다면 (&lt;strong&gt;all or nothing&lt;/strong&gt;) &lt;code&gt;traverseU&lt;/code&gt; 를&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State[S, List[Option[A]]&lt;/code&gt; 를 얻고 싶다면 &lt;code&gt;B = Option[A]&lt;/code&gt; 를 &lt;code&gt;List&lt;/code&gt; 로 감싸야 하므로 &lt;code&gt;State[S, F[B]]&lt;/code&gt; 를 돌려주는 위해 &lt;code&gt;traverseS&lt;/code&gt; 를 사용하면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;eithert&#34;&gt;EitherT&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;EitherT&lt;/code&gt; 는 &lt;em&gt;scalaz&lt;/em&gt; 의 &lt;code&gt;Either&lt;/code&gt; 에 대한 모나드 트랜스포머입니다. 참고로, &lt;code&gt;scalaz.Either&lt;/code&gt; 은 &lt;code&gt;scala.Either&lt;/code&gt; 과 달리 &lt;em&gt;right-biased&lt;/em&gt; 입니다. &lt;code&gt;Option&lt;/code&gt; 처럼요.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;A \/ B&lt;/code&gt; is isomorphic to &lt;code&gt;scala.Either[A, B]&lt;/code&gt;, but &lt;code&gt;\/&lt;/code&gt; is right-biased, so methods such as &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; apply only in the context of the &amp;ldquo;right&amp;rdquo; case.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;scalaz.Either&lt;/code&gt; 에 대한 기본적인 설명은 &lt;a href=&#34;http://eed3si9n.com/learning-scalaz/Either.html&#34;&gt;Learning Scalaz - Either&lt;/a&gt; 에서 보실 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;EitherT&lt;/code&gt; 를 위한 간단한 모델을 만들어 보겠습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;쿼리를 파싱하³ , 실행하는 과정에서 &lt;em&gt;상태&lt;/em&gt; 인 &lt;code&gt;QueryState&lt;/code&gt; 를 이용하고&lt;/li&gt;
&lt;li&gt;쿼리 파싱에 실패하면 수행하지 않고 종료하기 위해 &lt;code&gt;scalaz.Either&lt;/code&gt; 를 사용합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// ref - https://speakerdeck.com/mpilquist/scalaz-state-monad

import scalaz._, Scalaz._

trait Model
trait Query
trait QueryResult

object QueryService {
  def runQuery(s: String, model: Model): String \/ QueryResult = for {
    query &amp;lt;- parseQuery(s)
    result &amp;lt;- performQuery(query, model)
  } yield result

  def parseQuery(s: String): String \/ Query = &amp;quot;TODO&amp;quot;.left
  def performQuery(q: Query, m: Model): String \/ QueryResult = &amp;quot;TODO&amp;quot;.left
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드에 &lt;em&gt;State&lt;/em&gt; 와 &lt;code&gt;EitherT&lt;/code&gt; 를 추가하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Model
trait Query
trait QueryResult
trait Transaction

object QueryService {
  type TransactionState[A] = State[Transaction, A]
  type Transactional[A] = EitherT[TransactionState, String, A]

  def runQuery(s: String, model: Model): Transactional[QueryResult] = for {
    query &amp;lt;- EitherT(parseQuery(s).point[TransactionState])
    result &amp;lt;- EitherT(performQuery(query, model).point[TransactionState])
  } yield result

  def parseQuery(s: String): String \/ Query = ???
  def performQuery(q: Query, m: Model): String \/ QueryResult = ???
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기에 약간의 헬퍼 함수를 더하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def runQuery(s: String, model: Model): Transactional[QueryResult] = for {
  query &amp;lt;- Transactional(parseQuery(s))
  result &amp;lt;- Transactional(performQuery(query, model))
} yield result

object Transactional {
  import QueryService._
  def apply[A](e: String \/ A): Transactional[A] = liftE(e)
  def liftE[A](e: String \/ A): Transactional[A] =
    EitherT(e.point[TransactionState])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;Transactional&lt;/code&gt; 이 이름 그대로의 역할을 할 수 있게 간단한 커넥션도 모델링 해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Transaction {
  def closeConnection: Unit
  def commit: Unit = closeConnection
  def rollback: Unit = closeConnection
}

object QueryService {
  type TransactionState[A] = State[Transaction, A]
  type EitherStringT[F[_], A] = EitherT[F, String, A]
  type Transactional[A] = EitherStringT[TransactionState, A]

  def parseQuery(s: String): String \/ Query =
    if (s.startsWith(&amp;quot;SELECT&amp;quot;)) s&amp;quot;Invalid Query: $s&amp;quot;.left[Query]
    else (new Query {}).right[String]

  def performQuery(q: Query, m: Model): String \/ QueryResult =
    new QueryResult {}.right

  def runQuery(s: String, model: Model): Transactional[QueryResult] = for {
    query &amp;lt;- Transactional(parseQuery(s))
    result &amp;lt;- Transactional(performQuery(query, model))
    _ &amp;lt;- (modify { t: Transaction =&amp;gt; t.commit; t }).liftM[EitherStringT]
  } yield result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;EitherStringT&lt;/code&gt; 타입을 새로 만든건, &lt;code&gt;liftM&lt;/code&gt; 을 사용하기 위해서입니다. 만약 &lt;code&gt;liftM[EitherT]&lt;/code&gt; 를 이용해 리프팅을 하면, 다음과 같은 예외가 발생합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Error:(37, 59) scalaz.EitherT takes three type parameters, expected: two
    _ &amp;lt;- (modify { t: Transaction =&amp;gt; t.commit; t }).liftM[EitherT]
                                                          ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;parseQuery&lt;/code&gt; 와 &lt;code&gt;performQuery&lt;/code&gt; 실패시 &lt;code&gt;rollback&lt;/code&gt; 을 호출하는것을 구현하고, &lt;code&gt;commit&lt;/code&gt; 을 헬퍼 함수로 변경하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def runQuery(s: String, model: Model): Transactional[QueryResult] = for {
  query &amp;lt;- Transactional(parseQuery(s))
  result &amp;lt;- Transactional(performQuery(query, model))
  _ &amp;lt;- commit
} yield result

def commit: Transactional[Unit] =
  (modify { t: Transaction =&amp;gt; t.commit; t }).liftM[EitherStringT]

object Transactional {
  import QueryService._
  def apply[A](e: String \/ A): Transactional[A] = e match {
    case -\/(error) =&amp;gt;
      /* logging error and... */
      liftTS(State[Transaction, String \/ A] { t =&amp;gt; t.rollback; (t, e) })
    case \/-(a) =&amp;gt; liftE(e)
  }

  def liftE[A](e: String \/ A): Transactional[A] =
    EitherT(e.point[TransactionState])

  def liftTS[A](tse: TransactionState[String \/ A]): Transactional[A] =
    EitherT(tse)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 다음처럼 실패시 롤백이 호출되고 &lt;code&gt;for&lt;/code&gt; 자동으로 스탑되것을 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val t = new Transaction {}
val model = new Model {}
val result1 = runQuery(&amp;quot;qqq&amp;quot;, model).run.eval(t)
println(result)

// output
parseQuery
rollback
-\/(Invalid Query: qqq)

val result2 = runQuery(&amp;quot;SELECT&amp;quot;, model).run.eval(t)
println(result2)

// output
parseQuery
performQuery
\/-(QueryService$$anon$2@36804139)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 &lt;code&gt;Transaction&lt;/code&gt; 에 &lt;code&gt;committed&lt;/code&gt;, &lt;code&gt;rollbacked&lt;/code&gt; 등의 값을 추가하면 &lt;code&gt;eval&lt;/code&gt; 대신 &lt;code&gt;exec&lt;/code&gt; (&lt;code&gt;run&lt;/code&gt; 도 가능) 으로 최종 상태인 &lt;code&gt;Transaction&lt;/code&gt; 을 얻어 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/StateT.scala#L17

  /** An alias for `apply` */
  def run(initial: S1): F[(S2, A)] = apply(initial)

  /** Calls `run` using `Monoid[S].zero` as the initial state */
  def runZero[S &amp;lt;: S1](implicit S: Monoid[S]): F[(S2, A)] =
    run(S.zero)

  /** Run, discard the final state, and return the final value in the context of `F` */
  def eval(initial: S1)(implicit F: Functor[F]): F[A] =
    F.map(apply(initial))(_._2)

  /** Calls `eval` using `Monoid[S].zero` as the initial state */
  def evalZero[S &amp;lt;: S1](implicit F: Functor[F], S: Monoid[S]): F[A] =
    eval(S.zero)

  /** Run, discard the final value, and return the final state in the context of `F` */
  def exec(initial: S1)(implicit F: Functor[F]): F[S2] =
    F.map(apply(initial))(_._1)

  /** Calls `exec` using `Monoid[S].zero` as the initial state */
  def execZero[S &amp;lt;: S1](implicit F: Functor[F], S: Monoid[S]): F[S2] =
    exec(S.zero)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;statet&#34;&gt;StateT&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://1ambda.github.io/easy-scalaz-1-state/&#34;&gt;Easy Scalaz 1 - State&lt;/a&gt; 에서 언급했던 것 처럼&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type State[S, A] = StateT[Id, S, A]
type Id[+X] = X

// 더 엄밀히는,

type StateT[F[_], S, A] = IndexedStateT[F, S, S, A]
type IndexedState[-S1, S2, A] = IndexedStateT[Id, S1, S2, A]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;StateT&lt;/code&gt; 에다가 혼합할 모나드 &lt;code&gt;F&lt;/code&gt; 에 &lt;code&gt;Id&lt;/code&gt; 를 준것이 &lt;code&gt;State&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;여기에 함수 &lt;code&gt;replicateM&lt;/code&gt; 을 적용하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://speakerdeck.com/mpilquist/scalaz-state-monad
  &amp;quot;replicateM(10)&amp;quot; in {

    // def replicateM(n: Int): F[List[A]]
    val getAndIncrement: State[Int, Int] = State { s =&amp;gt; (s + 1, s) }
    getAndIncrement.replicateM(10).run(0) shouldBe (10, (0 until 10).toList)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;code&gt;State&lt;/code&gt; 를 &lt;code&gt;F[_]&lt;/code&gt; 라 보면 이걸 &lt;code&gt;F[List[_]]&lt;/code&gt; 로 만들어 주므로 여러개의 &lt;code&gt;flatMap&lt;/code&gt; 이 중첩된 형태가 됩니다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;replicateM(100000)&lt;/code&gt; 등의 코드는 &lt;em&gt;Stackoverflow&lt;/em&gt; 가 발생합니다.&lt;/p&gt;

&lt;p&gt;이 문제를 해결하기 위해 &lt;code&gt;Trampoline&lt;/code&gt; 을 이용할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Scalaz provides the &lt;code&gt;Free&lt;/code&gt; data type, which when used with Function0, trade heap for stack&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이럴때 &lt;code&gt;Trampoline&lt;/code&gt; 을 사용하면, &lt;em&gt;stackoverflow&lt;/em&gt; 를 피할 수 있습니다. (그만큼의 힙을 사용해서)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// type Trampoline[+A] = Free[Function0, A]

&amp;quot;replicateM(1000)&amp;quot; in {

  import scalaz.Free._

  val getAndIncrement: State[Int, Int] = State { s =&amp;gt; (s + 1, s) }
  getAndIncrement.lift[Trampoline].replicateM(1000).run(0).run shouldBe (1000, (0 until 1000).toList)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Trampoline&lt;/code&gt; 은 후에 &lt;code&gt;Free&lt;/code&gt; 를 살펴보면서 다시 보겠습니다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tonymorris.github.io/blog/posts/monads-do-not-compose&#34;&gt;Tony Morris - Monad Do Not Compose&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://softwarecorner.wordpress.com/2013/12/06/scalaz-optiont-monad-transformer/&#34;&gt;Scalaz OptionT Monad Transformer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/mpilquist/scalaz-state-monad&#34;&gt;State Monad in Scalaz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/earldouglas/scala-scratchpad/tree/master/category-theory/monad-transformers&#34;&gt;scala-scratchpad: Monad Transformer in Scala&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tpolecat.github.io/assets/scalaz.svg&#34;&gt;Scalaz Typeclass Hierarchy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/26602611/how-to-understand-traverse-traverseu-and-traversem&#34;&gt;Stackoverflow - traverseU, traverseM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cs.lth.se/edan40&#34;&gt;Haskell Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.haskell.org/All_About_Monads#The_IO_monad&#34;&gt;Haskell Wiki - All About Monads&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Easy Scalaz 4</title>
      <link>https://1ambda.github.io/21/scala/easy-scalaz-4/</link>
      <pubDate>Sun, 03 Jan 2016 00:16:35 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/easy-scalaz-4/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;readerwriterstate-with-kleisli&#34;&gt;ReaderWriterState with Kleisli&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Composition&lt;/em&gt; (합성) 은 함수형 언어에서 중요한 테마중 하나인데요, 이번 시간에는 &lt;em&gt;Kleisli&lt;/em&gt; 를 이용해 어떻게 함수를 타입으로 표현하고, 합성할 수 있는지 살펴보겠습니다. 그리고 나서, &lt;em&gt;Reader&lt;/em&gt;, &lt;em&gt;Writer&lt;/em&gt; 에 대해 알아보고, 이것들과 &lt;em&gt;State&lt;/em&gt; 를 같이 사용하는 &lt;em&gt;RWST&lt;/em&gt; 에 대해 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;kleisli&#34;&gt;Kleisli&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;State&lt;/em&gt; 가 &lt;code&gt;(S) =&amp;gt; (S, A)&lt;/code&gt; 를 타입클래스로 표현한 것이라면, &lt;code&gt;A =&amp;gt; B&lt;/code&gt; 를 타입클래스로 표현한 것도 있지 않을까요? 그렇게 되면, 스칼라에서 지원하는 &lt;code&gt;andThen&lt;/code&gt;, &lt;code&gt;compose&lt;/code&gt; 을 이용해서 함수를 조합하는 것처럼, 타입 클래스를 조합할 수 있을겁니다. &lt;code&gt;Kleisli&lt;/code&gt; 가 바로, 그런 역할을 하는 타입 클래스입니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Kleisli represents a function &lt;code&gt;A =&amp;gt; M[B]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;타입을 보면, 단순히 &lt;code&gt;A =&amp;gt; B&lt;/code&gt; 이 아니라 &lt;code&gt;A =&amp;gt; M[B]&lt;/code&gt; 를 나타냅니다. 이는 &lt;code&gt;Kleisli&lt;/code&gt; 가 &lt;code&gt;M&lt;/code&gt; 을 해석하고, 조합할 수 있는 방법을 제공한다는 것을 의미합니다. 실제 구현을 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Kleisli.scala#L8

final case class Kleisli[M[_], A, B](run: A =&amp;gt; M[B]) { self =&amp;gt;
  ...

  def &amp;gt;=&amp;gt;[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] =  kleisli((a: A) =&amp;gt; b.bind(this(a))(k.run))

  def andThen[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &amp;gt;=&amp;gt; k

  def &amp;gt;==&amp;gt;[C](k: B =&amp;gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &amp;gt;=&amp;gt; kleisli(k)

  def andThenK[C](k: B =&amp;gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &amp;gt;==&amp;gt; k

  /** alias for `compose` */
  def &amp;lt;=&amp;lt;[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &amp;gt;=&amp;gt; this

  def compose[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &amp;gt;=&amp;gt; this

  def &amp;lt;==&amp;lt;[C](k: C =&amp;gt; M[A])(implicit b: Bind[M]): Kleisli[M, C, B] = kleisli(k) &amp;gt;=&amp;gt; this

  def composeK[C](k: C =&amp;gt; M[A])(implicit b: Bind[M]): Kleisli[M, C, B] = this &amp;lt;==&amp;lt; k
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/KleisliUsage.scala&#34;&gt;Kleisli Example&lt;/a&gt; 에서 간단한 예제를 가져와서 사용법을 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/KleisliUsage.scala

case class Continent(name: String, countries: List[Country] = List.empty)
case class Country(name: String, cities: List[City] = List.empty)
case class City(name: String, isCapital: Boolean = false, inhabitants: Int = 20)

val data: List[Continent] = List(
  Continent(&amp;quot;Europe&amp;quot;),
  Continent(&amp;quot;America&amp;quot;,
    List(
      Country(&amp;quot;Canada&amp;quot;,
        List(
          City(&amp;quot;Ottawa&amp;quot;), City(&amp;quot;Vancouver&amp;quot;))),
      Country(&amp;quot;USA&amp;quot;,
        List(
          City(&amp;quot;Washington&amp;quot;), City(&amp;quot;New York&amp;quot;))))),
  Continent(&amp;quot;Asia&amp;quot;,
    List(
      Country(&amp;quot;India&amp;quot;,
        List(City(&amp;quot;New Dehli&amp;quot;), City(&amp;quot;Calcutta&amp;quot;))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기에 다음의 ¨수를 정의하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def continents(name: String): List[Continent] =
  data.filter(k =&amp;gt; k.name.contains(name))

def countries(continent: Continent): List[Country] = continent.countries

def cities(country: Country): List[City] = country.cities

def save(cities: List[City]): Try[Unit] =
  Try {
    // do IO or some side-effectful operations
    cities.foreach(c =&amp;gt; println(&amp;quot;Saving &amp;quot; + c.name))
  }

def inhabitants(c: City): Int = c.inhabitants
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;A =&amp;gt; M[B]&lt;/code&gt; 형태의 여러 함수들을 만들었으므로 이를 &lt;code&gt;Kleisli&lt;/code&gt; 를 이용해 조합할 수 있습니다. (이 예제에서 &lt;code&gt;M == List&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Kleisli[List, String, City]
val allCities = kleisli(continents) &amp;gt;==&amp;gt; countries &amp;gt;==&amp;gt; cities

// Kleisli[List, String, Int]
val cityInhabitants = allCities map inhabitants
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;allCities&lt;/code&gt; 는 &lt;code&gt;String&lt;/code&gt; 을 인자로 받기도 하고, &lt;code&gt;M == List&lt;/code&gt; 의 &lt;code&gt;Kleisli&lt;/code&gt; 기 때문에 &lt;code&gt;List&lt;/code&gt; 를 인자로 받을 수도 있습니다. (&lt;code&gt;=&amp;lt;&amp;lt;&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;allCities(&amp;quot;America&amp;quot;) map(println)

// output
City(Ottawa,false,20)
City(Vancouver,false,20)
City(Washington,false,20)
City(New York,false,20)

(allCities =&amp;lt;&amp;lt; List(&amp;quot;America&amp;quot;, &amp;quot;Asia&amp;quot;)).map(println)

// output
City(Ottawa,false,20)
City(Vancouver,false,20)
City(Washington,false,20)
City(New York,false,20)
City(New Dehli,false,20)
City(Calcutta,false,20)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Kleisli&lt;/code&gt; 가 제공하는 함수를 다시 살펴보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def =&amp;lt;&amp;lt;(a: M[A])(implicit m: Bind[M]): M[B] = m.bind(a)(run)

def map[C](f: B =&amp;gt; C)(implicit M: Functor[M]): Kleisli[M, A, C] =
  kleisli(a =&amp;gt; M.map(run(a))(f))

def mapK[N[_], C](f: M[B] =&amp;gt; N[C]): Kleisli[N, A, C] =
  kleisli(run andThen f)

def flatMapK[C](f: B =&amp;gt; M[C])(implicit M: Bind[M]): Kleisli[M, A, C] =
  kleisli(a =&amp;gt; M.bind(run(a))(f))

def flatMap[C](f: B =&amp;gt; Kleisli[M, A, C])(implicit M: Bind[M]): Kleisli[M, A, C] =
  kleisli((r: A) =&amp;gt; M.bind[B, C](run(r))(((b: B) =&amp;gt; f(b).run(r))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;mapK :: M[B] =&amp;gt; N[C]&lt;/code&gt; 를 이용하면 현재 &lt;code&gt;Kleisli[M, _, _]&lt;/code&gt; 를 &lt;code&gt;Kleisli[N, _, _]&lt;/code&gt; 로 변경할 수 있습니다.&lt;/p&gt;

&lt;p&gt;위에서 정한 &lt;code&gt;save&lt;/code&gt; 함수는 &lt;code&gt;List[A]&lt;/code&gt; 를 받아 &lt;code&gt;Try[Unit]&lt;/code&gt; 를 여기에 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Kleisli[Try, String, Unit]
val getAndSaveCities = allCities mapK save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;local&lt;/code&gt; 을 이용하면 함수를 &lt;em&gt;prepend&lt;/em&gt; 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// def local[AA](f: AA =&amp;gt; A): Kleisli[M, AA, B] =
//   kleisli(f andThen run)

def index(i: Int): String = data(i).name

// Kleisli[List, Int, City]
val allCitiesWithIndex = allCities local index

allCitiesWithIndex(1) map(println)

// output
City(Ottawa,false,20)
City(Vancouver,false,20)
City(Washington,false,20)
City(New York,false,20)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Kleisli&lt;/code&gt; 에 대한 더 읽을거리는 아래 링크를 참조해주세요.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://eed3si9n.com/learning-scalaz/Arrow.html&#34;&gt;Scalaz Arrow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Kleisli.scala#L209&#34;&gt;Scalaz - Kleisli.scala#KleisliArrow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reader&#34;&gt;Reader&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Kleisli&lt;/code&gt; 가 &lt;code&gt;A =&amp;gt; M[B]&lt;/code&gt; 를 나타낸다면, &lt;code&gt;Reader&lt;/code&gt; 는 &lt;code&gt;A =&amp;gt; B&lt;/code&gt; (&lt;code&gt;Function1&lt;/code&gt;) 를 의미하는 타입클래스입니다. 얼핏 생각하기에 &lt;code&gt;Kleisli[Id, A, B]&lt;/code&gt; 일것 같죠? 실제 구현을 보면 (&lt;em&gt;scalaz&lt;/em&gt; 에서 타입 얼라이어스는 &lt;code&gt;package.scala&lt;/code&gt; 에 정의되어 있습니다.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/package.scala

type ReaderT[F[_], E, A] = Kleisli[F, E, A]
val ReaderT = Kleisli
type Reader[E, A] = ReaderT[Id, E, A]

object Reader {
    def apply[E, A](f: E =&amp;gt; A): Reader[E, A] = Kleisli[Id, E, A](f)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Reader&lt;/code&gt; 도 &lt;code&gt;Klelsli&lt;/code&gt; 이므로, &lt;code&gt;Reader[A, B] &amp;gt;==&amp;gt; Reader[B, C]&lt;/code&gt; 는 &lt;code&gt;Reader[A, C]&lt;/code&gt; 가 됩니다. 게다가 &lt;code&gt;Kleisli&lt;/code&gt; 는 &lt;code&gt;flatMap&lt;/code&gt; 을 정의하고 있으므로 &lt;em&gt;monadic composition&lt;/em&gt; 을 작성할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The point of a &lt;code&gt;Reader&lt;/code&gt; is to supply some configuration object without having to manually (or &lt;em&gt;implicitly&lt;/em&gt;) pass i around all the functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;요는, 함수 사이의 체인을 엮어 새로운 함수를 만들수 있고 이로인해 직접 파라미터를 넘겨줄 필요가 없습니다. 예를 들어&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type URI = String
type Key = String
type Value = String

val uri: Reader[Get, URI]
val queryString: Reader[URI, String]
val body: Reader[String, Map[Key, Value]

// Get =&amp;gt; Map[Key, Value]
val queryStringToBody = uri &amp;gt;==&amp;gt; queryString &amp;gt;==&amp;gt; body
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;간단히 구현을 해보겠습니다. 예외 처리는 외부에서 &lt;code&gt;Try&lt;/code&gt; 혹은 &lt;code&gt;\/.fromTryCatchThrowable&lt;/code&gt; 등으로 한다 가정하고 로직에만 집중해보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// model
trait HttpRequest {
  def url: String
}
case class GET(url: String) extends HttpRequest
case class POST(url: String, body: Map[String, String]) extends HttpRequest

val uri: Reader[GET, String] = Reader { req: GET =&amp;gt; req.url }
val queryString: Reader[String, String] = Reader { url: String =&amp;gt; url.split(&amp;quot;\\?&amp;quot;)(1) }
val body: Reader[String, Map[String, String]] = Reader { queries: String =&amp;gt;
  val qs = queries.split(&amp;quot;&amp;amp;&amp;quot;).toList
  qs.foldLeft(Map.empty[String, String]) { (acc: Map[String, String], q) =&amp;gt;
    val kv = q.split(&amp;quot;=&amp;quot;)
    acc.updated(kv(0), kv(1))
  }
}

val queryStringToBody: Reader[GET, Map[String, String]] = uri &amp;gt;==&amp;gt; queryString &amp;gt;==&amp;gt; body
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;queryStringToBody&lt;/code&gt; 를 사용해 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val get1 = GET(&amp;quot;http://www.google.com/search?query=scalaz&amp;amp;site=github&amp;quot;)
val post1 = POST(&amp;quot;http://www.google.com/search&amp;quot;, Map(&amp;quot;query&amp;quot; -&amp;gt; &amp;quot;scalaz&amp;quot;, &amp;quot;site&amp;quot; -&amp;gt; &amp;quot;github&amp;quot;))
val post2 = POST(&amp;quot;https://www.google.com/search&amp;quot;, Map(&amp;quot;query&amp;quot; -&amp;gt; &amp;quot;scalaz&amp;quot;, &amp;quot;site&amp;quot; -&amp;gt; &amp;quot;github&amp;quot;))

queryStringToBody.run(get1) shouldBe Map(&amp;quot;query&amp;quot; -&amp;gt; &amp;quot;scalaz&amp;quot;, &amp;quot;site&amp;quot; -&amp;gt; &amp;quot;github&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;함수를 몇개 더 작성해보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;
val toHttpsRequest = Reader { url: String =&amp;gt; url.replaceAll(&amp;quot;http://$&amp;quot;, &amp;quot;https://&amp;quot;) }
val sslProxy: Reader[_ &amp;gt;: readerwriterstate.HttpRequest, readerwriterstate.HttpRequest] = Reader { req: readerwriterstate.HttpRequest =&amp;gt;
  req match {
    case request if request.url.startsWith(&amp;quot;https://&amp;quot;) =&amp;gt; request
    case request: POST =&amp;gt; request.copy(url = toHttpsRequest(request.url))
    case request: GET  =&amp;gt; request.copy(url = toHttpsRequest(request.url))
  }
}

val convertGetToPost: Reader[_ &amp;gt;: readerwriterstate.HttpRequest, POST] = Reader { req : readerwriterstate.HttpRequest =&amp;gt;
  req match {
    case get: GET =&amp;gt;
      val split = get.url.split(&amp;quot;\\?&amp;quot;)
      val (path, query) = (split(0), split(1))
      val postBody = body.run(query)

      POST(path, postBody)

    case post: POST =&amp;gt; post
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;HttpRequest&lt;/code&gt; 서브타입을 받아, 프록시를 적용하고, &lt;code&gt;GET&lt;/code&gt; 이면 &lt;code&gt;POST&lt;/code&gt; 로 변경하는 함수를 조합해보면 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;(&lt;code&gt;:&amp;gt;&lt;/code&gt; 등 &lt;em&gt;Type Bound&lt;/em&gt; 에 대해서는 &lt;a href=&#34;http://twitter.github.io/scala_school/type-basics.html&#34;&gt;Scala School - Type &amp;amp; Polymorphism&lt;/a&gt; 과 &lt;a href=&#34;http://twitter.github.io/scala_school/advanced-types.html&#34;&gt;Scala School - Advanced Types&lt;/a&gt; 를 참조해주세요.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val proxiedPost: Reader[_ &amp;gt;: HttpRequest, POST] = sslProxy &amp;gt;==&amp;gt; convertGetToPost

// spec
proxiedPost.run(get1) shouldBe post2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flatmap-for-reader&#34;&gt;flatMap for Reader&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Reader&lt;/code&gt; 는 &lt;code&gt;Kleisli&lt;/code&gt; 고, 이것간의 합성은 &lt;code&gt;&amp;gt;==&amp;gt;&lt;/code&gt; 을 이용한다는것을 확인했습니다. 그럼 &lt;code&gt;flatMap&lt;/code&gt; 은 어디에 쓰는걸까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type ReaderT[F[_], E, A] = Kleisli[F, E, A]
type Reader[E, A] = ReaderT[Id, E, A]

final case class Kleisli[M[_], A, B](run: A =&amp;gt; M[B]) { self =&amp;gt;
  ...

  // andThen
  def &amp;gt;=&amp;gt;[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] =  kleisli((a: A) =&amp;gt; b.bind(this(a))(k.run))

  def &amp;gt;==&amp;gt;[C](k: B =&amp;gt; M[C])(implicit b: Bind[M]): Kleisli[M, A, C] = this &amp;gt;=&amp;gt; kleisli(k)

  def flatMapK[C](f: B =&amp;gt; M[C])(implicit M: Bind[M]): Kleisli[M, A, C] =
    kleisli(a =&amp;gt; M.bind(run(a))(f))

  def flatMap[C](f: B =&amp;gt; Kleisli[M, A, C])(implicit M: Bind[M]): Kleisli[M, A, C] =
    kleisli((r: A) =&amp;gt; M.bind[B, C](run(r))(((b: B) =&amp;gt; f(b).run(r))))

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;flatMap&lt;/code&gt; 을 보면 재미난 점이 보입니다. &lt;code&gt;Kleisli[M, A, B]&lt;/code&gt; 와 &lt;code&gt;Kleisli[M, A, C]&lt;/code&gt; 를 &lt;code&gt;flatMap&lt;/code&gt; 으로 엮는데, &lt;code&gt;r: A&lt;/code&gt; 를 넣어서 &lt;code&gt;run(r)&lt;/code&gt; 을 실행하는걸 보실 수 있습니다. &lt;code&gt;Kleisli[M, A, C]&lt;/code&gt; 까지도요!&lt;/p&gt;

&lt;p&gt;즉 &lt;code&gt;A&lt;/code&gt; 자체가 일종의 설정(&lt;em&gt;Configuration&lt;/em&gt;) 값으로써 모든 &lt;code&gt;Kleisli&lt;/code&gt; 에서 사용됩니다. 그렇°에&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Reader[A, B]&lt;/code&gt; 와 &lt;code&gt;Reader[B, C]&lt;/code&gt; 는 &lt;code&gt;&amp;gt;==&amp;gt;&lt;/code&gt; 으로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Reader[A, B]&lt;/code&gt; 와 &lt;code&gt;Reader[A, C]&lt;/code&gt; 는 &lt;code&gt;flatMap&lt;/code&gt; 으로 엮을 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;dependency-injection-using-reader&#34;&gt;Dependency Injection using Reader&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Reader&lt;/code&gt; 를 이용하면 스칼라에서 별도의 라이브러리 없이 &lt;em&gt;Dependency Injection&lt;/em&gt; (이하 &lt;em&gt;DI&lt;/em&gt;) 를 구현할 수 있습니다. 이는 위에서 보았던 &lt;code&gt;flatMap&lt;/code&gt; 의 특징을 이용하면 됩니다. 다음과 같은 모델이 있다고 할  때,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class User(id: Long,
                name: String,
                age: Int,
                email: String,
                supervisorId: Long)

trait UserRepository {
  def get(id: Long): User
  def find(name: String): User
}

trait UserService {
  def getUser(id: Long): Reader[UserRepository, User] =
    Reader(repo =&amp;gt; repo.get(id))

  def findUser(userName: String): Reader[UserRepository, User] =
    Reader(repo =&amp;gt; repo.find(userName))

  def getUserInfo(userName: String): Reader[UserRepository, Map[String, String]] = for {
    user &amp;lt;- findUser(userName)
    supervisor &amp;lt;- getUser(user.supervisorId)
  } yield Map(
    &amp;quot;email&amp;quot; -&amp;gt; s&amp;quot;${user.email}&amp;quot;,
    &amp;quot;boss&amp;quot;  -&amp;gt; s&amp;quot;${supervisor.name}&amp;quot;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음처럼 주입할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object UserRepositoryDummyImpl extends UserRepository {
  override def get(id: Long): User = ???
  override def find(name: String): User = ???
}

class UserApplication(userRepository: UserRepository) extends UserService
object UserApplication extends UserApplication(UserRepositoryDummyImpl)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이외에도 스칼라에서 언어 자체의 기능만으로 DI 를 구현하는 방법으로 &lt;em&gt;Cake Pattern&lt;/em&gt; , &lt;em&gt;Implicit&lt;/em&gt; 등이 있습니다. (&lt;a href=&#34;http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/&#34;&gt;Scala Dependency Injection using Reader&lt;/a&gt; 참조)&lt;/p&gt;

&lt;p&gt;위의 두 방법과 &lt;code&gt;Reader&lt;/code&gt; 를 사용한 방법을 비교하면,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Cake Pattern&lt;/em&gt; 에 비해 코드가 짧고&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Implicit&lt;/em&gt; 를 이용하지 않으므로 함수 시그니쳐가 간단합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;writer&#34;&gt;Writer&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Writer[W, A]&lt;/code&gt; 는 &lt;code&gt;run: (W, A)&lt;/code&gt; 을 값¼로 가지는 &lt;em&gt;case class&lt;/em&gt; 입니다. 재미난 점은, &lt;code&gt;flatMap&lt;/code&gt; 을 이용해 두개의 &lt;code&gt;Writer&lt;/code&gt; 를 엮으면 각각의 값인 &lt;code&gt;(w1, a1)&lt;/code&gt;, &lt;code&gt;(w2, a2)&lt;/code&gt; 에 대해서 사용자가 다루는 값인 &lt;code&gt;a1, a2&lt;/code&gt; 를 제하고 &lt;code&gt;w1&lt;/code&gt; 과 &lt;code&gt;w2&lt;/code&gt; 가 일종의 &lt;a href=&#34;http://1ambda.github.io/easy-scalaz-1-state/&#34;&gt;State&lt;/a&gt; 처럼 관리되어 자동으로 &lt;em&gt;append&lt;/em&gt; 된다는 점입니다. 따라서 많은 튜토리얼들이 &lt;em&gt;logging&lt;/em&gt; 을 예로 들어 &lt;code&gt;Writer&lt;/code&gt; 를 설명하곤 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;test(&amp;quot;WriterOps&amp;quot;) {
  val w1: Writer[String, Int] = 10.set(&amp;quot;w1 created&amp;quot;)
  val w2: Writer[String, Int] = 20.set(&amp;quot;w2 created&amp;quot;)

  val result: Writer[String, Int] = for {
    n1 &amp;lt;- w1
    n2 &amp;lt;- w2
  } yield n1 + n2

  // What if we use `List[String]` instead of `String`?
  result.run shouldBe (&amp;quot;w1 createdw2 created&amp;quot;, 30)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Scalaz&lt;/em&gt; 구현을 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type Writer[W, A] = WriterT[Id, W, A]

final case class WriterT[F[_], W, A](run: F[(W, A)]) { self =&amp;gt;
  ...

  def flatMap[B](f: A =&amp;gt; WriterT[F, W, B])(implicit F: Bind[F], s: Semigroup[W]): WriterT[F, W, B] =
    flatMapF(f.andThen(_.run))

  def flatMapF[B](f: A =&amp;gt; F[(W, B)])(implicit F: Bind[F], s: Semigroup[W]): WriterT[F, W, B] =
    writerT(F.bind(run){wa =&amp;gt;
      val z = f(wa._2)
      F.map(z)(wb =&amp;gt; (s.append(wa._1, wb._1), wb._2))
    })

  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;WriterT&lt;/code&gt; 에서 &lt;code&gt;F&lt;/code&gt; 를 &lt;code&gt;Id&lt;/code&gt; 라 하면 &lt;code&gt;Writer&lt;/code&gt; 가 되고 &lt;code&gt;flatMap&lt;/code&gt; 로직은 다음처럼 단순화 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Writer[W, A](run: (W, A)) { self =&amp;gt;
  def flatMap[B](f: A =&amp;gt; Writer[W, B])(implicit s: Semigroup[W]) {
    val (w1, a) = self.run
    val (w2, b) = f(a)
    (s.append(w1, w2), b)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Semigroup.scala&#34;&gt;Semigroup.scala&lt;/a&gt; 은, &lt;em&gt;Associativity&lt;/em&gt; (결합법칙) 을 만족하는 &lt;em&gt;binary operator&lt;/em&gt; 를 정의하는 타입 클래스입니다. (위에서 &lt;code&gt;append&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Semigroup.scala#L55

 /**
   * A semigroup in type F must satisfy two laws:
    *
    *  - &#39;&#39;&#39;closure&#39;&#39;&#39;: `∀ a, b in F, append(a, b)` is also in `F`. This is enforced by the type system.
    *  - &#39;&#39;&#39;associativity&#39;&#39;&#39;: `∀ a, b, c` in `F`, the equation `append(append(a, b), c) = append(a, append(b , c))` holds.
   */
  trait SemigroupLaw {
    def associative(f1: F, f2: F, f3: F)(implicit F: Equal[F]): Boolean =
      F.equal(append(f1, append(f2, f3)), append(append(f1, f2), f3))
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Monoid.scala&#34;&gt;Monoid&lt;/a&gt; 는 결합법칙을 만족하는 덧셈 연산과, 항등원 연산을 정의하는 타입 클래스인데, &lt;em&gt;Scalaz&lt;/em&gt; 에서는 &lt;code&gt;Monoid&lt;/code&gt; 가 &lt;code&gt;Semigroup&lt;/code&gt; 을 상속받습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Monoid[F] extends Semigroup[F] { self =&amp;gt;
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png&#34; alt=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/about-type-class/Typeclassopedia-diagram.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;Writer[W, A]&lt;/code&gt; 의 &lt;code&gt;flatMap&lt;/code&gt; 을 이용하기 위해서는 &lt;code&gt;W&lt;/code&gt; 가 &lt;code&gt;Semigroup&lt;/code&gt; 여야 하고 그래야만 &lt;code&gt;flatMap&lt;/code&gt; 내부에서 자동으로 &lt;code&gt;W&lt;/code&gt; 를 &lt;em&gt;append&lt;/em&gt; 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;스칼라에서 제공하는 &lt;code&gt;List&lt;/code&gt; 등의 기본 타입은 &lt;em&gt;Scalaz&lt;/em&gt; 에서 &lt;code&gt;Monoid&lt;/code&gt; 를 제공합니다. (&lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/std/List.scala#L109&#34;&gt;scalaz.std.List&lt;/a&gt;, &lt;a href=&#34;https://github.com/scalaz/scalaz/tree/series/7.1.x/core/src/main/scala/scalaz/std&#34;&gt;scalaz.std&lt;/a&gt; 참조)&lt;/p&gt;

&lt;p&gt;정리하면, &lt;code&gt;Writer[W, A]&lt;/code&gt; 를 이용하면 값인 &lt;code&gt;A&lt;/code&gt; 를 조작하면서 &lt;code&gt;W&lt;/code&gt; 를 신경쓰지 않고, 자동으로 &lt;code&gt;append&lt;/code&gt; 시킬 수 있습니다. (e.g &lt;em&gt;logging&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;writer-example&#34;&gt;Writer Example&lt;/h2&gt;

&lt;p&gt;간단한 모델을 만들면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scalaz._, Scalaz._

trait ThreadState
case object Waiting    extends ThreadState
case object Running    extends ThreadState
case object Terminated extends ThreadState
case class Thread(tid: String, name: String, state: ThreadState)
case class Process(pid: String, threads: List[Thread])

object Process {
  type Logger[A] = Writer[Vector[String], A]

  def genRandomID: String = java.util.UUID.randomUUID().toString.replace(&amp;quot;-&amp;quot;, &amp;quot;&amp;quot;)

  def createThread(name: String): Logger[Thread] = {
    val tid = genRandomID
    Thread(tid, name, Waiting).set(Vector(s&amp;quot;Thread [$tid] was created&amp;quot;))
  }

  def createEmptyProcess: Logger[Process] = {
    val pid = genRandomID
    Process(pid, Nil).set(Vector(s&amp;quot;Empty Process [$pid] was created&amp;quot;))
  }

  def createNewProcess: Logger[Process] = for {
    mainThread &amp;lt;- createThread(&amp;quot;main&amp;quot;)
    process &amp;lt;- createEmptyProcess
    _ &amp;lt;- Vector(s&amp;quot;Main Thread [${mainThread.tid}] was added to Process [${process.pid}&amp;quot;).tell
  } yield process.copy(threads = mainThread.copy(state = Running) :: process.threads)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;W&lt;/code&gt; 로 &lt;code&gt;List[String]&lt;/code&gt; 대신 &lt;code&gt;Vector[String]&lt;/code&gt; 을 사용하는 이유는, &lt;em&gt;append&lt;/em&gt; 가 더 빠르기 때문입니다. (&lt;a href=&#34;http://docs.scala-lang.org/overviews/collections/performance-characteristics.html&#34;&gt;Scala Collection Performance Characteristics&lt;/a&gt; 참조)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;test(&amp;quot;Writer usage2&amp;quot;) {
  import readerwriterstate.Process._

  val (written, process) = createNewProcess.run

  process.threads.length shouldBe 1
  process.threads.head.name shouldBe &amp;quot;main&amp;quot;

  /* map lets you map over the value side */
  val ts: Logger[List[Thread]] = createNewProcess.map(p =&amp;gt; p.threads)
  ts.value.length shouldBe 1

  /* with mapWritten you can map over the written side */
  val edited: Vector[String] = createNewProcess.mapWritten(_.map { log =&amp;gt; &amp;quot;[LOG]&amp;quot; + log }).written
  println(edited.mkString(&amp;quot;\n&amp;quot;))

  /** output
   * [LOG]Thread [557ad5bd0f3b4d49bac85b05ebedcd7b] was created
   * [LOG]Empty Process [710bd940ebdd4a82b949a32b585a12d9] was created
   * [LOG]Main Thread [557ad5bd0f3b4d49bac85b05ebedcd7b] was added to Process [710bd940ebdd4a82b949a32b585a12d9]
   */

  /* with mapValue, you can map over both sides */
  createNewProcess.mapValue { case (log, p) =&amp;gt;
    (log :+ &amp;quot;Add an IO thread&amp;quot;,
     p.copy(threads = Thread(genRandomID, &amp;quot;IO-1&amp;quot;, Waiting) :: p.threads))
  }

  // `:++&amp;gt;` `:++&amp;gt;&amp;gt;`, `&amp;lt;++:`, `&amp;lt;&amp;lt;++:`
  createNewProcess :++&amp;gt; Vector(&amp;quot;add some log&amp;quot;)
  val emptyWithLog = createEmptyProcess :++&amp;gt;&amp;gt; { process =&amp;gt;
    Vector(s&amp;quot;${process.pid} is an empty process&amp;quot;)
  }

   println(emptyWithLog.written)

  // output: Vector(Empty Process [cf211fc366ab4d20a0c25a27d173accd] was created, cf211fc366ab4d20a0c25a27d173accd is an empty process)

  // Writer is an applicative
  val emptyProcesses: Logger[List[readerwriterstate.Process]] =
    (createEmptyProcess |@| createEmptyProcess) { List(_) |+| List(_) }

  val ps = emptyProcesses.value
  ps.length shouldBe 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://eed3si9n.com/learning-scalaz/Applicative+Builder.html&#34;&gt;Applicative Builder&lt;/a&gt;, &lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/WriterT.scala#L30&#34;&gt;WriterT Functions&lt;/a&gt; 를 참고하시면 이해가 더 쉽습니다.&lt;/p&gt;

&lt;h2 id=&#34;rwst&#34;&gt;RWST&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala&#34;&gt;ReaderWriterState&lt;/a&gt; 는 다름이 아니라, 이제까지 보았던 &lt;code&gt;Reader&lt;/code&gt;, &lt;code&gt;Writer&lt;/code&gt;, &lt;code&gt;State&lt;/code&gt; 를 모두 이용하는 타입 클래스입니다. &lt;code&gt;Reader&lt;/code&gt; 로 설정값을 읽고, &lt;code&gt;Writer&lt;/code&gt; 로 중간 과정을 기록하고, &lt;code&gt;State&lt;/code&gt; 로 상태를 변경 또는 유지해 가며 연산을 수행할 수 있습니다. &lt;em&gt;Scalaz&lt;/em&gt; 에서는 예제로 &lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.2.x/example/src/main/scala/scalaz/example/ReaderWriterStateTUsage.scala&#34;&gt;ReaderWriterStateTUsage.scala&lt;/a&gt; 를 제공하고 있습니다.&lt;/p&gt;

&lt;p&gt;이제까지 늘 그래왔듯이, &lt;code&gt;ReaderWriterState[R, W, S, A]&lt;/code&gt; 또한 &lt;code&gt;ReaderWriterStateT[Id, R, W, S, A]&lt;/code&gt; 의 &lt;em&gt;type alias&lt;/em&gt; 입니다. &lt;code&gt;Reader&lt;/code&gt;, &lt;code&gt;Writer&lt;/code&gt;, &lt;code&gt;State&lt;/code&gt; 에서 사용했었던 함수들도 같이 제공됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type ReaderWriterState[-R, W, S, A] = ReaderWriterStateT[Id, R, W, S, A]
type ReaderWriterStateT[F[_], -R, W, S, A] = IndexedReaderWriterStateT[F, R, W, S, S, A]

object ReaderWriterState extends ReaderWriterStateTInstances with ReaderWriterStateTFunctions {
  def apply[R, W, S, A](f: (R, S) =&amp;gt; (W, A, S)): ReaderWriterState[R, W, S, A] = IndexedReaderWriterStateT[Id, R, W, S, S, A] { (r: R, s: S) =&amp;gt; f(r, s) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;apply&lt;/code&gt; 를 보면, &lt;code&gt;ReaderWriterState&lt;/code&gt; 는 타입 &lt;code&gt;(R, S) =&amp;gt; (W, A, S)&lt;/code&gt; 함수를 넘겨주어 생성할 수 있습니다. &lt;code&gt;Reader&lt;/code&gt;, &lt;code&gt;State&lt;/code&gt; 를 받고, &lt;code&gt;Writer&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; (결과값), &lt;code&gt;State&lt;/code&gt; 를 돌려주는 것으로 해석할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ReadwrWriterState.flatMap&lt;/code&gt; 은 &lt;code&gt;State&lt;/code&gt;, &lt;code&gt;Writer&lt;/code&gt;, &lt;code&gt;Reader&lt;/code&gt; 의 &lt;code&gt;flatMap&lt;/code&gt; 을 모두 조합한것처럼 생겼습니다. 하는일도 그렇구요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;/** A monad transformer stack yielding `(R, S1) =&amp;gt; F[(W, A, S2)]`. */
sealed abstract class IndexedReaderWriterStateT[F[_], -R, W, -S1, S2, A] {

  ...

  def flatMap[B, RR &amp;lt;: R, S3](f: A =&amp;gt; IndexedReaderWriterStateT[F, RR, W, S2, S3, B])(implicit F: Bind[F], W: Semigroup[W]): IndexedReaderWriterStateT[F, RR, W, S1, S3, B] =
    new IndexedReaderWriterStateT[F, RR, W, S1, S3, B] {
      def run(r: RR, s1: S1): F[(W, B, S3)] = {
        F.bind(self.run(r, s1)) {
          case (w1, a, s2) =&amp;gt; {
            F.map(f(a).run(r, s2)) {
              case (w2, b, s3) =&amp;gt; (W.append(w1, w2), b, s3)
            }
          }
        }
      }
    }

  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala#L4&#34;&gt;Scalaz - IndexedReaderWriterStateT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/ReaderWriterStateT.scala#L179&#34;&gt;Scalaz - ReaderWriterStateTMonad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rwst-example&#34;&gt;RWST Example&lt;/h2&gt;

&lt;p&gt;예제를 위해 간단한 모델을 만들어 보겠습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Reader&lt;/code&gt; 로 &lt;code&gt;DatabaseConfig&lt;/code&gt; 를&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Writer&lt;/code&gt; 로 &lt;code&gt;Vector[String]&lt;/code&gt; 을&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State&lt;/code&gt; 로 &lt;code&gt;Connection&lt;/code&gt; 을 이용하고&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결과값으로 타입 &lt;code&gt;A&lt;/code&gt; 를 돌려주는 &lt;code&gt;Task[A]&lt;/code&gt; 를 만들면 아래와 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Database {
  type Task[A] = ReaderWriterState[DatabaseConfig, Vector[String] /* log */, Connection, A]
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기에 몇 가지 제약조건을 걸어보겠습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DatabaseConfig.operationTimeoutMillis&lt;/code&gt; 에 의해서 타임아(&lt;code&gt;OperationTimeoutException&lt;/code&gt;) 발생&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OperationTimeoutException&lt;/code&gt; 발생시, 연산을 즉시 중단하고, 오류 없이 수행이 되었을 경우 &lt;em&gt;commit&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Post Commit Action&lt;/em&gt; 등록을 할 수 있어야 하며, &lt;em&gt;commit&lt;/em&gt; 후 순차대로 자동 실행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 필요한 몇몇 클래스를 만들고&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type Action = () =&amp;gt; Unit
case class PostCommitAction(id: String, action: Action)
case class DatabaseConfig(operationTimeoutMillis: Long)
case class ResultSet() /* dummy */

case class Connection(id: String,
                      actions: List[PostCommitAction] = Nil) {

  def commit = {}
  def executeAndReturn(query: String): ResultSet = ResultSet()
  def execute(query: String): Unit = {}
}

class OperationTimeoutException private(ex: RuntimeException) extends RuntimeException(ex) {
  def this(message:String) = this(new RuntimeException(message))
  def this(message:String, throwable: Throwable) = this(new RuntimeException(message, throwable))
}

object OperationTimeoutException {
  def apply(message:String) = new OperationTimeoutException(message)
  def apply(message:String, throwable: Throwable) = new OperationTimeoutException(message, throwable)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 사용자가 API 를 사용하는 것을 한번 상상해보겠습니다. &lt;em&gt;commit&lt;/em&gt; 이 어쨌건, 사용자가 하고싶은 일은 쿼리를 실행해서 결과값을 받아오거나, 필요한 &lt;em&gt;post commit action&lt;/em&gt; 을 등록하는 일일겁니다. 나머지는 다 알아서 해주겠거니 하고 기대하고 있겠지요. 아래와 같은 API 가 있다면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def createTask[A](f: Connection =&amp;gt; A): Task[A]
def addPostCommitAction(action: Action): Task[Unit]
def run[A](task: Task[A]): Option[A]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;사용자들이 이런 방식으로 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Person(name: String, address: Address)
case class Address(street: String)

def getPerson(name: String): Task[Person] = createTask { conn =&amp;gt;
  val rs: ResultSet = conn.executeAndReturn(s&amp;quot;SELECT * FROM USER WHERE name == &#39;$name&#39;&amp;quot;)

  /* get a person using the result set */
  ...
}

def updateAddress(person : Person): Task[Unit] = createTask { conn =&amp;gt;
  /* do something */
  conn.execute(
    s&amp;quot;UPDATE ADDRESS SET street = &#39;${person.address.street}&#39; where person_name = &#39;${person.name}&#39;&amp;quot;)
}

val getAndUpdatePersonTask: Task[Person] = for {
  p &amp;lt;- getPerson(&amp;quot;1ambda&amp;quot;)
  updatedP = p.copy(address = Address(&amp;quot;BACON STREET 234&amp;quot;))
  _ &amp;lt;- addPostCommitAction(() =&amp;gt; println(&amp;quot;post commit action1&amp;quot;))
  _ &amp;lt;- updateAddress(updatedP)
  _ &amp;lt;- addPostCommitAction(() =&amp;gt; println(&amp;quot;post commit action2&amp;quot;))
} yield updatedP

val person: Option[Person] = Database.run(getAndUpdatePersonTask)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 상상했던 함수를 구현해 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/1ambda/scala/blob/master/learning-scalaz/src/main/scala/readerwriterstate/Database.scala

import java.util.UUID
import scalaz._, Scalaz._
import Database._
import com.github.nscala_time.time.Imports._

object Database {

  ...
  object Implicit {
    implicit def defaultConnection: Connection = Connection(genRandomUUID)
    implicit def defaultConfig = DatabaseConfig(500)
  }

  private def genRandomUUID: String = UUID.randomUUID().toString

  private def execute[A](f: =&amp;gt; A, conf: DatabaseConfig): A = {
    val start = DateTime.now

    val a = f

    val end = DateTime.now

    val time: Long = (start to end).millis

    if (time &amp;gt; conf.operationTimeoutMillis)
      throw OperationTimeoutException(s&amp;quot;Operation timeout: $time millis&amp;quot;)

    a
  }

  def createTask[A](f: Connection =&amp;gt; A): Task[A] =
    ReaderWriterState { (conf, conn) =&amp;gt;
      val a = execute(f(conn), conf)
      (Vector(s&amp;quot;Task was created with connection[${conn.id}]&amp;quot;), a, conn)
    }

  def addPostCommitAction(action: Action): Task[Unit] =
    ReaderWriterState { (conf, conn: Connection) =&amp;gt;

      val postCommitAction = PostCommitAction(genRandomUUID, action)
      (Vector(s&amp;quot;Add PostCommitAction(${postCommitAction.id})&amp;quot;),
        Unit,
        conn.copy(actions = conn.actions :+ postCommitAction))
    }

  def run[A](task: Task[A])
            (implicit defaultConf: DatabaseConfig, defaultConn: Connection): Option[A] = {

    \/.fromTryCatchThrowable[(Vector[String], A, Connection), Throwable](
      task.run(defaultConf, defaultConn)
    ) match {
      case -\/(t) =&amp;gt;
        println(s&amp;quot;Operation failed due to ${t.getMessage}&amp;quot;) /* logging */
        none[A]

      case \/-((log: Vector[String], a: A, conn: Connection)) =&amp;gt;
        conn.commit /* close connection */

        log.foreach { text =&amp;gt; println(s&amp;quot;[LOG] $text&amp;quot;)} /* logging */

        /* run post commit actions */
        conn.actions foreach { _.action() }

        a.some
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 실제로 &lt;em&gt;500 ms&lt;/em&gt; 를 초과하는 연산을 실행하면, 예외가 발생하는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  test(&amp;quot;Database example&amp;quot;) {

    val slowQuery: Task[Person] = createTask { conn =&amp;gt;
      sleep(600)
      Person(&amp;quot;Sherlock&amp;quot;, Address(&amp;quot;BACON ST 221-B&amp;quot;))
    }

    val getPeopleTask: Task[List[Person]] = for {
      p1 &amp;lt;- getPerson(&amp;quot;Mycroft&amp;quot;)
      p2 &amp;lt;- getPerson(&amp;quot;Watson&amp;quot;)
      p3 &amp;lt;- slowQuery
      _ &amp;lt;- addPostCommitAction(() =&amp;gt; println(&amp;quot;post commit1&amp;quot;))
    } yield p1 :: p2 :: p3 :: Nil

    import Database.Implicit._
    val people = Database.run(getPeopleTask)

    // log: Operation failed due to java.lang.RuntimeException: Operation timeout: 603 millis
    people shouldBe None
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;previous-posts&#34;&gt;Previous Posts&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://1ambda.github.io/easy-scalaz-1-state/&#34;&gt;Easy Scalaz 1, State&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://1ambda.github.io/easy-scalaz-2-monad-transformer/&#34;&gt;Easy Scalaz 2, Monad Transformer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cs.lth.se/edan40&#34;&gt;Haskell Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://coderwall.com/p/ye_s_w/tooling-the-reader-monad&#34;&gt;Tooling The Reader Monad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/&#34;&gt;Reader Monad For Dependency Injection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://slides.com/danielbedo/reader-monad&#34;&gt;Slideshare: Reader Monad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.haskell.org/Typeclassopedia&#34;&gt;Typeclassopedia Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.scala-lang.org/overviews/collections/performance-characteristics.html&#34;&gt;Scala Collection Performance Characteristics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Easy Scalaz 5</title>
      <link>https://1ambda.github.io/21/scala/easy-scalaz-5/</link>
      <pubDate>Sat, 02 Jan 2016 00:16:47 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/easy-scalaz-5/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;yoneda-coyoneda-free-and-trampoline&#34;&gt;Yoneda, Coyoneda, Free and Trampoline&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Free[F, A]&lt;/code&gt; 를 이용하면 Functor &lt;code&gt;F&lt;/code&gt; 를 Monad 인스턴스로 만들 수 있습니다. 그런데, &lt;code&gt;Coyoneda[G, A]&lt;/code&gt; 를 이용하면 아무 타입 &lt;code&gt;G&lt;/code&gt; 나 Functor 인스턴스로 만들 수 있으므로 어떤 타입이든 (심지어 방금 만든 &lt;em&gt;case class&lt;/em&gt; 조차) 모나드 인스턴스로 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Free&lt;/code&gt; 를 이용하면 사용자는 자신만의 &lt;em&gt;Composable DSL&lt;/em&gt; 을 구성하고, 구성한 모나딕 연산을 실행하는 해석기를 작성하게 됩니다. 즉, &lt;strong&gt;연산의 생성&lt;/strong&gt; 과 &lt;strong&gt;연산의 실행&lt;/strong&gt; 을 분리하여 다루게 됩니다. 이는 &lt;em&gt;side-effect&lt;/em&gt; 를 실행 시점으로 미룰 수 있다는 뜻입니다. (실행용 해석기와 별도로 테스트용 해석기를 작성하는 것도 가능합니다)&lt;/p&gt;

&lt;p&gt;그러면, 제가 가장 좋아하는 &lt;a href=&#34;http://tpolecat.github.io/assets/sbtb-slides.pdf&#34;&gt;Programs as Values: Fure Functional JDBC Programming&lt;/a&gt; 예 로 시작해보겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;if-we-have-a-monad&#34;&gt;If We Have a Monad&lt;/h2&gt;

&lt;p&gt;JDBC 를 쌩으로 사용한다면, 다음과 같은 코드를 작성해야 할텐데&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// ref - http://tpolecat.github.io/

case class Person(name: String, age: Int)

def getPerson(rs: ResultSet): Person {
  val name = rs.getString(1)
  val age  = rs.getInt(2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음과 같은 문제점이 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;managed resource&lt;/em&gt; 인 &lt;code&gt;ResultSet&lt;/code&gt; 을 프로그래머가 다룰 수 있습니다. 어디에 저장이라도 하고 나중에 사용한다면 문제가 될 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rs.get*&lt;/code&gt; 은 &lt;em&gt;side-effect&lt;/em&gt; 를 만들어 내므로 테스트하기 쉽지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;접근 방식을 바꿔보는건 어떨까요? 프로그램을 실행해서 &lt;em&gt;side-effect&lt;/em&gt; 를 즉시 만드는 대신&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;어떤 연산을 수행할지를 &lt;em&gt;case class&lt;/em&gt; 로 만들고 이것들을 조합해 어떤 연산을 수행할지 나타낸뒤에&lt;/li&gt;
&lt;li&gt;연산의 조합을 번역해 실행하는 해석기(&lt;em&gt;interpreter&lt;/em&gt;) 를 만들어 보겠습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저 연산부터 정의하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sealed trait ResultSetOp[A]

final case class GetString(index: Int) extends ResultSetOp[String]
final case class GetInt(index: Int)    extends ResultSetOp[Int]
final case object Next                 extends ResultSetOp[Boolean]
final case object Close                extends ResultSetOp[Unit]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 때 만약 &lt;code&gt;ResultSetOp[A]&lt;/code&gt; 가 모나드라면 다음과 같이 작성할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def getPerson: ResultSetOp[Person] = for {
  name &amp;lt;- GetString(1)
  age  &amp;lt;- GetInt(2)
} yield Person(name, age)

// Application Operation `*&amp;gt;`  (e.g `1.some *&amp;gt; 2.some== 2.some)
// See, http://eed3si9n.com/learning-scalaz/Applicative.html
def getNextPerson: ResultSetOp[Person] =
  Next *&amp;gt; getPerson

def getPeople(n: Int): ResultSet[List[Person]] =
  getNextPerson.repicateM(n) // List.fill(n)(getNextPerson).sequence

def getAllPeople: ResultSetIO[Vector[Person]] =
  getPerson.whileM[Vector](Next)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ResultSetIO&lt;/code&gt; 는 모나드가 아니므로 위와 같이 작성할 수 없습니다.&lt;/p&gt;

&lt;h3 id=&#34;writing-your-own-dsl&#34;&gt;Writing Your own DSL&lt;/h3&gt;

&lt;p&gt;놀랍게도, &lt;code&gt;ResultSetIO&lt;/code&gt; 를 모나드로 만들 수 있습니다. &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;unit&lt;/code&gt; 구현 없이 얻을 수 있는 공짜 모나드입니다. 방법은 이렇습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Free[F[_], ?]&lt;/code&gt; 는 &lt;code&gt;Functor&lt;/code&gt; &lt;code&gt;F&lt;/code&gt; 에 대해 &lt;code&gt;Monad&lt;/code&gt; 입니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Coyoneda[S[_], ?]&lt;/code&gt; 는 아무 타입 &lt;code&gt;S&lt;/code&gt; 에 대해 &lt;code&gt;Functor&lt;/code&gt; 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 &lt;code&gt;Free[Coyoneda[S, A], A&lt;/code&gt; 는 아무 타입 &lt;code&gt;S&lt;/code&gt; 에 대해서 모나드입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scalaz.{Free, Coyoneda}, Free._

// ResultSetOpCoyo is the Functor
type ResultSetOpCoyo[A] = Coyoneda[ResultSetOp, A]

// ResultSetIO is the Monad
type ResultSetIO[A] = Free[ResultSetOpCoyo, A]

// same as
// type ResultSetIO2[A] = Free[({ type λ[α] = Coyoneda[ResultSetOp, α]})#λ, A]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 다음처럼 작성할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val next                 : ResultSetIO[Boolean] = Free.liftFC(Next)
def getString(index: Int): ResultSetIO[String]  = Free.liftFC(GetString(index))
def getInt(index: Int)   : ResultSetIO[Int]     = Free.liftFC(GetInt(index))
def close                : ResultSetIO[Unit]    = Free.liftFC(Close)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;Free.listFC&lt;/code&gt; 는 타입 &lt;code&gt;ResultSetOp&lt;/code&gt; 를 바로 &lt;code&gt;ResultSetIO&lt;/code&gt; 로 리프팅 해주는 헬퍼 함수입니다. (&lt;code&gt;F&lt;/code&gt; = &lt;em&gt;Free&lt;/em&gt;, &lt;code&gt;C&lt;/code&gt; = &lt;em&gt;Coyoneda&lt;/em&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Free.scala#L30

/** A version of `liftF` that infers the nested type constructor. */
def liftFU[MA](value: =&amp;gt; MA)(implicit MA: Unapply[Functor, MA]): Free[MA.M, MA.A] =
  liftF(MA(value))(MA.TC)

/** A free monad over a free functor of `S`. */
def liftFC[S[_], A](s: S[A]): FreeC[S, A] =
    liftFU(Coyoneda lift s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;liftFU[MA]&lt;/code&gt; 에서, &lt;code&gt;MA = Coyoneda[ResultSetOp, A]&lt;/code&gt; 로 보면 &lt;code&gt;Free[MA.M, MA.A]&lt;/code&gt; 는 &lt;code&gt;Free[Coyoneda[ResultSetOp, A], A]&lt;/code&gt; 가 됩니다. (&lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Unapply.scala#L51&#34;&gt;Unapply.scala&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;이를 이용해서 &lt;code&gt;get*&lt;/code&gt; 를 작성해 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scalaz._, Scalaz._

def getPerson: ResultSetIO[Person] = for {
  name &amp;lt;- getString(1)
  age  &amp;lt;- getInt(2)
} yield Person(name, age)

def getNextPerson: ResultSetIO[Person] =
  next *&amp;gt; getPerson

def getPeople(n: Int): ResultSetIO[List[Person]] =
  getNextPerson.replicateM(n) // List.fill(n)(getNextPerson).sequence

def getPersonOpt: ResultSetIO[Option[Person]] =
  next &amp;gt;&amp;gt;= {
    case true  =&amp;gt; getPerson.map(_.some)
    case false =&amp;gt; none.point[ResultSetIO]
  }

def getAllPeople: ResultSetIO[Vector[Person]] =
  getPerson.whileM[Vector](next)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dsl-interpreter&#34;&gt;DSL Interpreter&lt;/h3&gt;

&lt;p&gt;이제 &lt;code&gt;RestSetOp&lt;/code&gt; 로 작성한 연산 (일종의 프로그램) 을 실행하려면, &lt;code&gt;ResetSetOp&lt;/code&gt; 명령(&lt;em&gt;case class&lt;/em&gt;) 을, 로직(&lt;em&gt;side-effect&lt;/em&gt; 를 유발할 수 있는) 으로 변경해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NaturalTransformation&lt;/code&gt; 을 이용할건데, &lt;code&gt;F ~&amp;gt; G&lt;/code&gt; 는 &lt;code&gt;F&lt;/code&gt; 를 &lt;code&gt;G&lt;/code&gt; 로 변경하는 변환(&lt;em&gt;Transformation&lt;/em&gt;) 을 의미합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/package.scala#L113

/** A [[scalaz.NaturalTransformation]][F, G]. */
type ~&amp;gt;[-F[_], +G[_]] = NaturalTransformation[F, G]

// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/NaturalTransformation.scala#L14
/** A universally quantified function, usually written as `F ~&amp;gt; G`,
  * for symmetry with `A =&amp;gt; B`.
  *
  * Can be used to encode first-class functor transformations in the
  * same way functions encode first-class concrete value morphisms;
  * for example, `sequence` from [[scalaz.Traverse]] and `cosequence`
  * from [[scalaz.Distributive]] give rise to `([a]T[A[a]]) ~&amp;gt;
  * ([a]A[T[a]])`, for varying `A` and `T` constraints.
  */
trait NaturalTransformation[-F[_], +G[_]] {
  self =&amp;gt;
  def apply[A](fa: F[A]): G[A]

  def compose[E[_]](f: E ~&amp;gt; F): E ~&amp;gt; G = new (E ~&amp;gt; G) {
    def apply[A](ea: E[A]) = self(f(ea))
  }

  def andThen[H[_]](f: G ~&amp;gt; H): F ~&amp;gt; H =
    f compose self
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제, &lt;code&gt;ResultSetOp&lt;/code&gt; 를 &lt;code&gt;IO&lt;/code&gt; 로 변경하는 해석기를 작성하면, (&lt;a href=&#34;http://eed3si9n.com/learning-scalaz/IO+Monad.html&#34;&gt;Learning Scalaz - IO&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scalaz.effect._

private def interpret(rs: ResultSet) = new (ResultSetOp ~&amp;gt; IO) {
    def apply[A](fa: ResultSetOp[A]): IO[A] = fa match {
      case Next         =&amp;gt; IO(rs.next)
      case GetString(i) =&amp;gt; IO(rs.getString(i))
      case GetInt(i)    =&amp;gt; IO(rs.getInt(i))
      case Close        =&amp;gt; IO(rs.close)
      // more...
    }
}

def run[A](a: ResultSetIO[A], rs: ResultSet): IO[A] =
  Free.runFC(a)(interpret(rs))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;why-free&#34;&gt;Why Free?&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Free&lt;/code&gt; 가 제공하는 가치는 다음과 같습니다. (Ref - &lt;a href=&#34;http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern&#34;&gt;StackExchange&lt;/a&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It is a lightweight way of &lt;strong&gt;creating a domain-specific language that gives you an AST&lt;/strong&gt;, and then having &lt;strong&gt;one or more interpreters&lt;/strong&gt; to &lt;strong&gt;execute the AST&lt;/strong&gt; however you like&lt;/li&gt;
&lt;li&gt;The free monad part is just a handy way to get an AST that you can assemble using Haskell&amp;rsquo;s standard monad facilities (like do-notation) without having to write lots of custom code. This also ensures that your DSL is composable&lt;/li&gt;
&lt;li&gt;You could then interpret this however you like: run it against a live database, run it against a mock, just log the commands for debugging or even try optimizing the queries&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, &lt;code&gt;Free&lt;/code&gt; 는 우리는 자신만의 Composable 한 DSL 을 구축하고, 필요에 따라 이 DSL 다른 방식으로 해석할 수 있도록 도와주는 도구입니다.&lt;/p&gt;

&lt;h2 id=&#34;free&#34;&gt;Free&lt;/h2&gt;

&lt;p&gt;(&lt;code&gt;Free&lt;/code&gt; 와 &lt;code&gt;Yoneda&lt;/code&gt; 는 난해할 수 있으니, &lt;code&gt;Free&lt;/code&gt; 를 어떻게 사용하는지만 알고 싶다면 &lt;a href=&#34;http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/#reasonablypricedmonad&#34;&gt;Reasonably Priced Monad&lt;/a&gt; 로 넘어가시면 됩니다.)&lt;/p&gt;

&lt;p&gt;어떻게 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 이기만 하면 &lt;code&gt;Free[F[_], ?]&lt;/code&gt; 가 모나드가 되는걸까요? 이를 알기 위해선, 모나드가 어떤 구조로 이루어져 있는지 알 필요가 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;monad&#34;&gt;Monad&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;A monad is just a monoid in the category of endofunctors, what&amp;rsquo;s the problem?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;del&gt;의사양반 이게 무슨소리요!&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;Monoid&lt;/code&gt; 와 &lt;code&gt;Functor&lt;/code&gt; 가 무엇인지 알아봅시다.&lt;/p&gt;

&lt;h2 id=&#34;monoid&#34;&gt;Monoid&lt;/h2&gt;

&lt;p&gt;어떤 합 &lt;code&gt;S&lt;/code&gt; 에 대한 닫힌 연산 &lt;code&gt;*&lt;/code&gt;, 집합 내의 어떤 원소 &lt;code&gt;e&lt;/code&gt; 가 다음을 만족할 경우 모노이드라 부릅니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;e * a = a = a * e&lt;/code&gt; (&lt;em&gt;identity&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(a * b) * c = a * (b * c)&lt;/code&gt; (&lt;em&gt;associativity&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 &lt;code&gt;e&lt;/code&gt; 를 항등원이라 부릅니다. &lt;code&gt;Option[A]&lt;/code&gt; 도 &lt;code&gt;None&lt;/code&gt; 을 항등원으로 사용하고, &lt;em&gt;associativity&lt;/em&gt; 를 만족하는 &lt;code&gt;A&lt;/code&gt; 의 연산을 사용하면 모노이드입니다. 따라서 &lt;code&gt;A&lt;/code&gt; 가 모노이드면 &lt;code&gt;Option[A]&lt;/code&gt; 도 모노이드입니다. (활용법은 &lt;a href=&#34;http://www.slideshare.net/oxbow_lakes/practical-scalaz&#34;&gt;Practical Scalaz&lt;/a&gt; 참조)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&amp;gt; load.ivy(&amp;quot;org.scalaz&amp;quot; % &amp;quot;scalaz-core_2.11&amp;quot; % &amp;quot;7.2.0-M5&amp;quot;)
&amp;gt; import scalaz._, Scalaz._


&amp;gt; 1.some |+| 2.some
res11: Option[Int] = Some(3)
&amp;gt; 1.some |+| none
res12: Option[Int] = Some(1)
&amp;gt; none[Int] |+| 1.some
res13: Option[Int] = Some(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;functor&#34;&gt;Functor&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Functor&lt;/code&gt; 는 일반적으로 다음처럼 정의되는데, 이는 &lt;code&gt;Functor F&lt;/code&gt; 가 &lt;code&gt;F&lt;/code&gt; 에서 값을 꺼내, 함수를 적용해 값을 변경할 수 있다는 것을 의미©니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A functor may go from one category to a different one&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A =&amp;gt; B): F[B]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;Functor&lt;/code&gt; 는 &lt;em&gt;identity function&lt;/em&gt; 을 항등원으로 사용하면, 모노이드입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;F.map(x =&amp;gt; x) == F&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F map f map g == F map (f compose g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 때, 변환의 인풋과 아웃풋이 같은 카테고리라면 이 &lt;code&gt;Functor&lt;/code&gt; 를 &lt;em&gt;endo-functor&lt;/em&gt; 라 부릅니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A functor may go from one category to a different one, an endofunctor is a functor for which start and target category are the same.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;monad-1&#34;&gt;Monad&lt;/h2&gt;

&lt;p&gt;그럼 다시 처음 문장으로 다시 돌아가면,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Monads are just monoids in the category of endofunctors&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 것의 의미를 이해하려면 모나드가 무엇인지 알아야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Monad[F[_]] {
  def point[A](a: A): F[A]
  def join[A](ffa: F[F[A]): F[A]
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;일반적으로는 &lt;code&gt;point&lt;/code&gt; (=&lt;code&gt;return&lt;/code&gt;) 와 &lt;code&gt;bind&lt;/code&gt; (= &lt;code&gt;flatMap&lt;/code&gt;) 으로 모나드를 정의하나, &lt;code&gt;join&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt; 으로도 &lt;code&gt;bind&lt;/code&gt; 를 정할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

trait Monad[F[_]] {
  def point[A](a: A): F[A]
  def bind[A, B](fa: F[A])(f: A =&amp;gt; F[B]): F[B]

  def map[A, B](fa: F[A])(f: A =&amp;gt; B): F[B] =
    bind(fa)(a =&amp;gt; point(f(a))
  def join[A](ffa: F[F[A]): F[A] =
    bind(ffa)(fa =&amp;gt; fa)
}

trait Monad[F[_]] {
  def map[A, B](fa: F[A])(f: A =&amp;gt; B): F[B]
  def point[A](a: A): F[A]
  def join[A](ffa: F[F[A]): F[A] /* flatten*/

  def bind[A, B](fa: F[A])(f: A =&amp;gt; F[B]): F[B] =
    join(map(fa)(f))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt;, &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;join&lt;/code&gt; 관점에서 모나드를 바라보면,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;(endo)functor&lt;/strong&gt; &lt;code&gt;T : X → X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;natural transformation&lt;/strong&gt; &lt;code&gt;μ : T × T → T&lt;/code&gt; (where &lt;code&gt;×&lt;/code&gt; means functor composition (also known as &lt;code&gt;join&lt;/code&gt; in Haskell)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;natural transformation&lt;/strong&gt;  &lt;code&gt;η : I → T&lt;/code&gt; (where &lt;code&gt;I&lt;/code&gt; is the identity endofunctor on &lt;code&gt;X&lt;/code&gt; also known as &lt;code&gt;return&lt;/code&gt; in Haskell)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이때 위 연산들이 모노이드 법칙을 만족합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;e * a = a = a * e&lt;/code&gt; (&lt;em&gt;identity&lt;/em&gt;)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;(a * b) * c = a * (b * c)&lt;/code&gt; (&lt;em&gt;associativity&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;μ(η(T)) = T = μ(T(η))&lt;/code&gt; (&lt;em&gt;identity&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;μ(μ(T × T) × T)) = μ(T × μ(T × T))&lt;/code&gt; (&lt;em&gt;associativity&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스칼라 코드로 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&amp;gt; import scalaz._, Scalaz._

&amp;gt; val A = List(1, 2)
List[Int] = List(1, 2)

// identity left-side: μ(η(T)) = T
&amp;gt; A.map(x =&amp;gt; Monad[List].point(x)).flatten
List[Int] = List(1, 2)

// identity right-side: μ(T(η)) = T
&amp;gt; Monad[List].point(A).flatten
List[Int] = List(1, 2)

// associativity
&amp;gt; val T = List(1, 2, 3, 4)
T: List[Int] = List(1, 2, 3, 4)
&amp;gt; val TT = T.map(List(_))
TT: List[List[Int]] = List(List(1), List(2), List(3), List(4))

// associativity left-side: μ(μ(T × T) × T))
&amp;gt; TT.flatten.map(List(_))
res30: List[List[Int]] = List(List(1), List(2), List(3), List(4))
&amp;gt; TT.flatten.map(List(_)).flatten
res31: List[Int] = List(1, 2, 3, 4)

// associativity right-side: μ(T × μ(T × T))
&amp;gt; List(TT.flatten)
res34: List[List[Int]] = List(List(1, 2, 3, 4))
&amp;gt; List(TT.flatten).flatten
res35: List[Int] = List(1, 2, 3, 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 *Monad*는 &lt;em&gt;(endo)Functor&lt;/em&gt; 카테고리에 대한 &lt;em&gt;Monoid&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;h2 id=&#34;free-monoid&#34;&gt;Free Monoid&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Free Monad&lt;/em&gt; 가 &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;point&lt;/code&gt; 에 대한 구현 없이, 모나드가 되듯이 &lt;em&gt;Free Monoid&lt;/em&gt; 또한 연산과 항등원에 대한 구현 없이 &lt;em&gt;구조적&lt;/em&gt; 으로 모노이드입니다.&lt;/p&gt;

&lt;p&gt;항등원과 연산을 &lt;code&gt;Zero&lt;/code&gt;, &lt;code&gt;Append&lt;/code&gt; 라는 이름으로 &lt;em&gt;구조화&lt;/em&gt; 하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

sealed trait FreeMonoid[+A]
final case object Zero extends FreeMonoid[Nothing]
final case class Value[A](a: A) extends FreeMonoid[A]
final case class Append[A](l: FreeMonoid[A], r: FreeMonoid[A]) extends FreeMonoid[A]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;모노이드는 &lt;em&gt;associativity&lt;/em&gt; 를 만족하므로, &lt;code&gt;Append&lt;/code&gt; 를 우측 결합으로 바꾸고, &lt;code&gt;Zero&lt;/code&gt; 로 끝나도록 하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

sealed trait FreeMonoid[+A]
final case object Zero extends FreeMonoid[Nothing]
final case class Append[A](l: A, r: FreeMonoid[A]) extends FreeMonoid[A]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;List&lt;/code&gt; 와 동일한 구조임을 알 수 있습니다. 실제로, 리스트는 &lt;em&gt;concatenation&lt;/em&gt; 연산, &lt;code&gt;Nil&lt;/code&gt; 항등원에 대해 모노이드입니다.&lt;/p&gt;

&lt;h2 id=&#34;free-monad&#34;&gt;Free Monad&lt;/h2&gt;

&lt;p&gt;이제까지의 내용을 정리하면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Monad is a monoid of functors&lt;/li&gt;
&lt;li&gt;Then, &lt;strong&gt;Free Monad is a free Monoid of functors&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 &lt;em&gt;Free Monad&lt;/em&gt; 는 &lt;em&gt;Functor&lt;/em&gt; 의 &lt;em&gt;List&lt;/em&gt; 라 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;모나드의 &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;join&lt;/code&gt; 을 &lt;em&gt;구조화&lt;/em&gt; (&lt;em&gt;타입화&lt;/em&gt;) 하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def point[A](a: A): F[A]
def join[A, B](ffa: F[F[A]): F[A]

sealed trait Free[F[_], A]
case class Point[F[_], A](a: A) extends Free[F, A]             // == Return
case class Join[F[_], A](ffa: F[Free[F, A]]) extends Free[F, A] // == Suspend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 을 타입화 하는 대신, &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 라면 다음처럼 &lt;code&gt;Free.point&lt;/code&gt;, &lt;code&gt;Free.flatMap&lt;/code&gt; 을 작성할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sealed trait Free[F[_], A] {
  def point[F[_]](a: A): Free[F, A] = Point(a)
  def flatMap[B](f: A =&amp;gt; Free[F, B])(implicit functor: Functor[F]): Free[F, B] =
    this match {
      case Point(a)  =&amp;gt; f(a)
      case Join(ffa) =&amp;gt; Join(ffa.map(fa =&amp;gt; fa.flatMap(f)))
    }
  def map[B](f: A =&amp;gt; B)(implicit functor: Functor[F]): Free[F, B] =
    flatMap(a =&amp;gt; Point(f(a)))
}

case class Point[F[_], A](a: A) extends Free[F, A]
case class Join[F[_], A](ff: F[Free[F, A]]) extends Free[F, A]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fa.flatMap(f)&lt;/code&gt; 의 결과가 &lt;code&gt;Free[F, B]&lt;/code&gt; 고 &lt;code&gt;ffa.map&lt;/code&gt; 의 결과로 들어가므로, &lt;code&gt;ffa.map(_ flatMap f)&lt;/code&gt; 의 결과는 &lt;code&gt;F[Free[F, B]&lt;/code&gt; 입니다. 이걸 &lt;code&gt;Free[F, B]&lt;/code&gt; 로 바꾸려면 &lt;code&gt;Join&lt;/code&gt; 을 이용하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이런 이유에서, &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 면 &lt;code&gt;Free[F, A]&lt;/code&gt; 는 &lt;code&gt;Monad&lt;/code&gt; 입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 리프팅과 실행을 위한 헬퍼 함수를 만들면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

import scalaz.{Functor, Monad, ~&amp;gt;}

def liftF[F[_], A](a: =&amp;gt; F[A])(implicit F: Functor[F]): Free[F, A] =
  Join(F.map(a)(Point[F, A]))

def foldMap[F[_], M[_], A](fm: Free[F, A])(f: F ~&amp;gt; M)
                          (implicit FI: Functor[F], MI: Monad[M]): M[A] =
  fm match {
    case Point(a) =&amp;gt; MI.pure(a)
    case Join(ffa) =&amp;gt; MI.bind(f(ffa))(fa =&amp;gt; foldMap(fa)(f))
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;F ~&amp;gt; M&lt;/code&gt; 는 &lt;code&gt;F&lt;/code&gt; 를 &lt;code&gt;M&lt;/code&gt; 으로 변환해주는, &lt;em&gt;NaturalTransformation&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

type ~&amp;gt;[-F[_], +G[_]] = NaturalTransformation[F, G]

trait NaturalTransformation[-F[_], +G[_]] {
  self =&amp;gt;
  def apply[A](fa: F[A]): G[A]

  def compose[E[_]](f: E ~&amp;gt; F): E ~&amp;gt; G = new (E ~&amp;gt; G) {
    def apply[A](ea: E[A]) = self(f(ea))
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MI.bind(f(ffa))&lt;/code&gt; 의 결과는 &lt;code&gt;M[Free[F, A]]&lt;/code&gt; 이므로 여기에서 &lt;code&gt;bind&lt;/code&gt; (= &lt;code&gt;flatMap&lt;/code&gt;) 로 &lt;code&gt;fa&lt;/code&gt; 를 얻어, 재귀적으로 &lt;code&gt;foldMap&lt;/code&gt; 을 호출합니다.&lt;/p&gt;

&lt;h3 id=&#34;scalaz-free-implementation&#34;&gt;Scalaz Free Implementation&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def flatMap[B](f: A =&amp;gt; Free[F, B])(implicit functor: Functor[F]): Free[F, B] =
    this match {
      case Point(a)  =&amp;gt; f(a)
      case Join(ffa) =&amp;gt; Join(ffa.map(fa =&amp;gt; fa.flatMap(f)))
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Scalaz 에서는 &lt;code&gt;flatMap&lt;/code&gt; 호출시 Stack 비용이 생각보다 크므로, &lt;code&gt;flatMap&lt;/code&gt; 자체도 타입화하고 있습니다. 즉, Stack 대신에 Heap 을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Point&lt;/code&gt; 대신, &lt;code&gt;Return&lt;/code&gt;, &lt;code&gt;Join&lt;/code&gt; 대신 &lt;code&gt;Suspend&lt;/code&gt;, &lt;code&gt;FlatMap&lt;/code&gt; 대신 &lt;code&gt;GoSub&lt;/code&gt; 라는 타입 이름으로 구현되어 있습니다. (이해를 돕기 위해 7.x 대신, 6.0.4 버전을 차용)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/release/6.0.4/core/src/main/scala/scalaz/Free.scala

final case class Return[S[+_], +A](a: A) extends Free[S, A]
final case class Suspend[S[+_], +A](a: S[Free[S, A]]) extends Free[S, A]
final case class Gosub[S[+_], A, +B](a: Free[S, A],
                                     f: A =&amp;gt; Free[S, B]) extends Free[S, B]
sealed trait Free[S[+_], +A] {
  final def map[B](f: A =&amp;gt; B): Free[S, B] =
    flatMap(a =&amp;gt; Return(f(a)))

  final def flatMap[B](f: A =&amp;gt; Free[S, B]): Free[S, B] = this match {
    case Gosub(a, g) =&amp;gt; Gosub(a, (x: Any) =&amp;gt; Gosub(g(x), f))
    case a           =&amp;gt; Gosub(a, f)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;trampoline&#34;&gt;Trampoline&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Free&lt;/code&gt; 를 이용하면, Stackoverflow 를 피할 수 있습니다. 이는 &lt;code&gt;Free&lt;/code&gt; 가 &lt;code&gt;flatMap&lt;/code&gt; 체인에서 스택 대신 힙을 이용하는 것을 응용한 것인데요,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/release/6.0.4/core/src/main/scala/scalaz/Free.scala

/** A computation that can be stepped through, suspended, and paused */
type Trampoline[+A] = Free[Function0, A]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이때 &lt;code&gt;Function0&lt;/code&gt; 도 &lt;code&gt;Functor&lt;/code&gt; 이므로,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit Function0Functor: Functor[Function0] = new Functor[Function0] {
  def fmap[A, B](f: A =&amp;gt; B)(fa: Function0[A]): Function0[B] =
    () =&amp;gt; f(fa)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Free[Function0, A]&lt;/code&gt; 도 모나드입니다.&lt;/p&gt;

&lt;p&gt;이제 스칼라에서 스택오버플로우가 발생하는 &lt;em&gt;mutual recursion&lt;/em&gt; 코드를 만들어 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

def isOdd(n: Int): Boolean = {
  if (0 == n) false
  else isEven(n -1)
}

def isEven(n: Int): Boolean = {
  if (0 == n) true
  else isOdd(n -1)
}

isOdd(10000) // stackoverflow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;Trampoline&lt;/code&gt; 을 이용하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf

import scalaz._, Scalaz._, Free._

def isOddT(n: Int): Trampoline[Boolean] =
  if (0 == n) return_(false)
  else suspend(isEvenT(n - 1))

def isEvenT(n: Int): Trampoline[Boolean] =
  if (0 == n) return_(true)
  else suspend(isOddT(n - 1))

scala&amp;gt; isOddT(2000000).run
res7: Boolean = false

scala&amp;gt; isOddT(2000001).run
res8: Boolean = true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;return_&lt;/code&gt; 과 &lt;code&gt;suspend&lt;/code&gt; 는 다음처럼 정의되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Free.scala#L15

trait FreeFunctions {

  ...
  def return_[S[_], A](value: =&amp;gt; A)(implicit S: Applicative[S]): Free[S, A] =
    Suspend[S, A](S.point(Return[S, A](value)))

  def suspend[S[_], A](value: =&amp;gt; Free[S, A])(implicit S: Applicative[S]): Free[S, A] =
    Suspend[S, A](S.point(value))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;yoneda-coyoneda&#34;&gt;Yoneda, Coyoneda&lt;/h2&gt;

&lt;p&gt;포스트의 시작 부분에서 &lt;code&gt;Coyoneda&lt;/code&gt; 에 대한 언급을 기억하시나요?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Free[F[_], ?]&lt;/code&gt; 는 &lt;code&gt;Functor&lt;/code&gt; &lt;code&gt;F&lt;/code&gt; 에 대해 &lt;code&gt;Monad&lt;/code&gt; 입니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Coyoneda[S[_], ?]&lt;/code&gt; 는 아무 타입에 대해 &lt;code&gt;Functor&lt;/code&gt; 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Coyoneda&lt;/code&gt; 가 어떻게 &lt;code&gt;Functor&lt;/code&gt; 를 만들어내는지 확인해 보겠습니다. 이 과정에서 &lt;em&gt;dual&lt;/em&gt; 인 &lt;code&gt;Yoneda&lt;/code&gt; 도 같이 살펴보겠습니다. (같은 &lt;em&gt;Category&lt;/em&gt; 내에서, &lt;em&gt;morphism&lt;/em&gt; 방향만 다른 경우)&lt;/p&gt;

&lt;p&gt;먼저, &lt;code&gt;Yoneda&lt;/code&gt;, &lt;code&gt;Coyoneda&lt;/code&gt; 의 기본적인 내용을 훑고 가면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Yoneda&lt;/code&gt;, &lt;code&gt;Coyoneda&lt;/code&gt; 는 &lt;code&gt;Functor&lt;/code&gt; 입니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Yoneda[F[_], A]&lt;/code&gt;, &lt;code&gt;Coyoneda[F[_], A]&lt;/code&gt; 는 &lt;code&gt;F[A]&lt;/code&gt; 와 &lt;em&gt;isomorphic&lt;/em&gt; 입니다 (&lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 일 경우)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Yoneda[F, A]&lt;/code&gt; 에서 &lt;code&gt;F[A]&lt;/code&gt; 로의 &lt;em&gt;homomorphism&lt;/em&gt; 은 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 가 아닐 경우에도 존재합니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F[A]&lt;/code&gt; 에서 &lt;code&gt;Coyoneda[F, A]&lt;/code&gt; 로의 &lt;em&gt;homomorphism&lt;/em&gt; 은 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 가 아닐 경우에도 존재합니다 (중요)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Yoneda&lt;/code&gt;, &lt;code&gt;Coyoneda&lt;/code&gt; 모두 &lt;code&gt;Functor&lt;/code&gt; 가 필요한 시점을 미루³ , &lt;code&gt;Functor.map&lt;/code&gt; 의 체인을, 일반 함수의 체인으로 표현합니다. 결국엔 &lt;code&gt;Functor&lt;/code&gt; 가 필요합니다 (중요)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/4-yoneda-and-free/iso_vs_homo_morphism.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;(Image - &lt;a href=&#34;http://evolvingthoughts.net/2010/08/homology-and-analogy/&#34;&gt;http://evolvingthoughts.net/2010/08/homology-and-analogy/&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;즉 &lt;code&gt;Coyoneda[F[_], A]&lt;/code&gt; 가  &lt;code&gt;F&lt;/code&gt; 와 상관없이 &lt;code&gt;Functor&lt;/code&gt; 인 이유는, &lt;code&gt;F[A] -&amp;gt; Coyoenda[F[_], A]&lt;/code&gt; 로의 변환이 &lt;code&gt;F&lt;/code&gt; &lt;code&gt;Functor&lt;/code&gt; 인 것과 상관이 없으며 &lt;code&gt;Coyoneda&lt;/code&gt; 자체가 &lt;code&gt;Functor&lt;/code&gt; 인스턴스이기 때문입니다.&lt;/p&gt;

&lt;p&gt;추상은 간단합니다. &lt;code&gt;Functor[F]&lt;/code&gt; 가 &lt;code&gt;F[A] -&amp;gt; F[B]&lt;/code&gt; 로의 변환을 &lt;code&gt;f: A =&amp;gt; B&lt;/code&gt; 만 가지고 해 낼 수 있다는 점을 역이용하면 됩니다. &lt;code&gt;F[A]&lt;/code&gt; 에 &lt;code&gt;Functor.map(f)&lt;/code&gt; 를 적용하는 것이 아니라, 값 &lt;code&gt;A&lt;/code&gt; 가 있을 때 &lt;code&gt;f(a)&lt;/code&gt; 를 적용한 뒤에, &lt;code&gt;F[B]&lt;/code&gt; 를 만들면 됩니다. 다시 말해&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Functor[F]&lt;/code&gt; 는 &lt;code&gt;F[A]&lt;/code&gt; 와 &lt;code&gt;f: A =&amp;gt; B&lt;/code&gt;, &lt;code&gt;g: B = &amp;gt; C&lt;/code&gt; 가 가 있을 때 &lt;code&gt;Functor[F].map(f compose g)&lt;/code&gt; 대신&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f compose g&lt;/code&gt; 를 먼저 하고, 이것의 결과값인 &lt;code&gt;C&lt;/code&gt; 를 이용해 &lt;code&gt;F[C]&lt;/code&gt; 를 만들면 됩니다. 그러면 &lt;code&gt;Functor[F].map&lt;/code&gt; 연산을 함수의 컴포지션으로 해결할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;yoneda&#34;&gt;Yoneda&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/Yoneda.scala

abstract class Yoneda[F[_], A] { yo =&amp;gt;
  def apply[B](f: A =&amp;gt; B): F[B]

  def run: F[A] = apply(a =&amp;gt; a)

  def map[B](f: A =&amp;gt; B): Yoneda[F, B] = new Yoneda[F, B] {
    override def apply[C](g: (B) =&amp;gt; C): F[C] = yo(f andThen g)
  }
}

/** `F[A]` converts to `Yoneda[F, A]` for any functor `F` */
def apply[F[_]: Functor, A](fa: F[A]): Yoneda[F, A] = new Yoneda[F, A] {
  override def apply[B](f: A =&amp;gt; B): F[B] = Functor[F].map(fa)(f)
}

/** `Yoneda[F, A]` converts to `F[A` for any `F` */
def from[F[_], A](yo: Yoneda[F, A]): F[A] =
  yo.run

/** `Yoneda[F, _]` is a functor for any `F` */
implicit def yonedaFunctor[F[_]]: Functor[({ type  λ[α] = Yoneda[F,α]})#λ] =
  new Functor[({type λ[α] = Yoneda[F, α]})#λ] {
    override def map[A, B](ya: Yoneda[F, A])(f: A =&amp;gt; B): Yoneda[F, B] =
      ya map f
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Yoneda[F[_], ?]&lt;/code&gt; 는 그 자체로 &lt;code&gt;Functor&lt;/code&gt; 이나 이를 만들기 위해선 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 여야 합니다. 반면 &lt;code&gt;Yoneda[F, A] -&amp;gt; F[A]&lt;/code&gt; 로의 변환은 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 이던 아니던 상관 없습니다.&lt;/p&gt;

&lt;h3 id=&#34;coyoneda&#34;&gt;Coyoneda&lt;/h3&gt;

&lt;p&gt;그렇다면, &lt;em&gt;dual&lt;/em&gt; 인 &lt;code&gt;Coyoneda&lt;/code&gt; 는 어떨까요? &lt;code&gt;Yoneda&lt;/code&gt; &lt;code&gt;F[A]&lt;/code&gt; 를 &lt;code&gt;Functor&lt;/code&gt; 로 부터 얻는것이 아니라, &lt;em&gt;Identity&lt;/em&gt; 를 이용해, 처음부터 &lt;code&gt;F[A]&lt;/code&gt; 를 가지고 있습니다. 이로 부터 얻어지는 결론은 놀랍습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sealed abstract class Coyoneda[F[_], A] { coyo =&amp;gt;
  type I
  val fi: F[I]
  val k: I =&amp;gt; A

  final def map[B](f: A =&amp;gt; B): Aux[F, I, B] =
    apply(fi)(f compose k)

  final def run(implicit F: Functor[F]): F[A] =
    F.map(fi)(k)
}

type Aux[F[_], A, B] = Coyoneda[F, B] { type I = A }

def apply[F[_], A, B](fa: F[A])(_k: A =&amp;gt; B): Aux[F, A, B] =
  new Coyoneda[F, B] {
    type I = A
    val k = _k
    val fi = fa
  }

/** `F[A]` converts to `Coyoneda[F, A]` for any `F` */
def lift[F[_], A](fa: F[A]): Coyoneda[F, A] = apply(fa)(identity[A])

/** `Coyoneda[F, A]` converts to `F[A]` for any Functor `F` */
def from[F[_], A](coyo: Coyoneda[F, A])(implicit F: Functor[F]): F[A] =
  F.map(coyo.fi)(coyo.k)

/** `CoyoYoneda[F, _]` is a functor for any `F` */
implicit def coyonedaFunctor[F[_]]: Functor[({ type  λ[α] = Coyoneda[F,α]})#λ] =
  new Functor[({type λ[α] = Coyoneda[F, α]})#λ] {
    override def map[A, B](ca: Coyoneda[F, A])(f: A =&amp;gt; B): Coyoneda[F, B] =
      ca.map(f)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;code&gt;Coyoneda[F[_], ?]&lt;/code&gt; 를 만들기 위해서 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;Functor&lt;/code&gt; 일 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/24000465/step-by-step-deep-explain-the-power-of-coyoneda-preferably-in-scala-throu&#34;&gt;Stackoverflow - The Power of (Co)yoneda&lt;/a&gt; 에선 다음처럼 설명합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype Yoneda f a = Yoneda { runYoneda :: forall b . (a -&amp;gt; b) -&amp;gt; f b }

instance Functor (Yoneda f) where
  fmap f y = Yoneda (\ab -&amp;gt; runYoneda y (ab . f))

data CoYoneda f a = forall b . CoYoneda (b -&amp;gt; a) (f b)

instance Functor (CoYoneda f) where
  fmap f (CoYoneda mp fb) = CoYoneda (f . mp) fb
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;So instead of appealing to the &lt;code&gt;Functor&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; during definition of the &lt;code&gt;Functor&lt;/code&gt; instance for &lt;code&gt;Yoneda&lt;/code&gt;, it gets &lt;strong&gt;&amp;ldquo;defered&amp;rdquo;&lt;/strong&gt; to the construction of the &lt;code&gt;Yoneda&lt;/code&gt; itself. Computationally, it also has the nice property of turning all &lt;code&gt;fmaps&lt;/code&gt; into compositions with the &amp;ldquo;continuation&amp;rdquo; function (&lt;code&gt;a -&amp;gt; b&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The opposite occurs in &lt;code&gt;CoYoneda&lt;/code&gt;. For instance, &lt;code&gt;CoYoneda f&lt;/code&gt; is still a &lt;code&gt;Functor&lt;/code&gt; whether or not &lt;code&gt;f&lt;/code&gt; is. Also we again notice the property that &lt;code&gt;fmap&lt;/code&gt; is nothing more than composition along the eventual continuation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So both of these are a way of &amp;ldquo;ignoring&amp;rdquo; a &lt;code&gt;Functor&lt;/code&gt; requirement for a little while, especially while performing &lt;code&gt;fmap&lt;/code&gt;s.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;reasonably-priced-monad&#34;&gt;Reasonably Priced Monad&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;for comprehension&lt;/em&gt; 내에서는 단 하나의 모나드 밖에 쓸 수 없습니다. &lt;del&gt;단칸방 세입자 모나드&lt;/del&gt; &lt;em&gt;Monad Transformer&lt;/em&gt; 등을 사용하긴 하는데 ¶편하기 짝이 없지요.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Rúnar Bjarnason&lt;/em&gt; 은 &lt;a href=&#34;https://www.parleys.com/tutorial/composable-application-architecture-reasonably-priced-monads&#34;&gt;Composable application architecture with reasonably priced monads
&lt;/a&gt; 에서 &lt;code&gt;Coproduct&lt;/code&gt; 를 이용해 &lt;code&gt;Free&lt;/code&gt; 를 조합하는 법을 소개합니다. (&lt;strong&gt;이 비디오는 꼭 보셔야합니다!&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;요약하면 &lt;code&gt;Free&lt;/code&gt; 를 이용해 생성한 서로 다른 두개의 모나드는 같은 &lt;em&gt;for comprehension&lt;/em&gt; 내에서 사용할 수 없습니다. 이 때 &lt;code&gt;Coproduct&lt;/code&gt; 를 이용해서 하나의 타입으로 묶고, 타입 자동 주입을 위해 &lt;code&gt;Inject&lt;/code&gt; 를 이용하면 많은 코드 없이도, 편리하게 &lt;code&gt;Free&lt;/code&gt; 를 이용할 수 있다는 것입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 다음과 처럼 두개의 프리 모나드 &lt;code&gt;Interact&lt;/code&gt;, &lt;code&gt;Auth&lt;/code&gt; 가 있을 때&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Interact
trait InteractOp[A]
final case class Ask(prompt: String) extends InteractOp[String]
final case class Tell(msg: String)   extends InteractOp[Unit]

type CoyonedaInteract[A] = Coyoneda[InteractOp, A]
type Interact[A] = Free[CoyonedaInteract, A]

def ask(prompt: String) = liftFC(Ask(prompt))
def tell(msg: String) = liftFC(Tell(msg))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Auth
case class User(userId: UserId, permissions: Set[Permission])

sealed trait AuthOp[A]
final case class Login(userId: UserId, password: Password) extends AuthOp[Option[User]]
final case class HasPermission(user: User, permission: Permission) extends AuthOp[Boolean]

type CoyonedaAuth[A] = Coyoneda[AuthOp, A]
type Auth[A] = Free[CoyonedaAuth, A]

def login(userId: UserId, password: Password): FreeC[F, Option[User]] =
  liftFC(Login(userId, password))

def hasPermission(user: User, permission: Permission): FreeC[F, Boolean] =
  liftFC(HasPermission(user, permission))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Log

sealed trait LogOp[A]
final case class Warn(message: String)  extends LogOp[Unit]
final case class Error(message: String) extends LogOp[Unit]
final case class Info(message: String)  extends LogOp[Unit]

type CoyonedaLog[A] = Coyoneda[LogOp, A]
type Log[A] = Free[CoyonedaLog, A]

object Log {
  def warn(message: String)  = liftFC(Warn(message))
  def info(message: String)  = liftFC(Info(message))
  def error(message: String) = liftFC(Error(message))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음처럼 같은 &lt;em&gt;for comprehension&lt;/em&gt; 구문에서 사용할 수 없습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// doesn&#39;t compile

for {
  userId &amp;lt;- ask(&amp;quot;Insert User ID: &amp;quot;)
  password &amp;lt;- ask(&amp;quot;Password: &amp;quot;)
  user &amp;lt;- login(userId, password)
  _ &amp;lt;- info(s&amp;quot;user $userId logged in&amp;quot;)
  hasPermission &amp;lt;- user.cata(
    none = point(false),
    some = hasPermission(_, &amp;quot;scalaz repository&amp;quot;)
  )
  _ &amp;lt;- warn(s&amp;quot;$userId has no permission for scalaz repository&amp;quot;)
} yield hasPermission
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 때 &lt;code&gt;Coproduct&lt;/code&gt; 를 이용하면, 가능합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// combine free monads
type Language0[A] = Coproduct[InteractOp, AuthOp, A]
type Language[A] = Coproduct[LogOp, Language0, A]
type LanguageCoyo[A] = Coyoneda[Language, A]
type LanguageMonad[A] = Free[LanguageCoyo, A]
def point[A](a: =&amp;gt; A): FreeC[Language, A] = Monad[LanguageMonad].point(a)

// combine interpreters
val interpreter0: Language0 ~&amp;gt; Id = or(InteractInterpreter, AuthInterpreter)
val interpreter: Language ~&amp;gt; Id = or(LogInterpreter, interpreter0)

// run a program
def main(args: Array[String]) {
  def program(implicit I: Interact[Language], A: Auth[Language], L: Log[Language]) = {
    import I._, A._, L._

    for {
      userId &amp;lt;- ask(&amp;quot;Insert User ID: &amp;quot;)
      password &amp;lt;- ask(&amp;quot;Password: &amp;quot;)
      user &amp;lt;- login(userId, password)
      _ &amp;lt;- info(s&amp;quot;user $userId logged in&amp;quot;)
      hasPermission &amp;lt;- user.cata(
        none = point(false),
        some = hasPermission(_, &amp;quot;scalaz repository&amp;quot;)
      )
      _ &amp;lt;- warn(s&amp;quot;$userId has no permission for scalaz repository&amp;quot;)
    } yield hasPermission
  }

  program.mapSuspension(Coyoneda.liftTF(interpreter))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;or&lt;/code&gt; 과 &lt;code&gt;lift&lt;/code&gt; 는 라이브러리 코드라 생각하시면 됩니다. 이제 변화된 프리 모나드 부분을 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Auth {
  type UserId = String
  type Password = String
  type Permission = String

  implicit def instance[F[_]](implicit I: Inject[AuthOp, F]): Auth[F] =
    new Auth
}

class Auth[F[_]](implicit I: Inject[AuthOp, F]) {
  import Common._
  def login(userId: UserId, password: Password): FreeC[F, Option[User]] =
    lift(Login(userId, password))

  def hasPermission(user: User, permission: Permission): FreeC[F, Boolean] =
    lift(HasPermission(user, permission))
}

class Interact[F[_]](implicit I: Inject[InteractOp, F]) {
  import Common._

  def ask(prompt: String): FreeC[F, String] =
    lift(Ask(prompt))

  def tell(message: String): FreeC[F, Unit] =
    lift(Tell(message))
}

object Interact {
  implicit def instance[F[_]](implicit I: Inject[InteractOp, F]): Interact[F] =
    new Interact
}

class Log[F[_]](implicit I: Inject[LogOp, F]) {
  import Common._

  def warn(message: String)  = lift(Warn(message))
  def info(message: String)  = lift(Info(message))
  def error(message: String) = lift(Error(message))
}

object Log {
  implicit def instant[F[_]](implicit I: Inject[LogOp ,F]) =
    new Log
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제, &lt;code&gt;Common&lt;/code&gt; 을 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Common {
  import scalaz.Coproduct, scalaz.~&amp;gt;

  def or[F[_], G[_], H[_]](f: F ~&amp;gt; H, g: G ~&amp;gt; H): ({type cp[α] = Coproduct[F,G,α]})#cp ~&amp;gt; H =
    new NaturalTransformation[({type cp[α] = Coproduct[F,G,α]})#cp,H] {
      def apply[A](fa: Coproduct[F,G,A]): H[A] = fa.run match {
        case -\/(ff) ⇒ f(ff)
        case \/-(gg) ⇒ g(gg)
      }
    }

  def lift[F[_], G[_], A](fa: F[A])(implicit I: Inject[F, G]): FreeC[G, A] =
    Free.liftFC(I.inj(fa))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Coproduct[F, G, A]&lt;/code&gt; 는 &lt;strong&gt;둘 중 하나&lt;/strong&gt; 를 의미하는 추상입니다. 결과로 &lt;code&gt;F[A] \/ G[A]&lt;/code&gt; (&lt;em&gt;scalaz either&lt;/em&gt;) 을 돌려줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Coproduct.scala

final case class Coproduct[F[_], G[_], A](run: F[A] \/ G[A]) {
  ...
}

trait CoproductFunctions {
  def leftc[F[_], G[_], A](x: F[A]): Coproduct[F, G, A] =
    Coproduct(-\/(x))

  def rightc[F[_], G[_], A](x: G[A]): Coproduct[F, G, A] =
    Coproduct(\/-(x))

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Inject[F[_], G[_]]&lt;/code&gt; 는 &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt; 를 포함하는 더 큰 타입인 &lt;code&gt;Coproduct&lt;/code&gt; 를 만들때 쓰입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def lift[F[_], G[_], A](fa: F[A])(implicit I: Inject[F, G]): FreeC[G, A] =
  Free.liftFC(I.inj(fa))

// F == Langauge
class Log[F[_]](implicit I: Inject[LogOp, F]) {
  def warn(message: String)  = lift(Warn(message))
  def info(message: String)  = lift(Info(message))
  def error(message: String) = lift(Error(message))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Inject&lt;/code&gt; 는 이렇게 생겼습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Inject.scala

sealed abstract class Inject[F[_], G[_]] {
  def inj[A](fa: F[A]): G[A]
  def prj[A](ga: G[A]): Option[F[A]]
}

sealed abstract class InjectInstances {
  implicit def reflexiveInjectInstance[F[_]] =
    new Inject[F, F] {
      def inj[A](fa: F[A]) = fa
      def prj[A](ga: F[A]) = some(ga)
    }

  implicit def leftInjectInstance[F[_], G[_]] =
    new Inject[F, ({type λ[α] = Coproduct[F, G, α]})#λ] {
      def inj[A](fa: F[A]) = Coproduct.leftc(fa)
      def prj[A](ga: Coproduct[F, G, A]) = ga.run.fold(some(_), _ =&amp;gt; none)
    }

  implicit def rightInjectInstance[F[_], G[_], H[_]](implicit I: Inject[F, G]) =
      new Inject[F, ({type λ[α] = Coproduct[H, G, α]})#λ] {
        def inj[A](fa: F[A]) = Coproduct.rightc(I.inj(fa))
        def prj[A](ga: Coproduct[H, G, A]) = ga.run.fold(_ =&amp;gt; none, I.prj(_))
      }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt; 타입만 맞추어 주면 &lt;code&gt;Inject&lt;/code&gt; 인스턴스는 자동으로 생성됩니다.&lt;/p&gt;

&lt;p&gt;다음시간에는 &lt;em&gt;side-effect&lt;/em&gt; 의 세계로 넘어가 &lt;code&gt;ST&lt;/code&gt;, &lt;code&gt;IO&lt;/code&gt; 등을 살펴보겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;previous-posts&#34;&gt;Previous Posts&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://1ambda.github.io/easy-scalaz-1-state/&#34;&gt;Easy Scalaz 1, State&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://1ambda.github.io/easy-scalaz-2-monad-transformer/&#34;&gt;Easy Scalaz 2, Monad Transformer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/&#34;&gt;Easy Scalaz 3, ReaderWriterState with Kleisli&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cs.lth.se/edan40&#34;&gt;Haskell Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tpolecat.github.io/assets/sbtb-slides.pdf&#34;&gt;Programs as Values: Fure Functional JDBC Programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.higher-order.com/blog/2013/11/01/free-and-yoneda/&#34;&gt;Free Monads and the Yoneda Lemma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/24000465/step-by-step-deep-explain-the-power-of-coyoneda-preferably-in-scala-throu&#34;&gt;Stackoverflow - The Power of (Co) Yoneda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern&#34;&gt;Stack Exchange - What is the Free Monad + Interpreter Pattern?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.functionalvilnius.lt/meetups/meetups/2015-04-29-functional-vilnius-03/freemonads.pdf&#34;&gt;Free Monad is Free Monoid + Functor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://underscore.io/blog/posts/2015/04/23/deriving-the-free-monad.html&#34;&gt;Underscore - Deriving the Free Monad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html&#34;&gt;Underscore - Free Monads Are Simple&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/10342876/differences-between-functors-and-endofunctors&#34;&gt;Stackoverflow - Difference between functors and endofuctors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem/3870310#3870310&#34;&gt;Stackoverflow - A monad is just monoid in the categy of endofuctors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://evolvingthoughts.net/2010/08/homology-and-analogy/&#34;&gt;Isomorphism vs Homomorphism Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.parleys.com/tutorial/composable-application-architecture-reasonably-priced-monads&#34;&gt;Composable application architecture with reasonably priced monads
&lt;/a&gt;(&lt;a href=&#34;https://gist.github.com/runarorama/a8fab38e473fafa0921d&#34;&gt;Gist: Code&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Easy Scalaz 6</title>
      <link>https://1ambda.github.io/21/scala/easy-scalaz-6/</link>
      <pubDate>Fri, 01 Jan 2016 00:16:53 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/easy-scalaz-6/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/easy-scalaz/1-state/haskell.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;playing-with-monoids&#34;&gt;Playing with Monoids&lt;/h2&gt;

&lt;p&gt;이번 글에서는 모노이드를 가지고 놀면서, 아래 나열된 라이브러리 및 언어적 특성을 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Boolean Monoid operations with &lt;strong&gt;&lt;a href=&#34;https://github.com/non/spire&#34;&gt;Spire&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Algebraic Data Types using &lt;strong&gt;&lt;a href=&#34;http://docs.scala-lang.org/overviews/core/value-classes.html&#34;&gt;Value Class&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Tag.scala&#34;&gt;Scalaz.Tag&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Creating Monoid for all subclasses using &lt;strong&gt;&lt;a href=&#34;https://github.com/milessabin/shapeless&#34;&gt;Shapeless&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;http://docs.scala-lang.org/tutorials/FAQ/context-and-view-bounds.html&#34;&gt;Context Bound&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://danielwestheide.com/blog/2013/02/13/the-neophytes-guide-to-scala-part-13-path-dependent-types.html&#34;&gt;Path Dependent Type&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;monoid&#34;&gt;Monoid&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/#monoid&#34;&gt;Easy Scalaz 4 - Yoneda and Free Monad: Monoid&lt;/a&gt; 부분에서 발췌하면,&lt;/p&gt;

&lt;p&gt;어떤 집합 &lt;code&gt;S&lt;/code&gt; 에 대한 닫힌 연산 &lt;code&gt;*&lt;/code&gt;, 집합 내의 어떤 원소 &lt;code&gt;e&lt;/code&gt; 가 다음을 만족할 경우 모노이드라 부릅니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;e * a = a = a * e&lt;/code&gt; (&lt;em&gt;identity&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(a * b) * c = a * (b * c)&lt;/code&gt; (&lt;em&gt;associativity&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 &lt;code&gt;e&lt;/code&gt; 를 항등원이라 부릅니다. &lt;code&gt;Option[A]&lt;/code&gt; 도 &lt;code&gt;None&lt;/code&gt; 을 항등원으로 사용하고, &lt;em&gt;associativity&lt;/em&gt; 를 만족하는 &lt;code&gt;A&lt;/code&gt; 의 연산을 사용하면 모노이드입니다. 따라서 &lt;code&gt;A&lt;/code&gt; 가 모노이드면 &lt;code&gt;Option[A]&lt;/code&gt; 도 모노이드입니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Scalaz&lt;/em&gt; 에서는 모노이드 연산 &lt;code&gt;*&lt;/code&gt; 를, &lt;code&gt;|+|&lt;/code&gt; 로 표시합니다. 우리가 알고 있는 &lt;em&gt;primitives&lt;/em&gt; 대부분이 모노이드입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&amp;gt; load.ivy(&amp;quot;org.scalaz&amp;quot; % &amp;quot;scalaz-core_2.11&amp;quot; % &amp;quot;7.2.0-M5&amp;quot;)

&amp;gt; import scalaz._, Scalaz._
import scalaz._, Scalaz._
&amp;gt; implicitly[Monoid[String]]
res4: Monoid[String] = scalaz.std.StringInstances$stringInstance$@5590d10f
&amp;gt; implicitly[Monoid[Int]]
res5: Monoid[Int] = scalaz.std.AnyValInstances$$anon$5@4b9f2522
&amp;gt; implicitly[Monoid[Set[Int]]]
res6: Monoid[Set[Int]] = scalaz.std.SetInstances$$anon$3@5b1965ea

&amp;gt; &amp;quot;1&amp;quot; |+| &amp;quot;2&amp;quot;
res7: String = &amp;quot;12&amp;quot;
&amp;gt; 1.0 |+| 2.0
Compilation Failed
Main.scala:1459: value |+| is not a member of Double
1.0 |+| 2.0
    ^
&amp;gt; 1 |+| 2
res8: Int = 3

&amp;gt; 1.some |+| 2.some
res11: Option[Int] = Some(3)
&amp;gt; 1.some |+| none
res12: Option[Int] = Some(1)
&amp;gt; none[Int] |+| 1.some
res13: Option[Int] = Some(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Map[A, B]&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 를 &lt;em&gt;Key&lt;/em&gt; 로 잡고, &lt;code&gt;B&lt;/code&gt; 의 모노이드 연산과 항등원을 이용하는 모노이드입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&amp;gt; val m1 = Map(&amp;quot;a&amp;quot; -&amp;gt; 1, &amp;quot;b&amp;quot; -&amp;gt; 2)
m1: Map[String, Int] = Map(&amp;quot;a&amp;quot; -&amp;gt; 1, &amp;quot;b&amp;quot; -&amp;gt; 2)
&amp;gt; val m2 = Map(&amp;quot;a&amp;quot; -&amp;gt; 1, &amp;quot;c&amp;quot; -&amp;gt; 2)
m2: Map[String, Int] = Map(&amp;quot;a&amp;quot; -&amp;gt; 1, &amp;quot;c&amp;quot; -&amp;gt; 2)
&amp;gt; m1 |+| m2
res16: Map[String, Int] = Map(&amp;quot;a&amp;quot; -&amp;gt; 2, &amp;quot;c&amp;quot; -&amp;gt; 2, &amp;quot;b&amp;quot; -&amp;gt; 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;boolean-monoid&#34;&gt;Boolean Monoid&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Boolean&lt;/code&gt; 의 경우에는, 두 가지 모노이드가 존재할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 를 연산으로 사용하고, &lt;code&gt;true&lt;/code&gt; 를 항등원으로 사용하는 경우&lt;/li&gt;
&lt;li&gt;&lt;code&gt;||&lt;/code&gt; 를 연산으로 사용하고, &lt;code&gt;false&lt;/code&gt; 를 항등원으로 사용하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;첫 번째를 &lt;em&gt;Conjunction&lt;/em&gt; 이라 부르고 두 번째를 &lt;em&gt;Disjunction&lt;/em&gt; 이라 부릅니다. 즉, &lt;code&gt;Boolean&lt;/code&gt; 은 두 개의 모노이드가 존재할 수 있기 때문에 아래처럼 &lt;em&gt;scalaz&lt;/em&gt; 의 &lt;code&gt;|+|&lt;/code&gt; 를 바로 이용할 수 없습니다. &lt;em&gt;Disjunction&lt;/em&gt; 인지 &lt;em&gt;Conjunction&lt;/em&gt; 인지 골라야 하기 때문입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&amp;gt; false |+| false
Compilation Failed
Main.scala:1468: value |+| is not a member of Boolean
false |+| false
      ^

// import 를 하지 않으면, scalaz.Tags.Disjunction 이 아니라 scalaz.Disjunction 을 사용하므로 주의
&amp;gt; import scalaz.Tags._
import scalaz.Tags._
&amp;gt; import scalaz.syntax.tag._
import scalaz.syntax.tag._
&amp;gt; Disjunction(false)
res22: Boolean @@ Disjunction = false
&amp;gt; Conjunction(false)
res23: Boolean @@ Conjunction = false

&amp;gt; implicitly[Monoid[Boolean @@ Disjunction]]
res27: Monoid[Boolean @@ Disjunction] = scalaz.std.AnyValInstances$$anon$7@79a6c868
&amp;gt; implicitly[Monoid[Boolean @@ Conjunction]]
res28: Monoid[Boolean @@ Conjunction] = scalaz.std.AnyValInstances$$anon$8@6e49df4a

&amp;gt; Disjunction(false) |+| Disjunction(true)
res29: Boolean @@ Disjunction = true
&amp;gt; Disjunction(true) |+| Disjunction(false)
res30: Boolean @@ Disjunction = true
&amp;gt; Conjunction(true) |+| Conjunction(true)
res31: Boolean @@ Conjunction = true
&amp;gt; Conjunction(true) |+| Conjunction(false)
res32: Boolean @@ Conjunction = false

&amp;gt; List(false, false, true, false)
res37: List[Boolean] = List(false, false, true, false)
&amp;gt; Disjunction.subst(res37).suml
res38: Boolean @@ Disjunction = true
&amp;gt; Conjunction.subst(res37).suml
res39: Boolean @@ Conjunction = false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실제로 &lt;code&gt;scalaz.std.AnyVal&lt;/code&gt; 을 확인해 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/std/AnyVal.scala#L52

object conjunction extends Monoid[Boolean] {
  def append(f1: Boolean, f2: =&amp;gt; Boolean) = f1 &amp;amp;&amp;amp; f2
  def zero: Boolean = true
}

object disjunction extends Monoid[Boolean] {
  def append(f1: Boolean, f2: =&amp;gt; Boolean) = f1 || f2
  def zero = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그렇다면 &lt;code&gt;Int&lt;/code&gt; 의 경우에도 &lt;code&gt;*&lt;/code&gt; 등 다른 ª¨노이드가 있는데 왜 &lt;code&gt;+&lt;/code&gt; 연산과 &lt;code&gt;0&lt;/code&gt; 항등원만 &lt;code&gt;|+|&lt;/code&gt; 에서 사용하는걸까요? 이는 &lt;code&gt;+&lt;/code&gt; 가 너무 보편적이기 때문이며, &lt;code&gt;*&lt;/code&gt; (곱셈) 등은 위에서 본 &lt;code&gt;Tag&lt;/code&gt; 를 이용해 모노이드 연산으로 지정할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;tag&#34;&gt;Tag&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Tags.scala

object Tags {

  ...

  /** Type tag to choose a [[scalaz.Monoid]] instance that selects the lesser of two operands, ignoring `zero`. */
  sealed trait Min

  val Min = Tag.of[Min]

  /** Type tag to choose a [[scalaz.Monoid]] instance that selects the greater of two operands, ignoring `zero`. */
  sealed trait Max

  val Max = Tag.of[Max]

  /** Type tag to choose a [[scalaz.Monoid]] instance for a numeric type that performs multiplication,
   *  rather than the default monoid for these types which by convention performs addition. */
  sealed trait Multiplication

  val Multiplication = Tag.of[Multiplication]

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Multiplication&lt;/code&gt; 을 이©하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&amp;gt; Multiplication(2) |+| Multiplication(6)
res3: Int @@ Multiplication = 12

&amp;gt; implicitly[Monoid[Int @@ Multiplication]]
res4: Monoid[Int @@ Multiplication] = scalaz.std.AnyValInstances$$anon$12@5910ca72
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;AnyValInstances&lt;/code&gt; 를 찾아보면 &lt;code&gt;byteMultiplicationNewType&lt;/code&gt;, &lt;code&gt;intMultiplicationNewType&lt;/code&gt; 등 &lt;code&gt;A @@ Multiplication&lt;/code&gt; 을 위한 인스턴스들이 구현되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/std/AnyVal.scala#L253

trait AnyValInstances {

  implicit val shortMultiplicationNewType: Monoid[Short @@ Multiplication] with Enum[Short @@ Multiplication] = new Monoid[Short @@ Multiplication] with Enum[Short @@ Multiplication] {
    ...
  }

  implicit val intMultiplicationNewType: Monoid[Int @@ Multiplication] with Enum[Int @@ Multiplication] = new Monoid[Int @@ Multiplication] with Enum[Int @@ Multiplication] {
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Tag&lt;/code&gt; 는 이렇게 생겼습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/package.scala#L99

package object scalaz {
  ...

  private[scalaz] type Tagged[A, T] = {type Tag = T; type Self = A}

  /**
   * Tag a type `T` with `Tag`.
   *
   * The resulting type is used to discriminate between type class instances.
   *
   * @see [[scalaz.Tag]] and [[scalaz.Tags]]
   *
   * Credit to Miles Sabin for the idea.
   */
  type @@[T, Tag] = Tagged[T, Tag]

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@@[A, T]&lt;/code&gt; 를 생성하기 위해 &lt;code&gt;Tag.apply&lt;/code&gt; 를 값을 추출하기 위해 &lt;code&gt;unwrap&lt;/code&gt; 을 이용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Tag.scala
object Tag {
  /** `subst` specialized to `Id`.
    *
    * @todo According to Miles, @specialized doesn&#39;t help here. Maybe manually specialize.
    */
  @inline def apply[@specialized A, T](a: A): A @@ T = a.asInstanceOf[A @@ T]

  /** `unsubst` specialized to `Id`. */
  @inline def unwrap[@specialized A, T](a: A @@ T): A = unsubst[A, Id, T](a)

  /** Add a tag `T` to `A`.
    *
    * NB: It is unsafe to `subst` or `unsubst` a tag in an `F` that is
    * sensitive to the `A` type within.  For example, if `F` is a
    * GADT, rather than a normal ADT, it is probably unsafe.  For
    * &amp;quot;normal&amp;quot; types like `List` and function types, it is safe.  More
    * broadly, if it is possible to write a &#39;&#39;legal&#39;&#39;
    * [[scalaz.InvariantFunctor]] over the parameter, `subst` of that
    * parameter is safe.
    *
    * We do not have a
    * &amp;lt;a href=&amp;quot;https://ghc.haskell.org/trac/ghc/wiki/Roles&amp;quot;&amp;gt;type role&amp;lt;/a&amp;gt;
    * system in Scala with which to declare the exact situations under
    * which `subst` is safe.  If we did, we would declare that `subst`
    * is safe if and only if the parameter has &amp;quot;representational&amp;quot; or
    * &amp;quot;phantom&amp;quot; role.
    */
  def subst[A, F[_], T](fa: F[A]): F[A @@ T] = fa.asInstanceOf[F[A @@ T]]

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Tag&lt;/code&gt; 는 &lt;a href=&#34;http://docs.scala-lang.org/overviews/core/value-classes.html&#34;&gt;&lt;em&gt;Value Class&lt;/em&gt;&lt;/a&gt; 처럼 활용할 수도 있는데요,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// http://eed3si9n.com/learning-scalaz/Tagged+type.html

sealed trait USD
sealed trait EUR
def USD[A](amount: A): A @@ USD = Tag[A, USD](amount)
def EUR[A](amount: A): A @@ EUR = Tag[A, EUR](amount)

val oneUSD = USD(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;태깅된 타입을 이용하면 &lt;em&gt;implicit&lt;/em&gt; 를 선택할 수 있습니다. 예를 들어&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit val anonymousUserWriter = Writer[User @@ Anonymous] { ... }
implicit val loggedInUserWriter  = Writer[User @@ LoggedIn]  { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러나 &lt;code&gt;type B = A @@ T&lt;/code&gt; 에서 &lt;code&gt;B&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 서브타입으로 취급되므로 주의하여 사용해야 합니다. 예를 들어, &lt;em&gt;scalatest&lt;/em&gt; 의 &lt;code&gt;===&lt;/code&gt;, &lt;code&gt;shouldBe&lt;/code&gt; 는 런타임값만 체크하므로 아래는 항상 참입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def convertUSDtoEUR[A](usd: A @@ USD, rate: A)
                      (implicit M: Monoid[A @@ Multiplication]): A @@ EUR =
  EUR((Multiplication(usd.unwrap) |+| Multiplication(rate)).unwrap)

convertUSDtoEUR(USD(1), 2) === EUR(2) // true
convertUSDtoEUR(USD(1), 2) === USD(2) // true

convertUSDtoEUR(USD(1), 2) shouldBe EUR(2) // true
convertUSDtoEUR(USD(1), 2) shouldBe USD(2) // true

2 shouldBe USD(2) // true
2 shouldBe EUR(2) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;code&gt;=:=&lt;/code&gt; 를 만들어 사용하면 &lt;code&gt;EUR&lt;/code&gt; 과 &lt;code&gt;USD&lt;/code&gt; 비교시 컴파일 예외를 발생시킬 수 있습니다. (더 정확히는 &lt;em&gt;scalaz&lt;/em&gt; 의 &lt;code&gt;===&lt;/code&gt; 또는 &lt;code&gt;org.scalactic.TypeCheckedTripleEquals&lt;/code&gt; 를 사용하면 되는데, &lt;code&gt;org.scalactic.TripleEqualSupports&lt;/code&gt; 를 &lt;code&gt;FunSuite&lt;/code&gt;  내에서 하이딩 시킬 방법을 찾지 못해서 아래처럼 구현했습니다.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// impilcit class 로 만들고 import 해서 사용해도 상관없음
trait TestImplicits {
  final case class StrictEqualOps[A](val a: A) {
    def =:=(aa: A) = assert(a == aa)
    def =/=(aa: A) = assert(!(a == aa))
  }

  implicit def toStrictEqualOps[A](a: A) = StrictEqualOps(a)
}

// spec
convertUSDtoEUR(USD(1), 2) =:= EUR(2)
convertUSDtoEUR(USD(1), 2) =:= EUR(3) // will fail
convertUSDtoEUR(USD(1), 2) =:= USD(3) // compile error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Tag&lt;/code&gt; 을 이용하면 같은 &lt;em&gt;primitive type&lt;/em&gt; 이어도 별도의 &lt;em&gt;wrapper&lt;/em&gt; 를 §들지 않으면서 다른 타입으로 만들 수 있습니다. 예를 들어 &lt;code&gt;Job&lt;/code&gt; 을 &lt;code&gt;Agent&lt;/code&gt; 가 수행한다고 하면, 다음과 같이 간단한 모델을 만들어 볼 수 있는데&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// ref - http://www.slideshare.net/IainHull/improving-correctness-with-types

case class Agent(id: String, /* agent id */
                 status: String, /* agent status */
                 jobType: String)

case class Job(id: String, /* job id */
               maybeAgentId: Option[String], /* agent id */
               status: String, /* job status */
               jobType: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;em&gt;Sum&lt;/em&gt; 을 먼저 추출하면, (&lt;em&gt;Algebraic Data Type&lt;/em&gt; 관련해서는 &lt;a href=&#34;https://gleichmann.wordpress.com/2011/02/05/functional-scala-algebraic-datatypes-sum-and-product-types/&#34;&gt;Sum and Product&lt;/a&gt; 참조)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sealed abstract class AgentStatus(val value: String)
case object Waiting    extends AgentStatus(&amp;quot;WAITING&amp;quot;)
case object Processing extends AgentStatus(&amp;quot;PROCESSING&amp;quot;)

sealed abstract class JobStatus(val value: String)
case object Created   extends JobStatus(&amp;quot;CREATED&amp;quot;)
case object Allocated extends JobStatus(&amp;quot;ALLOCATED&amp;quot;)
case object Completed extends JobStatus(&amp;quot;COMPLETED&amp;quot;)

sealed abstract class JobType(val value: String)
case object Small extends JobType(&amp;quot;SMALL&amp;quot;)
case object Large extends JobType(&amp;quot;LARGE&amp;quot;)
case object Batch extends JobType(&amp;quot;BATCH&amp;quot;)

case class Agent(id: String, /* agent id */
                 status: AgentStatus,
                 jobType: JobType)

case class Job(id: String, /* job id */
               maybeAgentId: Option[String], /* agent id */
               status: JobStatus,
               jobType: JobType)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 오류의 소지가 다분한 &lt;code&gt;id&lt;/code&gt; 에 태깅을 하면 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scalaz._

case class Agent(id: String @@ Agent,
                 status: AgentStatus,
                 jobType: JobType)

case class Job(id: String @@ Job,
               maybeAgentId: Option[String @@ Agent],
               status: JobStatus,
               jobType: JobType)

Agent(Tag[String, Agent](&amp;quot;03&amp;quot;), Waiting, Small)
Job(Tag[String, Job](&amp;quot;03&amp;quot;), None, Created, Small)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;조금 더 개선할 여지는, &lt;code&gt;maybeAgentId&lt;/code&gt; 에 &lt;code&gt;Option&lt;/code&gt; 을 이용하는 대신, &lt;em&gt;agent&lt;/em&gt; 에 할당된 &lt;em&gt;job&lt;/em&gt; 과 아닌 &lt;em&gt;job&lt;/em&gt; 을 서브타입으로 분리하면, &lt;code&gt;Job&lt;/code&gt; 을 다루는 함수에서 &lt;code&gt;Option&lt;/code&gt; 처리를 피할 수 있습니다.&lt;/p&gt;

&lt;p&gt;물론 이는 디자인적 결정입니다. &lt;code&gt;Option&lt;/code&gt; 을 허용하되 수퍼클래스를 인자로 받을것인가, 아니면 허용하지 않을것인가의 문제죠. 개인적으로는 프로그래밍 과정에서 타입을 점점 좁혀가면 오류의 여지를 줄일 수 있기 때문에 후자를 선호합니다. 그렇지 않으면 강력한 타입시스템을 갖춘 언어를 굳이 사용할 필요가 없겠지요.&lt;/p&gt;

&lt;p&gt;타입을 이용한 오류방지 방법 관련해서 &lt;a href=&#34;http://www.slideshare.net/IainHull/improving-correctness-with-types&#34;&gt;Improving Correctness with Types&lt;/a&gt; 를 읽어보시길 권합니다.&lt;/p&gt;

&lt;h2 id=&#34;monoid-example-filter&#34;&gt;Monoid Example: Filter&lt;/h2&gt;

&lt;p&gt;간단한 &lt;code&gt;Monoid&lt;/code&gt; 예제를 나 만들어 보겠습니다. &lt;code&gt;User&lt;/code&gt; 클래스가 있고, 필터링을 하고 싶을 때&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// http://www.slideshare.net/oxbow_lakes/practical-scalaz

case class User(name: String, city: String)
type Filter[A] = A =&amp;gt; Boolean // Function1, same as Reader[A, Boolean]

val london: Filter[User] = _.city endsWith(&amp;quot;.LONDON&amp;quot;)
val ny: Filter[User]     = _.city endsWith(&amp;quot;.NY&amp;quot;)

val inLondon = users filter london
val inNY = users filter ny
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 때 만약 &lt;code&gt;Filter[A]&lt;/code&gt; 가 &lt;code&gt;OR (||)&lt;/code&gt; 연산에 대한 모노이드라면, 이렇게 쓸 수 있지 않을까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;users filter (london |+| ny)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그런데 &lt;code&gt;Filter[A]&lt;/code&gt; 는 모노이드가 아니기 때문에 그럴 수 없습니다. 우린 모노이드를 배운 사람들이니까 &lt;del&gt;지성인&lt;/del&gt; 한 번 만들어 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit def booleanMonoid[A] = new Monoid[Filter[A]] = {
  override def zero: Filter[A] =
    false
  override def append(f1: Filter[A], f2: =&amp;gt; Filter[A]): Filter[A] =
    a =&amp;gt; f1(a) || f2(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;disjunction&lt;/em&gt; ´죠? &lt;em&gt;Scalaz&lt;/em&gt; 어딘가에 구현되어 있을것 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;impilcit def booleanMonoid[A] =
  function1Monoid[A, Boolean](booleanInstance.disjunction)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;function1Monoid[A, R]&lt;/code&gt; 은 결과값 &lt;code&gt;R&lt;/code&gt; 에 대한 모노이드 &lt;code&gt;Monoid[R]&lt;/code&gt; 를 필요로 하고 여기에 위에서 봤던 &lt;code&gt;Monoid[Boolean]&lt;/code&gt; 인 &lt;code&gt;booleanInstance.disjunction&lt;/code&gt; 을 넣으면, 우리가 원했던 &lt;code&gt;Monoid[Filter[A]&lt;/code&gt; 가 완성됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit def function1Monoid[A, R](implicit R0: Monoid[R]): Monoid[A =&amp;gt; R] = new Function1Monoid[A, R] {
  implicit def R = R0
}

private trait Function1Monoid[A, R] extends Monoid[A =&amp;gt; R] with Function1Semigroup[A, R] {
  implicit def R: Monoid[R]
  def zero = a =&amp;gt; R.zero
}

object disjunction extends Monoid[Boolean] {
    def append(f1: Boolean, f2: =&amp;gt; Boolean) = f1 || f2
    def zero = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러면 이제 요구사항을 좀 더 까다롭게 해서, &lt;strong&gt;런던에 사는 켈리 또는 뉴욕에 사는 켈리&lt;/strong&gt; 만 뽑아내려면 어떻게 해야할까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// if we have `|*|` representing `Conjunction`

val kelly: Filter[User] = _.name.endsWith(&amp;quot;Kelly&amp;quot;)
val myFriendKelly = (london |*| kelly) |+| (ny |*| kelly)
users filter myFriendKelly
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그런데, &lt;em&gt;scalaz&lt;/em&gt; 에서 할당한 모노이드 연산자는 &lt;code&gt;|+|&lt;/code&gt; 하나뿐입니다. 따라서 &lt;em&gt;Implicit Class&lt;/em&gt; 를 추가하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit class FilterOps[A](fa: Function1[A, Boolean]) {
  def |*|(other: Function1[A, Boolean]): Function1[A, Boolean] =
    function1Monoid[A, Boolean](booleanInstance.conjunction).append(fa, other)
}

val users = List(
  User(&amp;quot;Kelly&amp;quot;, &amp;quot;.LONDON&amp;quot;),
  User(&amp;quot;John&amp;quot;, &amp;quot;.NY&amp;quot;),
  User(&amp;quot;Cark&amp;quot;, &amp;quot;.SEOUL&amp;quot;),
  User(&amp;quot;Kelly&amp;quot;, &amp;quot;.NY&amp;quot;),
  User(&amp;quot;Kelly&amp;quot;, &amp;quot;.SEOUL&amp;quot;)
)

val ks1 = users filter ((london |*| isKelly) |+| (ny |*| isKelly))
val ks1.size shouldBe 2

// 더 짧게 줄이면,
val ks2 = users filter ((london |+| ny) |*| isKelly)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;scalaz.Monoid&lt;/code&gt; 가 &lt;code&gt;|+|&lt;/code&gt; 만을 지원하는 반면, 대수타입에 특화된 &lt;em&gt;Spire&lt;/em&gt; 는 &lt;code&gt;Boolean&lt;/code&gt; 에 대해 &lt;code&gt;*, +&lt;/code&gt; 두 가지 연산을 모두 지원합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import spire.algebra.Rig

implicit def filterRig[A] = new Rig[Filter[A]] {
  def plus(x: Filter[A], y: Filter[A]): Filter[A] = v =&amp;gt; x(v) || y(v)
  def one: Filter[A] = Function.const(true)
  def times(x: Filter[A], y: Filter[A]): Filter[A] = v =&amp;gt; x(v) &amp;amp;&amp;amp; y(v)
  def zero: Filter[A] = Function.const(false)
}

import spire.syntax.rig._

users filter ((london + ny) * kelly)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;monoid-with-booleanw-optionw-and-endo&#34;&gt;Monoid with BooleanW, OptionW and Endo&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Boolean&lt;/code&gt; 과 &lt;code&gt;Option&lt;/code&gt; 은, 연산에 &lt;code&gt;if-else&lt;/code&gt;, &lt;code&gt;getOrElse&lt;/code&gt; 처럼  &lt;strong&gt;다른 경우&lt;/strong&gt; 를 내포하기 때문에, &lt;code&gt;Monoid.zero&lt;/code&gt; 와 엮으면 쏠쏠하게 써먹을 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&amp;gt; load.ivy(&amp;quot;org.scalaz&amp;quot; % &amp;quot;scalaz-core_2.11&amp;quot; % &amp;quot;7.2.0-M5&amp;quot;)

&amp;gt; import scalaz._, Scalaz._
import scalaz._, Scalaz._

&amp;gt; ~ 1.some      // Some(1).getOrElse(Monoid[Int].zero)
res5: Int = 1
&amp;gt; ~ none[Int]   // None.getOrElse(Monoid[Int].zero)
res6: Int = 0
&amp;gt; none[Int] | 3 // None.getOrElse(3)
res7: Int = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Boolean&lt;/code&gt; 연산도 살펴보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;(true  ? 1 | 2) shouldBe 1
(false ? 1 | 2) shouldBe 2
(true  ?? 1) shouldBe 1
(false ?? 1) shouldBe 0 /* raise into zero */
(true  !? 1) shouldBe 0 /* reversed `??` */
(false !? 1) shouldBe 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;??&lt;/code&gt; 는 조건이 참일경우, &lt;code&gt;A&lt;/code&gt; 를 아닐 경우 &lt;code&gt;Monoid[A].zero&lt;/code&gt; 를 돌려줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;final class BooleanOps(self: Boolean) {
  ...
  final def ??[A](a: =&amp;gt; A)(implicit z: Monoid[A]): A = b.valueOrZero(self)(a)
  final def !?[A](a: =&amp;gt; A)(implicit z: Monoid[A]): A = b.zeroOrValue(self)(a)
  ...
}

trait BooleanFunctions {
  ...
  final def valueOrZero[A](cond: Boolean)(value: =&amp;gt; A)(implicit z: Monoid[A]): A =
    if (cond) value else z.zero
  final def zeroOrValue[A](cond: Boolean)(value: =&amp;gt; A)(implicit z: Monoid[A]): A =
    if (!cond) value else z.zero
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.slideshare.net/oxbow_lakes/practical-scalaz&#34;&gt;Practical Scalaz&lt;/a&gt; 에서는 &lt;code&gt;Endo&lt;/code&gt; 와 엮어 다음처럼 사용하는걸 보여줍니다. (&lt;code&gt;new Filter&lt;/code&gt; 부분을 추출하는것이 더 나은것 같습니다만, 그냥 이렇게도 사용할 수 있다 정도로 알고만 계시면 될 것 같습니다.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;// http://www.slideshare.net/oxbow_lakes/practical-scalaz

&amp;lt;instruments filter=&amp;quot;incl&amp;quot;&amp;gt;
  &amp;lt;symbol value=&amp;quot;VOD.L&amp;quot; /&amp;gt;
  &amp;lt;symbol value=&amp;quot;MSFT.O&amp;quot; /&amp;gt;
&amp;lt;/instruments&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// before
for {
  e &amp;lt;- xml \ &amp;quot;instrument&amp;quot;
  f &amp;lt;- e.attribute(&amp;quot;filter&amp;quot;)
} yield
  (if f == &amp;quot;incl&amp;quot;) new Filter(instr(e)) else new Filter(instr(e)).neg)

// after
val reverseFilter = Endo[Filter](_.neg)

for {
  e &amp;lt;- xml \ &amp;quot;instrument&amp;quot;
  f &amp;lt;- e.attribute(&amp;quot;filter&amp;quot;)
} yield
  (f == &amp;quot;incl&amp;quot;) !? reverseFilter apply new Filter(instr(e))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로 &lt;code&gt;Endo&lt;/code&gt; 는 &lt;code&gt;Function1[A, A]&lt;/code&gt; 입니다. 따라서 &lt;code&gt;Monoid[Endo[A]]&lt;/code&gt; 는 &lt;em&gt;identity function&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;final case class Endo[A](run: A =&amp;gt; A) {
  final def apply(a: A): A = run(a)

  /** Do `other`, than call myself with its result. */
  final def compose(other: Endo[A]): Endo[A] = Endo.endo(run compose other.run)

  /** Call `other` with my result. */
  final def andThen(other: Endo[A]): Endo[A] = other compose this
}

trait EndoFunctions {
  /** Alias for `Endo.apply`. */
  final def endo[A](f: A =&amp;gt; A): Endo[A] = Endo(f)

  /** Alias for `Monoid[Endo[A]].zero`. */
  final def idEndo[A]: Endo[A] = endo[A](a =&amp;gt; a)

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;example-currency&#34;&gt;Example: Currency&lt;/h2&gt;

&lt;p&gt;이제까지 배워왔던 바를 적용해서, 통화를 나타내는 &lt;code&gt;Currency&lt;/code&gt; 모델을 만들어 보겠습니다. 위에선 &lt;code&gt;Tag&lt;/code&gt; 를 이용했었으니, 이번엔 &lt;em&gt;&lt;a href=&#34;http://docs.scala-lang.org/overviews/core/value-classes.html&#34;&gt;Value Class&lt;/a&gt;&lt;/em&gt; 로 만들어 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Currency {
  sealed trait Currency extends Any
  final case class EUR[A](amount: A) extends AnyVal with Currency
  final case class USD[A](amount: A) extends AnyVal with Currency
}

// spec
USD(1) =:= USD(1)
USD(3) =:= EUR(2) // compile error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;1.USD&lt;/code&gt; 등 의 문법을 위해 &lt;em&gt;implicit class&lt;/em&gt; 를 추가하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Object Currency {
  ...

  implicit class CurrencyOps[A](amount: A) {
    def EUR = Currency3.EUR(amount)
    def USD = Currency3.USD(amount)
  }
}

// spec
10.USD =:= 10.USD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 같은 통간 덧셈을 위해, &lt;code&gt;Monoid[USD[A]]&lt;/code&gt; 등을 추가할 수 있습니다. &lt;code&gt;|+|&lt;/code&gt; 는 기존의 &lt;code&gt;Monoid[A]&lt;/code&gt; 를 이용하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Currency {
  import scalaz._, Scalaz._

  ...
  implicit def usdMonoid[A](implicit M: Monoid[A]) = new Monoid[USD[A]] {
    override def zero: USD[A] =
      USD(M.zero)

    override def append(u1: USD[A], u2: =&amp;gt; USD[A]): USD[A] =
      USD(M.append(u1.amount, u2.amount))
  }
}

// spec
(10.USD |+| 10.USD) =:= 20.USD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;EUR&lt;/code&gt; 를 위한 모노이드를 만들어 보겠습니다. 재미삼아 &lt;em&gt;&lt;a href=&#34;http://docs.scala-lang.org/tutorials/FAQ/context-and-view-bounds.html&#34;&gt;context bound&lt;/a&gt;&lt;/em&gt; 를 이용해 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Currency {
  ...

  implicit def eurMonoid[A : Monoid] = new Monoid[EUR[A]] {
    override def zero: EUR[A] =
      EUR(implicitly[Monoid[A]].zero)

    override def append(e1: EUR[A], e2: =&amp;gt; EUR[A]): EUR[A] =
      EUR(implicitly[Monoid[A]].append(e1.amount, e2.amount))
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;통화가 추가될때 마다 매번 반복적으로 ª¨노이드를 추가해야된다는 것이 귀찮으므로, &lt;code&gt;Currency&lt;/code&gt; 용 모노이드를 만들겠습니다. &lt;em&gt;&lt;a href=&#34;https://github.com/milessabin/shapeless&#34;&gt;Shapeless&lt;/a&gt;&lt;/em&gt; 를 이용하면, (&lt;em&gt;Shapeless&lt;/em&gt; 의 &lt;code&gt;Generic&lt;/code&gt;, &lt;code&gt;Aux&lt;/code&gt; 는 아래에서 설명하겠습니다)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Currency {
  import scalaz._, Scalaz._
  import shapeless._

  ...
  implicit def currencyMonoid[A : Monoid, C[_] &amp;lt;: Currency]
  (implicit G: Generic.Aux[C[A], A :: HNil]) = new Monoid[C[A]] {
    override def zero: C[A] =
      G.from(implicitly[Monoid[A]].zero :: HNil)

    override def append(c1: C[A], c2: =&amp;gt; C[A]): C[A] = {
      val a1: A = G.to(c1).head
      val a2: A = G.to(c2).head

      G.from(implicitly[Monoid[A]].append(a1, a2) :: HNil)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 통화간 변환을 위한 함수를 추가해보도록 하겠습니다. 이런 문법은 어떨까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;12.USD to EUR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그런데, 현재 우리가 가진 디자인에서 &lt;code&gt;EUR&lt;/code&gt; 은 &lt;em&gt;case class&lt;/em&gt; 이므로 &lt;code&gt;EUR&lt;/code&gt; 생성없이 타입만 지정하려면 이정 문법으로 타협할 수 있겠네요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;24.USD to[EUR]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Currency&lt;/code&gt; 에서 &lt;code&gt;to&lt;/code&gt; 구현을 하려면, &lt;code&gt;to[C[_] &amp;lt;: Currency[_]]&lt;/code&gt; 정도로 하위 클래스는 퉁친다 해도, 하위 클래스 인스턴스 생성시에 &lt;code&gt;A&lt;/code&gt; 가 필요하므로 &lt;code&gt;Currency&lt;/code&gt; 를 &lt;code&gt;Currency[A]&lt;/code&gt; 로 변경해야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Currency {
  sealed trait Currency[A] extends Any {
    def amount: A
  }

  final case class EUR[A](amount: A) extends AnyVal with Currency[A]
  final case class USD[A](amount: A) extends AnyVal with Currency[A]

  implicit class CurrencyOps[A](amount: A) {
    def EUR = Currency3.EUR(amount)
    def USD = Currency3.USD(amount)
  }

  implicit def currencyMonoid[A : Monoid, C[A] &amp;lt;: Currency[A]]
  (implicit G: Generic.Aux[C[A], A :: HNil]) = new Monoid[C[A]] {
    override def zero: C[A] =
      G.from(implicitly[Monoid[A]].zero :: HNil)

    override def append(c1: C[A], c2: =&amp;gt; C[A]): C[A] = {
      val a1: A = G.to(c1).head
      val a2: A = G.to(c2).head

      G.from(implicitly[Monoid[A]].append(a1, a2) :: HNil)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;Currency&lt;/code&gt; 에 &lt;code&gt;to&lt;/code&gt; 를 추가하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Currency {
  ...

  sealed trait Currency[A] extends Any {
    def amount: A
    def to[C[A] &amp;lt;: Currency[A]](implicit G: Generic.Aux[C[A], A :: HNil]): C[A] =
      G.from(amount :: HNil)
  }

  ...
}

// spec
(10.USD.to[EUR]) =:= 10.EUR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;to&lt;/code&gt; 에 &lt;code&gt;implicit&lt;/code&gt; 로 통화간 환율을 담고있는 &lt;code&gt;R: Rate&lt;/code&gt; 등을 추가하고 &lt;code&gt;Rate&lt;/code&gt; 내에서 &lt;code&gt;Monoid[A @@ Multiplcation&lt;/code&gt; 을 이용하면 컴파일타임에&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;USD -&amp;gt; EUR&lt;/code&gt; 변환이 정의되어 있는지 (&lt;a href=&#34;https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#heterogenous-maps&#34;&gt;Shapeless Heterogenous Maps&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; 에 대한 곱셈 연산 &lt;code&gt;Monoid[A @@ Multiplication]&lt;/code&gt; 이 정의 되어있는지를 검사할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;del&gt;구현은 숙제로.. 제가 귀찮아서가 절대 아닙니다&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;디자인적인 결정이겠으나, &lt;code&gt;USD&lt;/code&gt;, &lt;code&gt;EUR&lt;/code&gt; 등을 &lt;code&gt;object&lt;/code&gt; 로 만들고 &lt;code&gt;case class Money[A](amount: A, currency: Currency)&lt;/code&gt; 로 구현할수도 있겠습니다. 관심 있으신 분은 &lt;a href=&#34;https://github.com/lambdista/money&#34;&gt;github.com/lambdista/money&lt;/a&gt; 를 참조하시면 됩니다.&lt;/p&gt;

&lt;h2 id=&#34;shapeless&#34;&gt;Shapeless&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Shapeless&lt;/em&gt; 는 많은 기능을 가지고 있기 때문에 여기서 모든걸 설명하긴 어렵고, 위에서 사용한 &lt;code&gt;Generic&lt;/code&gt;, &lt;code&gt;Aux&lt;/code&gt; 에 대해 간단히 소개만 하겠습니다. (관심 있으신 분은 &lt;a href=&#34;https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0&#34;&gt;Shapeless - Feature 2.0.0&lt;/a&gt; 를 참조하시면 됩니다.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/milessabin/shapeless/blob/master/core/src/main/scala/shapeless/generic.scala

&amp;gt; load.ivy(&amp;quot;com.chuusai&amp;quot; %% &amp;quot;shapeless&amp;quot; % &amp;quot;2.2.5&amp;quot;)

&amp;gt; import shapeless._
import shapeless._

&amp;gt; case class Cat(name: String, catAge: Double)
defined class Cat
&amp;gt; Generic[Cat]
res4: Generic[Cat] {
  type Repr =
    shapeless.::[String,shapeless.::[Double,shapeless.HNil]]
} = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Generic[A]&lt;/code&gt; 는 &lt;a href=&#34;http://danielwestheide.com/blog/2013/02/13/the-neophytes-guide-to-scala-part-13-path-dependent-types.html&#34;&gt;Path-Dependent Type&lt;/a&gt; 으로 &lt;code&gt;Repr&lt;/code&gt; 을 가지고 있습니다. 이는 &lt;code&gt;A&lt;/code&gt; 에 따라 달라지는 값인데, 보통 &lt;code&gt;R&lt;/code&gt; 로 표기합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/milessabin/shapeless/blob/master/core/src/main/scala/shapeless/generic.scala#L103

trait Generic[T] extends Serializable {
  /** The generic representation type for {T}, which will be composed of {Coproduct} and {HList} types  */
  type Repr

  /** Convert an instance of the concrete type to the generic value representation */
  def to(t : T) : Repr

  /** Convert an instance of the generic representation to an instance of the concrete type */
  def from(r : Repr) : T
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Generic.Aux[A, R]&lt;/code&gt; 는 &lt;code&gt;Generic[A]&lt;/code&gt; 의 &lt;code&gt;Repr&lt;/code&gt; 에 &lt;code&gt;R&lt;/code&gt; 을 사용하는것으로, &lt;code&gt;Generic[A] { type Repr = R }&lt;/code&gt; 과 동일합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// https://github.com/milessabin/shapeless/blob/master/core/src/main/scala/shapeless/generic.scala#L148

object Generic {
  ...

  type Aux[T, Repr0] = Generic[T] { type Repr = Repr0 }

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Generic.Aux[A, R]&lt;/code&gt; 을 이용하면, 타입수준의 표현 &lt;code&gt;R&lt;/code&gt; 과 실제 타입 &lt;code&gt;A&lt;/code&gt; 간&lt;em&gt;isomorphic&lt;/em&gt; 변환을 수행할 수 있습니다. 위에서 봤던 &lt;code&gt;to&lt;/code&gt; 와 &lt;code&gt;from&lt;/code&gt; 기억 하시죠?&lt;/p&gt;

&lt;p&gt;만약 &lt;code&gt;R&lt;/code&gt; 이 기본적인 타입이어서, &lt;code&gt;Generic.Aux[A, R]&lt;/code&gt; 이 Shapeless 에서 자동 생성해 줄 경우 &lt;code&gt;Currency&lt;/code&gt; 예제에서 보았듯이 &lt;code&gt;implicit&lt;/code&gt; 로 가져오면, 바로 이용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;primitive&lt;/em&gt; 는 물론 &lt;em&gt;case class&lt;/em&gt; 도 &lt;code&gt;Generic[Cat]&lt;/code&gt; 처럼 자동생성되어 바로 가져다 쓸 수 있습니다. 중첩된것두 가능하구요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&amp;gt; case class EnhancedCat(catType: String, cat: Cat)
defined class EnhancedCat

&amp;gt; Generic[EnhancedCat]
res6: Generic[EnhancedCat] {
  type Repr = shapeless.::[String,shapeless.::[cmd3.Cat,shapeless.HNil]]
} = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;HList&lt;/code&gt; 는 (&lt;a href=&#34;https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#heterogenous-lists&#34;&gt;Heterogenous List&lt;/a&gt;) 여러 타입을 담을 수 있는 리스트입니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;to&lt;/code&gt; 와 &lt;code&gt;from&lt;/code&gt; 예제를 보´&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&amp;gt; val c1 = Cat(&amp;quot;odie&amp;quot;, 1.0)
c1: Cat = Cat(&amp;quot;odie&amp;quot;, 1.0)

&amp;gt; Generic[Cat].to(c1)
res9: String :: Double :: HNil = ::(&amp;quot;odie&amp;quot;, ::(1.0, HNil))

&amp;gt; val reconstructed = Generic[Cat].from(res9)
reconstructed: Cat = Cat(&amp;quot;odie&amp;quot;, 1.0)

&amp;gt; case class Dog(name: String, dogAge: Double)
defined class Dog

&amp;gt; val d1 = Dog(&amp;quot;dog odie&amp;quot;, 1.0)
d1: Dog = Dog(&amp;quot;dog odie&amp;quot;, 1.0)

&amp;gt; Generic[Dog].to(d1)
res13: String :: Double :: HNil = ::(&amp;quot;dog odie&amp;quot;, ::(1.0, HNil))

&amp;gt; val reconstructedFromDog = Generic[Cat].from(res13)
reconstructedFromDog: Cat = Cat(&amp;quot;dog odie&amp;quot;, 1.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/&#34;&gt;metaplasm.us - Type Classes and Generic Derivation&lt;/a&gt; 에서는 &lt;em&gt;Shapeless&lt;/em&gt; 를 이용해서 문자열로부터 &lt;em&gt;case class&lt;/em&gt; 를 자동생성하는 파서를 만드는 법을 보여줍니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CaseClassParser&lt;/code&gt; 가 있을 때, 문자열 &lt;code&gt;&amp;quot;odie, 1.2&amp;quot;&lt;/code&gt; 를 &lt;code&gt;Dog&lt;/code&gt; 로 파싱하기 위해 &lt;code&gt;CaseClassParser[Dog](&amp;quot;odie, 1.2&amp;quot;)&lt;/code&gt; 처럼 쓰고싶다고 하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// ref - https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/

object CaseClassParser {
  import shapeless._

  trait Parser[A] {
    def apply(s: String): Option[A]
  }

  def apply[A](s: String)(implicit P: Parser[A]): Option[A] = P(s)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 때 &lt;code&gt;shapeless.Generic[A]&lt;/code&gt; 를 이용하면 위에서 보았듯이 &lt;code&gt;A&lt;/code&gt; 를 &lt;code&gt;HList&lt;/code&gt; 로 (&lt;a href=&#34;https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#heterogenous-lists&#34;&gt;Heterogenous List&lt;/a&gt;) 로 변경할 수 있으므로 &lt;code&gt;Parser[HList]&lt;/code&gt; 만 있으면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HList&lt;/code&gt; 도 &lt;code&gt;List&lt;/code&gt; 처럼 &lt;code&gt;cons&lt;/code&gt; 와 &lt;code&gt;nil&lt;/code&gt; 로 구성되어 있습니다. &lt;code&gt;HNil&lt;/code&gt; 과 &lt;code&gt;HList&lt;/code&gt; 파서를 만들면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// ref - https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/

object CaseClassParser {
  ...

  implicit val hnilParser = new Parser[HNil] {
    override def apply(s: String): Option[HNil] =
      if (s.isEmpty) Some(HNil) else None
  }

  implicit def hlistParser[H : Parser, T &amp;lt;: HList : Parser] = new Parser[H :: T] {
    override def apply(s: String): Option[H :: T] =
      s.split(&amp;quot;,&amp;quot;).toList match {
        case cell +: rest /* use `+:` instead of :: */ =&amp;gt; for {
          head &amp;lt;- implicitly[Parser[H]].apply(cell)
          tail &amp;lt;- implicitly[Parser[T]].apply(rest.mkString(&amp;quot;,&amp;quot;))
        } yield head :: tail
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;implicitly[Parser[H]]&lt;/code&gt; 에서 사용할 개별 타입별 파서를 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// ref - https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/

object CaseClassParser {
  ...

  implicit val intParser = new Parser[Int] {
    override def apply(s: String): Option[Int] = Try(s.toInt).toOption
  }

  implicit val stringParser = new Parser[String] {
    override def apply(s: String): Option[String] = Some(s)
  }

  implicit val doubleParser = new Parser[Double] {
    override def apply(s: String): Option[Double] = Try(s.toDouble).toOption
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;마지막으로, &lt;em&gt;case class&lt;/em&gt; 를 &lt;code&gt;HList&lt;/code&gt; 로 만들어줄 &lt;code&gt;caseClassParser&lt;/code&gt; 만 만들면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// ref - https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/

object CaseClassParser {
  ...

  implicit def caseClassParser[C, R &amp;lt;: HList]
  (implicit G: Generic.Aux[C, R], reprParser: Parser[R]): Parser[C] = new Parser[C] {
    override def apply(s: String): Option[C] = reprParser.apply(s).map(G.from)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;reprParser.apply(s)&lt;/code&gt; 는 &lt;code&gt;Option[R]&lt;/code&gt; 이므로 &lt;code&gt;G.from&lt;/code&gt; 을 이용해 변환해주면 됩니다.&lt;/p&gt;

&lt;h2 id=&#34;previous-posts&#34;&gt;Previous Posts&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://1ambda.github.io/easy-scalaz-1-state/&#34;&gt;Easy Scalaz 1, State&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://1ambda.github.io/easy-scalaz-2-monad-transformer/&#34;&gt;Easy Scalaz 2, Monad Transformer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://1ambda.github.io/easy-scalaz-3-readerwriterstate-with-kleisli/&#34;&gt;Easy Scalaz 3, ReaderWriterState with Kleisli&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://1ambda.github.io/easy-scalaz-4-yoneda-and-free-monad/&#34;&gt;Easy Scalaz 4, Yoneda and Free Monad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://cs.lth.se/edan40&#34;&gt;Haskell Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://eed3si9n.com/learning-scalaz/Tagged+type.html&#34;&gt;Learning Scalaz: Tagged Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Tag.scala&#34;&gt;Scalaz 7.2: Tag.scala&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/scalaz/Py_IIfp9d2Q&#34;&gt;Scalaz Google Groups: Value Class vs Tag&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.scala-lang.org/overviews/core/value-classes.html&#34;&gt;Scala Docs: Value Classes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.scala-lang.org/tutorials/FAQ/context-and-view-bounds.html&#34;&gt;Scala Docs: Context Bound&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://etorreborre.blogspot.kr/2011/11/practical-uses-for-unboxed-tagged-types.html&#34;&gt;Practical uses for Unboxed Tagged Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/IainHull/improving-correctness-with-types&#34;&gt;Improving Correctness with Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://underscore.io/blog/posts/2014/01/29/unboxed-tagged-angst.html&#34;&gt;Underscore: Unboxed Tagged Angst&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/oxbow_lakes/practical-scalaz&#34;&gt;Slideshare: Practical Scalaz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/34266285/tagged-type-comparison-in-scalaz&#34;&gt;Stackoverflow: Tagged Type Comprarison in Scalaz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0&#34;&gt;Shapeless: Feature 2.0.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://danielwestheide.com/blog/2013/02/13/the-neophytes-guide-to-scala-part-13-path-dependent-types.html&#34;&gt;The Neophyte&amp;rsquo;s Guide to Scala Part 13: Path-Dependent Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://meta.plasm.us/posts/2015/11/08/type-classes-and-generic-derivation/&#34;&gt;metaplasm.us: Type classes and generic derivation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/33585441/constructing-simple-scala-case-classes-from-strings-strictly-without-boiler-pla/33586304#33586304&#34;&gt;Stackoverflow: Constructing simple Scala case classes from Strings, strictly without boiler-plate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Functional Programming 1</title>
      <link>https://1ambda.github.io/21/scala/functional-programming-1/</link>
      <pubDate>Wed, 07 Jan 2015 00:46:26 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/functional-programming-1/</guid>
      <description>

&lt;h3 id=&#34;1-1-programming-paradigms&#34;&gt;1.1 Programming Paradigms&lt;/h3&gt;

&lt;h4 id=&#34;imperative-programming&#34;&gt;Imperative Programming&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;modifying mutable variables&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;using assignment&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;and control str such as if-then-else, loop breakl continue, return&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;절차적인 프로그래밍은 폰 노이만 구조랑 비슷한데,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mutable var = memory cells&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;variable deferences = load instructions&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;var assginment = store instsruction&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;control structure = jumps&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그런데 이런 instruction 들이 &lt;code&gt;word&lt;/code&gt; 로 구성되어있으므로, 문제는&lt;br /&gt;
&amp;gt; &amp;ldquo;Scaling up, How can we avoid conceptualizign programs word by word?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;결국 pure Imperative Programming 은 폰노이만 구조처럼 제한을 받는다고 볼 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;One tends to conceptualize data structures word-by-words&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그렇기 때문에 컬렉션, 다항식, 문자열과 같은 high-level abstraction 을 정의할 방법이 필요한데, 이상적으로는 &lt;strong&gt;Theory&lt;/strong&gt; 를 만들면 해결할 수 있다. Theory 는 다음을 포함하는데&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;one or more data types&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;operations on these types&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;laws that describe the relationships between values and opertions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나, 일반적으로 &lt;strong&gt;Theory&lt;/strong&gt; 는 mutation 에 대해서는 describe 하지 않지만 Imperative Programming 에서는 mutation 때문에 theories 가 부서질(break) 수 있음. 따라서 다음과 같은 것들이 필요하다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Concentrate on defining theories for operators expressed as function&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;avoid mutations&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;have powerful way to abstract and compose functions&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정리하자면, Imperative Programming 에서는 high-level abstraction 을 위해 theory 를 이용할 수 있는데, Imperative Programming 에서는 mutation variable 을 이용하므로 theory 의 law 를 break 할 수 있다. 따라서 이런 단점을 해결하기 위해 나온 것이 Functional Programming 이다.&lt;/p&gt;

&lt;p&gt;Functional Programming 에서는 상태가 Immutable 이기 때문에 &lt;strong&gt;Theory&lt;/strong&gt; 를 구성하는 operator 를 만드는 것에 집중할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;functional-programming&#34;&gt;Functional Programming&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;without mutable variables, assignments, loops&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;focuses on functions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FP offers the folloing benefits&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;simpler reasoning principles&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;better modularity&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;good for exploiting parallelism fo mlticore and clod compting&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-2-elements-of-programming&#34;&gt;1.2 Elements of Programming&lt;/h3&gt;

&lt;h4 id=&#34;expression&#34;&gt;Expression&lt;/h4&gt;

&lt;p&gt;대다수의 언어들은 &lt;strong&gt;expression&lt;/strong&gt; 과 관련해서 다음의 기능들을 제공한다&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;primitive expressions, representing the simplest elements&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ways to combine expressions&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ways to abstract expressions, which introduce a name for an expression by which it can then be referred to.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;evaluation&#34;&gt;Evaluation&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Non-primitive&lt;/strong&gt; expression 은 최종적으로 value 를 만들기 전까지 다음과 같은 방식으로 evaluated 된다&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Take the leftmost operator&lt;/li&gt;
&lt;li&gt;Evaluate its operands (left before right)&lt;/li&gt;
&lt;li&gt;Apply the operator to the operands&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;A name&lt;/strong&gt; is evaluatd by replacing it with the right hand side of its definition.&lt;/p&gt;

&lt;p&gt;그러나 모든 expression 이 finite value 를 가지는 것은 아니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def loop: Int = loop
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;evaluation-of-function-applications&#34;&gt;Evaluation of Function Applications&lt;/h4&gt;

&lt;p&gt;Applications of parameterized functions 은 다음과 같은 방식으로 evaluated 된다. operator 와 얼추 비슷하다&lt;/p&gt;

&lt;p&gt;(1) Evaluate all function arguments, from left to right&lt;br /&gt;
(2.1) Replace the function application by the function&amp;rsquo;s right-hand side, and, at the same time
(2.2) Replace the formal parameters of the function by the actual arguments&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def square(x: Int) = x * *
def sumOfSquares(x: Int, : Int) = square(x) + square(x)

sumOfSquares(3, 2+2)

// sumOfSquares(3, 4) : step (1)
// square(3) + square(4) : step (2)
// 3 * 3 + square(4) : step (1), (2)
// 9 + square(4)
// 9 + 4 * 4
// 9 + 16
// 25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;인자를 먼저 평가하지 않을 경우 &lt;code&gt;square(2+2)&lt;/code&gt; 가 &lt;code&gt;(2*2) + (2*2)&lt;/code&gt; 로 reduced 되어 더 많은 계산을 야기할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;the-substitution-model&#34;&gt;The substitution model&lt;/h4&gt;

&lt;p&gt;이렇게 Evaluation 해 나가는 과정을 &lt;strong&gt;The substitution model&lt;/strong&gt; 이라 부른다. 이 모델의 근간이 되는 아이디어는 &lt;strong&gt;reducing an expression to a value&lt;/strong&gt; 이고, &lt;strong&gt;side-effect&lt;/strong&gt; 가 없는 한 모든 expressions 에  용할 수 있다. 참고로 이 모델은 Functional Programming 의 근간이 되는 &lt;strong&gt;lambda-calculus&lt;/strong&gt; 사용한 것이다.&lt;/p&gt;

&lt;h4 id=&#34;call-by-value-call-by-name&#34;&gt;Call-by-value, Call-by-name&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;square(4)&lt;/code&gt; 처럼 &lt;code&gt;sumOfSquares&lt;/code&gt; 의 인자가 먼저 평가되는 방식을 &lt;strong&gt;Call-by-value&lt;/strong&gt;, &lt;code&gt;square(2+2)&lt;/code&gt; 처럼 나중에 인자가 평가되는 방식을 &lt;strong&gt;Call-by-name&lt;/strong&gt; 이라 부른다.&lt;/p&gt;

&lt;p&gt;두 가지 방식 아래 조건이 지켜지는 한 모두 expression 을 value 로 reduce 한다&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the reuced expression consists of pure functions, and&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;both evaluations terminate&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Call-by-value&lt;/strong&gt; has the advantage that it evaluates every function argument only once&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Call-by-name&lt;/strong&gt; has the advantage that a function argument is not evaluated if the corresponding parameter is unused in the evaluation of the function body&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;examples&#34;&gt;Examples&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def test(x: Int, y: Int) = x *x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같은 함수가 있다고 할때, &lt;code&gt;test(3, 4)&lt;/code&gt; 는 똑같은 속도지만 &lt;code&gt;test(2+2, 3)&lt;/code&gt; 은  &lt;strong&gt;Call-by-value&lt;/strong&gt; 가, &lt;code&gt;test(2, 3+2)&lt;/code&gt; 는 &lt;strong&gt;Call-by-name&lt;/strong&gt; 이 더 빠르다&lt;/p&gt;

&lt;h3 id=&#34;1-3-evaluation-strategies-and-termination&#34;&gt;1.3 Evaluation Strategies and Termination&lt;/h3&gt;

&lt;p&gt;But what if termination is not guaranteed?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def test (x: Int, y: Int) = x * x
def loop () = loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제에서 &lt;code&gt;test(3, loop)&lt;/code&gt; 라는 expressions 은 &lt;strong&gt;Call-by-name&lt;/strong&gt; 방식으로 평가될 수 있지만, &lt;strong&gt;Call-by-value&lt;/strong&gt; 방식으로는 아니다.&lt;/p&gt;

&lt;p&gt;Scala 은 일반적으로 re-computation 을 피하기 위해 &lt;strong&gt;Call-by-value&lt;/strong&gt; 을 사용한다. 그러나 &lt;code&gt;def constOne(x: Int, y: =&amp;gt; Int) = 1&lt;/code&gt; 처럼 function parameter 가 &lt;code&gt;=&amp;gt;&lt;/code&gt; 로 시작하면 해당 인자는 &lt;strong&gt;Call-by-name&lt;/strong&gt; 을 이용한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def constOne(x: Int, y: =&amp;gt; Int) = 1
def loop() = loop

constOne(1+2, loop) // will be evaluated
constOne(loop, 1+2) // will not be evaluated
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-4-conditionals-and-value-definitions&#34;&gt;1.4 Conditionals and Value Definitions&lt;/h3&gt;

&lt;h4 id=&#34;conditional-expression&#34;&gt;Conditional Expression&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def abs(x: Int) = if (x &amp;gt;= 0) x else -x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, &lt;code&gt;x &amp;gt;= 0&lt;/code&gt; is a predicate, of type Boolean. and &lt;code&gt;If-else&lt;/code&gt; is an expression not a statement&lt;/p&gt;

&lt;h4 id=&#34;short-circuit-evaluation&#34;&gt;short-circuit evaluation&lt;/h4&gt;

&lt;p&gt;Boolean 을 위한 Rule 을 다시 만들수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;!true      --&amp;gt; false
!false     --&amp;gt; true
true &amp;amp;&amp;amp; e  --&amp;gt; e
false &amp;amp;&amp;amp; e --&amp;gt; false
true || e  --&amp;gt; true
false || e --&amp;gt; e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 와 &lt;code&gt;||&lt;/code&gt; 의 경우에는 언제나 오른쪽 operand 가 평가되야 하는건 아닌데, 이러한 expression 을 보고 &lt;strong&gt;short-circuit evaluation&lt;/strong&gt; 을 사용한다고 말한다.&lt;/p&gt;

&lt;h4 id=&#34;value-definitions&#34;&gt;Value Definitions&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def x loop(): Booelan = loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 식이 평가되는걸 보면 &lt;code&gt;def&lt;/code&gt; 는 &lt;strong&gt;Call-by-value&lt;/strong&gt; 를 이용하는걸 알 수 있다. 반대로 &lt;code&gt;val&lt;/code&gt; 은 &lt;strong&gt;Call-by-value&lt;/strong&gt; 를 사용한다. &lt;code&gt;val x = loop&lt;/code&gt; 식을 평가하면, 무한 루프가 도는것을 확인할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;exercise&#34;&gt;Exercise&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 와 &lt;code&gt;||&lt;/code&gt; 없이 &lt;code&gt;and&lt;/code&gt; 함수를 구현하려다 보면, 다음과 같이 구현하는 경우가 있는데,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def and(x: Boolean, y: Boolean = if (x) y else false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 경우 &lt;code&gt;and(false, loop)&lt;/code&gt; 를 평가하면 올바르게 동작하지 않고 무한루프에 걸린다 따라서 두번 째 인자가 &lt;strong&gt;Call-by-name&lt;/strong&gt; 을 이용해 평가되도록, 아래와 같이 작성해야 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def and(x: Boolean, y: =&amp;gt; Booelan) = if (x) y else false
def or(x: Boolean, y: =&amp;gt; Boolean) = if (x) true else y
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-5-example-square-roots-with-newton-s-method&#34;&gt;1.5 Example: square roots with Newton&amp;rsquo;s method&lt;/h3&gt;

&lt;p&gt;일단 시작 전에 먼저 말하자면, Scala 에서 recursive function 의 경우에는 explicit return type 이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://kevin0960.tistory.com/entry/%EA%B3%A0%EC%B0%A8-%EB%B0%A9%EC%A0%95%EC%8B%9D%EC%9D%98-%ED%95%B4-%EA%B5%AC%ED%95%98%EA%B8%B0-%EB%89%B4%ED%8A%BC-%EB%9E%A9%EC%8A%A8%EB%B2%95-Newton-Rahpson&#34;&gt;뉴튼-랩슨 법&lt;/a&gt;을 이용해서 제곱근을 구하는 Scala 코드를 작성하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def abs(x: Double) = if (x &amp;lt; 0) -x else x
  def sqrt(x: Int): Double = sqrtIter(1.0, x)
  def sqrtIter(guess: Double, x: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)

  def isGoodEnough(guess: Double, x: Double): Boolean =
    abs(guess * guess - x) / x &amp;lt; 0.0001

  def improve(guess: Double, x: Double) =
    (guess + x / guess) / 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실수에 대해 작업할때는 엄청나게 커다란 수와 작은 수에 대해 테스트를 해 보아야 한다. 만약 &lt;code&gt;isGoodEnough&lt;/code&gt; 의 구현이 &lt;code&gt;abs(guess * guess -x ) &amp;lt; 0.0001&lt;/code&gt; 이라면 큰수에 대해서는 non-termination 이, 작은 수에 대해서는 invalid 한 값이 나올수 있다.&lt;/p&gt;

&lt;p&gt;참고로, &lt;strong&gt;scalatest&lt;/strong&gt; 에서는 &lt;strong&gt;floating point number&lt;/strong&gt; 에 대한 테스틀 위해 다음과 같은 인터페이스를 지원한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sevenDotOh should equal (6.9 +- 0.2)
sevenDotOh should === (6.9 +- 0.2)
sevenDotOh should be (6.9 +- 0.2)
sevenDotOh shouldEqual 6.9 +- 0.2
sevenDotOh shouldBe 6.9 +- 0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-6-blocks-and-lexical-scope&#34;&gt;1.6 Blocks and Lexical Scope&lt;/h3&gt;

&lt;p&gt;위에서 작성한 &lt;code&gt;sqrt&lt;/code&gt; 를 block scope 를 이용하면 &lt;code&gt;x&lt;/code&gt; 를 파라미터로 넘기는것을 제거해 간단히 만들 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def abs(x: Double) = if (x &amp;lt; 0) -x else x
  def sqrt(x: Int): Double = {

    def sqrtIter(guess: Double): Double =
      if (isGoodEnough(guess, x)) guess
      else sqrtIter(improve(guess))

    def isGoodEnough(guess: Double, x: Double): Boolean =
      abs(guess * guess - x) &amp;lt; 0.0001

    def improve(guess: Double) =
      (guess +  x / guess) / 2

    sqrtIter(1.0)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;semicolons&#34;&gt;Semicolons&lt;/h4&gt;

&lt;p&gt;Scala 에서 세미콜론은 옵션이지만 이와 관련된 이슈가 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;someLongExp
+ someOtherExp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이건 다음과 같이 interpreted 될 것이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;someLongExp;
+ someOtherExp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Expression 이 분리 되는 것을 방지하기 위해 다음과 두 가지 방법을 이용할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;someLongExp +
someOtherExp

// or

(someLongExp
+ someOtherExp)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-7-tail-recursion&#34;&gt;1.7 Tail Recursion&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)

  def factorial(n: Int): Int =
    if (n == 0) 1 else n * factorial(n - 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음과 같은 재귀 함수가 있을때, 자세히 보면 &lt;code&gt;factorial(4)&lt;/code&gt; 의 경우 Expression 이 점점 길어진다. &lt;code&gt;(4 * 3 * 2 * (1 * 1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;반대로 &lt;code&gt;gcd(3, 2)&lt;/code&gt; 의 경우 계산과정을 살´보면 &lt;code&gt;gcd(3, 2)&lt;/code&gt;, &lt;code&gt;gcd(2, 1)&lt;/code&gt; 로 진행된다. 식이 점점 길어지는게 아니라, 함수에서 변수만 바뀌는걸 알 수 있다. 이 경우 저장해야할 지역변수가 없기 때문에 stack frame 을 재활용 할 수 있으며, 이런 Recursive call 을 &lt;strong&gt;Tail Recursion&lt;/strong&gt; 이라 부른다. 영문 설명을 보면,&lt;/p&gt;

&lt;p&gt;If a function calls itself as its last action, the function&amp;rsquo;s stack frame can e reused. This is called &lt;strong&gt;Tail Recursion&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tail recursive functions are iterative processes&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In general, if the last action of a function consists of calling a function (which may be the same), one stack frame would be sufficient for both functions. Such calls are called &lt;strong&gt;tail-calls&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tail-recursion&lt;/strong&gt; 버전의 &lt;code&gt;factorial&lt;/code&gt; 은 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def tailFactorial(n: Int) = {
    def loop(acc: Int, n: Int): Int =
      if (n == 0) acc else loop(acc * n, n-1)
    loop(1, n);
  }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Functional Programming 2</title>
      <link>https://1ambda.github.io/21/scala/functional-programming-2/</link>
      <pubDate>Wed, 06 Jan 2016 00:47:07 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/functional-programming-2/</guid>
      <description>

&lt;h3 id=&#34;2-1-higher-order-functions&#34;&gt;2.1 Higher-Order Functions&lt;/h3&gt;

&lt;h4 id=&#34;higher-order-functions&#34;&gt;Higher-Order Functions&lt;/h4&gt;

&lt;p&gt;Functional PL 에서는 함수를 &lt;em&gt;first-class&lt;/em&gt; 로 다루는데, 이는 함수를 파라미터로 넘기거나 결과로 리턴할 수 있다는 소리다.&lt;/p&gt;

&lt;p&gt;이렇게 함수를 파라미터로 받거나, 혹은 함수를 리턴하는 함수를 &lt;strong&gt;Higher order functions&lt;/strong&gt; 라 부른다.&lt;/p&gt;

&lt;h4 id=&#34;function-types&#34;&gt;Function Types&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;type A =&amp;gt; B is the type of a function that thaks an arg of type A and return a result of type B.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;anonymous-functions&#34;&gt;Anonymous Functions&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;The type of the parameter can be omittered if it can be infferred by the compiler&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;2-2-currying&#34;&gt;2.2 Currying&lt;/h3&gt;

&lt;p&gt;2.1 에서 우리는 &lt;strong&gt;Higher Order Functions&lt;/strong&gt; 를 만들었다. 다음과 같은 Tail-Recursive 버전의 &lt;code&gt;sum&lt;/code&gt; 이 있다고 하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def TailRecursiveSum(f: Int =&amp;gt; Int, a: Int, b: Int): Int = {
  def loop(a: Int, acc: Int): Int = {
    if (a &amp;gt; b) acc
    else loop(a + 1, f(a) + acc)
  }
  loop(a, 0);
}

def sumInts(a: Int, b: Int) =  sum(x =&amp;gt; x, a, b)
def sumCubes(a: Int, b: Int) =  sum(x =&amp;gt; x * x * x, a, b)
def sumFactorials(a: Int, b: Int) =  sum(fact, a, b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt;는 &lt;code&gt;sumInts&lt;/code&gt; 와 &lt;code&gt;sumCubes&lt;/code&gt; 로 부터 &lt;code&gt;sum&lt;/code&gt; 으로 변하지 않고 넘어간다. 제거할 수 없을까?&lt;br /&gt;
답은 간단하다. &lt;code&gt;sum&lt;/code&gt; 이 &lt;code&gt;a, b&lt;/code&gt; 를 받는 함수를 리턴하면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def sum(f: Int =&amp;gt; Int): (Int, Int) =&amp;gt; Int = {
  def sumF(a: Int, b: Int): Int = {
    def loop(a: Int, acc: Int): Int = {
      if (a &amp;gt; b) acc
      else loop(a + 1, f(a) +  acc)
    }
    loop(a, 0)
  }
  sumF
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러면 이렇게 인자를 숨길 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;
def sumInts = Currying.sum(x =&amp;gt; x)
assert(sumInts(1, 10) == 55)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sum&lt;/code&gt; 이 인자로 받은 &lt;code&gt;f&lt;/code&gt; 를 적용한 새로운 함수 &lt;code&gt;sumF&lt;/code&gt; 를 돌려주므로 다음과 같이 호출도 가능하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def cube = (x: Int) =&amp;gt; x * x * x
sum(cube)(1, 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;함수를 리턴하는 함수는 유용하기 때문에, 스칼라에서는 이를 위한 특별한 문법을 제공한다. 다음의 두 함수 &lt;code&gt;sum1&lt;/code&gt;과 &lt;code&gt;sum2&lt;/code&gt; 는 동일하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def sum1(f: Int =&amp;gt; Int): (Int, Int) =&amp;gt; Int = {
  def sumF(a: Int, b: Int): Int = {
    if (a &amp;gt; b) 0
    else f(a) + sum(a + 1, b)
  }
}

def sum2(f: Int =&amp;gt; Int)(a: Int, b: Int): Int = {
  if (a &amp;gt; b) 0
  else f(a) + sum2(f)(a + 1, b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;expansion-of-multiple-parameter-lists&#34;&gt;Expansion of Multiple Parameter Lists&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;def f(args1)...(argsn) = E&lt;/code&gt; 가 있을때 이건 다음과 같이 함수로 감싸고 그 함수를 다시 돌려주면, 원 함수 &lt;code&gt;f&lt;/code&gt; 에서 파라미터를 하나 줄일 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;def f(args1)...(argsn-1) = { def g(argn) = E; g }&lt;/code&gt; 만약 익명함수로 표현한다면,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;def f(args1)...(argsn-1) = (argsn =&amp;gt; E)&lt;/code&gt; 와 같이 표현할 수 있다. 따라서 이와 같이 함수로 감싸 원 함수 &lt;code&gt;f&lt;/code&gt; 에서 파라미터를 반복적으로 줄이다 보면&lt;/p&gt;

&lt;p&gt;&lt;code&gt;def f(args1)...(argsn) = E&lt;/code&gt; 는 인자를 1개씩 받는 N개의 익명함수로 표현할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;def f = (args1 =&amp;gt; (args2 =&amp;gt; ...(argn =&amp;gt; E) ...))&lt;/code&gt; 이러한 스타일을 &lt;strong&gt;currying&lt;/strong&gt; 이라 부른다.&lt;/p&gt;

&lt;h4 id=&#34;more-function-types&#34;&gt;More Function Types&lt;/h4&gt;

&lt;p&gt;그렇다면, 위에서 본 &lt;code&gt;sum&lt;/code&gt; 함수의 타입 무엇일까? &lt;code&gt;def sum(f: Int =&amp;gt; Int)(a: Int, b: Int): Int&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(Int =&amp;gt; Int) =&amp;gt; Int, Int =&amp;gt; Int&lt;/code&gt; 로 표현할 수 있다. 근데 스칼라에서 &lt;strong&gt;functional types associate to the right.&lt;/strong&gt; 이므로,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(Int =&amp;gt; Int) =&amp;gt; (Int, Int =&amp;gt; Int)&lt;/code&gt; 와 동일하다.&lt;/p&gt;

&lt;h4 id=&#34;exercise&#34;&gt;Exercise&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;(1). Write a &lt;code&gt;product&lt;/code&gt; function that calculates the product of the value of a function for the points on a given interval&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def product(f: Int =&amp;gt; Int)(a: Int, b: Int): Int = {
  if (a &amp;gt; b) 1
  else f(a) * product(f)(a + 1, b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;(2). Write &lt;code&gt;factorial&lt;/code&gt; in terms of &lt;code&gt;product&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def factorial(n: Int): Int = {
  product(x =&amp;gt; x)(1, n)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;(3). Can you write a more general funtion, which generalizes both &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;product&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def mapReduce(f: Int =&amp;gt; Int, combine: (Int, Int) =&amp;gt; Int, init: Int)(a: Int, b: Int): Int = {
  if (a &amp;gt; b) init
  else combine(f(a), mapReduce(f, combine, init)(a + 1, b))
}

def sumUsingMapReduce(f: Int =&amp;gt; Int)(a: Int, b: Int) =
  mapReduce(f, (x: Int, y: Int) =&amp;gt; x + y, 0)(a, b)

def productUsingMapReduce(f: Int =&amp;gt; Int)(a: Int, b: Int) =
  mapReduce(f, (x: Int, y: Int) =&amp;gt; x * y, 1)(a, b)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-example-finding-fixed-points&#34;&gt;2.3 Example: Finding Fixed Points&lt;/h3&gt;

&lt;h4 id=&#34;finding-a-fixed-point-of-a-function&#34;&gt;Finding a fixed point of a function&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;A number is called a &lt;strong&gt;fixed point&lt;/strong&gt; of a function f  if &lt;code&gt;f(x) = x&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;어떤 &lt;code&gt;f&lt;/code&gt; 들에 대해서는 &lt;code&gt;f(x)&lt;/code&gt; 를 반복적으로 적용하면서 변하지 않거나 변화량이 충분히 작아질때를 찾아 &lt;strong&gt;fixed point&lt;/strong&gt; 를 찾을 수 있다.&lt;/p&gt;

&lt;p&gt;1장에서 만들었던 제곱근을 구하는 함수로 돌아가 보자. 사실 이 함수는 &lt;strong&gt;fixed point&lt;/strong&gt; 와 관련이 있다. &lt;code&gt;sqrt(x) = y&lt;/code&gt; 라고 했을때 &lt;code&gt;y * y = x&lt;/code&gt; 이므로 &lt;code&gt;y = x / y&lt;/code&gt; 다. 따라서 &lt;code&gt;sqrt(x)&lt;/code&gt; 는 함수 &lt;code&gt;y = x / y&lt;/code&gt; 를 꾸준히 적용해서 찾아낼 수 있으므로 &lt;code&gt;y = x / y&lt;/code&gt; 의 &lt;strong&gt;fixed point&lt;/strong&gt; 다.&lt;/p&gt;

&lt;p&gt;다음과 같은 &lt;code&gt;fixedPoint&lt;/code&gt; 함수가 있다고 하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val tolerance = 0.0001 // = 1.0E-4
def isCloseEnough(x: Double, y: Double) = {
  abs((x - y) / x) / x &amp;lt; tolerance
}

def fixedPoint(f: Double =&amp;gt; Double)(firstGuess: Double): Double = {
  def iterate(guess: Double): Double = {
    val next = f(guess)
    if (isCloseEnough(guess, next)) next
    else iterate(next)
  }
  iterate(firstGuess)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 함수를 이용해서&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sqrt(x: Int) = fixedPoint(y =&amp;gt; x / y)(1.0)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;와 같은 제곱근을 구하는 함수를 만들어 볼 수 있겠다. 그러나 &lt;code&gt;sqrt(2)&lt;/code&gt;
 를 실행하면 &lt;code&gt;guess&lt;/code&gt; 값이 &lt;code&gt;1.0&lt;/code&gt;과 &lt;code&gt;2.0&lt;/code&gt; 사이를 널뛰기 하면서 무한 루프를 돈다.&lt;/p&gt;

&lt;p&gt;이건 &lt;code&gt;guess&lt;/code&gt; 값이 너무나 많이 변하기 때문인데, &lt;code&gt;f&lt;/code&gt; 를 적용하는 시퀀스에서 연속적인 두개의 &lt;code&gt;guess&lt;/code&gt; 값의 평균을 구하는 &lt;code&gt;f&lt;/code&gt; 를 만듦으로서 이 문제를 피할 수 있다. (잘못된 해석일 수 있으므로 원문을 첨부한다.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;One way to control such oscillations is to prevent the estimation from varying too much. This is done by averaging successive values of the original sequence
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;functions-as-return-values&#34;&gt;Functions as return values&lt;/h4&gt;

&lt;p&gt;여태까지는 함수를 인자로 사용했을때 언어에서 어떤 이점을 얻을 수 있는가에 대한 설명이었고, 이제부터는 함수를 리턴값으로 사용할때의 장점을 알아 보자.&lt;/p&gt;

&lt;p&gt;아까와 같이 averaging 함으로써 stabilizing 하는 기법을 &lt;strong&gt;Average Damping&lt;/strong&gt; 이라 부르는데, 아래와 같은 함수를 만들어서 인자로 넘길 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;def avgDamp(f: Double =&amp;gt; Double)(x: Doube) = (x + f(x)) / 2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;sqrt&lt;/code&gt; 함수는 다음과 같이 새로 작성할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def avgDamp(f: Double =&amp;gt; Double)(x: Double) = (x + f(x)) / 2
def sqrt(x: Double): Double = fixedPoint(avgDamp(y =&amp;gt; x / y))(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;avgDamp&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 를 다시 인자로 받는 함수를 돌려준다. 원래라면 &lt;code&gt;def&lt;/code&gt; 를 이용해서 새로 함수를 만들고 리턴했어야 하나, 스칼라에서 지원해주는 문법을 이용해서 &lt;code&gt;(x: Double)&lt;/code&gt; 을 추가하는 것 만으로 편하게 만들었다.&lt;/p&gt;

&lt;p&gt;이번장에선 Higher order function 을 이용해서 함수를 combine 하면 더 강력한 &lt;strong&gt;abstraction(추상화)&lt;/strong&gt; 를 얻을 수 있다는 법을 배웠다. 록 이 방법이 항상 좋은건  아니지만 배우면 다 쓸데가 있기 마련이다.&lt;/p&gt;

&lt;p&gt;덤으로 하나 더 정리하자면, &lt;strong&gt;Currying&lt;/strong&gt; 은 함수의 인자를 반복적으로 쪼개어 익명 함수로 만든 뒤 재활용 할 수 있도록 만드는 기술이라 보면 된다. 왜냐면 N개의 인자가 있다고 가정할때, 이전에는 1개의 함수에 다양한 인자를 줘야했지만, 커링을 이용하면 N개의 함수로 쪼갤 수 있고, 각각의 리턴되는 함수를 저장할 수 있으므로 각각을 재활용 할 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;2-5-functions-and-data&#34;&gt;2.5 Functions and Data&lt;/h3&gt;

&lt;p&gt;이번 장에서는 클래스를 사용한다. 유리수 계산을 하기 위해 &lt;code&gt;def add(n1: Int, d1: Int, n2: Int, d2: Int): Int&lt;/code&gt; 와 같은 함수를 만드는 것이 아니라, 데이터를 추상화 하기 위한 방법으로 다음과 같은 클래스를 만들 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Rational(x: Int, y: Int) {
  def numer = x
  def denom = y

  def add(that: Rational) = {
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로, 스칼라는 &lt;strong&gt;type&lt;/strong&gt; 과 &lt;strong&gt;value&lt;/strong&gt; 를 서로 다른네임스페이스에서 관리하기 때문에 충돌할 걱정을 할 필요가 없다.&lt;/p&gt;

&lt;h4 id=&#34;exercise-1&#34;&gt;Exercise&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;(1). In your worksheet, add a method &lt;code&gt;neg&lt;/code&gt; to class Rational that is used like this &lt;code&gt;x.neg // -x&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(2). Add a method sub to subtract two rational numbers&lt;/p&gt;

&lt;p&gt;(3). With the values of x, y, z as given in the previous slide, what is the result of &lt;code&gt;x - y - z&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Rational(x: Int, y: Int) {
  def numer = x
  def denom = y

  def add(that: Rational) = {
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }

  def sub(that: Rational) = {
    add(that.neg)
  }

  def neg = new Rational(-numer, denom)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-6-more-fun-with-rationals&#34;&gt;2.6 More Fun With Rationals&lt;/h3&gt;

&lt;p&gt;이전에 만든 &lt;code&gt;Rational&lt;/code&gt; 클래스는 약분된 형태로 표현되지 않기 때문에 이런 기능을 추가할 필요가 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;reduce them to their smallest numerator and denominator by dividing both with a divisor&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다양한 방법으로 구현할 수 있겠지만, 가장 쉬운 방법은 &lt;code&gt;Rational&lt;/code&gt; 오브젝트가 생성될때 약분 하는 방법이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
  private val g = abs(gcd(x, y))

  def numer = x / g
  def denom = y / g
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;self-reference&#34;&gt;Self-reference&lt;/h4&gt;

&lt;p&gt;그리고, &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt; 와 같은 함수도 만들어 볼 수 있다. &lt;code&gt;max&lt;/code&gt; 가 &lt;strong&gt;self-referencing&lt;/strong&gt; 을 위해 &lt;code&gt;this&lt;/code&gt; 키워드를 사용한다는 점에 주목하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def less(that: Rational) = numer * that.denom &amp;lt; that.numer * denom
  def max(that: Rational) = if (this.less(that)) that else this
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;pre-condition&#34;&gt;Pre-condition&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;new Rational(1, 0)&lt;/code&gt; 을 시도하면 &lt;code&gt;0&lt;/code&gt; 으로 나눌수 없기 때문에 에러를 뿜는다. 검사하기 위해 &lt;code&gt;require&lt;/code&gt; 함수를 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;require(y &amp;gt; 0, &amp;quot;denum must be != 0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;assert&lt;/code&gt; 도 사용할 수 있는데, &lt;code&gt;require&lt;/code&gt; 와는 차이가 있다. &lt;code&gt;AssertionError&lt;/code&gt; 가 나오고, &lt;code&gt;require&lt;/code&gt; 에는 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 나온다. 그래서 서로 다른 의도로 쓰이게끔 만들어졌다는걸 알 수 있다. (오역이 있을 수 있기 때문에 원문을 첨부한다.)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The reflects a difference in intent &lt;/br&gt;&lt;br/&gt;
- &lt;code&gt;require&lt;/code&gt; is used to enforce a precondition on the caller of a function &lt;br/&gt;
- &lt;code&gt;assert&lt;/code&gt; is used as to check the code of the function itself&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;만약 예외를 테스트한다면 &lt;code&gt;scalatest&lt;/code&gt; 에서는 &lt;code&gt;intercept&lt;/code&gt; 를 이용하면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  &amp;quot;Rational(1, 0)&amp;quot; should &amp;quot;throw IllegalArgumentException&amp;quot; in {
    intercept[IllegalArgumentException] {
      new Rational(1, 0)
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;constructor&#34;&gt;Constructor&lt;/h4&gt;

&lt;p&gt;스칼라에서는 암시적(implicitly) 인 생성자를 도입했는데, 다시 말해 코드상에 없어도 &lt;strong&gt;Primary Constructor&lt;/strong&gt; 가 존재하는데, 이 &lt;strong&gt;Primary Constructor&lt;/strong&gt; 는 클래스의 파라미터를 받아서 클래스 바디의 모든 문장을 실행한다. 만약 다른 생성자를 만들고 싶으면, 다음과 같이 작성하면 된¤.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;def this(x: Int) = this(x, 1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;우측에 나오는 &lt;code&gt;this&lt;/code&gt; 는 &lt;strong&gt;implicit primary constructor&lt;/strong&gt; 다.&lt;/p&gt;

&lt;h4 id=&#34;exercise-2&#34;&gt;Exercise&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Modify the &lt;code&gt;Rational&lt;/code&gt; class so that rational numbers are kept unsimplified internally, but the simplification is applied when numbers are converted to strings. Do clients observe the same behavior when interacting with rational class? &lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;primary constructor 에서 약분을 하지 않고, &lt;code&gt;toString&lt;/code&gt; 에서 약분을 할때 과연 제대로 되겠느냐인데, 답은 &lt;strong&gt;아니오&lt;/strong&gt; 다. integer overflow 를 생각하면 쉽다. 최대한 약분할 수 있을때 먼저 해버리는것이 낫다. 커다란 수 &lt;code&gt;a&lt;/code&gt; &amp;hellip; &lt;code&gt;z&lt;/code&gt; 에 대해서 연산 해버리면, 마지막 &lt;code&gt;toString&lt;/code&gt; 에서만 약분이 될텐데. 제대로 되지 않을 가능성이 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yes for small sizes of denominators and nominators and small numbers of operations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;2-7-evaluation-and-operators&#34;&gt;2.7 Evaluation and Operators&lt;/h3&gt;

&lt;h4 id=&#34;classes-and-substitutions&#34;&gt;Classes and Substitutions&lt;/h4&gt;

&lt;p&gt;(단어 오역이 있을 수 있어서 용어를 그대로 씀)&lt;/p&gt;

&lt;p&gt;함수에서 &lt;strong&gt;subtitution&lt;/strong&gt; 에 기반한 &lt;strong&gt;compuation model&lt;/strong&gt; 을 이용했는데, 사실 이건 클래스를 인스턴스 할때도 똑같이 적용된다. 즉 &lt;code&gt;new C(x1, ... ,xn)&lt;/code&gt; 은 &lt;code&gt;new C(v1, ..., vn)&lt;/code&gt; 과 같다.&lt;/p&gt;

&lt;p&gt;그렇다면, 다음과 같이 클래스가 인자 n 개를 받는 함수를 정의했을때 &lt;code&gt;def f(y1, ... , yn) = b&lt;/code&gt; 이런 식은 어떻게 평가될까?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;new C(v1, ..., vm).f(w1, ... , wn)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(1). 클래스의 &lt;strong&gt;formal parameter&lt;/strong&gt; &lt;code&gt;x1, ..., xn&lt;/code&gt; 이 &lt;strong&gt;actual parameter&lt;/strong&gt; &lt;code&gt;v1, ... , vm&lt;/code&gt; 으로 &lt;strong&gt;substitution&lt;/strong&gt; 된다.&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;(2). 함수 &lt;code&gt;f&lt;/code&gt; 의 &lt;strong&gt;formal parameter&lt;/strong&gt; &lt;code&gt;y1, ... , yn&lt;/code&gt; 이 &lt;strong&gt;actual parameter&lt;/strong&gt; &lt;code&gt;w1, ... , wn&lt;/code&gt; 으로 &lt;strong&gt;substitution&lt;/strong&gt; 된다. &lt;br/&gt;&lt;/p&gt;

&lt;p&gt;(3) &lt;code&gt;new Class(v1, ... , vm)&lt;/code&gt; 이 &lt;code&gt;this&lt;/code&gt; 로 치환되고&lt;/p&gt;

&lt;p&gt;(4) &lt;code&gt;f&lt;/code&gt; 의 바디 &lt;code&gt;b&lt;/code&gt; 가 평가된다.&lt;/p&gt;

&lt;p&gt;따라서 이를 식으로 표현하면, 다음과 같이 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[v1/x1, ... , vm/xm][w1/y1, ... , wn/yn][new C(v1, ..., vm)/this]b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;그러면, 예제를 통해서 살펴보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;new Rational(1, 2).less(new Rational(2, 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이건 ¤음과 같이 평가된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;[1/2, 2/y][new Rational(2, 3)/that][new Rational(1, 2)/this] this.numer * that.denom &amp;lt; that.numer * this denom
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결국 이건 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;new Rational(1, 2).numer * new Rational(2, 3).denom &amp;lt; new Rational(2, 3).numer * new Rational(1, 2).denom

// 1 * 3 &amp;lt; 2 * 2
// true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;operators&#34;&gt;Operators&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Int&lt;/code&gt; 의 경우에는 &lt;code&gt;+&lt;/code&gt; 를 사용하면 &lt;code&gt;3 + 5&lt;/code&gt; 와 같이 표현할 수 있지만 &lt;code&gt;Rational&lt;/code&gt; 의 경우에는 &lt;code&gt;r.add(r2)&lt;/code&gt; 와 같이 사용해야 했다. 뭔가 불편하다.&lt;/p&gt;

&lt;p&gt;스칼라에는 이런 문제를 해결하기 위해 &lt;strong&gt;Infix Notation&lt;/strong&gt; 이 있다. 함수의 인자가 하나라면, 괄호를 생략하는 것이다. 바이너리 오퍼레이터처럼 보일 수 있도록.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;r add s // r.add(s)
r less s // r less s
r max s // r max s
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;relaxed-identifiers&#34;&gt;Relaxed Identifiers&lt;/h4&gt;

&lt;p&gt;스칼라에서는 &lt;strong&gt;operator&lt;/strong&gt; 또한 &lt;strong&gt;identifier&lt;/strong&gt; 가 될 수 있다. 스칼라에서 &lt;strong&gt;identifier&lt;/strong&gt; 룰은 아래와 같다&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(1). &lt;strong&gt;Alphanumeric:&lt;/strong&gt; starting with a letter, followed by a sequence of letters or numbers &lt;br/&gt;&lt;/p&gt;

&lt;p&gt;(2). &lt;strong&gt;Symbolic:&lt;/strong&gt; starting with an operator symbol, followed by other character operator symbols &lt;br/&gt;&lt;/p&gt;

&lt;p&gt;(3). The underscore character &lt;code&gt;_&lt;/code&gt; counts as a letter &lt;br/&gt;&lt;/p&gt;

&lt;p&gt;(4). Alphanumeric identifiers can also end in an underscore, followed by some operator symbols&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+?%&amp;amp;&lt;/code&gt;, &lt;code&gt;vector_++&lt;/code&gt;, &lt;code&gt;counter_=&lt;/code&gt; 모두 유효한 identifier 들이다.&lt;/p&gt;

&lt;p&gt;이제 이런 symbolic identifier 들을 이용해서 &lt;code&gt;Rational&lt;/code&gt; 클래스의 함수 이름들을 산술연산 처럼 보이도록 변경해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Rational(x: Int, y: Int) {
  require(y &amp;gt; 0, &amp;quot;denom != 0&amp;quot;)

  // secondary constructor
  def this(x: Int) = this(x, 1)

  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
  private val g = abs(gcd(x, y))

  def numer = x / g
  def denom = y / g

  def &amp;lt; (that: Rational) = numer * that.denom &amp;lt; that.numer * denom
  def max(that: Rational) = if (this &amp;lt; that) that else this

  def + (that: Rational) = {
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }

  def - (that: Rational) = {
    this + -that
  }

  def unary_- = new Rational(-numer, denom)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;재밌는 점은 &lt;code&gt;neg&lt;/code&gt; 를 &lt;strong&gt;unary operator&lt;/strong&gt; &lt;code&gt;-&lt;/code&gt; 로 만들기 위해 &lt;code&gt;unary_&lt;/code&gt; 를 이용해서 &lt;code&gt;unary_-&lt;/code&gt; 로 정의했다는 것이다.&lt;/p&gt;

&lt;p&gt;참고로, return 값을 주기 위해서 &lt;code&gt;unary-_: Rational&lt;/code&gt; 과 같이 정의하면 에러가 난다. &lt;code&gt;:&lt;/code&gt; 가 포함된 identifier 로 인식하기 때문에 &lt;code&gt;unary-_ :&lt;/code&gt; 로 스페이스를 꼭 주어야 한다.&lt;/p&gt;

&lt;h4 id=&#34;precedence-rules&#34;&gt;Precedence Rules&lt;/h4&gt;

&lt;p&gt;그렇다면 &lt;code&gt;x * x + y&lt;/code&gt; 와 같은 경우 &lt;code&gt;*&lt;/code&gt; 가 먼저 계산되어야 하는데, 이런건 어떻게 해결할까? 우리가 만든건 정수 연산자가 아니라 함수인데.&lt;/p&gt;

&lt;p&gt;이를 위해 스칼라는 다음과 같은 룰을 만들어 두었다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The precedence of an operator is determined by its first character. The following table lists the characters in increasing order of priority precedence&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;(all letters) // Alphanumeric
|
^
&amp;amp;
&amp;lt; &amp;gt;
= !
:
+ -
* / %
(all other special characters)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;identifier 의 첫글자가 미리 정의된 테이블에 있다면 우선순위가 정해지는 룰이다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Functional Programming 3</title>
      <link>https://1ambda.github.io/21/scala/functional-programming-3/</link>
      <pubDate>Sat, 25 Jun 2016 00:47:08 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/functional-programming-3/</guid>
      <description>

&lt;h3 id=&#34;3-1-class-hierarchies&#34;&gt;3.1 Class Hierarchies&lt;/h3&gt;

&lt;h4 id=&#34;abstract-classes&#34;&gt;Abstract Classes&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;abstract class&lt;/strong&gt; 는 다른 언어의 그것과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;abstract class IntSet {
  def contains(x: Int): Boolean
  def incl(x: Int): IntSet
}

object EmptySet extends IntSet {
  def contains(x: Int) = false
  def incl(x: Int) = new NonEmptySet(x, EmptySet, EmptySet)
}

class NonEmptySet(elem: Int, left: IntSet, right: IntSet) extends IntSet {
  def contains(x: Int) = {
    if (x &amp;lt; elem) left contains x
    else if (x &amp;gt; elem) right contains x
    else true
  }

  def incl(x: Int) = {
    if (x &amp;lt; elem) new NonEmptySet(elem, left incl x, right)
    else if (x &amp;gt; elem) new NonEmptySet(elem, left, right incl x)
    else this
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 재밌는 점은 &lt;code&gt;incl&lt;/code&gt; 을 수행할때 새로운 서브트리를 매번 만든다는 것인데, 이건 이 프로그램이 &lt;code&gt;immutable&lt;/code&gt; 하다는 것을 말한다.&lt;/p&gt;

&lt;p&gt;이전의 데이터들을 변경하지 않으므로 &lt;strong&gt;persistent data structures&lt;/strong&gt; 라 볼 수 있다.&lt;/p&gt;

&lt;p&gt;클래스에서는 다른 언어와 마찬지로 &lt;strong&gt;override&lt;/strong&gt; 를 이용해서 existing 혹은 non-abstract definition 을 서브클래스에서 &lt;strong&gt;재정의(redefined)&lt;/strong&gt; 할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;object-definitions&#34;&gt;Object Definitions&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;object&lt;/code&gt; 키워드를 이용하면 &lt;strong&gt;singleton object&lt;/strong&gt; 를 만든다. 그리고 &lt;strong&gt;singleton object&lt;/strong&gt; 는 value 이기 때문에, 그 자체로 evaluate 된다. 다시말해 evaluation step 이 수행 될 필요가 없다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object EmptySet extends IntSet {
  def contains(x: Int) = false
  def incl(x: Int) = new NonEmptySet(x, EmptySet, EmptySet)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;exercisee&#34;&gt;Exercisee&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a method &lt;code&gt;union&lt;/code&gt; for forming the union of two sets. You should implement the following abstract class&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def union(other: IntSet): IntSet = {
    ((left union right) union other) incl elem
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;해석하면 terminal node 의 경우, union 연산이 &lt;code&gt;other incl elem&lt;/code&gt; 이 된다. 게다가 매번의 &lt;code&gt;left union right&lt;/code&gt; 연산은 현재보다 더 작은 단위를 호출하고, &lt;code&gt;(left union right) union other&lt;/code&gt; 은 적어도 좌측 operand 가 적어 현재보다 1개 작은 elem 을 가지고 있기 때문에 최소한 자기 자신을 다시 호출하지 않는다는 것을 알 수 있다. 따라서 이런 점을 고려하면 함수는 언젠가 끝난다는 것을 알 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;dynamic-binding&#34;&gt;Dynamic Binding&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Object-oriented language implement dynamic method dispatch. This means that the code invoked by a method call depends on the runtime type of the object that contains the method&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이렇게 보면, &lt;strong&gt;Dynamic dispatch&lt;/strong&gt; 는 ** higher-orher functions** 와 유사한데, 둘 다 static 타임에 어떤 함수가 실행될 지 알 수 없다. 그럼 둘을 섞으면 어떻게 될까?&lt;/p&gt;

&lt;h3 id=&#34;3-2-how-classes-are-organized&#34;&gt;3.2 How Classes Are Organized&lt;/h3&gt;

&lt;p&gt;스칼라에서 class 들은 &lt;strong&gt;package&lt;/strong&gt; 로 관리된다. 스칼라에서 자동으로 임포트하는 것들은&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All members of package &lt;code&gt;scala&lt;/code&gt; like scala.Int&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;All members of package &lt;code&gt;java.lang&lt;/code&gt; like java.lang.Object&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;All members of the singleton object  &lt;code&gt;scala.Predef&lt;/code&gt; like scala.Predef.require&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;trait&#34;&gt;Trait&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;A trait is declared like an abstract class, just with trait instead of abstract class&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Planar {
  def height: Int
  def width: Int
  def surface = height * width
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Trait&lt;/strong&gt; 는 자바의 &lt;strong&gt;Interface&lt;/strong&gt; 와 비슷하지만, fields 와 concrete methods 를 포함할 수 있다는 점에서 더 강력하다. 반면 &lt;strong&gt;Trait&lt;/strong&gt; 는 parameter 를 가질 수 없다.&lt;/p&gt;

&lt;h4 id=&#34;scala-s-hierarchy&#34;&gt;Scala&amp;rsquo;s Hierarchy&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://librairie.immateriel.fr/baw/9780596155957/httpatomoreillycomsourceoreillyimages322250.png&#34; /&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;(http://librairie.immateriel.fr/fr/read_book/9780596155957/ch07s04#scalas-type-hierarchy)&lt;/p&gt;

&lt;p&gt;그림을 보면 알겠지만, 가장 상위에 &lt;code&gt;scala.Any&lt;/code&gt; 가 있고, 그 아래로 기본 타입들은 &lt;code&gt;scala.AnyVal&lt;/code&gt; 아래에 위치한다. 스칼라의 &lt;code&gt;Double&lt;/code&gt; 은 자바의 &lt;code&gt;double&lt;/code&gt; 와 일치한다. &lt;code&gt;java.lang.Double&lt;/code&gt; 과는 다르다. &lt;code&gt;java.lang.Double&lt;/code&gt; 은 아래 설명을 보면 알겠지만, &lt;code&gt;AnyRef&lt;/code&gt; 하위에 위치한다.&lt;/p&gt;

&lt;p&gt;레퍼런스 타입은 &lt;code&gt;scala.AnyRef&lt;/code&gt; 아래에 위치 한다. 그리고 &lt;code&gt;scala.AnyRef&lt;/code&gt; 는 자바의 &lt;code&gt;java.lang.Object&lt;/code&gt; 와 동일하다. 모든 스칼라 오브젝트들은 &lt;code&gt;scala.AnyRef&lt;/code&gt; 를 하위에 위치한다. 받는다.&lt;/p&gt;

&lt;p&gt;정리하자면 primitive type 은 &lt;code&gt;scala.AnyVal&lt;/code&gt; 하위에 있고, object 는 &lt;code&gt;scala.AnyRef&lt;/code&gt; 하위에 있다고 보면 된다.&lt;/p&gt;

&lt;p&gt;그리고 하위에 보면 &lt;code&gt;scala.Nothing&lt;/code&gt; 과 &lt;code&gt;scala.Null&lt;/code&gt; 이 &lt;strong&gt;Trait&lt;/strong&gt; 로 존재하는 걸 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;p&gt;&lt;img src=&#34;http://docs.scala-lang.org/resources/images/classhierarchy.img_assist_custom.png&#34; /&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;http://docs.scala-lang.org/tutorials/tour/unified-types.html&#34;&gt;http://docs.scala-lang.org/tutorials/tour/unified-types.html&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;그림이 좀 작긴 한데, 자세히 보면 dotted arrow  가 있는걸 볼 수 있다. 이건 해당 타입이 화살표가 이어진 곳에 있는 타입으로 자동으로 converted 될 수 있는지의 여부다. 따라서 아래와 같은 &lt;strong&gt;REPL&lt;/strong&gt; 실행 결과를 얻을 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; val a: Byte = 1
a: Byte = 1

scala&amp;gt; val b: Short = a
b: Short = 1

scala&amp;gt; b
res0: Short = 1

scala&amp;gt; val c: Byte = b
&amp;lt;console&amp;gt;:9: error: type mismatch;
 found   : Short
 required: Byte
       val c: Byte = b
                     ^
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;top-types&#34;&gt;Top Types&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Any&lt;/code&gt; 은 모든 타입의 베이스 타입으로, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;equals&lt;/code&gt;, &lt;code&gt;hashCode&lt;/code&gt;, &lt;code&gt;toString&lt;/code&gt; 등의 메소드를 포함하고 있다.&lt;/p&gt;

&lt;h4 id=&#34;the-nothing-type&#34;&gt;The Nothing Type&lt;/h4&gt;

&lt;p&gt;&lt;br/&gt;
&lt;p&gt;&lt;img src=&#34;http://docs.scala-lang.org/resources/images/classhierarchy.img_assist_custom.png&#34; /&gt;&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;http://docs.scala-lang.org/tutorials/tour/unified-types.html&#34;&gt;http://docs.scala-lang.org/tutorials/tour/unified-types.html&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Nothing&lt;/code&gt; 은 Scala&amp;rsquo;s type hierarchy 가장 아래쪽에 위치하는데, &lt;strong&gt;모든 타입의 subtype&lt;/strong&gt; 이다. &lt;code&gt;Nothing&lt;/code&gt; 은 또한 값이 없는데, 다음의 두 가지 경우 유용하다.&lt;/p&gt;

&lt;p&gt;(1). To signal abnormal termination&lt;br /&gt;
(2). As an element type of empty collections. ex) &lt;code&gt;Set[Nothing]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;참고로, &lt;code&gt;Exception&lt;/code&gt; 의 타입도 &lt;code&gt;Nothing&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&#34;null&#34;&gt;Null&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Null&lt;/code&gt; 은 모든 &lt;code&gt;scala.AnyRef&lt;/code&gt; 하위에 있는 타입의 서브타입이다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Every reference class type also has null as a value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;null&lt;/code&gt; 의 type 이 바로 &lt;code&gt;Null&lt;/code&gt; 이다. &lt;code&gt;Null&lt;/code&gt; 은 &lt;code&gt;java.lang.Object&lt;/code&gt;, 즉 &lt;code&gt;scala.AnyRef&lt;/code&gt; 를 상속받는 모든 클래스의 서브타입이기 때문에 &lt;code&gt;scala.AnyVal&lt;/code&gt; 과는 incompatible 하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;
scala&amp;gt; null
res1: Null = null

scala&amp;gt; val a:String = null
a: String = null

scala&amp;gt; val b: Int =  null
&amp;lt;console&amp;gt;:7: error: an expression of type Null is ineligible for implicit conversion
       val b: Int =  null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로 &lt;code&gt;if (true) 1 else false&lt;/code&gt; 의 타입은 &lt;code&gt;AnyVal&lt;/code&gt; 인데 &lt;code&gt;1&lt;/code&gt;과 &lt;code&gt;false&lt;/code&gt; 의 공통적인 상위 타입은 &lt;code&gt;AnyVal&lt;/code&gt; 이기 때문이다.&lt;/p&gt;

&lt;h3 id=&#34;3-3-polymorphism&#34;&gt;3.3 Polymorphism&lt;/h3&gt;

&lt;p&gt;대부분의 함수형 언어에서 기본적인 데이터 구조는 &lt;strong&gt;immutable linked list&lt;/strong&gt; 다. 이건 &lt;strong&gt;Nil&lt;/strong&gt; 과 &lt;strong&gt;Cons&lt;/strong&gt; 로 구성되어 있는데, &lt;strong&gt;Nil&lt;/strong&gt; 은 empty list 를, &lt;strong&gt;Cons&lt;/strong&gt; 는 element 를 담고있는 부분을 말한다. 리습의 그것과 같다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Cons-cells.svg/525px-Cons-cells.svg.png&#34; /&gt;&lt;/p&gt;&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Cons&#34;&gt;http://en.wikipedia.org/wiki/Cons&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이번시간엔, &lt;code&gt;Cons&lt;/code&gt; 와 &lt;code&gt;Nil&lt;/code&gt; 들을 구현해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait List[T] {
  def isEmpty: Boolean
  def head: T
  def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {
  def isEmpty = false
}

class Nil[T] extends List[T] {
  def isEmpty = true
  def head = throw new NoSuchElementException(&amp;quot;Nil.head&amp;quot;)
  def tail = throw new NoSuchElementException(&amp;quot;Nil.tail&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 클래스에 있는 파라미터, &lt;code&gt;val head: T&lt;/code&gt; 를 &lt;strong&gt;&lt;em&gt;Value Parameter&lt;/em&gt;&lt;/strong&gt; 라 부른다. &lt;code&gt;val&lt;/code&gt; 의 경우에는 자동으로 &lt;strong&gt;public getter&lt;/strong&gt; 를 만들어 준다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code&gt;[T]&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 는 &lt;strong&gt;&lt;em&gt;Type Parameter&lt;/em&gt;&lt;/strong&gt; 다. 타입 파라미터는 클래스 뿐만 아니라 함수에도 적용할 수 있는데,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;def signleton[T](elem:T) = new Cons[T](elem, new Nil[T])&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;는 정상적으로 컴파일 된다. 물론 스칼라는 강력한 &lt;strong&gt;&lt;em&gt;Type Inference&lt;/em&gt;&lt;/strong&gt; 를 지원하기 때문에&lt;/p&gt;

&lt;p&gt;&lt;code&gt;singleton[Boolean](true)&lt;/code&gt; 대신 스칼라 컴파일러는 type inference 를 이용해서 &lt;code&gt;singleton(true)&lt;/code&gt; 혹은 &lt;code&gt;singleton(1)&lt;/code&gt; 를 받아들인다.&lt;/p&gt;

&lt;h4 id=&#34;types-and-evaluation&#34;&gt;Types and Evaluation&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Type parameters do not affect evaluation in Scala&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;재밌게도 Scala 프로그램이 evaluation 될 때  &lt;code&gt;[T]&lt;/code&gt; 와 같은 &lt;strong&gt;Type parameters&lt;/strong&gt; 는 전혀 영향을 미치지 않는다. 왜냐하면 Scala 가 evaluation 전에 모든 &lt;strong&gt;Type parameters&lt;/strong&gt; 와 &lt;strong&gt;Type arguments&lt;/strong&gt; 를 제거하기 때문이다.&lt;/p&gt;

&lt;p&gt;이 과정은 &lt;strong&gt;&lt;em&gt;Type erasure&lt;/em&gt;&lt;/strong&gt; 로 불린다. Java, Scala, Haskell, ML, OCaml 등은 &lt;strong&gt;&lt;em&gt;Type erasure&lt;/em&gt;&lt;/strong&gt; 를 이용하고, 런타임에도 &lt;strong&gt;Type parameters&lt;/strong&gt; 를 유지하는 언어는 C++, C#, F# 등이 있다.&lt;/p&gt;

&lt;h4 id=&#34;polymorphism&#34;&gt;Polymorphism&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Polymorphism&lt;/strong&gt; 은 &lt;em&gt;&amp;ldquo;in many forms&amp;rdquo;&lt;/em&gt; 라는 뜻이다. 프로그래밍에서는 다음과 같은 의미를 가진다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(1) the function can be applied to arguments of many types or &lt;br/&gt;
(2) the type can have instances of many types&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 정의로부터 두 가지 사실을 끌어낼 수 있는데,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(1) &lt;strong&gt;subtyping:&lt;/strong&gt; instances of a subclass can be passed to a base class  &lt;br/&gt;
(2) &lt;strong&gt;generics:&lt;/strong&gt; instances of a function or class are created by type parameterization&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;사실 &lt;strong&gt;subtyping&lt;/strong&gt; 은 OOP 언어에서 먼저 온 것이고, &lt;strong&gt;generics&lt;/strong&gt; 는 함수형 언어에서 온 것이나, Scala 는 모두 사용한다.&lt;/p&gt;

&lt;p&gt;중요한 내용이므로 다시 한 번 정리 하면 &lt;strong&gt;다형성&lt;/strong&gt; 이란, 다양한 형태를 가지고 있다는 뜻인데, 프로그래밍에서는 다음과 같은 의미를 지닌다.&lt;/p&gt;

&lt;p&gt;(1) 함수는 다양한 타입의 인자를 받아들일 수 있다.&lt;br /&gt;
(2) 타입은 다양한 타입의 인스턴스를 가질 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 함수나 클래스의 인스턴스는 &lt;strong&gt;&lt;em&gt;type parameterization&lt;/em&gt;&lt;/strong&gt; 을 통해 생성될 수 있으며, 하위 클래스의 인스턴스는 상위 클래스로서 동작할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;exercise&#34;&gt;Exercise&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Write a function &lt;code&gt;nth&lt;/code&gt; that takes an interger &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; list and selects the n&amp;rsquo;th element of the list&lt;br/&gt; &lt;br/&gt;
If index is outside the range from 0 up the length of the list minus one, a &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; should be thrown&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def nth[T](n: Int, list: List[T]): T = {
  if (list.isEmpty) throw new IndexOutOfBoundsException(&amp;quot;out of bound index&amp;quot;)
  else if (n == 0) list.head
  else nth(n - 1, list.tail)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Functional Programming 4</title>
      <link>https://1ambda.github.io/21/scala/functional-programming-4/</link>
      <pubDate>Sat, 25 Jun 2016 00:47:10 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/functional-programming-4/</guid>
      <description>

&lt;h2 id=&#34;types-and-pattern-matching&#34;&gt;Types and Pattern Matching&lt;/h2&gt;

&lt;h3 id=&#34;functions-as-objects&#34;&gt;Functions as Objects&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;In fact function values are treated as objects in Scala&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Function1[A, B] {
  def apply(x: A): B
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결국, &lt;code&gt;function&lt;/code&gt; 은 &lt;code&gt;apply&lt;/code&gt; 메소드를 가진 오브젝트다.&lt;/p&gt;

&lt;p&gt;예를 들어서 &lt;code&gt;(x: Int) =&amp;gt; x * x&lt;/code&gt; 는 다음과 같이 &lt;code&gt;Function1&lt;/code&gt; ` &lt;em&gt;trait&lt;/em&gt; 를 구현한 클래스 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;{
  class AnonFun extends Function1[Int, Int] (
    def apply(x: Int) = x * x
  }

  new AnonFun
}

// or using anonymous class syntax
// trait can be instanciated

new Function1[Int, Int] {
  def apply(x: Int) = x * x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 이런 정의를 보면, &lt;code&gt;f(a, b)&lt;/code&gt; 는 &lt;code&gt;f.apply(a, b)&lt;/code&gt; 다. 그런데 만약 메소드인 &lt;code&gt;def apply&lt;/code&gt; 자체도 오브젝트일까? 그렇지 않다. 만약 &lt;code&gt;apply&lt;/code&gt; 자체도 오브젝트라면, 그 오브젝트도 &lt;code&gt;apply&lt;/code&gt; 메소드를 가지고 있어야 하고, 또 다시 그렇게 반복될 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;functions-and-methods&#34;&gt;Functions and Methods&lt;/h4&gt;

&lt;p&gt;따라서 &lt;code&gt;def f(x: Int): Int = ...&lt;/code&gt; 메소드 자체는 &lt;strong&gt;Function&lt;/strong&gt; 이 아니¤. (&lt;em&gt;Method != Function&lt;/em&gt;) 그러나&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If &lt;code&gt;f&lt;/code&gt; is used in a place where a &lt;code&gt;Function&lt;/code&gt; type is expected, it is converted automatically to the function value&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를 들어, &lt;code&gt;(x: Int) = f(x)&lt;/code&gt; 는 다음과 같이 확장된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;new Function1[Int Int] {
 def apply(x: Int) = f(x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 &lt;em&gt;Method&lt;/em&gt; 가 &lt;em&gt;Function&lt;/em&gt; 으로 변환되는 과정을 &lt;em&gt;lambda calculus&lt;/em&gt; 에서는 &lt;strong&gt;eta-expansion&lt;/strong&gt; 이라 부른다.&lt;/p&gt;

&lt;p&gt;그리고 위에서 보았겠지만 &lt;code&gt;apply&lt;/code&gt; 메소드는, 오브젝트에 있을때 오브젝트 이름 자체로 호출될 수 있도록 해준다. 예를들어 지난 시간에 만들었던 &lt;code&gt;List&lt;/code&gt; &lt;em&gt;trait&lt;/em&gt; 에 대해서,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait List[T] {
  def isEmpty: Boolean
  def head: T
  def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {
  def isEmpty = false
}

class Nil[T] extends List[T] {
  def isEmpty = true
  def head = throw new NoSuchElementException(&amp;quot;Nil.head&amp;quot;)
  def tail = throw new NoSuchElementException(&amp;quot;Nil.tail&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래와 같은 호출을 한다면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val e = List()
val e3 = List(3)
val e34 = List(3, 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음과 같이 &lt;code&gt;List&lt;/code&gt; &lt;em&gt;Object&lt;/em&gt; 와 &lt;code&gt;apply&lt;/code&gt; &lt;em&gt;Method&lt;/em&gt; 를 정의할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object List {
  def apply() = new Nil
  def apply(x: Int) = new Cons(x, new Nil)
  def apply(x: Int, y: Int) = new Cons(x, new Cons(y, new Nil))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;subtyping-and-generics&#34;&gt;Subtyping and Generics&lt;/h3&gt;

&lt;p&gt;지난시간에는 &lt;em&gt;Polymorphism&lt;/em&gt; 의 두가지 형태에 대해 배웠었다. 하나는 &lt;strong&gt;Subtyping&lt;/strong&gt; 이고, 다른 하나는 &lt;strong&gt;Generics&lt;/strong&gt; 다. 기억을 더듬어 보면&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Subtyping:&lt;/strong&gt; Instance of a subclass can be passed to a base class&lt;br /&gt;
&lt;strong&gt;Generics:&lt;/strong&gt; Instance of a function or class are created  by type parameterazation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 중에서 &lt;em&gt;subtyping&lt;/em&gt; 은 OOP 에서 먼저 온 것이고, &lt;em&gt;generics&lt;/em&gt; 는 &lt;em&gt;FP&lt;/em&gt; 에서 먼저 온 것이라는 이야기 까지 했다.&lt;/p&gt;

&lt;h4 id=&#34;type-bounds&#34;&gt;Type Bounds&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;assertAllPos&lt;/code&gt; 메소드가 있다고 하자. &lt;code&gt;IntSet&lt;/code&gt; 을 취해서, 모든 Element 가 양수면 &lt;code&gt;IntSet&lt;/code&gt; 을 리턴하고 아니면 예외를 던진다. 다음과 같이 정의할 수 있겠다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;def assertAllPos(s: IntSet): IntSet&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;근데, 만약에 이 메소드가 &lt;code&gt;Empty&lt;/code&gt; 를 받으면 &lt;code&gt;Empty&lt;/code&gt; 를, &lt;code&gt;NonEmpty&lt;/code&gt; 를 받으면 &lt;code&gt;NonEmpty&lt;/code&gt; 를 돌려주게 하려면 어떻게 해야할까? 메소드를 2개를 더 만들어야 할까? &lt;em&gt;Type Bound&lt;/em&gt; 를 이용해 문제를 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;def assertAllPos[S &amp;lt;: IntSet](r: S): S = ...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;S &amp;lt;: IntSet&lt;/code&gt; 은 &lt;code&gt;S&lt;/code&gt; 가 &lt;code&gt;IntSet&lt;/code&gt; 의 서브타입임을 말하고, 이것을 &lt;strong&gt;Upper bound&lt;/strong&gt; 라 부른다(&lt;code&gt;IntSet&lt;/code&gt; 기준). 즉 &lt;code&gt;S&lt;/code&gt; 의 상위 타입을 지정하는 것이다.&lt;/p&gt;

&lt;p&gt;반대로 &lt;code&gt;S :&amp;gt; IntSet&lt;/code&gt; 도 있을 수 있다. 이것은 &lt;strong&gt;Lower bound&lt;/strong&gt; 라 부르며(&lt;code&gt;IntSet&lt;/code&gt; 기준), 이 메소드가 &lt;code&gt;IntSet&lt;/code&gt; 의 상위 타입 &lt;code&gt;S&lt;/code&gt; 를 이용한다는 것을 컴파일 타임에 지정한다. &lt;code&gt;S&lt;/code&gt; 는 &lt;code&gt;IntSet&lt;/code&gt;, &lt;code&gt;AnyRef&lt;/code&gt;, &lt;code&gt;Any&lt;/code&gt; 가 될 수 있다. 정리 하자면,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;S &amp;lt;: T&lt;/code&gt; means: &lt;strong&gt;S is a subtype of T&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;S :&amp;gt; T&lt;/code&gt; means: &lt;strong&gt;S is a supertype of T, or T is a subtype of S&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Mixed Bound&lt;/strong&gt; 도 있다. &lt;code&gt;[S &amp;gt;: NonEmpty &amp;lt;: IntSet]&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;covariance&#34;&gt;Covariance&lt;/h4&gt;

&lt;p&gt;그런데, &lt;code&gt;NonEmpty &amp;lt;: IntSet&lt;/code&gt; 일때 &lt;code&gt;List[NonEmpty] &amp;lt;: List[IntSet]&lt;/code&gt; 이면, &lt;strong&gt;Covariant&lt;/strong&gt; 하다고 말한다. 직관적으로 보면 그럴듯 하다.&lt;/p&gt;

&lt;p&gt;이거 정말 문제가 없을까? &lt;code&gt;List&lt;/code&gt; 말고 자바의 &lt;code&gt;Array&lt;/code&gt; 를 예로 들어보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;NonEmpty[] a =
  new NonEmpty[]{new NonEmpty(1, Empty, Empty)}

IntSet[] b = a
b[0] = Empty
NonEmpty s = a[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;b[0] = Empty&lt;/code&gt; 가 문제가 된다. 여기서 런타임 예외가 발생하는데, 자바에서는 배열이 생성될때, 이 배열이 어떤 타입으로 생성되었는지 내부적으로 태그를 붙인다. 그런데, &lt;code&gt;NonEmpty&lt;/code&gt; 로 태그가 붙은 배열에 호환되지 않는 &lt;code&gt;Empty&lt;/code&gt; 를 넣고 있기 때문이다.&lt;/p&gt;

&lt;p&gt;자바 1.5 이전에는 Generics 가 없었기 때문에 정렬을 위해서는 &lt;code&gt;sort(Object[] a)&lt;/code&gt; 처럼 주어야 했는데, 이를 위해서는 자바의 배열이 &lt;strong&gt;Covariant&lt;/strong&gt; 여야 했다.&lt;/p&gt;

&lt;h4 id=&#34;the-liskov-substitution-principle&#34;&gt;The Liskov Substitution Principle&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Liskov Substitution Princile(리스코프 치환원칙)&lt;/strong&gt; 은 언제 한 입이 다른 타입의 서브타입이 될 수 있는지 말해준다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If &lt;code&gt;A &amp;lt;: B&lt;/code&gt;, then everything one can to do with a value of type &lt;code&gt;B&lt;/code&gt; one should also be able to do with a value of type &lt;code&gt;A&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자 이제, Scala 에서 위의 코드를 작성하면 어디서 에러가 나는지 확인 해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val a: Array[NonEmpty] = Array(new NonEmpty(1, Empty, Empty))
val b Array[IntSet] = a
b(0) = Empty
val s: NonEmpty = a(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;val b: Array[IntSet] = a&lt;/code&gt; 에서 컴파일 타임 에러가 난다. 왜냐하면 Scala 의 &lt;code&gt;Array&lt;/code&gt; 는 &lt;strong&gt;Not&lt;/strong&gt; &lt;em&gt;covariant&lt;/em&gt; 이기 때문이다.&lt;/p&gt;

&lt;h3 id=&#34;variance&#34;&gt;Variance&lt;/h3&gt;

&lt;p&gt;어떤 타입은 &lt;em&gt;covariant&lt;/em&gt; 고 어떤 타입은 그렇지 않은걸까? 엄격히 말해서, elements 들의 &lt;em&gt;mutation&lt;/em&gt; 을 허용하는 타입은 &lt;em&gt;not-covariant&lt;/em&gt; 여야 한다.&lt;/p&gt;

&lt;p&gt;반면 &lt;em&gt;immutable types&lt;/em&gt; 은 조건이 갖춰지면 &lt;em&gt;covariant&lt;/em&gt; 일 수 있다. 위에서 &lt;code&gt;List&lt;/code&gt; 는 되고, &lt;code&gt;Array&lt;/code&gt;는 안되었던 것처럼.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C[T]&lt;/code&gt; 가 있고, &lt;code&gt;A &amp;lt;: B&lt;/code&gt; 일때 다음과 같은 정의를 내릴 수 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C[A] &amp;lt;: C[B]&lt;/code&gt; 이면, &lt;strong&gt;C is covariant&lt;/strong&gt;, &lt;code&gt;C[+A]&lt;/code&gt; 로 표시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C[A] &amp;gt;: C[B]&lt;/code&gt; 이면, &lt;strong&gt;C is contravariant&lt;/strong&gt;, &lt;code&gt;C[-A]&lt;/code&gt; 로 표시&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C[A]&lt;/code&gt; 와 &lt;code&gt;C[B]&lt;/code&gt; 가 상관이 없으면, &lt;strong&gt;C is non-variant&lt;/strong&gt;, , &lt;code&gt;C[A]&lt;/code&gt; 로 표시&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면 다음과 같은 두개의 타입이 있을때, 어떤것이 서브타입이고 어떤  것이 슈퍼타입일까?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type A = IntSet =&amp;gt; NonEmpty
type B = NonEmpty =&amp;gt; IntSet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;설명을 조금 자세히 하면, 함수의 파라미터는 &lt;em&gt;Contravariant&lt;/em&gt; 하고, 함수의 리턴타입은 &lt;em&gt;Covariant&lt;/em&gt; 하다. &lt;code&gt;Function1[-A, +B]&lt;/code&gt; 를 보면 알 수 있다. 따라서 &lt;code&gt;A &amp;lt;: B&lt;/code&gt; 다. 왜 그럴까? 여기 &lt;a href=&#34;https://twitter.github.io/scala_school/type-basics.html#variance&#34;&gt;Scala School&lt;/a&gt; 의 예제를 좀 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Animal {
  val sound = &amp;quot;rustle&amp;quot;
  def name = &amp;quot;animal&amp;quot;
}

class Bird extends Animal {
  override val sound = &amp;quot;call&amp;quot;
  def name = &amp;quot;bird&amp;quot;
}
class Chicken extends Bird {
  override val sound = &amp;quot;cluck&amp;quot;
  def name = &amp;quot;chicken&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이때, &lt;code&gt;val getTweet: (Bird =&amp;gt; String)&lt;/code&gt; 에 &lt;code&gt;(c: Chicken =&amp;gt;  c.chicken&lt;/code&gt; 과 같이 넘겨주고, 나중에 &lt;code&gt;getTweet(new Bird)&lt;/code&gt; 를 호출하면 에러가 난다. 반면 &lt;code&gt;a: Animal =&amp;gt; a.name&lt;/code&gt; 을 주고, &lt;code&gt;getTweek(new Bird)&lt;/code&gt; 는 상관 없다. 어차피 &lt;code&gt;Bird&lt;/code&gt; 는 &lt;code&gt;Animal&lt;/code&gt; 이니까&lt;/p&gt;

&lt;p&gt;따라서 함수의 파라미터는 현재와 같은 타입이거나, 혹은 그 슈퍼타입이어야 한다, 다시말해서 &lt;strong&gt;Contravariant&lt;/strong&gt; 해야 한다.&lt;/p&gt;

&lt;h4 id=&#34;variance-checks&#34;&gt;Variance Checks&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Array&lt;/code&gt; 의 경우 &lt;code&gt;update&lt;/code&gt; 연산이 문제가 될 수 있다는걸 위에서 논의 했었는데, 이걸 정리하자면&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;*The problematic combination is&lt;br /&gt;
&lt;strong&gt;the covariant type parameter T&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;which appears in parameter position of method &lt;code&gt;update&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉 &lt;em&gt;covariant&lt;/em&gt; 타입 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;update&lt;/code&gt; 연산에 나타날때 문제가 된다. 그래서 Scala 는 컴파일 타임에 이런 문제가 생기지 않는지 검사를 한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;covariant&lt;/em&gt; type parameters can only appear in method results&lt;br /&gt;
&lt;em&gt;contravariant&lt;/em&gt; type parameters can only appear in method parameters&lt;br /&gt;
&lt;em&gt;invariant&lt;/em&gt; type parameters can appear anywhere&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Function1&lt;/code&gt; &lt;em&gt;Trait&lt;/em&gt; 는 그래서 사실 이런 모양이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package scala
trait Function1[-T, +U] {
  def apply(x: T): U
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;T&lt;/code&gt; 는 &lt;em&gt;contravariant&lt;/em&gt; 이므로 파라미터에만, &lt;code&gt;U&lt;/code&gt; 는 &lt;em&gt;covaraint&lt;/em&gt; 이므로 리턴타입에만 나타난다. 이제 지난시간에 만들었던 &lt;code&gt;Nil&lt;/code&gt; 클래스를 &lt;em&gt;Object&lt;/em&gt; 로 만들어 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait List[+T] {
  def isEmpty: Boolean
  def head: T
  def tail: List[T]
}

class Cons[T](val head: T, val tail: List[T]) extends List[T] {
  def isEmpty = false
}

object Nil extends List[Nothing] {
  def isEmpty = true
  def head = throw new NoSuchElementException(&amp;quot;Nil.head&amp;quot;)
  def tail = throw new NoSuchElementException(&amp;quot;Nil.tail&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Nil&lt;/code&gt; 이 &lt;code&gt;List[Nothing]&lt;/code&gt; 을 상속하게 해, 모든 리스트의 서브타입이 될 수 있도록 했다. 그러나 이것만으로는 부족하다. &lt;code&gt;trait List[T]&lt;/code&gt; 로 만들면, &lt;code&gt;List[Something]&lt;/code&gt; 과 &lt;code&gt;List[Nothing]&lt;/code&gt; 과는 아무 관련이 없는 &lt;em&gt;non-variant&lt;/em&gt; 다. 따라서 &lt;code&gt;List[+T]&lt;/code&gt; 로 만들어, &lt;code&gt;List[Nothing] &amp;lt;: List[Something]&lt;/code&gt; 이 되도록 해야한다.&lt;/p&gt;

&lt;p&gt;이제, 다음과 같은 &lt;code&gt;prepend&lt;/code&gt; 메소드를 고려 해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait List[+T] {
  ...
  def preprend(elem: T): List[T] = new Cons(elem, this)
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 경우에는 &lt;em&gt;covariant&lt;/em&gt; &lt;code&gt;T&lt;/code&gt; 가 파라미터에 나오므로, 컴파일이 실패한다. 그러나 우리의 &lt;code&gt;List&lt;/code&gt; 는 &lt;em&gt;immutable&lt;/em&gt; 한데, 이 경우 파라미터에 &lt;code&gt;T&lt;/code&gt; 가 나오면 안되나?&lt;/p&gt;

&lt;h4 id=&#34;prepend-violates-lsp&#34;&gt;Prepend Violates LSP&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val xs = new List[IntSet]
xs.prepend(Empty)

val ys = new List[NonEmpty]
xs.prepend(Empty) // compilation fail
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서, &lt;code&gt;List[IntSet]&lt;/code&gt; 으로 할 수 있는걸 &lt;code&gt;List[NonEmpty]&lt;/code&gt;로 할 수 없으니, &lt;strong&gt;LSP&lt;/strong&gt; 에 따라서, &lt;code&gt;List[NonEmpty]&lt;/code&gt; 는 &lt;code&gt;List[IntSet]&lt;/code&gt; 의 서브타입이 될 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;List&lt;/code&gt; 는 &lt;em&gt;covariant&lt;/em&gt; 하고, &lt;code&gt;update&lt;/code&gt; 연산이 있는것도 아니므로 &lt;code&gt;immutable&lt;/code&gt; 한데, &lt;code&gt;prepend&lt;/code&gt; 메소드의 타입체킹이 문제다. 어떻게 하면 &lt;em&gt;covaraint&lt;/em&gt; 타입 &lt;code&gt;T&lt;/code&gt; 를 메소드 파라미터로 나타나게   수 있을까? &lt;strong&gt;Lower Bound&lt;/strong&gt; 를 이용하면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def prepend[U :&amp;gt; T](elem: U): List[U] = new Cons(elem, this)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 경우 &lt;code&gt;List[NonEmpty].prepend(Empty)&lt;/code&gt; 의 리턴값은 &lt;code&gt;List[IntSet]&lt;/code&gt; 이 될것이다. 따라서 룰을 정리하면&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(1) &lt;strong&gt;covariant type parameters&lt;/strong&gt; may appear in &lt;strong&gt;lower bounds&lt;/strong&gt; of method type parameters&lt;br /&gt;
(2) &lt;strong&gt;contravariant type parameters&lt;/strong&gt; may appear in &lt;strong&gt;upper bounds&lt;/strong&gt; of method&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;objects-everywhere&#34;&gt;Objects Everywhere&lt;/h3&gt;

&lt;h4 id=&#34;pure-object-orientation&#34;&gt;Pure Object Orientation&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Pure OO language&lt;/em&gt; 는 모든 &lt;em&gt;value&lt;/em&gt; 가 &lt;em&gt;object&lt;/em&gt; 다. 스칼라는 얼핏 보기에 &lt;em&gt;primitive type&lt;/em&gt; 을 사용하는 것 같지만 잘 보면 &lt;code&gt;scala.Boolean&lt;/code&gt;, &lt;code&gt;scala.Int&lt;/code&gt; 처럼 기본 타입이 클래스화 되어있다. (참고로 &lt;code&gt;Int&lt;/code&gt; 는 성능을 위해 32-bit Integer 로 되어있다.)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scala.Boolean&lt;/code&gt; 대신, 직접 만든 &lt;code&gt;Boolean&lt;/code&gt; 을 사용해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;abstract class cBoolean {

  def IfThenElse[T](t: T, e: T): T

  def &amp;amp;&amp;amp;(other: cBoolean) = IfThenElse(other, False)
  def ||(other: cBoolean) = IfThenElse(True, other)
  def unary_! : cBoolean = IfThenElse(False, True)

  def ==(other: cBoolean) = IfThenElse(other, other.unary_!)
  def !=(other: cBoolean) = IfThenElse(other.unary_!, other)

  def &amp;lt;(other: cBoolean) = IfThenElse(False, other)
  def &amp;gt;(other: cBoolean) = IfThenElse(other.unary_!, False)
}

object True extends cBoolean {
  def IfThenElse[T](t: T, e:T) = t
}

object False extends cBoolean {
  def IfThenElse[T](t: T, e:T) = e
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그럼 과연, &lt;em&gt;primitive type&lt;/em&gt; 없이 언어의 모든 부분을 클래스와 오브젝트로 구성하는것이 가능할까? &lt;code&gt;Boolean&lt;/code&gt; 은 우리가 &lt;code&gt;cBoolean&lt;/code&gt; 으로 대체했다. &lt;code&gt;Int&lt;/code&gt; 부터 더 자그마한 &lt;code&gt;Nat&lt;/code&gt;, 즉 자연수 범위부터 시작해보자.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Can it be represented as a class from first principles (i.e not using primitie ints)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;abstract class Nat {
  def isZero: Boolean
  def predecessor: Nat
  def successor = new Succ(this)
  def + (that: Nat): Nat
  def - (that: Nat): Nat
}

object Zero extends Nat {
  def isZero = true
  def predecessor = throw new RuntimeException(&amp;quot;Zero.predecessor&amp;quot;);
  def + (that: Nat) = that
  def - (that: Nat) = {
    if (that.isZero) this
    else throw new RuntimeException(&amp;quot;Zero.-&amp;quot;)
  }
}

class Succ(n: Nat) extends Nat {
  def isZero = false
  def predecessor: Nat = n
  def + (that: Nat) = new Succ(n + that)
  def - (that: Nat) = if(that.isZero) this else n - that.predecessor
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;숫자가 없을때 숫자를 추상화(abstraction) 할 방법을 찾아야 하는데, 놀랍게도 인스턴스의 중첩을, 숫자로 표현했다. 개인적으로 기가막힌다. 4강 초반부에서 집합을 predicate function 의 접합(&lt;code&gt;||&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;)으로 표현했을때도 놀라웠는데..&lt;/p&gt;

&lt;p&gt;위 코드에서 &lt;code&gt;Succ.-&lt;/code&gt; 메소드 같은 경우 &lt;code&gt;new Succ(n - that)&lt;/code&gt; 을 할 수 있는데, &lt;code&gt;n&lt;/code&gt; 이 &lt;code&gt;Zero&lt;/code&gt; 즉, 현재 &lt;code&gt;Succ&lt;/code&gt; 인스턴스가 1인 경우를 고려해야 한다. 이 경우 런타임 예외가 발생하므로, &lt;code&gt;n - that.predecessor&lt;/code&gt; 가 적절하다. 여기에 &lt;code&gt;that&lt;/code&gt; 이 &lt;code&gt;Zero&lt;/code&gt; 일 경우를 고려하면 된다.&lt;/p&gt;

&lt;p&gt;테스트를 작성할 경우 &lt;code&gt;Zero&lt;/code&gt; 를 제외하고는 나머지는 다 인스턴스라서, 비교가 어렵다. 그래서 다음과 같은 연속적인 &lt;code&gt;predecessor&lt;/code&gt; 를 호출할 수 있는데,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  val one = Zero.successor
  val two = one + one
  val three = two + one
  val four = three + one

  &amp;quot;One + One&amp;quot; should &amp;quot;be Two&amp;quot; in {
    assert(two.predecessor.predecessor == Zero)
  }

  &amp;quot;two + two&amp;quot; should &amp;quot;be four&amp;quot; in {
    assert(four.predecessor.predecessor.predecessor.predecessor == Zero)
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래와 같은 테스트용 유틸리티 함수를 만들면 편하다. (아니면 &lt;code&gt;==&lt;/code&gt;를 오버라이딩 하거나.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def number = {
    def count(n: Int, succ: Nat): Int = {
      if (succ == Zero) n
      else count(n + 1, succ.predecessor)
    }

    count(0, this)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게, 실제 타입에 대한 &lt;em&gt;primitive value&lt;/em&gt; 없이 &lt;em&gt;abstraction&lt;/em&gt; 만으로 타입을 구성할 수 있다. 위에서 구현한 &lt;code&gt;Nat&lt;/code&gt; 클래스를 기술적으로는 &lt;strong&gt;Peano numbers&lt;/strong&gt; 라 부른다. 다시 말해서,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The properties of the natural numbers can e derived from the &lt;strong&gt;Peano axioms&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자세한건 &lt;a href=&#34;http://en.wikipedia.org/wiki/Natural_number#Peano_axioms&#34;&gt;여기&lt;/a&gt;로&lt;/p&gt;

&lt;h3 id=&#34;decomposition&#34;&gt;Decomposition&lt;/h3&gt;

&lt;p&gt;프로그래밍의 많은 부분이 &lt;em&gt;Decomposition&lt;/em&gt; 이다. 타입을 비교하고 타입에 따라 처리하는 일들. 다음과 같은 아주 자그마한 컴파일러가 있다고 해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Decomposition {
  def eval(e: Expr): Int = {
    if (e.isNumber) e.numValue
    else if (e.isSum) eval(e.leftOp) + eval(e.rightOp)
    else throw new Error(s&amp;quot;unknown Expr $e&amp;quot;)
  }
}

trait Expr {
  def isNumber: Boolean
  def isSum: Boolean
  def numValue: Int
  def leftOp: Expr
  def rightOp: Expr
}

class Number(n: Int) extends Expr {
  def isNumber = true
  def isSum = false
  def numValue = n
  def leftOp = throw new Error(&amp;quot;Number.leftOp&amp;quot;)
  def rightOp = throw new Error(&amp;quot;Number.righOp&amp;quot;)
}

class Sum(l: Expr, r: Expr) extends Expr {
  def isNumber = false
  def isSum = true
  def numValue = throw new Error(&amp;quot;Sum.numValue&amp;quot;)
  def leftOp = l
  def rightOp = r
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음과 같은 테스트코드를 작성하면, 잘 돌아간다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sclaa&#34;&gt;  import Decomposition._

  &amp;quot;Sum(Number(3), Number(4))&amp;quot; should &amp;quot;be eql 7&amp;quot; in {
    val three = new Number(3)
    val four = new Number(4)
    val sum = new Sum(three, four)

    assert(eval(sum) == 7)
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위에서, &lt;code&gt;isNumber&lt;/code&gt; 과 같은 것들을 &lt;strong&gt;Classification&lt;/strong&gt;, &lt;code&gt;rightOp&lt;/code&gt;, &lt;code&gt;numValue&lt;/code&gt; 같은 것들을 &lt;strong&gt;Accessor&lt;/strong&gt; 라 부른다.&lt;/p&gt;

&lt;p&gt;문제는 만약 &lt;code&gt;Prod&lt;/code&gt; 나 &lt;code&gt;Var&lt;/code&gt; 같은 클래스들이 &lt;code&gt;Expr&lt;/code&gt; 을 상속했을 때 새로운 &lt;strong&gt;Classification&lt;/strong&gt; 과 &lt;strong&gt;Accessor&lt;/strong&gt; 를 작성 해야 한다는 거다. 무려 &lt;strong&gt;25&lt;/strong&gt; 개나! 단 두개의 클래스만 추가했을 뿐인데..&lt;/p&gt;

&lt;p&gt;일반적으로 새롭게 클래스를 정의했을때 메소드는 &lt;em&gt;quadratic&lt;/em&gt; 으로 증가한다. 이건 큰 문제다.&lt;/p&gt;

&lt;p&gt;이걸 해결하는 한가지 방법은, &lt;em&gt;Type Cast&lt;/em&gt; 와 &lt;em&gt;Type Test&lt;/em&gt; 를 이용하는거다. 자바에서 사용하는 아래의 두 메소드는&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;x instansceOf T
(T) x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;¤칼라에서 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x.isInstanceOf[T]
x.asInstanceOf[T]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 방법을 이용하면 &lt;code&gt;eval&lt;/code&gt; 함수에서 &lt;code&gt;if (e.isInstanceOf[Number])&lt;/code&gt; 와 같이 비교할 수 있기 때문에 &lt;em&gt;Classification Method&lt;/em&gt; 가 필요없다. 그러나, 타입캐스팅에 실패했을 경우 런타임 에러가 발생할 수 있다. 다른 방법은 없을까?&lt;/p&gt;

&lt;h4 id=&#34;object-oriented-decomposition&#34;&gt;Object-Oriented Decomposition&lt;/h4&gt;

&lt;p&gt;다른 한 가지 방법은, &lt;code&gt;eval&lt;/code&gt; 에서 타입체킹을 하는게 아니라 각 클래스에 &lt;code&gt;eval&lt;/code&gt; 메소드를 만드는거다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Expr {
  def eval: Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 방법의 문제는 &lt;code&gt;Expr&lt;/code&gt; 에 새로운 메소드를 추가했을때 &lt;em&gt;Hierarchy&lt;/em&gt; 내에 있는 모든 클래스에 같은 메소드를 작성해야 한다는 것이다.&lt;/p&gt;

&lt;p&gt;게다가 &lt;code&gt;a * b + a * c&lt;/code&gt; 를 &lt;code&gt;a * (b + 3)&lt;/code&gt; 로 축약하기가 어렵다. 이건 &lt;em&gt;Non-local simplification&lt;/em&gt; 이기 때문에, sub-tree 를 모두 테스트하고 접근해야한다. &lt;em&gt;OO Decomposition&lt;/em&gt; 은 &lt;code&gt;eval&lt;/code&gt; 메소드 구현엔 좋지만, 이런 점에선 문제가 다.&lt;/p&gt;

&lt;h3 id=&#34;pattern-matching&#34;&gt;Pattern Matching&lt;/h3&gt;

&lt;p&gt;우리는 &lt;em&gt;Decomposition&lt;/em&gt; 을 해결하기 위해서 3가지 방법을 시도해봤다.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;Classification&lt;/em&gt; and &lt;em&gt;acess&lt;/em&gt; methods: &lt;strong&gt;quadratic explosion&lt;/strong&gt;&lt;br /&gt;
(2) &lt;em&gt;Type tests&lt;/em&gt; and &lt;em&gt;Type casts&lt;/em&gt;: &lt;strong&gt;unsafe&lt;/strong&gt;, &lt;strong&gt;low-level&lt;/strong&gt;&lt;br /&gt;
(3) &lt;em&gt;OO Decomposition&lt;/em&gt;: &lt;strong&gt;need to touch all classes to add a new method&lt;/strong&gt;, &lt;strong&gt;does not work always&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;functional-decomposition-with-pattern-matching&#34;&gt;Functional Decomposition with Pattern Matching&lt;/h4&gt;

&lt;p&gt;사실 &lt;em&gt;Classification&lt;/em&gt; 이나 &lt;em&gt;Access&lt;/em&gt; 의 목적은 다음의 두가지라 봐도 충분하다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(1) Which subclass was used?&lt;br /&gt;
(2) What were the arugmnets of the constructor?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 Scala 에서는 &lt;strong&gt;Pattern Matching&lt;/strong&gt;, 그리고 그 과정에서 사용하는 &lt;strong&gt;Case class&lt;/strong&gt; 를 통해 &lt;em&gt;Decomposition&lt;/em&gt; 을 우아하게 자동화 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Expr
case class Number(n: Int) extends Expr
case class Sum(l: Expr, r: Expr) extends Expr

def eval(e: Expr): Expr = {
  e match {
    case Number(n) =&amp;gt; n
    case Sum(e1, e2) =&amp;gt; eval(e1) + eval(e2)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1) 패턴에서 사용하는 &lt;em&gt;Variable(변수)&lt;/em&gt; 는 소문자로 시작해야 한다.
(2) &lt;em&gt;Variable&lt;/em&gt; 은 두번 사용될 수 없다. &lt;code&gt;Sum(a, a)&lt;/code&gt; 는 잘못된 패턴이다.&lt;br /&gt;
(3) &lt;em&gt;Constant(상수)&lt;/em&gt; 는 대문자로 시작해야 하는데, 예외는 &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Expr&lt;/code&gt; &lt;em&gt;Trait&lt;/em&gt; 내부에 &lt;code&gt;eval&lt;/code&gt; 을 삽입하는 것도 가능하다&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Expr {
  def eval: Int = {
    this match {
      case Number(n) =&amp;gt; n
      case Sum(e1, e2) =&amp;gt; e1.eval + e2.eval
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Object-Oriented Decomposition&lt;/em&gt; 과 &lt;em&gt;Functional Decomposition&lt;/em&gt; 모두 장단이 있는데, 만약 메소드를 많이 만드는 경우라면 &lt;em&gt;Functional Decomposition&lt;/em&gt; 이 더 우월하다. 매 클라스마다 메소드를 만들 필요가 없기 때문이다. 반대로, 클래스를 많이 만드는 경우라면, &lt;em&gt;OO Decomposition&lt;/em&gt; 이 더 낫다. 클래스를 만들때마다 매번 &lt;code&gt;eval&lt;/code&gt; 함수를 수정 할 필요 없기 &lt;code&gt;eval&lt;/code&gt; 을 가진 클래스를 만들면 된다.&lt;/p&gt;

&lt;h3 id=&#34;lists&#34;&gt;Lists&lt;/h3&gt;

&lt;p&gt;Scala 에서 &lt;code&gt;List&lt;/code&gt; 와 &lt;code&gt;Array&lt;/code&gt; 는 크게 두가지 면에서 다르다, 먼저 &lt;code&gt;List&lt;/code&gt; 는 &lt;em&gt;immutable&lt;/em&gt; 이고, &lt;em&gt;recursive&lt;/em&gt; 인 반면 &lt;code&gt;Array&lt;/code&gt; 는 &lt;em&gt;mutable&lt;/em&gt;, &lt;em&gt;flat&lt;/em&gt; 하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;List(&amp;quot;apple&amp;quot;, &amp;quot;oranges&amp;quot;, &amp;quot;pears&amp;quot;)
&amp;quot;apple&amp;quot; :: (&amp;quot;oranges&amp;quot; :: (&amp;quot;pears&amp;quot; :: Nil))

List()
Nil
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;right-associativity&#34;&gt;Right Associativity&lt;/h4&gt;

&lt;p&gt;좀 더 편하게 하기 위해서, Scala 는 다음과 같은 문법을 제공한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;A :: (B :: C)
A :: B :: C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이는 Scala 에서 &lt;code&gt;:&lt;/code&gt; 로 끝나는 &lt;em&gt;operator&lt;/em&gt; 는 &lt;strong&gt;Right-associative&lt;/strong&gt; 이기 때문이다.&lt;/p&gt;

&lt;p&gt;또한 &lt;code&gt;:&lt;/code&gt; 로 끝나는 &lt;em&gt;operator&lt;/em&gt; 에서는, 우측에 오는것이 본래의 &lt;em&gt;operand&lt;/em&gt; 다&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Operators ending in &lt;code&gt;:&lt;/code&gt; are also difference in the they are seen as method calls of the right-hand operand&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 다음의 세 라인은 모두 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;1 :: 2 :: 3 :: 4 :: Nil
1 :: (2 :: (3 :: (4 :: Nil)))
Nil.::(4).::(3).::(2).::(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러므로 &lt;code&gt;::&lt;/code&gt; 를 &lt;code&gt;prepend&lt;/code&gt; 메소드라 보면 된다.&lt;/p&gt;

&lt;h4 id=&#34;list-patterns&#34;&gt;List Patterns&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;::&lt;/code&gt;(Cons) 연산자를 이용하면 다음과 같은 패턴이 가능하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;1 :: 2 :: xs
x :: Nil
List(x) // same as x :: nil
List() // Nil
List(2 :: xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sorting-lists&#34;&gt;Sorting Lists&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Insertion Sort&lt;/strong&gt; 는 재귀를 이용하면 다음과 같이 구현할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def isort(xs: List[Int]): List[Int] = {
    xs match {
      case Nil =&amp;gt; List()
      case y :: ys =&amp;gt; insert(y, isort(ys))
    }
  }

  def insert(x: Int, xs: List[Int]): List[Int] = {
    xs match {
      case Nil =&amp;gt; List(x)
      case y :: ys =&amp;gt; {
        if (x &amp;lt; y)  x :: xs
        else y :: insert(x, ys)
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;https://twitter.github.io/scala_school/type-basics.html#variance&#34;&gt;https://twitter.github.io/scala_school/type-basics.html#variance&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Functional Programming 5</title>
      <link>https://1ambda.github.io/21/scala/functional-programming-5/</link>
      <pubDate>Sat, 25 Jun 2016 00:47:11 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/functional-programming-5/</guid>
      <description>

&lt;p&gt;지난주엔 Scala 가 &lt;em&gt;리스코프 치환 원칙&lt;/em&gt; 을 지키기 위해 어떻게 &lt;em&gt;Variance(공변성)&lt;/em&gt; 을 문법적으로 지원하는지 알아보았다. 직접 &lt;code&gt;List&lt;/code&gt; 컨테이너를 구현해 보면서 함수의 인자는 &lt;em&gt;Covariant&lt;/em&gt;, 리턴타입은 &lt;em&gt;Contravariant&lt;/em&gt; 란 것도 알게 되었고, &lt;code&gt;Nil&lt;/code&gt; 을 만들기 위해 &lt;code&gt;Nothing&lt;/code&gt; 을 어떻게 엮을 수 있는지도 직접 확인해 보았다. 마지막으로, 프로그래머가 가장 많이 작성하는 로직인 &lt;em&gt;Decomposition&lt;/em&gt; 을 &lt;em&gt;Pattern Matching&lt;/em&gt; 을 이용해 더 우아하게 작성하는법도 배웠다. &lt;del&gt;오오 추상화 오오&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;이번시간에도 &lt;code&gt;List&lt;/code&gt; 를 가지고 놀면서 &lt;em&gt;Reduce&lt;/em&gt; 의 개념과 Scala 의 &lt;em&gt;Implicit&lt;/em&gt; 키워드가 어떤 역할을 하는지 배워본다.&lt;/p&gt;

&lt;h3 id=&#34;more-functions-on-lists&#34;&gt;More Functions on Lists&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;List.last&lt;/code&gt; 는 마지막 원소를 돌려준다. &lt;code&gt;head&lt;/code&gt; 나 &lt;code&gt;tail&lt;/code&gt; 같은 경우는 상수 시간 내에 리턴되지만, &lt;code&gt;last&lt;/code&gt; 는 어떨까?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def last[T](l: List[T]): T = xs match {
  case List() =&amp;gt; throw new Error(&#39;last of empty list&#39;)
  case List(x) =&amp;gt; x
  case y :: ys =&amp;gt; last(ys)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러므로 길이 &lt;code&gt;n&lt;/code&gt; 에 비례하는 성능을 보여준다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;last&lt;/code&gt; takes steps proportional to the length of the list&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;마찬가지로 마지막 원소를 제외하고 나머지를 돌려주는 &lt;code&gt;Last.init&lt;/code&gt; 경우도 같은 성능을 보여준다. 이렇게 구현할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def init[T](xs: List[T]): List[T] = xs match {
    case List() =&amp;gt; throw new Error(&amp;quot;init of empty list&amp;quot;)
    case List(x) =&amp;gt; List()
    case y :: ys =&amp;gt; y :: init(ys)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;concat&lt;/code&gt; 은 어떨까? &lt;code&gt;xs&lt;/code&gt; 를 받아서 &lt;code&gt;ys&lt;/code&gt; 앞에 붙이는 함수다. &lt;code&gt;prepend&lt;/code&gt; 함수라 보면 되겠는데, 지난 시간에 논의했었던 &lt;code&gt;:::&lt;/code&gt; 랑 같다.&lt;/p&gt;

&lt;p&gt;지난 시간에 언급 했듯이 &lt;code&gt;xs ::: ys&lt;/code&gt; 처럼 &lt;code&gt;:&lt;/code&gt; 로 끝나는 연산자는 우측에 오는것이 실제 좌측 피연산자다. &lt;code&gt;ys .::: (xs)&lt;/code&gt; 와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def concat[T](xs: List[T], ys: List[T]): List[T] = xs match {
    case List() =&amp;gt; ys
    case z :: zs =&amp;gt; z :: concat(zs, ys)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 , &lt;code&gt;reverse&lt;/code&gt; 를 구현 해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def reverse[T](xs: List[T]): List[T] = xs match {
    case List() =&amp;gt; xs
    case y :: ys =&amp;gt; reverse(ys) ++ List(y)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;reverse&lt;/code&gt; 도 마찬가지로 길이 &lt;code&gt;n&lt;/code&gt; 에 &lt;em&gt;quadratic&lt;/em&gt; 한 성능을 보여준다. 이는 &lt;code&gt;reverse&lt;/code&gt; 내부에서 &lt;code&gt;++&lt;/code&gt; 을 사용하기 때문이다. 이는 더 개선할 수 있는데, 후에 논의하겠다.&lt;/p&gt;

&lt;p&gt;참고로, &lt;code&gt;++&lt;/code&gt; 와 &lt;code&gt;:::&lt;/code&gt; 는 하는일은 같으나, &lt;code&gt;:::&lt;/code&gt; 는 &lt;code&gt;List&lt;/code&gt; 에만 적용 가능하고 &lt;code&gt;++&lt;/code&gt; 는 다른 &lt;em&gt;Traversal&lt;/em&gt; 에도 적용 가능하다. &lt;a href=&#34;http://stackoverflow.com/questions/6559996/scala-list-concatenation-vs&#34;&gt;여기&lt;/a&gt; 참조&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;removeAt&lt;/code&gt; 을 구현 해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def removeAt[T](n: Int, xs: List[T]): List[T] =
    (xs take n) ::: (xs drop n + 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;flatten&lt;/code&gt; 은 다음과 같이 작성할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def flatten(xs: List[Any]): List[Any] = xs match {
    case List() =&amp;gt; xs
    case List(y :: ys) =&amp;gt; y :: flatten(ys)
    case y :: ys =&amp;gt; y :: flatten(ys)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;pairs-and-tuples&#34;&gt;Pairs and Tuples&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;(3, &amp;quot;example&amp;quot;)&lt;/code&gt; 과 같은 형태를 &lt;em&gt;Pair&lt;/em&gt; 라 부르는데, 이건 사실 &lt;em&gt;Tuple&lt;/em&gt; 의 특별한 형태다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(T1, ..., Tn)&lt;/code&gt; 은 &lt;code&gt;scala.Tuplen[T1, ..., Tn]&lt;/code&gt; 의 &lt;em&gt;parameterized type&lt;/em&gt; 이고, &lt;em&gt;expression&lt;/em&gt;  &lt;code&gt;(e1, ..., en)&lt;/code&gt; 은 사실 &lt;code&gt;scala.Tuplen(e1, ..., en)&lt;/code&gt; 과 동일하다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;em&gt;tuple&lt;/em&gt; 의 패턴 &lt;code&gt;(p1, ..., pn)&lt;/code&gt; 은 &lt;em&gt;constructor pattern&lt;/em&gt; &lt;code&gt;scala.Tuplen(p1, ..., pn)&lt;/code&gt; 과 같다. &lt;code&gt;TupleN&lt;/code&gt; 클래스를 구경 해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Tuple2[T1, T2](_: +T1, _2: +T2) {
  override def toString = &amp;quot;(&amp;quot; + _1 + &amp;quot;,&amp;quot; + _2 + &amp;quot;)&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;멤버를 접근할 때 &lt;code&gt;_1&lt;/code&gt;, &lt;code&gt;_2&lt;/code&gt; 와 같은 식으로 접근하므로, 패턴 매칭에서&lt;/p&gt;

&lt;p&gt;&lt;code&gt;val (label, value) = pair&lt;/code&gt; 는 사실 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val label = pair._1
val value = pair._2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Tuple&lt;/em&gt; 의 패턴 매칭을 이용하면, 다음과 같이 중첩된 &lt;em&gt;case&lt;/em&gt; 를 사용하는 &lt;em&gt;merge sort&lt;/em&gt; 함수를&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def msort(xs: List[Int]): List[Int] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[Int], ys: List[Int]): List[Int] = xs match {
        case Nil =&amp;gt; ys
        case x :: xs1 =&amp;gt; ys match {
          case Nil =&amp;gt; xs
          case y :: ys1 =&amp;gt; {
            if (x &amp;gt; y) y :: merge(xs, ys1)
            else x :: merge(xs1, ys)
          }
        }
      }

      val (left, right) = xs splitAt n
      merge(msort(left), msort(right))
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;요로코롬 바꿀 수 있다. &lt;del&gt;오오 패턴매칭 오오&lt;/del&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def msort(xs: List[Int]): List[Int] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[Int], ys: List[Int]): List[Int] =
        (xs, ys) match {
          case (xs, Nil) =&amp;gt; xs
          case (Nil, ys) =&amp;gt; ys
          case (x :: xs1, y :: ys1) =&amp;gt;
            if (x &amp;gt; y) y :: merge(xs, ys1)
            else x :: merge(xs1, ys)
        }

      val (left, right) = xs splitAt n
      merge(msort(left), msort(right))
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;implicit-parameters&#34;&gt;Implicit Parameters&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Int&lt;/code&gt; 뿐만 아니라 우리가 만든 &lt;code&gt;msort&lt;/code&gt; 함수를 더 범용적으로 활용할 수 있도록, &lt;em&gt;Currying&lt;/em&gt; 을 ´용하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def msort[T](xs: List[T])(lt: (T, T) =&amp;gt; Boolean): List[T] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[T], ys: List[T]): List[T] =
        (xs, ys) match {
          case (xs, Nil) =&amp;gt; xs
          case (Nil, ys) =&amp;gt; ys
          case (x :: xs1, y :: ys1) =&amp;gt;
            if (lt(x, y)) x :: merge(xs1, ys)
            else y :: merge(xs, ys1)
        }

      val (left, right) = xs splitAt n
      merge(msort(left)(lt), msort(right)(lt))
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래는 테스트코드&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  &amp;quot;msort&amp;quot; should &amp;quot;return an ordered list&amp;quot; in {
    val xs = List(4, 2, 7, 1, 11, 9, 3)
    val ys = List(10, 9, 8, 7, 6)

    assert(msort(xs)((x: Int, y: Int) =&amp;gt; x &amp;lt; y) == List(1, 2, 3, 4, 7, 9, 11))
    assert(msort(ys)((x: Int, y: Int) =&amp;gt; x &amp;lt; y) == List(6, 7, 8, 9, 10))
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로 &lt;code&gt;msort&lt;/code&gt; 에 &lt;code&gt;Int&lt;/code&gt; 인자를 주는 경우, &lt;code&gt;x: Int, y: Int&lt;/code&gt; 처럼 타입을 명시하지 않아도 알아서 &lt;code&gt;xs&lt;/code&gt; 를 보고 추론한다.&lt;/p&gt;

&lt;h4 id=&#34;parameterization-with-ordered&#34;&gt;Parameterization with Ordered&lt;/h4&gt;

&lt;p&gt;¬실은 &lt;code&gt;scala.math.Othering[T]&lt;/code&gt; 에 &lt;em&gt;ordering&lt;/em&gt; 을 나타낼 수 있는 클래스가 있다. 이를 활용하면 &lt;code&gt;msort&lt;/code&gt; 를 다음과 같이 리팩토링 할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def msort[T](xs: List[T])(ord: Ordering[T]): List[T] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[T], ys: List[T]): List[T] =
        (xs, ys) match {
          case (xs, Nil) =&amp;gt; xs
          case (Nil, ys) =&amp;gt; ys
          case (x :: xs1, y :: ys1) =&amp;gt;
            if (ord.lt(x, y)) x :: merge(xs1, ys)
            else y :: merge(xs, ys1)
        }

      val (left, right) = xs splitAt n
      merge(msort(left)(ord), msort(right)(ord))
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;테스트 코드는,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  &amp;quot;msort&amp;quot; should &amp;quot;return an ordered list&amp;quot; in {
    val xs = List(4, 2, 7, 1, 11, 9, 3)
    val ys = List(10, 9, 8, 7, 6)
    val zs = List(&amp;quot;pineapple&amp;quot;, &amp;quot;apple&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;watermelon&amp;quot;)

    assert(msort(xs)(Ordering.Int) == List(1, 2, 3, 4, 7, 9, 11))
    assert(msort(ys)(Ordering.Int) == List(6, 7, 8, 9, 10))
    assert(msort(zs)(Ordering.String) == List(&amp;quot;apple&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;pineapple&amp;quot;, &amp;quot;watermelon&amp;quot;))
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다 좋은데, &lt;code&gt;Ordering.Int&lt;/code&gt; 인자 자체를 숨겨버렸으면 좋겠다. &lt;code&gt;msort&lt;/code&gt; 의 &lt;code&gt;ord&lt;/code&gt; 파라미터를 다음과 같이 변경하자. &lt;code&gt;(implicit ord: Ordering[T])&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def msort[T](xs: List[T])(implicit ord: Ordering[T]): List[T] = {
    val n = xs.length / 2

    if (n == 0) xs
    else {
      def merge(xs: List[T], ys: List[T]): List[T] =
        (xs, ys) match {
          case (xs, Nil) =&amp;gt; xs
          case (Nil, ys) =&amp;gt; ys
          case (x :: xs1, y :: ys1) =&amp;gt;
            if (ord.lt(x, y)) x :: merge(xs1, ys)
            else y :: merge(xs, ys1)
        }

      val (left, right) = xs splitAt n
      merge(msort(left), msort(right))
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;테스트 코드는 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  &amp;quot;msort&amp;quot; should &amp;quot;return an ordered list&amp;quot; in {
    val xs = List(4, 2, 7, 1, 11, 9, 3)
    val ys = List(10, 9, 8, 7, 6)
    val zs = List(&amp;quot;pineapple&amp;quot;, &amp;quot;apple&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;watermelon&amp;quot;)

    assert(msort(xs) == List(1, 2, 3, 4, 7, 9, 11))
    assert(msort(ys) == List(6, 7, 8, 9, 10))
    assert(msort(zs) == List(&amp;quot;apple&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;pineapple&amp;quot;, &amp;quot;watermelon&amp;quot;))
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;놀랍게도, 파라미터가 사라져버렸다. ~오오 스칼라 오오~ &lt;code&gt;implicit&lt;/code&gt; 하나만 추가했을 뿐인데! &lt;code&gt;implicit&lt;/code&gt; 를 파라미터 타입에 추가하면 아래처럼 해석된다.&lt;/p&gt;

&lt;p&gt;타입 &lt;code&gt;T&lt;/code&gt; 인 &lt;code&gt;implicit&lt;/code&gt; 파라미터에 대해서,&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;implicit&lt;/code&gt; 이며&lt;br /&gt;
(2) &lt;code&gt;T&lt;/code&gt; 와 호환 가능한 타입을 가지고 있고&lt;br /&gt;
(3) &lt;em&gt;function call&lt;/em&gt; 내에서 찾을 수 있거나&lt;br /&gt;
(4) 혹은 &lt;code&gt;T&lt;/code&gt; 와 관련된 &lt;em&gt;companion object&lt;/em&gt; 내에 있는&lt;/p&gt;

&lt;p&gt;&lt;em&gt;single definition (most specific)&lt;/em&gt; 이 있는지 컴파일러가 찾는다. 파라미터로 사용하고 아니면, 에러를 뿜는다.&lt;/p&gt;

&lt;p&gt;즉 위의 코드의 경우 &lt;code&gt;Ordering[String]&lt;/code&gt; 와 &lt;code&gt;Ordering[Int]&lt;/code&gt; 는 어딘가에 &lt;code&gt;implicit&lt;/code&gt; 로 처리되어 이미 존재한다.&lt;/p&gt;

&lt;h3 id=&#34;higher-order-list-functions&#34;&gt;Higher-Order List Functions&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;List&lt;/code&gt; 에 사용하는 메소드들은 종종 &lt;em&gt;반복된 패턴 (recurring patterns)&lt;/em&gt; 을 지는데, 3가지로 요약해 보면 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(1) transformaing each element in a list ina certain way&lt;br /&gt;
(2) retrieving a list of all elements satisfying a criterion&lt;br /&gt;
(3) combining the elements of a list using an operator&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;함수형 언어는, &lt;em&gt;higher-order function&lt;/em&gt; 이용해서 &lt;em&gt;generic function&lt;/em&gt; 을 만들 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;map&#34;&gt;Map&lt;/h4&gt;

&lt;p&gt;리스트의 모든 원소에 함수 &lt;code&gt;f&lt;/code&gt; 를 &lt;em&gt;적용 (Applying)&lt;/em&gt; 하는 &lt;em&gt;고차 함수 (Higher-Order Function)&lt;/em&gt; 은 &lt;code&gt;map&lt;/code&gt; 이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;abstract class List[T] {
  ...
  def map[T](f: T =&amp;gt; U): List[U] = this match {
    case Nil =&amp;gt; this
    csae x :: xs =&amp;gt; f(x) :: xs.map(f)
  }
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실제로 &lt;code&gt;map&lt;/code&gt; 은 좀 더 복잡한데, &lt;em&gt;tail-recursion&lt;/em&gt; 과 다양한 종류의 &lt;em&gt;collection&lt;/em&gt; 을 지원하기 위함이다.&lt;/p&gt;

&lt;h4 id=&#34;filter&#34;&gt;Filter&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;abstract class List[T] {
  ...
  def filter(p: T =&amp;gt; Boolean): List[T] = this match {
    case Nil =&amp;gt; this
    case x :: xs =&amp;gt; if (p(x)) x :: xs.filter(p) else xs.filter(p)
  }
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이외에도 &lt;code&gt;filterNot&lt;/code&gt; 과 &lt;code&gt;partition&lt;/code&gt;이 있다. &lt;code&gt;partition&lt;/code&gt; 은 &lt;code&gt;filter&lt;/code&gt; 와  &lt;code&gt;filterNot&lt;/code&gt; 의 결과를 둘 다 돌려준다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;takeWhile&lt;/code&gt; 은 일치하지 않는 곳에서 &lt;em&gt;filtering&lt;/em&gt; 을 멈추고, 그 전까지의 결과를 돌려준다. 반대로 &lt;code&gt;dropWhile&lt;/code&gt; 은 &lt;code&gt;takeWhile&lt;/code&gt; 에서 취해진 결과 이외의 나머지를 돌려준다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; val zs = List(2, -4, 1, 4, 7)
zs: List[Int] = List(2, -4, 1, 4, 7)

scala&amp;gt; zs partition(x =&amp;gt; x &amp;gt; 0)
res38: (List[Int], List[Int]) = (List(2, 1, 4, 7),List(-4))

scala&amp;gt; zs dropWhile(x =&amp;gt; x &amp;gt; 0)
res39: List[Int] = List(-4, 1, 4, 7)

scala&amp;gt; zs takeWhile(x =&amp;gt; x &amp;gt; 0)
res40: List[Int] = List(2)

scala&amp;gt; zs span(x =&amp;gt; x &amp;gt; 0)
res41: (List[Int], List[Int]) = (List(2),List(-4, 1, 4, 7))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;takeWhile&lt;/code&gt;, &lt;code&gt;dropWhile&lt;/code&gt; 을 이용하면 다음과 같은 &lt;code&gt;pack&lt;/code&gt; 함수도 만들 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def pack[T](xs: List[T]): List[List[T]] = xs match {
    case Nil =&amp;gt; Nil
    case x :: xs1 =&amp;gt;
      xs.takeWhile(y =&amp;gt; y == x) :: pack(xs.dropWhile(y =&amp;gt; y == x))
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래는 테스트코드&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  val ts = List(&amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;a&amp;quot;)
  val ss = List(List(&amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;), List(&amp;quot;b&amp;quot;), List(&amp;quot;c&amp;quot;, &amp;quot;c&amp;quot;), List(&amp;quot;a&amp;quot;))

  &amp;quot;pack&amp;quot; should &amp;quot;return a packed list&amp;quot; in {
    assert(pack(ts) == ss)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reduction-of-lists&#34;&gt;Reduction of Lists&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;reduce&lt;/code&gt; 는 리스트의 모든 원소에 특정 연산을 수행해 하나의 결과를 만들어 내고 싶을 때 사용한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def sum(xs: List[Int]) = (0 :: xs) reduceLeft((x, y) =&amp;gt; x + y)
  def product(xs: List[Int]) = (1 :: xs) reduceLeft((x, y) =&amp;gt; x * y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;사실 &lt;code&gt;reduceLeft&lt;/code&gt;, &lt;code&gt;reduceRight&lt;/code&gt; 를 기억하는 쉬운 방법은, &lt;em&gt;왼쪽으로 / 오른쪽으로 기운 트리&lt;/em&gt; 를 기억하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://joelneely.files.wordpress.com/2011/03/foldleftplain.jpg?w=219&amp;h=325&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;https://joelneely.wordpress.com/&#34;&gt;https://joelneely.wordpress.com/&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reduce&lt;/code&gt; 와 비슷하지만 초기 인자를 받아 &lt;em&gt;empty-list&lt;/em&gt; 에 대해서도 호출될 수 있는 &lt;code&gt;fold&lt;/code&gt; 가 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;abstract class List[T] {
  ...
  def reduceLeft(op (T, T) =&amp;gt; T): T = this match {
    case Nil =&amp;gt; throw new Error(&amp;quot;Nil.reduceLeft&amp;quot;)
    case x :: xs =&amp;gt; (xs foldLeft x)(op)
  }

  def foldLeft[U](z: U)(op: (U, T) =&amp;gt; U): U = this match {
    case Nil =&amp;gt; z
    case x :: xs =&amp;gt; (xs foldLeft op(z, x))(op)
  }
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
&lt;code&gt;foldRight&lt;/code&gt; 는 &lt;em&gt;오른쪽으로 기운 트리&lt;/em&gt; 를 생각하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://joelneely.files.wordpress.com/2011/03/foldrightplain.jpg?w=219&amp;h=325&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;https://joelneely.wordpress.com/&#34;&gt;https://joelneely.wordpress.com/&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def reduceRight(op: (T, T) =&amp;gt; T): T = this match {
  case Nil =&amp;gt; throw new Error(&amp;quot;Nil.reduceRight&amp;quot;)
  case x :: Nil =&amp;gt; x
  case x :: xs =&amp;gt; op(x, xs.reduceRight(op))
}

def foldRight[U](z: U)(op: (T, U) =&amp;gt; U): U = this match {
  case Nil =&amp;gt; z
  case x :: xs =&amp;gt; op(x, (xs foldRight z)(op))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;foldLeft&lt;/code&gt; 와 &lt;code&gt;foldRight&lt;/code&gt; 는 같은 일을 하긴 하는데, 때때로는 둘 중 하나만 적절한 경우도 있다. 예를 들어&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def concat[T](xs: List[T], ys: List[T]): List[T] =
  (xs foldRight ys)(_ :: _)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;foldRight&lt;/code&gt; 대신에 &lt;code&gt;foldLeft&lt;/code&gt; 가 오면 어떻게 될까? &lt;em&gt;타입 에러&lt;/em&gt; 가 발생한다. &lt;code&gt;3 :: List(4)&lt;/code&gt; 는 가능해도 &lt;code&gt;List(3) :: 4&lt;/code&gt; 는 불가능하기 때문이다.&lt;/p&gt;

&lt;h3 id=&#34;reasoning-about-concat&#34;&gt;Reasoning About Concat&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;We would like to verify that concatenation is associative, and that it admits the empty list &lt;code&gt;Nil&lt;/code&gt; as neutral element to the left and to the right&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이번장에서는 &lt;em&gt;natural indction&lt;/em&gt; 과 비슷한 &lt;em&gt;structural induction&lt;/em&gt; 을 이용해 함수형 프로그래밍에서 어떻게 함수의 정확성을 증명할 수 있는지 배운다.&lt;/p&gt;

&lt;p&gt;함수형 프로그래밍에선 &lt;em&gt;side-effect&lt;/em&gt; 가 없기 때문에, &lt;em&gt;reduction step&lt;/em&gt; 이 전체나, 부분이나 동일하게 적용된다. 이걸 다른말로 &lt;em&gt;참조 투명성 (referential transparency)&lt;/em&gt; 라고 부른다. 혹시 몰라 원문을 첨부 하자면,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that a proof can freely apply reduction steps as equalities to some part of a term &lt;br/&gt;&lt;/p&gt;

&lt;p&gt;That works because pure functional programs don&amp;rsquo;t have side effects so that a term is equivalent to the terms to the term to which it reduces.&lt;/p&gt;

&lt;p&gt;This principle is called referential transparency.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;structural-induction&#34;&gt;Structural Induction&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;property&lt;/em&gt; &lt;code&gt;P(xs)&lt;/code&gt; 를 모든 &lt;code&gt;xs&lt;/code&gt; 에 대해 증명하기 위해&lt;/p&gt;

&lt;p&gt;(1) show that &lt;code&gt;P(Nil)&lt;/code&gt; holds (Base case)&lt;br /&gt;
(2) for a list &lt;code&gt;xs&lt;/code&gt; and some element &lt;code&gt;x&lt;/code&gt;, show the &lt;em&gt;induction step:&lt;/em&gt;&lt;br /&gt;
if &lt;code&gt;P(xs)&lt;/code&gt; holds, then &lt;code&gt;P(x :: xs)&lt;/code&gt; also holds&lt;/p&gt;

&lt;p&gt;우리는 &lt;code&gt;(xs ++ ys) ++ zs = xs ++ (ys ++ zs)&lt;/code&gt; 를 증명하고 싶다. 이를 위한 &lt;code&gt;concat&lt;/code&gt; 함수는&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def concat[T](xs: List[T], ys: List[T]) = xs match {
  case List() =&amp;gt; ys
  case x :: xs1 =&amp;gt; x :: concat(xs1, ys)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 &lt;code&gt;concat&lt;/code&gt; 의 정의로 부터 두 가지 사실을 뽑아낼 수 있다. (distill two defining clauses)&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;Nil ++ ys = ys&lt;/code&gt;&lt;br /&gt;
(2) &lt;code&gt;(x :: xs1) ++ ys = x :: (xs1 ++ ys)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이제 먼저 &lt;em&gt;Base-case&lt;/em&gt; 인 &lt;code&gt;Nil&lt;/code&gt; 에 대해 먼저 참임을 보이면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(Nil ++ ys) ++ zs = Nil ++ (ys ++ zs)&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;좌변은 (1) 에 의해 &lt;code&gt;ys ++ zs&lt;/code&gt; 이고
우변도 (1) 에 의해 &lt;code&gt;ys ++ zs&lt;/code&gt; 이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제 &lt;code&gt;P(xs)&lt;/code&gt; 가 참일때 &lt;code&gt;P(x :: xs)&lt;/code&gt; 임을 보이면 된다. 먼저 좌변부터 하면&lt;/p&gt;

&lt;p&gt;= &lt;code&gt;((x :: xs) ++ ys) ++ zs&lt;/code&gt; by (2)&lt;br /&gt;
= &lt;code&gt;(x :: (xs ++ ys)) ++ zs&lt;/code&gt; by (2)&lt;br /&gt;
= &lt;code&gt;x :: ((xs ++ ys) ++ zs)&lt;/code&gt; by (2)&lt;br /&gt;
= &lt;code&gt;x :: (xs ++ (ys ++ zs))&lt;/code&gt; by &lt;em&gt;induction hypothesis&lt;/em&gt; (&lt;code&gt;P(xs)&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;우변을 정리하면,&lt;/p&gt;

&lt;p&gt;= &lt;code&gt;(x :: xs) ++ (ys ++ zs)&lt;/code&gt; by (2)&lt;br /&gt;
= &lt;code&gt;x :: (xs ++ (ys ++ zs))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;우변과 좌변이 같으므로, &lt;code&gt;P&lt;/code&gt; 는 성립한다.&lt;/p&gt;

&lt;h3 id=&#34;a-larger-equational-proof-on-lists&#34;&gt;A Larger Equational Proof on Lists&lt;/h3&gt;

&lt;p&gt;이제 &lt;code&gt;reverse&lt;/code&gt; 의 &lt;code&gt;xs.reverse.reverse = xs&lt;/code&gt; 라는 속성을 증명해 보자. 다음 2개의 &lt;em&gt;clause&lt;/em&gt; 를 알고 있다. (교수님이, 좀 더 &lt;em&gt;amenable&lt;/em&gt; 하기 때문에 비 효율적인 정의를 골랐다고 하심.)&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;Nil.reverse&lt;/code&gt; = &lt;code&gt;Nil&lt;/code&gt;&lt;br /&gt;
(2) &lt;code&gt;(x :: xs).reverse&lt;/code&gt; = &lt;code&gt;xs.reverse&lt;/code&gt; ++ &lt;code&gt;List(x)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Base-case&lt;/em&gt; 는 패스하고, 바로 &lt;code&gt;x :: xs&lt;/code&gt; 에 대한 것 부터 들어가면 좌변은&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(x :: xs).reverse.reverse&lt;/code&gt;&lt;br /&gt;
= &lt;code&gt;(xs.reverse ++ List(x)).reverse&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;우변은&lt;/p&gt;

&lt;p&gt;&lt;code&gt;x :: xs&lt;/code&gt;&lt;br /&gt;
= &lt;code&gt;x :: xs.reverse.reverse&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이걸로는 할 수 있는게 없으므로 &lt;code&gt;xs.reverse&lt;/code&gt; 를 &lt;code&gt;ys&lt;/code&gt; 라 놓으면&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(ys ++ List(x)).reverse&lt;/code&gt; = &lt;code&gt;x :: ys.reverse&lt;/code&gt; 를 증명하면 된다. &lt;em&gt;Auxiliary Equation&lt;/em&gt; 인데, 먼저 &lt;em&gt;Base-case&lt;/em&gt; 부터 참임을 보이면&lt;/p&gt;

&lt;p&gt;좌변은&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(Nil ++ List(x)).reverse&lt;/code&gt;&lt;br /&gt;
= &lt;code&gt;List(x).reverse&lt;/code&gt; // ++ clause 1&lt;br /&gt;
= &lt;code&gt;(x :: Nil).reverse&lt;/code&gt; // List Definition&lt;br /&gt;
= &lt;code&gt;Nll.reverse ++ List(x)&lt;/code&gt; // reverse clause 2&lt;br /&gt;
= &lt;code&gt;Nil ++ List(x)&lt;/code&gt; // reverse clause 1&lt;br /&gt;
= &lt;code&gt;x :: Nil&lt;/code&gt; // List Definition&lt;/p&gt;

&lt;p&gt;우변은&lt;/p&gt;

&lt;p&gt;&lt;code&gt;x :: Nil.reverse&lt;/code&gt;&lt;br /&gt;
= &lt;code&gt;x :: Nil&lt;/code&gt; // reverse clause 1&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;((y :: ys) ++ List(x)).reverse&lt;/code&gt; 와 &lt;code&gt;x :: (y :: ys).reverse&lt;/code&gt; 가 같음을 보이면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;((y :: ys) ++ List(x)).reverse&lt;/code&gt;&lt;br /&gt;
= &lt;code&gt;(y :: (ys ++ List(x)).reverse&lt;/code&gt; // ++ clause 2&lt;br /&gt;
= &lt;code&gt;(ys ++ List(x)).reverse ++ List(y)&lt;/code&gt;  // reverse clause 2&lt;br /&gt;
= &lt;code&gt;(x :: ys.reverse) ++ List(y)&lt;/code&gt;  // &lt;em&gt;induction hypothesis&lt;/em&gt;&lt;br /&gt;
= &lt;code&gt;x :: (ys.reverse ++ List(y)&lt;/code&gt;  // reverse clause 2&lt;br /&gt;
= &lt;code&gt;x :: (y : ys).reverse&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이것은 우변 &lt;code&gt;x :: (y :: ys).reverse&lt;/code&gt; 와 동일하므로 &lt;em&gt;Auxiliary equation&lt;/em&gt; 이 성립하고, 본래의 성질 &lt;code&gt;xs = xs.reverse.reverse&lt;/code&gt; 도 성립한다.&lt;/p&gt;

&lt;h4 id=&#34;exercise&#34;&gt;Exercise&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt;  증명하라고 주시는데, 못해먹겠다 -_-; 패쓰!&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Reduction&lt;/em&gt;, &lt;em&gt;Fold&lt;/em&gt;, &lt;em&gt;referential transparency&lt;/em&gt; 그리고 &lt;em&gt;structural induction&lt;/em&gt; 에 대해서 배웠다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;http://stackoverflow.com/questions/6559996/scala-list-concatenation-vs&#34;&gt;scala-list-concatenation-vs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2014-10-14, &lt;strong&gt;Functional Programming in Scala&lt;/strong&gt;, Coursera&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Functional Programming 6</title>
      <link>https://1ambda.github.io/21/scala/functional-programming-6/</link>
      <pubDate>Sat, 25 Jun 2016 00:47:12 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/functional-programming-6/</guid>
      <description>

&lt;p&gt;지난 시간에는 &lt;em&gt;referential transparency (참조투명성)&lt;/em&gt; 과 함수형 언어에서의 귀납법인 &lt;em&gt;structural induction&lt;/em&gt; 에 대해서 배우고, 몇 개의 예제를 증명했었다.&lt;/p&gt;

&lt;p&gt;이번 시간에는 스칼라의 컬렉션인 &lt;code&gt;Seq&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt; 을 알아보고 마지막 챕터에서는 여기에 &lt;em&gt;higher-order function&lt;/em&gt; 을 더해 미친듯한 표현력을 가진 코드를 작성해 본다. &lt;del&gt;one-liner 의 절정을 보여주시는 교수님&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;(번역이 서툴러 어중간한 의역을 하느니 단어를 그대로 사용하고 필요할 경우 원문을 첨부한다)&lt;/p&gt;

&lt;h3 id=&#34;other-collections&#34;&gt;Other Collections&lt;/h3&gt;

&lt;h4 id=&#34;vector&#34;&gt;Vector&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;List&lt;/code&gt; 는 처음 원소는 &lt;code&gt;O(1)&lt;/code&gt; 로 빠르게 접근하지만, 중간이나 마지막 원소에 대해서는 조금 느린편이다. 만약에 중간이나 마지막 원소에 대한 탐색을 빠르게 하고싶다면 다른 &lt;em&gt;sequence implementation&lt;/em&gt; 인 &lt;code&gt;Vector&lt;/code&gt; 를 사용하면 된다. &lt;code&gt;Vector&lt;/code&gt; 는 다른 원소들에 대한 접근이 &lt;em&gt;evenly balanced&lt;/em&gt; 하다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This one has more evenly balanced access pattern then &lt;code&gt;List&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt; 는 &lt;code&gt;2^5 = 32&lt;/code&gt; 개의 원소를 가진 리스트의 트리로 구현된다. 따라서 처음 단계에서는 &lt;code&gt;2^5&lt;/code&gt; 개를 저장할 수 있고, 그 다음 단계에서는 &lt;code&gt;2^5 * 2^5 = 2^10&lt;/code&gt;, 그 다음 단계에서는 &lt;code&gt;2^15&lt;/code&gt; 를 저장할 수 있다. &lt;code&gt;2^5&lt;/code&gt; 의 배수만큼 증가하는 것이다. &lt;em&gt;binary tree&lt;/em&gt; 에서 자식의 갯수가 &lt;code&gt;2&lt;/code&gt; 개가 아니라 &lt;code&gt;32&lt;/code&gt; 개라고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;이런 이유로, 원소를 탐색하는데 걸리는 시간은 &lt;code&gt;log_32 (N)&lt;/code&gt; (&lt;em&gt;32 based-log&lt;/em&gt;) 라 보면 된다. &lt;em&gt;random access&lt;/em&gt; 에 대해서는 &lt;code&gt;List&lt;/code&gt; 보다 훨씬 낫다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt; 의 또 다른 장점은 &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; 같은 &lt;em&gt;bulk operator&lt;/em&gt; 에 대해서 빠른 연산이 가능하다는 것이다. 이것은 원소들이 32개씩 뭉쳐있기 때문에 &lt;em&gt;single cache line&lt;/em&gt; 에 있을 확률이 높아진다. 리스트의 경우에는 콘셀이 같은 &lt;em&gt;cache line&lt;/em&gt; 에 있으리라는 보장이 없기 때문에 &lt;code&gt;Vector&lt;/code&gt; 보다 &lt;em&gt;locality&lt;/em&gt; 가 떨어진다.&lt;/p&gt;

&lt;p&gt;그럼 &lt;code&gt;List&lt;/code&gt; 가 필요없을까? 그렇지 않다. &lt;code&gt;head&lt;/code&gt;, &lt;code&gt;tail&lt;/code&gt; 과 같은 연산을 할때 빠르다. 깊이가 깊은 &lt;code&gt;Vector&lt;/code&gt; 구조에서, &lt;code&gt;head&lt;/code&gt; 나 &lt;code&gt;tail&lt;/code&gt; 의 경우 몇 번의 연산이 필요한지 생각해보면 쉽게 이해할 수 있다.&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; 과 같은 &lt;em&gt;bulk operation&lt;/em&gt; 은 &lt;code&gt;Vector&lt;/code&gt; 가&lt;br /&gt;
(2) &lt;code&gt;tail&lt;/code&gt;, &lt;code&gt;head&lt;/code&gt; 는 &lt;code&gt;List&lt;/code&gt; 가 더 빠르다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt; 는 대부분의 &lt;code&gt;List&lt;/code&gt; 연산을 사용할 수 있는데 예외가 하나 있다. 바로 &lt;code&gt;::&lt;/code&gt; 콘싱은 &lt;code&gt;List&lt;/code&gt; 를 위한 연산이기 때문이다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;Vector&lt;/code&gt; 에서는 원소 추가나, 패턴 매칭을 위해 &lt;code&gt;x +: xs&lt;/code&gt;, &lt;code&gt;x :+ x&lt;/code&gt; 를 사용하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt; 는 &lt;code&gt;List&lt;/code&gt; 처럼 &lt;em&gt;immutable&lt;/em&gt; 이기 때문에 원소를 추가하면 기존의 데이터는 변경되지 않는다. 따라서 가장 깊은 깊이에 새로운 &lt;code&gt;Vector&lt;/code&gt; 를 추가하고 그 벡터를 가리키는 상위 벡터, &amp;hellip;, 루트 벡터까지 만드는 비용은 &lt;code&gt;log32(N)&lt;/code&gt; 이 된다. 물론 이건 &lt;em&gt;object creation&lt;/em&gt; 비용이다.&lt;/p&gt;

&lt;h4 id=&#34;sequence&#34;&gt;Sequence&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Range&lt;/code&gt; 는 &lt;code&gt;Seq&lt;/code&gt; 의 &lt;em&gt;sub-type&lt;/em&gt; 다. &lt;code&gt;Seq&lt;/code&gt; 이외에도 &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt; 등이 있으며 &lt;code&gt;Seq, Set, Map&lt;/code&gt; 은 &lt;code&gt;Iterable&lt;/code&gt; 의 &lt;em&gt;sub-type&lt;/em&gt; 이다. &lt;em&gt;hierarchy&lt;/em&gt; 를 살펴보면,&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.scala-lang.org/resources/images/collections.png&#34;&gt;
&lt;img src=&#34;http://docs.scala-lang.org/resources/images/collections.png&#34; align=&#34;center&#34; /&gt;&lt;/a&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://docs.scala-lang.org&#34;&gt;http://docs.scala-lang.org&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.scala-lang.org/resources/images/collections.immutable.png&#34;&gt;
&lt;img src=&#34;http://docs.scala-lang.org/resources/images/collections.immutable.png&#34;  align=&#34;center&#34; /&gt;
&lt;/a&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://docs.scala-lang.org&#34;&gt;http://docs.scala-lang.org&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Array&lt;/code&gt; 와 &lt;code&gt;String&lt;/code&gt; 은 점선으로 연결된 걸 볼 수 있는데 이건 두 클래스가 &lt;code&gt;Java&lt;/code&gt; 에서 왔기 때문이다. 스칼라 클래스는 아니지만 스칼라의 &lt;code&gt;Seq&lt;/code&gt; 로 볼 수 있다. (&lt;em&gt;View&lt;/em&gt;) 따라서 다음과 같은 코드는 정상 동작한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&amp;quot;Hello World&amp;quot; filter { c =&amp;gt; c.isUpper }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;range&#34;&gt;Range&lt;/h4&gt;

&lt;p&gt;다른 &lt;code&gt;Seq&lt;/code&gt; 구현체로는 &lt;code&gt;Range&lt;/code&gt; 가 있다. &lt;code&gt;Range&lt;/code&gt; 는 &lt;em&gt;evenly spaced intergers&lt;/em&gt; 를 나타낸다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val r: Range = 1 until 5 // Range(1, 2, 3, 4)
val s: Range = 1 to 5 // Range(1, 2, 3, 4)
1 to 10 by 3
6 to 1 by -2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그렇기에 &lt;code&gt;Range&lt;/code&gt; 는 &lt;em&gt;upper bound, lower bound, step value&lt;/em&gt; 를 클래스의 멤버로 가지고 있다.&lt;/p&gt;

&lt;h4 id=&#34;sequence-operations&#34;&gt;Sequence Operations&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Seq&lt;/code&gt; 에 대해서 &lt;code&gt;exists&lt;/code&gt;, &lt;code&gt;forall&lt;/code&gt;, &lt;code&gt;zip&lt;/code&gt;, &lt;code&gt;unzip&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;product&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt; 등을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;zip&lt;/code&gt; 은 두개의 &lt;code&gt;Seq&lt;/code&gt; 의 각 원소를 &lt;code&gt;pair&lt;/code&gt; 로 묶는거고, &lt;code&gt;unzip&lt;/code&gt; 은 각 &lt;code&gt;pair&lt;/code&gt; 를 푼다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; a
res13: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5)

scala&amp;gt; b
res14: List[Char] = List(h, e, l, l, o)

scala&amp;gt; a zip b
res15: scala.collection.immutable.IndexedSeq[(Int, Char)] = Vector((1,h), (2,e), (3,l), (4,l), (5,o))

scala&amp;gt; a zip b unzip
res16: (scala.collection.immutable.IndexedSeq[Int], scala.collection.immutable.IndexedSeq[Char]) = (Vector(1, 2, 3, 4, 5),Vector(h, e, l, l, o))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;flatMap&lt;/code&gt; 은 각 원소에 &lt;code&gt;map&lt;/code&gt; 을 적용한 ¤, 풀어 헤친다. 예를 들어&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; &amp;quot;HelloWorld&amp;quot; flatMap { c =&amp;gt; List(&#39;.&#39;, c) }
res17: String = .H.e.l.l.o.W.o.r.l.d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;flatMap&lt;/code&gt; 은 맵을 두번하면 할 때 자주 쓰인다. 예를 들어  &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt; 에 대해 &lt;em&gt;combinator (조합)&lt;/em&gt; 을 찾을때 &lt;code&gt;flatMap&lt;/code&gt; 을 사용하면 &lt;code&gt;Vector&lt;/code&gt; 의 &lt;code&gt;Vector&lt;/code&gt; 가 아니라 &lt;code&gt;Vector&lt;/code&gt; 만 얻는다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;1 to m flatMap { x =&amp;gt; 1 to n map { y =&amp;gt; (x, y) } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;벡터에 대해 스칼라 곱을 하고 싶다면, &lt;code&gt;zip&lt;/code&gt; 을 이용할 수 있다. &lt;code&gt;zip&lt;/code&gt; 을 이용하면 두 &lt;code&gt;Seq&lt;/code&gt; 의 &lt;code&gt;pair&lt;/code&gt; 가 나오므로, 곱한 후 &lt;code&gt;sum&lt;/code&gt; 하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;(xs zip ys).map(xy =&amp;gt; xy._1 * xy._2).sum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그런데, &lt;code&gt;zip&lt;/code&gt; 해서 나오는 &lt;code&gt;pair&lt;/code&gt; 에 패턴매칭을 적용할 수 있으므로&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;(xs zip ys).map { case(x, y) =&amp;gt; x * y }.sum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로, &lt;code&gt;x =&amp;gt; match { case ... }&lt;/code&gt; 은 &lt;code&gt;{ case ... }&lt;/code&gt; 으로 바로 줄여쓸 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;combinatorial-search-and-for-expression&#34;&gt;Combinatorial Search and For-Expression&lt;/h3&gt;

&lt;h4 id=&#34;handling-nested-sequences&#34;&gt;Handling Nested Sequences&lt;/h4&gt;

&lt;p&gt;보다 작은 두 수 &lt;code&gt;i, j (1 &amp;lt;= j &amp;lt; i &amp;lt; n)&lt;/code&gt; 에 대´서 &lt;code&gt;i + j&lt;/code&gt; 가 소수인 &lt;code&gt;i, j&lt;/code&gt; 를 찾는다고 하자.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a positive integer &lt;code&gt;n&lt;/code&gt;, find all pairs of positive integers &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; with &lt;code&gt;1 &amp;lt;= j &amp;lt; i &amp;lt; n&lt;/code&gt; such that &lt;code&gt;i + j&lt;/code&gt; is prime&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이렇게 코드를 작성해 볼 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;1 until 5 flatMap { i =&amp;gt; 1 until i map { j =&amp;gt; (i, j) }}

res36: scala.collection.immutable.IndexedSeq[(Int, Int)] = Vector((2,1), (3,1), (3,2), (4,1), (4,2), (4,3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;재밌는 사실은 &lt;code&gt;Range&lt;/code&gt; 를 사용했음에도 &lt;code&gt;Vector&lt;/code&gt; 가 나온다는 점이다. 더 정확히는 &lt;code&gt;IndexedSeq&lt;/code&gt; 다. 무슨 일이 일어난 걸까? &lt;code&gt;Range&lt;/code&gt; 는 &lt;code&gt;Pair&lt;/code&gt; 를 원소로 가질 수 없기 때문에 상위 타입인 &lt;code&gt;IndexedSeq&lt;/code&gt; 를 가지게 되고, 이것의 구체적 타입인 &lt;code&gt;Vector&lt;/code&gt; 가 된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.scala-lang.org/resources/images/collections.immutable.png&#34;&gt;
&lt;img src=&#34;http://docs.scala-lang.org/resources/images/collections.immutable.png&#34;  align=&#34;center&#34; /&gt;
&lt;/a&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://docs.scala-lang.org&#34;&gt;http://docs.scala-lang.org&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;flatMap&lt;/code&gt; 을 안쓰면 &lt;code&gt;Vector&lt;/code&gt; 의 &lt;code&gt;Vector&lt;/code&gt; 가 나오는데, 여기에 &lt;code&gt;foldRight Seq[Int]() (_ ++ _)&lt;/code&gt; 을 사용하거나 아니면 &lt;code&gt;flatten&lt;/code&gt; 을 사용할 수도 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;(1 until 5 { i =&amp;gt; 1 until i map { j =&amp;gt; (i, j) }}).flatten
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결국 &lt;code&gt;flatMap&lt;/code&gt; 은 &lt;code&gt;map&lt;/code&gt; 후 &lt;code&gt;flatten&lt;/code&gt; 을 적용한 결과를 돌려줌을 알 수 있다. 이제 여기에 &lt;code&gt;filter&lt;/code&gt; 를 적용하면 처음에 주어졌던 문제를 해결할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;    1 until n flatMap { i =&amp;gt; 1 until i map {j =&amp;gt; (i, j)} } filter { case (i, j) =&amp;gt; isPrime(i + j)}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;for-expression&#34;&gt;For-Expression&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 과 같은 &lt;em&gt;higher-order function&lt;/em&gt; 은 &lt;em&gt;expressive&lt;/em&gt; 한데 읽기가 좀 힘들때가 있다. 스칼라에서는 이를 위해 &lt;code&gt;for&lt;/code&gt; 을 제공한다. 다음의 두 문자을 보자. 완전히 동일하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Person(name: String, age: Int)

for (p &amp;lt;- persons if p.age &amp;gt; 20) yield p.name
persons filter (p =&amp;gt; p.age &amp;gt; 20) map (p =&amp;gt; p.name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt; 는 &lt;em&gt;imperative language&lt;/em&gt; 의 그것과 비슷하긴 한데, 스칼라의 &lt;code&gt;for&lt;/code&gt; 은 무언갈 변경하지 않고 새로운 &lt;code&gt;List&lt;/code&gt; 를 &lt;code&gt;yield&lt;/code&gt; 를 통해 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;for (s) yield e&lt;/code&gt; 문법을 좀 자세히 살펴보자.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;where &lt;code&gt;s&lt;/code&gt; is a sequence of &lt;em&gt;generators&lt;/em&gt; and &lt;em&gt;filters&lt;/em&gt;, and &lt;code&gt;e&lt;/code&gt; is an expression whose value is returned by an iteration&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;generator&lt;/em&gt; 는 &lt;code&gt;p &amp;lt;- e&lt;/code&gt; 형태의 &lt;em&gt;form&lt;/em&gt; 인데 &lt;code&gt;p&lt;/code&gt; 는 &lt;em&gt;pattern&lt;/em&gt; 이고 &lt;code&gt;e&lt;/code&gt; 는 &lt;em&gt;value&lt;/em&gt; 로 &lt;em&gt;collection&lt;/em&gt; 을 가진 &lt;em&gt;expression&lt;/em&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;filter&lt;/em&gt; 는 &lt;code&gt;Boolean&lt;/code&gt; &lt;em&gt;expression&lt;/em&gt; 을 가지는 &lt;em&gt;form&lt;/em&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt; 루프 여러개 중첩하는 것처럼 &lt;em&gt;generator&lt;/em&gt; 가 여러개 일 수 있는데, 이 경우 마지막에 오는 &lt;em&gt;generator&lt;/em&gt; 가 여러번 돈다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If there are several generators in the sequence, the last generators vary faster than the first.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그리고 &lt;code&gt;( s )&lt;/code&gt; 대신에 &lt;code&gt;{ s }&lt;/code&gt; 를 사용할 수도 있는데, 이러면 세미콜론 없이 &lt;em&gt;filter&lt;/em&gt; 와 &lt;em&gt;generator&lt;/em&gt; 를 여러줄에 걸쳐서 작성할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 처음에 나왔던 문제를 &lt;code&gt;for&lt;/code&gt; 로 작성해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for {
  i &amp;lt;- 1 until n
  j &amp;lt;- 1 until i
  if isPrime(i + j)
} yield (i, j)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;읽기 쉬워졌다. &lt;del&gt;flatMap 따위&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;이제 아까 나왔던 벡터간 스칼라 곱을 하는 함수를 다시 작성해 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def scalaProduct(xs: List[Double], ys: List[Double] =
    (for ((x, y) &amp;lt;- xs zip ys) yield (x * y)).sum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;해보면 알겠지만 &lt;code&gt;for { x &amp;lt;- xs; y &amp;lt;- ys } yield x * y sum&lt;/code&gt; 은 안된다. 루프가 중첩되기 때문이다.&lt;/p&gt;

&lt;h3 id=&#34;combinatorial-search-example&#34;&gt;Combinatorial Search Example&lt;/h3&gt;

&lt;p&gt;자 이제 &lt;code&gt;Seq&lt;/code&gt; 말고 &lt;code&gt;Set&lt;/code&gt; 에 대해서 알아보자. &lt;code&gt;Seq&lt;/code&gt; 의 대부분의 연산도 사용할 수 있고, 비슷비슷허다. &lt;code&gt;Seq&lt;/code&gt; 와 &lt;code&gt;Set&lt;/code&gt; 은 &lt;code&gt;Iterable&lt;/code&gt; 의 &lt;em&gt;sub-type&lt;/em&gt; 이므로 &lt;code&gt;Iterable&lt;/code&gt; 스칼라독을 보면 어떤 연산을 사용할 수 있는지 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Seq&lt;/code&gt; 와의 차이점은 다음과 같다.&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;Set&lt;/code&gt; 은 순서가 없다.&lt;br /&gt;
(2) &lt;code&gt;Set&lt;/code&gt; 은 중복된 원소를 가질 수 없다.&lt;br /&gt;
(3) &lt;code&gt;contain&lt;/code&gt; 이 &lt;em&gt;fundamental operation&lt;/em&gt; 이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val a = 1 to 4 toSet

scala&amp;gt; a
res53: scala.collection.immutable.Set[Int] = Set(1, 2, 3, 4)

scala&amp;gt; a map (_ / 2)
res54: scala.collection.immutable.Set[Int] = Set(0, 1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;n-queens-problem&#34;&gt;N-Queens Problem&lt;/h4&gt;

&lt;p&gt;이제 &lt;code&gt;Set&lt;/code&gt; 을 이용해 좀 문제를 풀어보자.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The n-queens problem is to place &lt;code&gt;n&lt;/code&gt; queens on a chess board so that no queen is threatened by another &lt;br/&gt;&lt;/p&gt;

&lt;p&gt;In other words, there can&amp;rsquo;t be two queens in the same row, column, or diagonal&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;모든 조합을 뽑아내고, 열을 &lt;code&gt;List&lt;/code&gt; 로 표현하고, 그 순서를 행이라 한 뒤 모든 조합을 뽑아내 &lt;code&gt;Set&lt;/code&gt; 에 넣으면 자동으로 중복된 결과가 제거된다. 로직은 다음과 같다.&lt;/p&gt;

&lt;p&gt;(1) 내게 &lt;code&gt;placeQueens&lt;/code&gt; 라는 1 개의 퀸을 위치시킬 수 있는 함수가 있다.&lt;br /&gt;
(2) &lt;code&gt;n = 1, 2, ... , n&lt;/code&gt; 으로 &lt;code&gt;placeQueens&lt;/code&gt; 를 재귀적으로 호출해 가며 이전 단계에서 얻은 퀸들을 이용하여 하나의 퀸을 새롭게 배치한다.&lt;br /&gt;
(3) 각 단계에서는 새 퀸을 배치할 수 있는지 없는지 검사할 &lt;code&gt;isSafe&lt;/code&gt; 함수가 필요하다.&lt;/p&gt;

&lt;p&gt;이게 &lt;em&gt;Recursion&lt;/em&gt; 에서 문제를 풀 때 기본적으로 필요한 생각인 것 같다. &lt;strong&gt;문제를 작게 잘라 매번 &lt;code&gt;1/n&lt;/code&gt; 씩 해결할 수 있다면&lt;/strong&gt; 이라 가정 한 뒤 &lt;code&gt;1/n&lt;/code&gt; 문제를 풀기 위한 함수와 &lt;code&gt;1/n&lt;/code&gt; 문제의 종료조건을 정의하는 것. 우리의 경우엔 그 함수가 &lt;code&gt;isSafe&lt;/code&gt; 였다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def nQueens(n: Int): Set[List[Int]] = {

    def isSafe(col: Int, queens: List[Int]): Boolean = {
      val row = queens.length // where new queen will be placed
      val queensWithRow = (row - 1 to 0 by -1) zip queens
      queensWithRow forall {
        case (r, c) =&amp;gt; col != c &amp;amp;&amp;amp; math.abs(col - c) != row - r
      }
    }

    def placeQueens(k: Int): Set[List[Int]] =
      if (k == 0) Set(List())
      else
        for {
          queens &amp;lt;- placeQueens(k - 1)
          col &amp;lt;- 0 until n
          if isSafe(col, queens)
        } yield col :: queens

    placeQueens(n)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;diagonal&lt;/em&gt; 을 어떻게 검사할까가 고민이 될 수 있겠는데, 사실 생각해보면 쉽다. 컬럼의 차이와 행의 차이가 같으면 &lt;em&gt;diagonal&lt;/em&gt; 인 것.&lt;/p&gt;

&lt;p&gt;여기에 출력하기 위한 함수를 요로코롬 만들고 출력하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def showQueens(queens: List[Int]) = {
    val lines =
      for {
        col &amp;lt;- queens.reverse
      } yield Vector.fill(queens.length)(&amp;quot;[ ]&amp;quot;).updated(col, &amp;quot;[*]&amp;quot;).mkString

    &amp;quot;\n\n&amp;quot; + (lines.mkString(&amp;quot;\n&amp;quot;))
  }


[ ][ ][*][ ]
[*][ ][ ][ ]
[ ][ ][ ][*]
[ ][*][ ][ ],

[ ][*][ ][ ]
[ ][ ][ ][*]
[*][ ][ ][ ]
[ ][ ][*][ ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nQueens(8) take 3 map show&lt;/code&gt; 처럼 응용도 가능하다.&lt;/p&gt;

&lt;h3 id=&#34;queries-with-for&#34;&gt;Queries with For&lt;/h3&gt;

&lt;p&gt;지난 시간에 배운 &lt;code&gt;for&lt;/code&gt; 는 &lt;code&gt;SQL&lt;/code&gt; 과 비슷한데 좀 더 자세히 살펴보자. 다음과 같은 &lt;em&gt;case class&lt;/em&gt; 가 있다고 하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Book(title: String, authors: List[String])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 다음과 같은 코드를 이용해 쿼리처럼 질의할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for {
  b &amp;lt;- books
  a &amp;lt;- b.authros
  if a startWith &amp;quot;Bird&amp;quot;)
} yield b.title

for {
  b &amp;lt;- books
  if b.title indexOf &amp;quot;Programming&amp;quot; &amp;gt;= 0
} yield b.title

for {
  b1 &amp;lt;- books
  b2 &amp;lt;- books
  if b1 != b2
  a1 &amp;lt;- b1.authors
  a2 &amp;lt;- b2.authors
  if a1 == a2
} yield a1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;세번째 &lt;code&gt;for&lt;/code&gt; 문은 약간 문제가 있는데 내용이 똑같고 순서만 다른 &lt;code&gt;List&lt;/code&gt; 를 만들 수 있다 따라서 중복을 피하기 위해 &lt;code&gt;&amp;lt;&lt;/code&gt; 를 비교로 사용하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for {
  b1 &amp;lt;- books
  b2 &amp;lt;- books
  if b1.title &amp;lt; b2.title
  a1 &amp;lt;- b1.authors
  a2 &amp;lt;- b2.authors
  if a1 == a2
} yield a1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;근데 만약에 같은 작가가 3개의 책을 출판했다면? &lt;code&gt;title&lt;/code&gt; 이 &lt;code&gt;a &amp;lt; b &amp;lt; c&lt;/code&gt; 와 같은 순서를 가지므로 &lt;code&gt;(a, b), (a, c), (b, c)&lt;/code&gt; 처럼 비교되어 3번 출력된다.&lt;/p&gt;

&lt;p&gt;중복을 제거하기 위해 &lt;code&gt;distint&lt;/code&gt; 를 사용할 수 있다. 더 좋은 방법은 &lt;code&gt;Set&lt;/code&gt; 을 사용하면 된다.&lt;/p&gt;

&lt;h3 id=&#34;translation-of-for&#34;&gt;Translation of For&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt; 을 이용하면 &lt;code&gt;map, flatMap, filter&lt;/code&gt; 를 쉽게 구현할 수 있는데&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def mapFun[T, U](xs: List[T], f: T =&amp;gt; U): List[U] =
  for (x &amp;lt;- xs) yield f(x)

def flatMap[T, U](xs: List[T], f: T =&amp;gt; Iterable[U]): List[U] =
  for (x &amp;lt;- xs; y &amp;lt;- f(x)) yield y

def filter[T](xs: List[T], p: T =&amp;gt; Boolean): List[T] =
  for (x &amp;lt;- xs; if (p(x)) yield x  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;사실 스칼라 컴파일러는 &lt;code&gt;for&lt;/code&gt; 을 &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt;, &lt;em&gt;lazy variant of &lt;code&gt;filter&lt;/code&gt;&lt;/em&gt; 로 바꿔치기한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Scala compiler expresses &lt;code&gt;for&lt;/code&gt; expressions in terms of &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt; and a &lt;em&gt;lazy variant of &lt;code&gt;filter&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를 들어 &lt;code&gt;for (x &amp;lt;- e1) yield e2&lt;/code&gt; 는 &lt;code&gt;e1.map(x =&amp;gt; e2)&lt;/code&gt; 로 바꾼다&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for (x &amp;lt;- e1 if f; s) yield e2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;f&lt;/code&gt; 가 &lt;em&gt;filter&lt;/em&gt; 고 &lt;code&gt;s&lt;/code&gt; 가 &lt;em&gt;sequence of generators and filters&lt;/em&gt; 라면 다음과 같이 번역된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for (x &amp;lt;- e1.withFilter(x =&amp;gt; f); s) yield e2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;withFilter&lt;/code&gt; 는 바로 적용되는 것이 아니라, 뒤 따라오는 &lt;code&gt;map&lt;/code&gt; 또는 &lt;code&gt;flatMap&lt;/code&gt; 등에 적용된다고 보면 된다. 원문을 첨부하면&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can think of &lt;code&gt;withFilter&lt;/code&gt; as a variant of &lt;code&gt;filter&lt;/code&gt; that does not produce an intermediate list, but instead filters the following &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;flatMap&lt;/code&gt; function application&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for (x &amp;lt;- e1; y &amp;lt;- e2; s) yield e3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이건 다음처럼 번역된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;e1.flatMap(x =&amp;gt; for (y &amp;lt;- e2; s) yield e3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 내부의 &lt;code&gt;for&lt;/code&gt;  다시 한번 더 번역된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for {
  i &amp;lt;- 1 until n
  j &amp;lt;- 1 until i
  if isPrime(i + j)
} yield (i, j)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이것은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;(1 until n) flatMap(i =&amp;gt;
  (1 until i).withFilter(j =&amp;gt; isPrime(i + j))
  .map(j =&amp;gt; (i, j)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 아까 &lt;em&gt;lazy variant of &lt;code&gt;filter&lt;/code&gt;&lt;/em&gt; 어쩌구 하던 내용을 이해할 수 있는데, 중간에 &lt;code&gt;withFilter&lt;/code&gt; 는 &lt;code&gt;1 until i&lt;/code&gt; 에 적용 되는것이 아니라 &lt;code&gt;map&lt;/code&gt; 이 만들어낸 &lt;em&gt;pair&lt;/em&gt; &lt;code&gt;(i, j)&lt;/code&gt; 에 대해 적용된다.&lt;/p&gt;

&lt;p&gt;다시 말해 &lt;code&gt;for&lt;/code&gt; 문에서 &lt;code&gt;if&lt;/code&gt; &lt;em&gt;guard&lt;/em&gt; 는 나중에 적용되는 &lt;code&gt;withFilter&lt;/code&gt; 다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for (b &amp;lt;- books; a &amp;lt;- b.authros if a startsWith &amp;quot;Bird&amp;quot;) yield b.title
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;요건 이렇게 번역된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;b.flatMap(b =&amp;gt; b.authors.withFilter(a =&amp;gt; a.startsWith &amp;quot;Bird&amp;quot;).map(x =&amp;gt; x.title)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt; 는 다양한 컬렉션에도 적용할 수 있는데 이는 &lt;code&gt;for&lt;/code&gt; 가 &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;withFilter&lt;/code&gt; 이 3개의 함수를 기반으로 만들어졌기 때문이다. 따라서 커스텀 타입에도 이 3개의 함수를 만들면 &lt;code&gt;for&lt;/code&gt; 를 사©할 수 있다.&lt;/p&gt;

&lt;p&gt;이런 이유로 데이터베이스 클라이언트가 &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;withFilter&lt;/code&gt; 같은 메소드를 정의하면 &lt;code&gt;for&lt;/code&gt; 을 이용해 쿼리할 수 있다.&lt;/p&gt;

&lt;p&gt;이것이 바로 &lt;em&gt;ScalaQuery&lt;/em&gt; 나 &lt;em&gt;Slick&lt;/em&gt; 같은 스칼라 데이터베이스 프레임워크가 사용하는 방법이다. &lt;em&gt;LINQ&lt;/em&gt; 도 비슷한 개념이다.&lt;/p&gt;

&lt;h3 id=&#34;maps&#34;&gt;Maps&lt;/h3&gt;

&lt;p&gt;자 이제 &lt;code&gt;Seq&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; 을 살펴보았으니 &lt;code&gt;Map&lt;/code&gt; 을 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Map&lt;/code&gt; 은 &lt;code&gt;Iterable&lt;/code&gt; 일뿐만 아니라 &lt;code&gt;Function&lt;/code&gt; 이다. 그래서 함수 호출하듯이 &lt;em&gt;Key&lt;/em&gt; 를 인자로 주어 호출하면 &lt;em&gt;Value&lt;/em&gt; 를 얻을 수 있다. 그러나 없는 &lt;em&gt;Key&lt;/em&gt; 에 대해서 호출하면 &lt;code&gt;NoSuchElementException&lt;/code&gt; 이 발생한다.&lt;/p&gt;

&lt;p&gt;예외 대신에 있는지 없는지 알려면 &lt;code&gt;get&lt;/code&gt; 을 이용하면 된다. 없으면 &lt;code&gt;None&lt;/code&gt; 있으면 &lt;code&gt;Option[Value]&lt;/code&gt; 를 돌려준다.&lt;/p&gt;

&lt;h4 id=&#34;option-type&#34;&gt;Option Type&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Option&lt;/code&gt; 은 &lt;em&gt;Trait&lt;/em&gt; 인데&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Option[+A]
case class Some[+A](value: A) extend Option[A]
object None extend Option[Nothing]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;covaraint&lt;/em&gt; 기 때문에 &lt;code&gt;Option[Type]&lt;/code&gt;  &lt;code&gt;None&lt;/code&gt; 을 넣을 수 있다. &lt;code&gt;None&lt;/code&gt; 은 &lt;code&gt;Option[Nothing]&lt;/code&gt; 이므로 모든 &lt;code&gt;Option&lt;/code&gt; 의 하위타입이다.  참고로 &lt;code&gt;get&lt;/code&gt; 의 결과에 패턴매칭을 이용할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;sorted-and-groupby&#34;&gt;Sorted and GroupBy&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;SQL Query&lt;/em&gt; 처럼 &lt;code&gt;sorted&lt;/code&gt; 와 &lt;code&gt;groupBy&lt;/code&gt; 를 이용할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;scala&amp;gt; fruit
res70: List[String] = List(apple, pear, orange, pineapple)

scala&amp;gt; fruit.sorted
res71: List[String] = List(apple, orange, pear, pineapple)

scala&amp;gt; fruit.sortWith(_.length &amp;lt; _.length)
res72: List[String] = List(pear, apple, orange, pineapple)

scala&amp;gt; fruit.groupBy(_.head)
res73: scala.collection.immutable.Map[Char,List[String]] = Map(p -&amp;gt; List(pear, pineapple), a -&amp;gt; List(apple), o -&amp;gt; List(orange))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;groupBy&lt;/code&gt; 는 컬렉션을 &lt;em&gt;discriminator&lt;/em&gt; 를 이용해 &lt;code&gt;Map&lt;/code&gt; 으로 파티셔닝한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ploynomials (다항식)&lt;/em&gt; 을 &lt;code&gt;Map&lt;/code&gt; 을 이용해 표현해 보자. 다항식은 각 차수가 한개씩 있고, 상수도 하나씩 붙어 있으므로 &lt;code&gt;Map&lt;/code&gt; 으로 표현하기에 적합하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  class Poly(val terms: Map[Int, Double]) {
    def + (other: Poly): Poly = new Poly(terms ++ other.terms)
    override def toString = {
      (for((exp, coeff) &amp;lt;- terms.toList.sorted.reverse) yield  coeff + &amp;quot;x^&amp;quot; + exp) mkString &amp;quot; + &amp;quot;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 만들면 제대로 된 계산이 안된다. 왜냐하면 &lt;code&gt;Map&lt;/code&gt; 의 &lt;code&gt;++&lt;/code&gt; 오른쪽에 오는 &lt;code&gt;Map&lt;/code&gt; 에 똑같은 &lt;em&gt;key&lt;/em&gt; 를 가지고 있는 원소가 있으면 덮어 쓰기 때문이다. 다항식에서 차수가 같으면 &lt;em&gt;coefficient (계수)&lt;/em&gt; 를 덧셈해야 하는데 덮어씌우면 올바른 계산이 아니다. 따라서 &lt;code&gt;other.terms&lt;/code&gt; 에 같은 &lt;em&gt;Key&lt;/em&gt; 를 가진 원소가 있나 없나 계산해서 있으면 현재 &lt;code&gt;terms&lt;/code&gt; 와 계수를 더한 새로운 &lt;code&gt;pair&lt;/code&gt; 를 돌려줘야 한다. (&lt;code&gt;Map&lt;/code&gt; 의 원소는 &lt;code&gt;pair&lt;/code&gt; 다)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  class Poly(val terms: Map[Int, Double]) {
    def + (other: Poly): Poly =
    new Poly(terms ++ (other.terms map adjust))

    def adjust(term: (Int, Double)): (Int, Double) = {

      val (exp, coeff) = term

      terms.get(exp) match {
        case None =&amp;gt; term
        case Some(coeff1) =&amp;gt; (exp, coeff + coeff1)
      }
    }

    override def toString = {
      (for{
        (exp, coeff) &amp;lt;- terms.toList.sorted.reverse
      } yield  coeff + &amp;quot;x^&amp;quot; + exp) mkString &amp;quot; + &amp;quot;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;default-values&#34;&gt;Default Values&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Map&lt;/code&gt; 은 &lt;em&gt;partial function&lt;/em&gt; 이기 때문에 없는 &lt;em&gt;Key&lt;/em&gt; 에 대해 &lt;code&gt;Map&lt;/code&gt; 을 호출하면 예외가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Map&lt;/code&gt; 에 &lt;code&gt;withDefaultValue&lt;/code&gt; 를 적용하면 &lt;em&gt;total function&lt;/em&gt; 으로 바꿀 수 있다. &lt;code&gt;Poly&lt;/code&gt; 에 적용해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  class Poly(val terms0: Map[Int, Double]) {
    val terms = terms0 withDefaultValue 0.0
    def + (other: Poly): Poly = new Poly(terms ++ (other.terms map adjust))
    def adjust(term: (Int, Double)): (Int, Double) = {

      val (exp, coeff) = term
      (exp, coeff + terms(exp))
    }
    override def toString = {
      (for{
        (exp, coeff) &amp;lt;- terms.toList.sorted.reverse)}
      yield coeff + &amp;quot;x^&amp;quot; + exp) mkString &amp;quot; + &amp;quot;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;음. 다 좋은데 생성할 때 &lt;code&gt;Map&lt;/code&gt; 을 주는 대신 여러개의 &lt;code&gt;Pair&lt;/code&gt; 를 주고 &lt;code&gt;Map&lt;/code&gt; 으로 바꾸면 좀 더 나을것 같다. 다음의 생성자를 추가하자.
    def + (other:Poly): Poly =
    new Poly((other.terms foldLeft terms)(addTerm))
    def addTerm(ts: Map[Int, Double], t: (Int, Double)): Map[Int, Double] = {
      val (exp, coeff) = t
      ts + (exp -&amp;gt; (coeff + terms(exp)))
    }&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def this(arg: (Int, Double)*) = this(arg.toMap)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;++&lt;/code&gt; 대신 &lt;code&gt;fold&lt;/code&gt; 를 이용하면 &lt;code&gt;Map&lt;/code&gt; 을 생성하지 않고 바로 기존의 &lt;code&gt;terms&lt;/code&gt; 에 원소를 추가하기 때문에 더 효율적이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;    def + (other:Poly): Poly =
    new Poly((other.terms foldLeft terms)(addTerm))
    def addTerm(ts: Map[Int, Double], t: (Int, Double)): Map[Int, Double] = {
      val (exp, coeff) = t
      ts + (exp -&amp;gt; (coeff + terms(exp)))
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래는 테스트 케이스&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  &amp;quot;(x^2 + 3x) + (-2x + 7)&amp;quot; should &amp;quot;be x^2 + x + 7&amp;quot; in {
    val p1 = new Poly(2-&amp;gt;1, 1-&amp;gt;3)
    val p2 = new Poly(1-&amp;gt;(-2), 0-&amp;gt;7)
    val p3 = new Poly(2-&amp;gt;1, 1-&amp;gt;1, 0-&amp;gt;7)

    assert((p1 + p2).terms == p3.terms)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;putting-the-pieces-together&#34;&gt;Putting the Pieces Together&lt;/h3&gt;

&lt;p&gt;이번엔 전화번호를 알파벳으로 바꾸는 예제를 통해서 스칼라의 컬렉션과 고차함수가 얼마나 &lt;em&gt;expressive&lt;/em&gt; 한지 알아본다.&lt;/p&gt;

&lt;p&gt;여기 나온 예제는 7 가지 언어로 이미 실험이 되었는데 스크립트 언어는 대략 100 라인, C 나 C++ 같은 언어는 대략 200-300 라인정도가 나왔다고 한다. (2000년)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  val mnem = Map(
    &#39;2&#39; -&amp;gt; &amp;quot;ABC&amp;quot;,
    &#39;3&#39; -&amp;gt; &amp;quot;DEF&amp;quot;,
    &#39;4&#39; -&amp;gt; &amp;quot;GHI&amp;quot;,
    &#39;5&#39; -&amp;gt; &amp;quot;JKL&amp;quot;,
    &#39;6&#39; -&amp;gt; &amp;quot;MNO&amp;quot;,
    &#39;7&#39; -&amp;gt; &amp;quot;PQRS&amp;quot;,
    &#39;8&#39; -&amp;gt; &amp;quot;TUV&amp;quot;,
    &#39;9&#39; -&amp;gt; &amp;quot;WXYZ&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이런 맵이 있다고 하자. &lt;code&gt;7225247386&lt;/code&gt; 을 인코딩 하면 여러가지 경우가 나오겠지만, 그 중 하나는 &lt;code&gt;SCALA IS FUN&lt;/code&gt; 이어야 한다. &lt;del&gt;교수님 센스보소&lt;/del&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  val path = &amp;quot;/home/anster/github/coursera-scala/src/main/scala/coursera/chapter6/linux.words&amp;quot;
  val in = Source.fromFile(path)
  // java&#39;s iterator doesn&#39;t have groupBy
  val words = in.getLines.toList filter { _ forall { _.isLetter }}

  val mnem = Map(
    &#39;2&#39; -&amp;gt; &amp;quot;ABC&amp;quot;,
    &#39;3&#39; -&amp;gt; &amp;quot;DEF&amp;quot;,
    &#39;4&#39; -&amp;gt; &amp;quot;GHI&amp;quot;,
    &#39;5&#39; -&amp;gt; &amp;quot;JKL&amp;quot;,
    &#39;6&#39; -&amp;gt; &amp;quot;MNO&amp;quot;,
    &#39;7&#39; -&amp;gt; &amp;quot;PQRS&amp;quot;,
    &#39;8&#39; -&amp;gt; &amp;quot;TUV&amp;quot;,
    &#39;9&#39; -&amp;gt; &amp;quot;WXYZ&amp;quot;)

  // A to Z -&amp;gt; 2 to 9
  val charCode = mnem flatMap { case(k, v) =&amp;gt; v map { c =&amp;gt; (c, k) } }
  // or for ((digit, str) &amp;lt;- mnem; ltr &amp;lt;- str) yield ltr -&amp;gt; digit

  // &amp;quot;Java&amp;quot; -&amp;gt; &amp;quot;5282&amp;quot;
  def wordCode(word: String): String = word.toUpperCase map charCode

  // &amp;quot;5282&amp;quot; -&amp;gt; List(&amp;quot;Java&amp;quot;, &amp;quot;Kava&amp;quot;, ...), &amp;quot;1111&amp;quot; -&amp;gt; List()
  val wordsForNum: Map[String, Seq[String]] =
    words groupBy wordCode withDefaultValue Seq()

  // return all ways to encode a number as a list of words
  def encode(number: String): Set[List[String]] =
    if (number.isEmpty) Set(List())
    else {
      (for {
        split &amp;lt;- 1 to number.length
        word &amp;lt;- wordsForNum(number take split)
        rest &amp;lt;- encode(number drop split)
      } yield word :: rest).toSet
    }

  def printEncoded(number: String) = {
    encode(number) map { _ mkString &amp;quot; &amp;quot;} map println
  }

  def translate(number: String): Set[String] = {
    encode(number) map { _ mkString &amp;quot; &amp;quot; }
  }

  translate(&amp;quot;7225247386&amp;quot;) foreach { println _ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;군더더기 없이 깔끔하다. &lt;del&gt;스칼라는 넉넉하게 50라인에서 끝납니다요&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;encode&lt;/code&gt; 가 좀 난해하긴 한데, 경우의 수를 모두 찾아내야 하므로 길이를 모두 짤라 &lt;code&gt;wordForNum&lt;/code&gt; 에 넣고 각 길이마다 인코딩을 할 수 있는지 검사한 후 나머지도 &lt;code&gt;encode&lt;/code&gt; 함수에 넣어 모든 경우의 수를 찾는다. 주의할 부분은 &lt;code&gt;wordsForNum(number take split)&lt;/code&gt; 에서 없는 경우가 나올 수 있으니 &lt;code&gt;withDefaultValue Seq()&lt;/code&gt; 로 처리하면 된다. 그리고 &lt;code&gt;1 to number.length&lt;/code&gt; 가 &lt;code&gt;Range&lt;/code&gt; 이기 때문에 리턴 타입이 &lt;code&gt;IndexedSeq&lt;/code&gt; 다. 타입 에러를 해결하기 위해 &lt;code&gt;toSet&lt;/code&gt; 을 사용한다.&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;마지막 &lt;em&gt;6.7 Putting the Pieces Toghther&lt;/em&gt; 챕터를 보면서 스칼라는 정말 &lt;em&gt;expressive&lt;/em&gt; 하다는걸 느낀다. 교수님 말로는 &lt;em&gt;immutable collection&lt;/em&gt; 은&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;easy to use:&lt;/em&gt; &lt;strong&gt;few steps to do the job&lt;/strong&gt;&lt;br /&gt;
(2) &lt;em&gt;concise:&lt;/em&gt; &lt;strong&gt;one word replaces a whole loop&lt;/strong&gt;&lt;br /&gt;
(3) &lt;em&gt;safe:&lt;/em&gt; &lt;strong&gt;type checker is really good at catching erros&lt;/strong&gt;&lt;br /&gt;
(4) &lt;em&gt;fast:&lt;/em&gt; &lt;strong&gt;collection ops are tuned, can be parallelized&lt;/strong&gt;&lt;br /&gt;
(5) &lt;em&gt;universal:&lt;/em&gt; &lt;strong&gt;one vocabulary to work on all kinds of collections&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;내 컴퓨터에서 돌아가는 &lt;em&gt;SBT&lt;/em&gt; 를 보면 스칼라가 빠른지는 의문이지만&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;그리고 항상 느끼는 점이지만, &lt;em&gt;Problem&lt;/em&gt; = &lt;em&gt;Algorithm&lt;/em&gt; + &lt;em&gt;Data Structure&lt;/em&gt; 다. 자료구조를 잘 선택하면 알고리즘이 간단해진다. &lt;del&gt;그래서 둘 다 배워야 하는거고 크흑&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;http://docs.scala-lang.org/overviews/collections/overview.html&#34;&gt;http://docs.scala-lang.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2014-10-25, &lt;strong&gt;Functional Programming in Scala&lt;/strong&gt;, Coursera&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Functional Programming 7</title>
      <link>https://1ambda.github.io/21/scala/functional-programming-7/</link>
      <pubDate>Sat, 25 Jun 2016 00:47:14 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/functional-programming-7/</guid>
      <description>

&lt;h1 id=&#34;functional-programming-in-scala-7&#34;&gt;Functional Programming in Scala 7&lt;/h1&gt;

&lt;p&gt;7주차에 걸친 대장정의 마지막이다. 이번시간에는 &lt;em&gt;stream&lt;/em&gt;, &lt;em&gt;lazy evaluation&lt;/em&gt; 에 대해 배우고 이걸 이용해 길이가 무한인 컬렉션을 만들어 보기도 하고 계산을 늦추는 것을 다양한 예제에 적용해 본다.&lt;/p&gt;

&lt;h3 id=&#34;structural-induction-on-trees&#34;&gt;Structural Induction on Trees&lt;/h3&gt;

&lt;p&gt;지난번엔 함수가 올바르게 동작함을 증명하기 위해 &lt;em&gt;induction&lt;/em&gt; 을 사용했었는데 이번시간엔 &lt;em&gt;tree&lt;/em&gt; 에 대해 &lt;em&gt;induction&lt;/em&gt; 을 사용한다.&lt;/p&gt;

&lt;p&gt;모든 트리 &lt;code&gt;t&lt;/code&gt; 에 대해서 속성 &lt;code&gt;P(t)&lt;/code&gt; 가 참임을 증명하려면&lt;/p&gt;

&lt;p&gt;(1) 먼저 트리의 모든 &lt;em&gt;leave&lt;/em&gt; 에 대해 &lt;code&gt;P(1)&lt;/code&gt; 임을 보인다.&lt;br /&gt;
(2) 서브트리 &lt;code&gt;s1, ..., s&lt;/code&gt; 을 가진 &lt;em&gt;internal node&lt;/em&gt; 에 대해 &lt;code&gt;P(s1) ^ ... ^ P(sn)&lt;/code&gt; 임을 보인다.&lt;/p&gt;

&lt;p&gt;이제 몇 주 전에 만들었던 &lt;code&gt;IntSet&lt;/code&gt; 을 증명해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  abstract class IntSet {
    def incl(x: Int): IntSet
    def contains(x: Int): Boolean
  }

  object Empty extends IntSet {
    def contains(x: Int): Boolean = false
    def incl(x: Int): IntSet = NonEmpty(x, Empty, Empty)
  }

  case class NonEmpty(elem: Int, left: IntSet, right: IntSet) extends IntSet {
    def contains(x: Int): Boolean =
      if (x &amp;lt; elem) left contains x
      else if (x &amp;gt; elem) right contains x
      else true

    def incl(x: Int): IntSet =
      if (x &amp;lt; elem) NonEmpty(elem, left incl x, right)
      else if (x &amp;gt; elem) NonEmpty(elem, left, right incl x)
      else this
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;구현에 대한 증명을 한다는건 구현이 포함하는 &lt;em&gt;law&lt;/em&gt; 를 증명한다는 것을 의미한다. 예를들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Empty contains x == false
(s incl x) contains x == true
(s incl x) contains y == s contains y (if x != y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(s incl x) contains x == true&lt;/code&gt; 부터 증명하자. &lt;del&gt;쉬우니까&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;base case (&lt;code&gt;P(1)&lt;/code&gt;)&lt;/em&gt; 은 &lt;code&gt;Empty&lt;/code&gt; 를 &lt;code&gt;s&lt;/code&gt; 에 집어넣으면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NonEmpty(x, Empty, Empty) contains x&lt;/code&gt; 이므로 &lt;code&gt;true&lt;/code&gt; 다.&lt;/p&gt;

&lt;p&gt;(2) &lt;em&gt;induction step: &lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;NonEmpty(z, l, r)&lt;/code&gt;&lt;/em&gt; 에 대해서 증명하자.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NonEmpty(z, l, r) incl x contains x&lt;/code&gt; 인데, &lt;code&gt;z == x&lt;/code&gt;, &lt;code&gt;z &amp;lt; x&lt;/code&gt;, &lt;code&gt;z &amp;gt; x&lt;/code&gt; 인 3 가지 경우로 나눠 참임을 보이면 된다. 뒤의 두개는 같은 증명이며 각각의 마지막 단계에서 &lt;em&gt;induction hypothesis&lt;/em&gt; 를 사용하면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;(NonEmpty(z, l, r) incl x) contians x // z &amp;lt; x
(NonEmpty(z, l, r incl x) contains x
(r incl x) contians x // by def of NonEmpty.contains
true // by induction hypothesis
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;(xs incl y) contains x == xs contians x&lt;/code&gt;, &lt;code&gt;(if x != y)&lt;/code&gt; 를 증명해 보자.&lt;/p&gt;

&lt;p&gt;마찬가지로 &lt;em&gt;base case&lt;/em&gt; 는 &lt;code&gt;Empty&lt;/code&gt; 를 이용하면 된다. &lt;code&gt;y &amp;lt; x&lt;/code&gt;, &lt;code&gt;y &amp;gt; x&lt;/code&gt; 인 두 가지 경우로 나누어 참임을 보이자.&lt;/p&gt;

&lt;p&gt;다음으로 &lt;em&gt;inductive step&lt;/em&gt; 인데, &lt;code&gt;xs&lt;/code&gt; 가 &lt;code&gt;NonEmpty(z, l, r)&lt;/code&gt; 일때다. 아래의 5가지 경우를 고려해야 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;z = x
z = y
z &amp;lt; y &amp;lt; x
y &amp;lt; z &amp;lt; x
y &amp;lt; x &amp;lt; z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;마찬가지로 &lt;code&gt;z = x, z = y&lt;/code&gt; 도 &lt;code&gt;y &amp;lt; x, y &amp;gt; x&lt;/code&gt; 로 나누어 풀자. 나머지 증명은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// z &amp;lt; y &amp;lt; x, to show NonEmpty(z, l, r) contains x
NonEmpty(z, l, r incl y) contains x
(r incl y) contains x
r contains x  // by induction hypothesis
NonEmpty(z, l, r) contains x // by def of NonEmpty.contains

// y &amp;lt; z &amp;lt; x
NonEmpty(z, l incl y, r) contains x
r contains x
NonEmpty(z, l, r) contains x // by def of NonEmpty.contains

// y &amp;lt; x &amp;lt; z
(NonEmpty(z, l, r) incl y) contains x
NonEmpty(z, l incl y, r) contains x
(l incl y) contains x
l contains x // by induction hypothesis
NonEmpty(z, l, r) contains x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;조금 더 어려운 증명으로 &lt;code&gt;union&lt;/code&gt; 이 참임을 보일 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;(xs union ys) contains x = xs contains x || ys contains x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;마찬가지로 &lt;code&gt;xs&lt;/code&gt; 에 대해 &lt;em&gt;structural induction&lt;/em&gt; 을 이용하면 된다.&lt;/p&gt;

&lt;h3 id=&#34;streams&#34;&gt;Streams&lt;/h3&gt;

&lt;p&gt;1000 부터 10000 사이에 있는 소수 중 두번 째 것을 찾는다 하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;((1000 to 10000) filter isPrime)(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;짧고 엘레강스 하지만 문제가 하나 있다. 1000 부터 10000 까지의 소수를 모두 찾은 뒤 2번째 원소에 접근하므로 성능 문제가 생긴다. 필요없는 나머지 소수도 같이 찾아버리는 것이다.&lt;/p&gt;

&lt;p&gt;그래서 스칼라에서는 &lt;em&gt;stream&lt;/em&gt; 을 지원한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Avoid computing the tail of a sequence until it is needed for the evaluation result which might be never&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다시 말해서 &lt;em&gt;sequence&lt;/em&gt; 에서 각 부분이 &lt;em&gt;evaluation (평가)&lt;/em&gt; 되기 전까지 계산을 미루는 클래스를 스칼라에서는 &lt;em&gt;stream&lt;/em&gt; 이란 이름으로 만들어 놨다.&lt;/p&gt;

&lt;p&gt;스트림은 리스트와 유사하지만 &lt;em&gt;tail&lt;/em&gt; 부분이 &lt;em&gt;on-demand&lt;/em&gt; 로 &lt;em&gt;evaluation&lt;/em&gt; 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&amp;gt; Stream(1, 2, 3)
scala.collection.immutable.Stream[Int] = Stream(1, ?)

&amp;gt; Stream.empty
res1: scala.collection.immutable.Stream[Nothing] = Stream()

&amp;gt; (1 to 1000).toStream
scala.collection.immutable.Stream[Int] = Stream(1, ?)

&amp;gt; val xs = Stream(1, Stream.cons(2,  Stream.empty))
xs: scala.collection.immutable.Stream[Any] = Stream(1, ?)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보면 알겠지만 진짜로 &lt;em&gt;tail&lt;/em&gt; 부분이 &lt;code&gt;?&lt;/code&gt; 로 되어있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def streamRange(l: Int, h: Int): Stream[Int] = {
    if (l &amp;gt;= h) Stream.empty
    else Stream.cons(l, streamRange(l + 1, h))
  }

  def listRange(l:Int, h: Int): List[Int] = {
    if (l &amp;gt;= h) Nil
    else l :: listRange(l + 1, h)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;스트림을 만드는 &lt;code&gt;streamRange&lt;/code&gt; 와 리스트를 만드는 &lt;code&gt;listRange&lt;/code&gt; 를 보면 하는 생긴건 비슷하지만 실제로는 완전히 다른 일을 한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;listRange&lt;/code&gt; 는 마지막 원소가 &lt;code&gt;Nil&lt;/code&gt; 인 리스트를 만들지만 &lt;code&gt;streamRange&lt;/code&gt; 는 두번 째 원소가 &lt;code&gt;?&lt;/code&gt; 인 스트림을 만든다.&lt;/p&gt;

&lt;p&gt;다시 처음의 예제로 돌아와서&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;((1000 to 10000).toStream filter isPrime)(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;stream&lt;/em&gt; 은 리스트와 관련된 메소드를 모두 사용할 수 있다. 하나만 빼고, 바로 &lt;code&gt;cons ::&lt;/code&gt; 다.&lt;code&gt;Stream.cons&lt;/code&gt; 는 &lt;code&gt;#::&lt;/code&gt; 다.&lt;/p&gt;

&lt;p&gt;마찬가지로 &lt;code&gt;#::&lt;/code&gt; 도 패턴으로 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;스트림의 구현은 대부분 리스트와 비슷한데, &lt;code&gt;empty&lt;/code&gt; 가 좀 다르다.  &lt;code&gt;Stream.empty&lt;/code&gt; 처럼 스트림 내부에 정의되어있다.&lt;/p&gt;

&lt;p&gt;그리고 가장 중요한 차이점은 &lt;code&gt;Stream.cons&lt;/code&gt; 의 파라미터다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Stream {
  def cons[T](hd: T, tl: =&amp;gt; Stream[T]) = new Stream[T] {
    def isEmpty = false
    def head = hd
    def tail = tl
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tl: =&amp;gt; Stream[T]&lt;/code&gt; 를 보면 알 수 있듯이 &lt;code&gt;tl&lt;/code&gt; 은 &lt;em&gt;call-by-name&lt;/em&gt; 이다. 따라서 바로 평가되지 않으며 사용하는 시점에 평가된다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;filter&lt;/code&gt; 의 구현을 좀 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def filter(p: T =&amp;gt; Boolean): Stream[T] =
  if (isEmpty) this
  else if (p(head)) cons(head, tail.filter(p))
  else tail.filter(p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 중요한 부분이 &lt;code&gt;cons(head, tail.filter(p))&lt;/code&gt; 다. 스트림의 &lt;code&gt;cons&lt;/code&gt; 의 두번째 인자로 &lt;code&gt;tail.filter(p)&lt;/code&gt; 를 넘겨주기 때문에 이 식의 평가는 나중에 호출될 때 이루어진다. 다시 말해 지금 당장은 &lt;code&gt;head&lt;/code&gt; 만 &lt;em&gt;predicate &lt;code&gt;p&lt;/code&gt;&lt;/em&gt; 가 적용된다는 뜻이다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;streamRange&lt;/code&gt; 를 이렇게 수정하면 어떤 값이 출력될까?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def streamRange(l: Int, h: Int): Stream[Int] = {
    println(&amp;quot;l: &amp;quot; + l)
    if (l &amp;gt;= h) Stream.empty
    else Stream.cons(l, streamRange(l + 1, h))
  }

streamRange(1, 10).take(3).toList
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;답은 &lt;code&gt;1 2 3&lt;/code&gt; 이다. &lt;code&gt;take(3)&lt;/code&gt; 가 아니라 &lt;code&gt;toList&lt;/code&gt; 때문에 그렇다. &lt;code&gt;take(3)&lt;/code&gt; 는 여전히 &lt;em&gt;stream&lt;/em&gt; 이다. 따라서 첫 번째 원소인 &lt;code&gt;1&lt;/code&gt; 만 평가된 상태이며 리스트로 바꾸는 순간 &lt;code&gt;1, 2, 3&lt;/code&gt; 이 모두 평가되어야 하므로 그때 출력된다.&lt;/p&gt;

&lt;h3 id=&#34;lazy-evaluation&#34;&gt;Lazy Evaluation&lt;/h3&gt;

&lt;p&gt;이제 까지 본 &lt;em&gt;stream&lt;/em&gt; 구현은 필요 없는 &lt;code&gt;tail&lt;/code&gt; 부분을 계산하지 않게 해 주었지만 심각한 결함이 있다. &lt;code&gt;tail&lt;/code&gt; 이 여러번 호출된다면 어떻게 될까? 매번 다시 계산되야 한다.&lt;/p&gt;

&lt;p&gt;그래서 첫 번째 &lt;code&gt;tail&lt;/code&gt; 을 계산할 때 결과를 저장해 놓고, 그 다음부터는 재활용 하는 방법으로 이 문제를 해결해 보자.&lt;/p&gt;

&lt;p&gt;사실 이건 함수형 프로그래밍에서 함수는 매번 같은 결과를 반환한다는 원칙에도 부합한다.&lt;/p&gt;

&lt;p&gt;이걸 &lt;em&gt;lazy evaluation&lt;/em&gt; 이라 부른다. 우리가 이제 까지 보아왔던 것은 &lt;em&gt;by-name evaluation&lt;/em&gt; 이다. 필요할 때 평가하긴 하지만 매번 다시 계산해야하기 때문에 성능이 떨어진다. 그리고 &lt;em&gt;strict evaluation&lt;/em&gt; 은 바로 평가되는 일반 &lt;code&gt;val&lt;/code&gt; 변수라 보면 된¤.&lt;/p&gt;

&lt;p&gt;하스켈은 &lt;em&gt;lazy evaluation&lt;/em&gt; 이 디폴트지만 스칼라는 &lt;em&gt;strict evaluation&lt;/em&gt; 이 기본이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;lazy val x = expr
def x expr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음 두 식의 차이는 무엇일까? 둘 다 &lt;em&gt;on-demand&lt;/em&gt; 로 평가되지만 &lt;code&gt;def&lt;/code&gt; 는 매번 다시 계산되고 &lt;code&gt;lazy val&lt;/code&gt; 은 처음의 계산을 재활용한다.&lt;/p&gt;

&lt;p&gt;그런 이유로 다음의 코드를 실행시키면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def expr = {
    val x = { println(&amp;quot;x&amp;quot;); 1 }
    lazy val y = { println(&amp;quot;y&amp;quot;); 2 }
    def z = { println(&amp;quot;z&amp;quot;); 3 }
    z + y + x + z + y + x
  }

  expr
  // x
  // z
  // y
  // z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;xzyz&lt;/code&gt; 가 출력된다.&lt;/p&gt;

&lt;p&gt;이제 &lt;em&gt;lazy evaluation&lt;/em&gt; 을 &lt;em&gt;stream&lt;/em&gt; 구현에 적용하자&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Stream {
  def cons[T](hd: T, tl: =&amp;gt; Stream[T]) = new Stream[T] {
    def isEmpty = false
    def head = hd
    lazy val tail = tl
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;근데 이렇게 작성한 코드가 실제로 &lt;em&gt;on-demand&lt;/em&gt; 로 평가되는지 어떻게 알까? &lt;em&gt;substitution model&lt;/em&gt; 에 적용해보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;(streamRange(1000, 10000) filter isPrime) apply 1

// will be expanded

cons(1000, streamRange(1000 + 1, 10000)).filter(isPrime).apply(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;cons(1000, streamRange(1000 + 1, 10000))&lt;/code&gt; 를 &lt;code&gt;C1&lt;/code&gt; 이라 하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;C1.filter(isPrime).apply(1)

// same as
(if (isPrirme(C1.head))
  cons(C1.head, C1.tail.filter(isPrime))
else C1.tail.filter(isPrime))
apply(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 때 &lt;code&gt;C1.head == 1000&lt;/code&gt; 이므로 소수가 아니다. 따라서 이 식은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;C1.tail.filter(isPrime).apply(1)

// same as
streamRange(1001, 10000).filter(isPrime).apply(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 첫 번째 소수를 찾을 때 까지 반복된다. &lt;code&gt;cons(1009, streamRange(1009 + 1, 10000)&lt;/code&gt; 을 &lt;code&gt;C2&lt;/code&gt; 라 부르면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;C2.filter(isPrime).apply(1)

// same as
cons(1009, C2.tail.filter(isPrime)).apply(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 된다 스트림의 &lt;code&gt;apply&lt;/code&gt; 가 다음과 같이 구현되어 있다고 하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def apply(n: Int): T =
  if (n == 0) head
  else tail.apply(n - 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그럼 위 식은 이렇게 확장된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;cons(1009, C2.tail.filter(isPrime)).tail.apply(0)


// same as
C2.tail.filter(isPrime).apply(0)

// same as
streamRange(1010, 10000)).filter(isPrime).apply(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;마찬가지로 다음 번 소수 &lt;code&gt;1013&lt;/code&gt; 을 찾을 때 까지 &lt;code&gt;streamRange.tail&lt;/code&gt; 와 &lt;code&gt;filter&lt;/code&gt; 가 반복되며 식이 확장된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;cons(1013, streamRange(1013 + 1, 10000)).filter(isPrime).apply(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;cons(1013, streamRange(1013 + 1, 10000))&lt;/code&gt; 를 &lt;code&gt;C3&lt;/code&gt; 라 하자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;C3.filter(isPrime).apply(0)

// same as
cons(1013, C3.tail.filter(isPrime)).apply(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;code&gt;1013&lt;/code&gt; 이 나온다. 결국 모든 과정에서 &lt;em&gt;stream&lt;/em&gt; 의 &lt;code&gt;cons&lt;/code&gt; 내부의 &lt;code&gt;tail&lt;/code&gt; 은 &lt;code&gt;apply&lt;/code&gt; 나 &lt;code&gt;filter&lt;/code&gt; 이후에 호출됨을 알 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;computing-with-infinite-sequences&#34;&gt;Computing with Infinite Sequences&lt;/h3&gt;

&lt;p&gt;스트림에서 &lt;em&gt;tail&lt;/em&gt; 이 필요할 때만 평가되기 때문에 &lt;em&gt;infinite stream&lt;/em&gt; 을 만드는 것도 가능하다!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def from(n: Int): Stream[Int] = n #:: from(n + 1)


val nats = from(0) // natural number  
val m4s = nats map (_ * 4)

(m4s take 3).toList // List(0, 4, 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 무한한 길이의 스트림을 만드는 방법을 배웠으니 이걸 이용해 우주에 존재하는 모든 소수를 포함하는 스트림을 만들어보자.&lt;/p&gt;

&lt;p&gt;고대의 소수 계산 방법인 &lt;em&gt;The Sieve of Eratosthenes&lt;/em&gt; 를 이용한다. 2 부터 시작해서 하나씩 숫자를 증가 시키며 해당 숫자의 배수를 모두 제거하는 방식으로 소수를 찾는다. &lt;del&gt;무려 몇천년 뒤의 컴퓨터 기술을 고려하고  알고리즘을 구현한 갓 고대인들&lt;/del&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def sieve(s: Stream[Int]): Stream[Int] =
  s.head #:: sieve(s.tail filter (_ % s.head != 0))

val primes = sieve(from(2))
primes.take(4).toList
// List(2, 3, 5, 7)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다른 곳에도 좀 활용 해보자. 오래전에 &lt;a href=&#34;http://1ambda.github.io/functional-programming-in-scala-chapter-1/&#34;&gt;1강&lt;/a&gt; 에서 &lt;em&gt;뉴튼-랩슨&lt;/em&gt; 법으로 제곱근을 구하는 함수를 작성한 적이 있었다. 그 때 제곱근의 값이 한 재귀 호출마다 특정 값 미만으로 변하는지 검사하는 &lt;code&gt;isGoodEnough&lt;/code&gt; 함수를 작성했었고 이를 이용해서 제³±근 구하는 함수가 무한 재귀에 빠지지 않도록 했었다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;lazy evaluation&lt;/em&gt; 을 이용하면 계산을 미룰 수 있기 때문에 무한 재귀에 빠지는걸 막을 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def sqrtStream(x: Double): Stream[Double] = {
    def improve(guess: Double) = (guess + x / guess) / 2
    lazy val guesses: Stream[Double] = 1 #:: (guesses map improve)
    guesses
  }

  sqrt(4).take(10).toList  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로 원리가 알고싶다면 &lt;a href=&#34;https://www.google.co.kr/search?q=y+%3D+1%2Fx&amp;amp;oq=y+%3D+1%2Fx&amp;amp;aqs=chrome..69i57j69i65l2j69i64l2.3051j0j1&amp;amp;sourceid=chrome&amp;amp;es_sm=122&amp;amp;ie=UTF-8#newwindow=1&amp;amp;q=y+%3D+(4%2Fx+%2B+x)+%2F+2&#34;&gt;여기&lt;/a&gt; 그래프를 한번 보라.&lt;/p&gt;

&lt;p&gt;물론 &lt;code&gt;sqrtStream&lt;/code&gt; 은 &lt;em&gt;stream&lt;/em&gt; 을 리턴하므로 좀 더 세밀한 값을 얻기 위해 &lt;code&gt;isGoodEnough&lt;/code&gt; 를 활용할 수도 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def isGoodEnough(x: Double, guess: Double) =
  math.abs((guess * guess - x ) / x) &amp;lt; 0.0001

sqrtStream(4).filter(isGoodEnough(_, 4)).take(10).toList
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그럼 이제 무한한 길이를 가진 컬렉션을 &lt;code&gt;map&lt;/code&gt; 과 &lt;code&gt;filter&lt;/code&gt; 두 가지 방법으로 구현할 수 있다는 사실을 알게 되었을 텐데, 어느게 더 빠를까?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val xs = from(1) map (_ * N)
val ys = from(1) filter (_ % N == 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;당연히 &lt;code&gt;map&lt;/code&gt; 이 더 빠르다. 필터는 원소를 돌면서 필터링 하는거고, 맵은 바로 곱해서 값을 구한다.&lt;/p&gt;

&lt;h3 id=&#34;the-water-pouring-problem&#34;&gt;The Water Pouring Problem&lt;/h3&gt;

&lt;p&gt;기본적인 아이디어는 물컵에 대한 액션(&lt;code&gt;Move&lt;/code&gt;)을 &lt;code&gt;Empty, Fill, Pour&lt;/code&gt; 로, 액션을 수행할 상태를 &lt;code&gt;type State = Vector[Int]&lt;/code&gt; 모델링한다.&lt;/p&gt;

&lt;p&gt;최초 상태 &lt;code&gt;initialState&lt;/code&gt; 에 대해 가능한 모든 종류의 &lt;code&gt;Move&lt;/code&gt; 를 미리 &lt;code&gt;moves&lt;/code&gt; 에 만들어 놓고 (쉽게 만들 수 있다) 한번 씩 수행해 가면서 답이 있는지 검사한다.&lt;/p&gt;

&lt;p&gt;이 과정에서 만들어지는 &lt;code&gt;List[Move]&lt;/code&gt; 를 &lt;code&gt;Path&lt;/code&gt; 라 볼 수 있다. 쉽게 연산하기 위해(리스트의 컨싱을 이용) &lt;code&gt;Path&lt;/code&gt; 의 &lt;code&gt;head&lt;/code&gt; 가 제일 마지막 &lt;code&gt;Move&lt;/code&gt; 라 하자.&lt;/p&gt;

&lt;p&gt;이러면 하나의 &lt;code&gt;Path&lt;/code&gt; 는 우리가 가진 &lt;code&gt;initialState&lt;/code&gt; 에 대해 &lt;code&gt;List[Move]&lt;/code&gt; 를 적용해 마지막 상태를 알 수 있다. 이 것을 &lt;code&gt;endState&lt;/code&gt; 함수로 구현한다. 이 때 마지막 &lt;code&gt;Move&lt;/code&gt; 가 먼저 적용되야 하므로 &lt;code&gt;foldRight&lt;/code&gt; 를 이용하면 &lt;em&gt;one-liner&lt;/em&gt; 로 구현할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Path&lt;/code&gt; 가 가진 &lt;code&gt;List[Move]&lt;/code&gt; 에 새로운 &lt;code&gt;Move&lt;/code&gt; 를 컨싱으로 연결하는 &lt;code&gt;extend&lt;/code&gt; 메소드를 만들고, 우리가 풀어야 할 문제의 답은 하나의 &lt;code&gt;Path&lt;/code&gt; 이므로 출력을 위해 &lt;code&gt;toString&lt;/code&gt; 도 오버라이드 하자.&lt;/p&gt;

&lt;p&gt;하나의 &lt;code&gt;Path&lt;/code&gt; 에서 &lt;code&gt;moves&lt;/code&gt; 를 적용하면 다수의 &lt;code&gt;Path&lt;/code&gt; 가 나온다. 이걸 &lt;code&gt;Paths: Set[Path]&lt;/code&gt; 라 부르면 한 단계 한 단계 액션을 적용할 때마다 &lt;code&gt;Set[Path]&lt;/code&gt; 가 생기는것이다.&lt;/p&gt;

&lt;p&gt;그런데, 재귀를 이용해 구현한다 해도 무한정 계산할 수 없으므로 스트림을 이용해 다음단계의 계산은 필요할때로 미룰 수 있다. &lt;code&gt;Set[Path]&lt;/code&gt; 를 받아 &lt;code&gt;Stream[Set[Path]]&lt;/code&gt; 를 돌려주는 &lt;code&gt;from&lt;/code&gt; 함수를 만들자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Pouring(capacity: Vector[Int]) {

  // State
  type State = Vector[Int]
  val initialState = capacity map { _ =&amp;gt; 0 }

  // Move
  trait Move {
    def change(s: State): State
  }
  case class Empty(glass: Int) extends Move {
    def change(s: State) = s updated(glass, 0)
  }
  case class Fill(glass: Int) extends Move {
    def change(s: State) = s updated(glass, capacity(glass))
  }
  case class Pour(from: Int, to: Int) extends Move {
    def change(s: State) = {
      val amount = s(from) min (capacity(to) - s(to))
      s updated (from, s(from) - amount) updated (to, s(to) + amount)
    }
  }

  val glasses = 0 until capacity.length

  val moves =
    (for (glass &amp;lt;- glasses) yield Empty(glass)) ++
    (for (glass &amp;lt;- glasses) yield Fill(glass)) ++
    (for (from &amp;lt;- glasses; to &amp;lt;- glasses if from != to) yield Pour(from, to))

  // Path

  class Path(history: List[Move]) {
    def endState: State = (history foldRight initialState)(_ change _)
    def extend(move: Move): Path = new Path(move :: history)
    override def toString = &amp;quot;\n&amp;quot; + (history.reverse mkString &amp;quot; &amp;quot;) + &amp;quot;--&amp;gt;&amp;quot; + endState
  }

  val initialPath = new Path(Nil)

  def from(paths: Set[Path]): Stream[Set[Path]] = {
    if (paths.isEmpty) Stream.empty
    else {
      val more = for {
        path &amp;lt;- paths
        next &amp;lt;- moves map path.extend
      } yield next

      paths #:: from(more)
    }
  }

  val pathSets = from(Set(initialPath))

  def solutions(target: Int): Stream[Path] = {
    for {
      pathSet &amp;lt;- pathSets
      path &amp;lt;- pathSet
      if path.endState contains target
    } yield path
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그런데, 실제로 코드를 돌려보면 상당히 느리다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val problem = new Pouring(Vector(4, 7, 8))
println(problem.solutions(6))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이는 &lt;code&gt;from&lt;/code&gt; 함수에서 &lt;code&gt;path&lt;/code&gt; 를 &lt;code&gt;extend&lt;/code&gt; 할 때 기존에 있던 &lt;code&gt;path&lt;/code&gt;  도 포함하기 때문이다. 따라서 각 &lt;code&gt;path&lt;/code&gt; 에서 &lt;code&gt;endState&lt;/code&gt; 를 담은 &lt;code&gt;explored&lt;/code&gt; 를 인자에 넘겨주고, 다시 넘겨 받으면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def from(paths: Set[Path], explored: Set[State]): Stream[Set[Path]] = {
    if (paths.isEmpty) Stream.empty
    else {
      val more = for {
        path &amp;lt;- paths
        next &amp;lt;- moves map path.extend
      } yield next

      paths #:: from(more, explored ++ (more map (_.endState)))
    }
  }

  val pathSets = from(Set(initialPath), Set(initialState))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;endState&lt;/code&gt; 도 재귀함수로서 자주 호출되는데 매번 다시 계산되야 하므로 변수로 저장하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  class Path(history: List[Move], val endState: State) {
    def extend(move: Move): Path = new Path(move :: history, move change endState)
    override def toString = &amp;quot;\n&amp;quot; + (history.reverse mkString &amp;quot; &amp;quot;) + &amp;quot;--&amp;gt;&amp;quot; + endState
  }

  val initialPath = new Path(Nil, initialState)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;del&gt;내 경우는 옵티마이징 한 결과가 더 느렸다;;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;여기서 중요한 아이디어 두개를 짚어보면&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;List[Move]&lt;/code&gt; 에서 앞쪽 &lt;code&gt;Move&lt;/code&gt; 가 더 나중에 적용되는 것을 통해 매 &lt;code&gt;extend&lt;/code&gt; 마다 전체 리스트를 순회할 필요가 없도록 하고 계산은 &lt;code&gt;foldRight&lt;/code&gt; 를 이용해 쉽게 구현&lt;br /&gt;
(2) 무한한 재귀를 &lt;em&gt;stream&lt;/em&gt; 을 이용해 계산을 미룬 &lt;code&gt;solution&lt;/code&gt; 이나 &lt;code&gt;from&lt;/code&gt; 함수.&lt;/p&gt;

&lt;p&gt;특히 &lt;code&gt;solution&lt;/code&gt; 은 &lt;code&gt;Stream[Path]&lt;/code&gt; 를 리턴하도록 하여 첫번째 답까지 찾는 계산만 수행하는데, 이는 스트림에 &lt;code&gt;for-loop&lt;/code&gt; 을 돌려도 스트림을 돌려준다는 사실을 알려준다. (&lt;em&gt;filter&lt;/em&gt; 와 같다고 생각하면 편하다.*)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def ex =
  for(i &amp;lt;- (1 to 10).toStream if i % 2 == 0)

ex.take(3).toList // List(2, 4, 6)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;course-summary&#34;&gt;Course Summary&lt;/h3&gt;

&lt;p&gt;이제 까지 우리가 다뤄 온 것들은&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;higher-order functions&lt;/li&gt;
&lt;li&gt;case classes and pattern matching&lt;/li&gt;
&lt;li&gt;immutable collections&lt;/li&gt;
&lt;li&gt;absence of mutable state&lt;/li&gt;
&lt;li&gt;flexible evaluation strategies: &lt;em&gt;strict / lazy / by-name&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;앞으로 다룰 것들은 (아마 &lt;em&gt;reactive programming&lt;/em&gt; 에서)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;functional programming and state&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;what does it mean to have mutable state?&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;what changes if we add it?&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;parallelism&lt;/strong&gt;
&lt;em&gt;how to exploit immutablility for parallel execution&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;DSL&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;high-level libraries as embedded DSLs&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;interpretation techniques for external DSLs&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;2014-11-04, &lt;strong&gt;Functional Programming in Scala&lt;/strong&gt;, Coursera&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reactive Programming 1</title>
      <link>https://1ambda.github.io/21/scala/reactive-programming-1/</link>
      <pubDate>Sat, 25 Jun 2016 01:08:44 +0900</pubDate>
      
      <guid>https://1ambda.github.io/21/scala/reactive-programming-1/</guid>
      <description>

&lt;h2 id=&#34;monad-generator&#34;&gt;Monad, Generator&lt;/h2&gt;

&lt;h3 id=&#34;what-is-reactive-programming&#34;&gt;What is Reactive Programming?&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;reactive&lt;/em&gt; 란 뜻은&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;React to events&lt;/em&gt; &lt;strong&gt;(event-driven)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;React to load&lt;/em&gt; &lt;strong&gt;(scalable)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;React to failures&lt;/em&gt; &lt;strong&gt;(resilient)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;React to users&lt;/em&gt; &lt;strong&gt;(responsive)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;event-driven&#34;&gt;Event-driven&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;event-driven&lt;/em&gt; 을 통해 &lt;em&gt;scalable, resilient&lt;/em&gt; 해질 수 있고, 이 3가지를 통해 &lt;em&gt;responsive&lt;/em&gt; 한 서비스를 만들 수 있다.&lt;/p&gt;

&lt;p&gt;옛날에는 시스템이 &lt;em&gt;multi-threaded&lt;/em&gt; 로 구성되어 &lt;em&gt;shared, synchronized state&lt;/em&gt; 를 통해 커뮤니케이션 했었다. 그래서&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Strong coupling, hard to compose&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;근데 요즘 시스템은 &lt;em&gt;loosely coupled even handlers&lt;/em&gt; 로 구성되기 때문에&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Events can be handled asynchoronously, without blokcing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;scalable&#34;&gt;Scalable&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;An application is &lt;strong&gt;scalable&lt;/strong&gt; if it is able to be expanded according ot its usage&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;scale up:&lt;/strong&gt; make use of parallelism in multi-core systems&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scale out:&lt;/strong&gt; make use of multiple server nodes&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Important for scalability:&lt;/strong&gt; minimize shared mutable state&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Important for scale out:&lt;/strong&gt; location transparency, resilience&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;resilient&#34;&gt;Resilient&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;An application is &lt;strong&gt;resilient&lt;/strong&gt; if it can recover quickly from failures&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;일반적으로 &lt;em&gt;resilience&lt;/em&gt; 는 나중에 (&lt;em&gt;afterthought&lt;/em&gt;) 추가하기 어렵다. 시작부터 디자인의 일부로 고려해야한다. 이를 위해&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;loose coupling&lt;/li&gt;
&lt;li&gt;strong ecapsulation of state&lt;/li&gt;
&lt;li&gt;pervasive supervisor hierarchies&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;responsive&#34;&gt;Responsive&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;An application is &lt;strong&gt;responsive&lt;/strong&gt; if it provides rich, real-time interaction with its users even under load and in the presence of failures.&lt;/p&gt;

&lt;p&gt;Responsive applications can be built on an event-driven, scalable, and resilient architecture&lt;/p&gt;

&lt;p&gt;Still need careful attention to algorithms, system design, back-pressure, and many other details.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;callback&#34;&gt;Callback&lt;/h4&gt;

&lt;p&gt;보통 이벤트를 다루기 위해 &lt;em&gt;callback&lt;/em&gt; 이 사용되는데 자바를 예로 들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Counter extends ActionListener {
  private var count = 0
  button.addActinoListener(this)
  
  def actionPerformed(e: ActionEvent): Unit = {
    count += 1
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 볼 수 있는 문제는&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;shared mutable state&lt;/em&gt; 가 필요하다&lt;br /&gt;
(2) &lt;em&gt;composing&lt;/em&gt; 하기 힘들다&lt;br /&gt;
(3) 시스템이 커지면 &lt;em&gt;callback hell&lt;/em&gt; 이 될 수 있다&lt;/p&gt;

&lt;h4 id=&#34;composable-event-abstraction&#34;&gt;Composable Event Abstraction&lt;/h4&gt;

&lt;p&gt;일반적으로 함수형 프로그래밍에서 이를 해결하기 위한 방법은 &lt;em&gt;composable event abstraction&lt;/em&gt; 이다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Events are first class&lt;/li&gt;
&lt;li&gt;Events are often represented as messages&lt;/li&gt;
&lt;li&gt;Handlers of events are also first-class&lt;/li&gt;
&lt;li&gt;Complex handlers can be composed from primitive ones&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 수업에서 다룰 내용은 &lt;em&gt;monad&lt;/em&gt;, &lt;em&gt;future&lt;/em&gt;, &lt;em&gt;observables&lt;/em&gt;, &lt;em&gt;actor&lt;/em&gt;, &lt;em&gt;supervisor&lt;/em&gt;, &lt;em&gt;distributed actor&lt;/em&gt; 등이다.&lt;/p&gt;

&lt;h4 id=&#34;function-pattern-maching&#34;&gt;Function, Pattern Maching&lt;/h4&gt;

&lt;p&gt;잠깐 복습하고 가면 &lt;em&gt;JSON&lt;/em&gt; 을 모델링 하기 위해서&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;abstract class JSON
case class JSeq (elems: List[JSON])           extends JSON
case class JObj (bindings: Map[String, JSON]) extends JSON
case class JNum (num: Double)                 extends JSON
case class JStr (str: String)                 extends JSON
case class JBool (b: Boolean)                 extends JSON
case class JNull                              extends JSON
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러면 요로코롬 데이터를 표현할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  val data = JObj(Map(
    &amp;quot;firstName&amp;quot;   -&amp;gt; JStr(&amp;quot;Jason&amp;quot;),
    &amp;quot;lastName&amp;quot;    -&amp;gt; JStr(&amp;quot;Bone&amp;quot;),
    &amp;quot;phoneNumber&amp;quot; -&amp;gt; JSeq(List(
      JObj(Map(
        &amp;quot;type&amp;quot; -&amp;gt; JStr(&amp;quot;home&amp;quot;), &amp;quot;number&amp;quot; -&amp;gt; JStr(&amp;quot;212 555 3347&amp;quot;),
        &amp;quot;type&amp;quot; -&amp;gt; JStr(&amp;quot;fax&amp;quot;),  &amp;quot;number&amp;quot; -&amp;gt; JStr(&amp;quot;33312 555 3347&amp;quot;)
      ))
    ))
  ))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자바스크립트에서 이거랑 똑같다. 좀 스칼라 버전이 복잡해 보이는데, 오더스키 말로는 더 문법적으로 간편하도록 작성할 수 있다고 한다. 아마 어디 라이브러리에 구현되어있을듯&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;data = {
  &amp;quot;firstName&amp;quot;: &amp;quot;Json&amp;quot;,
  &amp;quot;lastName&amp;quot;: &amp;quot;Bone&amp;quot;,
  &amp;quot;phoneNumber&amp;quot;: [
    { &amp;quot;type: &amp;quot;home&amp;quot;, &amp;quot;number&amp;quot;, &amp;quot;212 555 3347&amp;quot; },
    { &amp;quot;type: &amp;quot;fax&amp;quot;,  &amp;quot;number&amp;quot;, &amp;quot;33312 555 3347&amp;quot; }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;JSON&lt;/code&gt; 을 출력하는 &lt;code&gt;show&lt;/code&gt; 함수를 만들어 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def show(json: JSON): String = json match {
    case JSeq(elems) =&amp;gt; &amp;quot;[&amp;quot; + (elems map show mkString &amp;quot;, &amp;quot;) + &amp;quot;]&amp;quot;
    case JObj(bindings) =&amp;gt;
      val assocs = bindings map {
        case (key, value) =&amp;gt; &amp;quot;\&amp;quot;&amp;quot; + key + &amp;quot;\&amp;quot;:&amp;quot; + show(value)
      }
      &amp;quot;{&amp;quot; + (assocs mkString &amp;quot;, &amp;quot;) + &amp;quot;}&amp;quot;

    case JNum(num) =&amp;gt; num.toString
    case JStr(str) =&amp;gt; &amp;quot;\&amp;quot;&amp;quot; + str + &amp;quot;\&amp;quot;&amp;quot;
    case JBool(b) =&amp;gt; b.toString
    case JNull() =&amp;gt; &amp;quot;null&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;case class&lt;/em&gt; 가 나와서 잠깐 보면 다음 타입은 무엇일까?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;{ case (key, value) =&amp;gt; ...  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이것 자체로는 아무 타입이 아닌데, 타입을 지정해 주면 &lt;em&gt;function&lt;/em&gt; 이 될 수 있다. 무슨말인고 하니&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;type JBinding = (String, JSON)
val f = { case (key, value) =&amp;gt; ...  } // error
val f: JBinding =&amp;gt; String = { case (key, value) =&amp;gt; ...  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;두 번째 &lt;code&gt;val&lt;/code&gt; 만 성공적으로 컴파일된다. 그리고 스칼라에서 모든 구체적인 타입은 &lt;em&gt;class&lt;/em&gt; 나 &lt;em&gt;trait&lt;/em&gt; 의 구현체인데 &lt;em&gt;function&lt;/em&gt; 도 마찬가지다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;JBinding =&amp;gt; String&lt;/code&gt; 은 &lt;code&gt;scala.Function1[JBinding, String]&lt;/code&gt; 이다. 다시 말해서 모든 함수는 &lt;code&gt;Function&lt;/code&gt; &lt;em&gt;trait&lt;/em&gt; 의 구현이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Function[-A, +R] {
  def apply(x: A): R
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;-A&lt;/code&gt;, &lt;code&gt;+R&lt;/code&gt; 등은 &lt;em&gt;variance&lt;/em&gt; 와 관련된 것인데, 이 &lt;em&gt;variance&lt;/em&gt; 란 것이 어떤 두 타입사이에 관계가 있다면, 컨테이너에 넣었을때의 관계는 어떠한가를 기술하는 것이다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S &amp;lt;: T&lt;/code&gt; means &lt;strong&gt;S is a subtype of T&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S :&amp;gt; T&lt;/code&gt; means &lt;strong&gt;S is a supertype of T&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이걸 &lt;em&gt;bound&lt;/em&gt; 라 부른다. 따라서 &lt;em&gt;mixed bound&lt;/em&gt; 도 있다. &lt;code&gt;S &amp;gt;: NonEmpty &amp;lt;: IntSet]&lt;/code&gt; 이라던지.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A &amp;lt;: B&lt;/code&gt;, 즉 &lt;em&gt;lower bound&lt;/em&gt; 가 있고, 컨테이너 &lt;code&gt;C&lt;/code&gt; 가 있을때&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C[A] &amp;lt;: C[B]&lt;/code&gt; means &lt;strong&gt;C is covariant&lt;/strong&gt;, &lt;code&gt;C[+A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C[A] &amp;gt;: C[B]&lt;/code&gt; means &lt;strong&gt;C is contravariant&lt;/strong&gt;, &lt;code&gt;C[-A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;상관 없으면 &lt;strong&gt;C is non-variant&lt;/strong&gt;, &lt;code&gt;C[A]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위에서 봤듯이 함수의 파라미터는 &lt;em&gt;contravariant&lt;/em&gt;, 리턴타입은 &lt;em&gt;covariant&lt;/em&gt; 인데 이는 파라미터를 나중에 함수 호출할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;더 자세한 내용은 &lt;a href=&#34;http://1ambda.github.io/functional-programming-in-scala-chapter-4/&#34;&gt;Functional Programming in Scala Chapter4&lt;/a&gt; 를 참조하자.&lt;/p&gt;

&lt;p&gt;함수는 &lt;em&gt;trait&lt;/em&gt; 의 구현이고, &lt;code&gt;Map&lt;/code&gt; 은 &lt;code&gt;Function1&lt;/code&gt; 의 서브클래스다. 따라서 맵을 사용할때 &lt;code&gt;exampleMap(key)&lt;/code&gt; 처럼 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Seq&lt;/code&gt; 도 마찬가지로 서브클래스다. 그래서 &lt;code&gt;Vector(3)&lt;/code&gt; 처럼 사용할 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;collection&#34;&gt;Collection&lt;/h4&gt;

&lt;p&gt;컬렉션도 잠깐 복습해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://librairie.immateriel.fr/baw/9780596155957/httpatomoreillycomsourceoreillyimages322250.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://librairie.immateriel.fr&#34;&gt;http://librairie.immateriel.fr&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.stack.imgur.com/2fjoA.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://stackoverflow.com&#34;&gt;http://stackoverflow.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;filter, map&lt;/em&gt; 과 같은 메소드들은 다양한 컬렉션을 지원하지만, &lt;em&gt;list&lt;/em&gt; 에서는 &lt;em&gt;tail recursive&lt;/em&gt; 하게 정의되어 있다고 한다.&lt;/p&gt;

&lt;h3 id=&#34;for-expression&#34;&gt;For Expression&lt;/h3&gt;

&lt;p&gt;스칼라에서 &lt;code&gt;for&lt;/code&gt; 구문은 &lt;code&gt;map, flatMap&lt;/code&gt; 그리고 &lt;em&gt;lazy variant&lt;/em&gt; &lt;code&gt;filter&lt;/code&gt; 로 번역된다.&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;for (x &amp;lt;- e1) yield e2&lt;/code&gt; 는&lt;/p&gt;

&lt;p&gt;&lt;code&gt;e1.map(x =&amp;gt; e2)&lt;/code&gt; 다.&lt;/p&gt;

&lt;p&gt;(2) &lt;code&gt;for (x &amp;lt;- e1 if f; s) yield e2&lt;/code&gt; 는&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;f&lt;/code&gt; 는 &lt;em&gt;filter&lt;/em&gt; 고 &lt;code&gt;s&lt;/code&gt; 는 &lt;em&gt;sequence of generators and filters&lt;/em&gt; 다. 따라서&lt;/p&gt;

&lt;p&gt;&lt;code&gt;for (x &amp;lt;- e1.withFilter(x =&amp;gt; f); s) yield e2&lt;/code&gt; 로 번역된다. 외울 필요는 없고 &lt;code&gt;for&lt;/code&gt; 루프를 쓸 때 &lt;code&gt;withFilter&lt;/code&gt; 때문에 메모리 낭비가 적다는 사실 정도만 알고 있으면 된다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can think of &lt;code&gt;withFilter&lt;/code&gt; as a variant of &lt;code&gt;filter&lt;/code&gt; that doesn&amp;rsquo;t produce an intermediate list, but instead filters the following &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;flatMap&lt;/code&gt; function application&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(3) &lt;code&gt;for (x &amp;lt;- e1; y &amp;lt;- e2; s) yield e3&lt;/code&gt; 는&lt;/p&gt;

&lt;p&gt;&lt;code&gt;e1.flatMap(x =&amp;gt; for (y &amp;lt;- e2; s) yield e3)&lt;/code&gt; 로 번역된다.&lt;/p&gt;

&lt;p&gt;(4) &lt;code&gt;for&lt;/code&gt; 구문에서 &lt;em&gt;generator&lt;/em&gt; 의 &lt;em&gt;left-hand side&lt;/em&gt; 가 패턴일 수 있다. 무슨말인고 하니&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val data: List[JSON] = ...

for {
  JObj(bindings) &amp;lt;- data
  JSeq(phones) &amp;lt;- bindings(&amp;quot;phoneNumber&amp;quot;)
  JObj(phone) &amp;lt;- phones
  JStr(digits) = phone(&amp;quot;number&amp;quot;)
  if digits startWith &amp;quot;212&amp;quot;
} yield (bindings(&amp;quot;firstName&amp;quot;), bindings(&amp;quot;lastName&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;pattern &amp;lt;- expr&lt;/code&gt; 은 이렇게 번역된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;x &amp;lt;- expr withFilter {
        case pattern =&amp;gt; true
        case _ =&amp;gt; false
     } map {
       case pattern =&amp;gt; x
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;functional-random-generators&#34;&gt;Functional Random Generators&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt; 구문은 &lt;em&gt;collection&lt;/em&gt; 에만 쓸 수 있지 않다. &lt;code&gt;map, flatMap, withFilter&lt;/code&gt; 만 구현 된다면 다른 곳으로의 응용도 가능하다. (LINQ 도 그 예라고 본것 같음)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;random value generator&lt;/em&gt; 가 하나의 예제인데, 뭔지 살펴보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  trait Generator[+T] {
    def generate: T
  }

  val integers = new Generator[Int] {
    val rand = new java.util.Random
    def generate = rand.nextInt()
  }

  val booleans = new Generator[Boolean] {
    def generate = integers.generate &amp;gt; 0
  }

  val pairs = new Generator[(Int, Int)] {
    def generate = (integers.generate, integers.generate)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;말 그대로 랜덤한 값들을 타입별로 생성해주는거다. 근데, 매번 해야하는 &lt;em&gt;boilerplate&lt;/em&gt; 땜에 귀찮타. 더 좋은 방법은 없을까? 예를 들어 이렇게 쓸 수 있다면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val booleans = for (x &amp;lt;- integers) yield x &amp;gt; 0

def pairs[T, U](t: Generator[T], u: Generator[U]) = for {
  x &amp;lt;- t
  y &amp;lt;- u
} yield (x, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;del&gt;존나&lt;/del&gt; 쿨하다! 근데 이게 스칼라에서 이렇게 번역되기 때문에&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val booleans = integers map (x =&amp;gt; x &amp;gt; 0)

def pairs[T, U](t: Generator[T], u: Generator[U]) =
  t flatMap(x =&amp;gt; u map (y =&amp;gt; (x, y)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;generator&lt;/em&gt; 을 위한 &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt; 을 만들어야 한다. 이 함수들이  새로운 타입을 위한 &lt;code&gt;Generator&lt;/code&gt; 를 돌려주면 된다. &lt;del&gt;모나드 느낌이 솔솔 난다&lt;/del&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait Generator[+T] {
  self =&amp;gt; // an alias for &amp;quot;this&amp;quot;
  def generate: T

  def map[S](f: T =&amp;gt; S): Generator[S] = new Generator[S] {
    def generate = f(self.generate)
  }
  
  def flatMap[S](f: T =&amp;gt; Generator[S]): Generator[S] = 
    new Generator[S] {
      def generate = f(self.generate).generate
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;self&lt;/code&gt; 가 필요한 이유는 &lt;code&gt;map&lt;/code&gt; 함수 내부에서 &lt;code&gt;this&lt;/code&gt; 컨텍스트를 사용할 수 없기 때문이다. &lt;code&gt;map&lt;/code&gt; 의 &lt;code&gt;this&lt;/code&gt; 로 해석되어 무한루프에 빠진다.&lt;/p&gt;

&lt;p&gt;이렇게 &lt;code&gt;Generator&lt;/code&gt; 를 위 &lt;code&gt;map, flatMap&lt;/code&gt; 을 만들면 &lt;code&gt;booleans&lt;/code&gt; 가 이렇게 번역된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val booleans = for (x &amp;lt;- integers) yield x &amp;gt; 0

val booleans = integers map { x =&amp;gt; x &amp;gt; 0 }

val booleans = new Generator[Booelan] {
  def generate = (x =&amp;gt; x &amp;gt; 0)(integers.generate)
}

val booleans = new Generator[Booelan] {
  def generate = integers.generate &amp;gt; 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def pairs[T, U](t: Generator[T], u: Generator[U]) = t flatMap {
  x =&amp;gt; u map { y =&amp;gt; (x, y) }
}

...
...
...

def pairs[T, U](t: Generator[T], u: Generator[U]) = 
  new Generator[(T, U)] {
    def generate = (t.generate, u.generate)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기 몇개 더 유용한 &lt;em&gt;generator&lt;/em&gt; 를 좀 살펴보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def single[T](x: T): Generator[T] = new Generator[T] {
    def generator = x
  }

  def choose(l: Int, h: Int): Generator[Int] =
    for (x &amp;lt;- integers) yield l + x % (h - l)

  def oneOf[T](xs: T*): Generator[T] =
    for (i &amp;lt;- choose(0, xs.length)) yield xs(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;재밌는 사실은 &lt;em&gt;Generator&lt;/em&gt; 가 &lt;em&gt;building block&lt;/em&gt; 이 된다는 사실이다. &lt;em&gt;Generator&lt;/em&gt; 를 조합해 &lt;em&gt;Generator&lt;/em&gt; 를 만들고.&lt;/p&gt;

&lt;p&gt;처음에 &lt;em&gt;reactive programming&lt;/em&gt; 에 관해서 잠깐 이야기 하면서 &lt;em&gt;compose&lt;/em&gt; 란 단어가 나왔는데, 이게 바로 &lt;em&gt;composing&lt;/em&gt; 의 강력함이다.&lt;/p&gt;

&lt;h4 id=&#34;list-generator&#34;&gt;List Generator&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  def lists: Generator[List[Int]] = for {
    isEmpty &amp;lt;- booleans
    list &amp;lt;- if (isEmpty) emptyLists else nonEmptyLists
  } yield list

  def emptyLists = single(Nil)

  def nonEmptyLists = for {
    head &amp;lt;- integers
    tail &amp;lt;- lists
  } yield head :: tail
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;tree-generator&#34;&gt;Tree Generator&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  // tree generator
  trait Tree
  case class Leaf(x: Int)                   extends Tree
  case class Inner(left: Tree, right: Tree) extends Tree

  def leafs: Generator[Leaf] = for {
    x &amp;lt;- integers
  } yield Leaf(x)

  def inners: Generator[Inner] = for {
    l &amp;lt;- trees
    r &amp;lt;- trees
  } yield Inner(l, r)

  def trees: Generator[Tree] = for {
    isLeaf &amp;lt;- booleans
    tree &amp;lt;- if (isLeaf) leafs else inners
  } yield tree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;코드를 보면, 좀 뭔가 감이 올테다. 바¡ &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt; 을 &lt;code&gt;Geneartor&lt;/code&gt; 에 대해서 정의했기 때문에 &lt;code&gt;for&lt;/code&gt; 내부에서 &lt;code&gt;Generator&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 타입을 빼올 수 있다. 그리고 &lt;code&gt;yield&lt;/code&gt; 를 이용해 만드는 것 또한 &lt;code&gt;Generator&lt;/code&gt; 가 된다.&lt;/p&gt;

&lt;p&gt;&lt;del&gt;오더스키 교수는 진짜 천재같다. 모나드를 이렇게 설명하다니. 예전 강의 들을때도 정말 쉽게 설명한다는 느낌을 많이 받았는데&lt;/del&gt;&lt;/p&gt;

&lt;h4 id=&#34;application-random-testing&#34;&gt;Application: Random Testing&lt;/h4&gt;

&lt;p&gt;유닛테스팅을 할때 &lt;em&gt;input&lt;/em&gt; 에 대해서 &lt;em&gt;expected output&lt;/em&gt; 과 비교해 테스팅을 진행하는데, &lt;em&gt;input&lt;/em&gt; 을 직접 만들지 않고 테스팅이 가능할까?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yes, By generating random test inputs&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def randomTest[T](g: Generator[T], times: Int = 100)(f: T =&amp;gt; Boolean): Unit = {
  for (i &amp;lt;- 0 until times) {
    val value = g.generate
    assert(f(value), &amp;quot;test failed for&amp;quot; + value)
  }
  println(&amp;quot;passed &amp;quot; + times + &amp;quot;tests&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이런 테스팅을 한다면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;randomTest(pairs(lists, lits)) {
  case (xs, ys) =&amp;gt; (xs ++ ys).length &amp;gt; xs.length
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;¤패할 것이다. 둘다 &lt;code&gt;Nil&lt;/code&gt; 이면 실패한다.&lt;/p&gt;

&lt;p&gt;우리는 &lt;em&gt;test&lt;/em&gt; 를 작성할 필요가 없고, 항상 참이어야 하는 &lt;em&gt;properties&lt;/em&gt; 만 작성하면 된다. 그게 &lt;a href=&#34;http://www.scalacheck.org/&#34;&gt;&lt;em&gt;ScalaCheck&lt;/em&gt;&lt;/a&gt; 도구의 기본 아이디어다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ScalaCheck&lt;/em&gt; 튜토리얼을 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import org.scalacheck.Properties
import org.scalacheck.Prop.forAll

object StringSpecification extends Properties(&amp;quot;String&amp;quot;) {

  property(&amp;quot;startsWith&amp;quot;) = forAll { (a: String, b: String) =&amp;gt;
    (a+b).startsWith(a)
  }

  property(&amp;quot;concatenate&amp;quot;) = forAll { (a: String, b: String) =&amp;gt;
    (a+b).length &amp;gt; a.length &amp;amp;&amp;amp; (a+b).length &amp;gt; b.length
  }

  property(&amp;quot;substring&amp;quot;) = forAll { (a: String, b: String, c: String) =&amp;gt;
    (a+b+c).substring(a.length, a.length+b.length) == b
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하스켈의 &lt;a href=&#34;https://www.haskell.org/haskellwiki/Introduction_to_QuickCheck1&#34;&gt;&lt;em&gt;QuickCheck&lt;/em&gt;&lt;/a&gt; 가 먼저 구현되었다고 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;*A&amp;gt; quickCheck ((\s -&amp;gt; (reverse.reverse) s == s) :: [Char] -&amp;gt; Bool)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;monads&#34;&gt;Monads&lt;/h3&gt;

&lt;p&gt;&lt;del&gt;올것이 왔¤&lt;/del&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Data structures with &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; seem to be quite common.&lt;/p&gt;

&lt;p&gt;In fact there&amp;rsquo;s a name that describe this class of a data structure together with some algebraic laws that they hould have&lt;/p&gt;

&lt;p&gt;They are called &lt;strong&gt;monads&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;모나드는 &lt;code&gt;M[T]&lt;/code&gt; 타입으로 표시하는데, 다음의 함수들을 구현해야 한다. 하스켈에서 &lt;code&gt;&amp;gt;&amp;gt;=, return&lt;/code&gt; 과 동일하다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait M[T] {
  // `&amp;gt;&amp;gt;=` called bind
  def flatMap[U](f: T =&amp;gt; M[U]): M[U]
}

// return
def unit[T](x: T): M[T]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이미 우리가 모르는 사이에 썼던 모나드를 보면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt; is a monad with &lt;code&gt;unit(x) = List(x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&lt;/code&gt; is a monad with &lt;code&gt;unit(x) = Set(x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Option&lt;/code&gt; is a monad with &lt;code&gt;unit(x) = Some(x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Generator&lt;/code&gt; is a monad with &lt;code&gt;unit(x) = single(x)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;flatMap&lt;/code&gt; 은 이들 타입에 두루 쓰일 수 있는 반면 스칼라에서 &lt;code&gt;unit&lt;/code&gt; 은 각 모나드 마다 다르다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code&gt;map&lt;/code&gt; 은 모나드에서 &lt;code&gt;flatMap&lt;/code&gt; 과 &lt;code&gt;unit&lt;/code&gt; 을 조합해 만들 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;m map f

== m flatMap (x =&amp;gt; unit(f(x)))
== m flatMap (f andThen unit) // composing functions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;즉 &lt;code&gt;f&lt;/code&gt; 를 받아 적용하고, &lt;code&gt;unit&lt;/code&gt; 으로 모나드로 감싼뒤 &lt;code&gt;flatMap&lt;/code&gt; 을 이용해 &lt;em&gt;flattening&lt;/em&gt; 하면 &lt;code&gt;map&lt;/code&gt; 의 결과가 나온다.&lt;/p&gt;

&lt;h4 id=&#34;monad-laws&#34;&gt;Monad Laws&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;associativity&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;m flatMap f flatMap g == m flatMap (x =&amp;gt; f(x) flatMap g)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;left unit&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;unit(x) flatMap f == f(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;right unit&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;m flatMap unit = m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikibooks.org/wiki/Haskell/Understanding_monads#Monad_Laws&#34;&gt;하스켈 문법&lt;/a&gt;으로 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(m &amp;gt;&amp;gt;= f) &amp;gt;&amp;gt;= g  =  m &amp;gt;&amp;gt;= (\x -&amp;gt; f x &amp;gt;&amp;gt;= g)  -- associativity

return x &amp;gt;&amp;gt;= f   =  f x                      -- left unit

m &amp;gt;&amp;gt;= return     =  m                        -- right unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;associativity&lt;/em&gt; 와 관련해서, &lt;em&gt;monoid&lt;/em&gt; 란 것도 있는데 이건 &lt;em&gt;bind&lt;/em&gt; 가 없는 모나드라 생각하면 쉽다. 예를 들어 &lt;em&gt;integer&lt;/em&gt; 는 모노이드다&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(x + y) + z = x + (y + z)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;monad laws&lt;/em&gt; 를 확인하기 위해 &lt;code&gt;Option&lt;/code&gt; 을 좀 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;abstract class Option[+T] {
  def flatMap[U](f: T =&amp;gt; Option[U]): Option[U] = this match {
    case Some(x) =&amp;gt; f(x)
    case None =&amp;gt; None
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;left unit&lt;/em&gt; 을 보이려면 &lt;code&gt;return x &amp;gt;&amp;gt;&amp;gt; f   =   f x&lt;/code&gt;, 즉&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Some(x) flatMap f == f(x)

// ==
Some(x) match {
  case Some(x) =&amp;gt; f(x)
  case None =&amp;gt; None
}

// == 
f(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;right unit&lt;/em&gt; 을 보이려면 &lt;code&gt;m &amp;gt;&amp;gt; return     =    m&lt;/code&gt; 임을 보이면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;opt flatMap Some // == opt

// == 
opt match {
  case Some(x) =&amp;gt; Some(x)
  case None =&amp;gt; None
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;associative law&lt;/em&gt; 를 보이려면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(m &amp;gt;&amp;gt;= f) &amp;gt;&amp;gt;= g     =     m &amp;gt;&amp;gt;= (\x -&amp;gt; f x &amp;gt;&amp;gt;= g)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 스칼라에선&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;opt flatMap f flatMap g 
// == opt flatMap (x =&amp;gt; f(x) flatMap g)

opt flatMap f flatMap g

// ==
opt match { case Some(x) =&amp;gt; f(x) case None =&amp;gt; None }
    match { case Some(y) =&amp;gt; g(y) case None =&amp;gt; None }
    
// ==
opt match {
  case Some(x) =&amp;gt;
    f(x) match { case Some(y) =&amp;gt; g(y) case None =&amp;gt; None }
  case None =&amp;gt;
    None match { case Some(y) =&amp;gt; g(y) case None =&amp;gt; None }
}

// ==
opt match {
  case Some(x) =&amp;gt; f(x) match {
    case Some(y) =&amp;gt; g(y) case None =&amp;gt; None
  }
  case None =&amp;gt; None
}

// ==
opt match{
  case Some(x) =&amp;gt; f(x) flatMap g
  case None =&amp;gt; None
}

// ==
opt flatMap (x =&amp;gt; f(x) flatMap g)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결국 &lt;code&gt;Option&lt;/code&gt; 은 모나드다. 근데 이런 &lt;em&gt;monad laws&lt;/em&gt; 를 지키면 얻는게 뭘까?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;associativity&lt;/em&gt; 가 지켜지면, 중첩된 &lt;em&gt;for-loop&lt;/em&gt; 를 &lt;em&gt;inline&lt;/em&gt; 할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for (y &amp;lt;- for (x &amp;lt;- m; y &amp;lt;- f(x)) yield y
     z &amp;lt;- g(y)) yield z
     
// ==
for (x &amp;lt;- m;
     y &amp;lt;- f(x)
     z &amp;lt;- g(y)) yield z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;right unit&lt;/em&gt; 은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for (x &amp;lt;- m) yield x

== m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;애석하게도 &lt;em&gt;left unit&lt;/em&gt; 은 마땅한 &lt;em&gt;for-loop&lt;/em&gt; 가 없다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Left unit does not have an analogue for &lt;em&gt;for-expression&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;another-type-try&#34;&gt;Another type: Try&lt;/h3&gt;

&lt;p&gt;강의 후반부에서 &lt;code&gt;Try&lt;/code&gt; 라는 타입을 다룰건데, 이 타입은 &lt;code&gt;Option&lt;/code&gt; 과 비슷하다. 서브타입이 &lt;code&gt;Success, Failure&lt;/code&gt; 로 &lt;em&gt;exception&lt;/em&gt; 이 발생할 경우와 아닐 경우를 처리하는데 쓸 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;abstract class Try[+T]
case class Success[T](x: T)         extends Try[T]
case class Failure[T](e: Exception) extends Try[Nothing]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 &lt;code&gt;Try&lt;/code&gt; 를 예외가 발생할 수 있는 &lt;em&gt;computation (연산)&lt;/em&gt; 을 &lt;em&gt;thread, computer&lt;/em&gt; 간 넘겨주는데 사용할 수 있다. 참고로 스칼라에서 &lt;code&gt;Nothing&lt;/code&gt; 은 &lt;em&gt;bottom type&lt;/em&gt; 이다.&lt;/p&gt;

&lt;p&gt;이 &lt;code&gt;Try&lt;/code&gt; 를 이용해 &lt;em&gt;computation&lt;/em&gt; 을 감쌀 수 있다. &lt;code&gt;Try(expr)&lt;/code&gt; 처럼&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Try {
  def apply[T](expr: =&amp;gt; T): Try[T] =
    try Success(expr)
    catch {
      case NonFatal(e) =&amp;gt; Failure(e)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;=&amp;gt; T&lt;/code&gt; 로 &lt;code&gt;expr&lt;/code&gt; 를 &lt;em&gt;by name&lt;/em&gt; 으로 받는 이유는 연산을 나중에 하기 위해서다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Try&lt;/code&gt; 를 &lt;em&gt;for-loop&lt;/em&gt; 에 활용하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for {
  x &amp;lt;- computeX
  y &amp;lt;- computeY
} yield f(x, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 구문이 하는 일은, &lt;code&gt;computeX&lt;/code&gt;, &lt;code&gt;computeY&lt;/code&gt; 가 모두 성공할 경우에만 &lt;code&gt;Success(f(x, y))&lt;/code&gt; 를 돌려준다. 둘 중 하나라도 실패하면 &lt;code&gt;Failure(e)&lt;/code&gt; 를 반환할 것이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Try&lt;/code&gt; 를 위한 &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt; 은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;abstract class Try[T] {
  def flatMap[U](f: T =&amp;gt; Try[U]): Try[U] = this match {
    case Success(x) = try f(x) 
                      catch { case NonFatal(e) =&amp;gt; Failure(ex)
    case fail: Failure =&amp;gt; fail
  }
  
  def flatMap[U](f: T =&amp;gt; U): Try[U] = this match {
    case Success(x) =&amp;gt; Try(f(x))
    case fail: Failure =&amp;gt; fail
  }
}


// t map f
// == t flatMap (f andThen Try)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Try&lt;/code&gt; 를 모나드라 생각해 보자. &lt;em&gt;monad law&lt;/em&gt; 중 실패하는 것이 있을까? 다시 한번 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;return x &amp;gt;&amp;gt;= f     =    f x    -- left unit
m &amp;gt;&amp;gt;= return       =    m      -- right unit
-- associativity
(m &amp;gt;&amp;gt;= f) &amp;gt;&amp;gt;= g    =    m &amp;gt;&amp;gt;= (\x -&amp;gt; f x &amp;gt;&amp;gt;= g) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아까 &lt;em&gt;for-expression&lt;/em&gt; 에 사용했으니 &lt;em&gt;right unit, associativity&lt;/em&gt; 는 맞을 거고 &lt;em&gt;left unit&lt;/em&gt; 을 살펴보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// return x &amp;gt;&amp;gt;= f     =    f x
Try(x) flatmap f

// ==
this match {
  Success(x) =&amp;gt; try f(x) 
                catch { case NonFatal(e) =&amp;gt; Failure(ex)
  case fail: Failure =&amp;gt; fail
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보면 알겠지만, 예외가 발생하지 않을 경우에만 &lt;em&gt;left unit&lt;/em&gt; 이 성립한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Try(expr) flatMap f != f(expr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;좌변은 예외를 그냥 던지지않고, 감싸서 준다. 반면 우측은 예외를 던질 수 있다. 즉 예외를 던지지 않는 &lt;em&gt;law&lt;/em&gt; 를 얻기 위해 &lt;em&gt;left unit&lt;/em&gt; 을 희생했다고 보면 된다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An expression composed from &lt;code&gt;Try&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt; will never throw a non-fatal exception&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이거 &lt;em&gt;bullet-proof principle&lt;/em&gt; 이라 부른다.&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;이제까지 &lt;em&gt;collection&lt;/em&gt; 뿐만 아니라 다양한 타입에 대해 &lt;em&gt;for-expression&lt;/em&gt; 을 쓸 수 있음을 배웠다. &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;withFilter&lt;/code&gt; 등을 구현하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;flatMap&lt;/code&gt; 을 구현한 많은 타입이 &lt;em&gt;monad&lt;/em&gt; 다. 만약에 &lt;code&gt;withFilter&lt;/code&gt; 를 구현하면 &lt;em&gt;monad with zero&lt;/em&gt; 라 부른다.&lt;/p&gt;

&lt;p&gt;모나드 법칙은 &lt;em&gt;API&lt;/em&gt; 를 구현할때 가이드라인이 되지만, &lt;code&gt;Try&lt;/code&gt; 의 예에서 봤듯이 모나드 법칙을 버려서 다른 이득을 얻을 수도 있다. &lt;del&gt;만만한 left unit&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;http://stackoverflow.com/questions/1722137/scala-2-8-collections-design-tutoria$l&#34;&gt;Scala 2.8 Collection&lt;/a&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://en.wikibooks.org/wiki/Haskell/Understanding_monads#Monad_Laws&#34;&gt;Haskell Wiki: Monad&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>