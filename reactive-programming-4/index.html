<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/Blog">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

  <title>Reactive Programming 4, Observable, Rx</title>
  <meta name="description" content="" />

  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Reactive Programming 4, Observable, Rx">
  <meta name="twitter:description" content="지난시간엔 단일 데이터에 대해 latency 를 지원하는 Future, Promise 에 대해서 알아봤다. 이번에는 컬렉션에서 latency 를 지원하는 방법인 Observable 을 배워보자.                   One           Many Synchronous     T/Try[T]     Iterable[T]   Asynchronous    Future[T]    Observable[T]   From Futures to Observables Future 의 정의를 다시 보면, trait Future[T] {     def onComplete[U](f">
  <meta name="twitter:creator" content="@yourTwitterUsername">
  <meta name="twitter:image" content="">
  <meta name="twitter:url" content="http://1ambda.github.io/reactive-programming-4/">
  <meta name="twitter:domain" content="http://1ambda.github.io">

  

  <link rel="author" href="https://plus.google.com/101105410053351451441?rel=author" />

  <link rel="shortcut icon" href="../favicon.ico">

  <link rel="stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Droid+Serif" />
  <link rel='stylesheet' type='text/css' href="http://fonts.googleapis.com/css?family=Open+Sans:600,300" />
  <link rel="stylesheet" type="text/css" href="../assets/stylesheets/xpressio.css" />
  <link rel="stylesheet" type="text/css" href="../assets/1ambda/1ambda.css" />
  <script type="text/javascript" src="../assets/1ambda/modernizr.js">
  </script>
  <script type="text/javascript" src="../assets/1ambda/detectizr.min.js">
  </script>

  <!--load css if windows -->
  <script type="text/javascript">
    if (Modernizr.windows) {
      file = location.pathname.split( "/" ).pop();
      link = document.createElement( "link" );
      link.href = "/assets/1ambda/1ambda_windows.css";
      link.type = "text/css";
      link.rel = "stylesheet";
      link.media = "screen,print";
      document.getElementsByTagName("head")[0].appendChild( link );
    }
  </script>


  
  <link rel="stylesheet" href="../assets/highlight/styles/github.css">
<script src="../assets/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


  <meta name="generator" content="Ghost 0.5" />
<link rel="alternate" type="application/rss+xml" title="Old Lisper" href="../rss">
<link rel="canonical" href="http://1ambda.github.io/reactive-programming-4/" />

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52181619-1', '1ambda.github.io');
  ga('send', 'pageview');
</script>

  
</head>
<body>

  
  <script src="../public/jquery.js?v=d22d41c688"></script>

  

<header class="site_width text center padding_top_big margin_bottom_big">
  
  <h1 class="blog_title margin_bottom_small"><a href="http://1ambda.github.io">Old Lisper</a></h1>
  <h4 class="text book">Functional Programming</h4>
  
  <div class="social border solid top_small bottom_small padding_medium">
  <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="/about-me"><i class="fa fa-user"></i> <span class="margin_left_small desktop">About me</span></a></h6>
  <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="http://kr.linkedin.com/in/1ambda" target="_blank"><i class="fa fa-linkedin-square"></i> <span class="margin_left_small desktop">Linkedin</span></a></h6>
  <h6 class="text book color c_black_medium without_margin"><a href="http://github.com/1ambda" target="_blank"><i class="fa fa-github"></i> <span class="margin_left_small desktop">GitHub</span></a></h6>
</div>

</header>

<main class="site_width" role="main">
  <article class="post tag-scala tag-coursera tag-observable tag-rx tag-scheduler tag-subscription tag-subject">

    

    <header class="text center margin_bottom_medium">
      <h5 class="text book small uppercase color c_black_light margin_bottom_small">Posted in <a href="../tag/scala">scala</a>, <a href="../tag/coursera">coursera</a>, <a href="../tag/observable">observable</a>, <a href="../tag/rx">rx</a>, <a href="../tag/scheduler">scheduler</a>, <a href="../tag/subscription">subscription</a>, <a href="../tag/subject">subject</a></h5>
      <h1 class="margin_bottom_medium">Reactive Programming 4, Observable, Rx</h1>
      <h5 class="text book small uppercase color c_black_light margin_bottom_small"><time datetime="2014-12-26">Friday, December 26, 2014</time>
      <br/><br/>
       <a href="http://1ambda.github.io/reactive-programming-4/#disqus_thread">Comment</a>
      </h5>
    </header>

    <section>
      <p>지난시간엔 단일 데이터에 대해 <em>latency</em> 를 지원하는 <em>Future, Promise</em> 에 대해서 알아봤다. 이번에는 컬렉션에서 <em>latency</em> 를 지원하는 방법인 <em>Observable</em> 을 배워보자.</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<h3 id="fromfuturestoobservables">From Futures to Observables</h3>

<p><code>Future</code> 의 정의를 다시 보면,</p>

<pre><code class="scala">trait Future[T] {  
  def onComplete[U](f: Try[T] =&gt; U)
  (implicit ex: ExecutionContext): Unit
}
</code></pre>

<p>여기서 중요한 부분은 콜백 <code>f</code> 를 받아 <code>Unit</code> 을 돌려준다는 것이다.</p>

<pre><code class="scala">(Try[T] =&gt; Unit) =&gt; Unit
</code></pre>

<p>이제 <code>=&gt;</code> 를 뒤집고, <code>Unit</code> 을 <code>()</code> 로 표기해서 어떤 <em>intuition</em> 을 얻어보자.</p>

<pre><code class="scala">(Try[T] =&gt; Unit) =&gt; Unit
Unit =&gt; (Unit =&gt; Try[T]) // reverse  
() =&gt; (()=&gt; Try[T])      // Unit -&gt; ()

Try[T]                   // simplify  
</code></pre>

<p>여기서 핵심은 <code>()</code> 는 사이드 이펙트를 위해 존재하므로 그 부분을 제거하면 타<code>Future[T]</code> 의 결과는 <code>Try[T]</code> 와 같다는 것이다.</p>

<blockquote>
  <p><code>Future[T]</code> and <code>Try[T]</code> are <strong>dual</strong></p>
</blockquote>

<p><em>duality</em> 란 <a href="http://en.wikipedia.org/wiki/Category_theory">Category Theory</a> 에 의하면</p>

<blockquote>
  <p>Every statement, theorem, or definition in category theory has a dual which is essentially obtained by <strong>"reversing all the arrows"</strong>.</p>
</blockquote>

<p>처음 시작 부분에서 이런 테이블을 봤을텐데, 여기서도 <em>duality</em> 관계가 나타난다.</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<p>그리고 지난시간에 이메일을 발송하는 코드에서 <code>onComplete</code> 를 몇 번 호출하던 콜백이 받는 <code>Try[T]</code> 는 동일하다는 것을 봤다. 이것은 <code>Future[T]</code> 가 <code>Try[T]</code> 를 돌려주고, 그 값이 일정하다는 사실을 말한다.</p>

<p>이렇게 생각할수도 있다. 콜백 <code>f: Try[T] =&gt; Unit</code> 을 넘기고 <code>Try[T]</code> 를 얻기 위해 <code>asynchronous()</code> 를 사용할 수 있고, <code>Try[T]</code> 를 얻기 전까지 블럭되는 <code>synchronous</code> 를 이용할 수도 있다는 식으로</p>

<pre><code class="scala">def asynchronous(): Future[T]  
def synchronous(): Try[T]  
</code></pre>

<h3 id="iterable">Iterable</h3>

<p><code>Observable[T]</code> 를 보기전에 <em>synchronous data stream</em> 인 <code>Iterable[T]</code> 를 좀 살펴보자.</p>

<pre><code class="scala">trait Iterable[T] { def iterator(): iterator[T] }  
trait Iterator[T] { def hasNext: Boolean; def next(): T }  
</code></pre>

<p><code>while (hasNext) next()</code> 처럼 사용할 수 있다.</p>

<p>그리고 <code>Iterable[T]</code> 를 위한 <code>flatMap</code> 도 정의되어 있다. 따라서 <code>Iterable</code> 은 모나드다.</p>

<pre><code class="scala">def flatMap[B](f: A =&gt; Iterable[B]): Iterable[B]  
</code></pre>

<p>이 <code>Iterator</code> 를 이용해서 디스크에서 파일을 읽는 코드를 작성하면</p>

<pre><code class="scala">def ReadLinesFromDisk(path: String): iterator[String] = {  
  Source.fromFile(path).getLines()
}

val lines = ReadLinesFromDisk(path)

for (line &lt;- lines) {  
  ... DoWork(line) ... // latency
}
</code></pre>

<p>한 라인이 <code>100K</code> 로 어마어마하게 길다면 디스크를 읽기 전까지 기다려야할까? <code>Future</code> 처럼 비동기로 IO 연산을 수행하는 방법을 찾아보자. 이전과 좀 다른점은 지금은 컬렉션을 다루고 있다는 점이다. </p>

<p>이 문제를 해결하기 위해 컬렉션을 순회하는 <code>trait</code> 를 좀 살펴보자. 어떤 일을 해야 하는지 알아야하니까.</p>

<pre><code class="scala">trait Iterable[T] {  
  def iterator(): Iterator[T]
}

trait Iterator[T] {  
  def hasNext: Boolean
  def next(): T
}
</code></pre>

<p><code>Iterable</code>, <code>Iterator</code> 을 좀 간략화 하면, </p>

<ul>
<li><code>Iterable</code> 는 <code>()</code> 를 인자로 받아 <code>Iterator</code> 를 돌려주고</li>
<li><code>Iterator</code> 는 <code>()</code> 를 인자로 받아 <code>Try[Option[T]]</code> 를 돌려준다</li>
</ul>

<p>전체적으로 보면 <code>() =&gt; (() =&gt; Try[Option[T]])</code> 다. 사이드이펙트로 예외를 돌려주거나, <code>None</code> 일수 있거나, 아니면 정상적인 값을 얻을 수 있다는 뜻이다.</p>

<p>타입이 좀 복잡한데, 아까 <em>arrow</em> <code>=&gt;</code> 를 뒤집었던 방법을 다시 사용해서 간단히 만들어 보자. 강의에서는 <em>dualization trick</em> 이라 부른다.</p>

<p>뒤집은 후에는 <code>Try[Option[T]]</code> 를 분해해 보자. 예외를 주거나, 아무 값도 주지 않거나(끝나거나), 값을 주거나.</p>

<pre><code class="scala">() =&gt; (() =&gt; Try[Option[T]])

// reverse
(Try[Option[T]] =&gt; Unit) =&gt; Unit)

// simplify
( T         =&gt; Unit, // Value
  Throwable =&gt; Unit, // Exception
  ()        =&gt; Unit  // Nothing, Terminate
) =&gt; Unit
</code></pre>

<p>즉, 비동기로 컬렉션을 순회하기 위해서는 이런 작업을 처리해줄 무언가가 필요하다. 스칼라에서는 <code>Observable, Observer, Subscription</code> 이 그 일을 담당한다.</p>

<pre><code class="scala">trait Observable[T] {  
  def Subscribe(observer: Observer[T]): Subscription
}

trait Observer[T] {  
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
  def OnCompleted(): Unit
}

trait Subscription {  
  def unsubscribe(): Unit
}
</code></pre>

<p>즉, <code>Observable</code> 에 <code>Try[Option[T]]</code> 에 따라 할일을 지정해 놓은 <code>Observer</code> 를 세팅하고, <code>Subscription</code> 을 얻은 뒤 이후에 필요에 의해 중단해야 하면 <code>unsubscribe</code> 를 호출하는 방식이다. 이는 작업하는 대상이 컬렉션이므로 <code>Future</code> 와는 달리, 하나의 값이 아니라 무한한 값들을 얻어올 수 있기 때문.</p>

<h3 id="futurevsobservable">Future vs Observable</h3>

<p>초반에, 이 테이블을 다시 보면 <code>Iterable</code> 과 <code>Observable</code> 이 <em>dual</em> 이다.</p>

<pre><code>                  One           Many

Synchronous     T/Try[T]     Iterable[T]  
Asynchronous    Future[T]    Observable[T]  
</code></pre>

<p>그리고 이 테이블에 의하면, <code>Future</code> 와 <code>Observable</code> 을 비교해보면 <em>one</em> 과 <em>many</em> 가 의미하는 바를 <em>type</em> 으로 이해할 수 있다.</p>

<pre><code class="scala">Observable[T] = (Try[Option[T]] =&gt; Unit) =&gt; Unit  
Future[T]     = (Try[T]         =&gt; Unit) =&gt; Unit  
</code></pre>

<p>타입을 보면 <code>Future</code> 는 <code>Option</code> 부분이 없지만 <code>Observable</code> 은 있다. 즉 <code>Observable</code> 은 아무런 값도 없다는 사실을 의미하는 타입 <code>Option</code> 을 이용해 <em>종료시점</em> 을 알려줄 수 있기 때문에 <em>multiple values</em> 를 처리할 수 있다.</p>

<p><em>concurrency</em> 측면에선 어떨까? 타입을 살펴보면</p>

<pre><code class="scala">object Future {  
  def apply[T](body: =&gt; T)
   (implicit executor: ExecutionContext): Future[T]
}

trait Observable[T] {  
  def observeOn(scheduler: Scheduler): Observable[T]
}
</code></pre>

<p><code>Observable</code> 의 경우엔 하나의 <code>ExecutionContext</code> 가 아니라 여러개를 가져야 하기 때문에 <code>Scheduler</code> 를 이용한다. 이 부분은 나중에 더 자세히 살펴보자.</p>

<h4 id="observableexample">Observable example</h4>

<pre><code class="scala">val ticks: Observable[Long] = Observable.interval(1 seconds)  
val evens: Observable[Long] = ticks.filter(s =&gt; s % 2 == 0)  
val bufs:  Observable[Seq[Long]] = evens.buffer(2, 1)  
val s = bufs.subscribe(b =&gt; println(b))

readLine()  
s.unsubscribe  
</code></pre>

<p><code>Observable</code> 을 <em>latency</em> 를 지원하는 컬렉션으로 이해하면 쉽다. <code>interval</code>  을 이용해 간격을 지정하거나, 일반 컬렉션처럼 <code>filter</code> 도 사용할 수 있다. <code>evens.buffer</code> 는 그냥 버퍼링이라고 생각하면 된다. 버퍼 크기가 2인 것으로.</p>

<p>이런 것도 가능하다.</p>

<pre><code class="scala">val xs = Observable.range(1, 10)  
val ys = xs.map(x =&gt; x + 1)  
</code></pre>

<p><code>xs</code> 는 비동기 순회를 지원하는 컬렉션이다. <code>filter</code>, <code>map</code>, <code>flatMap</code>, <code>take</code>, <code>zip</code> 등 을 지원한다.</p>

<h3 id="flatmap">flatMap</h3>

<p><img src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/flatMap.png" alt="" /></p>

<p align="center">(<a href='http://reactivex.io/'>http://reactivex.io/</a>)</p>

<p>색깔의 순서를 봐야할 필요가 있다. <code>Observable</code> 은 비동기 연산이기 때문에 순서가 좀 달라질 수 있다. 구현에도 그런 부분이 나타나 있는데 아래의 코드에서 <code>flatten</code> 이 의미하는 바는 <em>non-deterministic merge</em> 다. </p>

<pre><code class="scala">def flatMap(f: T =&gt; Observable[S]): Observable[S] = {  
  map(f).flatten()
}
</code></pre>

<p>다른 코드도 좀 보면</p>

<pre><code class="scala">val xs: Observable[Int] = Observable(3, 2, 1)

val yss: Observable[Observable[Int]] =  
  xs.map(x =&gt; Observable.Interval(x seconds).map(_ =&gt; x).take(2))

val zs: Observalble[Int] = yss.flatten()  
</code></pre>

<p><img src="https://camo.githubusercontent.com/1db5afe0637db37bf24a0476deeb4a6af5f846a1/687474703a2f2f692e696d6775722e636f6d2f5a75364f5034442e706e67" alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine'>https://github.com/iirvine</a>)</p>

<p>위 코드는 <code>x</code> 초 후에 <code>x</code> 2개를 뱉는 <code>Oberservable</code> 을 만든 후 <code>flatten</code> 을 사용해 껍데기를 벗긴다. <code>List(List(1, 2), List(3)).flatten</code> 하면 <code>List(1, 2, 3)</code> 이 되듯이 <code>Observable[Observable].flatten</code> 도 <code>Observable</code> 을 만든다고 생각하면 쉽다.</p>

<h3 id="merge">Merge</h3>

<p><img src="https://camo.githubusercontent.com/7bf59d06b672be32c63b8c2260e68840b408e100/687474703a2f2f692e696d6775722e636f6d2f64376e74576d462e706e67" alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine'>https://github.com/iirvine</a>)</p>

<p>예외나, 종료 등 어떤 이유에서든지 먼저 끝나는 <code>Observable</code> 에 의해 <code>merge</code> 가 종료된다는 점에 주의하자.</p>

<h3 id="concat">Concat</h3>

<pre><code class="scala">val xs: Observable[Int] = Observable(3, 2, 1)

val yss: Observable[Observable[Int]] =  
  xs.map(x =&gt; Observable.Interval(x seconds).map(_ =&gt; x).take(2))

val zs: Observalble[Int] = yss.concat  
</code></pre>

<p><img src="https://camo.githubusercontent.com/2a578ecf4d5c6890f82ef27a5eb5330e3a613d4c/687474703a2f2f692e696d6775722e636f6d2f4b386a5147316e2e706e67" alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine'>https://github.com/iirvine</a>)</p>

<p>여기서 재밌는점은 <code>yss</code> 의 첫번째 원소인 </p>

<pre><code class="scala">Observable.Interval(3 seconds).map(_ =&gt; x).take(2)  
</code></pre>

<p>가 끝나기 전까지 다른 원소들이 버퍼링 되므로 주의해야 한다는 점이다. <em>marble diagram</em> 으로 보면</p>

<p><img src="https://camo.githubusercontent.com/126a399bf6587fd5d3a5e23975b3aeb865573269/687474703a2f2f692e696d6775722e636f6d2f62334a6e564d542e706e67" alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine'>https://github.com/iirvine</a>)</p>

<h3 id="earthquakesexample">Earthquakes example</h3>

<pre><code class="scala">def usgs(): Observable[EarthQuake] = { ... }

class EarthQuake {  
  ...
  def magnitude: Double
  def location: GeoCoordinate
}

object Magnitude extends Enumeration {  
  def apply(magnitude: Double): Magnitude = { ... }
  type Magnitude = Value

  val Micro, Minor, Light, Moderate, Strong, Major, Great = Value
}

val major = quakes.  
  map(q =&gt; (q.location, Magnitude(q.magnitude))).
  filter { case (loc, mag) =&gt; mag =&gt; Major }

major.subscribe({ case (loc, mag) =&gt;  
  println($"Magnitude ${ msg } quake at ${ loc }")
})
</code></pre>

<p>이런식으로 사용할 수 있다. 더 실제 동작하는 코드는 <a href="https://github.com/headinthebox/CourseraCodeSamplesReactiveProgramming">여기</a>로. 조금 복잡하다.</p>

<p>위치를 <code>GeoCoordinate</code> 로 받기 때문에, 해당 위치의 나라를 돌려준다든지 등으로 개선할 수 있다.</p>

<pre><code class="scala">def reverseGeocode(g: GeoCoordinate): Future[Country] = { ... }  
</code></pre>

<p>이 함수를 구현하면</p>

<pre><code class="scala">val withCountry: Observable[Observable[EarthQuake, Country)]] =  
  usgs().map(q =&gt; {
    val country: Future[Country] = reverseGeocode(q.location)
    Objservable(country.map(country =&gt; (quake, country)))
  })

// val merged: Observable[(EarthQuake, Country)] =
//  withCountry.flatten()
val merged: Observable[(EarthQuake, Country)] = withCountry.concat()  
</code></pre>

<p>여기서 머징하기 위해 <code>flatten</code> 이나 <code>concat</code> 을 사용할 수 있는데, 언급했듯이 어떤걸 쓰느냐에 따라 순서가 달라질 수 있다. 아래 그림은 각각 <code>flatten</code>, <code>concat</code> 을 설명한다.</p>

<p><img src="https://camo.githubusercontent.com/d33a97e9d34e395be97256e9993798e4ae24362e/687474703a2f2f692e696d6775722e636f6d2f6258665a5a30532e706e67" alt="" /></p>

<p><img src="https://camo.githubusercontent.com/f8689dc2d0bdd4435a34c5309f54c59b39b85162/687474703a2f2f692e696d6775722e636f6d2f6a3161486e55462e706e67" alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine'>https://github.com/iirvine</a>)</p>

<h4 id="groupby">group by</h4>

<p><img src="https://camo.githubusercontent.com/f0c975e06586e938d62c8c6c96eac90132cbc591/687474703a2f2f692e696d6775722e636f6d2f6e36543251624b2e706e67" alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine'>https://github.com/iirvine</a>)</p>

<pre><code class="scala">def groupBy[K](keySelector: T =&gt; K): Observable[(K, Observable[T])]  
</code></pre>

<p>즉 <code>T</code> 를 받아 키 <code>K</code> 를 만들고, 이것에 따라 <code>Observable</code> 을 그룹짓는다. 이걸 응용하면 나라별로 지진을 취합하는 것이 가능하다.</p>

<pre><code class="scala">val byCountry: Observable[(Country, Observable[(EarthQuake, Country)]] =  
  merged.groupBy( case (q, c) =&gt; c }
</code></pre>

<p><img src="https://camo.githubusercontent.com/c5cff5ae933284de2de7ed009c3d4228ea2f1b12/687474703a2f2f692e696d6775722e636f6d2f775852325a4c592e706e67" alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine'>https://github.com/iirvine</a>)</p>

<p>이제 <code>runningAverage</code> 란 함수가 있다고 해 보자. <code>Observable[Double]</code> 을 받아  업데이트 후 <code>Observable[Double]</code> 을 돌려주는 함수. 그러면 <code>runningAveragePerCountry</code> 는 어떻게 구현할까?</p>

<pre><code class="scala">val byCountry: Observable[(Country, Observable[(EarthQuake, Country)]]  
def runningAverage(s: Observable[Double]): Observable[Double] =  
  { ... }
val runningAveragePerCountry: Observable[(Country, Observable[Double])] =  
  byCountry.map { case (country, cqs) =&gt; 
    (country, runningAverage(cqs.map(_._1.magnitude))
  }
</code></pre>

<h3 id="subscription">Subscription</h3>

<p>지진 예제를 다시 가져오면, 더이상 관심 없을때 <code>unsubscribe</code> 를 호출할 수 있다.</p>

<pre><code class="scala">val quakes: Observable[EarthQuake] = { ... }  
val s: Subscription = quakes.Subscribe(...)

s.unsubscribe()  
</code></pre>

<p>근데, 생각해보면 여러 곳에서 <em>subscription</em> 할 수 있다. <em>UI</em> 같은 경우 그 수가 많을 것이다. 이 경우 <em>unsubscribing</em> 이 <em>cancellation</em> 을 의미하지 않는다. 왜냐하면 다른곳에서 <em>subscribing</em> 하고 있을 수 있기 때문이다.</p>

<p>타입을 좀 보면</p>

<pre><code class="scala">trait Subscription {  
  def unsubscribe(): Unit
}

object Subscription {  
  def apply(unsubscribe: =&gt; Unit): Subscription
}

trait BooleanSubscription extends Subscription {  
  def isUnsubscribed: Boolean
}

trait CompositeSubscription extends BooleanSubscription {  
  def +=(s: Subscription): this.type
  def -=(s: Subscription): this.type
}

trait MultipleAssignmentSubscription extends BooleanSubscription {  
  def subscription: Subscription
  def subscription_=(that: Subscription): this.type
}
</code></pre>

<p>여기서 <code>CompositeSubscription</code> 은 컬렉션처럼 <code>Subscription</code> 을 추가하거나, 제거할 수 있고 <code>unsubscribe</code> 하면 나머지도 모두 취소 된다.</p>

<p><code>MultipleAssignmentSubscription</code> 은 일종의 <em>inner subscription</em> 을 위한 프록시처럼 동작한다. 세팅하고, 교체할 수 있지만, 항상 내부에는 동작하는 하나의 <code>Subscription</code> 이 있다.</p>

<pre><code class="scala">import rx.lang.scala.subscriptions._  
import rx.lang.scala.Subscription

val s = Subscription {  
  println("bye, bye")
}

s.unsubscribe()  
s.unsubscribe() // buggy  
</code></pre>

<p>이 경우 두번째 <code>unsubscribe()</code> 를 호출했을때 <code>"bye, bye"</code> 가 호출되지 않는다. 먼저 <code>unsubscribe()</code> 를 호출했기 때문이다. </p>

<p>직접 <code>Subscription</code> 을 구현할때는 다수의 스레드에서 저마다 <code>unsubscribe()</code> 를 호출할 수 있기 때문에 이 메소드는 <em>idempotent</em> 하게 구현되야 한다.</p>

<p><code>CompositeSubscription</code> 을 이미 <code>unsubscribe</code> 했을땐, 새로운 <code>Subscription</code> 을 추가한다 하더라도 자동으로 <code>unsubscribe</code> 가 호출된다.</p>

<p><code>MultiAssignmentSubscription</code> 의 경우에는 여러번 할당할 수 있으나, 단 하나의 <code>Subscription</code> 만 가리킨다. 따라서 다음 코드를 실행할 경우 <code>b.unsubscribe</code> 만 호출된다.</p>

<pre><code class="scala">val a = Subscription { println("A") }  
val b = Subscription { println("B") }  
val m = MultiAssignmentSubscription()

multi.subscription = a  
multi.subscription = b  
multi.unsubscribe  
</code></pre>

<p><code>CompositeSubscription</code> 과 마찬가지로 이미 <code>unsubscribe</code> 되었다면, 할당되는 <code>Subscription</code> 도 자동으로 <code>unsubscribe</code> 된다.</p>

<p><code>CompositeSubscription</code> 이나 <code>MultiAssignment</code> 를 연산을 공유하는 컨테이너라 볼 수 있겠는데, 그럼 여기서 내부의 것만 <code>unsubscribe</code> 하면 어떻게 될까? 당연히 외부의 <code>MultiAssignment</code> 나 <code>Composite</code> 는 알 길이 없으니 <code>isUnsubscribe</code> 는 <code>false</code> 가 된다.</p>

<h3 id="rxstream">Rx Stream</h3>

<p>자주 보게 될 타입부터 소개하면</p>

<pre><code class="scala">object Observable {  
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

trait Observable[T] {  
  def subscribe(observer: Observer[T]): Subscription
}

trait Observer[T] {  
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
  def OnCompleted(): Unit
}

trait Subscription {  
  def unsubscribe(): Unit
}
</code></pre>

<p>아무런 알림도 못받는 <code>Observable</code> 을 만드는 <code>never</code> 와, <code>onError</code> 를 호출하는 <code>apply</code> 를 구현해 보자.</p>

<pre><code class="scala">def never(): Observable[Nothing] = Observable[Nothing](observer =&gt; {  
  Subscription {}
})

def apply[T](error: Throwable): Observable[T] =  
  Observable[T](observer =&gt; {
    observer.onError(error)
    Subscription {}
  }
</code></pre>

<p>이제 이 함수들을 이용해 다양한 함수를 구현해 보자.</p>

<h4 id="startwith">startWith</h4>

<pre><code class="scala">object Observable {  
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

def switchWith(ss: T*): Observable[T] = {  
  Observer[T](observer =&gt; {
    for(s &lt;- ss) observer onNext(s)
    subscribe(observer)
  }
}
</code></pre>

<h4 id="filter">filter</h4>

<p><img src="http://reactivex.io/assets/operators/filter.png" alt="" /></p>

<pre><code class="scala">object Observable {  
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

def filter(p: T =&gt; Boolean): Observable[T] = {  
  Observable[T](observer =&gt; {
    subscribe(
      (t: T) =&gt; { if (p(t)) observer.onNext(t) },
      (e: Throwable) =&gt; { observer.onError(e) },
      () =&gt; { observer.onCompleted() }
    )
  })
}
</code></pre>

<p><br/></p>

<h4 id="map">map</h4>

<p><img src="http://reactivex.io/assets/operators/map.png" alt="" /></p>

<pre><code class="scala">object Observable {  
  def apply[T](s: Observer[T] =&gt; Subscription): Oberservable[T]
}

def map[S](f: T =&gt; S): Observable[S] = {  
  Observable[T](observer =&gt; {
    subscribe(
      (t: T) =&gt; { if (p(t)) observer.onNext(f(t)) },
      (e: Throwable) =&gt; { observer.onError(e) },
      () =&gt; { observer.onCompleted() }
    )
  })
}
</code></pre>

<p>그림을 잘 보면 <em>input stream</em> 으로 부터 값을 얻어 함수를 적용하고 <em>output stream</em> 으로 뱉는다. 구현도 마찬가지로 현재의 컨테이너인 <code>Observable</code> 로 부터 값을 얻었을때 함수를 적용하고 어떻게 넘겨줄지를 정의한다. </p>

<p><em>duality</em> 관계인 <code>Iterable</code> 의 <code>map</code> 구현을 보면 더 명확히 알 수 있다.</p>

<pre><code class="scala">def map[S](f: T =&gt; S): Iterable[S] = {  
  new Iterable[S] {
    val it = this.iterator()
    def iterator: Iterator[S] = new Iterator[S] {
      def hasNext: Boolean = { it.hasNext }
      def next(): S = { f(it.next()) }
    }
  }
}
</code></pre>

<h4 id="futuretoobservable">Future to Observable</h4>

<p><code>Future[T]</code> 를 얻어 <code>Observable[T]</code> 로 바꿔보자. <code>T</code> 를 <code>List[T]</code> 로 바꾸듯이. 그럴려면 <code>Subject</code> 를 알아야 하는데, 이건 지난시간에 배운 <code>Promise</code> 비슷한 역할을 한다.</p>

<pre><code class="scala">import scala.concurrent.ExecutionContext.Implicits.global

def race[T](left: Future[T], right: Future[T]): Future[T] = {  
  val p = Promise[T]()

  left  onComplete { p.tryComplete(_) }
  right onComplete { p.tryComplete(_) }

  p.future
}
</code></pre>

<p><code>Promise</code> 로 부터 <code>Future</code> 를 얻고, <code>Future.onComplete</code> 에 콜백을 넘기면, 완료되었을때 <code>Promise.complete</code> 에 의해 호출된다. <code>Promise</code> 는 <code>Future</code> 를 위한 대리자? 프록시쯤으로 볼 수 있다. </p>

<p><code>Observable</code> 과 <code>Subject</code> 도 비슷한 관계다. </p>

<p><img src="https://camo.githubusercontent.com/bf2c5f3f0d9cadd2b62b347d91be4f4024bd5c8d/687474703a2f2f692e696d6775722e636f6d2f4879644b49374c2e706e67" alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine'>https://github.com/iirvine</a>)</p>

<p>코드로 이해해 보자.</p>

<pre><code class="scala">val channel = PublishSubject[Int]()

val a = channel.subscribe(x =&gt; println("a: " + x))  
val b = channel.subscribe(x =&gt; println("b: " + x))

channel.onNext(42)  
a.unsubscribe()

channel.onNext(4711)  
channel.onComplete()

val c = channel.subscribe(x =&gt; println("c: " + x))  
channel.onNext(13)  
</code></pre>

<p><img src="https://camo.githubusercontent.com/52f18665a6534224028549d548f23833f3abab10/687474703a2f2f692e696d6775722e636f6d2f5671507a6b42372e706e67" alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine'>https://github.com/iirvine</a>)</p>

<p><code>Subject</code> 는 일종의 채널이라 보면 된다. 위 코드에서 흥미로운 점은 <code>onComplete</code> (<code>!</code> 로 표시) 가 호출 된 뒤에 옵저버 <code>c</code> 를 <code>Subject</code> 에 추가했음에도 <code>c</code> 도 <code>onComplete</code> 가 호출된 것을 알고 있다는 사실이다. </p>

<p><br/></p>

<pre><code class="scala">val channel = ReplaySubject[Int]()

val a = channel.subscribe(x =&gt; println("a: " + x))  
val b = channel.subscribe(x =&gt; println("b: " + x))

channel.onNext(42)  
a.unsubscribe()

channel.onNext(4711)  
channel.onComplete()

val c = channel.subscribe(x =&gt; println("c: " + x))  
channel.onNext(13)  
</code></pre>

<p><img src="https://camo.githubusercontent.com/5a105a4004a31498e930295235501c0963ae7fe0/687474703a2f2f692e696d6775722e636f6d2f577770466d34752e706e67" alt="" /></p>

<p><code>ReplaySubject</code> 의 경우에는 <code>c</code> 에도 모든 데이터를 받는다. 이는 <code>ReplaySubject</code> 가 히스토리를 캐싱하고있기 때문이다. </p>

<p>다양한 종류의 <code>Subject</code> 를 그림으로 보면</p>

<p><img src="https://camo.githubusercontent.com/ee926edb502552b7b50a1858ae4baf601d19b26b/687474703a2f2f692e696d6775722e636f6d2f78424a5874596d2e706e67" alt="" /></p>

<p align="center">(<a href='https://github.com/iirvine'>https://github.com/iirvine</a>)</p>

<h4 id="convertingfuturetoobservable">Converting Future to Observable</h4>

<pre><code class="scala">object Observable {  
  def apply[T](f: Future[T]): Observable[T] = {
    val as = AsyncSubject[T]()

    f onComplete {
      case Failure(e) =&gt; { as.onError(e) }
      case Success(c) =&gt; { as.onNext(c); as.onCompleted() }
    }

    as
  }
}
</code></pre>

<p>복잡하게 생각하지 말고 그냥 <code>Promise</code> 랑 비슷한 일을 한다고 이해하면 쉽다.</p>

<h4 id="notifications">Notifications</h4>

<p>지난 시간에 <code>Future</code> 가 <code>Try</code> 를 이용하는걸 봤다. <code>Future[Try[T]</code> 처럼.  <code>Notification</code> 도 이와 비슷하다. <code>Observable[Notification[T]]</code> 처럼 사용한다.</p>

<pre><code class="scala">abstract class Try[+T]  
case class Success[T](elem: T) extends Try[T]  
case class Failure(t: Throwable) extends Try[Nothing]

abstract class Notification[+T]  
case class OnNext[T](elem: T) extends Notification[T]  
case class OnError(t: Throwable) extends Notification[Nothing]  
case object onCompleted extends Notification[Nothing]

def materialize: Observable[Notification[T]] = { ... }  
</code></pre>

<p>차이라면, <em>종료</em> 를 알려주는 <code>onCompleted</code> 가 있다는 것이다. <code>materialize</code> 는 <code>Observable[T]</code> 를 감싸 <code>Observable[Notification[T]]</code> 로 만든다.</p>

<p><img src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/materialize.png" alt="" /></p>

<h4 id="blocking">Blocking</h4>

<p>권할만한 방법은 아니지만, 만약에, 만약에 블러킹이 필요하다면 이런식으로 코드를 작성할 수도 있다는 것을 지난시간에 배웠다.</p>

<pre><code class="scala">val f: Future[String] = { ... }  
val text: String = Await.result(f, 10 seconds)  
</code></pre>

<p><code>Observable</code> 도 마찬가지다.</p>

<p><img src="https://camo.githubusercontent.com/f71128934e19a648745cd6d02664cdc887b55db6/687474703a2f2f692e696d6775722e636f6d2f66683745746f692e706e67" alt="" /></p>

<pre><code class="scala">val xs: Observable[Long] = Observable.interval(1 seconds).take(5)  
val ys: List[Long] = xs.toBlockingObservable.toList

println(ys)

// all Rx operators are non-blocking
val zs: Observable[Long] = xs.sum  
val s: Long = zs.toBlockingObservable.single  
</code></pre>

<h4 id="observabletoscalartypes">Observable to Scalar Types</h4>

<p><code>Observable</code> 내에 있는 값들을 계산하기 위해 <code>reduce</code> 를 사용할 수 있다. <code>fold</code> 와 비슷하달까</p>

<p><img src="https://camo.githubusercontent.com/c2f1c7ca45a71649a8f64c515c282835ef543b1d/687474703a2f2f692e696d6775722e636f6d2f5130636a64395a2e706e67" alt="" /></p>

<pre><code class="scala">def reduce(f: (T, T) =&gt; T): Observable[T]  
</code></pre>

<p>재밌는 사실은 리턴타입이 원소가 <code>Observable</code> 을 돌려주기 때문에 <code>Future</code> 와 비슷하다는 것이다.</p>

<h4 id="iterabletoobservable">Iterable to Observable</h4>

<p>잘못된 구현을 먼저 보자.</p>

<pre><code class="scala">def from[T](seq: Iterable[T]): Observable[T] =  
  Observable(o =&gt; {
    seq.foreach(s =&gt; o.onNext(s)) // What if seq is infinite?
    o.onCompleted // What if seq fails?
    Subscription {}
  })
</code></pre>

<p>이 구현의 문제점은, <code>Iterable</code> 이 무한하거나, 실패하면 어떻게 처리할지 전혀 고려하지 않았다는 것이다. 게다가 빈 <code>Subscription</code> 을 돌려주기 때문에, <code>unsubscribe</code> 할 수도 없다.</p>

<p>이 문제를 풀기 위해서는 <em>scheduler</em> 가 필요하다.</p>

<h3 id="scheduler">Scheduler</h3>

<p>우선 돌아가는 코드를 만들기 전에 테스트 케이스부터 작성하자</p>

<pre><code class="scala">// factory method
object Observable {  
  def apply[T](subscribe: Observer[T] =&gt; Subscription): Observable[T]
}

def from[T](seq: Iterable[T]): Observable[T] = { ... }

// infinite seq
def nats(): Iterable[Int] = new Iterable[Int] {  
  val i = -1
  def iterator: Iterator[Int] = new Itertor[Int] {
    def hasNext: Boolean = { true }
    def next(): Int = { i += 1; i }
  }
}

val infinite: Iterable[Int] = nats()  
val subscription = from(infinite).subscribe(x =&gt; println(x))

subscription.unsubscribe()  
</code></pre>

<p>만약 <code>from</code> 이 위에서 본 것처럼 구현되어 있다면 <code>subscription.unsubscribe()</code> 에 도달하지 못한다. 따라서 <em>iteration</em> 을 진행하는 것과는 다른 컨텍스트를 도입해 <code>unsubscribe</code> 를 호출해야 한다. 그래서 스케쥴러가 필요하다. </p>

<p><code>Future</code> 에서는 <code>ExecutionContext</code> 가 있었지만, <code>Observable</code> 은 복수개의 컨텍스트를 조작해야 하므로 스케쥴러를 써야한다.</p>

<pre><code class="scala">object Future[  
  def apply[T](body: =&gt; T)
   (implicit executor: ExecutionContext): Future[T]
}

trait Observable[T] {  
  def observeOn(scheduler: Scheduler): Observable[T]
}

// Runnable == Java's Runnable
trait ExecutionContext {  
  def execute(runnable: Runnable): Unit
}

// '=&gt; Unit' == Runnable
trait Scheduler {  
  def schedule(work: =&gt; Unit) Subsciption
}

// example
val scheduler = Scheduler.newThreadScheduler  
val subscription = scheduler.schedule {  
  println("Hello World!")
}
</code></pre>

<p><code>Future</code> 는 <code>Runnable</code> 을 취소할 수 있는 방법이 없지만, <code>Scheduler</code> 는 <code>Subscription</code> 을 리턴하기 때문에 취소할 수 있다. 그러나 일단 작업이 시작되면 취소할 수 있는 방법은 없다. 아래 예제를 보자</p>

<pre><code class="scala">def from[T](seq: Iterable[T])  
    (implicit s: Scheduler): Observable[T] = {

  Observable[T](o =&gt; {
    s.schedule {
      seq.foreach(x =&gt; observer.onNext(x))
      observer.onCompleted()
    }
  }
}
</code></pre>

<p><code>onNext</code> 가 호출되기 전, 아주 잠깐동안만 작업을 취소할 수 있는 기회가 있다. 다시 말해서, 이터레이션이 통채로 스케쥴링 되기 때문에 좀 별로라는 것이다. 매 이터레이션마다 취소할 기회가 있는 <code>from</code> 을 구현하고 싶다. </p>

<p><code>scheduler</code> 의 다른 시그니쳐를 좀 보자.</p>

<pre><code class="scala">trait Scheduler {  
  def schedule(work: =&gt; Unit): Subscription

  def schedule(work: Scheduler =&gt; Subscription): Subscription

  def schedule(work: (=&gt; Unit) =&gt; Unit): Subscription
}
</code></pre>

<p>두번째 시그니쳐를 보자. <code>schedule</code> 함수가 하는 일이 <code>Scheduler</code> 를 받아 등록하고 <code>Subscription</code> 을 돌려주는 일이라면 그것 자체를 <code>work</code> 로 받고, 해당 <code>work</code> 에서 한번씩만 이터레이션 한다면 매 이터레이션에서 취소할 기회를 가질 수 있다. </p>

<p>이건 사실 세번째 시그니쳐와 동일한데 이유는 뒤에서 보겠다. </p>

<p><code>from</code> 의 새로운 구현을 보면</p>

<pre><code class="scala">def from[T](seq: Iterable[T])  
    (implicit) scheduler: Scheduler): Observable[T] = {

  Observable[T](o =&gt; {
    val it = seq.iterator()

    scheduler.schedule(self =&gt; {
      if (it.hasNext) { o.onNext(it.next()); self() }
      else { o.onCompleted() }
    }
  }
}
</code></pre>

<p><del>으사양반 이게 무슨 개소리요!</del></p>

<p>조금 난해한데, <code>it.hasNext</code> 가 있어서 다음 이터레이션으로 넘어갈 수 있으면 <code>self()</code> 를 호출해 자기 자신을 스케쥴링한다. 따라서 매 이터레이션마다 사용 가능한 <code>Subscription</code> 이 있으므로 취소할 수 있는 기회가 생긴다. </p>

<p><img src="https://camo.githubusercontent.com/216556caf19e30587d4697466b4244b33f182f76/687474703a2f2f692e696d6775722e636f6d2f78683546576a382e706e67" alt="" /></p>

<p>물론 <code>Subscription</code> 이 갱신되는데 어떻게 하나의 레퍼런스로 그게 가능하느냐 하는 질문이 나올 수 있는데, 우리는 이미 <code>MultipleAssignmentSubscription</code> 을 배웠다. <code>schedule</code> 함수의 내부를 보자.</p>

<pre><code class="scala">def schedule(work: (=&gt; Unit) =&gt; Unit): Subscription = {  
  val subs = new MultipleAssignmentSubscription()

  schedule(scheduler =&gt; {
    def loop(): Unit = {
      subs.Subscription = scheduler.schedule {
        work { loop() }
      }
    }

    loop()
    subs
  })

  subs
}

def from[T](seq: Iterable[T])  
    (implicit) scheduler: Scheduler): Observable[T] = {

  Observable[T](o =&gt; {
    val it = seq.iterator()

    scheduler.schedule(self =&gt; {
      if (it.hasNext) { o.onNext(it.next()); self() }
      else { o.onCompleted() }
    }
  }
}
</code></pre>

<p>즉, <code>self</code> 가 바로 <code>loop</code> 다. 자기 자신을 스케쥴링하는 함수인데, 
<code>work -&gt; loop -&gt; work -&gt; loop -&gt; ...</code> 을 반복하면서 더 이터레이션할 멤버가 없거나, <code>unsubscribe</code> 하기 전까지 재귀적으로 돈다. </p>

<h4 id="schedulertoobservable">Scheduler to Observable</h4>

<p>돌려주는 값 없이 행위 그 자체만 보면, 스케쥴러 그 자체는 <code>Observable[Unit]</code> 에 대응된다. </p>

<pre><code class="scala">object Observable {  
  def apply() (implicit s: Scheduler): Observable[Unit] = {
    Observable(o =&gt; {
      s.schedule(self =&gt; {
        o.onNext(()); self
      })
    })
  }
}

implicit val s = Scheduler.NewThreadScheduler  
val ticks: Observable[Unit] = Observable()  
</code></pre>

<p>이게 실제로 어떻게 동작하나 보면</p>

<pre><code class="scala">object Observable {  
  def apply(s: Observer[T] =&gt; Subscription) = new Observable[T] {
    def subscribe(o: Observer[T]): Subscription = { Magic(s(o)) }
  }
}

val subs = Observable(o =&gt; F(o)).subscribe(observer)

// = conceptually
val subs = Magic(F(observer))  
</code></pre>

<p>여기서 <code>F</code> 나 <code>Magic</code> 는 임의의 함수라 생각하면 된다. (그런게 있나보다 하자.)</p>

<p>이걸 왜 이야기하냐 하면 <em>auto unsubscribe</em> 가 가능하기 때문이다. 스케쥴링 하는 행위를 <em>observable</em> 로 변경할 수 있다면, 스케쥴링이 불가능할때 <em>unsubscribe</em> 하도록 만드는 것이다.</p>

<p><code>F</code> 가 <code>observer.onCompleted</code> 나 <code>observer.OnError</code> 를 호출한다면, <code>Magic</code> 함수에 의해 자동으로 <code>unsubscribe</code> 가 호출된다. 이로인해 다음에 호출되는 <code>onNext</code> 는 아무런 영향도 미치지 않게 된다.</p>

<p>이럴 수 있는 이유는 <code>Observable</code> 을 생성하는 방식이 <em>Rx Contract</em> 을 만족하기 때문이다. (따라서 직접 <code>Observable, Observer</code> 를 만들지 말고 팩토리 메소드를 사용해야한다)</p>

<pre><code class="scala">(onNext)*(onCompleted + onError)?
</code></pre>

<p><code>onNext</code> 는 여러번 호출될 수 있으나 겹치지 않고, <code>onCompleted</code> 나 <code>OnError</code> 는 옵션이지만 (무한한 시퀀스가 존재하기때문) 호출된다면 둘 중 단 한개만, 단 한번 호출되야한다는 것이다. 아까 본 코드를 다시 나열해서 어떻게 그렇게 되나 살펴보자.</p>

<pre><code class="scala">object Observable {  
  def apply() (implicit s: Scheduler): Observable[Unit] = {
    Observable(o =&gt; {
      s.schedule(self =&gt; {
        o.onNext(()); self
      })
    })
  }
}

def schedule(work: (=&gt; Unit) =&gt; Unit): Subscription = {  
  val subs = new MultipleAssignmentSubscription()

  schedule(scheduler =&gt; {
    def loop(): Unit = {
      subs.Subscription = scheduler.schedule {
        work { loop() }
      }
    }

    loop()
    subs
  })

  subs
}


implicit val s = Scheduler.NewThreadScheduler  
val ticks: Observable[Unit] = Observable()

ticks.subscribe(observer)  
</code></pre>

<p>여기서 <code>ticks.subscribe(observer)</code> 를 계속 풀면</p>

<pre><code class="scala">Observable({ o =&gt; scheduler.schedule {  
  self =&gt; o.onNext(()); self()
}}).subscribe(observer)

// unfold create
scheduler.schedule {  
  self =&gt; observer.onNext(()); self()
}

// unfold schedule
val m = new MultipleAssignmentSubscription()

schedule(scheduler =&gt; {  
  def loop(): Unit = {
    m.Subscription = scheduler.schedule {
      { self =&gt; observer.onNext(()); self() }({ loop() })
    }
  }

  loop()
  m
})

// `self` is a continuation
val m = new MultipleAssignmentSubscription()

schedule(scheduler =&gt; {  
  def loop(): Unit = {
    m.Subscription = scheduler.schedule {
      { observer.onNext(()); loop() }
    }
  }

  loop()
  m
})

// extract loop
val m = new MultipleAssignmentSubscription()

def loop(): Unit = {  
    m.Subscription = scheduler.schedule {
      { observer.onNext(()); loop() }
    }
}

schedule(scheduler =&gt; {  
  loop()
  m
})

// apply loop
schedule(scheduler =&gt; {  
  m.Subscription = scheduler.schedule {
      { observer.onNext(()); loop() }
  }

  m
})
</code></pre>

<p>즉 매 스케쥴링마다, <em>subscription</em> 을 갱신하고, 작업을 진행한뒤, 자기 자신을 다시 스케쥴링 한다.</p>

<h4 id="range">Range</h4>

<p>이렇게 응용할 수 있다.</p>

<pre><code class="scala">implicit val scheduler: Scheduler = Scheduler.NewThreadScheduler

def range(start, Int, count: Int):  
  (implicit s: Scheduler) Observable[Int] = {

  Observable(o =&gt; {
    var i = 0
    Observable().subscribe(u =&gt; {
      if (i &lt; count) { o.onNext(start + i); i += 1 }
      else { o.onCompleted() }
    })
  })
}

val xs = range(1, 10)  
    xs.subscribe(x =&gt; println(x))
    println("range out")
</code></pre>

<p>즉 <code>Observable()</code> 은 일종의 무한히 반복되는 스케쥴러고 여기에 액션을 추가해 원하는 작업을 해낼 수 있다. 그리고 작업이 완료되면 자동으로 <em>unsubscribe</em> 를 수행한다. 이제 무한히 긴 스트림을 <code>Observable</code> 로도 다룰 수 있게 되었다.</p>

<h3 id="references">References</h3>

<p>(1) <em>Reactive Programming</em> by <strong>Martin Ordersky</strong> <br />
(2) <a href='http://reactivex.io/'>http://reactivex.io/</a> <br />
(3) <a href="https://github.com/iirvine/principles-of-reactive-programming/blob/master/notes/week-4/002-basic-combinators-on-observable-collections.md">https://github.com/iirvine</a>  </p>
    </section>

    <footer>
      
      <section class="author_info margin_top_big">
        <div class="alignleft border rad_circle" style="height: 87px; width: 87px; background-image: url(http://www.gravatar.com/avatar/aa2032ba2302419e3c2ede54f1fbf687?d=404&amp;s=250); background-size: cover;"></div>
        <p class="margin_left_medium text small">Author</p>
        <p class="margin_left_medium text bold"><a href="http://language.is">1ambda</a></p>
        <p class="margin_left_medium text small">Lisp, Emacs, FP</p>
      </section>
      
    </footer>

    

    
    <div id="disqus_thread" class="margin_top_big"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = '1ambda'; // required: replace example with your forum shortname
  var disqus_identifier = '87';
  var disqus_url = 'http://1ambda.github.io/reactive-programming-4/';

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    </article>
</main>


  
  <script src="../assets/fitvids/jquery.fitvids.js"></script>
<script>
$(document).ready(function(){
  // Target your .container, .wrapper, .post, etc.
  $("section").fitVids();
});
</script>


  <footer class="blog_info margin_top_big padding_medium text center">
    <h5 class="text book small">&copy; 2015 <a href="..">Old Lisper</a>. All rights reserved.</h5>
    <h5 class="text book small"><a href="https://github.com/dreyacosta/velox" target="_blank" class="text bold">Velox theme</a> by <a href="http://dreyacosta.com/">David Rey</a></h5>
    <h5 class="text book small">Proudly published with <a href="http://ghost.org"><span>Ghost</span></a></h5>

  </footer>

  
  <script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = '1ambda'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function () {
 var s = document.createElement('script'); s.async = true;
 s.type = 'text/javascript';
 s.src = '//' + disqus_shortname + '.disqus.com/count.js';
 (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
 }());
</script>



  </body>
  </html>
