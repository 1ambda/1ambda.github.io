<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Old Lisper</title>
    <link>https://1ambda.github.io/index.xml</link>
    <description>Recent content on Old Lisper</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Sat, 06 Aug 2016 20:41:38 +0900</lastBuildDate>
    <atom:link href="https://1ambda.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Kubernetes: Intro</title>
      <link>https://1ambda.github.io/infrastructure/container/kubernetes-intro/</link>
      <pubDate>Sat, 06 Aug 2016 20:41:38 +0900</pubDate>
      
      <guid>https://1ambda.github.io/infrastructure/container/kubernetes-intro/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/infra-kubernetes/intro/logo.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;kubernetes-intro&#34;&gt;Kubernetes: Intro&lt;/h2&gt;

&lt;h3 id=&#34;caution&#34;&gt;Caution&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;작성자는 Container 전문가가 아니며 최대한 정확한 내용을 기록하려 했으나, 주말동안 짧게 찾아본 내용이므로 오류가 있을 수 있습니다. Production 적용을 위해서는, 더 많은 자료를 참고 부탁드립니다&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이하의 내용은 docker, docker-compose, docker-swarm 등에 대해 이해하고 있다는 가정 하에 쓰여졌습니다.
잘 모르신다면 &lt;a href=&#34;https://training.docker.com/self-paced-training&#34;&gt;Docker Self-Paced Online Learning&lt;/a&gt; 을 보고 오시면 더욱 쉽게 이해할 수 있습니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이 글에서는 kubernetes 의 구성요소, 인터널 등을 간략히 다룹니다. &lt;a href=&#34;http://autopilotpattern.io/&#34;&gt;Autopilot Pattern&lt;/a&gt; 등의 볼륨 매니지먼트 기술을 찾아 오셨다면, 아래의 글 참고 부탁드립니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.joyent.com/blog/persistent-storage-patterns&#34;&gt;Joyent: Persistent storage patterns for Docker in Production&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.joyent.com/blog/dbaas-simplicity-no-lock-in&#34;&gt;Joyent: MySQL on Autopilot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;kubernetes.io&#34;&gt;kubernetes&lt;/a&gt; (이하 k8s) 는 container orchestration 툴입니다.
(e.g &lt;a href=&#34;https://docs.docker.com/swarm/overview/&#34;&gt;docker-swarm&lt;/a&gt;,  &lt;a href=&#34;https://mesosphere.github.io/marathon/&#34;&gt;marathon&lt;/a&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;여러 host (&lt;a href=&#34;http://kubernetes.io/docs/admin/node/&#34;&gt;= node in k8s&lt;/a&gt;) 를 묶어 클러스터를 구성하고&lt;/li&gt;
&lt;li&gt;container 를 적절한 위치에 배포하고 (auto-placement)&lt;/li&gt;
&lt;li&gt;container 가 죽으면 자동으로 복구하며 (auto-restart)&lt;/li&gt;
&lt;li&gt;필요에 따라 container 를 매끄럽게 추가(scaling), 복제(replication), 업데이트(rolling update), 롤백(rollback) 할 수 있습니다&lt;/li&gt;
&lt;li&gt;이 외에도 수 많은 기능이 있으며, &lt;a href=&#34;http://kubernetes.io/docs/whatisk8s/&#34;&gt;What is k8s?&lt;/a&gt; 에서 확인할 수 있습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;k8s 를 사용하려면, 다음과 같은 내용을 알아야 합니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;k8s object (e.g &lt;a href=&#34;http://kubernetes.io/docs/user-guide/pods/&#34;&gt;pod&lt;/a&gt;, &lt;a href=&#34;http://kubernetes.io/docs/user-guide/petset/&#34;&gt;pet set&lt;/a&gt;, &lt;a href=&#34;http://kubernetes.io/docs/user-guide/services/&#34;&gt;service&lt;/a&gt;, &lt;a href=&#34;http://kubernetes.io/docs/user-guide/labels/&#34;&gt;selector&lt;/a&gt; 등)&lt;/li&gt;
&lt;li&gt;multi-host 위에서 container 실행시 고려해야 할 것들 (e.g service discovery, networking, volume management, log aggregation)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;k8s internal&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다행히도 문서가 장황하지 않습니다. 필요한 내용을, 필요한 만큼만 설명하고 있기 때문에 날 잡아서 쭈욱 읽기에도 괜찮습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;내용을 설명하기에 앞서 짧게나마 느낀점을 요약하면 다음과 같습니다&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;docker 1.12 기준으로 &lt;a href=&#34;https://blog.docker.com/2016/06/docker-1-12-built-in-orchestration/&#34;&gt;docker-swarm: built-in orchestration&lt;/a&gt; 이 대폭 개선되었음에도 불구하고, k8s 가 더 많은 기능과 자세한 세팅을 제공합니다.
실제 production 적용시에 다양한 요구사항이 생길 수 밖에 없기 때문에, k8s 의 다양한 기능은 큰 장점으로 보입니다&lt;/li&gt;
&lt;li&gt;GCE 를 쓰지 않아도 됩니다. github issue 를 살펴보다 보면 AWS 에서 사용하는 사람도 많은것 같습니다
(&lt;a href=&#34;http://kubernetes.io/docs/getting-started-guides/aws/&#34;&gt;running k8s on AWS&lt;/a&gt;)
일부 기능들 (e.g Service type LoadBalancer) 을 사용할 수 없으나, 세팅이 많은 만큼 우회가 가능하며
AWS 를 직접 지원하기도 합니다. (e.g AWSElasticBlockStore, SSL 등 &lt;del&gt;대인배&lt;/del&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/ingress/&#34;&gt;ingress&lt;/a&gt; 등의 기능과 Future Work 등을 보고 있노라면
정말 다양한 기능을 빠르게 추가하려고 노력한다는 느낌을 받습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지금 production 에 적용할거라면 swarm 보다는 k8s 에 베팅하고 올라 타겠습니다. (물론 &lt;a href=&#34;https://mesosphere.github.io/marathon/&#34;&gt;marathone&lt;/a&gt; 도 살펴보겠습니다만..)&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;GCE 가입하신 후 &lt;a href=&#34;http://kubernetes.io/docs/hellonode/&#34;&gt;Kubernetes: Hello World Walkthrough&lt;/a&gt; 를 진행하고 오시면 아래의 내용을 이해하시는데 더욱 도움이 됩니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/minikube/blob/master/README.md&#34;&gt;minikube&lt;/a&gt; 를 설치하면 로컬에서 k8s 를 실행해볼 수 있습니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kubectl 1.3.0+ 의 경우에는 bash 와 zsh completion 이 들어있습니다. 이걸 이용하면 편합니다. (&lt;code&gt;source &amp;lt;(kubectl completion zsh)
&lt;/code&gt;) gcloud 이용시 1.2.5 버전이 깔릴 수 있습니다. 버전이 낮을시 &lt;a href=&#34;http://kubernetes.io/docs/user-guide/prereqs/&#34;&gt;kubectl isntall&lt;/a&gt; 참고하시어 설치하면 됩니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl version

Client Version: version.Info{Major:&amp;quot;1&amp;quot;, Minor:&amp;quot;3&amp;quot;, GitVersion:&amp;quot;v1.3.0&amp;quot;, GitCommit:&amp;quot;283137936a498aed572ee22af6774b6fb6e9fd94&amp;quot;, GitTreeState:&amp;quot;clean&amp;quot;, BuildDate:&amp;quot;2016-07-01T19:26:38Z&amp;quot;, GoVersion:&amp;quot;go1.6.2&amp;quot;, Compiler:&amp;quot;gc&amp;quot;, Platform:&amp;quot;darwin/amd64&amp;quot;}

Server Version: version.Info{Major:&amp;quot;1&amp;quot;, Minor:&amp;quot;3&amp;quot;, GitVersion:&amp;quot;v1.3.3&amp;quot;, GitCommit:&amp;quot;c6411395e09da356c608896d3d9725acab821418&amp;quot;, GitTreeState:&amp;quot;dirty&amp;quot;, BuildDate:&amp;quot;1970-01-01T00:00:00Z&amp;quot;, GoVersion:&amp;quot;go1.6.2&amp;quot;, Compiler:&amp;quot;gc&amp;quot;, Platform:&amp;quot;linux/amd64&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;kubernetes-internal-abbreviated&#34;&gt;Kubernetes Internal (abbreviated)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://k8s.info/cs.html&#34;&gt;k8s.info: Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.3/docs/design/architecture.md&#34;&gt;k8s design docs: Architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시작 전에 간단히 구성 요소를 짚고 넘어가겠습니다. 아래의 설명 대신 위에 있는 링크를 읽고 오셔도 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/infra-kubernetes/intro/physical-layout.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;하나의 k8s 클러스터는 하나의 master 와 여러개의 node 로 구성되어 있습니다.
개발자는 kubectl 을 이용해서 master 에 명령을 내리고, node 를 관리합니다.
반면 사용자 (endpoint user) 는 node 에 접속해 서비스를 이용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/infra-kubernetes/intro/arc_k8s_simple.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;조금 더 자세히 보면,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;master 에는 작업을 위한 &lt;a href=&#34;http://kubernetes.io/docs/admin/kube-apiserver/&#34;&gt;api server&lt;/a&gt;,
state 를 관리하기 위한 분산 저장소 (default 로 &lt;a href=&#34;https://coreos.com/etcd/&#34;&gt;etcd&lt;/a&gt;),
&lt;a href=&#34;http://kubernetes.io/docs/admin/kube-scheduler/&#34;&gt;scheduler&lt;/a&gt;,
&lt;a href=&#34;http://kubernetes.io/docs/admin/kube-controller-manager/&#34;&gt;controller manager&lt;/a&gt; 등이 있습니다. (현재는 master 가 단일 노드이지만 추후 multi-node master 가 지원될 예정)&lt;/li&gt;
&lt;li&gt;node (= minion) 에는 master 와 통신하는 &lt;a href=&#34;http://kubernetes.io/docs/admin/kubelet/&#34;&gt;kubelet&lt;/a&gt; (agent, 현재는 containerized 되어있지 않음)이 있고,
외부의 요청을 처리하는 &lt;a href=&#34;http://kubernetes.io/docs/admin/kube-proxy/&#34;&gt;kube-proxy&lt;/a&gt;,
container 리소스 모니터링을 위한 &lt;a href=&#34;https://github.com/google/cadvisor&#34;&gt;cAdviser&lt;/a&gt; 등이 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 다시 큰 그림에서 보면, 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/infra-kubernetes/intro/arc_official.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;pod&#34;&gt;Pod&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/infra-kubernetes/intro/pods.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;하나 또는 여러개의 container 묶음을 &lt;a href=&#34;http://kubernetes.io/docs/user-guide/pods&#34;&gt;pod&lt;/a&gt; 이라 부릅니다.
docker 에서 container 끼리 통신하려면 같은 network 위에 있도록 구성해야 하는 반면 (compose 도 동일), 하나의 pod 내에 있는 contianer 끼리는 그럴 필요가 없습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;같은 IP 와 port space 를 가지기 때문에 &lt;code&gt;localhost&lt;/code&gt; 로 통신이 가능하며&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/volumes/&#34;&gt;volume&lt;/a&gt; 을 공유합니다
만약 어느 container 가 죽고 재시작되어도 pod 이 살아있는 한 shared volume 은 유지됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;In terms of Docker constructs, a pod is modelled as a group of Docker containers with shared namespaces and shared volumes. PID namespace sharing is not yet implemented in Docker.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;pod 의 종료, 삭제 관련해서는 &lt;a href=&#34;http://kubernetes.io/docs/user-guide/pods/#termination-of-pods&#34;&gt;Termination of Pods&lt;/a&gt; 를 참고하시면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;위에서 k8s 가 auto-restart 등을 해준다고 했었는데 테스트 해보겠습니다. 그 전에 먼저 클러스터가 정상적으로 세팅이 되었는지 확인해 보겠습니다. 저는 minikube 를 이용해서 로컬에서 실행했으므로 아래와 같은 결과가 나옵니다.
kubectl 을 여러 클러스터 중 하나에 붙어서 커맨드를 날릴 수 있도록 도와주는 docker-machine 정도로 이해하시면 됩니다. (단위가 다르지만)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl config view

apiVersion: v1
clusters:
- cluster:
    certificate-authority: /Users/1ambda/.minikube/ca.crt
    server: https://192.168.64.2:8443
  name: minikube
contexts:
- context:
    cluster: minikube
    user: minikube
  name: minikube
current-context: minikube
kind: Config
preferences: {}
users:
- name: minikube
  user:
    client-certificate: /Users/1ambda/.minikube/apiserver.crt
    client-key: /Users/1ambda/.minikube/apiserver.key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 아래와 같이 &lt;code&gt;nginx.yaml&lt;/code&gt; 을 만들겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ReplicationController
metadata:
  name: nginx
spec:
  replicas: 3
  selector:
    app: nginx
  template:
    metadata:
      name: nginx
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 실행하면,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f nginx.yaml
replicationcontroller &amp;quot;nginx&amp;quot; created

$ kubectl get replicationcontroller nginx
NAME      DESIRED   CURRENT   AGE
nginx     3         3         41s

$ kubectl get pods
NAME          READY     STATUS    RESTARTS   AGE
nginx-5aa7m   1/1       Running   0          45s
nginx-5frtc   1/1       Running   0          45s
nginx-sg1s5   1/1       Running   0          45s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pod 하나를 죽여보겠습니다. 재생성되는걸 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl delete pod nginx-5aa7m
pod &amp;quot;nginx-5aa7m&amp;quot; deleted

$ kubectl get pods
NAME          READY     STATUS              RESTARTS   AGE
nginx-5frtc   1/1       Running             0          1m
nginx-6tub7   0/1       ContainerCreating   0          1s
nginx-sg1s5   1/1       Running             0          1m


$ kubectl get pods
NAME          READY     STATUS    RESTARTS   AGE
nginx-5frtc   1/1       Running   0          1m
nginx-6tub7   1/1       Running   0          5s
nginx-sg1s5   1/1       Running   0          1m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;service&#34;&gt;Service&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/infra-kubernetes/intro/abstraction.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;pod 은 생성/삭제 될 수 있습니다. &lt;a href=&#34;http://kubernetes.io/docs/user-guide/replication-controller/&#34;&gt;replication-controller&lt;/a&gt; 를 이용하면 심지어 동적으로도 scale up/down 이 가능한데,
이럴 경우 IP 가 변경/추가/제거 되므로, k8s 는 external &amp;lt;-&amp;gt; pods 이나 pods &amp;lt;-&amp;gt; pods 간의 안정적인 통신을 위해 &lt;a href=&#34;http://kubernetes.io/docs/user-guide/services/&#34;&gt;service&lt;/a&gt; 라는 object 를 도입했습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Services provide a single, stable name and address for a set of pods. They act as basic load balancers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 그림을 잘 보면, pod 에 있는 &lt;a href=&#34;http://kubernetes.io/docs/user-guide/labels/&#34;&gt;label&lt;/a&gt; 과 동일한 컬러의 것이 service 에도 있고,
해당 service 가 같은 label 컬러를 가진 pod 을 위한 것임을 쉽게 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;위에서 생성한 nginx pods 를 위한 service 를 &lt;code&gt;nginx-svc.yaml&lt;/code&gt; 이란 이름으로 만들어 보겠습니다. &lt;code&gt;selector&lt;/code&gt; 를 잘 보세요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Service
metadata:
  name: nginx-svc
spec:
  ports:
    - name: nginx-svc
      port: 8090
      targetPort: 80
  type: NodePort
  selector:
    app: nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 생성하면,  &lt;code&gt;nginx-svc&lt;/code&gt; service 의 EXTERNAL-IP 가 &lt;code&gt;&amp;lt;nodes&amp;gt;&lt;/code&gt; 로 보입니다.
전체 node 에 대해서 외부 포트를 열어서 그런데,
&lt;a href=&#34;http://kubernetes.io/docs/user-guide/services/#type-nodeport&#34;&gt;NodePort&lt;/a&gt;
대신 &lt;a href=&#34;type-loadbalancer&#34;&gt;LoadBalancer&lt;/a&gt; (cloud provider 가 지원할 경우만 사용가능) 타입을 이용하거나 &lt;a href=&#34;http://kubernetes.io/docs/user-guide/ingress/&#34;&gt;ingress&lt;/a&gt; 를 이용할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As of Kubernetes v1.0, Services are a “layer 3” (TCP/UDP over IP) construct. In Kubernetes v1.1 the Ingress API was added (beta) to represent “layer 7” (HTTP) services.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f nginx-svc.yaml
service &amp;quot;nginx-svc&amp;quot; created

$ kubtctl get service
NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
kubernetes   10.0.0.1     &amp;lt;none&amp;gt;        443/TCP    3d
nginx-svc    10.0.0.196   &amp;lt;nodes&amp;gt;       8090/TCP   1m

$ kubectl describe service nginx-svc
  ...
  Endpoints:              172.17.0.3:80,172.17.0.4:80,172.17.0.5:80
  
$ kubectl get node
NAME          STATUS    AGE
boot2docker   Ready     3d

$ kubectl describe node boot2docker | grep Address
Addresses:              192.168.64.2,192.168.64.2

$ curl 192.168.64.2:31968

 &amp;lt;!DOCTYPE html&amp;gt;
 &amp;lt;html&amp;gt;
 &amp;lt;head&amp;gt;
 &amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;192.168.64.2:31968&lt;/strong&gt; 을 접근해보면, nginx 가 떠있음을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;pod 이 생성될때 active service 에 대해서 kubelet 이 service 의 IP, port 와 관련된 환경변수를 pod 에 주입합니다. (service 가 먼저 생성되어 있어야 함)
예를 들어 service name 이 &lt;code&gt;redis-master&lt;/code&gt; 라면 다음과 같은 값들이 주입됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;REDIS_MASTER_SERVICE_HOST=10.0.0.11
REDIS_MASTER_SERVICE_PORT=6379
REDIS_MASTER_PORT=tcp://10.0.0.11:6379
REDIS_MASTER_PORT_6379_TCP=tcp://10.0.0.11:6379
REDIS_MASTER_PORT_6379_TCP_PROTO=tcp
REDIS_MASTER_PORT_6379_TCP_PORT=6379
REDIS_MASTER_PORT_6379_TCP_ADDR=10.0.0.11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하여 pod 간 통신에는 env variable 을 이용할 수 있으나, &lt;a href=&#34;http://kubernetes.io/docs/user-guide/services/#dns&#34;&gt;DNS&lt;/a&gt; 를 이용하는 것이 더 권장됩니다.&lt;/p&gt;

&lt;p&gt;추가적으로, label 값은 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/tree/master/examples/guestbook&#34;&gt;kubernetes/example/guestbook&lt;/a&gt; 처럼 붙이는 것이 권장됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: redis-master
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: redis
        role: master
        tier: backend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;deployment&#34;&gt;Deployment&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/deployments/&#34;&gt;deployment&lt;/a&gt; 는 &lt;a href=&#34;http://kubernetes.io/docs/hellonode/&#34;&gt;Kubernetes: Hello World Walkthrough&lt;/a&gt; 를 진행하셨다면 감이 오셨을수도 있겠습니다.
rolling update, rollback 등을 지원하는 pod, replica set 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 &lt;code&gt;nginx-deployment.yaml&lt;/code&gt; 을 만들고, 배포하면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl delete replicationcontroller nginx
$ kubectl get pod

$ kubectl create -f nginx-deployment.yaml
deployment &amp;quot;nginx-deployment&amp;quot; created

$ kubectl get deployment
NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3         3         3            3           8h

$ kubectl get rs
NAME                          DESIRED   CURRENT   AGE
nginx-deployment-1159050644   3         3         8h

$ kubectl get pods
NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1159050644-1bhfw   1/1       Running   0          8h
nginx-deployment-1159050644-hxaxs   1/1       Running   0          8h
nginx-deployment-1159050644-zc5tc   1/1       Running   0          8h

$ kubectl rollout status deployment/nginx-deployment
  deployment nginx-deployment successfully rolled out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;정상적으로 배포되었는지는 &lt;strong&gt;rollout status&lt;/strong&gt; 커맨드를 이용해서 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 container 의 nginx 버전을 올려보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1
deployment &amp;quot;nginx-deployment&amp;quot; image updated

$ # also, we can use `edit` 
$ # kubectl edit deployment/nginx-deployment

$ kubectl rollout status deployment/nginx-deployment
deployment nginx-deployment successfully rolled out

$ kubectl get deployment
NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3         3         3            3           9h

$ kubectl get rs
NAME                          DESIRED   CURRENT   AGE
nginx-deployment-1159050644   0         0         8h
nginx-deployment-671724942    3         3         1m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;모든 pod 을 한번에 생성하고, 한번에 오래된 pod 을 죽이는 방식으로 일어나는 것이 아니라 rolling update 처럼 하나하나씩 진행됩니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Deployment can ensure that only a certain number of Pods may be down while they are being updated. By default, it ensures that at least 1 less than the desired number of Pods are up (1 max unavailable).&lt;/p&gt;

&lt;p&gt;Deployment can also ensure that only a certain number of Pods may be created above the desired number of Pods. By default, it ensures that at most 1 more than the desired number of Pods are up (1 max surge).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get pods
NAME                               READY     STATUS    RESTARTS   AGE
nginx-deployment-671724942-1hytl   1/1       Running   0          41s
nginx-deployment-671724942-7a0f1   1/1       Running   0          41s
nginx-deployment-671724942-jzgm0   1/1       Running   0          40s

$ kubectl describe deployments
Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Sun, 07 Aug 2016 00:48:18 +0900
Labels:                 app=nginx
Selector:               app=nginx
Replicas:               3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  1 max unavailable, 1 max surge
OldReplicaSets:         &amp;lt;none&amp;gt;
NewReplicaSet:          nginx-deployment-671724942 (3/3 replicas created)
Events:
  FirstSeen     LastSeen        Count   From                            SubobjectPath   Type        Reason                   Message
  ---------     --------        -----   ----                            -------------   --------    ------                   -------
  51s           51s             1       {deployment-controller }                        Normal      ScalingReplicaSet        Scaled up replica set nginx-deployment-671724942 to 1
  51s           51s             1       {deployment-controller }                        Normal      ScalingReplicaSet        Scaled down replica set nginx-deployment-1159050644 to 2
  51s           51s             1       {deployment-controller }                        Normal      ScalingReplicaSet        Scaled up replica set nginx-deployment-671724942 to 2
  50s           50s             1       {deployment-controller }                        Normal      ScalingReplicaSet        Scaled down replica set nginx-deployment-1159050644 to 1
  50s           50s             1       {deployment-controller }                        Normal      ScalingReplicaSet        Scaled up replica set nginx-deployment-671724942 to 3
  50s           50s             1       {deployment-controller }                        Normal      ScalingReplicaSet        Scaled down replica set nginx-deployment-1159050644 to 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보면 replica set 은 2개지만 &lt;code&gt;nginx-deployment-1159050644&lt;/code&gt; 은 업데이트 전 버전인 1.7.9 pod 이 하나도 없고 (&lt;strong&gt;desired = 0&lt;/strong&gt;), &lt;code&gt;nginx-deployment-671724942&lt;/code&gt; 만 3 개의 pod 을 가지고 있습니다.
이전 replica set 을 유지하는 이유는 rollback 을 위해서 인데요&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl rollout history deployment/nginx-deployment
deployments &amp;quot;nginx-deployment&amp;quot;:
REVISION        CHANGE-CAUSE
1               &amp;lt;none&amp;gt;
2               &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;CHANGE-CAUSE&lt;/code&gt; 가 &lt;strong&gt;none&lt;/strong&gt; 인 이유는 deployment 커맨드 이용해 &lt;strong&gt;--record&lt;/strong&gt; 를 사용하지 않아서 그렇습니다. revision 값을 지정해 살펴보면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl rollout history deployment/nginx-deployment --revision=1
deployments &amp;quot;nginx-deployment&amp;quot; revision 1
  Labels:       app=nginx
        pod-template-hash=1159050644
  Containers:
   nginx:
    Image:      nginx:1.7.9
    Port:       80/TCP
    Environment Variables:      &amp;lt;none&amp;gt;
  No volumes.
  
$ kubectl rollout history deployment/nginx-deployment --revision=2
deployments &amp;quot;nginx-deployment&amp;quot; revision 2
  Labels:       app=nginx
        pod-template-hash=671724942
  Containers:
   nginx:
    Image:      nginx:1.9.1
    Port:       80/TCP
    Environment Variables:      &amp;lt;none&amp;gt;
  No volumes.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 rollback 해 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl rollout undo deployment/nginx-deployment --to-revision=1
deployment &amp;quot;nginx-deployment&amp;quot; rolled back

$ kb get pods
NAME                                READY     STATUS              RESTARTS   AGE
nginx-deployment-1159050644-mg5e9   1/1       Running             0          2s
nginx-deployment-1159050644-vsoaw   1/1       Running             0          2s
nginx-deployment-1159050644-x0319   0/1       ContainerCreating   0          1s
nginx-deployment-671724942-1hytl    1/1       Terminating         0          23m

$ kb get deployment
NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3         3         3            3           9h

$ kb get rs
NAME                          DESIRED   CURRENT   AGE
nginx-deployment-1159050644   3         3         9h
nginx-deployment-671724942    0         0         24m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이전 pod 이 죽고, 새로운 pod 이 생성되는 과정을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;pet-set&#34;&gt;Pet Set&lt;/h3&gt;

&lt;p&gt;stateless application 의 경우에는 기존의 pod, replica set 등을 이용해 쉽게 배포하고 확장할 수 있었지만,
 cluster 로 동작하는 경우에는 각 instance 간 networking 을 위해 reliable name (e.g index based, advertised hostname) 등의 기능이 필요했습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/petset/&#34;&gt;pet set&lt;/a&gt; 은 stateful (e.g clustering) applications 의 지원을 위해 1.3 버전에서 alpha 기능으로 추가되었습니다. (see &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG.md#v130&#34;&gt;CHANGELOG#1.3&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.kubernetes.io/2016/07/thousand-instances-of-cassandra-using-kubernetes-pet-set.html&#34;&gt;1000 Instances of Cassandra using Kubernetes Pet Set&lt;/a&gt; 에서는 alpha 기능인 pet set 을 이용해 1000 개의 카산드라 인스턴스를 배포하고 sample job 을 돌린 경험을 공유하고 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We deployed 1,000 pets. Technically with the Cassandra setup, &lt;strong&gt;we could have lost 333 nodes without service or data loss&lt;/strong&gt;.&lt;br /&gt;
&lt;strong&gt;8,072 Cores&lt;/strong&gt;. The master used 24, minion nodes used the rest&lt;br /&gt;
&lt;strong&gt;100,510 GB&lt;/strong&gt; persistent disk used by the Minions and the Master&lt;br /&gt;
&lt;strong&gt;380,020 GB SSD&lt;/strong&gt; disk persistent disk. 20 GB for the master and 340 GB per Cassandra Pet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;팀 내에서 20+ broker 로 kafka cluster 를 운영하고 있는데다가 container 기반 기술에 관심이 많아 적용을 해보고 싶긴 한데,
아직 레퍼런스가 없어 안타깝습니다. github issue 를 보면 example 을 만들기 위해 논의는 진행중인것 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/issues/5017&#34;&gt;kubernetes #5017: Example: Kafka/Zookeeper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/32140025/kafka-on-kubernetes-multi-node&#34;&gt;SO: Kafka on k8s multi node&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.defuze.org/archives/351-running-a-zookeeper-and-kafka-cluster-with-kubernetes-on-aws.html&#34;&gt;Running a ZK and kafka clusters on k8s&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CloudTrackInc/kubernetes-kafka/issues&#34;&gt;Github: kubernetes-kafka&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/contrib/tree/master/pets&#34;&gt;Github: kubernetes-contrib/pets&lt;/a&gt; 를 보시면 pet set 을 이용해 cluster 를 구성하는 샘플이 몇개 있습니다.
현재까지는 mysql, redis, ZK 정도가 있네요. &lt;a href=&#34;https://github.com/kubernetes/kubernetes/tree/master/examples&#34;&gt;Github: kubernetes/examples&lt;/a&gt; 도 다양한 샘플이 있으므로 한번 쭈욱 둘러보시면 도움이 될듯 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;other-objects&#34;&gt;Other Objects&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/volumes/&#34;&gt;Volume&lt;/a&gt;, &lt;a href=&#34;http://kubernetes.io/docs/user-guide/persistent-volumes/&#34;&gt;Persistent Volume&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위에서는 pod 과 volume 의 life cycle 이 동일하다고 했지만, 사실 꼭 그렇지는 않습니다. 다양한 type 의 volume 이 지원되기 때문인데요,
&lt;code&gt;emptyDir&lt;/code&gt; 이외의 volume type 을 이용하면 pod 이 죽더라도, 데이터를 유지할 수 있습니다. (e.g &lt;a href=&#34;http://kubernetes.io/docs/user-guide/volumes/#gcepersistentdisk&#34;&gt;gcePersistentDisk&lt;/a&gt;, &lt;a href=&#34;https://clusterhq.com/flocker/introduction/&#34;&gt;flocker&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;persistent volume (PV) 는 일종의 networked storage 로 pod lifecycle 을 벗어나 존재할수 있으면서도, 사용자가 리소스의 양을 특정지어 요청할 수 있는 volume 입니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Managing storage is a distinct problem from managing compute. The PersistentVolume subsystem provides an API for users and administrators that abstracts details of how storage is provided from how it is consumed&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kubernetes.io/docs/admin/daemons/&#34;&gt;Daemon Set&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;daemon set 은 node 마다 추가되야 하는 프로세스가 있을때 사용할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;running a cluster storage daemon, such as &lt;strong&gt;glusterd&lt;/strong&gt;, &lt;strong&gt;ceph&lt;/strong&gt;, on each node&lt;br /&gt;
running a logs collection daemon on every node, such as &lt;strong&gt;fluentd&lt;/strong&gt; or &lt;strong&gt;logstash&lt;/strong&gt;&lt;br /&gt;
&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kubernetes.io/docs/user-guide/jobs/&#34;&gt;Job&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배치 작업처럼, 실행후 종료되는 Job 을 의미합니다.&lt;/p&gt;

&lt;p&gt;기타 오브젝트는 &lt;a href=&#34;http://kubernetes.io/docs/reference/&#34;&gt;Reference&lt;/a&gt; 의 &lt;a href=&#34;http://kubernetes.io/docs/user-guide/annotations/&#34;&gt;Glossary&lt;/a&gt; 를 참조하시면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;etc&#34;&gt;Etc&lt;/h3&gt;

&lt;p&gt;A. Log Aggregation 은 아래의 내용을 참고하실 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://kubernetes.io/docs/getting-started-guides/logging/&#34;&gt;http://kubernetes.io/docs/getting-started-guides/logging/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/issues/1071&#34;&gt;https://github.com/kubernetes/kubernetes/issues/1071&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/issues/24677&#34;&gt;https://github.com/kubernetes/kubernetes/issues/24677&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;B. k8s cluster 간 연결은 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/docs/proposals/federation.md&#34;&gt;k8s cluster federation&lt;/a&gt; 이라 불립니다.&lt;/p&gt;

&lt;p&gt;C. k8s production 적용을 위한 &lt;a href=&#34;http://kubernetes.io/docs/user-guide/production-pods/#liveness-and-readiness-probes-aka-health-checks&#34;&gt;guide&lt;/a&gt; 도 있습니다.&lt;/p&gt;

&lt;p&gt;D. 이런 저런 CI 를 테스팅 해봤는데 &lt;a href=&#34;circleci.com&#34;&gt;Circle CI&lt;/a&gt; 가 썩 괜찮습니다.
싼 가격에, 연동 잘되고 기능 많습니다. 아래와 같이 build (scala) 세팅하면 &lt;a href=&#34;https://cloud.google.com/container-registry/&#34;&gt;google container registry&lt;/a&gt; 에 push 하고
gcloud 커맨드 까지 직접 내릴 수 있으니, develop branch 정도라면 k8s &lt;a href=&#34;kubernetes.io/docs/user-guide/deployments/&#34;&gt;deployment&lt;/a&gt; 이용해서 바로 롤링 업그레이드 가능합니다. (만약 SBT 가 느리다면 &lt;a href=&#34;https://github.com/alexarchambault/coursier&#34;&gt;courseir&lt;/a&gt; 나 circle CI build cache 등을 이용해보세요.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;machine:
  environment:
    SBT_VERSION: 0.13.8
    SBT_OPTS: &amp;quot;-Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled
-XX:MaxPermSize=256M&amp;quot;
    PROJECT_NAME: dmm-common
  services:
    - docker
  java:
    version: oraclejdk8

dependencies:
  cache_directories:
    - &amp;quot;~/.sbt&amp;quot;
  pre:
    # install SBT
    - wget --output-document=$HOME/bin/sbt-launch.jar
      https://repo.typesafe.com/typesafe/ivy-releases/org.scala-sbt/sbt-launch/&amp;quot;$SBT_VERSION&amp;quot;/sbt-launch.jar
    - echo &amp;quot;java $SBT_OPTS -jar \`dirname \$0\`/sbt-launch.jar \&amp;quot;\$@\&amp;quot;&amp;quot; &amp;gt; $HOME/bin/sbt
    - chmod u+x $HOME/bin/sbt

    # install gcloud SDK, kubectl
    - sudo /opt/google-cloud-sdk/bin/gcloud --quiet components update
    - sudo /opt/google-cloud-sdk/bin/gcloud --quiet components update kubectl

  override:
    - sbt sbt-version

test:
  override:
    - sbt test
    - sbt docker

deployment:
  development:
    branch: /feature.*/
    commands:
      - echo $GCE_KEY &amp;gt; gcloud-key.json
      - gcloud auth activate-service-account --key-file gcloud-key.json
      - docker tag 1ambda/sample gcr.io/1ambda/sample:$CIRCLE_SHA1
      - gcloud docker push gcr.io/1ambda/sample:$CIRCLE_SHA1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://devops.com/2015/11/09/9-more-open-source-devops-tools-we-love/&#34;&gt;Title Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://kubernetes.io/docs/whatisk8s/&#34;&gt;What is k8s?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://k8s.info/cs.html&#34;&gt;k8s.info&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/33970251/how-to-expose-a-kubernetes-service-externally-using-nodeport&#34;&gt;SO: How to expose a Kubernetes service externally using NodePort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nshani.blogspot.kr/2016/02/getting-started-with-kubernetes.html&#34;&gt;k8s pod image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/erialc_w/kubernetes-50626679&#34;&gt;k8s architecture slide1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/imesh/apache-stratos-410-architecture&#34;&gt;k8s architecture slide2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.kubernetes.io/2016/07/thousand-instances-of-cassandra-using-kubernetes-pet-set.html&#34;&gt;1000 Instances of Cassandra using Kubernetes Pet Set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.3/docs/design/architecture.md&#34;&gt;k8s design docs: Architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang Tutorial</title>
      <link>https://1ambda.github.io/golang/golang-tutorial/</link>
      <pubDate>Fri, 16 Dec 2016 00:06:04 +0900</pubDate>
      
      <guid>https://1ambda.github.io/golang/golang-tutorial/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://github.com/1ambda/1ambda.github.io/raw/master/assets/images/golang/golang-tutorial.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;gopath-를-처음-여행하는-gopher-들을-위한-golang-안내서&#34;&gt;GOPATH 를 처음 여행하는 GOPHER 들을 위한 GOLANG 안내서&lt;/h2&gt;

&lt;p&gt;2016년은 다사다난한 해였던것 같습니다. 개인적으로도, 사회적으로도 말입니다 :) JVM 위에서만 놀던 제가 Golang (이하 Go) 을 배운것을 보면요. 이 글에서는 1달 남짓한 기간동안 Go 를 배우며 들었던 느낌들을 튜토리얼 형태로 적어보았습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;사실 Go 를 처음 봤을땐 그다지 탐탁치 않았습니다. 많은 이들이 말하듯 낡은 C 언어를 현대적으로 포장된 했다는 느낌을 많이 받아서 내게 필요할까 의문이 들기도 했었구요. 구체적으로는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Generic 이 지원되지 않으며&lt;/li&gt;
&lt;li&gt;아키텍처마다 별도의 컴파일이 필요하고&lt;/li&gt;
&lt;li&gt;npm 등과 비교하면 쓸만한 의존성 관리 툴도 없고 (당시에는)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$GOPATH&lt;/code&gt; 아래 코드를 위치하도록 하는 이상한 강제사항도 있을뿐만 아니라&lt;/li&gt;
&lt;li&gt;세련되지 않은 문법과&lt;/li&gt;
&lt;li&gt;다른 함수형 언어와 비교했을때 언어학적으로 흥미로울것 없는 언어처럼 보였습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go 는 필요 없다고까지 느꼈던 제가 Tutorial 을 따라 읽고, 컨퍼런스 영상까지 찾아보며 새로운 언어를 배운 이유는 팀을 옮기며 맡게된 업무에서 기존에 사용하던 언어 (Java, Scala) 의 한계를 절실히 느꼈기 때문입니다. JVM 위에서 돌아가는 대규모 오픈소스 프로젝트에서는 다음과 같은 문제들이 종종 발생하곤 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;problem-1-너무나-느린-빌드&#34;&gt;Problem 1: 너무나 느린 빌드&lt;/h3&gt;

&lt;p&gt;모든 작업에 앞서서 제가 가장 먼저 하는 일은 “빠른 피드백 루프를 갖추기” 입니다. 테스트를 작성하거나, 기능을 변경하거나 심지어 버그가 발생해 가설을 세우는 상황에서도 피드백 루프가 간단하다면 몇 번이고 실험하는데 부담이 없습니다. 이것이 우리가 복잡한 로직에서 println 를 수십번 적는 대신 debug 버튼을 클릭하는 이유입니다.&lt;/p&gt;

&lt;p&gt;그런데, 빌드가 느리면 답이 없습니다. 단위 테스트야 IDEA 에서 실행한다고 해도 PR 이 머지되려면 CI 에서 돌아가는 통합 테스트는 물론이고 라이센스 검증 등 수 많은 단계를 거쳐야 합니다. 빌드가 느리면 이 모든 과정이 느려지고, CI 큐가 꽉차고 피드백을 위해 더 많이 기다려야 하고, 머지가 느려지고, 이 PR 을 기다리는 다른 PR 에 영향을 주고, 전체적인 개발 속도가 느려집니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&amp;ldquo;우리는 만드는 방법을 혁신하지 않고서는, 제품을 혁신할 수 없습니다.”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;problem-2-복잡해질-수-있는-다양한-문법적-기능&#34;&gt;Problem 2: 복잡해질 수 있는 다양한 문법적 기능&lt;/h3&gt;

&lt;p&gt;자유도가 높은 문법은 같은 일을 하는 다양한 스타일의 코드를 만듭니다. Scala 에는 심지어 &lt;a href=&#34;http://www.lihaoyi.com/post/StrategicScalaStylePrincipleofLeastPower.html&#34;&gt;Principle Of Least Power&lt;/a&gt; 라는 가이드 마저 있습니다. 결국 많은 기능을 가진 언어로 작성된 PR을 리뷰한다는 것은 읽어야 할 것이 많고 시간이 부족한 리뷰어에게 큰 부담이 됩니다. 또한 컨트리뷰터는 코드를 작성하고 떠날 수 있지만, 그가 작성한 코드는 남아 유지보수의 대상이 됩니다.&lt;/p&gt;

&lt;p&gt;바꾸어 말하면, 누가 봐도 어떤 일을 하는 코드인지 쉽게 알 수 있고, 변경과 수정이 용이한 idiomatic 한 코드를 누구나 작성할 수 있는 언어가 필요합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When reading code, it should be clear what the program will do.&lt;br /&gt;
When writing code, it should be clear how to make the program do what you want.
by Rob Pike in &lt;a href=&#34;https://www.youtube.com/watch?v=rFejpH_tAHM&#34;&gt;&lt;em&gt;Simplicity is Complicated&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Error 는 Go 의 철학을 보여주는 한 예입니다. Go 에서는 Exception 이 없습니다. Exception 은 만들어진 장소에서 처리되지 않는다면 GOTO 문과 같아 코드를 읽기 어렵게 만듭니다. 대신, Go 는 Error 를 값으로 취급해 항상 리턴하도록 하여 코드가 어떤 예외 처리를 하는지 알기 쉽게 만듭니다. 사실 Exception 을 즉시 처리되어야 하는 것으로 본다면, 다른 곳에서 처리되야 할 이유가 없습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;… exceptional code is hopelessly serial. There is only one exception in flight, how quaint is that? There can be only one exception at any moment in flight. … [they] require immediate an exclusive attention. [The exception] comes to the fore, you must handle it right now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;동일한 스타일의 코드를 강제하기 위해서, 우리는 많은 오픈소스에서 lint tool (e.g &lt;a href=&#34;https://github.com/checkstyle/checkstyle&#34;&gt;checkstyle&lt;/a&gt;) 등을 사용하는 것을 보아 왔습니다. 그러나 이것은 validation 일뿐 reformatting 이 아닙니다. 수정하려면 사람의 노력이 필요합니다. reformatting 을 위한 &lt;a href=&#34;https://github.com/olafurpg/scalafmt&#34;&gt;scalafmt&lt;/a&gt; 이나 &lt;a href=&#34;https://github.com/google/google-java-format&#34;&gt;google-java-format&lt;/a&gt; 툴들은 많은 문법을 지원해야 하기 때문에 성숙도가 떨어집니다. 이 툴들을 이용해 수정된 코드를 보고 있노라면 Idiomatic 하다고 말하긴 어렵습니다.&lt;/p&gt;

&lt;p&gt;Java 는 50개 정도의 키워드를 가지고 있고 Scala 는 그것보다는 좀 더 많습니다. 반면 Go 는 25개의 키워드로만 구성되어 있습니다. 문법이 간단하므로 idiomatic 한 코드를 작성하기 쉽고, 완성도 높은 gofmt 를 만들 수 있습니다. 우스갯소리로, 어느 누구도 gofmt 의 스타일을 좋아하지 않는다는 이야기도 있지만, 적어도 통일성 있는 스타일링을 사람의 도움 없이 기계적으로 수행할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Gofmt&amp;rsquo;s style is no one&amp;rsquo;s favorite, yet gofmt is everyone&amp;rsquo;s favourite.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Java 와 Scala 는 훌륭한 언어입니다. 많은 사람들이 즐겨 사용하는 Spring, Play, Akka 와 같은 좋은 프레임워크를 가지고 있고, 안정적입니다. 그 외에도 수 많은 장점이 있습니다만, 이 두 부분에서 미흡합니다. 솔직히 말하자면, 저는 2016 년에도 이런 상황에서 개발해야 된다는 사실이 믿기지 않습니다. 더 놀라운 사실은, 각 언어들은 현란한 기능을 추가하고 자신을 뽐내는것에만 바쁘지 우리가 매일 매일 겪는 진짜 문제를 해결하지 하려 않는다는 것입니다. 이런것들은 결국 커뮤니티가 해결해야 될 숙제로 남습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Leading edge language features don&amp;rsquo;t usually address what you really want. Golang is designed for large applications, large teams and large dependencies.
By Rob Pike &lt;a href=&#34;https://talks.golang.org/2012/splash.article&#34;&gt;&lt;em&gt;Go at Google&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;다른-언어를-여행하다-온-프로그래머를-위한-golang-가이드&#34;&gt;다른 언어를 여행하다 온 프로그래머를 위한 Golang 가이드&lt;/h3&gt;

&lt;p&gt;언어를 배우는 데에는 다양한 방법이 있습니다. 저는 주로 간단한 튜토리얼을 읽은 후 언어의 철학과 디자인을 살펴보고 충분한 동기를 얻은 후에야 다른 기능들을 살펴보곤 합니다. 다행히도, Go 블로그, Go 언어 홈페이지에는 Google Go 팀이 작성한 읽을거리들이 많습니다. 그 중에서 꼭 봐야 할 몇 가지를 소개합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(Quick Tutorial) &lt;a href=&#34;https://talks.golang.org/2014/taste.slide#40&#34;&gt;A Taste of Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(Quick Tutorial) &lt;a href=&#34;https://github.com/a8m/go-lang-cheat-sheet&#34;&gt;Golang Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(Design) &lt;a href=&#34;https://www.youtube.com/watch?v=rFejpH_tAHM&#34;&gt;Simplicity is Complicated&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(Design) &lt;a href=&#34;https://golang.org/doc/faq#Design&#34;&gt;Golang FAQ: Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(Design) &lt;a href=&#34;(https://go-proverbs.github.io/)&#34;&gt;Go Proverb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(Design) &lt;a href=&#34;https://talks.golang.org/2012/splash.article&#34;&gt;Go at Google&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;언어의 문법이 눈에 익고 문법 설계의 이유를 알고 나면 자신이 사용했던 언어와의 차이점을 묻게 됩니다. Go 언어 초보자로서 제가 가장 먼저 궁금했던 내용은 Struct, Interface, Concurrency, Error Handling 와 관련된 것들이었습니다. 좋은 아티클들이 많기 때문에 링크를 걸도록 하고 설명은 제가 특이하게 느낀 점들만 간단히 적도록 하겠습니다.&lt;/p&gt;

&lt;h4 id=&#34;go-struct&#34;&gt;Go: Struct&lt;/h4&gt;

&lt;p&gt;Go 언어에는 멤버 변수를 가진 &lt;code&gt;Struct&lt;/code&gt; 는 있지만 멤버 함수까지 포함한 Class 는 없습니다. 대신 &lt;code&gt;Struct&lt;/code&gt; 의 멤버 함수처럼 쓰일 수 있는 &lt;a href=&#34;https://tour.golang.org/methods/1&#34;&gt;Method&lt;/a&gt; 나 &lt;a href=&#34;https://tour.golang.org/methods/4&#34;&gt;Pointer Recevier&lt;/a&gt; 가 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Vertex struct {
     X, Y float64
}

func (v Vertex) Abs() float64 {
     return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func (v *Vertex) Scale(f float64) {
     v.X = v.X * f
     v.Y = v.Y * f
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또한 Inheritance 를 위한 직접적인 키워드가 없습니다. &lt;a href=&#34;https://golang.org/doc/effective_go.html#embedding&#34;&gt;Embedding&lt;/a&gt; 을 이용할 수 있습니다. 예를 들어 아래 코드에서는  &lt;code&gt;Job&lt;/code&gt; 내에서 &lt;code&gt;log.Logger&lt;/code&gt; 의 메소드를 호출하는 것을 볼 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Job struct {
    Command string
    *log.Logger
}

job.Log(“…”)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;If C++ and Java are about type hierarchies and the taxonomy of types, &lt;strong&gt;Go is about composition&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이런 문법들을 보고 있노라면, Go 에서는 해당 Data (&lt;code&gt;Struct&lt;/code&gt;) 가 와 Action (&lt;code&gt;Method&lt;/code&gt;) 은 별개인 것 처럼 느껴집니다. 메소드의 정의도 Java 의 클래스와 달리 외부에 하기때문인데요, 마치 Scala 의 case class 를 값으로 이용하고 함수는 companion object 에만 정의하는 것과 비슷합니다. 그리고 상속대신 합성을 이용하는 부분은 더 유연해 보이기도 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dave.cheney.net/2014/03/25/the-empty-struct&#34;&gt;The empty struct&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://thenewstack.io/understanding-golang-type-system/&#34;&gt;Understanding Golang Type System&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;go-interface&#34;&gt;Go: Interface&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Q. Hey gophers, what was the best/worst moment of your experienes lenaring golang?&lt;br /&gt;
&lt;strong&gt;A. The worst was interface, but the best was also interface&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Struct&lt;/code&gt; 가 데이터라면 &lt;a href=&#34;https://tour.golang.org/methods/9&#34;&gt;Interface&lt;/a&gt; 는 메소드의 집합입니다. &lt;code&gt;Struct&lt;/code&gt; 와 마찬가지로 &lt;a href=&#34;https://golang.org/doc/effective_go.html#embedding&#34;&gt;Embedding&lt;/a&gt; 을 이용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

// ReadWriter is the interface that combines the Reader and Writer interfaces.
type ReadWriter interface {
    Reader
    Writer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go 에서는 주로 작은 인터페이스, 즉 1개의 메소드만 선언하고 있는 인터페이스를 이용하는것이 권장됩니다. 이유는 해당 인터페이스를 쉽게 구현할 수 있어 유용한 구현체를 많이 만들 수 있기 때문입니다. 예를 들어 위에서 언급한 &lt;code&gt;Writer&lt;/code&gt; 의 경우에는 &lt;code&gt;bytes.Buffer&lt;/code&gt;, &lt;code&gt;io.multiWriter&lt;/code&gt;, &lt;code&gt;gzip.Writer&lt;/code&gt;, &lt;code&gt;net.Pipe&lt;/code&gt;, &lt;code&gt;net.Conn&lt;/code&gt;, &lt;code&gt;httpResponseWriter&lt;/code&gt; 등 수 많은 유용한 구현체를 가지고 있습니다. 예를 들어 이런 코드 작성도 가능합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var but bytes.Buffer
…
var wr io.Writer = &amp;amp;buf
if test.chunked {
    wr = internal.NewChunkedWriter(wr)
}
if test.compressed {
    buf.WriteString(&amp;quot;Content-Encoding: gzip\r\n&amp;quot;) wr = gzip.NewWriter(wr)
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래는 인터페이스와 관련된 아티클들입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go&#34;&gt;How to use interfaces in Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/23148812/go-whats-the-meaning-of-interface&#34;&gt;What’s the meaning of interface{}&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;go-error-handling&#34;&gt;Go: Error Handling&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Error values in Go aren’t special, they are just values like any other, and so you have the entire language at your disposal.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Error 와 관련해서는 읽을거리를 좀 많이 찾아봤습니다. 제가 이해가 안되었던 부분이 많아서 인데요, 각각의 내용은 길지 않으니 모두 읽어보셔도 좋을것 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/defer-panic-and-recover&#34;&gt;Go Blog: Defer, Panic, and Recover&lt;/a&gt; - &lt;a href=&#34;https://blog.golang.org/error-handling-and-go&#34;&gt;Go Blog: Error Handling and Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/errors-are-values&#34;&gt;Go Blog: Errors are Values&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dave Cheney: Don&amp;rsquo;t just check errors, handle them gracefully&lt;/strong&gt; &lt;a href=&#34;https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully&#34;&gt;Article&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/watch?v=lsBF58Q-DnY&#34;&gt;Video&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Go solves the exception problem by not having exceptions.
…
The decision to not include exceptions in Go is an example of its simplicity and orthogonality. Using multiple return values and a simple convention, Go solves the problem of letting programmers know when things have gone wrong and reserves panic for the truly exceptional.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right&#34;&gt;Dave Cheney: Why Go gets exceptions right&lt;/a&gt; - &lt;a href=&#34;https://dave.cheney.net/2014/12/24/inspecting-errors&#34;&gt;Dave Cheney: Inspecting errors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux&#34;&gt;Dave Cheney: Error handling vs. exceptions redux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux&#34;&gt;Dave Cheney: Errors and Exceptions, redux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;go-concurrency&#34;&gt;Go: Concurrency&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;Concurrency is about structure, while Paralleism is about execution&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;channel&lt;/code&gt; 과 &lt;code&gt;goroutine&lt;/code&gt; 은  는 Go 가 자랑하는 기능중 하나입니다. 아래 나오는 자료들은 꼭 보시길 추천드립니다. &lt;strong&gt;Concurrency is not Parallelism&lt;/strong&gt; 에서는 Concurrency 의 개념과 이를 구현하기 위해 Go 에서 사용가능한 빌딩 블럭들을 알아봅니다. &lt;strong&gt;Go Concurrency Patterns&lt;/strong&gt; 에서는 Mock 형태의 Google Search 서비스를 만들고 select, timeout 등을 이용해서 개선하는 방법을 보여줍니다. &lt;strong&gt;Curious Channels&lt;/strong&gt; 에서는 channel 등을 사용할 때 주의해야 할 부분에 대해서 이야기 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rob Pike: Concurrency is not Parallelism&lt;/strong&gt; &lt;a href=&#34;https://talks.golang.org/2012/waza.slide&#34;&gt;Slide&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/watch?v=B9lP-E4J_lc&#34;&gt;Video&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=f6kdp27TYZs&#34;&gt;Go Concurrency Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dave.cheney.net/2013/04/30/curious-channels&#34;&gt;Curious Channels&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;혹시나 여유가 되신다면 아래의 영상들도 보시길 추천드립니다. 특히 &lt;strong&gt;Complex Concurrency Patterns with Go&lt;/strong&gt; 는 높은 성능이 요구되는 Kafka Client 를 Go 로 만들면서 겪었던 문제들을 이야기 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=QDDwwePbDtw&#34;&gt;Advanced Go Concurrency Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=2HOO5gIgyMg&#34;&gt;Complex Concurrency Patterns with Go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;idiomatic-go-tips&#34;&gt;Idiomatic Go, Tips&lt;/h3&gt;

&lt;p&gt;새로운 언어를 배울때는, 책을 읽는것도 좋은 방법이지만 다른사람의 경험으로 부터도 많은것을 배울 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=ynoY2xz-F8s&#34;&gt;Understanding nil&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rob Pike: Go Proverb&lt;/strong&gt; &lt;a href=&#34;https://go-proverbs.github.io/&#34;&gt;Page&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/watch?v=PAAkCSZUG1c&#34;&gt;Video&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://openmymind.net/Things-I-Wish-Someone-Had-Told-Me-About-Go/&#34;&gt;Things I Wish Someone Had Told Me About Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Twelve Go Best Practices&lt;/strong&gt;: &lt;a href=&#34;https://talks.golang.org/2013/bestpractices.slide#1&#34;&gt;Slide&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/watch?v=8D3Vmm1BGoY&#34;&gt;Video&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go best practices, six years in:&lt;/strong&gt; &lt;a href=&#34;https://peter.bourgon.org/go-best-practices-2016/&#34;&gt;Article&lt;/a&gt;, &lt;a href=&#34;https://www.infoq.com/presentations/go-patterns&#34;&gt;Video&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;development&#34;&gt;Development&lt;/h3&gt;

&lt;p&gt;Go 에는 언어 자체적으로 제공되는 기본 툴들이 많습니다. &lt;a href=&#34;https://www.youtube.com/watch?v=uBjoTxosSys&#34;&gt;Tooling in Action&lt;/a&gt; 에서는 이런 기본 툴 뿐만 아니라, 프로파일링에 사용할 수 있는 툴등 다양한 것들을 쉽게 설명합니다.&lt;/p&gt;

&lt;p&gt;IDE 관련해서는 최초에는 Emacs 에 &lt;a href=&#34;https://github.com/syl20bnr/spacemacs&#34;&gt;Spacemacs&lt;/a&gt; 를 얹고 Golang layout 을 이용했으나 불편함을 많이 느꼈습니다. 그 다음에는 &lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;Intellij&lt;/a&gt; 를 사용했었고, 가장 최근에는 &lt;a href=&#34;https://atom.io&#34;&gt;Atom&lt;/a&gt; 을 이용하고 있습니다. 써보진 않았지만 &lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;VS Code&lt;/a&gt; 도 괜찮다고 들었습니다. IDE 는 무엇이든 본인에게 제일 편한걸 쓰는게 좋은것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;언어는 도구일 뿐입니다. 따라서 문제에 맞는 도구를 골라 사용하면 될 일입니다. 다만, 저와 비슷한 문제들을 고민하고 계시거나, 위에서 언급했던 Go 의 특성 / 기능들이 괜찮다고 생각된다면 한번 도전해 보시는것도 나쁘지 않을것 같습니다 :)&lt;/p&gt;

&lt;p&gt;위에 나온 모든 링크는 &lt;a href=&#34;https://github.com/1ambda/golang&#34;&gt;https://github.com/1ambda/golang&lt;/a&gt; 에서 모아보실 수 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10분만에 Github Profile 만들기</title>
      <link>https://1ambda.github.io/oh-my-github/tutorial/</link>
      <pubDate>Sat, 25 Jun 2016 14:53:48 +0900</pubDate>
      
      <guid>https://1ambda.github.io/oh-my-github/tutorial/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/oh-my-github/baracktocat-large.jpg?width=200&amp;amp;height=200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Github 데이터를 이용해 프로필을 만들려면&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://developer.github.com/v3/&#34;&gt;Github API&lt;/a&gt;&lt;/strong&gt; 를 이용해 데이터를 긁어옵니다.&lt;/li&gt;
&lt;li&gt;데이터를 보여줄 웹 어플리케이션 (&lt;em&gt;static&lt;/em&gt;) 을 만듭니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Page (gh-pages)&lt;/a&gt;&lt;/strong&gt; 를 이용해 남들에게 보여줍니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 때, (1) 에서 만든 데이터의 &lt;strong&gt;포맷을 정형화하면&lt;/strong&gt;, 이것을 사용하는 (2) 의 웹 어플리케이션을 일종의 &lt;em&gt;viewer&lt;/em&gt; 로 생각할 수 있습니다. 포맷이 고정되어 있으므로 데이터를 사용하는 &lt;em&gt;viewer&lt;/em&gt; 를 &lt;strong&gt;쉽게 교체하거나&lt;/strong&gt;, 자신이 원하는대로 &lt;strong&gt;커스터마이징&lt;/strong&gt; 할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;demo&#34;&gt;Demo&lt;/h3&gt;

&lt;p&gt;시작 전에 오늘 만들 결과물의 데모를 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://1ambda.github.io/oh-my-github/&#34;&gt;Demo (Chrome, Firefox, Safari, IE11+)&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Langauge&lt;/strong&gt;: 즐겨 사용하는 프로그래밍 언어&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Repository&lt;/strong&gt;: 레포지토리 정보 (&lt;em&gt;stargazer&lt;/em&gt;, &lt;em&gt;fork count&lt;/em&gt; 등)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Contribution&lt;/strong&gt;: 오픈소스 커밋 내역&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Activity&lt;/strong&gt;: 최근 활동 내역 (&lt;em&gt;Push&lt;/em&gt;, &lt;em&gt;PullRequest&lt;/em&gt; 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등의 정보를 확인할 수 있습니다. 커스터마이징 등은 아래에서 설명하겠습니다.&lt;/p&gt;

&lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;

&lt;p&gt;이제 Github 프로필을 만들어 보겠습니다. 준비물을 먼저 확인하면,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;SSH Key&lt;/em&gt; 가 Github 에 등록이 안되어있을 경우 &lt;strong&gt;&lt;a href=&#34;https://help.github.com/articles/generating-an-ssh-key/&#34;&gt;Github: Generating an SSH key&lt;/a&gt;&lt;/strong&gt; 를 참조해서 등록해주세요.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;oh-my-github&lt;/strong&gt; 란 이름의 &lt;strong&gt;&lt;a href=&#34;https://github.com/new&#34;&gt;Github Repository&lt;/a&gt;&lt;/strong&gt; 를 만들어주세요. &lt;strong&gt;&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Page&lt;/a&gt;&lt;/strong&gt; 를 이용해 배포시 사용할 저장소입니다. (이름은 반드시 &lt;strong&gt;oh-my-github&lt;/strong&gt; 여야 합니다)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/settings/tokens/new&#34;&gt;Github Access Token&lt;/a&gt;&lt;/strong&gt; 을 만들어주세요. 50 개 이상의 Github API 호출을 위해선 Access Token 이 꼭 필요합니다. (Write Permission 은 필요 없습니다.)&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;데이터를 보여주는 정적 웹 어플리케이션인 &lt;a href=&#34;https://github.com/oh-my-github/viewer&#34;&gt;viewer&lt;/a&gt; 와 Github API 를 호출해 데이터를 생성하는 &lt;a href=&#34;https://github.com/oh-my-github/oh-my-github&#34;&gt;oh-my-github&lt;/a&gt; 설치법은 아래서 설명하겠습니다.&lt;/p&gt;

&lt;h3 id=&#34;install-viewer&#34;&gt;Install: Viewer&lt;/h3&gt;

&lt;p&gt;먼저 &lt;a href=&#34;https://github.com/oh-my-github/viewer&#34;&gt;default viewer&lt;/a&gt; 를 클론 받고, &lt;code&gt;upstream&lt;/code&gt; 업데이트를 위해 remote 를 등록합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:oh-my-github/viewer.git oh-my-github
$ cd oh-my-github

$ git remote add upstream git@github.com:oh-my-github/viewer.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고, 위에서 만든 자신의 레포지토리 url 을 &lt;code&gt;origin&lt;/code&gt; 으로 등록합니다. &lt;code&gt;[GITHUB_ID]&lt;/code&gt; 대신 자신의 아이디를 사용하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote remove origin
$ git remote add origin git@github.com:[GITHUB_ID]/oh-my-github
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;install-oh-my-github&#34;&gt;Install: oh-my-github&lt;/h3&gt;

&lt;p&gt;먼저 &lt;a href=&#34;https://github.com/oh-my-github/oh-my-github&#34;&gt;oh-my-github&lt;/a&gt; 를 설치하겠습니다. NodeJS 가 없다면, &lt;a href=&#34;https://github.com/creationix/nvm&#34;&gt;NVM&lt;/a&gt; 설치 후 문서에 나와있는 대로 NodeJS 5.0.0 이상 버전을 설치해 주세요. 이 문서에서는 5.0.0 을 사용하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nvm use 5.0.0
Now using node v5.0.0

$ nvm ls
   v0.12.9
-&amp;gt;  v5.0.0
    v5.4.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;a href=&#34;https://github.com/oh-my-github/oh-my-github&#34;&gt;oh-my-github&lt;/a&gt; 를 설치합니다. 네트워크 상황에 따라 2분 ~ 4분정도 걸립니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install oh-my-github -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 Linux 를 사용하고 있고, 위 설치 과정에서 &lt;code&gt;LIBXXX&lt;/code&gt; 등의 에러를 마주쳤을 경우 &lt;a href=&#34;https://github.com/oh-my-github/oh-my-github/wiki/Installation-Guide-for-Linux&#34;&gt;Linux Install Guide&lt;/a&gt; 를 참조해주세요.&lt;/p&gt;

&lt;p&gt;이제 &lt;em&gt;viewer&lt;/em&gt; 를 클론 받은 디렉토리로 이동한 뒤 &lt;em&gt;oh-my-github&lt;/em&gt; 를 실행합니다. 여기서 &lt;code&gt;[GITHUB_TOKEN]&lt;/code&gt; 은 위에서 만든 &lt;a href=&#34;https://github.com/settings/tokens/new&#34;&gt;Github Access Token&lt;/a&gt; 값이고, &lt;code&gt;[GITHUB_ID]&lt;/code&gt; 는 자신의 Github ID 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ oh-my-github

$ omg init [GITHUB_ID] oh-my-github       # (e.g) omg init 1ambda oh-my-github
$ omg generate [GITHUB_TOKEN]             # (e.g) omg generate 394fbad49191aca
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;omg generate&lt;/code&gt; 를 실행하면, 현재 디렉토리에 &lt;code&gt;oh-my-github.json&lt;/code&gt; (프로필 데이터) 가 생성됩니다. &lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Page&lt;/a&gt; 에 배포하기 전에 먼저 로컬에 띄워 볼 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ omg preview
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;gh-pages&lt;/code&gt; 브랜치를 만들고 push 를 해야하는데, 아래의 명령어를 이용해 한번에 해결할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ omg publish
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 &lt;code&gt;omg publish&lt;/code&gt; 명령어가 동작하지 않는다면, 직접 Git 커맨드를 사용하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add --all
$ git commit -m &amp;quot;feat: Update Profile&amp;quot;
$ git checkout -b gh-pages
$ git push origin HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 30초 정도 기다리고, 자신의 oh-my-github 레포지토리 &lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Page&lt;/a&gt; URL 을 확인해 봅니다. 예를 들어 Github ID 가 &lt;code&gt;1ambda&lt;/code&gt; 라면, &lt;a href=&#34;http://1ambda.github.io/oh-my-github&#34;&gt;http://1ambda.github.io/oh-my-github&lt;/a&gt; 에 프로필이 생성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;update&#34;&gt;Update&lt;/h3&gt;

&lt;h4 id=&#34;profile&#34;&gt;Profile&lt;/h4&gt;

&lt;p&gt;프로필 데이터 &lt;code&gt;oh-my-github.json&lt;/code&gt; 내용은 크게 분류하면 두가지로 나뉩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;activities&lt;/code&gt;: 사용자의 활동 정보로, 이전 정보에 새로운 값이 추가됨(&lt;em&gt;append&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repositories&lt;/code&gt;, &lt;code&gt;languages&lt;/code&gt; 등: 최신 정보로 덮어 씌워짐 (&lt;em&gt;overwrite&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;omg generate&lt;/code&gt; 를 실행할 때 마다, 새로운 이벤트가 있다면 &lt;code&gt;activities&lt;/code&gt; 값이 추가 (&lt;em&gt;append&lt;/em&gt;) 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;더 정확히는, Github API 는 최대 10개월 혹은 최대 300개의 event 만 제공하기 때문에, 이것보다 더 많은 양의 event 를 프로필 데이터에 저장하고자 event id 값으로 중복 제거를 한 뒤 &lt;em&gt;append&lt;/em&gt; 방식으로 데이터를 쌓습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 프로필 데이터를 업데이트 하고, Github 에 푸시하려면 다음의 명령어를 실행하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd oh-my-github         # oh-my-github.json 이 위치한 곳

$ omg generate [GITHUB_TOKEN]
$ omg publish
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;viewer&#34;&gt;Viewer&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;viewer&lt;/em&gt; 를 &lt;a href=&#34;https://github.com/oh-my-github/viewer&#34;&gt;upstream&lt;/a&gt; 에서 다음처럼 업데이트 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd oh-my-github         # oh-my-github.json 이 위치한 곳

$ git checkout master
$ git pull upstream master --rebase

$ git checkout gh-pages
$ git rebase master

$ git push origin HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;customizing&#34;&gt;Customizing&lt;/h3&gt;

&lt;p&gt;만약 &lt;a href=&#34;https://github.com/oh-my-github/viewer&#34;&gt;default viewer&lt;/a&gt; 가 맘에 들지 않는다거나, 새로운 기능 (e.g 그래프) 을 추가하고 싶다면 클론받아 &lt;code&gt;app/src&lt;/code&gt; 아래의 코드를 수정할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app
├── LICENSE.md
├── package.json
├── src (웹 애플리케이션 소스)
│   ├── actions
│   ├── components
│   ├── constants
│   ├── containers
│   ├── reducers
│   ├── store
│   ├── theme
│   └── util
└── tools (빌드도구 관련)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;app&lt;/code&gt; 디렉토리로 이동 후 &lt;code&gt;npm start -s&lt;/code&gt; 를 실행하고 코드를 수정한 뒤, &lt;code&gt;npm run build&lt;/code&gt; 를 실행하면 루트 디렉토리에 &lt;code&gt;bundle.js&lt;/code&gt; 와 &lt;code&gt;index.html&lt;/code&gt; 이 업데이트 됩니다. 이 두 파일을 자신의 &lt;strong&gt;oh-my-github&lt;/strong&gt; 에 업데이트 하면 됩니다.&lt;/p&gt;

&lt;p&gt;추가로, 다른 사람들이 자신이 수정한 &lt;em&gt;viewer&lt;/em&gt; 를 찾을 수 있게 &lt;a href=&#34;https://www.npmjs.com/search?q=oh-my-github%2C+viewer&#34;&gt;NPM&lt;/a&gt; 에 등록하고 싶다면 &lt;code&gt;package.json&lt;/code&gt; 을 수정 후 &lt;code&gt;app&lt;/code&gt; 디렉토리에서 &lt;code&gt;npm publish&lt;/code&gt; 명령을 실행하면 됩니다.&lt;/p&gt;

&lt;p&gt;아래의 내용을 수정하고, 배포하면 NPM 에서 &lt;code&gt;oh-my-github, viewer&lt;/code&gt; 키워드로 검색할 수 있습니다. &lt;a href=&#34;https://www.npmjs.com/search?q=oh-my-github%2C+viewer&#34;&gt;(NPM: oh-my-github, viewer)&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  ...

  &amp;quot;name&amp;quot;: &amp;quot;oh-my-github-viewer-default&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
  &amp;quot;author&amp;quot;: &amp;quot;1ambda&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;homepage&amp;quot;: &amp;quot;https://github.com/oh-my-github/viewer#readme&amp;quot;,
  &amp;quot;repository&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;git&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;git+https://github.com/oh-my-github/viewer.git&amp;quot;
  },
  &amp;quot;bugs&amp;quot;: {
    &amp;quot;url&amp;quot;: &amp;quot;https://github.com/oh-my-github/viewer/issues&amp;quot;
  },

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://octodex.github.com/baracktocat&#34;&gt;@baracktocat on octodex (Title Iamge)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oh-my-github/oh-my-github&#34;&gt;oh-my-github: generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oh-my-github/viewer&#34;&gt;oh-my-github: viewer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CC 01: Map Reduce</title>
      <link>https://1ambda.github.io/cloud-computing/cloud-computing-1/</link>
      <pubDate>Sat, 25 Jun 2016 14:42:29 +0900</pubDate>
      
      <guid>https://1ambda.github.io/cloud-computing/cloud-computing-1/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://ook.co/wp-content/uploads/cloudcomputing.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;intro&#34;&gt;Intro&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;map&lt;/em&gt; 과 &lt;em&gt;reduce&lt;/em&gt; 라는 단어는 &lt;em&gt;functional language&lt;/em&gt; 에서 왔다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;map:&lt;/em&gt; processes each record sequentially and independently&lt;/li&gt;
&lt;li&gt;&lt;em&gt;reduce:&lt;/em&gt; processes set of all records in batches&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(map square &#39;(1 2 3 4))
;; (1 4 9 16)

(reduce + &#39;(1 4 9 16))
;; (+16 (+9 (+4 1)))
;; 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;mapreduce&#34;&gt;MapReduce&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://webmapreduce.sourceforge.net/docs/User_Guide/images/map-reduce.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://webmapreduce.sourceforge.net/&#34;&gt;http://webmapreduce.sourceforge.net/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Map:&lt;/em&gt; &lt;strong&gt;Parallelly&lt;/strong&gt; process &lt;strong&gt;a large number&lt;/strong&gt; of individual records to generate intermediate key/value pairs
&lt;br/&gt;
&lt;em&gt;Reduce:&lt;/em&gt; processes and merges all intermediate values associated per key&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;각 키는 하나의 &lt;em&gt;reducer&lt;/em&gt; 에 할당되고, &lt;em&gt;partitioning keys&lt;/em&gt; 에 의해 &lt;em&gt;reduce&lt;/em&gt; 가 진행된다. 자주 쓰이는 기법으로 &lt;em&gt;hash partitioning&lt;/em&gt; 이 있다. &lt;code&gt;hash(key) % # of reduce servers&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static class MapClass extends MapReduceBase 
            implements Mapper&amp;lt;LongWriteable, Text, Text, IntWritable&amp;gt; {

  private final static IntWritable one = new IntWritable(1);
  private Text word = new Text();
  
  public void map(LongWritable key, Text value, 
                  OutputCollector&amp;lt;Text, IntWritable&amp;gt; output,
                  Reporter reporter) throws IOException {
  
    String line = value.toString();
    StringTokenizer itr = new StringTokenizer(line);
    
    while (itr.hasMoreTokens()) {
      word.set(itr.nextToken());
      output.collect(word, one);
    }
  }
}

public static class ReduceClass extends MapReduceBase
            implements Reducer&amp;lt;Text, IntWritable, Text, IntWritable&amp;gt; {
            
  public void reduce(Text key, Iterator&amp;lt;IntWritable&amp;gt; values,
                     OutputCollector&amp;lt;Text, IntWritable&amp;gt; output,
                     Reporter reporter) throw IOException {
    
    int sum = 0;
    while (values.hasNext()) {
      sum += values.next().get();
    }
    
    output.collect(key, new IntWritable(sum));
  }                     
}

public void run(String inputPath, String outputPath) throw Exception {

  // The job
  JobConf conf = new JobConf(WordCount.class);
  conf.setJobName(&amp;quot;mywordcount&amp;quot;);
  
  // The keys are words
  (srings) conf.setOutputKeyClass(Text.class);
  
  // The values are counts (ints)
  conf.setOutputValueClass(IntWritable.class);
  conf.setMapperClass(MapClass.class);
  conf.setReducerClass(ReduceClass.class);
  
  FileInputFormat.addInputPat(conf, new Path(inputPath);
  FileOutputFormat.setOutputPath(conf, new Path(outputPath));
  
  JobClient.runJob(conf);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;mapreduce-application&#34;&gt;MapReduce Application&lt;/h3&gt;

&lt;p&gt;(1) &lt;strong&gt;Distributed Grep&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;input:&lt;/em&gt; large set of files&lt;/li&gt;
&lt;li&gt;&lt;em&gt;output:&lt;/em&gt; lines that match pattern&lt;/li&gt;
&lt;li&gt;&lt;em&gt;map:&lt;/em&gt; emits a line if it matches the supplied pattern&lt;/li&gt;
&lt;li&gt;&lt;em&gt;reduce:&lt;/em&gt; copies the intermediate data to output&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) &lt;strong&gt;Reverse Web-Link Graph&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;input:&lt;/em&gt; web graph(tuple &lt;code&gt;(a,b)&lt;/code&gt; where page &lt;code&gt;a&lt;/code&gt; -&amp;gt; page &lt;code&gt;b&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;output:&lt;/em&gt; for each page, list of pages that link to it&lt;/li&gt;
&lt;li&gt;&lt;em&gt;map:&lt;/em&gt; process we log and for each input &lt;code&gt;&amp;lt;source, target&amp;gt;&lt;/code&gt;, it outputs &lt;code&gt;&amp;lt;target, source&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;reduce:&lt;/em&gt; emits &lt;code&gt;&amp;lt;target, list(source)&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(3) &lt;strong&gt;Count of URL Access Frequency&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;input:&lt;/em&gt; log of accessed URLs&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;output:&lt;/em&gt; for each URL, the number of total accesses for that URL&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;map:&lt;/em&gt; process web log and outputs &lt;code&gt;&amp;lt;URL, 1&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;multiple reducers:&lt;/em&gt; emits `&lt;URL, URL_count&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;chain another MapReduce job to calculate&lt;/strong&gt; &lt;code&gt;overall_count&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(4) &lt;em&gt;Sort&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;map&lt;/em&gt; task&amp;rsquo;s output is sorted (e.g., &lt;em&gt;quicksort&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;reduce&lt;/em&gt; task&amp;rsquo;s input is osrted (e.g., &lt;em&gt;mergesort&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 정렬을 하기 위해&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;map:&lt;/em&gt; &lt;code&gt;&amp;lt;key, value&amp;gt;&lt;/code&gt; -&amp;gt; &lt;code&gt;&amp;lt;value, _&amp;gt;&lt;/code&gt; (identity)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;reduce:&lt;/em&gt; &lt;code&gt;&amp;lt;key, value&amp;gt;&lt;/code&gt; -&amp;gt; &lt;code&gt;&amp;lt;key, value&amp;gt;&lt;/code&gt; (identity)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 때 &lt;em&gt;parttition key&lt;/em&gt; 로 &lt;em&gt;range&lt;/em&gt; 를 사용하는 것이 가능하다. 다만, 특정 구간에 &lt;em&gt;data&lt;/em&gt; 가 몰려있을 수 있으므로 &lt;em&gt;dstiribution&lt;/em&gt; 을 고려해 &lt;em&gt;reducer&lt;/em&gt; 에게 할당해주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;scheduling&#34;&gt;Scheduling&lt;/h3&gt;

&lt;p&gt;일반 &lt;em&gt;user&lt;/em&gt; 는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Write a Map program, write a Reduce program&lt;/li&gt;
&lt;li&gt;Submit job; wait for result&lt;/li&gt;
&lt;li&gt;Need to know nothing about parallel/distributed programming&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 내부적으로는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Parallelize Map&lt;/li&gt;
&lt;li&gt;Transfer data from Map to Reduce&lt;/li&gt;
&lt;li&gt;Parallelize Reduce&lt;/li&gt;
&lt;li&gt;Implement Stroage for Map input, Map output, Reduce input, Reduce output&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 &lt;em&gt;reduce&lt;/em&gt; 가 시작되기 전에 반드시 &lt;em&gt;map&lt;/em&gt; 이 끝나야 한다. 다시 말해서 &lt;em&gt;map phase&lt;/em&gt; 와 &lt;em&gt;reduce phase&lt;/em&gt; 사이에는 &lt;em&gt;barrier&lt;/em&gt; 가 있어야 한다. 그렇지 않으면 결과가 부정확할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 하나하나씩 살펴보자.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;Parallelize Map:&lt;/em&gt; Easy. Each map task is independent of the other&lt;/p&gt;

&lt;p&gt;(2) &lt;em&gt;Transfer data from Map to Reduce:&lt;/em&gt; All map output records with same key assigned to same Reduce task. Use &lt;strong&gt;Partitionning Function&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(3) &lt;em&gt;Parallelize Reduce:&lt;/em&gt; Easy. Each reduce task is independent of the other&lt;/p&gt;

&lt;p&gt;(4) &lt;em&gt;Implement Storage for Map input, Map output, Reduce input and Reduce output:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Map input: from &lt;strong&gt;distributed file system&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Map output: to local disk at Map node; Use &lt;strong&gt;local file systems&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Reduce input: from (multiple) remote disks; Uses local file systems&lt;/li&gt;
&lt;li&gt;Reduce output: to &lt;strong&gt;distributed file system&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DFS 의 예로 &lt;em&gt;Google File System&lt;/em&gt;, &lt;em&gt;HDFS&lt;/em&gt; 등이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;하둡은 스케쥴러로 *YARN, Yet Another Resouce Negotiator*를 사용한다. &lt;em&gt;YARN&lt;/em&gt; 은 각 서버를 &lt;em&gt;a collection of containers&lt;/em&gt; 로 취급한다. 여기서 &lt;em&gt;container = some CPU + some Memory&lt;/em&gt; 다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;YARN&lt;/em&gt; 은 크게 3파트로 나눌 수 있는데&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Global Resource Manager(RM):&lt;/em&gt; scheduling&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Per-server Node Manager(NM):&lt;/em&gt; Daemon and server-specific functions&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Per-application(job) Application Master(AM):&lt;/em&gt; Container negotiation with RM and NMs, Detecting task failures of that job&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week1/YARN.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;container&lt;/em&gt; 가 필요하면 &lt;em&gt;AM1&lt;/em&gt; 이 &lt;em&gt;RM&lt;/em&gt; 에게 알리고, &lt;em&gt;Node B&lt;/em&gt; 의 &lt;em&gt;NM2&lt;/em&gt; 에서 &lt;em&gt;Task&lt;/em&gt; 가 끝나면, &lt;em&gt;RM&lt;/em&gt; 이 &lt;em&gt;Node A&lt;/em&gt; 의 &lt;em&gt;AM1&lt;/em&gt; 에게 사용 가능한 컨테이너가 있다는 사실을 알려 &lt;em&gt;AM1&lt;/em&gt; 이 &lt;em&gt;NM2&lt;/em&gt; 에게 컨테이너를 사용하겠다는 요청을 보내는 식이다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;fault-tolerance&#34;&gt;Fault-Tolerance&lt;/h3&gt;

&lt;p&gt;(1) Server Failure&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;NM&lt;/em&gt; hearbeats to &lt;em&gt;RM&lt;/em&gt;. If server fails &lt;em&gt;RM&lt;/em&gt; lets all affected &lt;em&gt;AMs&lt;/em&gt; know, and &lt;em&gt;AMs&lt;/em&gt; take action&lt;/li&gt;
&lt;li&gt;&lt;em&gt;NM&lt;/em&gt; keeps track of each task running at its server. If task fails while in-progress, mark the task as idle and restart it&lt;/li&gt;
&lt;li&gt;&lt;em&gt;AM&lt;/em&gt; heartbeats to &lt;em&gt;RM&lt;/em&gt;. On failure, &lt;em&gt;RM&lt;/em&gt; restarts &lt;em&gt;AM&lt;/em&gt;, which then syncs up with its running tasks&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) RM Failure&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use old checkpoints and bring up secondary &lt;em&gt;RM&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Heartbeats also used to piggyback container requests. Avoids extra mesages&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;요약하자면, &lt;em&gt;NM&lt;/em&gt;, &lt;em&gt;AM&lt;/em&gt; 은 &lt;em&gt;RM&lt;/em&gt; 에게 &lt;em&gt;heartbeat&lt;/em&gt; 를 보낸다. &lt;em&gt;NM&lt;/em&gt; 에서 오류가 나면 &lt;em&gt;RM&lt;/em&gt; 이 영향을 받는 &lt;em&gt;AM&lt;/em&gt; 에게 알리고, 해당 &lt;em&gt;AM&lt;/em&gt; 이 적절히 처리한다. 또한 &lt;em&gt;NM&lt;/em&gt; 은 &lt;em&gt;task&lt;/em&gt; 를 유지하면서, &lt;em&gt;task&lt;/em&gt; 에러가 발생하면 재시작한다. &lt;em&gt;AM&lt;/em&gt; 에서 오류가 나면 &lt;em&gt;RM&lt;/em&gt; 이 재시작하고, 해당 &lt;em&gt;AM&lt;/em&gt; 의 태스크와 싱크를 맞춘다. &lt;em&gt;RM&lt;/em&gt; 에서 오류가 날 경우엔 &lt;em&gt;secondary RM&lt;/em&gt; 을 이용한다.&lt;/p&gt;

&lt;h3 id=&#34;stragglers&#34;&gt;Stragglers&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;slow nodes&lt;/em&gt; 를 부르는 다른말이다. &lt;em&gt;speculative execution&lt;/em&gt; 으로 해결할 수 있다. 보통 느린 이유는 &lt;em&gt;disk&lt;/em&gt;, &lt;em&gt;network bandwidth&lt;/em&gt;, &lt;em&gt;CPU&lt;/em&gt;, &lt;em&gt;memory&lt;/em&gt; 등 때문인데 &lt;em&gt;task&lt;/em&gt; 를 복제해서 다른 &lt;em&gt;node&lt;/em&gt; 에서 돌린 뒤 먼저 완료되는 노드의 결과를 이용하는 방식이다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Perform backup (replicated) execution of straggler task: task considered done when first replica completed&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;locality&#34;&gt;Locality&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;cloud&lt;/em&gt; 의 &lt;em&gt;hierarchical topology&lt;/em&gt; 때문에 &lt;em&gt;GFS&lt;/em&gt;, &lt;em&gt;HDFS&lt;/em&gt; 등은 각 &lt;em&gt;chunk&lt;/em&gt; 를 3군데에 복제한다. 이때 같은 &lt;em&gt;rack&lt;/em&gt; 에 위치할수도 아닐수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;MapReduce&lt;/em&gt; 연산에서는 &lt;em&gt;map task&lt;/em&gt; 를 스케쥴링할때 가능하면 다음의 순서로 배치한다.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;chunk&lt;/em&gt; 가 있는 머신에 or failing that&lt;br /&gt;
(2) 아니면 같은 &lt;em&gt;rack&lt;/em&gt; 에 or failing that&lt;br /&gt;
(3) Anywhere&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;(1) MapReduce uses parallelization + aggregation to schedule applications across clusters.&lt;/p&gt;

&lt;p&gt;(2) Need to deal with failure&lt;/p&gt;

&lt;p&gt;(3) Plenty of ongoing research work in scheduling and fault-tolerance for Mapreduce and Hadoop&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;refs&#34;&gt;Refs&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;http://ook.co/solutions/cloud-computing/&#34;&gt;Title Image&lt;/a&gt;&lt;br /&gt;
(2) &lt;strong&gt;Cloud Computing Concept 1&lt;/strong&gt; by &lt;em&gt;Indranil Gupta&lt;/em&gt;, Coursera&lt;br /&gt;
(3) &lt;a href=&#34;http://webmapreduce.sourceforge.net/docs/User_Guide/sect-User_Guide-Introduction-What_is_Map_Reduce.html&#34;&gt;MapReduce Image&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ML 01: Linear Regression</title>
      <link>https://1ambda.github.io/data-analysis/machine-learning-week-1/</link>
      <pubDate>Sat, 25 Jun 2016 14:25:15 +0900</pubDate>
      
      <guid>https://1ambda.github.io/data-analysis/machine-learning-week-1/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Machine Learning&lt;/strong&gt; by Andrew Ng, &lt;em&gt;Coursera&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;what-is-machine-learning&#34;&gt;What is Machine Learning?&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Field of study that gies computers the abiliry to learn without being explicitly programmed. (1959, Arthur Samuel)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Well-posed Learning Problem:&lt;/strong&gt; A computer program is said to &lt;em&gt;learn&lt;/em&gt; from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E (1998, Tom Michell)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;체크메이트를 예로 들면, 수천번의 체스 게임은 &lt;em&gt;E&lt;/em&gt; 에 해당하고 게임 속에서 체크메이트는 &lt;em&gt;T&lt;/em&gt; 에, &lt;em&gt;P&lt;/em&gt; 는 다음 게임에서 이길 확률로 볼 수 있다.&lt;/p&gt;

&lt;p&gt;다른 예로, 이메일을 분류하는 스팸검사기가 있다고 할때&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;E&lt;/em&gt;: Wathing you label emails as spam or not spam.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;T&lt;/em&gt;: Classifying emails as spam or not spam.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;P&lt;/em&gt;: The number(or fraction) of emails correctly classified as spam/not spam.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;supervised-learning&#34;&gt;Supervised Learning&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Given the rihgt answer&lt;/strong&gt; for each example in the data&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 주어진 정답이 있을때 사용할 수 있다. 이런 문제들은 많은데, &lt;em&gt;Regression&lt;/em&gt; 이나 &lt;em&gt;Classification&lt;/em&gt; 등이 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Regression:&lt;/strong&gt; Predict continuous valued output&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Classification:&lt;/strong&gt; Discrete valued output (0 or 1)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단순히 1개 혹은 2개의 attribute 를 사용할 수 있지만, infinite number of features(attribute) 를 사용하는 &lt;em&gt;Support Vector Machine&lt;/em&gt; 같은 알고리즘도 있다.&lt;/p&gt;

&lt;h3 id=&#34;unsupervised-learning&#34;&gt;Unsupervised Learning&lt;/h3&gt;

&lt;p&gt;즉 모든 데이터에 attribute 는 있지만 주어진 정답이 없을때 사용한다. 다시 말해서, 여러 집단으로 분류될때 미리 컴퓨터에게 이건 &lt;code&gt;type1&lt;/code&gt; 이야 등의 정보를 제공하지 않는다.&lt;/p&gt;

&lt;p&gt;예를 들어서, 다음의 두가지 예는 &lt;em&gt;Unsupervised leanring&lt;/em&gt; 이 아니라 &lt;em&gt;Supervised learning&lt;/em&gt; 이다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(1) &lt;strong&gt;Given email labeled as spam/not spam&lt;/strong&gt;, learn a spam filter&lt;br/&gt;&lt;br/&gt;
(2) &lt;strong&gt;Given a dataset of patients diagnosed as either having diabetes or not&lt;/strong&gt;, learn to classify new patients as having diabetes or not&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Clustering&lt;/strong&gt; 이라 불리는데, DNS Clustering, Social network analysis, market segmentation 등에 쓰인다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cocktail party problem&lt;/strong&gt; 은 2명이 동시에 말하고, 이걸 서로 다른 위치에 있는 마이크가 녹음한다고 할 때 이 소리를 구분할 수 있는가 하는 문제다. 이것 또한 &lt;em&gt;Unsupervised lerning&lt;/em&gt; 으로 해결할 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;model-representation&#34;&gt;Model Representation&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://mercris.files.wordpress.com/2012/07/genericmlatwork.png&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://mercris.files.wordpress.com/2012/07/genericmlatwork.png&#34;&gt;http://mercris.files.wordpress.com/2012/07/genericmlatwork.png&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Traning Set&lt;/em&gt; 을 넣고 &lt;em&gt;Learning Algorithm&lt;/em&gt; 을 돌리면 &lt;em&gt;Hypothesis&lt;/em&gt; 가 나오는데, 이건 사실 함수라 보면 된다. 여기에 새로운 &lt;em&gt;Input X&lt;/em&gt; 를 넣으면 &lt;em&gt;Estimated Y&lt;/em&gt; 가 나온다.&lt;/p&gt;

&lt;p&gt;참고로, 변수가 하나인 &lt;em&gt;Linear regression&lt;/em&gt; 은 &lt;strong&gt;Univariate linear regression&lt;/strong&gt; 이라 부른다.&lt;/p&gt;

&lt;h3 id=&#34;cost-function&#34;&gt;Cost Function&lt;/h3&gt;

&lt;p&gt;예를 들어서 다음과 같은 데이터셋이 있을때,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://mercris.files.wordpress.com/2012/07/screen-shot-2012-07-17-at-2-12-05-pm.png?w=584&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;http://mercris.files.wordpress.com/2012/07/screen-shot-2012-07-17-at-2-12-05-pm.png?w=584&#34;&gt;http://mercris.files.wordpress.com/2012/07/screen-shot-2012-07-17-at-2-12-05-pm.png?w=584&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;H(hypothesis)&lt;/em&gt; 가 다음처럼 나온다면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://s0.wp.com/latex.php?latex=h_%7B%5Ctheta%7Dx+%3D+%5Ctheta_%7B0%7D+%2B+%5Ctheta_%7B1%7Dx&amp;bg=ffffff&amp;fg=333333&amp;s=0&#34; align=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;0 (Theta)&lt;/code&gt; 는 &lt;em&gt;parameter&lt;/em&gt; 라고 부른다.
문제는, 상수를 어떻게 찾느냐인데, 아이디어는 간단하다. training set &lt;code&gt;(x, y)&lt;/code&gt; 에 가까운 &lt;code&gt;h(x)&lt;/code&gt; 를 찾으면 된다.&lt;/p&gt;

&lt;p&gt;따라서 다음과 같은 식을 만들 수 있고,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://s0.wp.com/latex.php?latex=J%28%5Ctheta_%7B0%7D%2C+%5Ctheta_%7B1%7D%29+%3D+%5Cdfrac+%7B1%7D%7B2m%7D+%5Csum+%5Climits_%7Bi%3D1%7D%5E%7Bm%7D+%28h_%7B%5Ctheta%7D+%28x%5E%7B%28i%29%7D%29+-+y%5E%7B%28i%29%7D%29%5E2&amp;bg=ffffff&amp;fg=333333&amp;s=0&#34; align=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;J(01, 02)&lt;/code&gt; 를 최소화 하는 &lt;code&gt;(01, 02)&lt;/code&gt; 를 찾으면 된다. 이 식을 &lt;strong&gt;cost function&lt;/strong&gt; 또는 &lt;strong&gt;squred error function&lt;/strong&gt; 이라 부른다. 여기서 &lt;code&gt;1/2m&lt;/code&gt; 으로 나누는 이유에 대해 좀 궁금해서 구글링 해봤는데, &lt;code&gt;1/m&lt;/code&gt; 으로 나누는 이유는 &lt;em&gt;squared error&lt;/em&gt; 에 대해 &lt;em&gt;mean&lt;/em&gt; 을 얻기 위한거고, &lt;code&gt;1/2&lt;/code&gt; 로 다시 나누는 이유는 미분했을때 나오는 &lt;code&gt;2&lt;/code&gt; 를 제거하기 위해서다. &lt;a href=&#34;http://stackoverflow.com/questions/21099289/cant-understand-the-cost-function-for-linear-regression&#34;&gt;SO 답변&lt;/a&gt; 을 첨부하면,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The cost function is&lt;/p&gt;

&lt;p&gt;J(theta_0, theta&lt;em&gt;1) = 1/(2m) * sum&lt;/em&gt;(i=1)^m [ h_theta(x^i) - y^i ]^2
By h_theta(x^i) we denote what model outputs for x^i, so h_theta(x^i) - y^i is its error (assuming, that y^i is a correct output).&lt;/p&gt;

&lt;p&gt;Now, we calculate the square of this error [ h_theta(x^i) - y^i ]^2 (which removes the sign, as this error could be both positive and negative) and sum it over all samples, and to &lt;strong&gt;bound it somehow we normalize it - simply by dividing by m,&lt;/strong&gt; so we have mean (because we devide by number of samples) squared (because we square) error (because we compute an error):&lt;/p&gt;

&lt;p&gt;1/m * sum_(i=1)^m [ h_theta(x^i) - y^i ]^2
&lt;strong&gt;This 2 which appears in the front is used only for simplification of the derivative&lt;/strong&gt;, because when you will try to minimize it, you will use the steepest descent method, which is based on the derivative of this function. Derivative of a^2 is 2a, and our function is a square of something, so this 2 will cancel out. This is the only reason of its existance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 &lt;em&gt;cost function&lt;/em&gt; 은 &lt;em&gt;regression&lt;/em&gt; 문제를 위해 자주 쓰이는 기법이다.&lt;/p&gt;

&lt;h3 id=&#34;cost-function-intuition-1&#34;&gt;Cost Function: Intuition 1&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Cost function&lt;/em&gt; 에서 만약에 &lt;code&gt;0_0&lt;/code&gt; 이 제로라면 &lt;code&gt;0_1&lt;/code&gt; 만 찾으면 된다. 따라서 다음과 같은 실제 데이터에서&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://cfile3.uf.tistory.com/image/2275174452D612AE06C75B&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://mapository.tistory.com/59&#34;&gt;http://mapository.tistory.com/59&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;J(0_1)&lt;/code&gt; 을 찾아보면, 다음과 같은 이차함수가 나온다.&lt;/p&gt;

&lt;p&gt;&lt;img align=&#34;center&#34; src=&#34;http://cfile29.uf.tistory.com/image/234E894A52D6113D1F8267&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://mapository.tistory.com/59&#34;&gt;http://mapository.tistory.com/59&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;당연히 이차함수이므로, 기울기가 0이 되는 지점은 &lt;code&gt;J(0_1)&lt;/code&gt; 을 미분해서 찾으면 된다. (이래서 아까 1/2가 있던 것)&lt;/p&gt;

&lt;h3 id=&#34;cost-function-intuition-2&#34;&gt;Cost Function: Intuition 2&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Parameter&lt;/em&gt; 가 &lt;code&gt;0_1&lt;/code&gt; 만 있었을때는, (&lt;code&gt;0_0&lt;/code&gt; = 0) &lt;code&gt;J(0_1)&lt;/code&gt; 이 이차함수였지만, &lt;code&gt;J(0_0, 0_1)&lt;/code&gt; 일때는 다음과 같은 모양을 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img align=&#34;center&#34; src=&#34;http://cfile2.uf.tistory.com/image/2232CA4C52D611111DDFCD&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://mapository.tistory.com/59&#34;&gt;http://mapository.tistory.com/59&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;J(0_0, 0_1)&lt;/code&gt; 값을 제외하고 &lt;code&gt;(0_0, 0_1)&lt;/code&gt; 을 평면으로 나타내면 아래 사진에서 우측과 같은 여러 궤도가 나온다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://cfile24.uf.tistory.com/original/2107074652D6134E0ECB0F&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://mapository.tistory.com/59&#34;&gt;http://mapository.tistory.com/59&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;여기서 같은 궤도에 있는 &lt;code&gt;(0_0, 0_1)&lt;/code&gt; 쌍은, 같은 &lt;code&gt;J&lt;/code&gt; 함수를 만든다. 그리고 재밌는 사실은 궤도가 가장 좁은 타원의 중심에 있는 &lt;code&gt;(0_0, 0_1)&lt;/code&gt; 가 가장 작은 &lt;code&gt;J(0_0, 0_1)&lt;/code&gt; 를 만들어 낸다.&lt;/p&gt;

&lt;h3 id=&#34;gradient-descent&#34;&gt;Gradient Descent&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Gradient Descent&lt;/em&gt; 알고리즘은 &lt;em&gt;Linear Regression&lt;/em&gt; 에만 쓸 수 있는건 아니고, 범용적인 알고리즘이다. &lt;em&gt;cost function&lt;/em&gt; 의 최소값을 찾기 위해 사용할 수 있는데, 다음과 같은 &lt;code&gt;J&lt;/code&gt; 가 있을때,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://cfile28.uf.tistory.com/image/2401353E52D618322EDFB5&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://mapository.tistory.com/59&#34;&gt;http://mapository.tistory.com/59&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;높이를 비교해 가며 점점 낮은쪽으로 이동해 가면서 &lt;code&gt;J&lt;/code&gt; 의 최소값을 찾을 수 있다. 식은 다음과 같은데,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://2.bp.blogspot.com/-AdV-O-MoZHE/TtLibFTaf9I/AAAAAAAAAVM/aOxUGP7zl98/s1600/gradient+descent+algorithm+OLS.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://econometricsense.blogspot.kr/2011_11_01_archive.html&#34;&gt;http://econometricsense.blogspot.kr/2011_11_01_archive.html&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;:=&lt;/code&gt; 는 &lt;em&gt;assignment&lt;/em&gt; 다. &lt;code&gt;a(alpha)&lt;/code&gt; 는 &lt;em&gt;learning rate&lt;/em&gt; 라 부른다. 이때 &lt;code&gt;(0_0, 0_1)&lt;/code&gt; 은 동시에 업데이트 되야한다. &lt;strong&gt;(Simultaneous update)&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;gradient-descent-intuition&#34;&gt;Gradient Descent: Intuition&lt;/h3&gt;

&lt;p&gt;이제 저 식을 분해하기 위해 &lt;code&gt;J(0_1)&lt;/code&gt; 처럼 &lt;em&gt;parameter&lt;/em&gt; 하나만 놓고 보면, 이차원 함수가 나올테다. 만약 현재 &lt;code&gt;0_1&lt;/code&gt; 이 이차함수의 최저점 우측에 있다면, &lt;code&gt;J(0_1)&lt;/code&gt; 을 미분한 값&lt;strong&gt;(Slope, 기울기)&lt;/strong&gt; 에 양수 &lt;code&gt;a&lt;/code&gt; 를 곱한 값을 &lt;code&gt;0_1&lt;/code&gt; 에서 뻬면서 갱신하면 &lt;code&gt;0_1&lt;/code&gt; 은 점점 최저점 쪽으로 간다,&lt;/p&gt;

&lt;p&gt;반대로 &lt;code&gt;0_1&lt;/code&gt; 이 &lt;code&gt;J(0_1)&lt;/code&gt; 의 좌측에 위치한다면 우측으로 이동하고, 아래는 그걸 요약한 그림이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.ytimg.com/vi/ud4o8AYe9tI/hqdefault.jpg&#34; align=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;learning late&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; 가 너무 작으면 &lt;em&gt;Gradient descent&lt;/em&gt; 가 너무 느려진다. 왜냐하면 &lt;code&gt;0&lt;/code&gt; 의 차이가 점점 작이지기 때문에 최저점에 도착할때 까지 너무 많은 step 이 필요하다.&lt;/p&gt;

&lt;p&gt;반대로 너무 크면 최저점을 넘어갈 수 있다. 심지어 최저점에서 점점 더 멀어질 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;if &lt;code&gt;a&lt;/code&gt; is too small, &lt;em&gt;gradient descent&lt;/em&gt; can be slow &lt;br/&gt;&lt;br/&gt;
if &lt;code&gt;a&lt;/code&gt; is too large, &lt;em&gt;gradient desscent&lt;/em&gt; can overshoot the minimum, It may fail to converge, or even diverge&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그런데 이 &lt;em&gt;gradient descent&lt;/em&gt; 알고리즘의 문제는 &lt;strong&gt;local optimum&lt;/strong&gt; 수 있다는 점이다. 왜냐하면 &lt;strong&gt;local optimum&lt;/strong&gt; 에서도 &lt;code&gt;J&lt;/code&gt; 의 derivative 가 &lt;code&gt;0&lt;/code&gt; 이기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Extrema_example.svg/2000px-Extrema_example.svg.png&#34; align=&#34;center&#34; /&gt;&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Backpropagation&#34;&gt;http://en.wikipedia.org/wiki/Backpropagation&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;h3 id=&#34;gradient-descent-for-linear-regression&#34;&gt;Gradient Descent For Linear Regression&lt;/h3&gt;

&lt;p&gt;이제 &lt;em&gt;cost function&lt;/em&gt; 을 &lt;em&gt;gradient descent&lt;/em&gt; 에 집어넣고, 정리하자. &lt;code&gt;0_0(Theta zero)&lt;/code&gt;, 과 &lt;code&gt;0_1(Theta one)&lt;/code&gt; 대해서 시그마 내부 제곱을 각각 미분해서 정리하면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://pingax.com/wp-content/uploads/2013/11/Convergence-300x107.png&#34;  align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://pingax.com/linear-regression-with-r-step-by-step-implementation-part-1/&#34;&gt;http://pingax.com/linear-regression-with-r-step-by-step-implementation-part-1/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;참고로 &lt;strong&gt;Convex function&lt;/strong&gt; 은 &lt;em&gt;Bowl shaped&lt;/em&gt; 처럼 &lt;em&gt;local optima&lt;/em&gt; 가 없는 &lt;code&gt;h&lt;/code&gt;(Hypothesis) 를 말한다. 따라서 &lt;em&gt;convex function&lt;/em&gt; 을 선택할 수 있다면, 하는편이 낫다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Batch&lt;/strong&gt; &lt;em&gt;gradient descent&lt;/em&gt; 는 모든 training example 을 사용하는 &lt;em&gt;gradient descent&lt;/em&gt; 를 말한다. (시그마에서)&lt;/p&gt;

&lt;p&gt;어떤 경우에는 &lt;em&gt;gradient descent&lt;/em&gt; 같은 interative algorithm 없이도 &lt;code&gt;min J(0_0, 0_1)&lt;/code&gt; 를 풀 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;http://mercris.wordpress.com/&#34;&gt;http://mercris.wordpress.com/&lt;/a&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://mapository.tistory.com/&#34;&gt;http://mapository.tistory.com/&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://econometricsense.blogspot.kr&#34;&gt;http://econometricsense.blogspot.kr&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://pingax.com/&#34;&gt;http://pingax.com/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design and Analysis: Divide &amp; Conquer</title>
      <link>https://1ambda.github.io/algorithm/design-and-analysis-part1-1/</link>
      <pubDate>Sat, 25 Jun 2016 12:54:35 +0900</pubDate>
      
      <guid>https://1ambda.github.io/algorithm/design-and-analysis-part1-1/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Divide and Conquer (분할 정복)&lt;/em&gt; 을 배운다. &lt;em&gt;merge, quick sort&lt;/em&gt; 를 배우고 이 과정에서 왜 &lt;em&gt;combine&lt;/em&gt; 단계가 &lt;code&gt;O(n)&lt;/code&gt; 이 되어야 하는지 알아본다. 뒷부분에서는 &lt;em&gt;Big O&lt;/em&gt; 뿐만 아니라 &lt;em&gt;master method&lt;/em&gt;, &lt;em&gt;decomposition approach&lt;/em&gt; 를 이용해 성능을 분석한다.&lt;/p&gt;

&lt;h3 id=&#34;divide-and-conquer&#34;&gt;Divide and Conquer&lt;/h3&gt;

&lt;p&gt;각 level 의 문제 갯수는 &lt;code&gt;2^j (j = 0, 1, 2, ... , log2n)&lt;/code&gt; 이고 문제의 사이즈는 &lt;code&gt;n / 2^j&lt;/code&gt; 이므로 연산수를 &lt;code&gt;k&lt;/code&gt; 라 하면, 각 레벨에서 연산 수는 &lt;code&gt;k * n&lt;/code&gt;, 레벨의 &lt;em&gt;depth&lt;/em&gt; 가 &lt;code&gt;log2n + 1&lt;/code&gt; 이므로,&lt;/p&gt;

&lt;p&gt;&lt;em&gt;merge sort&lt;/em&gt; 같은 경우는 연산수 &lt;code&gt;k = 6&lt;/code&gt; 에서 &lt;code&gt;6n (log2n + 1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Big O 는 &lt;code&gt;O(f(n))&lt;/code&gt; 이라 했을때 &lt;em&gt;at most&lt;/em&gt;, &lt;code&gt;f(n)&lt;/code&gt; 에 proportional 하므로 upper 바운드.
반면 Omega 는 &lt;code&gt;omega(f(n))&lt;/code&gt; 이라 했을 때 &lt;em&gt;at least&lt;/em&gt; &lt;code&gt;f(n)&lt;/code&gt; 에 proportional 하므로 lower 바운드.&lt;/p&gt;

&lt;p&gt;분할 정복의 핵심은 각 sub-problem 에서 연산 수를 o(n) 으로 맞출 수 있느냐 없느냐, 맞춘다면 nlogn 알고리즘이 되는 것이다.&lt;/p&gt;

&lt;p&gt;알고리즘은 3단계로 구성된다.&lt;/p&gt;

&lt;p&gt;(1) Divide&lt;br /&gt;
(2) Conquer sub problems&lt;br /&gt;
(3) combine (merge)&lt;/p&gt;

&lt;p&gt;여기서 중요한건, combine 단계인데 이게 O(n) 이기만 하면 전체 알고리즘의 성능을 O(nlogn) 으로 보장할 수 있음.&lt;/p&gt;

&lt;h3 id=&#34;master-method-motivation&#34;&gt;Master Method: Motivation&lt;/h3&gt;

&lt;p&gt;T(n) 을 O(n) 으로 upper bound 를 구하긴 했지만 O(n) 연산 수 구하는게 좀 힘들다. 재귀 호출의 갯수나, 문제의 분할 사이즈로 O(n) 을 쉽게 구해보자.&lt;/p&gt;

&lt;p&gt;가우스 곱셈? 의 경우에 T(n) &amp;lt;= 4 * T(n/2) + O(n)&lt;/p&gt;

&lt;p&gt;그러나 더 작아질 수 있음. (a+b)(c+d) 에서 ad+bc = (a+b)(c+d) - ad - bd 로 구할 수 있음&lt;/p&gt;

&lt;p&gt;즉 3개의 부분식만 구해도 됌.&lt;/p&gt;

&lt;p&gt;T(n) &amp;lt;= 3 * T(n/2) + O(n)&lt;/p&gt;

&lt;p&gt;머지소트는 2 * T(n/2) + O(n) 쯤 되니까 가우스보다 더 낫긴 함. 그럼 가우스의 그것은 얼마일까?&lt;/p&gt;

&lt;h4 id=&#34;master-method&#34;&gt;Master Method&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Master method&lt;/em&gt; 는 재귀 문제의 러닝타임을 구하는데 &lt;em&gt;black box&lt;/em&gt; 같은 역할을 한다. 대강의 코드만으로도 러닝타임을 추측할 수 있다.&lt;/p&gt;

&lt;p&gt;그러나 &lt;em&gt;master method&lt;/em&gt; 는 가정을 하나 하는데, 바로 모든 문제가 같은 사이즈로 분할 된다는 것.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;All sub priblems have equal size&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 이 충분히 작다면, &lt;code&gt;T(n)&lt;/code&gt; 은 상수라 볼 수 있고 만약 &lt;code&gt;n&lt;/code&gt; 이 충분히 크다면 &lt;em&gt;master method&lt;/em&gt; 는 다음의 포맷을 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://acrocontext.files.wordpress.com/2014/01/master-method.png?w=300&amp;h=160&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;https://acrocontext.wordpress.com&#34;&gt;https://acrocontext.wordpress.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;a&lt;/code&gt; 는 재귀 함수 호출의 수고, &lt;code&gt;b&lt;/code&gt; 는 분할된 문제의 사이즈다. &lt;code&gt;d&lt;/code&gt; 는 &lt;em&gt;combine&lt;/em&gt; 스텝에서 사용하는 함수의 러닝타임의 지수다. (&lt;em&gt;merge-sort&lt;/em&gt; 에서 머징하는 함수라 보면 된다.)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;: number of recursive calls (&lt;code&gt;&amp;gt;= 1&lt;/code&gt;)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;: input size shrinkage factor (&lt;code&gt;&amp;gt; 1&lt;/code&gt;)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt;: exponent in running time of &lt;em&gt;combine step&lt;/em&gt; (&lt;code&gt;&amp;gt;= 0&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 몇 가지 예제를 좀 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;merge sort&lt;/em&gt; 의 경우는 &lt;code&gt;a = 2, b = 2, d = 1&lt;/code&gt; 이므로 &lt;code&gt;2 = 2^1&lt;/code&gt; 이어서 &lt;code&gt;O(n^1 * logn)&lt;/code&gt; 즉 &lt;code&gt;O(nlogn)&lt;/code&gt; 의 러닝타임을 가진다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;binary search&lt;/em&gt; 는 문제 수가 절반으로 줄긴 하나 반쪽만 사용하고, 매 재귀호출 마다 한번의 비교만 하므로 &lt;code&gt;a = 1, b = 2, d = 0&lt;/code&gt; 이므로 &lt;code&gt;a = b^d&lt;/code&gt; 는 &lt;code&gt;1 = 1^1&lt;/code&gt; 이 되어 &lt;code&gt;O(nlogn)&lt;/code&gt; 이 된다.&lt;/p&gt;

&lt;p&gt;가우스 곱셈은 &lt;code&gt;a = 3, b = 2, d = 1&lt;/code&gt; 이므로 &lt;code&gt;O(n^log2_3)&lt;/code&gt; 이 된다. 더 정확히는 &lt;code&gt;O(n^1.59)&lt;/code&gt; &lt;em&gt;merge-sort&lt;/em&gt; 보다 빠르진 않지만 &lt;em&gt;quadratic&lt;/em&gt; 보단 빠르다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;strassen&lt;/em&gt; 행렬 곱셈은 어떨까? &lt;code&gt;a = 7, b = 2, d = 2&lt;/code&gt; 에서 마찬가지로 &lt;em&gt;case 3&lt;/em&gt; 이므로 &lt;code&gt;O(n^log2_7)&lt;/code&gt; 이다. &lt;code&gt;O(n^2.81)&lt;/code&gt; 쯤 되므로 &lt;code&gt;O(n^3)&lt;/code&gt; 보다는 훨씬 낫다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;merge-sort&lt;/em&gt; 에서 &lt;code&gt;d = 2&lt;/code&gt; 라면 &lt;code&gt;O(n^2)&lt;/code&gt; 이 나온다. 사실 일반적으로 생각하기에는 &lt;code&gt;O(n^2 * logn)&lt;/code&gt; 이 나올거 같은데, 사실 이건 &lt;em&gt;upper bound&lt;/em&gt; 이므로 &lt;code&gt;O(n^2)&lt;/code&gt; 이 좀 더 나은 &lt;em&gt;upper bound&lt;/em&gt; 임을 알 수 있다. 이 사실은  &lt;em&gt;master method&lt;/em&gt; 를 이용하면 수학적으로 더 근사한 값을 찾아낼 수 있다는걸 알려준다.&lt;/p&gt;

&lt;h4 id=&#34;proof-master-method&#34;&gt;Proof: Master Method&lt;/h4&gt;

&lt;p&gt;재귀의 각 단계를 &lt;code&gt;j = 0, 1, 2, ... , logb_n (base b)&lt;/code&gt; 라 하면 각 단계에서는 &lt;code&gt;a^j&lt;/code&gt; 사이즈의 &lt;em&gt;sub-problem&lt;/em&gt; 수와 &lt;code&gt;n / b^j&lt;/code&gt; 사이즈의 문제가 있다.&lt;/p&gt;

&lt;p&gt;단계 &lt;code&gt;j&lt;/code&gt; 에서의 연산은 &lt;code&gt;a^j * c * (n / b^j)^d&lt;/code&gt; 즉 &lt;em&gt;문제의 수 x 각 문제의 사이즈와 일어나는 거기서 일어나는 연산 수&lt;/em&gt; 로 정의할 수 있다. 수식을 &lt;code&gt;j&lt;/code&gt; 로 다시 정리하면&lt;/p&gt;

&lt;p&gt;각 단계의 &lt;em&gt;sub problem&lt;/em&gt; 에서 일어나는 연산은 &lt;code&gt;c * n ^d * (a / b^d)^j&lt;/code&gt; 다. 따라서 전체 단계를 구하려면 여기에 시그마를 씌우면 된다.&lt;/p&gt;

&lt;p&gt;식을 좀 더 자세히 보면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;code&gt;a&lt;/code&gt;:&lt;/em&gt; rate of sub problem proliferation &lt;em&gt;(RSP)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;code&gt;b^d&lt;/code&gt;:&lt;/em&gt; rate of work shirinkage &lt;em&gt;(RWS)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;d&lt;/code&gt; 가 &lt;code&gt;n^d&lt;/code&gt; 에도 섞여있어 좀 복잡하긴 한데 느낌만 알아보자면 &lt;code&gt;b = 2, d = 1&lt;/code&gt; 일때는 &lt;em&gt;sub-problem&lt;/em&gt; 당 문제가 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; 씩 줄어든다. 하지만 &lt;code&gt;b = 2, d  = 2&lt;/code&gt; 라면 문제의 수가 2배가 될때 문제 사이즈는 4배가 되고, &lt;code&gt;b^d = 4&lt;/code&gt; 가 되어 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; 만큼의 연산만 줄어든다. 따라서 &lt;code&gt;d&lt;/code&gt; 가 커지는 건 생각보다 영향이 큰 걸 알 수 있다.&lt;/p&gt;

&lt;p&gt;위 식으로부터 다음의 관계를 이끌어 낼 수 있다.&lt;/p&gt;

&lt;p&gt;(1) if &lt;em&gt;RSP &amp;lt; RWS&lt;/em&gt;, then the amount of work is decreasing with the recursion level &lt;code&gt;j&lt;/code&gt;&lt;br /&gt;
(2) if &lt;em&gt;RSP &amp;gt; RWS&lt;/em&gt;, then the amount of work is increasing with the recursion level &lt;code&gt;j&lt;/code&gt;&lt;br /&gt;
(3) if &lt;em&gt;RSP = RWS&lt;/em&gt;, then the amount of work is same at every recursion level &lt;code&gt;j&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;(3)&lt;/code&gt; 의 경우 각 단계에서의 연산이 &lt;code&gt;c* n^d * 1^j&lt;/code&gt; 이므로 깊이 &lt;code&gt;logb_n (base b)&lt;/code&gt; 을 곱하면 &lt;code&gt;O(n^d * logn)&lt;/code&gt; 이다. &lt;em&gt;(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; 는 문제의 사이즈와 관계가 없다 그리고 더 정확히는 시그마를 더하면 &lt;code&gt;O(n^d * (1 + logb_n)&lt;/code&gt; 이다)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(2)&lt;/code&gt; 의 경우 깊이가 깊어질 수록 각 단계에서의 연산이 급격하게 줄어들고, 루트에서의 (&lt;code&gt;j = 0&lt;/code&gt;) 연산이 가장 크므로 루트에서의 연산을 &lt;em&gt;upper bound&lt;/em&gt; 로 보면 &lt;code&gt;O(n^d)&lt;/code&gt; 라 볼 수 있다.&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;code&gt;(1)&lt;/code&gt; 의 경우 깊이가 깊어질수록 연산이 늘어나고, 대충 생각하면 마지막 노드의 개수에 비례하는 &lt;em&gt;Big O&lt;/em&gt; 를 가지리라는 생각을 해볼 수 있다.&lt;/p&gt;

&lt;p&gt;좀 더 수식에 대한 이해를 얻기 위해 수학적으로 접근해 보자.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1 + r + r^2 + ... + r^k&lt;/code&gt; 를 귀납법으로 풀면 &lt;code&gt;r^(k+1) - 1 / r - 1&lt;/code&gt; 이란 값이 나온다. &lt;code&gt;(r != 1)&lt;/code&gt; 이 때&lt;/p&gt;

&lt;p&gt;&lt;code&gt;r &amp;lt; 1&lt;/code&gt; 이고 &lt;code&gt;k&lt;/code&gt; 가 충분히 크다면 이 식은 &lt;code&gt;1 / (1 - r)&lt;/code&gt; 이라 보아도 된다. 다시 말해서 &lt;code&gt;k&lt;/code&gt; 와는 관련 없는 상수라 보아도 된다는 뜻이다. 그리고 첫번 째 항이 다른 것들의 합보다 크다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;r &amp;gt; 1&lt;/code&gt; 이라 했을때, 우측 식 &lt;code&gt;r^(k+1) - 1 / r - 1&lt;/code&gt; 은 &lt;code&gt;r^k * (1 + 1 / r - 1)&lt;/code&gt; 보다 항상 작거나 같다는 사실을 알 수 있다 &lt;em&gt;(upper bound)&lt;/em&gt; 다시 말해서 마지막 항 &lt;code&gt;r^k&lt;/code&gt; 의 2배보다 작거나 같다는 사실을 알 수 있다. 이것도 &lt;code&gt;r = 2&lt;/code&gt; 일때나 맥시멈 두배다.&lt;/p&gt;

&lt;p&gt;1 부터 256까지 더해봐도 512 보다 작거나 같다는 사실을 알 수 있다. 다시 말해서 마지막 항이 그 전 모든 항을 합한 것 보다 크다.&lt;/p&gt;

&lt;p&gt;이제 다시 &lt;em&gt;master method&lt;/em&gt; 로 다시 돌아오자.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;c* n^d * sigma(j) (a / b^d)^j&lt;/code&gt; (&lt;code&gt;j = 0 to logb_n&lt;/code&gt;) 에서 &lt;code&gt;a / b^d&lt;/code&gt; 를 &lt;code&gt;r&lt;/code&gt; 이라 두자.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;RSP &amp;lt; RWS (case 2)&lt;/em&gt; 이면 &lt;code&gt;r &amp;lt; 1&lt;/code&gt; 이므로 시그마를 합해봐야 특정 상수다. &lt;code&gt;O(n^d)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;반대로 &lt;em&gt;RSP &amp;gt; RSW (case 3)&lt;/em&gt; 이면 &lt;code&gt;r &amp;gt; 1&lt;/code&gt; 이므로 시그마를 합해봐야 &lt;code&gt;r^k * 상수&lt;/code&gt; 보다 작거나 같으므로 가장 큰 항 &lt;code&gt;r^k&lt;/code&gt; 는 &lt;code&gt;(a / b^d)^logb_n&lt;/code&gt; 이다. 여기서 &lt;code&gt;b^(-dlogb_n)&lt;/code&gt; 이 &lt;code&gt;n^-d&lt;/code&gt; 라는 사실을 이용하면 &lt;code&gt;O(a^logb_n)&lt;/code&gt;만 남는다.&lt;/p&gt;

&lt;p&gt;그런데, 재미있는 사실은 &lt;code&gt;logb_n&lt;/code&gt; 이 마지막 단계이고, &lt;code&gt;a&lt;/code&gt; 는 각 단계에서 분할되는 노드의 갯수이므로 &lt;code&gt;a^(logb_n)&lt;/code&gt; 은 &lt;em&gt;recursion tree&lt;/em&gt; 에서 &lt;em&gt;leave&lt;/em&gt; 의 갯수다.&lt;/p&gt;

&lt;p&gt;다시 말해서 마지막 단계에서의 노드의 갯수에 연산이 비례한다. 근데 처음에 우리가 봤던건 &lt;code&gt;n^(logb_n)&lt;/code&gt; 아니었던가? 사실 로그를 배우면 위 두 식은 같다는걸 알 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;quick-sort&#34;&gt;Quick Sort&lt;/h3&gt;

&lt;p&gt;퀵소트는 평균적으로 &lt;code&gt;O(n logn)&lt;/code&gt; 성능을 보여주며 &lt;em&gt;in-place&lt;/em&gt; 로 작동하는 인기있는 정렬 알고리즘이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;key idea&lt;/em&gt; 는 &lt;em&gt;pivot&lt;/em&gt; 을 중심으로 문제를 좌우로 분할하는 것이다.   &lt;em&gt;less than pivot&lt;/em&gt; 들은 왼쪽에, &lt;em&gt;greater than pivot&lt;/em&gt; 들은 우측에 놓음으로써 최소한 한번의 분할당 하나의 원소 &lt;em&gt;(pivot)&lt;/em&gt; 은 자리를 잡는 다는 것을 보장한다.&lt;/p&gt;

&lt;p&gt;퀵소트의 매 호출당 일어나는 &lt;em&gt;partition (분할)&lt;/em&gt; 은 다음의 두 특징을 가진다.&lt;/p&gt;

&lt;p&gt;(1) linear time, &lt;code&gt;O(n)&lt;/code&gt;&lt;br /&gt;
(2) no extra memory&lt;/p&gt;

&lt;p&gt;대강의 로직은 이렇다. &lt;code&gt;Quicksort(array A, length n)&lt;/code&gt; 에 대해서&lt;/p&gt;

&lt;p&gt;(1) if &lt;code&gt;n = 1&lt;/code&gt; return &lt;code&gt;A&lt;/code&gt;&lt;br /&gt;
(2) &lt;code&gt;p&lt;/code&gt; = choose &lt;code&gt;Pivot(A, n)&lt;/code&gt;&lt;br /&gt;
(3) partition &lt;code&gt;A&lt;/code&gt; round &lt;code&gt;p&lt;/code&gt; =&amp;gt; &lt;code&gt;L, R&lt;/code&gt;&lt;br /&gt;
(4) recursively solve &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;보면 알겠지만 &lt;em&gt;combine&lt;/em&gt; 혹은 &lt;em&gt;merge&lt;/em&gt; 스텝이 전혀 없다.&lt;/p&gt;

&lt;h4 id=&#34;partition-in-place&#34;&gt;Partition: In-place&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;O(n)&lt;/code&gt; 의 추가 메모리를 사용하면 연산시간 &lt;code&gt;O(n)&lt;/code&gt; 을 구현하기 쉽다. 추가 메모리 없이 어떻게 &lt;code&gt;O(n)&lt;/code&gt; 으로 &lt;em&gt;partitioning&lt;/em&gt; 을 구현할 수 있을까?&lt;/p&gt;

&lt;p&gt;(1) 첫 번째 원소를 &lt;em&gt;pivot&lt;/em&gt; 이라 놓고&lt;br /&gt;
(2) &lt;em&gt;pivot&lt;/em&gt; 다음의 원소를 &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; 가 가리키게 한다.&lt;br /&gt;
(3) &lt;code&gt;j&lt;/code&gt; 보다 작은 원소들은 &lt;em&gt;partitioned&lt;/em&gt; , 큰 원소는 &lt;em&gt;unpartitioned&lt;/em&gt; 라 보고&lt;br /&gt;
(4) &lt;code&gt;i&lt;/code&gt; 보다 작은 원소들은 &lt;em&gt;pivot&lt;/em&gt; 보다 작은 값, 큰 원소들은 &lt;em&gt;pivot&lt;/em&gt; 보다 큰 값이다.&lt;br /&gt;
(5) &lt;code&gt;i &amp;lt;= j&lt;/code&gt; 이며, &lt;code&gt;i == j&lt;/code&gt; 일때는 &lt;code&gt;j&lt;/code&gt; 값을 증가시켜 원소를 비교 한뒤 &lt;code&gt;j&lt;/code&gt; 에 있는 원소가 &lt;code&gt;i&lt;/code&gt; 가 가리키는 원소보다 크면 &lt;em&gt;swap&lt;/em&gt; 하고 &lt;code&gt;i += 1, j +=1&lt;/code&gt; 아니면 &lt;code&gt;j += 1&lt;/code&gt; 한다.&lt;/p&gt;

&lt;p&gt;이해가 쉽게 그림을 첨부하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sadakurapati.files.wordpress.com/2013/10/qsort_1.png&#34; align=&#34;center&#34; /&gt;
&lt;img src=&#34;http://sadakurapati.files.wordpress.com/2013/10/qsort_2.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://sadakurapati.wordpress.com&#34;&gt;http://sadakurapati.wordpress.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이런 로직으로 &lt;code&gt;n&lt;/code&gt; 개의 원소를 순회하면, &lt;code&gt;n-1&lt;/code&gt; 번 만큼 &lt;code&gt;j&lt;/code&gt; 순회를 하고 최악의 경우 &lt;code&gt;n-1&lt;/code&gt; 번의 &lt;em&gt;swap&lt;/em&gt; 과 &lt;em&gt;i += 1&lt;/em&gt; 연산이 일어난다.  다시 말해 각 원소마다 &lt;code&gt;O(1)&lt;/code&gt; 연산이므로, &lt;em&gt;partition&lt;/em&gt; 연산은 &lt;code&gt;O(n)&lt;/code&gt; 이라 보장할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;quick-sort&lt;/em&gt; 는 귀납법으로 증명하기도 쉬운데, &lt;code&gt;P(n)&lt;/code&gt; 이 1부터 &lt;code&gt;n&lt;/code&gt; 까지의 정렬된 원소를 가지고 있는 배열이라고 하면,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;P(1)&lt;/code&gt; 임은 자명하고, 문제의 수 &lt;code&gt;k&lt;/code&gt; 에 대해 퀵소트가 &lt;code&gt;P(k)&lt;/code&gt; 일때  &lt;code&gt;P(k+1)&lt;/code&gt; 임을 보이면 &lt;code&gt;P(n)&lt;/code&gt; 에 대해서도 참임을 알 수 있다.&lt;/p&gt;

&lt;p&gt;그런데, &lt;code&gt;P(k+1)&lt;/code&gt; 에서 &lt;em&gt;pivot&lt;/em&gt; 을 제외한 좌측과 우측의 사이즈를 &lt;code&gt;k1&lt;/code&gt;, &lt;code&gt;k2&lt;/code&gt; 라 하면 &lt;code&gt;k1, k2 &amp;lt; k&lt;/code&gt; 이다. 좌측 또는 우측이 없을 때라야 &lt;code&gt;k1 or k2 = k&lt;/code&gt; 다. 이때 &lt;code&gt;P(k)&lt;/code&gt; 가 참이므로 이보다 작거나 같은 &lt;code&gt;k1, k2&lt;/code&gt; 의 문제 사이즈에 대해서도 참이다. 따라서 &lt;code&gt;P(k+1)&lt;/code&gt; 도 참이다.&lt;/p&gt;

&lt;h4 id=&#34;choosing-a-good-pivot&#34;&gt;Choosing a good pivot&lt;/h4&gt;

&lt;p&gt;그럼 &lt;em&gt;pivot&lt;/em&gt; 은 무엇을 기준으로 잡는게 좋을까? 어차피 비교에서 &lt;code&gt;i != p and j != p&lt;/code&gt; 라면 구현에는 어느 위치에 잡던 문제가 없을것 같은데..&lt;/p&gt;

&lt;p&gt;만약에 &lt;em&gt;pivot&lt;/em&gt; 이 첫 번째 원소이고, 입력이 이미 정렬이 된 배열이라면 성능이 어떻게 될까? 바로 &lt;code&gt;O(n^2)&lt;/code&gt; 이다. 왜냐하면 이미 정렬이 되어있으므로 문제가 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; 로 분할되지 않기 때문이다. 배열 사이즈만 1씩 줄어들면서 재귀호출이 반복된다.&lt;/p&gt;

&lt;p&gt;그럼 만약에, &lt;em&gt;pivot&lt;/em&gt; 을 원소들의 &lt;em&gt;median (중앙값)&lt;/em&gt; 으로 고른다면? 매 재귀마다 문제가 좌우로 분할되므로 &lt;code&gt;O(nlogn)&lt;/code&gt; 이라 볼 수 있다.&lt;/p&gt;

&lt;p&gt;근데 생각해 볼 거리가 있다. &lt;em&gt;pivot&lt;/em&gt; 을 구하는 함수의 비용은 어떻게 되는걸까? 이것 또한 &lt;code&gt;O(n)&lt;/code&gt; 이므로 전체 &lt;em&gt;partition&lt;/em&gt; 의 비용은 &lt;code&gt;O(n)&lt;/code&gt; 이라 보아도 된다.&lt;/p&gt;

&lt;h4 id=&#34;randomized-pivots&#34;&gt;Randomized pivots&lt;/h4&gt;

&lt;p&gt;그럼 만약에 &lt;em&gt;pivot&lt;/em&gt; 을 무작위로 고르면 어떻게 될까 생각해 보자. &lt;em&gt;pivot&lt;/em&gt; 을 무작위로 선택했을 때 한쪽이 &lt;code&gt;25-75%&lt;/code&gt; 로 분할될 확률은 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; 이다.&lt;/p&gt;

&lt;p&gt;그리고 무작위로 &lt;em&gt;pivot&lt;/em&gt; 을 선택했을때 첫번째 다음 재귀 호출에 넘겨질 배열의 길이의 기대값을 구하면, 다시 말해 &lt;code&gt;X&lt;/code&gt; 를 &lt;em&gt;subproblem size&lt;/em&gt; 라 했을때 &lt;code&gt;E(X)&lt;/code&gt; 를 구하면&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1/n * (0 + 1 + ... + (n - 1)) = (n - 1) / 2&lt;/code&gt; 다.&lt;/p&gt;

&lt;p&gt;여기서 잠깐 중요한 속성인 &lt;em&gt;linearity of expection&lt;/em&gt; 을 설명하면&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;모든 &lt;em&gt;random variable&lt;/em&gt; &lt;code&gt;X&lt;/code&gt; 의 합의 기대값은, 각 &lt;code&gt;X&lt;/code&gt;의 기대값의 합과 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://www.opendatastructures.org/ods-java/img333.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.opendatastructures.org&#34;&gt;http://www.opendatastructures.org&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Xj(i)P(i)&lt;/code&gt; 를 컬럼의 개수가 &lt;code&gt;j&lt;/code&gt;, 행의 개수가 &lt;code&gt;i&lt;/code&gt; 인 행렬의 원소로 보면 이 &lt;em&gt;linearity of expectation&lt;/em&gt; 은 쉽게 이해할 수 있다. 이 속성은 꽤나 유용하다.&lt;/p&gt;

&lt;p&gt;예를 들어 두개의 주사위를 독립적으로 굴린다고 할 때 나오는 값인 &lt;em&gt;random variable&lt;/em&gt; &lt;code&gt;X1, X2&lt;/code&gt; 에 대한 기대값을 직접 구하려면 36개의 &lt;em&gt;sample space&lt;/em&gt; 를 살펴봐야 하는데, 그러지 말고 하나를 굴렸을때의 값을 구해 이걸 2배 하면 된다. 하나를 굴렸을때는 6개의 &lt;em&gt;sample space&lt;/em&gt; 만 살피면 되니 금방 구한다.&lt;/p&gt;

&lt;p&gt;로드 밸런싱문제에 &lt;em&gt;linearity of expectation&lt;/em&gt; 을 적용해보자. &lt;code&gt;n&lt;/code&gt;개의 서버가 있고 여기에 &lt;code&gt;n&lt;/code&gt; 개의 프로세스를 랜덤하게 할당할때 한개의 서버에 할당될 프로세스의 기대값은 얼마일까? 다시 말해 평균적으로 몇개의 프로세스가 서버에 할당될까?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;sample space&lt;/em&gt; 는 &lt;code&gt;n&lt;/code&gt; 개의 항끼리의 곱에서 항의 개수를 구하는 문제와 같으므로 &lt;code&gt;n^n&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;이때 &lt;code&gt;Y&lt;/code&gt; 를 첫 번째 서버에 할당된 프로세스 수의 합이라 하면 이때 &lt;code&gt;Y&lt;/code&gt; 는 &lt;code&gt;sigma Xj (j = 1 to n, Xj = 1 or 0)&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;E[Y]&lt;/code&gt; 를 구하는 것이 본래의 문제인데 가능한 &lt;code&gt;Y&lt;/code&gt; 값을 모두 구한 뒤에 각각의 확률을 곱해서 더하느니, &lt;code&gt;Y&lt;/code&gt; 를 분해해 각각의 기대값을 구한 후 더하는게 훨씬 빠르다. (주사위 굴리기 문제처럼)&lt;/p&gt;

&lt;p&gt;다시 말해서, &lt;code&gt;Y&lt;/code&gt; 가 여러개의 항으로 구성될때는 각각의 기대값을 구하는게 더 계산이 빠르다는것이 &lt;em&gt;lineariry of expectation&lt;/em&gt; 의 본질이다.&lt;/p&gt;

&lt;p&gt;따라서 기대값을 시그마 뒤쪽으로 빼서 계산하면 &lt;code&gt;1&lt;/code&gt; 이 나온다. 다시 말해 서버 하나당 평균적으로 1개의 프로세스를 가진다는 이야기.&lt;/p&gt;

&lt;p&gt;다시 이 확률 테크닉을 &lt;em&gt;randomized pivot&lt;/em&gt; 을 선택하는 &lt;em&gt;merge sort&lt;/em&gt; 에 적용하러 가 보자.&lt;/p&gt;

&lt;h3 id=&#34;decomposition-principle&#34;&gt;Decomposition Principle&lt;/h3&gt;

&lt;p&gt;일단 랜덤 피벗을 가지는 퀵소트를 &lt;em&gt;master method&lt;/em&gt; 로는 &lt;em&gt;Big O&lt;/em&gt; 를 찾을 수가 없다는 사실을 알아 두자. 이는 입력한 배열이 일정하게 분할되지 않고 피벗때문에 랜덤하게 분할되지 때문이다.&lt;/p&gt;

&lt;p&gt;이제, 퀵 소트의 각 재귀에서 일어나는 연산 중 &lt;em&gt;comparison (비교)&lt;/em&gt; 가 다른 연산보다 &lt;em&gt;dominant&lt;/em&gt; 하다고 하면, 다시 말해서 비교하는 숫자에 의해 연산 수가 결정된다고 하자. 이건 생각해보면 사실인데, &lt;em&gt;partition&lt;/em&gt; 과정에서 일어나는 비교가 각 &lt;em&gt;sub-problem&lt;/em&gt; 에서의 연산 수를 결정한다.&lt;/p&gt;

&lt;p&gt;이렇게 하면 연산수의 기대값, 다시 말해서 &lt;em&gt;비교가 일어나는 회수의 평균으로&lt;/em&gt;, 퀵소트의 평균 성능을 찾아낼 수 있다.&lt;/p&gt;

&lt;p&gt;그런데 입력 배열에 대한 전체 비교 수를 &lt;code&gt;C&lt;/code&gt; 라 두면 &lt;code&gt;E(C)&lt;/code&gt; 는 사실 구하기가 굉장히 어렵다. 그런데, &lt;code&gt;E(C)&lt;/code&gt; 를 시그마 두번으로 분해할 수 있고, 심지어 가장 내부의 항은 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 을 가지는 원소이다. 따라서 &lt;em&gt;linearity of expectation&lt;/em&gt; 을 이용할 수 있다 &lt;del&gt;할렐루야&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;참고로 가장 내부의 항에 대해서 설명하자면, 전체 입력에서 두개의 원소를 골랐을 때 이 두개의 원소가 비교 되는 수다. 이 두개의 원소는 &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; 를 기준으로 구할 수 있으므로 &lt;code&gt;X_ij&lt;/code&gt; 라 두면 &lt;code&gt;i, j&lt;/code&gt; 에 각각에 대해 시그마를 씌울 수 있다. 이것이 &lt;code&gt;C&lt;/code&gt; 이므로 &lt;code&gt;E(C)&lt;/code&gt; 를 구하기는 상당히 복잡함을 알 수 있다. 그런데 &lt;code&gt;X_ij&lt;/code&gt; 자체는 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 만 가지는 값이니 이것에 대해 &lt;code&gt;E(X_ij)&lt;/code&gt; 를 구하면 심플해진다. (수식을 적기 힘드니 자세한 내용은 강의 &lt;em&gt;Analysis I: A Decomposition Principle&lt;/em&gt; 을 참조)&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;E(C)&lt;/code&gt; 는 &lt;code&gt;sigma i &amp;lt;- 1 to n-1, sigma j &amp;lt;- i+1 to n P(X_ij = 1)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;여기서 잠깐 이제 까지 나온 &lt;em&gt;decompositio principle&lt;/em&gt; 을 설명하자면&lt;/p&gt;

&lt;p&gt;(1) 구하고자 하는 랜덤 변수 &lt;code&gt;Y&lt;/code&gt; 를 정의하고&lt;br /&gt;
(2) &lt;code&gt;Y&lt;/code&gt; 를 더 간단한 랜덤 변수 &lt;code&gt;X&lt;/code&gt; 의 합으로 정의하자. &lt;code&gt;X&lt;/code&gt; 가 0 또는 1만 가지는 값이면 더 좋다.
(3) &lt;em&gt;linearity of expectation&lt;/em&gt; 을 적용&lt;/p&gt;

&lt;p&gt;다시 말해 알고리즘의 성능을 결정하는 &lt;em&gt;dominant operation&lt;/em&gt; 을 확률변수로 표현할 수 있고, 더 간단한 확률 변수의 합으로 표현할 수 있다면 해해 여기에 &lt;em&gt;기대값의 선형성&lt;/em&gt; 을 이용해 알고리즘의 평균적인 성능을 구할 수 있다는 뜻이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sigma i &amp;lt;- 1 to n-1, sigma j &amp;lt;- i+1 to n P(X_ij = 1)&lt;/code&gt; 다시 이 식으로 돌아오자. 여기에 적용할 수 있는 퀵소트의 특징이 있다. 여기서 &lt;code&gt;z_i&lt;/code&gt; 를 정렬된 배열의 &lt;code&gt;i&lt;/code&gt; 번쨰 원소라 했을때 &lt;em&gt;pivot&lt;/em&gt; 이 될 수 있는 것은 &lt;code&gt;z_i, z_i+1, ... z_j-1, z_j&lt;/code&gt; 다. 이때&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;z_i&lt;/code&gt; 또는 &lt;code&gt;z_j&lt;/code&gt; 가 &lt;em&gt;pivot&lt;/em&gt; 이 되면, 즉 가장 작은 수나 가장 큰 수가 &lt;em&gt;pivot&lt;/em&gt; 이 되면 &lt;code&gt;z_i&lt;/code&gt; 와 &lt;code&gt;z_j&lt;/code&gt; 는 한번만 비교된다. (이후에는 다른 재귀로 넘어가 둘 중 하나의 수만 남음)&lt;br /&gt;
(2) &lt;code&gt;z_i+1&lt;/code&gt;, &amp;hellip;, &lt;code&gt;z_j-1&lt;/code&gt; 이 &lt;em&gt;pivot&lt;/em&gt; 이 되면 &lt;code&gt;z_i&lt;/code&gt; 와 &lt;code&gt;z_j&lt;/code&gt; 는 절대로 비교되지 않는다. &lt;em&gt;pivot&lt;/em&gt; 기준으로 큰 수와 작은수는 서로 비교되지 않으며 둘 다 피벗과만 비교된다. 이후에도 다른 파티션으로 나누어져 비교되지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 각 &lt;em&gt;sub-problem&lt;/em&gt; 에서 일어나는 비교가 일어날 확률은 &lt;code&gt;2 / (j - i + 1)&lt;/code&gt; 이다. 다시 말해서 전체 원소 중에서 &lt;code&gt;z_i&lt;/code&gt; 와 &lt;code&gt;z_j&lt;/code&gt; 를 피벗으로 삼는 경우에만 비교가 일어난다.&lt;/p&gt;

&lt;p&gt;따라서 평균 연산 수 &lt;code&gt;E(C)&lt;/code&gt; 는 &lt;code&gt;sigma i &amp;lt;- 1 to n-1, sigma j &amp;lt;- i+1 to n [2 / (j -i + 1)]&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;이때 &lt;code&gt;j = i +1&lt;/code&gt; 부터 시작하므로 내부 시그마는 &lt;code&gt;1/2 + 1/3 + ... 1/n&lt;/code&gt; 이다. 그리고 내부 시그마에서 &lt;code&gt;i&lt;/code&gt; 가 사라졌으므로 외부 시그마 &lt;code&gt;i &amp;lt;- 1 to n-1&lt;/code&gt; 을 &lt;code&gt;n-1&lt;/code&gt; 대신 대략 &lt;code&gt;n&lt;/code&gt; 이라고 놓으면,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;E(C) &amp;lt;= 2 * n * [sigma k &amp;lt;- 2 to n (1/k)]&lt;/code&gt; 다.&lt;/p&gt;

&lt;p&gt;이때 &lt;code&gt;sigma k &amp;lt;- 2 to n (1/k)&lt;/code&gt; &amp;lt;= &lt;code&gt;ln n&lt;/code&gt; 인데, 본래 식의 &lt;code&gt;k&lt;/code&gt; 1 부터의 시그마보다 작으므로 이걸 적분으로 넓이를 구하면 &lt;code&gt;ln n - ln 1 =  ln n&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;E(C) &amp;lt;= 2 * n * ln n&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;notes&#34;&gt;Notes&lt;/h3&gt;

&lt;p&gt;이하는 필기 노트입니다.&lt;/p&gt;

&lt;h4 id=&#34;matrix-multiplication&#34;&gt;matrix multiplication&lt;/h4&gt;

&lt;p&gt;단순히 brute force 로 3 for-loop 로 구현하면 당연히 o(n^3) -_-;&lt;/p&gt;

&lt;p&gt;스트라센 매트릭스 곱셈으로 구현하면 놀랍게도 n^2&lt;/p&gt;

&lt;h4 id=&#34;multiplication&#34;&gt;Multiplication&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;define Input, output&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;assess performance&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;can we do better strait forard?&lt;/p&gt;

&lt;p&gt;일반적인 곱셈(초등3학년)은 2n * n&lt;/p&gt;

&lt;h4 id=&#34;karatsuba-multiplication&#34;&gt;Karatsuba Multiplication&lt;/h4&gt;

&lt;p&gt;a * c
b * d = 2652
(a + b)(c + d) = 6164
(a+b)(c+d) - a*c - b * d = 2840&lt;/p&gt;

&lt;p&gt;ad bc&lt;/p&gt;

&lt;p&gt;6164 + * 10000
+ 2652
+ 2840 * 100&lt;/p&gt;

&lt;p&gt;x = 10^n/2 a + b
y = 10^n/2 c + d&lt;/p&gt;

&lt;p&gt;x * y =&amp;gt; 10^n ac + 10 n/2 (ad+bc) + bd
따라서 &lt;em&gt;Karatsuba multiplication&lt;/em&gt; 은 &lt;em&gt;product&lt;/em&gt; 문제를 ac, ad, bc, bd 의 곱으로 쪼갬.&lt;/p&gt;

&lt;p&gt;여기서도, ac, ad, bc, bd 를 모두 구하는 대신에&lt;/p&gt;

&lt;p&gt;(a+b)(c+d) - ac bd 를 빼면,  ac bd (a+b)(c+d) 3개만 구하면 된다.&lt;/p&gt;

&lt;p&gt;따라서 3개의 recursive multiplication 만 필요&lt;/p&gt;

&lt;h4 id=&#34;closest-pairs&#34;&gt;Closest Pairs&lt;/h4&gt;

&lt;p&gt;brute force 는 n^2 인데,&lt;/p&gt;

&lt;p&gt;1D 의 closest pair 에서 sorting 하면 n^2 가 아니라 nlogn 이다.&lt;/p&gt;

&lt;p&gt;로직은 다음과 같다.&lt;/p&gt;

&lt;p&gt;문제를 반으로 잘라가면서 왼쪽에서 거리가 가장 짧은것 좌표 쌍, 오른쪽에서 가장 짧은것을 찾고, 각 영역에 좌표가 하나씩 있는 쌍도 검사 한다.&lt;/p&gt;

&lt;p&gt;(1) 주어진 배열을 P 라 하고 반으로 각각 좌우 Q, R 자른다. O(n) Q를 x 정렬한것을 Qx, y 축 기준으로 Qy, R도 Rx, Ry. 이건 전체 인풋 n 에 대해서 n logn&lt;br /&gt;
(2) ClosestPair(Qx, Qy), Closest(Rx, Ry) 해서 각각 좌 우에서 가장 짧은 거리를 가진 pair 쌍을 찾는다.  이걸 (p1, q1), (p2, q2)  라 하면&lt;br /&gt;
(3) (p1, q1), (p2, q2) 의 거리를 구해 최소값인 d 를 찾는다&lt;br /&gt;
(4) Closest(Px, Py, d) 해서 (p3 , q3) 가 있으면 찾아낸다. 여기서 찾은건 하나는 Q 하나는 R 에 있는 d 보다 작은 거리를 가진 점의 쌍&lt;br /&gt;
(5) p1, p2, p3 쌍중 가장 작은 d 를 가진 것을 리턴&lt;/p&gt;

&lt;p&gt;ClosestSplitPair&lt;/p&gt;

&lt;p&gt;(1) Px 의 가운데 점을 xBar 라 하면 이것 기준으로 -d, +d 의 x 값을 가진 점들을 Py 에서 찾아낸다. 정의에 의해서 x1 - x2 &amp;lt;= d 이기 때문에 아무리 커봐야 xBar 기준으로 좌우 d 까지밖에 존재하지 못함. 이걸 Sy 라 부르자. 이건 Py 가 이미 정렬되어 있기 때문에 O(n) 시간.&lt;br /&gt;
(2) Sy 는 y 축 기준으로 이미 정렬되어 있는데, 여기서 Sy 의 원소를 루프로 돌면서 이것 기준으로 +7개 원소를 검사하면서 거리가 d 보다 작은것이 있는지 검사. 이것 또한 마찬가지로 d 의 정의와 두 점이 Q, R 에 있다는 점을 이용해서 증명이 가능함.&lt;/p&gt;

&lt;p&gt;y1 - y2 도 d 보다 작거나 같이 때문에 y 기준으로 정렬된 점을 기준으로 잡았을때,&lt;/p&gt;

&lt;p&gt;p 와 같은 왼편에 있는 것들은 p와의 거리가 d 보다 작을 수 없다. 왜냐하면 d 자체가 같은 사이드에 있는 것들의 최소 거리이기 때문.
이런점들을 아무리 많이 왼쪽에 구겨 넣어도 3개. p 포함하면 4개다. 마찬가지로 q 와 같은 편에 있는것들도 3개.&lt;/p&gt;

&lt;p&gt;따라서 운이 나쁠 경우 Sy 에서 p, q + 6개를 더 검사해야.&lt;/p&gt;

&lt;p&gt;직사각형을 그려보면 이해가 쉬움.&lt;/p&gt;

&lt;p&gt;Input 은 (x1, y1) &amp;hellip; (xn, yn) 의 pair n개 편의상 p1, p2, &amp;hellip; pn&lt;/p&gt;

&lt;p&gt;d(p_i, p_j) 는 두 point 사이 거리&lt;/p&gt;

&lt;p&gt;(1) 모든 점들을 x 기준으로 정렬했을때 가운데에 있는 점을 xBar 라 하면 S_y 는 xBard - d, xBar + d 사이에 있는 모든 점이다. 만약에 왼쪽에 있는 p, 오른쪽에 있는 q 가 존재한다면 이 둘은 S_y 사이에 있고 아래 증명에 에해서 x1, x2 사이 거리는 d 보다 작다.&lt;/p&gt;

&lt;p&gt;왜냐하면, p(x1, y1), q(x2, y2) 사이의 거리가 d 보다 작기 때문에 x1 - x2 &amp;lt;= d 이다.&lt;/p&gt;

&lt;p&gt;(2) S_y 에서 p, q 가 존재한다면 그건 y 기준으로 7 원소 이내에 인접해 있다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;https://acrocontext.wordpress.com&#34;&gt;https://acrocontext.wordpress.com&lt;/a&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://sadakurapati.wordpress.com/2013/10/25/quicksort-a-practical-and-efficient-sorting-algorithm/&#34;&gt;http://sadakurapati.wordpress.com&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://www.opendatastructures.org/ods-java/1_3_Mathematical_Background.html&#34;&gt;http://www.opendatastructures.org&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Javascript Inheritance</title>
      <link>https://1ambda.github.io/javascripts/javascript-inheritance/</link>
      <pubDate>Sat, 25 Jun 2016 12:22:02 +0900</pubDate>
      
      <guid>https://1ambda.github.io/javascripts/javascript-inheritance/</guid>
      <description>

&lt;h2 id=&#34;prototype-inheritance&#34;&gt;Prototype Inheritance?&lt;/h2&gt;

&lt;p&gt;자바스크립트는 프로토타입 방식의 상속을 사용한다고들 말합니다. 프로토타입이란 무엇이고, 클래스 기반 상속과는 어떻게 다른지, 그리고 주의해야 할 점은 무엇인지 알아보겠습니다. 이 글에서 다루는 키워드는 아래와 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;.constructor&lt;/li&gt;
&lt;li&gt;.__proto__&lt;/li&gt;
&lt;li&gt;.prototype&lt;/li&gt;
&lt;li&gt;Object.create&lt;/li&gt;
&lt;li&gt;new&lt;/li&gt;
&lt;li&gt;Object, Function&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저 예제부터 보시겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create

// Shape - superclass (1)
function Shape() {
  this.x = 0;
  this.y = 0;
}

// superclass method (2)
Shape.prototype.move = function(x, y) {
    this.x += x;
    this.y += y;
    console.info(&amp;quot;Shape moved.&amp;quot;);
};

// Rectangle - subclass (3)
function Rectangle() {
  Shape.call(this); // call super constructor.
}

// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype); (4)
Rectangle.prototype.constructor = Rectangle; (5)

var rect = new Rectangle();

rect instanceof Rectangle // true.
rect instanceof Shape // true.

rect.move(1, 1); // Outputs, &amp;quot;Shape moved.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1). 먼저 &lt;code&gt;Shape&lt;/code&gt; 이라는 함수를 만듭니다. 자바스크립트에서는 객체를 생성하기 위한 함수를 &lt;code&gt;Constructor(생성자)&lt;/code&gt; 라고 부르며, 생성자임을 알아볼 수 있게 첫 글자를 &lt;strong&gt;대문자&lt;/strong&gt;로 작성하는 것이 관례입니다. 이렇게 만들어진 생성자는 &lt;code&gt;new&lt;/code&gt; 를 통해 호출할 수 있습니다. 물론 생성자는 그 자체로서 함수이기 때문에 &lt;code&gt;Shape()&lt;/code&gt; 과 같이 호출도 가능합니다. 그러나 &lt;code&gt;new&lt;/code&gt; 가 있는것과 없는것은 조금 차이가 있습니다. 아래에서 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;(2). 생성자에 존재하는 &lt;code&gt;prototype&lt;/code&gt; 속성, 즉 &lt;code&gt;Shape.prototype&lt;/code&gt; 에 &lt;code&gt;move&lt;/code&gt; 란 메소드를 추가하고 있습니다. 생성자의 &lt;code&gt;prototype&lt;/code&gt; 속성에 추가된 모든 것들은 이 생성자를 통해 생성된 모든 객체에서 사용 가능합니다. 그러나, 생성자의 &lt;code&gt;prototype&lt;/code&gt; 이 아니라, 인스턴스에 추가된 속성들은 그 인스턴스만 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt; var s1 = new Shape();
s1.move(3, 3);

s1.isShape = true;

var s2 = new Shape();
console.log (s2.isShape) // undefined
console.log (typeof s2.isShape === &amp;quot;undefined&amp;quot;) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(3). &lt;code&gt;Rectangle&lt;/code&gt; 이라는 새로운 생성자를 정의하고 있습니다. 그리고 이 생성자 내에서 &lt;code&gt;Shape.call(this)&lt;/code&gt; 를 호출하여, &lt;code&gt;new Rectangle()&lt;/code&gt; 을 통해 만들어지는 모든 인스턴스가 &lt;code&gt;Shape&lt;/code&gt; 처럼 &lt;code&gt;this.x&lt;/code&gt; 와 &lt;code&gt;this.y&lt;/code&gt; 를 가지고, 0으로 초기화 하도록 합니다. 이 과정이 끝나면 다음과 같은 결과가 나옵니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function Rectangle() {
	Shape.call(this);
}

var r1 = new Rectangle();
console.log (r1.x); // 0
console.log (r2.y); // 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러나 이 시점에서 &lt;code&gt;r1&lt;/code&gt; 은 &lt;code&gt;move&lt;/code&gt; 란 메소드를 사용할 수 없습니다. &lt;code&gt;Shape.move&lt;/code&gt; 는 있지만 이 &lt;code&gt;move&lt;/code&gt; 메소드를 상속받은것은 아닙니다. &lt;code&gt;Rectangle&lt;/code&gt; 은 단지 &lt;code&gt;this.x&lt;/code&gt;, &lt;code&gt;this.y&lt;/code&gt; 란 멤버변수를 상속받은 것 뿐입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log (r1.move); // undefined 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(4). 드디어 &lt;code&gt;Rectangle.prototye&lt;/code&gt; 에 &lt;code&gt;Shape.prototype&lt;/code&gt; 을 연결해 주어 &lt;code&gt;r1&lt;/code&gt; 에서도 &lt;code&gt;Shape.prototype&lt;/code&gt; 에 정의된 메소드들을 사용할 수 있게끔 해줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;r1.move(2, 2);
console.log(r1.x); // 2
console.log(r1.y); // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 Rectangle.prototype = Shape.prototype 을 하지않고 새롭게 Object.create 해주는 이유는, &lt;code&gt;Rectangle.prototype&lt;/code&gt; 에 새로운 속성을 추가했을때, &lt;code&gt;Shape.prototype&lt;/code&gt; 에 추가되도록 하지 않기 위함입니다. 다시 말해, &lt;code&gt;Rectangle&lt;/code&gt; 에 추가한 것은, &lt;code&gt;Rectangle&lt;/code&gt; 에만 추가되라는 것이지요.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Rectangle.prototype = new Shape();&lt;/code&gt; 처럼 &lt;code&gt;new&lt;/code&gt; 를 사용하게 되면, 생성자를 호출하게 되어 &lt;code&gt;Rectangle.prototype&lt;/code&gt; 에 인스턴스 변수인 &lt;code&gt;this.x&lt;/code&gt; 와 &lt;code&gt;this.y&lt;/code&gt; 가 추가됩니다.   이것은 우리가 원하지 않은 동작이기에, 일반적으로 &lt;code&gt;new&lt;/code&gt; 를 이용해서 프로토타입을 생성하지 않습니다.&lt;/p&gt;

&lt;p&gt;(5). &lt;code&gt;Object.create(Shape.prototype)&lt;/code&gt; 으로 생성한 객체는 &lt;code&gt;constructor&lt;/code&gt; 값으로 &lt;code&gt;Shape&lt;/code&gt; 를 가지고 있습니다. 이 객체를 이제, &lt;code&gt;Rectangle.prototype&lt;/code&gt; 에서 사용하므로 값을 변경해 줍니다.&lt;/p&gt;

&lt;h3 id=&#34;proto&#34;&gt;&lt;strong&gt;proto&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;__proto__&lt;/code&gt; 속성은 자바스크립트에서 상속의 핵심입니다. 모든 객체들은 자신의 속성을 찾다가 실패하면, &lt;code&gt;__proto__&lt;/code&gt; 를 통해 더 검색을 시도합니다. 무슨말인고 하니, 다음과 같은 코드가 있을때&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var r1 = new Rectangle();

r1.move(1, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실제로 &lt;code&gt;Rectangle&lt;/code&gt; 은 &lt;code&gt;move&lt;/code&gt; 라는 메소드를 인스턴스 멤버로도, 프로토타입 멤버로도 가지고 있지 않습니다. 다시 말해서, 아래와 같은 코드를 작성한 적이 없단 말이지요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Method per instance
function Rectangle() {
	this.move = function(_x, _y) { this.x = _x; this.y = _y; };
}

// Method for specific instance
r1.move = function(_x, _y) { this.x = _x; this.y = _y; };

// Prototype method
Rectangle.prototype.move = function(_x, _y) { this.x = _x; this.y = _y; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이런 작업을 해 준 적이 없는데, 어떻게 &lt;code&gt;move&lt;/code&gt; 메소드를 찾는걸까요? 우리는 &lt;code&gt;move&lt;/code&gt; 를 &lt;code&gt;Shape.prototype&lt;/code&gt; 에만 추가했는데요! 비결은 아래와 같습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;r1&lt;/code&gt; 인스턴스 자체에 &lt;code&gt;move&lt;/code&gt; 메소드가 인스턴스에 없기 때문에 &lt;code&gt;r1.__proto__&lt;/code&gt; 에서 탐색하게 됩니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;인스턴스가 가지고 있는 &lt;code&gt;__proto__&lt;/code&gt; 의 값은, 생성자의 프로토타입, 즉 &lt;code&gt;Rectangle.prototype&lt;/code&gt; 입니다. 따라서 이곳을 검색합니다. 그러나 &lt;code&gt;Rectangle&lt;/code&gt; 프로토타입에도 &lt;code&gt;move&lt;/code&gt; 메소드는 없습니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Rectangle.prototype.__proto__&lt;/code&gt; 를 검색합니다. &lt;code&gt;Rectangle.prototype&lt;/code&gt; 은 &lt;code&gt;Object.create(Shape.prototype)&lt;/code&gt; 을 통해 생성되었고, 이것은 인스턴스 멤버가 없는 &lt;code&gt;Shape&lt;/code&gt; 인스턴스 이기 때문에, &lt;code&gt;Rectangle.prototype.__proto__&lt;/code&gt; 의 값은 &lt;code&gt;Shape.prototype&lt;/code&gt; 이 됩니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Shape.prototype&lt;/code&gt; 에는 &lt;code&gt;move&lt;/code&gt; 가 있기 때문에, 이를 실행합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;만약 &lt;code&gt;Shape.prototype&lt;/code&gt; 에도 &lt;code&gt;move&lt;/code&gt; 가 없다면, &lt;code&gt;Shape.prototype.__proto__&lt;/code&gt; 를 탐색합니다. 모든 객체는 Default 값으로 &lt;code&gt;Object&lt;/code&gt; 를 상속받으며, &lt;code&gt;Shape&lt;/code&gt; 도 마찬가지입니다. &lt;code&gt;Shape&lt;/code&gt; 은 &lt;code&gt;Object&lt;/code&gt; 를 상속받았기 때문에 &lt;code&gt;Shape.prototype.__proto__&lt;/code&gt; 는 &lt;code&gt;Object.prototype&lt;/code&gt; 을 가리킵니다. 여기서 메소드를 검색합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;만약 &lt;code&gt;Object.prototype&lt;/code&gt; 에도 없다면, &lt;code&gt;Object.prototype.__proto__&lt;/code&gt; 를 검색하나, 이 값은 &lt;code&gt;null&lt;/code&gt; 이기 때문에 멤버 검색에 실패하고 &lt;code&gt;undefined&lt;/code&gt; 를 돌려줍니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다른 예제지만, 이미지를 통해 보는것도 이해에 도움이 될 듯 하여 이미지를 같이 첨부합니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;p&gt;
&lt;img src=&#34;http://mckoss.com/jscript/Prototype.gif&#34; /&gt;
&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;
(&lt;a href=&#34;http://mckoss.com/jscript/object.htm&#34;&gt;http://mckoss.com/jscript/object.htm&lt;/a&gt;)
&lt;/p&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;object-function&#34;&gt;Object, Function&lt;/h3&gt;

&lt;p&gt;자바스크립트의 모든 함수는 &lt;code&gt;Function&lt;/code&gt; 의 인스턴스입니다. 무슨 말인고 하니, 사용자가 정의한 함수들은 &lt;code&gt;__proto__&lt;/code&gt; 값으로 &lt;code&gt;Function.prototype&lt;/code&gt; 을 가진다는 뜻이지요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function example() {};

example.__proto__ === Function.prototype; // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;Function&lt;/code&gt; 은 &lt;code&gt;Object&lt;/code&gt; 를 상속합니다. 다시 말해,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;example.__proto__.__proto__ == Object.prototype
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 이전에 언급했듯이, &lt;code&gt;Object.prototype.__proto__&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.prototype.__proto__ === null // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;Object&lt;/code&gt; 그 자체는, &lt;code&gt;Function&lt;/code&gt; 을 상속합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.__proto__ === Function.prototype // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그래서 &lt;code&gt;Function&lt;/code&gt; 과 &lt;code&gt;Object&lt;/code&gt; 를 설명할때, 아래와 같은 그림으로 설명할 수 있습니다. 아래 그림에서 빨간 선으로 이어진 &lt;code&gt;[[Prototype]]&lt;/code&gt; 은 &lt;code&gt;__proto__&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;p align=&#34;center&#34;&gt;
&lt;img src=&#34;http://i.stack.imgur.com/rcGmc.png&#34; /&gt;
&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;
(&lt;a href=&#34;http://iwiki.readthedocs.org/en/latest/javascript/js_core.html#inheritance&#34;&gt;http://iwiki.readthedocs.org/en/latest/javascript/js_core.html#inheritance&lt;/a&gt;)
&lt;/p&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;prototype-inhertance-vs-classical-inheritance&#34;&gt;Prototype Inhertance vs Classical Inheritance&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;그래요. 프로토타입 기반 상속이란 이런거군요!. 근데 이거 왜 하는건가요?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;제 짧은 지식으로 어줍잖게 대답하는 것보다, 링크로 연결해드리는게 더 나을것 같아서 관련 링크를 적어놓습니다. 꼭 읽어보셨으면 좋겠습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/19633762/classical-inheritance-vs-protoypal-inheritance-in-javascript&#34;&gt;classical-inheritance-vs-protoypal-inheritance-in-javascript&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://aaditmshah.github.io/why-prototypal-inheritance-matters/#toc_6&#34;&gt;why-prototypal-inheritance-matters&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/2800964/benefits-of-prototypal-inheritance-over-classical&#34;&gt;benefits-of-prototypal-inheritance-over-classical&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/1450582/classical-vs-prototypal-inheritance&#34;&gt;classical-vs-prototypal-inheritance&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;new-vs-object-create&#34;&gt;new vs Object.create&lt;/h3&gt;

&lt;p&gt;위에서 잠깐 언급했듯이 일반적으로는 프로토타입 객체를 만들기 위해서 &lt;code&gt;Object.create()&lt;/code&gt;를 사용한다고 했었습니다. &lt;code&gt;new&lt;/code&gt; 대신에요. 왜 그런가 &lt;code&gt;Object.create&lt;/code&gt; 의 동작을 한번 알아보겠습니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Object.create&lt;/code&gt; 는 첫 번째 인자로 프로토타입을 받습니다.&lt;/li&gt;
&lt;li&gt;빈 객체를 하나 만들고, 이 객체의 &lt;code&gt;__proto__&lt;/code&gt; 에 인자로 받은 프로토타입 객체를 연결합니다.&lt;/li&gt;
&lt;li&gt;프로토타입이 연결된 객체를 리턴합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;아마 코드는 아래와 비슷할 겁니다. 간단한 설명을 위해 두번째 인자는 생략하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.prototype.create == function(proto) {
  var obj = {};
  obj.__proto__ = proto;
  return obj;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 어떠한 경우에도 생성자를 호출하지 않으므로 다음과 같은 코드가 생성자에 있을 경우 호출되지 않을겁니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function Shape() {
  this.x = 0;
  this.y = 0;
  
  console.log(&amp;quot;This is constructor for Shape&amp;quot;);
}

var created = Object.create(Shape.prototype);
var newed  = new Shape(); // &amp;quot;This is constructor for Shape&amp;quot; 

console.log( created.x ); // undefined
console.log( newed.x ); // 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;new&lt;/code&gt; 를 이용해 생성한 객체만 생성자가 호출되어, &lt;strong&gt;&amp;ldquo;This is constructor for Shape&amp;rdquo;&lt;/strong&gt; 가 출력되고 &lt;code&gt;this.x = 0&lt;/code&gt; 이 실행됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;new Shape()&lt;/code&gt; 의 로직은 아마 다음과 비슷할 겁니다. (더 자세한 내용은 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new&#34;&gt;MDN: new Operator&lt;/a&gt; 를 보시면 되겠습니다.)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;새로운 오브젝트를 생성하고,&lt;/li&gt;
&lt;li&gt;이 오브젝트의 &lt;code&gt;__proto__&lt;/code&gt; 에 생성자의 프로토타입 객체를 연결합니다.&lt;/li&gt;
&lt;li&gt;생성자를 호출하고, 리턴합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// new Shape();

{
  var obj = {};
  obj.__proto__ = Shape.prototype;
  return Shape.apply(obj, arguments) || obj; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 &lt;code&gt;new&lt;/code&gt; 연산자는 생성자를 호출하기 때문에, 새롭게 사용할 프로토타입 객체에 의도치 않은 속성이 추가될 수 있습니다. 위의 예에서 &lt;code&gt;Rectangle&lt;/code&gt; 에서 새롭게 사용할 프로토타입 객체는, 다시 말해 &lt;code&gt;Rectangle.prototype&lt;/code&gt; 에 들어갈 객체는 단순히 &lt;code&gt;__proto__&lt;/code&gt; 값으로 &lt;code&gt;Shape.prototype&lt;/code&gt; 만 가지고 있으면 됩니다.&lt;/p&gt;

&lt;p&gt;만약 &lt;code&gt;Object.create&lt;/code&gt; 대신 &lt;code&gt;new&lt;/code&gt; 를 사용하게 되면 &lt;code&gt;Rectangle.prototype.x&lt;/code&gt; 와 &lt;code&gt;Rectangle.prototype.y&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 으로 초기화되게 됩니다. 이는 원치 않았던 부작용입니다. 이런 이유에서 일반적인 경우에는 &lt;code&gt;new&lt;/code&gt; 대신 &lt;code&gt;Object.create&lt;/code&gt; 를 프로토타입 객체 생성에 사용해야 합니다. 아래처럼요&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;constructor&#34;&gt;.constructor&lt;/h3&gt;

&lt;p&gt;모든 프로토타입 객체들은, &lt;code&gt;constructor&lt;/code&gt; 란 프로퍼티가 있습니다. 이 값은 생성자를 가리킵니다. 그러므로 아래 코드는 &lt;code&gt;true&lt;/code&gt; 를 출력합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Rectangle.prototype.constructor === Rectangle // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;우리의 예제인 &lt;code&gt;Rectangle&lt;/code&gt; 에서도 위에 있는 코드처럼 프로토타입의 &lt;code&gt;constructor&lt;/code&gt; 값을 초기화 하고 있습니다. 왜 그래야 할까요?&lt;/p&gt;

&lt;p&gt;사실 &lt;code&gt;.constructor&lt;/code&gt; 값은 별로 의미있는 값은 아닙니다. 만약 우리가 &lt;code&gt;constructor&lt;/code&gt; 값으로 어떤 종류의 객체인지 판별한다면, 의미는 있겠지요. 그러나 일반적으로는 &lt;code&gt;instanceof&lt;/code&gt; 를 사용합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Shape() { this.x = 0; }

var s1 = new Shape();

console.log( s1.__proto__.constrctor === Shape) // true
console.log( s1 instanceof Shape) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그럼 이렇게 &lt;code&gt;constructor&lt;/code&gt; 를 비교하는 작업을 &lt;code&gt;instanceof&lt;/code&gt; 내부에서 사용하느냐, 그것도 아닙니다. &lt;code&gt;instanceof&lt;/code&gt; 는 &lt;code&gt;s1.__proto__&lt;/code&gt; 와 &lt;code&gt;Shape.prototype&lt;/code&gt; 을 비교합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.constructor&lt;/code&gt; 는 사실 정말로 쓸모가 없을지도 모르겠습니다. 그러나 자바스크립트 표준이 프로토타입 객체의 &lt;code&gt;constructor&lt;/code&gt; 프로퍼티는 생성자를 가르켜야 한다고 말하는 한, 적어도 세팅은 해주는게 나쁘지 않다는게 제 생각입니다. 아래는 관련된 논의입니다.&lt;/p&gt;

&lt;p&gt;Link : &lt;strong&gt;&lt;a href=&#34;http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property&#34;&gt;What it the significance of the javascript constructor property&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;다시 우리의 예제로 돌아와서, 코드를 살펴보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// subclass extends superclass
Rectangle.prototype = Object.create(Shape.prototype); (1)
Rectangle.prototype.constructor = Rectangle; (2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Rectangle.prototype.constuctor&lt;/code&gt; 를 다시 세팅해 주는 이유는, 이 값이 &lt;code&gt;Shape&lt;/code&gt; 이기 때문입니다. &lt;code&gt;Rectangle.protoype&lt;/code&gt; 은 &lt;code&gt;__proto__&lt;/code&gt; 를 &lt;code&gt;Shape.prototype&lt;/code&gt; 으로 가지는 오브젝트고, 따라서 (1) 라인에서 코드를 실행시켰을 때는 다음과 같은 결과가 나옵니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;console.log( Rectangle.prototype.constructor ); // Shape&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;왜냐 하면 &lt;code&gt;Rectangle.prototype&lt;/code&gt; 에는 &lt;code&gt;constructor&lt;/code&gt; 가 없기 때문에 &lt;code&gt;Rectangle.prototype.__proto__&lt;/code&gt; 에서 &lt;code&gt;constructor&lt;/code&gt; 를 찾는데, &lt;code&gt;Rectangle.prototype.__proto__&lt;/code&gt; 는 &lt;code&gt;Shape.prototype&lt;/code&gt; 이기 때문이지요.&lt;/p&gt;

&lt;p&gt;기본적으로 우리가 생성자를 만들면, 자바스크립트는 다음과 같이 프로토타입 객체를 만들고 이 프로토타입 객체의 &lt;code&gt;constructor&lt;/code&gt; 를 세팅해 줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Shape() { this.x = 0; }

console.log( Shape.prototype.constructor ); // Shape;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Rectangle.prototype.constructor&lt;/code&gt; 는 본래 처음 &lt;code&gt;Rectangle&lt;/code&gt; 생성자를 만들었을때는 &lt;code&gt;Rectangle&lt;/code&gt; 이었겠지만, (1) 라인의 코드를 실행 시킨 순간 &lt;code&gt;Shape&lt;/code&gt; 으로 변경되고, 더 정확히 이 값은 &lt;code&gt;Rectangle.prototype.__proto__.consturctor&lt;/code&gt; 에서 옵니다. 결국 값이 바뀌었기 때문에 원래대로 돌려주어야 하므로 아래와 같은 코드를 작성해준 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Rectangle.prototype.constructor = Rectangle;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자 이제, 아래 그림이 완벽히 이해되실 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;p align=&#34;center&#34;&gt;
&lt;img src=&#34;http://i.stack.imgur.com/UfXRZ.png&#34; /&gt;
&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;
(&lt;a href=&#34;http://dmitrysoshnikov.com/ecmascript/javascript-the-core/&#34;&gt;http://dmitrysoshnikov.com/ecmascript/javascript-the-core/&lt;/a&gt;)
&lt;/p&gt;
&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Interview Questions: Collection</title>
      <link>https://1ambda.github.io/java/interview-questions-collection/</link>
      <pubDate>Sat, 25 Jun 2016 12:06:44 +0900</pubDate>
      
      <guid>https://1ambda.github.io/java/interview-questions-collection/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://4.bp.blogspot.com/_b6abT-2H2yE/TSTixbyU8GI/AAAAAAAAAUU/LcqDidb_liw/s1600/screen-capture-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;general&#34;&gt;General&lt;/h3&gt;

&lt;p&gt;(1) &lt;strong&gt;Explain Collections Hierarchy?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://2.bp.blogspot.com/-M0M8nv5s2lQ/U3BcbRQcRvI/AAAAAAAAAec/oBBmQCPDm9Y/s1600/Collection-Classes.tif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://4.bp.blogspot.com/-o9Jk4Z4Tohs/U3Be46CxGTI/AAAAAAAAAeo/Wq8-hhZ8dCA/s1600/Collection-Classes_Map.tif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;(http://www.java-redefined.com)&lt;/p&gt;

&lt;p&gt;크게 보면 &lt;em&gt;Collection&lt;/em&gt; 과 &lt;em&gt;Map&lt;/em&gt; 인터페이스로 구분되어 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt; 은 &lt;em&gt;key-value pair&lt;/em&gt; 컨테이너이기 때문에 단일 원소에 대한 컨테이너인 &lt;code&gt;Collection&lt;/code&gt; 과 호환되지 않습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&lt;/code&gt; 은 중복된 원소를 허용하지 않습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&lt;/code&gt; 과 &lt;code&gt;Map&lt;/code&gt; 에 정렬 기능이 필요하면 &lt;code&gt;SortedSet&lt;/code&gt;,  &lt;code&gt;SortedMap&lt;/code&gt; 인터페이스 구현체인 &lt;code&gt;TreeMap&lt;/code&gt;, &lt;code&gt;TreeSet&lt;/code&gt; 등을 이용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) How do you remove an entry from a collection? and subsequently what is difference between &lt;code&gt;Collection.remove()&lt;/code&gt; and &lt;code&gt;Iterator.remove()&lt;/code&gt;, which one you will use, while removing elements during iteration?&lt;/p&gt;

&lt;p&gt;아래에서 언급하겠지만 &lt;em&gt;fail-fast&lt;/em&gt; 와 관련된 문제입니다. 만약 순회하고 있지 않다면 &lt;code&gt;Collection.remove()&lt;/code&gt; 를 사용해도 상관 없지만&lt;/p&gt;

&lt;p&gt;&lt;em&gt;iterator&lt;/em&gt; 를 이용해서 순회하는 동안 컬렉션의 &lt;code&gt;remove()&lt;/code&gt; 메소드를 이용하면 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 예외가 발생합니다.  따라서 &lt;code&gt;Iterator.remove()&lt;/code&gt; 를 이용해야 합니다. &lt;a href=&#34;http://stackoverflow.com/questions/14200489/collection-iterator-remove-vs-collection-remove&#34;&gt;SO 답변&lt;/a&gt;에서도 그 이유를 찾을 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// invalid
List&amp;lt;Integer&amp;gt; l = new ArrayList&amp;lt;Integer&amp;gt;(Arrays.asList(1, 2, 3, 4));
for (int el : l) {
  if (el &amp;lt; 3) {
      l.remove(el);
  }
}
    
// correct way
Iterator&amp;lt;Integer&amp;gt; it = l.iterator();
while (it.hasNext()) {
  int el = it.next();
  if (el &amp;lt; 3) {
      it.remove();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;list-interface-related&#34;&gt;List interface related&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt; 는 중복된 원소를 허용하며 &lt;em&gt;ordered elements&lt;/em&gt; 를 담는 컨테이너입니다. 때때로 &lt;em&gt;Sequence&lt;/em&gt; 라 불리기도 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(1) &lt;code&gt;Vector&lt;/code&gt; vs &lt;code&gt;ArrayList&lt;/code&gt; vs &lt;code&gt;LinkedList&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Vector&lt;/code&gt; 의 모든 메소드는 &lt;em&gt;동기화 (synchronized)&lt;/em&gt; 됩니다. &lt;code&gt;ArrayList&lt;/code&gt; 는 &lt;em&gt;thread-unsafe&lt;/em&gt; 합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vector&lt;/code&gt; 는 &lt;em&gt;JDK&lt;/em&gt; 첫 릴리즈부터 포함되어있던 레거시 클래스고, &lt;code&gt;ArrayList&lt;/code&gt; 는 &lt;em&gt;JDK 1.2&lt;/em&gt; 에서 컬렉션 프레임워크 도입과 함께 추가되었습니다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;default&lt;/em&gt; 로 &lt;code&gt;Vector&lt;/code&gt; 는 두배씩 사이즈가 커지는 반면, &lt;code&gt;ArrayList&lt;/code&gt; 는 &lt;em&gt;50%&lt;/em&gt; 씩 증가합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt; 도 &lt;em&gt;thread-unsafe&lt;/em&gt; 하기 때문에 대신 &lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html&#34;&gt;ConcurrentLinkedQueue&lt;/a&gt; 나 &lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/LinkedBlockingDeque.html&#34;&gt;LinkedBlockingDeque&lt;/a&gt; 를 이용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) What is different between &lt;code&gt;Iterator&lt;/code&gt; and &lt;code&gt;ListIterator&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Iterator&lt;/code&gt; 를 이용해 &lt;code&gt;Set&lt;/code&gt; 등 컬렉션을 순회할 수 있지만 &lt;code&gt;ListIterator&lt;/code&gt; 는 &lt;code&gt;List&lt;/code&gt; 밖에 못 합니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Iterator&lt;/code&gt; 는 &lt;em&gt;forward-only&lt;/em&gt; 지만, &lt;code&gt;ListIterator&lt;/code&gt; 는 양방향 순회가 가능합니다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ListIterator&lt;/code&gt; 는 &lt;em&gt;add&lt;/em&gt;, &lt;em&gt;replace&lt;/em&gt;, &lt;em&gt;getting index position&lt;/em&gt; 등의 기능이 더 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고로 &lt;em&gt;iterator&lt;/em&gt; 를 이용해 리스트를 순회하는 방법은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; strList = new ArrayList&amp;lt;&amp;gt;();
Iterator&amp;lt;String&amp;gt; it = strList.iterator();

while(it.hasNext()){
  String obj = it.next();
  System.out.println(obj);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;set-interface-related&#34;&gt;Set interface related&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Set&lt;/code&gt; 은 &lt;em&gt;uniqueness of elements&lt;/em&gt; 를 보장합니다. 따라서 중복된 원소를 허용하지 않습니다. 만약 &lt;em&gt;ordering&lt;/em&gt; 이 있는 &lt;code&gt;Set&lt;/code&gt; 을 사용하고 싶다면 구현체로 &lt;code&gt;TreeSet&lt;/code&gt; 을 선택하면 됩니다.&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;How HashSet store elements?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HashSet&lt;/code&gt; 은 &lt;em&gt;uniqueness&lt;/em&gt; 를 보장하기 위해 내부적으로 &lt;code&gt;Map&lt;/code&gt; 을 이용합니다. &lt;em&gt;key-value&lt;/em&gt; 를 저장하나, 모든 &lt;em&gt;value&lt;/em&gt; 를 같게끔 하죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private transient HashMap&amp;lt;E, Object&amp;gt; map;
// This is added as value for each key
private static final Object PRESENT = new Object();

public boolean add(E e) {
  return map.put(e, PRESENT) == null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2) Can a null element added to a &lt;code&gt;TreeSet&lt;/code&gt; or &lt;code&gt;HashSet&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;HashSet&lt;/code&gt; 은 하나의 &lt;em&gt;null-key&lt;/em&gt; 를 허용하지만, &lt;code&gt;TreeSet&lt;/code&gt;, &lt;code&gt;TreeMap&lt;/code&gt; 은 &lt;em&gt;null-key&lt;/em&gt; 를 허용하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TreeMap&lt;/code&gt; 은 &lt;code&gt;NavigableMap&lt;/code&gt; 의 구현이고, &lt;code&gt;TreeSet&lt;/code&gt; 은 내부적으로 &lt;code&gt;NavigableMap&lt;/code&gt; 을 사용합니다. 그런데 &lt;code&gt;NavigableMap&lt;/code&gt; 이 &lt;em&gt;null-key&lt;/em&gt; 를 허용하지 않기 때문에, &lt;code&gt;TreeSet&lt;/code&gt;, &lt;code&gt;TreeMap&lt;/code&gt; 도 그렇습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;map-interface-related&#34;&gt;Map interface related&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Map&lt;/code&gt; 은 &lt;em&gt;key-value pair&lt;/em&gt; 를 저장하기 위해 사용합니다. &lt;code&gt;Map&lt;/code&gt; 인터페이스 구현체로 &lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;LinkedHashMap&lt;/code&gt;, &lt;code&gt;HashTable&lt;/code&gt;, &lt;code&gt;EnumMap&lt;/code&gt;, &lt;code&gt;IdentityHashMap&lt;/code&gt;, &lt;code&gt;Properties&lt;/code&gt; 가 있습니다.&lt;/p&gt;

&lt;p&gt;(1) Difference between &lt;code&gt;HashMap&lt;/code&gt; and &lt;code&gt;HashTable&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HashTable&lt;/code&gt; 은 &lt;em&gt;동기화 (synchronized)&lt;/em&gt; 되지만, &lt;code&gt;HashMap&lt;/code&gt; 은 그렇지 않습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HashTable&lt;/code&gt; 은 &lt;em&gt;null-key&lt;/em&gt; 나 &lt;em&gt;null-value&lt;/em&gt; 를 허용하지 않습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HashMap&lt;/code&gt; 의 &lt;em&gt;iterator&lt;/em&gt; 는 &lt;strong&gt;fail-fast&lt;/strong&gt; 인 반면 &lt;code&gt;HashTable&lt;/code&gt; 의 &lt;em&gt;enumerator&lt;/em&gt; 는 그렇지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고로, &lt;em&gt;iterator&lt;/em&gt; 는 &lt;em&gt;iteration&lt;/em&gt; 동안 &lt;em&gt;caller&lt;/em&gt; 가 &lt;code&gt;remove&lt;/code&gt; 메소드를 이용해서 원소를 제거할 수 있지만, &lt;em&gt;enumerator&lt;/em&gt; 를 이용할때는 원소를 추가하거나 제거할 수 없습니다. 이런 기능 차이 때문에 &lt;em&gt;enumerator&lt;/em&gt; 가 기본적인 기능만 가지고 있고 더 빠릅니다. 또 다른 차이점은 &lt;em&gt;enumerator&lt;/em&gt; 는 &lt;code&gt;Stack&lt;/code&gt;, &lt;code&gt;Vector&lt;/code&gt; 처럼 레거시 클래스에 대해 사용합니다.&lt;/p&gt;

&lt;p&gt;(2) What are &lt;code&gt;IdentityHashMap&lt;/code&gt; and &lt;code&gt;WeakHashMap&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;이부분은 &lt;a href=&#34;http://howtodoinjava.com/2013/07/09/useful-java-collection-interview-questions/#identityHashMap_weakHashMap_differences&#34;&gt;원문&lt;/a&gt;을 첨부합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;IdentityHashMap&lt;/strong&gt; is similar to HashMap except that &lt;strong&gt;it uses reference equality when comparing elements&lt;/strong&gt;. IdentityHashMap class is not a widely used Map implementation. While this class implements the Map interface, it intentionally violates Map’s general contract, which mandates the use of the equals() method when comparing objects. IdentityHashMap is designed for use only in the rare cases wherein reference-equality semantics are required.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeakHashMap&lt;/strong&gt; is an implementation of the Map interface that &lt;strong&gt;stores only weak references to its keys&lt;/strong&gt;. Storing only weak references allows a key-value pair to be garbage collected when its key is no longer referenced outside of the WeakHashMap. This class is intended primarily for use with key objects whose equals methods test for object identity using the == operator. Once such a key is discarded it can never be recreated, so it is impossible to do a look-up of that key in a WeakHashMap at some later time and be surprised that its entry has been removed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;more-questions&#34;&gt;More Questions&lt;/h3&gt;

&lt;p&gt;(1) What do you understand by iterator &lt;strong&gt;fail-fast&lt;/strong&gt; property?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;fail-fast iterator&lt;/strong&gt; 는 &lt;em&gt;iteration&lt;/em&gt; 이 시작된 이후로 &lt;em&gt;collection&lt;/em&gt; 이 변경되는걸 알아채는 순간 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 던지면서 멈춥니다. 여기서 &lt;em&gt;변경&lt;/em&gt; 이란 한 스레드가 컬렉션을 순회하는 동안, 컬렉션에 있는 원소의 삭제, 변경 혹은 추가가 일어나는 것을 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;fail-fast&lt;/em&gt; 는 &lt;em&gt;modification count&lt;/em&gt; 란 것을 유지하고 있다가, &lt;em&gt;iteration thread&lt;/em&gt; 가 &lt;em&gt;modification count&lt;/em&gt; 의 변경을 알아채면 예외를 던지는 방식으로 구현됩니다.&lt;/p&gt;

&lt;p&gt;(2) What is difference between &lt;strong&gt;fail-fast&lt;/strong&gt; and &lt;strong&gt;fail-safe&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;fail-safe iterator&lt;/strong&gt; 는 복사본에 대해 컬렉션 순회를 진행하기 때문에 원본에 변경이 일어나도 멈추지 않습니다. 일반적으로 &lt;code&gt;java.util.concurrent&lt;/code&gt; 에 있는 클래스들의 (e.g &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 이나 &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;) &lt;em&gt;iterator&lt;/em&gt; 가 &lt;em&gt;fail-safe&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;p&gt;(3) How to avoid &lt;code&gt;ConcurrentModificationException&lt;/code&gt; while iterating a collection?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;먼저 &lt;em&gt;fail-safe iterator&lt;/em&gt; 를 사용할 수 있는지 확인합니다 &lt;em&gt;JDK 1.5&lt;/em&gt; 이상을 사용한다면, &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 이나 &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 를 사용할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 방법이 불가능하면 다음을 고려할 수 있으나, 퍼포먼스가 떨어질 수 있다는 점을 유의해야 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;list&lt;/em&gt; 를 &lt;em&gt;array&lt;/em&gt; 로 바꾸어, 순회합니다&lt;/li&gt;
&lt;li&gt;&lt;em&gt;list&lt;/em&gt; 를 순회하는 동안 &lt;em&gt;synchronized block&lt;/em&gt; 을 이용해 &lt;em&gt;lock&lt;/em&gt; 을 겁니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(4) What is difference between Synchronized Collection and Concurrent Collection?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Java 5&lt;/em&gt; 와 함께 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;, &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;, &lt;code&gt;BlockingQueue&lt;/code&gt; 등의 &lt;em&gt;concurrent collection&lt;/em&gt; 클래스들이 추가 되었습니다. 이 클래스들은 &lt;em&gt;synchronized collection&lt;/em&gt; 보다 성능이 더 나은데, 이는 일부분에만 &lt;em&gt;lock&lt;/em&gt; 을 걸기 때문입니다. 더 자세한 내용은 &lt;a href=&#34;http://javarevisited.blogspot.kr/2011/04/difference-between-concurrenthashmap.html&#34;&gt;여기로&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(5) What is &lt;code&gt;Comparable&lt;/code&gt; and &lt;code&gt;Comparator&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;자바에서 &lt;code&gt;TreeSet&lt;/code&gt; 이나 &lt;code&gt;TreeMap&lt;/code&gt; 처럼 &lt;em&gt;automatic sorting&lt;/em&gt; 기능이 있는 모든 컬렉션은 &lt;code&gt;compare&lt;/code&gt; 메소드를 사용합니다.&lt;/p&gt;

&lt;p&gt;이 때 &lt;em&gt;element class&lt;/em&gt; 는 정렬을 위해 &lt;code&gt;Comparator&lt;/code&gt; &lt;strong&gt;또는&lt;/strong&gt; &lt;code&gt;Comparable&lt;/code&gt; 인터페이스를 반드시 구현해야 합니다. &lt;em&gt;wrapper class&lt;/em&gt; 인 &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt; 등이 &lt;code&gt;Comparable&lt;/code&gt; 인터페이스를 구현하는 이유가 바로 이것입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Comparable&lt;/code&gt; 은 원소가 컬렉션에 추가될때 자동적으로 정렬되도록 (&lt;em&gt;natural sorting&lt;/em&gt;) 하기 위해 사용하고, &lt;code&gt;Comparator&lt;/code&gt; 는 추가적인 정렬방법을 이용하기 위해 정의할 수 있습니다. &lt;a href=&#34;http://www.java2blog.com/2013/02/difference-between-comparator-and.html&#34;&gt;여기&lt;/a&gt;서 가져온 예제를 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Comparable
public class Country implements Comparable&amp;lt;Country&amp;gt;{
       @Override
    public int compareTo(Country country) {
        return (this.countryId &amp;lt; country.countryId ) ? -1: (this.countryId &amp;gt; country.countryId ) ? 1:0 ;
}} 

// Comparator

Country indiaCountry=new Country(1, &amp;quot;India&amp;quot;);
Country chinaCountry=new Country(4, &amp;quot;China&amp;quot;);
Country nepalCountry=new Country(3, &amp;quot;Nepal&amp;quot;);
Country bhutanCountry=new Country(2, &amp;quot;Bhutan&amp;quot;);
        
List&amp;lt;Country&amp;gt; listOfCountries = new ArrayList&amp;lt;Country&amp;gt;();
listOfCountries.add(indiaCountry);
listOfCountries.add(chinaCountry);
listOfCountries.add(nepalCountry);
listOfCountries.add(bhutanCountry); 

Collections.sort(listOfCountries,new Comparator&amp;lt;Country&amp;gt;() {
  @Override
  public int compare(Country o1, Country o2) {
    return o1.getCountryName().compareTo(o2.getCountryName());
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;http://howtodoinjava.com/2013/07/09/useful-java-collection-interview-questions/#why_map_not_extend_collection&#34;&gt;Useful Java Collection Interview Questions&lt;/a&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://websphereemerge.blogspot.kr/&#34;&gt;Title Image&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://www.java-redefined.com/2014/05/java-collection-interview-questions.html&#34;&gt;http://www.java-redefined.com&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://www.java2blog.com/2013/02/difference-between-comparator-and.html&#34;&gt;http://www.java2blog.com/&lt;/a&gt;&lt;br /&gt;
(5) &lt;a href=&#34;http://www.javatpoint.com/java-collections-interview-questions&#34;&gt;http://www.javatpoint.com&lt;/a&gt;&lt;br /&gt;
(6) &lt;a href=&#34;http://stackoverflow.com/questions/14200489/collection-iterator-remove-vs-collection-remove&#34;&gt;SO:  Iterator.remove() vs Collection.remove()&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CC 02: Gossip Protocol</title>
      <link>https://1ambda.github.io/cloud-computing/cloud-computing-2/</link>
      <pubDate>Sat, 25 Jun 2016 14:42:40 +0900</pubDate>
      
      <guid>https://1ambda.github.io/cloud-computing/cloud-computing-2/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://ook.co/wp-content/uploads/cloudcomputing.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;multicast&#34;&gt;Multicast&lt;/h3&gt;

&lt;p&gt;이번시간에 배울 내용은 &lt;em&gt;Gossip Protocol&lt;/em&gt; (혹은 &lt;em&gt;Epidemic Protocol&lt;/em&gt;) 입니다.&lt;/p&gt;

&lt;p&gt;기존에는 특정 그룹에게 메세지를 보내기 위해 &lt;em&gt;multicast&lt;/em&gt; 를 이용했지만, 클라우드 컴퓨티 환경에서는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;프로세스가 죽어 노드가 크래쉬를 일으킬수도&lt;/li&gt;
&lt;li&gt;네트워크 문제때문에 패킷이 딜레이되거나, 드랍될 수 있고&lt;/li&gt;
&lt;li&gt;노드가 빠르게 증가합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 멀티캐스트는 &lt;em&gt;fault-tolerance&lt;/em&gt; 와 &lt;em&gt;scalability&lt;/em&gt; 측면에서 부족한 부분이 많았습니다. 이런 문제를 해결하기 위해 다양한 방법이 도입되었는데&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Centralized:&lt;/strong&gt; 중앙 서버에서 &lt;em&gt;TCP, UDP&lt;/em&gt; 패킷을 날립니다. 간단한 구현이지만 중앙서버의 오버헤드가 높고, 수천개의 노드가 있을때 &lt;em&gt;latency&lt;/em&gt; 가 생깁니다. 노드의 수를 &lt;code&gt;N&lt;/code&gt; 이라 했을때, 모든 노드에 메시지가 전달되는데 &lt;code&gt;O(N)&lt;/code&gt; 시간이 걸리지요.&lt;/p&gt;

&lt;p&gt;(2) &lt;strong&gt;Tree-Based:&lt;/strong&gt; 전달 받은 노드에서, 다시 패킷을 전달하여 경로가 &lt;em&gt;tree&lt;/em&gt; 형태로 구성됩니다. &lt;em&gt;balanced tree&lt;/em&gt; 라면 어떤 그룹에 패킷이 전달되는데 &lt;code&gt;O(logN)&lt;/code&gt; 의 시간이 걸립니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/tree_based_multicast.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 방법의 단점은&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;tree&lt;/em&gt; 를 구성하고 유지하는데 필요한 오버헤드&lt;/li&gt;
&lt;li&gt;&lt;em&gt;root&lt;/em&gt; 에 가까운 곳에서 &lt;em&gt;failure&lt;/em&gt; 가 발생했을때의 파급력&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 &lt;em&gt;tree-based multicast&lt;/em&gt; 프로토콜에서는 &lt;em&gt;spanning tree&lt;/em&gt; 를 구성해서 최단비용으로 패킷을 전달합니다. 그리고 메시지가 올바르게 전달되었는지 &lt;em&gt;ACK&lt;/em&gt; 또는 &lt;em&gt;NAK&lt;/em&gt; 를 이용하는데 &lt;em&gt;SRM&lt;/em&gt; 이던 &lt;em&gt;RMTP&lt;/em&gt; 던 여전히 &lt;code&gt;O(N)&lt;/code&gt; 만큼의 &lt;em&gt;ACK/NAK&lt;/em&gt; 오버헤드가 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;gossip&#34;&gt;Gossip&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/gossip_example1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/gossip_example2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;가십 프로토콜은 위 그림처럼 작동합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;주기적으로 랜덤한 타겟을 골라 &lt;em&gt;gossip message&lt;/em&gt; 를 전송합니다&lt;/li&gt;
&lt;li&gt;그리고 이것을 받아 &lt;em&gt;infected&lt;/em&gt; 상태가 된 노드도 똑같이 행동합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이걸 &lt;em&gt;Push gossip&lt;/em&gt; 이라 부릅니다. &lt;em&gt;multiple message&lt;/em&gt; 를 가십하기 위해 랜덤 서브셋을 선택하거나, &lt;em&gt;recently-received&lt;/em&gt; 메시지를 를 선택하거나, &lt;em&gt;higher priority one&lt;/em&gt; 을 고를 수 있습니다.&lt;/p&gt;

&lt;p&gt;어떤 가십 메시지에 대해 대부분의 노드가 &lt;em&gt;infected&lt;/em&gt; 되었을때 &lt;em&gt;push gossip&lt;/em&gt; 은 비효율적입니다. 이때는 &lt;em&gt;uninfected&lt;/em&gt; 노드가, 새로운 가십메시지가 있는지 주변 노드에게 물어보는 &lt;strong&gt;pull gossip&lt;/strong&gt; 이 오버헤드가 더 적습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pull gossip:&lt;/strong&gt; Periodically poll a few random selected processes for new multicast meesages that you haven&amp;rsquo;t received&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;gossip-analysis&#34;&gt;Gossip Analysis&lt;/h3&gt;

&lt;p&gt;가십프로토콜은 다음의 특징을 가집니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;lightweight&lt;/strong&gt; in large groups&lt;/li&gt;
&lt;li&gt;spreads a multicast quickly&lt;/li&gt;
&lt;li&gt;highly &lt;em&gt;fault-tolerant&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이를 위해 간단한 증명을 해보도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;전체 &lt;code&gt;n+1&lt;/code&gt; 의 &lt;em&gt;population&lt;/em&gt; 에 대해&lt;/li&gt;
&lt;li&gt;&lt;em&gt;uninfected individuals&lt;/em&gt; 의 수를 &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;infected individuals&lt;/em&gt; 의 수를 &lt;code&gt;y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;individual pair&lt;/em&gt; 간의 &lt;em&gt;contract rate&lt;/em&gt; 를 &lt;code&gt;β&lt;/code&gt; 라 하면&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;항상 &lt;code&gt;x + y = n + 1&lt;/code&gt; 이고, 시작상태에서는 &lt;code&gt;x_0 = n, y_0 = 1&lt;/code&gt; 입니다. 그리고 시간이 지날때마다 &lt;em&gt;uninfected&lt;/em&gt; &lt;code&gt;y&lt;/code&gt; 는 다음처럼 감소합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%5Cfrac%7B%5Cmathrm%7Bd%7D%20x%7D%7B%5Cmathrm%7Bd%7D%20t%7D%20%3D%20-%5Cbeta%20xy&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그러면 이 수식으로부터 다음을 이끌어 낼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?x%20%3D%20%7B%20n%28n&amp;amp;plus;1%29%20%5Cover%20%7Bn%20&amp;amp;plus;%20e%5E%7B%5Cbeta%28n&amp;amp;plus;1%29t%7D%7D%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?y%20%3D%20%7B%20%28n&amp;amp;plus;1%29%20%5Cover%20%7B1%20&amp;amp;plus;%20ne%5E%7B-%5Cbeta%28n&amp;amp;plus;1%29t%7D%7D%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 &lt;em&gt;infected node&lt;/em&gt; 가 랜덤하게 &lt;code&gt;b&lt;/code&gt; 개의 노드를 고른다 하면 &lt;code&gt;β&lt;/code&gt; 는&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%5Cbeta%20%3D%20%7Bb%20%5Cover%20b%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 시간 &lt;code&gt;t&lt;/code&gt; 를 가십이 진행되는 &lt;em&gt;round&lt;/em&gt; 라 보고 &lt;code&gt;t = clog(n)&lt;/code&gt; 이라 치환하겠습니다. 다음을 이끌어낼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?y%20%5Capprox%20%28n&amp;amp;plus;1%29%20-%20%7B1%20%5Cover%20n%5E%7Bcb-2%7D%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 식으로부터 &lt;em&gt;gossip protocol&lt;/em&gt; 이 &lt;em&gt;low latency&lt;/em&gt;, &lt;em&gt;reliability&lt;/em&gt;, &lt;em&gt;lightweight&lt;/em&gt; 하다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;low latency&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;c, b&lt;/code&gt; 를 &lt;code&gt;n&lt;/code&gt; 과 독립적으로 아주 작은 숫자로 세팅하면 &lt;code&gt;clog(n)&lt;/code&gt; &lt;em&gt;round&lt;/em&gt; 이므로 적은 시간 내에 메시지가 전파됩니다.&lt;/p&gt;

&lt;p&gt;(2) &lt;strong&gt;reliability&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 이 매우 크면 &lt;code&gt;1 / n^{cb-2}&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 에 가까워지므로, &lt;code&gt;1 / n^{cb-2}&lt;/code&gt; 만큼의 노드를 제외한 모든 노드가 &lt;em&gt;infected&lt;/em&gt; 된다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;(3) &lt;strong&gt;lightweight&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;각 노드는 &lt;code&gt;cb log(n)&lt;/code&gt; 만큼의 &lt;em&gt;gossip message&lt;/em&gt; 만 전파합니다. 이론적으로는 &lt;code&gt;log(N)&lt;/code&gt; 은 상수가 아니지만, 실제로는 아주 천천히 증가하는 숫자기에 작은 숫자처럼 생각할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;fault-tolerance&#34;&gt;Fault-Tolerance&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;50% packet loss&lt;/em&gt; 를 생각해 봅시다. &lt;code&gt;b&lt;/code&gt; 를 &lt;code&gt;2/b&lt;/code&gt; 로 치환하면 됩니다. 그러면 이전과 같은 &lt;em&gt;reliability&lt;/em&gt; &lt;em&gt;0% packet loss&lt;/em&gt; 를 위하 두배의 &lt;em&gt;round&lt;/em&gt; 만큼만 더 진행하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;node failure&lt;/em&gt; 는 어떨까요? 50% 노드에서 &lt;em&gt;failure&lt;/em&gt; 가 발생한다면 &lt;code&gt;n, b&lt;/code&gt; 을 &lt;code&gt;2/n, 2/b&lt;/code&gt; 으로 치환하면 됩니다. 이는 &lt;em&gt;contract rate&lt;/em&gt; 에서 가십 메시지를 전달하는 &lt;code&gt;n&lt;/code&gt; 중 &lt;code&gt;2/n&lt;/code&gt; 의 노드만 살아있고, 선택되는 &lt;code&gt;b&lt;/code&gt; 중 &lt;code&gt;b/2&lt;/code&gt; 노드만 살아있기 때문입니다. 이 경우에도 상수만 곱하면 이전과 같은 &lt;em&gt;reliability&lt;/em&gt; 를 얻을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;failure&lt;/em&gt; 와 관련해서 한 가지 생각해 볼 문제가 있습니다. 모든 노드가 죽는것이 가능할까요? 물론 가능합니다 초기에 모든 노드가 죽으면요. 그러나 &lt;em&gt;improbable&lt;/em&gt; 입니다. 일단 몇개의 노드가 &lt;em&gt;infected&lt;/em&gt; 되면, 이후에는 퍼지는 속도가 훨씬 더 빠르기 때문입니다. 루머나 바이러스가 퍼질 수 있는 이유를 생각하면 이해하기 쉽습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;pull-gossip&#34;&gt;Pull Gossip&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/pull_gossip_analysis.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그림에서 볼 수 있듯이, 어떤 형태의 가십 프로토콜이던 &lt;code&gt;2/N&lt;/code&gt; 까지 전달할때는 &lt;code&gt;O(logN)&lt;/code&gt; 만큼의 시간이 걸립니다. 그 이후에는 &lt;em&gt;pull gossip&lt;/em&gt; 이 훨씬 빠르죠.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;i&lt;/code&gt; &lt;em&gt;round&lt;/em&gt; 후에 남아있는 &lt;em&gt;uninfected node&lt;/em&gt; 의 수를 &lt;code&gt;p_i&lt;/code&gt; 라 합시다. &lt;em&gt;pull gossip&lt;/em&gt; 을 이용할때 다음 단계에서도 &lt;em&gt;uninfected&lt;/em&gt; 일 확률은&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?p_%7Bi&amp;amp;plus;1%7D%20%3D%20p_i%5E%7Bk&amp;amp;plus;1%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이는 &lt;code&gt;p_i&lt;/code&gt; 자체가 &lt;em&gt;uninfected&lt;/em&gt; 여야 하고, 이 노드가 선택하는 &lt;code&gt;k = b&lt;/code&gt; 만큼의 노드도 &lt;em&gt;uninfected&lt;/em&gt; 여야 하는데, 이 확률은 극히 낮습니다. 슬라이드에서 보듯이 &lt;em&gt;super-exponential&lt;/em&gt; 하고, 그렇기 때문에 &lt;em&gt;second half&lt;/em&gt; 부터는 &lt;em&gt;pull gossip&lt;/em&gt; 이 &lt;code&gt;O(log(logN))&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;topology-aware-gossip&#34;&gt;Topology-Aware Gossip&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/topology_aware_gossip.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;em&gt;uninfected node&lt;/em&gt; 를 &lt;em&gt;uniformly random&lt;/em&gt; 하게 고른다면 위 그림에서 라우터의 오버헤드는 &lt;code&gt;O(N)&lt;/code&gt; 이 됩니다. 더 정확하게는 &lt;em&gt;round&lt;/em&gt; 마다 &lt;code&gt;b * (2/n)&lt;/code&gt; 이 될겁니다.&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해, 서브넷에 &lt;code&gt;n_i&lt;/code&gt; 개의 노드가 있을때 자신이 속한 서브넷에 있는 &lt;em&gt;uninfected node&lt;/em&gt; 를 더 자주 고르게, 확률을 &lt;code&gt;1 - (1/n_i)&lt;/code&gt; 가 되도록 합니다. 그러면, 현재 서브넷에 있는 노드를 선택할 확률이 1 에 가까우므로 &lt;code&gt;O(logN)&lt;/code&gt; 시간 내에 전파되고, 라우터의 오버헤드는 &lt;code&gt;(n_i) / (n_i)&lt;/code&gt; 가 되어, &lt;code&gt;O(1)&lt;/code&gt; 이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;refs&#34;&gt;Refs&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;http://ook.co/solutions/cloud-computing/&#34;&gt;Title Image&lt;/a&gt;&lt;br /&gt;
(2) &lt;strong&gt;Cloud Computing Concept 1&lt;/strong&gt; by &lt;em&gt;Indranil Gupta&lt;/em&gt;, Coursera&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ML 02: Gradient Descent</title>
      <link>https://1ambda.github.io/data-analysis/machine-learning-week-2/</link>
      <pubDate>Sat, 25 Jun 2016 14:25:17 +0900</pubDate>
      
      <guid>https://1ambda.github.io/data-analysis/machine-learning-week-2/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Machine Learning&lt;/strong&gt; by Andrew Ng, &lt;em&gt;Coursera&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;linear-regression-with-multiple-variables&#34;&gt;Linear Regression with Multiple Variables&lt;/h2&gt;

&lt;h3 id=&#34;mutiple-features&#34;&gt;Mutiple Features&lt;/h3&gt;

&lt;p&gt;변수가 적을때는 &lt;em&gt;Hypothesis&lt;/em&gt; 가 간단하다. 많으면 어떻게 될까? &lt;em&gt;Feature&lt;/em&gt; 가 &lt;code&gt;N+1&lt;/code&gt; 개라면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://bt22dr.files.wordpress.com/2013/05/04_2.png?w=300&amp;h=19&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;http://bt22dr.wordpress.com&#34;&gt;http://bt22dr.wordpress.com&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;편의상 &lt;code&gt;x_0 = 1&lt;/code&gt; 이라 두면, &lt;em&gt;Hypothesis&lt;/em&gt; 는 &lt;em&gt;Zero-based index&lt;/em&gt; 인 &lt;code&gt;n+1&lt;/code&gt; 벡터 &lt;code&gt;h&lt;/code&gt; 와 &lt;code&gt;x&lt;/code&gt; 의 곱이다. 따라서 &lt;code&gt;h(x) = h_t * x&lt;/code&gt; 로 표기할 수 있다. 이걸 &lt;strong&gt;Mutivariate linear regression&lt;/strong&gt; 이라 부른다.&lt;/p&gt;

&lt;h3 id=&#34;gradient-descent-for-multiple-variables&#34;&gt;Gradient Descent for Multiple Variables&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Cost function&lt;/em&gt; 은 다음과 같다. 변수의 subscript 는 &lt;code&gt;j&lt;/code&gt; 번째 &lt;em&gt;Feature&lt;/em&gt; 를, superscript 는 &lt;code&gt;i&lt;/code&gt; 번째 데이터임을 말한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://bt22dr.files.wordpress.com/2013/05/04_6.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://bt22dr.wordpress.com/&#34;&gt;http://bt22dr.wordpress.com/&lt;/a&gt;)&lt;/p&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;다음은 &lt;em&gt;Gradient Descent&lt;/em&gt; 알고리즘을 구하는 정의다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://bt22dr.files.wordpress.com/2013/05/04_7.png?w=300&amp;h=104&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://bt22dr.wordpress.com/&#34;&gt;http://bt22dr.wordpress.com/&lt;/a&gt;)&lt;/p&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;따라서&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://bt22dr.files.wordpress.com/2013/05/04_8.png?w=630&amp;h=354&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://bt22dr.wordpress.com/&#34;&gt;http://bt22dr.wordpress.com/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;h3 id=&#34;feature-scaling&#34;&gt;Feature Scaling&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Feature&lt;/em&gt; 간 데이터 크기가 많이 차이가 나면, &lt;em&gt;Gradient Descent&lt;/em&gt; 에서 등고선 간 간격이 좁으므로, &lt;em&gt;Global optima&lt;/em&gt; 를 찾는데 오래걸릴 수 있다. 따라서 &lt;em&gt;Feature&lt;/em&gt; 값을 &lt;code&gt;m&lt;/code&gt; 으로 나누거나  -1 과 1 사이로 &lt;em&gt;scaliing&lt;/em&gt; 할 수 있다. 거꾸로 말하면, &lt;em&gt;Feature scaling&lt;/em&gt; 을 이용하면 &lt;em&gt;Gradient descent&lt;/em&gt; 가 결과값을 더 빠르게 찾는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.stack.imgur.com/4RBjR.png&#34; align=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;p&gt;또한 &lt;strong&gt;Mean normalization&lt;/strong&gt; 을 이용할 수 있는데, 모든 &lt;em&gt;feature&lt;/em&gt; 에서 평균을 빼서, 평균을 0 으로 만드는 방법이다.&lt;/p&gt;

&lt;p&gt;더 일반적인 방법은 &lt;em&gt;mean normalization&lt;/em&gt; 을 하고, 거기에 &lt;code&gt;max-min&lt;/code&gt; 또는 &lt;em&gt;standard deviation&lt;/em&gt; 으로 나누는 방법이다.&lt;/p&gt;

&lt;h3 id=&#34;learning-rate&#34;&gt;Learning Rate&lt;/h3&gt;

&lt;p&gt;디버깅 팁 중 하나는, 우리가 작성한 &lt;em&gt;Gradient descent&lt;/em&gt; 알고리즘이 매 &lt;em&gt;interation&lt;/em&gt; 마다 줄어들어야 한다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://d37rcl8t6g8sj5.cloudfront.net/wp-content/uploads/gradient_descent_error_by_iteration.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://spin.atomicobject.com&#34;&gt;http://spin.atomicobject.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;그리고, 어느 지점에선가 &lt;em&gt;converged&lt;/em&gt; 되는지 검사하기 위해 &lt;em&gt;automatic convergence test&lt;/em&gt; 를 사용할 수 있다. 예를 들어 한 이터레이션에서, 10^-3 보다 적게 줄어드는지 검사한다거나.&lt;/p&gt;

&lt;p&gt;만약에 &lt;em&gt;gradient descent&lt;/em&gt; 값이 증가하면, 더 작은 &lt;em&gt;learning rate&lt;/em&gt; 를 사용해라. 그렇다고 너무 작은 값을 사용하면 &lt;em&gt;gradient descent&lt;/em&gt; 가 느리게 수렴할 수 있다. &lt;em&gt;learning rate&lt;/em&gt; 가 너무 크면, 심지어 수렴하지 않을 수도 있다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;learning rate&lt;/em&gt; 를 &lt;code&gt;0.001&lt;/code&gt;, &lt;code&gt;0.003&lt;/code&gt;, &lt;code&gt;0.01&lt;/code&gt;, &lt;code&gt;0.03&lt;/code&gt;, &lt;code&gt;0.1&lt;/code&gt;, &lt;code&gt;0.3&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; 처럼 작은 것부터 선택하되, 천천히 늘려가는 것이 좋다.&lt;/p&gt;

&lt;h3 id=&#34;polynomial-regression&#34;&gt;Polynomial Regression&lt;/h3&gt;

&lt;p&gt;집값을 예측하기 위해 두개의 &lt;em&gt;feature&lt;/em&gt;, &lt;code&gt;frontage&lt;/code&gt; 와 &lt;code&gt;depth&lt;/code&gt; 가 있다고 하자. 두 값을 곱해 &lt;code&gt;area&lt;/code&gt; 라는 새로운 &lt;em&gt;feature&lt;/em&gt; 를 만들면, &lt;em&gt;Hypothesis&lt;/em&gt; 가 간단해진다. 따라서 기존의 &lt;em&gt;feature&lt;/em&gt; 를 이용 할 수 있는지도 잘 알아보는 게 좋다.&lt;/p&gt;

&lt;p&gt;자 이제, 집 값(Housing prices) 을 예측하기 위해 &lt;em&gt;Size(Area)&lt;/em&gt; 라는 &lt;em&gt;feature&lt;/em&gt; 를 이용한다 하자. &lt;em&gt;training set&lt;/em&gt; 이 다음과 같을때,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/01_02_Introduction_regression_analysis_and_gr_files/Image.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;http://www.holehouse.org/mlclass&#34;&gt;http://www.holehouse.org/mlclass&lt;/a&gt;&lt;/p&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;hypothesis&lt;/em&gt; 를 &lt;em&gt;quadratic&lt;/em&gt; 로 세우면 어느 지점부터는 예측된 값이 감소하므로 &lt;em&gt;traning set&lt;/em&gt; 과 일치하지 않는다. 따라서 &lt;em&gt;cubic&lt;/em&gt; 다항식을 이용해 볼 수 있겠는데, &lt;em&gt;feature&lt;/em&gt; 가 &lt;code&gt;size&lt;/code&gt; 하나 뿐이므로, &lt;em&gt;hypothesis&lt;/em&gt; 는 &lt;code&gt;size&lt;/code&gt; 를 이용한 삼차식이 되겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/04_Linear_Regression_with_multiple_variables_files/Image%20[10].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;&lt;a href=&#34;http://www.holehouse.org/mlclass&#34;&gt;http://www.holehouse.org/mlclass&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이 경우 &lt;code&gt;size&lt;/code&gt; 하나로 3개의 &lt;em&gt;feature&lt;/em&gt; 를 만들었으니, &lt;em&gt;scaling&lt;/em&gt; 이 문제가 될 수 있다.&lt;/p&gt;

&lt;p&gt;이 전에 앞서서 &lt;em&gt;feature&lt;/em&gt; 가 두개인 &lt;em&gt;hypothesis&lt;/em&gt; (quadratic) 은 말이 안된다고 했는데, 두개지만 &lt;em&gt;square&lt;/em&gt; 모델을 사용하면 우리가 가진 &lt;em&gt;training set&lt;/em&gt; 과 얼추 맞아 떨어지는 모델을 찾을 수 있다. 그림이 없어서 대충 식을 첨부하면,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;h(x) = y0 + y1(size) + y2 * square(size)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;y&lt;/code&gt; 는 강의에서 말하는 &lt;code&gt;0(theta)&lt;/code&gt; 라 보면 된다.&lt;/p&gt;

&lt;h3 id=&#34;nomal-equation&#34;&gt;Nomal Equation&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;gradient descent&lt;/em&gt; 는 반복하면서 특정 값에 수렴해 가는 알고리즘 이었지만 &lt;strong&gt;normal equation&lt;/strong&gt; 은 그냥 &lt;code&gt;J(0)&lt;/code&gt; 식을 풀어버려 값을 찾아낸다.&lt;/p&gt;

&lt;p&gt;예를 들어서 &lt;code&gt;J(0)&lt;/code&gt; 가 &lt;code&gt;0(theta)&lt;/code&gt; 에 대해  &lt;em&gt;quadratic&lt;/em&gt; 이면, &lt;code&gt;0&lt;/code&gt; 에 대해 미분해서 최저점을 찾아내면 된다. 문제는, &lt;code&gt;0&lt;/code&gt; 가 여러개 일때, 모든 &lt;code&gt;0_j&lt;/code&gt; 에 대해 &lt;em&gt;cost function&lt;/em&gt; 을 풀어야 한다는 것이다. &lt;em&gt;partial derivative&lt;/em&gt; 를 이용해서 해를 찾으면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.longhaiqiang.com/wp-content/uploads/2013/08/Snip20130817_44.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.longhaiqiang.com/&#34;&gt;http://www.longhaiqiang.com/&lt;/a&gt;)&lt;/p&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;행렬을 이용할 수도 있다. 자세한 건 강의 내용을 보자, &lt;em&gt;design matrix&lt;/em&gt; 라고 부르는 &lt;code&gt;X&lt;/code&gt; 를 만들어서 아래의 식을 구하면 된다. 사실 &lt;code&gt;X&lt;/code&gt; 는 그냥 &lt;em&gt;feature&lt;/em&gt; 들을 있는 그대로 행렬로 만들면 된다. 맨 앞에 &lt;code&gt;x0&lt;/code&gt; 만 추가해서.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.longhaiqiang.com/wp-content/uploads/2013/08/Snip20130817_41.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.longhaiqiang.com/&#34;&gt;http://www.longhaiqiang.com/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;참고로, 저 식을 &lt;em&gt;Octave&lt;/em&gt; 에서는 다음과 같이 계산한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-octave&#34;&gt;pinv(X`*X)*X`*y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;normal equation&lt;/em&gt; 을 이용할때는 &lt;em&gt;feature scaling&lt;/em&gt; 을 하지 않아도 괜찮다. &lt;em&gt;gradient descent&lt;/em&gt; 와 비교해 보자면,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Gradient Descent:&lt;/strong&gt; &lt;br/&gt;
(1) &lt;em&gt;learning rate&lt;/em&gt; 를 골라야 한다.
(2) &lt;em&gt;feature scaling&lt;/em&gt; 을 해야할 필요가 있다.&lt;br /&gt;
(3) &lt;em&gt;interation&lt;/em&gt; 을 해야하므로 알고리즘이 제대로 돌아가는지 체크해야할 필요가 있다.&lt;br /&gt;
(4) 대신 &lt;code&gt;n&lt;/code&gt; 이 커도 잘 돌아간다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Normal Equation:&lt;/strong&gt; &lt;br/&gt;
(1) &lt;em&gt;learning rate&lt;/em&gt; 를 고를 필요가 없다.&lt;br /&gt;
(2) &lt;em&gt;feature scaling&lt;/em&gt; 을 해야할 필요가 없다.&lt;br /&gt;
(3) &lt;em&gt;interation&lt;/em&gt; 을 하지 않는다.&lt;br /&gt;
(4) &lt;code&gt;n&lt;/code&gt; 이 커질경우 굉장히 느려지고 &lt;code&gt;(X^TX)^-1)&lt;/code&gt; 을 계산해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 &lt;code&gt;n&lt;/code&gt; 이 너무 크지 않으면, 100~1000 정도까지는, &lt;em&gt;normal equation&lt;/em&gt; 을 쓰는편이 낫다.&lt;/p&gt;

&lt;h3 id=&#34;nomal-equation-noninvertibility&#34;&gt;Nomal Equation Noninvertibility&lt;/h3&gt;

&lt;p&gt;만약에, 우리가 가진 &lt;code&gt;X&lt;/code&gt; 가 &lt;em&gt;non-invertible&lt;/em&gt; 하다면 어떻게 될까? &lt;em&gt;invertible matrix&lt;/em&gt; 란, 아래를 만족시키는 &lt;code&gt;B&lt;/code&gt; 가 존재하는 행렬이다. &lt;code&gt;I&lt;/code&gt; 는 &lt;em&gt;identity matrix&lt;/em&gt; 다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/math/7/3/3/7334597613ae1773c19e1ed1289349db.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://en.wikipedia.org/wiki/Invertible_matrix&#34;&gt;http://en.wikipedia.org/wiki/Invertible_matrix&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;만약 저런 &lt;code&gt;B&lt;/code&gt; 가 존재하지 않아 &lt;em&gt;non-invertible&lt;/em&gt; 한 행렬을 &lt;strong&gt;sigular matrix&lt;/strong&gt;, &lt;strong&gt;degenerate matrix&lt;/strong&gt; 라 부른다.&lt;/p&gt;

&lt;p&gt;우리가 계산해야 할 행렬이 &lt;em&gt;non-invertible&lt;/em&gt; 이라면, 두 가지 경우가 있을 수 있는데,&lt;/p&gt;

&lt;p&gt;(1) Redundant features(linearly dependent) e.g &lt;code&gt;x1 = (3.28) * x2&lt;/code&gt;&lt;br /&gt;
(2) too many features e.g &lt;code&gt;m &amp;lt;= n&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이럴 때는 몇몇 &lt;em&gt;feature&lt;/em&gt; 를 삭제하고, &lt;em&gt;regulaization&lt;/em&gt; 을 하면 된다.&lt;/p&gt;

&lt;h3 id=&#34;cost-function-octave&#34;&gt;Cost Function: Octave&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;cost function&lt;/em&gt; 을 구현 해 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-matlab&#34;&gt;function J = costFunctionJ(X, y, theta)

m = size(X, 1) % number of training examples
predictions= X * theta; % predictions of hypothesis on all m examples
sqrErros = (predictions-y).^2;

J = 1 / (2*m) * sum(sqrErros);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;R&lt;/em&gt; 이나 이런것들은 행렬연산이 참 쉬운것 같다.&lt;/p&gt;

&lt;h3 id=&#34;vectorization&#34;&gt;Vectorization&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Vectorization&lt;/em&gt; 을 이용하면, &lt;code&gt;for loop&lt;/code&gt; 을 제거할 수 있는데, 예를 들어&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.ytimg.com/vi/jRr2XuZOWB8/hqdefault.jpg&#34; align=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이건 행렬 곱셈이 한번에 이루어진다는 것을 이용한 방법이다. 따라서 &lt;em&gt;gradient descent&lt;/em&gt; 알고리즘에서 &lt;code&gt;theta&lt;/code&gt; 를 &lt;code&gt;for-loop&lt;/code&gt; 으로 구하는 것이 아니라, &lt;em&gt;vectorization&lt;/em&gt; 을 이용하면 한번에 계산할 수 있다.&lt;/p&gt;

&lt;p&gt;이게 그림을 구하기가 어려운데, 아래첨자(sub-script) 를 이렇게 기술한다고 하자. &lt;code&gt;x_0&lt;/code&gt; 그럼, &lt;em&gt;grandient descent&lt;/em&gt; 알고리즘 식에서 &lt;em&gt;learning rate&lt;/em&gt; 뒷부분이 &lt;em&gt;vector&lt;/em&gt; 가 되는데 그 이유는 &lt;code&gt;theta&lt;/code&gt; 와 마찬가지로 &lt;code&gt;j&lt;/code&gt; 에 대한 나열이기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://2.bp.blogspot.com/-ZxJ87cWjPJ8/TtLtwqv0hCI/AAAAAAAAAV0/9FYqcxJ6dNY/s1600/gradient+descent+algorithm+OLS.png&#34; align=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;p&gt;구글에 검색하니까 1번으로 뜨는게 &lt;em&gt;vectorization(parallel computing)&lt;/em&gt; 이더라. 병렬 연산에 많이 사용되나보다.&lt;/p&gt;

&lt;h3 id=&#34;refenrences&#34;&gt;Refenrences&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;http://stats.stackexchange.com/questions/111467/is-it-necessary-to-scale-the-target-value-in-addition-to-scaling-features-for-re&#34;&gt;StackExchange&lt;/a&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://bt22dr.wordpress.com/&#34;&gt;http://bt22dr.wordpress.com/&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://spin.atomicobject.com/2014/06/24/gradient-descent-linear-regression/&#34;&gt;http://spin.atomicobject.com&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://www.holehouse.org/mlclass/01_02_Introduction_regression_analysis_and_gr.html&#34;&gt;http://www.holehouse.org/mlclass/&lt;/a&gt;&lt;br /&gt;
(5) &lt;a href=&#34;http://www.longhaiqiang.com/&#34;&gt;http://www.longhaiqiang.com/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design and Analysis: Randomized Selection</title>
      <link>https://1ambda.github.io/algorithm/design-and-analysis-part1-2/</link>
      <pubDate>Sat, 25 Jun 2016 12:54:47 +0900</pubDate>
      
      <guid>https://1ambda.github.io/algorithm/design-and-analysis-part1-2/</guid>
      <description>

&lt;h3 id=&#34;intuition&#34;&gt;Intuition&lt;/h3&gt;

&lt;p&gt;중복이 없는 &lt;code&gt;n&lt;/code&gt; 개의 원소를 가진 배열에서 &lt;code&gt;i&lt;/code&gt; 번째로 큰 원소를 얻고 싶다고 하자. 간단한 방법은 먼저 정렬을 한 뒤 거기서 &lt;code&gt;i&lt;/code&gt; 번째 원소를 고르면 된다. 이 방법을 &lt;em&gt;reduction&lt;/em&gt; 이라 부르는데 &lt;em&gt;selection&lt;/em&gt; 문제를 &lt;em&gt;sorting&lt;/em&gt; 문제로 바꾸어 푼 것이다. 이 경우 정렬에 머지소트를 사용한다면 &lt;code&gt;O(n logn)&lt;/code&gt; 만큼의 시간이 걸릴 것이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;selection&lt;/em&gt; 문제는 &lt;code&gt;O(n)&lt;/code&gt; 시간 안에 &lt;em&gt;deterministic&lt;/em&gt; 하게 해결할 수 있다. 지난시간에 잠깐 논의했던 &lt;em&gt;randomization&lt;/em&gt; 을 이용하면 된다. 어떻게 그럴 수 있을까? 저기서 정렬을 더 개선할 수 없다는건 모두가 알고 있는 사실인데&lt;/p&gt;

&lt;p&gt;&lt;em&gt;quick sort&lt;/em&gt; 를 수정해서 &lt;em&gt;pivot&lt;/em&gt; 을 &lt;em&gt;median of medians&lt;/em&gt; 로 고르면 된다. &lt;del&gt;아니 의사양반 이게 무슨 개소리요!&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;더 정확히 말해서 이 문제는 &lt;strong&gt;정렬 문제가 아니기 때문에&lt;/strong&gt; 더 개선할 여지가 있다. &lt;em&gt;pivot&lt;/em&gt; &lt;code&gt;P&lt;/code&gt; 를 기준으로 좌측이나 우측 한쪽만 선택하면 되는 &lt;em&gt;selection&lt;/em&gt; 문제다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;worst case&lt;/em&gt; 는 당연히 매 재귀호출마다 문제 수가 1씩 줄어드는 경우이므로 &lt;code&gt;O(n^2)&lt;/code&gt; 일테다. 만약에, &lt;em&gt;bast case&lt;/em&gt; 로 문제가 절반씩 줄어든다면? &lt;em&gt;master method&lt;/em&gt; 를 이용하면 &lt;code&gt;a = 1, b = 2, d = 1&lt;/code&gt; 에서 &lt;code&gt;T(n) = O(n^1)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://acrocontext.files.wordpress.com/2014/01/master-method.png?w=300&amp;amp;h=160&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그럼 이제 문제는 어떻게 사이즈를 &lt;code&gt;1/2&lt;/code&gt; 로, 더 정확히는 &lt;em&gt;median&lt;/em&gt; 을 &lt;em&gt;pivot&lt;/em&gt; 으로 삼느냐다.&lt;/p&gt;

&lt;h3 id=&#34;analysis&#34;&gt;Analysis&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;randomized selection&lt;/em&gt; 문제를 풀기 위해 구현한 함수를 &lt;code&gt;rSelect&lt;/code&gt; 라 하자. 매 재귀마다 문제 사이즈가 &lt;code&gt;n&lt;/code&gt; 이라고 하면, 각 재귀에서의 &lt;code&gt;rSelect&lt;/code&gt; 의 연산은 &lt;code&gt;c * n&lt;/code&gt; 보다 작거나 같다. (&lt;code&gt;c&lt;/code&gt; 는 상수)&lt;/p&gt;

&lt;p&gt;이제 본격적인 분석전에  잠깐 &lt;em&gt;notation&lt;/em&gt; 을 하나 만들고 가면 &lt;code&gt;phase j&lt;/code&gt; 는 문제의 사이즈가 &lt;code&gt;(3/4)^j+1 * n&lt;/code&gt; 과 &lt;code&gt;(3/4)^j * n&lt;/code&gt; 사이에 있는 &lt;code&gt;rSelect&lt;/code&gt; 다. 따라서 문제의 사이즈가 &lt;code&gt;n&lt;/code&gt; 부터 &lt;code&gt;3/4&lt;/code&gt; 가 되기 전까지의 모든 &lt;code&gt;rSelect&lt;/code&gt; 는 &lt;code&gt;phase 0&lt;/code&gt; 에 있다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code&gt;Xj&lt;/code&gt; 를 &lt;code&gt;phase j&lt;/code&gt; 에 있는 &lt;code&gt;rSelect&lt;/code&gt; 호출의 수라 정의하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20%5Csum_%7Bphase%20j%7D%20X_j%20*%20c%20*%20%28%7B3%20%5Cover%204%7D%29%5Ej%20*%20n&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 정의해 놓으면 재밌는 조건을 하나 쓸 수 있다. 바로 &lt;em&gt;pivot&lt;/em&gt; 이 &lt;code&gt;25%-75%&lt;/code&gt; 사이로 분할만 해주면, 다시 말해서 반으로 갈린 문제 중 작은 한쪽이 적어도 &lt;code&gt;25%&lt;/code&gt; 가 넘으면 현재 &lt;em&gt;phase&lt;/em&gt; 가 끝난다. 그럼 이제 전체 알고리즘의 기대값을 구하기 위해 &lt;em&gt;linearity of expectation&lt;/em&gt; 을 이용해서 &lt;code&gt;E(Xj)&lt;/code&gt; 를 구하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;25-75%&lt;/code&gt; 로 피벗이 걸릴 확률 &lt;code&gt;P(25-75%) = 1/2&lt;/code&gt; 이고 그럴때의 &lt;code&gt;Xj = 1&lt;/code&gt; 이다. 반면 두번째에 피벗이 제대로 걸릴 확률은 &lt;code&gt;1/4&lt;/code&gt; 이고, 세번째에 피벗이 제대로 걸릴 확률은 &lt;code&gt;1/2^3&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;기대값은 이 모든 각각 확률변수값과 그 확률의 곱이므로 계산하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%7B1%20%5Cover%202%7D%20&amp;amp;plus;%20%7B1%20%5Cover%202%5E2%7D%20&amp;amp;plus;%20%7B1%20%5Cover%202%5E3%7D%20&amp;amp;plus;%20%5Ccdots%20%5Cleq%202&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이것 말고 더 재밌는 계산법도 있다. 자세한 건 강의 내용을 참조&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?E%28X_j%29%20%3D%201%20&amp;amp;plus;%20%7B1%20%5Cover%202%7D%20*%20E%28X_j%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;em&gt;average running&lt;/em&gt; 타임을 구하기 위해 &lt;code&gt;T(n)&lt;/code&gt; 의 평균을 구하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20E%5Bc%20*%20n%20*%20%5Csum_%7Bphase%20j%7D%20%28%7B3%20%5Cover%204%7D%29%5Ej%20*%20X_j%5D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;em&gt;linearity of expectation (기대값의 선형성)&lt;/em&gt; 을 이용하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20c%20*%20n%20*%20%5Csum_%7Bphase%20j%7D%20%28%7B3%20%5Cover%204%7D%29%5Ej%20*%20E%28X_j%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20c%20*%20n%20*%20%5Csum_%7Bphase%20j%7D%202%20*%20%28%7B3%20%5Cover%204%7D%29%5Ej&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;무한급수 공식을 적용하면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20c%20*%20n%20*%204&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;얼마나 멋진가?&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&#34;deterministic-selection&#34;&gt;Deterministic Selection&lt;/h3&gt;

&lt;p&gt;만약에 &lt;em&gt;randomization&lt;/em&gt; 을 이용할 수 없다면? 그럼 이제 문제는 &lt;em&gt;good pivot&lt;/em&gt;, 즉 &lt;code&gt;50/50&lt;/code&gt; 에 최대한 가깝게 잘라내는 &lt;em&gt;pivot&lt;/em&gt; 을 찾아야 한다. &lt;em&gt;median of medians&lt;/em&gt; 를 이용하면 해낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;deterministic selection&lt;/em&gt; 알고리즘을 구현한 함수를 &lt;code&gt;dSelect&lt;/code&gt; 라 부르면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dSelect(array A, length n, order statistic i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1) Break &lt;code&gt;A&lt;/code&gt; into groups of 5, sort each group&lt;br /&gt;
(2) C = the &lt;code&gt;n/5&lt;/code&gt; &amp;ldquo;middle elements&amp;rdquo;&lt;br /&gt;
(3) p = &lt;code&gt;dSelect(C, n/5, n/10)&lt;/code&gt;, recursivly computes median of C&lt;br /&gt;
(4) Partition &lt;code&gt;A&lt;/code&gt; around &lt;code&gt;p&lt;/code&gt;&lt;br /&gt;
(5) if &lt;code&gt;j = i&lt;/code&gt; return &lt;code&gt;p&lt;/code&gt;&lt;br /&gt;
(6) if &lt;code&gt;j &amp;lt; i&lt;/code&gt; return &lt;code&gt;dSelect(1st part of A, j-1, i)&lt;/code&gt;&lt;br /&gt;
(7) if &lt;code&gt;j &amp;gt; i&lt;/code&gt; return &lt;code&gt;dSelect(2nd part of A, j-j, i-j)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;4-7&lt;/code&gt; 스텝은 &lt;em&gt;randomized selection&lt;/em&gt; 과 똑같다. 더 복잡해진 부분은 앞의 &lt;code&gt;1-3&lt;/code&gt; 스텝에서 피벗을 고르는 일이다.&lt;/p&gt;

&lt;p&gt;퍼포먼스를 다시 이야기 해 보자 &lt;em&gt;randomized selection&lt;/em&gt; 은 &lt;em&gt;pivot&lt;/em&gt; 이 정말 나쁘게 선택되면 &lt;code&gt;O(n^2)&lt;/code&gt; 이 될 수 있다.&lt;/p&gt;

&lt;p&gt;반면 &lt;em&gt;deterministic selection&lt;/em&gt; 은 모든 경우에 &lt;code&gt;O(n)&lt;/code&gt; 을 보장한다. 그러나 실제로는 &lt;em&gt;randomized&lt;/em&gt; 보다 성능이 나쁜데, 이유는 알고리즘에서 볼 수 있듯이 새로운 배열 &lt;code&gt;C&lt;/code&gt; 가 필요하고 (&lt;em&gt;not in-place&lt;/em&gt;), 표기법에는 상수가 생략되는데 &lt;em&gt;deterministic selection&lt;/em&gt; 은 이 상수가 꽤나 커질 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;analysis-1&#34;&gt;Analysis&lt;/h3&gt;

&lt;p&gt;이제 좀 더 자세히 살펴보자.&lt;/p&gt;

&lt;p&gt;(1) Break &lt;code&gt;A&lt;/code&gt; into groups of 5, sort each group&lt;/p&gt;

&lt;p&gt;이건 얼마의 시간이 걸릴까? 주어진 배열을 5개씩 짜르고, 각각의 그룹을 정렬하는데 걸리는 시간은? &lt;code&gt;O(n)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code&gt;n = 120&lt;/code&gt; 이라 하자. 정렬에 &lt;em&gt;merge sort&lt;/em&gt; 를 사용하면 &lt;em&gt;merge sort&lt;/em&gt; 연산 수 공식은&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?6n%20*%20log_2%28n&amp;amp;plus;1%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;따라서 잘려진 5개짜리를 정렬하는데 걸리는 시간은 &lt;code&gt;30 * log_2(6)&lt;/code&gt; 에서, 이 값은 적어도 120 보다는 작음을 알 수 있다. 따라서 전체 그룹의개수 &lt;code&gt;n/5&lt;/code&gt; 를 곱하면, &lt;code&gt;24n&lt;/code&gt; 으로 &lt;code&gt;O(n)&lt;/code&gt; 임을 알 수 있다. 비록 상수가 좀 크긴 하지만&lt;/p&gt;

&lt;p&gt;(2) C = the &lt;code&gt;n/5&lt;/code&gt; &amp;ldquo;middle elements&amp;rdquo;&lt;br /&gt;
(3) p = &lt;code&gt;dSelect(C, n/5, n/10)&lt;/code&gt;, recursivly computes median of C&lt;br /&gt;
(4) Partition &lt;code&gt;A&lt;/code&gt; around &lt;code&gt;p&lt;/code&gt;&lt;br /&gt;
(5) if &lt;code&gt;j = i&lt;/code&gt; return &lt;code&gt;p&lt;/code&gt;&lt;br /&gt;
(6) if &lt;code&gt;j &amp;lt; i&lt;/code&gt; return &lt;code&gt;dSelect(1st part of A, j-1, i)&lt;/code&gt;&lt;br /&gt;
(7) if &lt;code&gt;j &amp;gt; i&lt;/code&gt; return &lt;code&gt;dSelect(2nd part of A, j-j, i-j)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(2), (4) 는 &lt;code&gt;O(n)&lt;/code&gt; 임을 알 수 있고, (3) 은 &lt;code&gt;T(n/5)&lt;/code&gt; 다. 문제는 (6), (7) 이다. 둘 중에 하나만 호출되긴 하지만 선택되는 &lt;em&gt;pivot&lt;/em&gt; &lt;code&gt;p&lt;/code&gt; 에 따라서 문제의 사이즈가 달라진다. 모르니까 &lt;code&gt;T(?)&lt;/code&gt; 라 두자 그러면 &lt;em&gt;determinitic selection&lt;/em&gt; 의 &lt;em&gt;running time&lt;/em&gt; 은&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&amp;amp;plus;%20T%28n/5%29%20&amp;amp;plus;%20T%28%3F%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;간단한 가설을 세워보자.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;두번째 &lt;code&gt;dSelect&lt;/code&gt; 호출의 input size 는 &lt;code&gt;7/10 * n&lt;/code&gt; 보다 작거나 같다&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그러면 수식을 이렇게 바꿀 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&amp;amp;plus;%20T%28n/5%29%20&amp;amp;plus;%20T%287n/10%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;(2) 에서 &lt;em&gt;medians&lt;/em&gt; 를 찾고, 이걸 (3)에서 재귀에 한번 더 넘기면 &lt;em&gt;median of medians&lt;/em&gt; 을 찾게된다. 이게 어떤 효과가 있냐면, 모든 원소를 5개씩 짤라 아래에서 위로 정렬, &lt;em&gt;medians&lt;/em&gt; 는 좌에서 우로 정렬하면 다음과 같은 행렬이 나오는데&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/gaOxb1A.jpg?1&#34; alt=&#34;&#34; /&gt;&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://functionspace.org/articles/19&#34;&gt;http://functionspace.org/articles/19&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;모든 원소 중 좌측 하단에 있는 &lt;code&gt;30%&lt;/code&gt; 는 &lt;em&gt;median of medians&lt;/em&gt; 보다 분명히 작다. 그리고 우측 상단 &lt;code&gt;30%&lt;/code&gt; 는 &lt;em&gt;medians of medians&lt;/em&gt; 보다 분명히 크다. 따라서 나머지 40% 값이 어쨌던건 간에 적어도 &lt;code&gt;30-70%&lt;/code&gt; 분할은 해주므로 문제의 사이즈가 (6) 스텝에서 &lt;code&gt;7n/10&lt;/code&gt; 보다 작거나 같다는 것을 분명히 보장해준다. 따라서 아래 식은 참이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&amp;amp;plus;%20T%28n/5%29%20&amp;amp;plus;%20T%287n/10%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;쉽게 &lt;em&gt;master method&lt;/em&gt; 를 이용하고 싶은데 문제가 서로 다른 사이즈로 분할되니까 사용할 수 없다. &lt;em&gt;induction&lt;/em&gt; 을 이용하자. 아래가 참임을 보이면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20an&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;우선 &lt;em&gt;base case&lt;/em&gt; 는 &lt;code&gt;T(1) = 1&lt;/code&gt; 이므로 &lt;code&gt;T(1) &amp;lt;= a (where a &amp;gt;= 1)&lt;/code&gt; 에서 참이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&amp;amp;plus;%20T%28n/5%29%20&amp;amp;plus;%20T%287n/10%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이제 위 식에서 &lt;em&gt;induction hypothesis&lt;/em&gt; 를 이용하고, 정리하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20cn%20&amp;amp;plus;%20a%28n/5%29%20&amp;amp;plus;%20a%287n/10%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20n%20*%20%289a/10%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 때 &lt;code&gt;c&lt;/code&gt; 는 상수이므로 &lt;code&gt;c = a / 10&lt;/code&gt; 이라 하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?T%28n%29%20%5Cleq%20an&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;em&gt;deterministic selection&lt;/em&gt; 의 성능은 &lt;code&gt;O(n)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&#34;lower-bound-for-sorting&#34;&gt;lower bound for sorting&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;comparison-based sorting&lt;/em&gt; 의 &lt;em&gt;lower bound&lt;/em&gt; 는&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?%0A%5COmega%20(n*log%20n)&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;여기 해당되는 정렬들은 &lt;em&gt;merge sort, quick sort, heap sort&lt;/em&gt; 등이 있다. 이런 정렬들은 데이터가 어떠할 것이라는 가정 없이 정렬을 해낸다.&lt;/p&gt;

&lt;p&gt;반면 데이터의 분포를 안다면 &lt;em&gt;bucket sort&lt;/em&gt; 같은 경우 &lt;em&gt;linear time&lt;/em&gt; 으로 해결할 수 있다. &lt;em&gt;counting sort&lt;/em&gt; 나 &lt;em&gt;radix sort&lt;/em&gt; 같은 정렬도 데이터에 대한 정보(정수)라는 것을 이미 알고 있는 경우이므로 &lt;code&gt;O(n)&lt;/code&gt; 으로 정렬 가능하다.&lt;/p&gt;

&lt;p&gt;데이터에 대한 정보를 모른다고 해 보자. &lt;code&gt;1, 2, ..., n&lt;/code&gt; 까지의 데이터를 가지고 있다면 이 데이터들이 배열 안에 담겨있을 수 있는 경우의 수는 &lt;code&gt;n!&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;n!&lt;/code&gt; 개의 모든 종류의 인풋에 대해서 &lt;code&gt;k&lt;/code&gt; 번만큼, 혹은 그보다 더 적게 비교가 일어난다고 하자. 그럼 모든 &lt;code&gt;n!&lt;/code&gt; 종류의 인풋에 대해서 &lt;code&gt;2^k&lt;/code&gt; 개의 서로 다른 &lt;em&gt;execution&lt;/em&gt; 이 생긴다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose algorithm always makes &amp;lt;= k comparisons to correctly sort these &lt;code&gt;n!&lt;/code&gt; inputs. Across all &lt;code&gt;n!&lt;/code&gt; possile inputs algorithms exhibits &amp;lt;= &lt;code&gt;2^k&lt;/code&gt; distinct executions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;쉽게 생각해서 &lt;code&gt;k-bit&lt;/code&gt; 문자열이 있을때 이걸로 얻을 수 있는 문자열은 &lt;code&gt;2^k&lt;/code&gt; 개수다. 즉 어떤 문자는 없을수도 있다.&lt;/p&gt;

&lt;p&gt;비둘기 집 원리를 생각해 보자. 우리는 &lt;code&gt;n!&lt;/code&gt; 비둘기가 있고, &lt;code&gt;2^k&lt;/code&gt; 개의 비둘기 집이 있다. 만약에 &lt;code&gt;k&lt;/code&gt; 가 작아 &lt;code&gt;2^k &amp;lt; n!&lt;/code&gt; 이면 서로 다른 두개의 인풋에 대해서 같은 종류의 &lt;em&gt;execution&lt;/em&gt; 을 공유 한다는 뜻이다. 따라서 둘 중 하나는 제대로 정렬되고, 나머지 하나는 제대로 정렬되지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;2^k &amp;gt;= n!&lt;/code&gt; 이다. 이때&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?n%21%20%5Cgeq%20n%20*%20%28n-1%29%20*%20%28n-2%29%20%5Ccdots%20%28n/2%29%20%5Cgeq%20%28n/2%29%5E%7B%28n/2%29%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이므로&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?2%5Ek%20%5Cgeq%20%28n/2%29%5E%7Bn/2%7D&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?k%20%5Cgeq%20%28n/2%29*%20log_2%28n/2%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.codecogs.com/gif.latex?k%20%5Cgeq%20%5COmega%28n*logn%29&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;k&lt;/code&gt; 가 연산 수 이므로 &lt;em&gt;comparison-based sorting&lt;/em&gt; 의 &lt;em&gt;lower bound&lt;/em&gt; 는 &lt;code&gt;Omega(n logn)&lt;/code&gt; 이다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;em&gt;Algorithms: Design and Analysis, Part 1&lt;/em&gt; by &lt;strong&gt;Tim Roughgarden&lt;/strong&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://functionspace.org/articles/19&#34;&gt;http://functionspace.org/articles/19&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tips for Webpack and Redux</title>
      <link>https://1ambda.github.io/javascripts/tips-for-webpack-and-redux/</link>
      <pubDate>Sat, 25 Jun 2016 12:24:38 +0900</pubDate>
      
      <guid>https://1ambda.github.io/javascripts/tips-for-webpack-and-redux/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/redux/redux_logo.png?width=30%&amp;amp;height=30%&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;지난 한달 동안 자그마한 웹앱 프로젝트를 Redux 를 이용해서 진행했습니다. 그 과정에서 배운 몇 가지를 적었습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#1combinereducersreducer&#34;&gt;Redux: 1. combineReducers 를 이용해 Reducer 를 잘게 분해하기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#2reduceractionactiontype&#34;&gt;Redux: 2. Reducer 에서는 관련있는 Action 만 처리하기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#3reduxinternal&#34;&gt;Redux: 3. redux internal 이해하기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#4reduxsaga&#34;&gt;Redux: 4. redux-saga 사용하기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#5api&#34;&gt;Redux: 5. API 호출 실패에 대한 액션을 여러개 만들지 않기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#6jestmocha&#34;&gt;Webpack: 6. 테스팅 프레임워크로 jest 대신 mocha 사용하기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#7postcss&#34;&gt;Webpack: 7. postcss 를 사용할 경우, 테스팅 환경에서 스타일파일 무시하기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#8defineplugin&#34;&gt;Webpack: 8. DefinePlugin 을 이용해 클라이언트 파일에 환경변수 주입하기&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#9jsonserver&#34;&gt;Etc: 9. json-server 사용하기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;redux&#34;&gt;Redux&lt;/h2&gt;

&lt;h3 id=&#34;1-combinereducers-를-이용해-reducer-를-잘게-분해하기&#34;&gt;1. combineReducers 를 이용해 Reducer 를 잘게 분해하기&lt;/h3&gt;

&lt;p&gt;Root Reducer 가 &lt;code&gt;JobReducer&lt;/code&gt; 를 포함하고 있고, &lt;code&gt;JobReducer&lt;/code&gt; 는 Job 과 관련된 모든 상태를 다룬다고 할 때 다음처럼 &lt;code&gt;combineReducers&lt;/code&gt; 를 이용해서 &lt;code&gt;JobReducer&lt;/code&gt; 를 분해하면, 개별 컴포넌트의 상태(&lt;em&gt;State&lt;/em&gt;) 는 각각의 서브 리듀서 (이하 핸들러) 에서 다루면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://github.com/1ambda/slott/blob/master/src/reducers/JobReducer/index.js

import { combineReducers, } from &#39;redux&#39;

import * as JobItemState from &#39;./JobItemState&#39;
import * as PaginatorState from &#39;./PaginatorState&#39;
import * as FilterState from &#39;./FilterState&#39;
import * as SorterState from &#39;./SorterState&#39;
...

export const JOB_STATE_PROPERTY = {
  JOB_ITEMS: &#39;items&#39;,
  PAGINATOR: &#39;paginator&#39;,
  FILTER: &#39;filterKeyword&#39;,
  SORTER: &#39;sortingStrategy&#39;,
  ...
}

export default combineReducers({
  [JOB_STATE_PROPERTY.CONTAINER_SELECTOR]: ContainerSelectorState.handler,
  [JOB_STATE_PROPERTY.JOB_ITEMS]: JobItemState.handler,
  [JOB_STATE_PROPERTY.PAGINATOR]: PaginatorState.handler,
  [JOB_STATE_PROPERTY.FILTER]: FilterState.handler,
  [JOB_STATE_PROPERTY.SORTER]: SorterState.handler,
  ...
})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://github.com/1ambda/slott/blob/master/src/reducers/JobReducer/FilterState.js

import { createAction, handleActions, } from &#39;redux-actions&#39;

const INITIAL_STATE = &#39;&#39; /** initial state of FilterState */

export const ActionType = {
  FILTER: &#39;JOB_FILTER&#39;,
  INITIALIZE_FILTER: &#39;JOB_INITIALIZE_FILTER&#39;,
}

export const Action = {
  filterJob: createAction(ActionType.FILTER),
  initializeFilter: createAction(ActionType.INITIALIZE_FILTER),
}

export const handler = handleActions({
  [ActionType.FILTER]: (state, { payload, }) =&amp;gt;
    payload.filterKeyword, /** since string is immutable. we don&#39;t need to copy old state */

  [ActionType.INITIALIZE_FILTER]: (state, { payload, }) =&amp;gt;
    INITIAL_STATE,
}, INITIAL_STATE)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-reducer-action-actiontype-을-한-파일로-모으기&#34;&gt;2. Reducer, Action, ActionType 을 한 파일로 모으기&lt;/h3&gt;

&lt;p&gt;[Redux Github]() 에 나와있는 예제에서는 &lt;code&gt;ActionType&lt;/code&gt; 과 &lt;code&gt;Action&lt;/code&gt; 을 하나의 파일에 모아놓는데, 프로젝트가 커질수록 부담스럽습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Action&lt;/code&gt;, &lt;code&gt;ActionType&lt;/code&gt;, &lt;code&gt;Handler&lt;/code&gt; 를 한 파일에 모아놓으면 이 핸들러가 어떤 일들을 하는지, 페이로드는 무엇인지 한 눈에 파악할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://github.com/1ambda/slott/blob/master/src/reducers/JobReducer/PaginatorState.js

import { createAction, handleActions, } from &#39;redux-actions&#39;

import { PAGINATOR_ITEM_COUNT_PER_PAGE, } from &#39;../../constants/config&#39;

import * as FilterState from &#39;./FilterState&#39;
import * as SorterState from &#39;./SorterState&#39;

const INITIAL_PAGINATOR_STATE = {
  currentPageOffset: 0,
  currentItemOffset: 0,
  itemCountPerPage: PAGINATOR_ITEM_COUNT_PER_PAGE,
}

export const ActionType = {
  CHANGE_PAGE_OFFSET: &#39;JOB_CHANGE_PAGE_OFFSET&#39;,
}

export const Action = {
  changePageOffset: createAction(ActionType.CHANGE_PAGE_OFFSET),
}

export const handler = handleActions({
  [ActionType.CHANGE_PAGE_OFFSET]: (state, { payload, }) =&amp;gt; {
    const { newPageOffset, } = payload
    const currentItemOffset = newPageOffset * state.itemCountPerPage
    return Object.assign({}, state, {currentPageOffset: newPageOffset, currentItemOffset,})
  },

  /** reset paginator if filter or sorter action is occurred */
  [SorterState.ActionType.SORT]: (state) =&amp;gt; INITIAL_PAGINATOR_STATE,
  [FilterState.ActionType.FILTER]: (state) =&amp;gt; INITIAL_PAGINATOR_STATE,
}, INITIAL_PAGINATOR_STATE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Paginator&lt;/code&gt; 가 어떤 액션을 처리하고, 페이로드는 무엇인지 하나의 파일에서 확인할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;3-redux-internal-이해하기&#34;&gt;3. redux internal 이해하기&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/reactjs/redux&#34;&gt;redux&lt;/a&gt; 의 놀라운 점중 하나는 소스코드가 길지 않다는 점입니다. 따라서 내부 구조를 이해하기도 어렵지 않은데요,&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://briantroncone.com/?p=529&#34;&gt;Redux Middleware: Behind the Scenes&lt;/a&gt; 를 참고하면, &lt;em&gt;enhancer&lt;/em&gt; 가 어떻게 조합되고, &lt;em&gt;store&lt;/em&gt; 가 어떻게 생성되는지 쉽게 알 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;4-redux-saga-사용하기&#34;&gt;4. redux-saga 사용하기&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/yelouafi/redux-saga&#34;&gt;redux-saga&lt;/a&gt; 를 이용하면 &lt;code&gt;Promise&lt;/code&gt; 가 들어가는 비동기 로직을 &lt;a href=&#34;https://tc39.github.io/ecmascript-asyncawait/&#34;&gt;ES7 async&lt;/a&gt; 를 이용하는것처럼 작성할 수 있습니다. 추가적으로 사이드이펙트 (e.g API call) 의 선언과 실행 시점을 분리해 테스트를 쉽게 할 수 있도록 도와줍니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 초기화 시점에 서버로부터 전체 Job 을 가져오는 로직을 &lt;a href=&#34;https://github.com/yelouafi/redux-saga&#34;&gt;redux-saga&lt;/a&gt; 를 이용해 다음처럼 작성할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://github.com/1ambda/slott/blob/master/src/middlewares/sagas.js#L12

import { fork, call, put, } from &#39;redux-saga/effects&#39;

import * as SnackbarState from &#39;../reducers/JobReducer/ClosableSnackbarState&#39;
import * as Handler from &#39;./handler&#39;

export function* initialize() {
  try {
    yield call(Handler.callFetchContainerJobs)
  } catch (error) {
    yield put(
      SnackbarState.Action.openErrorSnackbar(
        { message: &#39;Failed to fetch jobs&#39;, error, }
      )
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드는 서버로부터 모든 Job 을 가져오고, 그 과정에서 예외가 발생하면 Snackbar 에 예외메세지를 출력하는 Action 을 Reducer 로 보내는 코드입니다. (여기서 &lt;code&gt;Handler.callFetchContainerJobs&lt;/code&gt; 가 &lt;code&gt;Promise&lt;/code&gt; 를 돌려준다고 보고)&lt;/p&gt;

&lt;p&gt;이 때 다음처럼 테스트를 작성할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://github.com/1ambda/slott/blob/master/src/middlewares/__tests__/sagas.spec.js#L87

  describe(&#39;initialize&#39;, () =&amp;gt; {
    it(&#39;should callFetchContainerJobs&#39;, () =&amp;gt; {
      const gen = Sagas.initialize()
      expect(gen.next().value).to.deep.equal(
        call(Handler.callFetchContainerJobs)
      )

      expect(gen.next().done).to.deep.equal(true)
    })

    it(`should callFetchJobs
        - if exception is occurred,
          put(openErrorSnackbar with { message, error }`, () =&amp;gt; {
      const gen = Sagas.initialize()

      expect(gen.next().value).to.deep.equal(
        call(Handler.callFetchContainerJobs)
      )

      const error = new Error(&#39;error&#39;)
      expect(gen.throw(error).value).to.deep.equal(
        put(ClosableSnackBarState.Action.openErrorSnackbar({ message: &#39;Failed to fetch jobs&#39;, error, }))
      )
    })
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 테스트 코드에서 알 수 있듯이, &lt;code&gt;redux-saga/effects&lt;/code&gt; 의 &lt;code&gt;call&lt;/code&gt; 을 호출하는 시점에서 AJAX 이 실행되지 않습니다. 실제로는 &lt;code&gt;call&lt;/code&gt; 은 AJAX 실행할것임을 &lt;strong&gt;선언&lt;/strong&gt; 만 합니다. AJAX 은 &lt;code&gt;call&lt;/code&gt; 로 부터 생성된 redux 액션이 &lt;code&gt;redux-saga&lt;/code&gt; 미들웨어에서 처리되는 순간에 &lt;strong&gt;실행&lt;/strong&gt; 됩니다. &lt;code&gt;call&lt;/code&gt; 의 리턴값은, 어떤 redux 액션이 실행될 것인지 알려주는 자바스크립트 객체입니다. 위에서는 이 리턴값을 이용해 테스트를 작성한 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// https://github.com/yelouafi/redux-saga/blob/master/docs/basics/DeclarativeEffects.md


{
  CALL: {
    fn: Handler.callFetchContainerJobs,
    args: []  
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-api-호출-실패에-대한-액션을-여러개-만들지-않기&#34;&gt;5. API 호출 실패에 대한 액션을 여러개 만들지 않기&lt;/h3&gt;

&lt;p&gt;redux 나 &lt;a href=&#34;https://github.com/yelouafi/redux-saga/blob/ce1d701467d2ec4e8c5c40288d9a41254c6f3583/examples/real-world/actions/index.js&#34;&gt;redux-saga 예제&lt;/a&gt; 를 보면, API 실패에 대한 액션을 여러 종류로 만드는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그러나 일반적으로 예외는 단일화된 방식으로 (e.g 에러 다이어로그, 팝업, 페이지 등) 처리되기 때문에 에러를 다룰 UI 컴포넌트에 대한 1개의 액션만 만드는 것이 더 바람직 합니다. 예를 들어 Snackbar 에서 예외 메세지를 보여준다고 할 때 다음처럼 액션 핸들러를 작성할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://github.com/1ambda/slott/blob/e2fc9c1260a5c8202ad747c31f5907ff29ab9a94/src/reducers/JobReducer/ClosableSnackbarState.js#L27

export const handler = handleActions({
  /** snackbar related */
  [ActionType.CLOSE_SNACKBAR]: (state) =&amp;gt;
    Object.assign({}, state, { snackbarMode: CLOSABLE_SNACKBAR_MODE.CLOSE, }),

  [ActionType.OPEN_ERROR_SNACKBAR]: (state, { payload, }) =&amp;gt;
    Object.assign({}, state, {
      snackbarMode: CLOSABLE_SNACKBAR_MODE.OPEN,
      message: `[ERROR] ${payload.message} (${payload.error.message})`,
    }),

  [ActionType.OPEN_INFO_SNACKBAR]: (state, { payload, }) =&amp;gt;
    Object.assign({}, state, {
      snackbarMode: CLOSABLE_SNACKBAR_MODE.OPEN,
      message: `[INFO] ${payload.message}`,
    }),

}, INITIAL_SNACKBAR_STATE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 여러 종류의 API 실패에 대한 액션을 처리하도록 작성했다면, 이런 코드가 되었을 거고 API_FAILED 액션 타입이 삭제되고 추가될 때 마다 수정해야 하므로 변경에 취약했을 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
const FAILED_API_ACTION_TYPES = [
  ActionType.LOAD_ALL_JOBS_FAILED,
  ActionType.CREATE_JOB_FAILED,
  ActionType.REMOVE_JOB_FAILED,
  ...
]

const FailureHandlers = FAILED_API_ACTION_TYPES.map(actionType =&amp;gt; {
  return { [actionType]: (state, { payload, }) =&amp;gt;
    Object.assign({}, state, {
      snackbarMode: CLOSABLE_SNACKBAR_MODE.OPEN,
      message: `[ERROR] ${payload.message} (${payload.error.message})`,
    })
  }
})

export const handler = handleActions({
  /** snackbar related */
  [ActionType.CLOSE_SNACKBAR]: (state) =&amp;gt;
    Object.assign({}, state, { snackbarMode: CLOSABLE_SNACKBAR_MODE.CLOSE, }),

  ...FailureHandlers,

}, INITIAL_SNACKBAR_STATE)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;webpack&#34;&gt;Webpack&lt;/h2&gt;

&lt;h3 id=&#34;6-테스팅-프레임워크로-jest-대신-mocha-사용하기&#34;&gt;6. 테스팅 프레임워크로 jest 대신 mocha 사용하기&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://facebook.github.io/jest/&#34;&gt;jest&lt;/a&gt; 는 Facebook 에서 만든 테스팅 프레임워크입니다. 모든 &lt;code&gt;import&lt;/code&gt; 는 기본적으로 mocking 됩니다. 따라서 테스트할 &lt;code&gt;.js&lt;/code&gt; 파일에서 사용되는 모든 라이브러리도 mocking 됩니다. 이런식으로 테스트 대상만 unmocking 해서 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://github.com/facebook/jest

jest.unmock(&#39;../sum&#39;); // unmock to use the actual implementation of sum

describe(&#39;sum&#39;, () =&amp;gt; {
  it(&#39;adds 1 + 2 to equal 3&#39;, () =&amp;gt; {
    const sum = require(&#39;../sum&#39;);
    expect(sum(1, 2)).toBe(3);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/facebook/jest&#34;&gt;jest&lt;/a&gt; 사용시 주의 할 사항이 두 가지 있습니다.&lt;/p&gt;

&lt;p&gt;jest 0.9.0 기준으로 아직 모든 라이브러리가 mocking 되진 않습니다. (e.g redux-saga)
babel 을 사용할 경우 babel-jest 로 테스트 실행이 가능하지만 여기에 postcss 까지 같이 쓸 경우, &lt;code&gt;import (‘*.css)&lt;/code&gt; 구문 때문에 테스팅이 불가능합니다. 커스텀 jest 로더를 등록하면, babel-runtime 로딩이 제대로 안되며 &lt;a href=&#34;https://github.com/atecarlos/webpack-babel-jest&#34;&gt;webpack-babel-jest&lt;/a&gt; 란것도 있으나 제대로 동작하지 않습니다. (관련이슈 &lt;a href=&#34;https://github.com/facebook/jest/issues/334&#34;&gt;jest issue: 334 - How to test with Jest when I&amp;rsquo;m using webpack&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&#34;7-postcss-를-사용할-경우-테스팅-환경에서-스타일파일-무시하기&#34;&gt;7. postcss 를 사용할 경우, 테스팅 환경에서 스타일파일 무시하기&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/postcss/postcss&#34;&gt;postcss&lt;/a&gt; 를 이용하면 &lt;a href=&#34;https://github.com/postcss/autoprefixer&#34;&gt;autoprefixer&lt;/a&gt; 등의 각종 플러그인을 사용 가능합니다. 특히 &lt;a href=&#34;https://github.com/postcss/postcss-loader&#34;&gt;postcss-loader&lt;/a&gt; 를 이용하면
 지엽적인 css 클래스 생성과 적용이 가능하므로 모듈, 컴포넌트 단위로 관리되는 React 와 같이 쓰기 좋습니다.&lt;/p&gt;

&lt;p&gt;그런데, 테스팅 환경에서는 &lt;a href=&#34;https://webpack.github.io/&#34;&gt;webpack&lt;/a&gt; 이 돌지 않으므로 css 파일 임포트가 불가능 하고, 테스트 실행이 안됩니다. 이 경우 &lt;a href=&#34;https://www.npmjs.com/package/ignore-styles&#34;&gt;ignore-styles&lt;/a&gt; 를 이용하거나 mocha 설정을 이용해 css 파일 임포트 문장을 무시할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://github.com/1ambda/slott/blob/f1e94a9e693c30f466d92a4d3c988b75d5db4118/package.json#L28

&amp;quot;test&amp;quot;: &amp;quot;cross-env NODE_ENV=test mocha --reporter progress --compilers js:babel-core/register --recursive \&amp;quot;./src/**/*.spec.js\&amp;quot; --require ignore-styles&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아니면 &lt;a href=&#34;https://github.com/coryhouse/react-slingshot&#34;&gt;react-slingshot&lt;/a&gt; 처럼 셋업 파일을 분리해서 mocha 설정으로 이용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://github.com/coryhouse/react-slingshot/blob/16ec28c9029bf7e2b65b26c22a1c2daadab427a2/tools/testSetup.js

process.env.NODE_ENV = &#39;production&#39;;

// Disable webpack-specific features for tests since
// Mocha doesn&#39;t know what to do with them.
require.extensions[&#39;.css&#39;] = function () {
  return null;
};
require.extensions[&#39;.png&#39;] = function () {
  return null;
};
require.extensions[&#39;.jpg&#39;] = function () {
  return null;
};

// Register babel so that it will transpile ES6 to ES5
// before our tests run.
require(&#39;babel-register&#39;)();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이후 &lt;code&gt;package.son&lt;/code&gt; 에서 &lt;code&gt;&amp;quot;test&amp;quot;: &amp;quot;mocha tools/testSetup.js src/**/*.spec.js --reporter&lt;/code&gt; 처럼 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;8-defineplugin-을-이용해-클라이언트-파일에-환경변수-주입하기&#34;&gt;8. DefinePlugin 을 이용해 클라이언트 파일에 환경변수 주입하기&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://webpack.github.io/docs/list-of-plugins.html#defineplugin&#34;&gt;Webpack: DefinePlugin&lt;/a&gt; 을 이용하면 Webpack 실행 시점에 존재하는 변수를 클라이언트에 주입할 수 있습니다. (e.g 환경변수, 별도 파일로 존재하는 설정값 등) 예를 들어&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://github.com/1ambda/slott/blob/f1e94a9e693c30f466d92a4d3c988b75d5db4118/tools/config.js

import { ENV_DEV, ENV_PROD, ENV_TEST, } from &#39;./env&#39;
import * as DEV_CONFIG from &#39;../config/development.config&#39;
import * as PROD_CONFIG from &#39;../config/production.config&#39;

const env = process.env.NODE_ENV

export const CONFIG = (env === ENV_DEV) ? DEV_CONFIG : PROD_CONFIG

export const GLOBAL_VARIABLES = { /** used by Webpack.DefinePlugin */
  &#39;process.env.ENV_DEV&#39;: JSON.stringify(ENV_DEV),
  &#39;process.env.ENV_PROD&#39;: JSON.stringify(ENV_PROD),
  &#39;process.env.NODE_ENV&#39;: JSON.stringify(env),

  /** variables defined in `CONFIG` file ares already stringified */
  &#39;process.env.CONTAINERS&#39;: CONFIG.CONTAINERS,
  &#39;process.env.TITLE&#39;: CONFIG.TITLE,
  &#39;process.env.PAGINATOR_ITEM_COUNT&#39;: CONFIG.PAGINATOR_ITEM_COUNT,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;좌측이 클라이언트에서 사용할 변수, 우측이 주입할 변수입니다. 이렇게 만든 후 Webpack 설정에서 다음처럼 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://github.com/1ambda/slott/blob/f1e94a9e693c30f466d92a4d3c988b75d5db4118/webpack.config.js

const getPlugins = function (env) {
  const plugins = [
    new webpack.optimize.OccurenceOrderPlugin(),
    new webpack.DefinePlugin(GLOBAL_VARIABLES),
    ...
  ]

  /* eslint-disable no-console */
  console.log(&#39;Injecting Global Variable&#39;.green)
  console.log(GLOBAL_VARIABLES)
  /* eslint-enable no-console */

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 때 몇 가지 주의할 사항이 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If the value is a string it will be used as a code fragment.
If the value isn’t a string, it will be stringified (including functions).
If the value is an object all keys are defined the same way.
If you prefix typeof to the key, it’s only defined for typeof calls.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 우측 값이 문자열일 경우, 코드값으로 사용되므로 &lt;code&gt;undefined&lt;/code&gt; 로 주입되거나, Webpack 실행시 예외가 발생할 경우는 확인해 보아야 합니다. 실제로 문자열을 주입하고 싶다면 한번 더 문자열로 감싸야 하구요. 이 부분은 문서에도 나와 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://webpack.github.io/docs/list-of-plugins.html#defineplugin

new webpack.DefinePlugin({
    VERSION: JSON.stringify(&amp;quot;5fa3b9&amp;quot;),
    BROWSER_SUPPORTS_HTML5: true,
    TWO: &amp;quot;1+1&amp;quot;,
    &amp;quot;typeof window&amp;quot;: JSON.stringify(&amp;quot;object&amp;quot;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;etc&#34;&gt;Etc&lt;/h2&gt;

&lt;h3 id=&#34;9-json-server-사용하기&#34;&gt;9. json-server 사용하기&lt;/h3&gt;

&lt;p&gt;웹 클라이언트 개발 과정에서, API 연동을 하다보면 두 가지 문제점에 마주칩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;아직 백엔드가 개발되지 않았는데 연동이 필요할 경우&lt;/strong&gt;: 테스팅은 mock 등을 어찌어찌 해서 짤 수 있으나, UI 시뮬레이션은 최소한 로컬호스트 개발용 서버라도 갖추어야 하므로 어려움&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RESTful API 구현&lt;/strong&gt;: HTTP Status, Methods, URI 등에 대한 학습과 고민이 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로컬에서 미리 정의된 리소스를 읽어 표준화된 REST API 서버를 제공하는 &lt;a href=&#34;https://github.com/typicode/json-server&#34;&gt;json-server&lt;/a&gt; 를 이용하면 이 두 가지 문제를 해결할 수 있습니다.&lt;/p&gt;

&lt;p&gt;예를 들어 Job 을 &lt;code&gt;/api/jobs&lt;/code&gt; 에서 돌려준다고 하면 리소스 파일을 다음처럼 작성할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;jobs&amp;quot;: [
    {
      &amp;quot;id&amp;quot;: &amp;quot;akka-cluster-A-1&amp;quot;,
      &amp;quot;tags&amp;quot;: [
        &amp;quot;cluster&amp;quot;
      ],
      &amp;quot;active&amp;quot;: true,
      &amp;quot;enabled&amp;quot;: true,
      &amp;quot;kafka&amp;quot;: {
        &amp;quot;topic&amp;quot;: &amp;quot;akka-A&amp;quot;,
        &amp;quot;consumer-group&amp;quot;: &amp;quot;cluster-consumers&amp;quot;
      },
      &amp;quot;hdfs&amp;quot;: &amp;quot;/data/akka/cluster-A&amp;quot;
    }
  , ...
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;추가적으로 라우팅 세팅을 위해 &lt;code&gt;routes.json&lt;/code&gt; 파일을 다음처럼 작성하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;/api/&amp;quot;: &amp;quot;/&amp;quot;,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/typicode/json-server&#34;&gt;json-server&lt;/a&gt; 를 사용할 때 두 가지 주의해야 할 점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. &lt;code&gt;id&lt;/code&gt; 값은 &lt;em&gt;immutable&lt;/em&gt; 이고, 모든 리소스는 &lt;code&gt;id&lt;/code&gt; 값을 가지고 있어야 합니다. (키 값은 &lt;code&gt;--id&lt;/code&gt; 옵션으로 변경 가능함)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;따라서 각 Job 의 실행 상태와 설정값을 별개의 리소스가 아니라 (별개의 리소스라면 &lt;code&gt;jobId&lt;/code&gt; 를 주어 &lt;em&gt;join&lt;/em&gt; 을 해야함) &lt;code&gt;/api/jobs/:id/state&lt;/code&gt;, &lt;code&gt;/api/jobs/:id/config&lt;/code&gt; 처럼 nested 된 형태로 돌려주고 싶을 때는 &lt;code&gt;routes.json&lt;/code&gt; 의 라우팅 트릭을 이용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;// https://github.com/1ambda/slott/blob/f1e94a9e693c30f466d92a4d3c988b75d5db4118/resource/routes.json

{
  &amp;quot;/api/&amp;quot;: &amp;quot;/&amp;quot;,
  &amp;quot;/:resource/:id/state&amp;quot;: &amp;quot;/:resource/:id&amp;quot;,
  &amp;quot;/:resource/:id/config&amp;quot;: &amp;quot;/:resource/:id&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 때, 이 리소스는 별개의 리소스가 아니라 URI 만 매핑된 것이므로 &lt;code&gt;config&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt; 등에 대한 변경은 HTTP &lt;em&gt;PATCH&lt;/em&gt; 메소드로 변경해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 모든 리소스 변경은 즉시 파일에 변경됩니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;따라서 매 실행마다 동일한 리소스로 시작하려면, 리소스 파일을 복사 후 실행하는 간단한 스크립트를 작성하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// https://github.com/1ambda/slott/blob/f1e94a9e693c30f466d92a4d3c988b75d5db4118/tools/remote.js

import fs from &#39;fs-extra&#39;

/** initialize resource/remote/db.json */

const resourceDir = &#39;resource&#39;

// 3개의 서버를 별개로 띄우므로 3벌 복사
const remotes = [&#39;remote1&#39;, &#39;remote2&#39;, &#39;remote3&#39;,]

remotes.map(remote =&amp;gt; {
  fs.copySync(`${resourceDir}/${remote}/db.origin.json`, `${resourceDir}/${remote}/db.json`)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이후 &lt;code&gt;package.json&lt;/code&gt; 에 다음의 스크립트를 작성하고, 사용하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;// https://github.com/1ambda/slott/blob/f1e94a9e693c30f466d92a4d3c988b75d5db4118/package.json#L9

...

 &amp;quot;start:mock-server1&amp;quot;: &amp;quot;json-server resource/remote1/db.json --routes resource/routes.json --port 3002&amp;quot;,
    &amp;quot;start:mock-server2&amp;quot;: &amp;quot;json-server resource/remote2/db.json --routes resource/routes.json --port 3003&amp;quot;,
    &amp;quot;start:mock-server3&amp;quot;: &amp;quot;json-server resource/remote3/db.json --routes resource/routes.json --port 3004&amp;quot;,
    &amp;quot;start:mock-server&amp;quot;: &amp;quot;npm-run-all --parallel start:mock-server1 start:mock-server2 start:mock-server3&amp;quot;,

...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/reactjs/redux/issues/151&#34;&gt;Redux Logo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://briantroncone.com/?p=529&#34;&gt;Redux Middleware: Behind the Scenes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tc39.github.io/ecmascript-asyncawait/&#34;&gt;ES7 async&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yelouafi/redux-saga/blob/master/docs/basics/DeclarativeEffects.md&#34;&gt;redux-saga: Declarative Effects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://webpack.github.io/docs/list-of-plugins.html#defineplugin&#34;&gt;Webpack: DefinePlugin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/coryhouse/react-slingshot&#34;&gt;react-slingshot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>REST API: Put vs Post</title>
      <link>https://1ambda.github.io/javascripts/rest-api-put-vs-post/</link>
      <pubDate>Sat, 25 Jun 2016 22:25:23 +0900</pubDate>
      
      <guid>https://1ambda.github.io/javascripts/rest-api-put-vs-post/</guid>
      <description>

&lt;h3 id=&#34;idempotent&#34;&gt;idempotent&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;PUT&lt;/code&gt; 과 &lt;code&gt;POST&lt;/code&gt; 를 이해하려면, &lt;strong&gt;&lt;a href=&#34;http://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation&#34;&gt;idempotent&lt;/a&gt;&lt;/strong&gt; 라는 개념의 도입이 필요하다. 한글로 직역하면 &lt;em&gt;멱등의&lt;/em&gt; 정도 되시겠다. 수학적으로 이해하는 편이 쉬운데,&lt;/p&gt;

&lt;p&gt;&lt;em&gt;f(x) = f(f(x))&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;라 보면 된다. 다시 말해 몇 번이고 같은 &lt;em&gt;연산&lt;/em&gt; 을 반복해도 같은 값이 나온다는 것. 이건 fault-tolerant API 를 디자인 하는데 있어서 굉장히 중요한 요소다.&lt;/p&gt;

&lt;p&gt;예를 들어보자. 클라이언트가 &lt;code&gt;POST /dogs&lt;/code&gt; 를 요청했는데, 어떤 이유로간에 요청이  time-out (408) 되었다고 해 보자. 클라이언트는 요청이 전달되었으나 네트워크가 끊어졌는지, 아니면 요청조차 전달이 되지 않았는지 알 수 없다.&lt;/p&gt;

&lt;p&gt;이 때, 클라이언트가 원하는 operation 이 &lt;strong&gt;idempotent&lt;/strong&gt; 하다면 다시 요청해도 상관 없다. 항상 같은 결과를 만드니까. 그러나 &lt;code&gt;POST&lt;/code&gt; 는 &lt;strong&gt;idempotent&lt;/strong&gt; 하지 않다.&lt;/p&gt;

&lt;h3 id=&#34;post&#34;&gt;POST&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;POST&lt;/code&gt; 는 클라이언트가 &lt;em&gt;리소스의 위치를 지정하지 않았을때&lt;/em&gt; 리소스를 생성하기 위해 사용하는 연산이다. 예를들어&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;POST /dogs HTTP/1.1

{ &amp;quot;name&amp;quot;: &amp;quot;blue&amp;quot;, &amp;quot;age&amp;quot;: 5 }

HTTP/1.1 201 Created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 이 연산을 수행하면 &lt;code&gt;/dogs/2&lt;/code&gt; 에 생기고, 그 다음번엔 &lt;code&gt;/dogs/3&lt;/code&gt; 등 매번 다른곳에 새로운 리소스가 생성될 수 있으므로, 이 연산은 &lt;strong&gt;idempotent 하지 않다&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;put&#34;&gt;PUT&lt;/h3&gt;

&lt;p&gt;반면 리소스의 위치가 명확히 지정된 다음의 요청을 고려해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;PUT /dogs/3 HTTP/1.1

{ &amp;quot;name&amp;quot;: &amp;quot;blue&amp;quot;, &amp;quot;age&amp;quot;: 5 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/dogs&lt;/code&gt; 의 프로퍼티가 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;age&lt;/code&gt; 뿐이라면, 이건 몇 번을 수행하더라도, 같은 결과를 보장한다. 다시 말해 &lt;strong&gt;idempotent&lt;/strong&gt; 하다.&lt;/p&gt;

&lt;p&gt;그리고 위에 예에서 알 수 있듯이 &lt;code&gt;PUT&lt;/code&gt; 은 &lt;em&gt;리소스의 위치가 지정되었을때&lt;/em&gt; &lt;strong&gt;생성&lt;/strong&gt; 또는 &lt;strong&gt;업데이트&lt;/strong&gt; 를 위해 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;### PATCH&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PUT&lt;/code&gt; 이 리소스의 모든 프로퍼티를 업데이트 하기 위해 사용된다면, &lt;code&gt;PATCH&lt;/code&gt; 는 부분만을 업데이트하기 위해 사용한다. &lt;code&gt;PUT&lt;/code&gt; 과 마찬가지로 리소스의 위치를 클라이언트가 알고 있을 때 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/630453/put-vs-post-in-rest&#34;&gt;SO&lt;/a&gt; 에는 3개의 메소드를 다음과 같이 요약하는 답변이 있다.&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;POST&lt;/strong&gt; to a URL &lt;strong&gt;creates a child resouce&lt;/strong&gt; at a server defiend URL&lt;br /&gt;
(&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5&#34;&gt;RFC 2616 POST&lt;/a&gt;)&lt;br /&gt;
(2) &lt;strong&gt;PUT&lt;/strong&gt; to a URL &lt;strong&gt;create/replaces the resource&lt;/strong&gt; in is entirely at the client defined URL&lt;br /&gt;
(&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.6&#34;&gt;RFC 2616 PUT&lt;/a&gt;)&lt;br /&gt;
(3) &lt;strong&gt;PATCH&lt;/strong&gt; to a URL &lt;strong&gt;updates part of the resource&lt;/strong&gt; at that client defined URL&lt;br /&gt;
(&lt;a href=&#34;http://tools.ietf.org/html/rfc5789&#34;&gt;RFC 5789: Patch Method for HTTP&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&#34;response-code&#34;&gt;Response Code&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;POST&lt;/code&gt; 이나 &lt;code&gt;POST&lt;/code&gt; 요청이 리소스를 새로 생성할 경우엔 리소스의 위치를 response header 의 &lt;strong&gt;Location&lt;/strong&gt; field 에 담아 &lt;em&gt;201 Created&lt;/em&gt; 를 보낼 수 있다. 그러나 not-identifiable 한 리소스를 생성할 경우엔 &lt;em&gt;200 OK&lt;/em&gt; 또는 &lt;em&gt;204 No Content&lt;/em&gt; 를 보낼수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.w3.org/Protocols이나 `POST` /rfc2616/rfc2616-sec9스의tml#sec9.5&#34;&gt;원문&lt;/a&gt;을 첨부하자면,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The action performed by the POST method might not result in a resource that can be identified by a URI. In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result. &lt;br/&gt;&lt;br/&gt;
If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header (see section 14.30).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Async 하게 서버가 처리한다면, 요청은 수락 되었으나 아직 커밋되지 않았음을 알리기 위해 &lt;em&gt;202 Accepted&lt;/em&gt; 를 보내야 한다. (if the operation has not been commited yet)&lt;/p&gt;

&lt;p&gt;아래 사진은, response code decision tree&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;a href=&#34;http://i.stack.imgur.com/whhD1.png&#34;&gt;&lt;img src=&#34;http://i.stack.imgur.com/whhD1.png&#34; /&gt;&lt;/a&gt;&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://i.stack.imgur.com/whhD1.png&#34;&gt;http://i.stack.imgur.com/whhD1.png&lt;/a&gt;)&lt;/p&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;safe-methods&#34;&gt;Safe Methods&lt;/h3&gt;

&lt;p&gt;리소스를 수정하지 않는 메소드들, &lt;code&gt;OPTIONS&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt; 등을 &lt;em&gt;safe&lt;/em&gt; 하다고 말한다. 대부분의 경우 &lt;em&gt;idempotent&lt;/em&gt; 하면 &lt;em&gt;safe&lt;/em&gt; 하다. 물론 예외도 있는데 &lt;code&gt;DELETE&lt;/code&gt; 는 &lt;em&gt;idempotent&lt;/em&gt; 하지만 리소스를 변경하므로 &lt;em&gt;safe&lt;/em&gt; 하지 않다. 자세한 내용은 &lt;a href=&#34;http://tools.ietf.org/html/rfc7231#section-4.2&#34;&gt;RFC 7231: Safe Methods&lt;/a&gt; 를 보자. 참고로 &lt;a href=&#34;http://tools.ietf.org/html/rfc7231#section-4.2.1&#34;&gt;RFC 7231&lt;/a&gt; 은 &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; 와 &lt;em&gt;safe methods&lt;/em&gt; 를 &lt;em&gt;idempotent&lt;/em&gt; 하다고 정의한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HEAD&lt;/code&gt; 는 Response-Body 없이 Header 만 얻기 위해 사용하고, &lt;code&gt;OPTIONS&lt;/code&gt; 는 해당 리소스에 대해 가능한 operation 이 무엇인지 응답을 얻기 위해 사용한다. 만약 &lt;code&gt;OPTIONS&lt;/code&gt; 에 대한 응답이 온다면 response &lt;code&gt;Allow&lt;/code&gt; 에 가능한 operation 이 와야한다. &lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&#34;&gt;RFC2616&lt;/a&gt; 에는 다음과 같이 나와있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;OPTIONS&lt;/code&gt; method represents a request for information about the communication options available on the request/response chain identified by the Request-URI. This method allows the client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval. &lt;br/&gt;&lt;br/&gt;
Responses to this method are not cacheable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;cacheable-methods&#34;&gt;Cacheable Methods&lt;/h3&gt;

&lt;p&gt;왜 &lt;code&gt;OPTIONS&lt;/code&gt; 메소드에 대한 응답은 캐시가 불가능한걸까? SO 에서 이 &lt;a href=&#34;http://stackoverflow.com/questions/13073313/http-options-not-cacheable&#34;&gt;답변&lt;/a&gt; 이 제일 나은것 같아서 가져왔다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;OPTIONS&lt;/code&gt; HTTP request returns the available methods which can be performed on a resource. (The objects methods)&lt;/p&gt;

&lt;p&gt;I can not say for certain why you can not cache the response, but its most likely a precaution. Caching would have little value for the &lt;code&gt;OPTIONS&lt;/code&gt; http method.&lt;/p&gt;

&lt;p&gt;A Resource is &amp;ldquo;any information that can be given a name&amp;rdquo;, that name is its URI. the response from the OPTIONs request is only a list of methods that can be requested on this resource (e.g. &amp;ldquo;GET PUT POST&amp;rdquo; maybe the response). To actually get at the information stored, you must use the GET method.&lt;/p&gt;

&lt;p&gt;History, more than anything; OPTIONS was defined that way to start with. The underlying reason is that HTTP caches are defined in terms of representations, which means the way you get something out of the cache is GET. This is why OPTIONS, PROPFIND, etc. caching are problematic.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다시 말해서, 리소스는 주어진 URI 에 대한 정보인데 &lt;code&gt;OPTIONS&lt;/code&gt; 는 정보를 가지고 오는 것이 아니라, 정보에 대해 어떤 연산이 가능한지를 알려준다. HTTP 에서는 정보에 대해 캐싱하므로, &lt;code&gt;GET&lt;/code&gt; 이나 &lt;code&gt;HEAD&lt;/code&gt; 같이 정보를 돌려주는 연산만 캐싱할 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;trace-connect&#34;&gt;Trace, Connect&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;TRACE&lt;/code&gt; 는 클라이언트가 방금 보낸 요청을 다시 달라고, 서버에게 요청하는 것이고 &lt;code&gt;CONNECT&lt;/code&gt; 는 HTTP 터널링을 할때 쓰인다. 중간의 프록시 서버를 위해서는 &lt;code&gt;CONNECT&lt;/code&gt; 로 요청하고, 마지막 프록시에서 end-point 로는 &lt;code&gt;GET&lt;/code&gt; 또는 &lt;code&gt;CONNECT&lt;/code&gt; 를 날린다. &lt;code&gt;HTTPS&lt;/code&gt; 라면 &lt;code&gt;CONNECT&lt;/code&gt; 를, &lt;code&gt;HTTP&lt;/code&gt; 라면 둘 중 아무거나 써도 상관 없다. 더 자세한건 &lt;a href=&#34;http://stackoverflow.com/questions/11697943/when-should-one-use-connect-and-get-http-methods-at-http-proxy-server&#34;&gt;SO 답변&lt;/a&gt; 으로&lt;/p&gt;

&lt;p&gt;원문을 첨부하면,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;CONNECT:&lt;/strong&gt; This method could allow a client to use the web server as a proxy.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TRACE:&lt;/strong&gt; This method simply echoes back to the client whatever string has been sent to the server, and is used mainly for debugging purposes. This method, originally assumed harmless, can be used to mount an attack known as Cross Site Tracing, which has been discovered by Jeremiah Grossman (see links at the bottom of the page).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;HTTP 메소드에 대해서 알아보았는데, 조금 더 찾아보니 HTTP 는 0.9 -&amp;gt; 1.0 -&amp;gt; 1.1 순으로 변화했다고 한다. 0.9 에선 &lt;code&gt;GET&lt;/code&gt; 을 이용한 Read-only 버전이었고 1.0 에 들어와서야 &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt; 등을 이용해 서버로 데이터 전송이 가능해졌다.   HTTP 1.1 (RFC 2616) 에 와서야 &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; 등이 추가되면서 변경, 삭제까지 가능해졌다.&lt;/p&gt;

&lt;p&gt;다음번에 HTTP 를 또 살펴 볼 일이 생긴다면, &lt;a href=&#34;http://tools.ietf.org/html/rfc7234&#34;&gt;RFC 7243: Caching&lt;/a&gt; 과 &lt;a href=&#34;http://tools.ietf.org/html/rfc7235&#34;&gt;RFC 7235: Authentication&lt;/a&gt; 에 대해서 보지 않을까 싶다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;http://restcookbook.com/HTTP%20Methods/put-vs-post/&#34;&gt;REST Cookbook: PUT vs POST&lt;/a&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://stackoverflow.com/questions/2342579/http-status-code-for-update-and-delete&#34;&gt;HTTP status code for UPDATE and DELETE&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://stackoverflow.com/questions/630453/put-vs-post-in-rest/18243587#18243587&#34;&gt;PUT vs POST in REST&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://restcookbook.com/HTTP%20Methods/idempotency/&#34;&gt;REST Coookbook: idempotency&lt;/a&gt;&lt;br /&gt;
(5) &lt;a href=&#34;http://zacstewart.com/2012/04/14/http-options-method.html&#34;&gt;HTTP OPTIONS Method&lt;/a&gt;&lt;br /&gt;
(6) &lt;a href=&#34;https://www.mnot.net/blog/2012/10/29/NO_OPTIONS&#34;&gt;NO OPTIONS&lt;/a&gt;&lt;br /&gt;
(7) &lt;a href=&#34;http://www.mkexdev.net/Article/Content.aspx?parentCategoryID=1&amp;amp;categoryID=11&amp;amp;ID=119&#34;&gt;HTTP History&lt;/a&gt;&lt;br /&gt;
(8) &lt;a href=&#34;http://stackoverflow.com/questions/13073313/http-options-not-cacheable&#34;&gt;HTTP OPTIONS not cacheable&lt;/a&gt;&lt;br /&gt;
(9) &lt;a href=&#34;http://stackoverflow.com/questions/11697943/when-should-one-use-connect-and-get-http-methods-at-http-proxy-server&#34;&gt;CONNECT vs GET in proxy&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CC 03: Membership Protocol</title>
      <link>https://1ambda.github.io/cloud-computing/cloud-computing-3/</link>
      <pubDate>Sat, 25 Jun 2016 14:42:41 +0900</pubDate>
      
      <guid>https://1ambda.github.io/cloud-computing/cloud-computing-3/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://ook.co/wp-content/uploads/cloudcomputing.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;왜 &lt;em&gt;membership&lt;/em&gt; 이란 개념이 클라우드 컴퓨팅에 필요할까요?&lt;/p&gt;

&lt;p&gt;한 노드가 &lt;em&gt;OS&lt;/em&gt;, &lt;em&gt;Disk&lt;/em&gt;, &lt;em&gt;Network&lt;/em&gt; 등 때문에 10년 (120개월) 마다 한 번씩 고장난다고 합시다. 그러면 120개의 노드를 가지고 있다면 1개월마다  한 번씩입니다. 이정도는 참을만하죠? 그런데, 12,000 개의 서버를 가지고 있다면 &lt;em&gt;MTTF (mean time to failure)&lt;/em&gt; 는 7.2 시간마다 한번씩입니다. 이건 큰 문제입니다.&lt;/p&gt;

&lt;p&gt;따라서 머신이 멀쩡한지 아닌지를 수동이 아니라 자동으로 판단하고 보고해줄 시스템이 필요합니다. &lt;em&gt;membership&lt;/em&gt; 이 필요한 것이죠. 이 대상은&lt;/p&gt;

&lt;p&gt;(1) Process &lt;em&gt;group&lt;/em&gt;-based systems&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clouds / Datacenters&lt;/li&gt;
&lt;li&gt;Replicated servers&lt;/li&gt;
&lt;li&gt;Distributed databases&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) Cash-stop / Fail stop process failures&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/membership1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/membership2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;멤버십 프로토콜은 다음처럼 구성되어 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;멤버쉽 리스트 (&lt;em&gt;complete&lt;/em&gt;, &lt;em&gt;almost-complete&lt;/em&gt;, &lt;em&gt;partial-random&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;dissemination&lt;/em&gt; mechanism to inform about joins, leavs, and failures of processes&lt;/li&gt;
&lt;li&gt;&lt;em&gt;failure detector&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;failure-detector&#34;&gt;Failure Detector&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;distributed failure detector&lt;/em&gt; 를 평가할 수 있는 지표는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Completeness:&lt;/strong&gt; each failure is detected&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Accuracy:&lt;/strong&gt; there is no mistaken detection&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Speed:&lt;/strong&gt; time to first detection of a failure&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scale:&lt;/strong&gt; equal load on each member. network message load&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;안타깝게도 &lt;em&gt;completeness&lt;/em&gt; 와 &lt;em&gt;accuracy&lt;/em&gt; 를 &lt;em&gt;lossy network&lt;/em&gt; 에서 동시에 추구할 수 없다는 사실이 밝혀졌습니다. (&lt;em&gt;Chandra and Toueg&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;현실적으로는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;completeness:&lt;/em&gt; 100% guaranteed&lt;/li&gt;
&lt;li&gt;&lt;em&gt;accuracy:&lt;/em&gt; partial / probabilistic guarantee&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;(1) Centralized Heartbeating&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/centralized_heartbeating.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;중앙 집중형이기 때문에 &lt;em&gt;load&lt;/em&gt; 가 한쪽으로만 쏠린다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;(2) Ring Heartbeating&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/ring_heartbeating.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;링 형태로 구성되었기때문에 동시에 발생하는 다수개의 &lt;em&gt;failure&lt;/em&gt; 를 탐지하지 못합니다.&lt;/p&gt;

&lt;p&gt;(3) All To All Heartbeating&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/all2all_heartbeating.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;우선 &lt;em&gt;equal load&lt;/em&gt; 라는 장점이 있습니다. 개별 노드당 오버헤드가 큰 것처럼 보이는데, 뒤에서 다시 한번 보겠지만 사실 그렇게 크지 않습니다.&lt;/p&gt;

&lt;p&gt;(4) Gossip-Style Membership&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/gossip_heartbeating1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/gossip_heartbeating2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;accuracy&lt;/em&gt; 가 높다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;동작 방식은 이렇습니다. &lt;em&gt;hearbeat&lt;/em&gt; 가 &lt;code&gt;T_fail&lt;/code&gt; 초 후에도 증가하지 않으면, 해당 멤버는 &lt;em&gt;failure&lt;/em&gt; 를 일으킨 것으로 판별됩니다. 그리고 멤버 리스트에서는 &lt;code&gt;T_cleanup&lt;/code&gt; 초 후에 제거됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/why_cleanup_time1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/why_cleanup_time2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/why_cleanup_time3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;왜 바로 제거하지 않고, &lt;code&gt;T_cleanup&lt;/code&gt; 초 후에 제거할까요? 이는 위 슬라이드에서 볼 수 있듯이 &lt;code&gt;3&lt;/code&gt; 번 노드가 &lt;em&gt;failure&lt;/em&gt; 를 일으켰을때, &lt;code&gt;2&lt;/code&gt; 번 노드의 멤버 리스트에서 바로 제거한다면 &lt;code&gt;1&lt;/code&gt; 번 노드로부터 업데이트를 받아 멤버 리스트에 &lt;em&gt;failure&lt;/em&gt; 가 발생하지 않은것처럼 추가될 수 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/gossip_membership_analysis.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;T_gossip&lt;/code&gt; 이 줄면, &lt;em&gt;bandwidth&lt;/em&gt; 를 많이 잡아먹는 대신, &lt;em&gt;detection time&lt;/em&gt; 이 줄어듭니다. &lt;em&gt;trade-off&lt;/em&gt; 라 보면 되겠습니다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code&gt;T_fail, T_cleanup&lt;/code&gt; 이 증가하면 &lt;em&gt;false positive rate&lt;/em&gt; 는 줄어드는 대신, 당연히 &lt;em&gt;detection time&lt;/em&gt; 이 늘어납니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;그러면 위에 나온 것 중 어느것이 가장 좋은 &lt;em&gt;failure detector&lt;/em&gt; 일까요? 앞서 언급했던 기준들을 이용해서 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Completeness:&lt;/em&gt; guarantee always&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Accuracy:&lt;/em&gt; a prob of mstake in time T &lt;code&gt;PM(T)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Speed:&lt;/em&gt; &lt;code&gt;T&lt;/code&gt; time units&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Scale:&lt;/em&gt; &lt;code&gt;N*L&lt;/code&gt; Compare this across protocols&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(1) All-To-All Heartbeating&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/performance_all2all.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;work load&lt;/em&gt; 가 &lt;code&gt;N&lt;/code&gt; 에 비례합니다.&lt;/p&gt;

&lt;p&gt;(2) Gossip-Style Heartbeating&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/performance_gossip.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tg&lt;/code&gt; 를 &lt;code&gt;O(n)&lt;/code&gt; 의 &lt;em&gt;gossip message&lt;/em&gt; 를 보내는데 걸리는 &lt;em&gt;gossip period&lt;/em&gt; 라 했을때, 한 &lt;em&gt;round&lt;/em&gt; 에서의 전파 시간인 &lt;code&gt;logN&lt;/code&gt; 을 곱해 &lt;code&gt;T = logN * tg&lt;/code&gt; 입니다. 이때 오버헤드 &lt;code&gt;L = N/tg&lt;/code&gt; 이므로, &lt;code&gt;L = N * logN / T&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;오버헤드가 &lt;em&gt;all-to-all heartbeating&lt;/em&gt; 보다 훨씬 높죠? 이는 &lt;em&gt;accuracy&lt;/em&gt; 가 더 높기 때문입니다. 앞에서 &lt;em&gt;all-to-all&lt;/em&gt; 가 더 비용이 많이 들것 같지만 실제로는 그렇지 않다고 했었는데, 이런 이유에서입니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/suboptimal_worstcase.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;worst case load per member&lt;/em&gt; &lt;code&gt;L*&lt;/code&gt; 라 하고&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P_ml&lt;/code&gt; 을 독립적인 메시지 손실양 이라고 했을때,&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;L*&lt;/code&gt; 을 &lt;code&gt;T, PM(T), P_ml&lt;/code&gt; 의 함수로 표시하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://latex.numberempire.com/render?L%2A%20%3D%20%7B%20log%28PM%28T%29%29%20%5Cover%20log%28P_ml%29%20%7D%20%2A%20%7B1%20%5Cover%20T%20%7D&amp;amp;sig=b21744720873bd544c3b394bd827b158&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;메시지 손실 &lt;code&gt;P_ml&lt;/code&gt; 이 높을수록, 오버헤드 &lt;code&gt;L*&lt;/code&gt; 는 당연히 작아져야 하고, &lt;code&gt;PM(T)&lt;/code&gt; 가 높을수록 &lt;em&gt;false-positive&lt;/em&gt; 가 많으므로 오버헤드가 높습니다. 수식을 보면 변수 &lt;code&gt;N&lt;/code&gt; 이 없는데, 이는 &lt;em&gt;scale-free&lt;/em&gt; 함을 보여줍니다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;em&gt;all-to-all&lt;/em&gt; 이나 &lt;em&gt;gossip-based&lt;/em&gt; 는 &lt;strong&gt;suboptimal&lt;/strong&gt; 입니다. 왜냐하면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;L = O(N/T)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;try to achieve simultaneous detection at all processes&lt;/li&gt;
&lt;li&gt;fail to distinguish &lt;strong&gt;failure detection&lt;/strong&gt; and &lt;strong&gt;dissemination components&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 두개의 컴포넌트를 분리하고, &lt;em&gt;non heatbeat-based failure detection&lt;/em&gt; 을 이용하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;swim-failure-detector&#34;&gt;SWIM Failure Detector&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/SWIM_intro.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;SWIM&lt;/em&gt; 은 &lt;em&gt;probabilistic failure detector protocol&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;period&lt;/em&gt; &lt;code&gt;T&lt;/code&gt; 동안 프로세스(노드) &lt;code&gt;pi&lt;/code&gt; 는 &lt;code&gt;pj&lt;/code&gt; 를 랜덤하게 골라 &lt;em&gt;ping&lt;/em&gt; 을 보냅니다. &lt;em&gt;ack&lt;/em&gt; 가 오면, 남은 &lt;em&gt;period&lt;/em&gt; 동안 아무것도 하지 않습니다. 그러나 위 슬라이드에서 볼 수 있듯이 &lt;code&gt;pj&lt;/code&gt; 가 응답하지 않으면 랜덤하게 &lt;code&gt;K&lt;/code&gt; 개의 프로세스를 선택해서, &lt;em&gt;ping&lt;/em&gt; 을 날리고, 이를 통해 &lt;em&gt;indirect&lt;/em&gt; 한 방법으로 &lt;code&gt;pj&lt;/code&gt; 의 응답을 검사합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;SWIM&lt;/em&gt; 의 퍼포먼스는 &lt;em&gt;heartbeat&lt;/em&gt; 와 비교했을때 어떨까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/SWIM_vs_heartbeating.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;X&lt;/code&gt; 축은 &lt;strong&gt;process load&lt;/strong&gt;, &lt;code&gt;Y&lt;/code&gt; 축은 &lt;em&gt;first detection time&lt;/em&gt; 입니다. &lt;em&gt;false-positive rate&lt;/em&gt; 와 &lt;em&gt;message loss rate&lt;/em&gt; 는 고정되어있다고 가정합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;heartbeat&lt;/em&gt; 의 경우에는 앞서 봤듯이 &lt;em&gt;detection time&lt;/em&gt; 읖 높이면 &lt;em&gt;work load&lt;/em&gt; 가 낮아지고 (= &lt;em&gt;low bound on the bandwidth&lt;/em&gt;), 반대로 &lt;em&gt;detection time&lt;/em&gt; 을 낮추면, &lt;em&gt;work load&lt;/em&gt; 가 높아집니다. 반면 &lt;em&gt;SWIM&lt;/em&gt; 은 둘다 적죠.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/SWIM_parameters.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;슬라이드에서 볼 수있듯이 &lt;em&gt;first detection time&lt;/em&gt;, &lt;em&gt;process load&lt;/em&gt; 는 &lt;em&gt;constant&lt;/em&gt; 입니다. &lt;em&gt;process load&lt;/em&gt; 의 경우에는 &lt;em&gt;15% packet loss&lt;/em&gt; 가 있을때 &lt;em&gt;optimal&lt;/em&gt; 의 8배인 &lt;code&gt;8L*&lt;/code&gt; 보다 적습니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;false positive rate&lt;/em&gt; 는 &lt;code&gt;K&lt;/code&gt; 를 증가시켜서 줄일 수 있습니다. &lt;code&gt;K&lt;/code&gt; 가 증가함에 따라 &lt;em&gt;false positive rate&lt;/em&gt; 는 지수적으로 감소합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/SWIM_accuracy_load.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;쿨하게 페이퍼를 보시라는 교수님&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/SWIM_detection_time.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;어째서 &lt;em&gt;expected detection time&lt;/em&gt; 이 &lt;code&gt;1 / e-1&lt;/code&gt; 일까요? 하나의 프로세스가 죽었을때, 핑 되려면 다른 프로세스의 멤버쉽 리스트에 있어야 하고, 랜덤하게 선택되야 합니다.&lt;/p&gt;

&lt;p&gt;랜덤하게 선택될 확률은 &lt;code&gt;1/N&lt;/code&gt; 이고, 선택되지 않을 확률은 &lt;code&gt;1 - 1/N&lt;/code&gt; 입니다. 다른 &lt;code&gt;N-1&lt;/code&gt; 개의 프로세스에 의해 모두 선택되지 않을 확률은 &lt;code&gt;(1-1/N)^N-1&lt;/code&gt; 이고, &lt;code&gt;1&lt;/code&gt; 에서 이 값을 빼면 선택될 확률입니다. 그리고 익히 알려진 바대로 &lt;del&gt;응?&lt;/del&gt; &lt;code&gt;N&lt;/code&gt; 이 매우 커지면 이 값은 &lt;code&gt;1-e^-1&lt;/code&gt; 과 같습니다.&lt;/p&gt;

&lt;p&gt;그리고 확률론을 잘 안다면 &lt;del&gt;응?&lt;/del&gt; 이 값에 기대값을 취하면 &lt;code&gt;e / e-1&lt;/code&gt; 이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/time_bounded_completeness.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;여기에 간단한 트릭을 이용하면 &lt;em&gt;worst case&lt;/em&gt; 로 &lt;code&gt;O(N)&lt;/code&gt;, 정확히는 &lt;code&gt;2N-1&lt;/code&gt; &lt;em&gt;period&lt;/em&gt; 내에 &lt;em&gt;failure&lt;/em&gt; 가 발견되도록 할 수 있습니다. &lt;em&gt;membership list&lt;/em&gt; 를 순회하다가, 마지막에 도달하면 랜덤하게 재배열 하는 것입니다.&lt;/p&gt;

&lt;p&gt;그러면 최악의 경우 2번째 멤버에 대해 &lt;em&gt;ping&lt;/em&gt; 을 날릴때 첫번째 멤버에 &lt;em&gt;failure&lt;/em&gt; 가 발생하고, 재 배열했을때 첫번째 멤버가 마지막에 있다면 &lt;code&gt;(N-1) + (N)&lt;/code&gt; 의 &lt;em&gt;period&lt;/em&gt; 가 걸립니다. 그리고 이것은 &lt;em&gt;accuracy&lt;/em&gt; 등 다른 &lt;em&gt;failure detector&lt;/em&gt; 의 속성들을 그대로 유지한채 &lt;em&gt;worst case&lt;/em&gt; 시간을 줄이는 결과를 만듭니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h4 id=&#34;dissemination-and-suspicion&#34;&gt;Dissemination and Suspicion&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;dissemiantion&lt;/em&gt; 방법으로&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Multicast&lt;/strong&gt; (Hardware / IP)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;unreliable&lt;/li&gt;
&lt;li&gt;multiple simultaneous multicasts&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2) &lt;strong&gt;Point-To-Point&lt;/strong&gt; (TCP / UDP)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expensive&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(3) &lt;strong&gt;Zero extra message:&lt;/strong&gt; Piggyback on Failure Detector messages&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Infection-style Dissemination (like &lt;em&gt;SWIM&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/infection_style_dissemination.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;슬라이드에서 볼 수 있듯이 &lt;em&gt;infection style dissemination&lt;/em&gt; 은 &lt;code&gt;λ log(N)&lt;/code&gt; &lt;em&gt;protocol periods&lt;/em&gt; 후에 &lt;code&gt;N^-(2λ-2)&lt;/code&gt; 개의 프로세스만 업데이트되지 않습니다. 바꿔말하면 &lt;code&gt;O(logN)&lt;/code&gt; 후에 대부분의 프로세스는 발견돈 &lt;em&gt;failure&lt;/em&gt; 정보를 업데이트 한다는 뜻입니다.&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;λ&lt;/code&gt; 는 &lt;em&gt;consistency level&lt;/em&gt; 을 결정하는 상수입니다. 어떤 경우에도 &lt;em&gt;SWIM detector&lt;/em&gt; 는 &lt;em&gt;failure&lt;/em&gt; 를 &lt;code&gt;2N-1&lt;/code&gt; 내에 발견하기 때문에 &lt;em&gt;completeness&lt;/em&gt; 100% 가 보장됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;suspicion-mechanism&#34;&gt;Suspicion Mechanism&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;false positive&lt;/em&gt; 가 발생하는 이유는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;perturbed processes&lt;/li&gt;
&lt;li&gt;package losses (e.g from congestion)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;SWIM&lt;/em&gt; 에서 사용했던 &lt;em&gt;indirect pinging&lt;/em&gt; 도 이 문제를 해결하지 못할 수 있습니다. (e.g &lt;em&gt;correlated message losses near pinged host&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;먼저 &lt;em&gt;failure&lt;/em&gt; 가 발견되었을때 다른 노드들에게 알리기 전에 먼저 &lt;em&gt;suspect&lt;/em&gt; 한다면 &lt;em&gt;false positive&lt;/em&gt; 비율을 줄일 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/1ambda/1ambda.github.io/master/assets/images/cloud-computing-concept-1/week2/suspicon_mechanism_state_machine.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그림이 좀 복잡한데, 프로세스(노드) &lt;code&gt;pi&lt;/code&gt; 기준으로 &lt;em&gt;state&lt;/em&gt; 가 어떻게 변하는지를 나타낸 그림이라고 보면 됩니다. &lt;code&gt;pj&lt;/code&gt; 에게 핑을 날려 응답하지 않으면 &lt;em&gt;suspected&lt;/em&gt; 상태로 변하고, 여기서 &lt;em&gt;timeout&lt;/em&gt; 되면 &lt;em&gt;failed&lt;/em&gt; 되어 &lt;code&gt;pj&lt;/code&gt; 가 &lt;em&gt;failure&lt;/em&gt; 라고 &lt;em&gt;dissemination&lt;/em&gt; 하는 상태가 됩니다.&lt;/p&gt;

&lt;p&gt;한 가지 발생할 수 있는 문제점은 &lt;em&gt;suspected&lt;/em&gt; 상태에서 &lt;em&gt;alive&lt;/em&gt; 상태로 반복적으로 전환될 수 있다는 점입니다. 이러한 혼란을 피하기 위해 &lt;em&gt;incarnation number&lt;/em&gt; 를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;프로세스 &lt;code&gt;pj&lt;/code&gt; 가 &lt;em&gt;suspected&lt;/em&gt; 메세지를 받았을때, &lt;em&gt;incarnation number&lt;/em&gt; 를 증가시킬 수 있는 것은 &lt;code&gt;pj&lt;/code&gt; 만 가능합니다. 그리고 &lt;em&gt;increase incarnation number&lt;/em&gt; 메시지를 받은 다른 프로세스들은 &lt;em&gt;alive&lt;/em&gt; &lt;code&gt;pj&lt;/code&gt; 메시지를 전달합니다.&lt;/p&gt;

&lt;p&gt;높은 숫자의 &lt;em&gt;incarnation number&lt;/em&gt; 가 더 우선합니다. 그리고 &lt;em&gt;suspect&lt;/em&gt; 와 &lt;em&gt;alive&lt;/em&gt; 같은 값이라면 &lt;em&gt;suspect&lt;/em&gt; 메시지로 처리됩니다. 그리고 &lt;em&gt;failed&lt;/em&gt; 메시지는 다른 어떤 메시지보다 더 높은 우선순위를 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;failures the norm, not the exception in datacenters&lt;/li&gt;
&lt;li&gt;every distributed system uses a failure detector&lt;/li&gt;
&lt;li&gt;many distributed systems use a membership service&lt;/li&gt;
&lt;li&gt;ring failure detection underlies &lt;em&gt;IBM SP2&lt;/em&gt; and many other similar clusters&lt;/li&gt;
&lt;li&gt;Gossip-style failure detection underlies AWS EC2/S3 (rumored)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;refs&#34;&gt;Refs&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;http://ook.co/solutions/cloud-computing/&#34;&gt;Title Image&lt;/a&gt;&lt;br /&gt;
(2) &lt;strong&gt;Cloud Computing Concept 1&lt;/strong&gt; by &lt;em&gt;Indranil Gupta&lt;/em&gt;, Coursera&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ML 03: Logistic Regression</title>
      <link>https://1ambda.github.io/data-analysis/machine-learning-week-3/</link>
      <pubDate>Sat, 25 Jun 2016 14:25:21 +0900</pubDate>
      
      <guid>https://1ambda.github.io/data-analysis/machine-learning-week-3/</guid>
      <description>

&lt;p&gt;지난 시간엔 &lt;em&gt;Regression&lt;/em&gt; 을 해결하기 위해 &lt;em&gt;graident descent&lt;/em&gt; 알고리즘을 도입했었다. &lt;em&gt;learning rate&lt;/em&gt;, &lt;em&gt;vectorization&lt;/em&gt; 등에 대해서 알아 보기도 했고. 이번시간엔 &lt;em&gt;classification&lt;/em&gt; 과 &lt;em&gt;regulrzation&lt;/em&gt; 에 대해서 배워 본다.&lt;/p&gt;

&lt;p&gt;이 수업이 재밌는 이유는 수식을 증명하는 것보다 수식속에 숨겨진 내용들을 직관적으로 이해할 수 있게 설명하기 때문이다. &lt;del&gt;그러나 교수님 과제는 제발 그만&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&#34;classification&#34;&gt;Classification&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;regression&lt;/em&gt; 이 &lt;em&gt;continuous value&lt;/em&gt; 를 다룬다면 &lt;strong&gt;Classification&lt;/strong&gt; 은 &lt;strong&gt;discrete value&lt;/strong&gt; 를 다룬다. 따라서 &lt;em&gt;Classification (분류)&lt;/em&gt; 의 예는,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;이메일이 스팸인지 / 아닌지&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;온라인 거래가 사기인지 / 아닌지 (Online Transaction: Fraudulent)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;악성 종양인지 / 아닌지&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://i.stack.imgur.com/VVtRW.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://stats.stackexchange.com&#34;&gt;http://stats.stackexchange.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 경우, &lt;em&gt;Regression&lt;/em&gt; 으로 문제를 풀면 당장은 맞아 보이나, 종양이 이상한 위치에 생겼을 경우 아래와 같이 직선이 크게 변한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.stack.imgur.com/nEC4H.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://stats.stackexchange.com&#34;&gt;http://stats.stackexchange.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;따라서 이렇게 &lt;em&gt;discrete value&lt;/em&gt; 에 대해서는 &lt;em&gt;Regression&lt;/em&gt; 보다는 &lt;em&gt;Threshold&lt;/em&gt; 에 기반을 두어, &lt;code&gt;h(x)&lt;/code&gt; 가 일정 값 이상이면 &lt;code&gt;y=1&lt;/code&gt; 로 예측하는 편이 더 정확도가 높아진다. 게다가 &lt;em&gt;regression&lt;/em&gt; 은 직선이기 때문에, &lt;code&gt;0 &amp;lt;= y &amp;lt;= 1&lt;/code&gt; 인 &lt;code&gt;y&lt;/code&gt; 에 대해서 0보다 작거나, 1보다 더 큰 &lt;code&gt;y&lt;/code&gt; 를 만들어낼 수 있다.&lt;/p&gt;

&lt;p&gt;이런 이유 때문에 &lt;em&gt;Classification&lt;/em&gt; 문제에 &lt;em&gt;Regression&lt;/em&gt; 을 잘 사용하지 않는다. 그러나 &lt;code&gt;y&lt;/code&gt; 의 범위가 &lt;code&gt;0 &amp;lt;= h(x) &amp;lt;= 1&lt;/code&gt; 을 가지는 &lt;em&gt;Logistic Regression&lt;/em&gt; 도 있다. 이건 &lt;em&gt;Classification&lt;/em&gt; 에 사용되기도 한다.&lt;/p&gt;

&lt;h3 id=&#34;logistic-regression&#34;&gt;Logistic Regression&lt;/h3&gt;

&lt;p&gt;이전에 언급했듯이 &lt;em&gt;classification&lt;/em&gt; 에선 예측된 값, 즉 &lt;code&gt;h(x)&lt;/code&gt; 값이 0 과 1사이에 있길 바란다. 이를 위해 &lt;em&gt;logistic function&lt;/em&gt;, 혹은 &lt;strong&gt;sigmoid function&lt;/strong&gt; 이라 불리는 아래 식을 &lt;em&gt;hypothesis&lt;/em&gt; &lt;code&gt;h(x)&lt;/code&gt; 에 적용하면 아래와 같은 그림이 나온다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.saedsayad.com/images/ANN_Sigmoid.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.saedsayad.com&#34;&gt;http://www.saedsayad.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이 때 &lt;em&gt;sigmoid function&lt;/em&gt; 이 적용된 &lt;code&gt;h(x)&lt;/code&gt; 는 최대값이 1이므로, 이건 입력값 &lt;code&gt;x&lt;/code&gt; 에 대해서 &lt;code&gt;y&lt;/code&gt; 가 1이 나올 확률이라 보아도 된다. 따라서&lt;/p&gt;

&lt;p&gt;&lt;code&gt;h(x) = P(y = 1 | x ; 0)&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Probability that &lt;code&gt;y = 1&lt;/code&gt;, given &lt;code&gt;x&lt;/code&gt;, parameterized by &lt;code&gt;0(theta)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 때 &lt;em&gt;sigmoid function&lt;/em&gt; 을 보면, X 축이 0보다 큰 점에선 &lt;code&gt;y&lt;/code&gt; 값이 0.5 보다 크므로, 이 점 이후부터는 &lt;code&gt;y&lt;/code&gt; 를 1 이라 &lt;em&gt;예측 (predict)&lt;/em&gt; 하고, 반대로 X 축 값이 0보다 작은 지점에선 &lt;code&gt;y&lt;/code&gt; 를 0이라 예측할 수 있다.&lt;/p&gt;

&lt;p&gt;그런데 &lt;code&gt;h(x) = g(0^T * x)&lt;/code&gt; 이므로, 본래의 &lt;em&gt;hypothesis&lt;/em&gt; &lt;code&gt;0^T * x&lt;/code&gt; 가 0이 되는 지점을 찾으면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my.csdn.net/uploads/201207/04/1341403634_5914.jpg&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://blog.csdn.net/abcjennifer/&#34;&gt;http://blog.csdn.net/abcjennifer/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;h3 id=&#34;decision-boundary&#34;&gt;Decision Boundary&lt;/h3&gt;

&lt;p&gt;이제 실제로 문제에 적용해 보자. 다음과 같이 두개의 집단이 있을때, 이 두 집단을 가르는 식을 찾기 위한 &lt;code&gt;h(x) = g(01 + 01x1 + 02x2)&lt;/code&gt; 가 있다고 해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my.csdn.net/uploads/201207/05/1341470683_7505.jpg&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://blog.csdn.net/abcjennifer/&#34;&gt;http://blog.csdn.net/abcjennifer/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이때 &lt;code&gt;0(theta)&lt;/code&gt; 를 &lt;code&gt;[-3; 1; 1]&lt;/code&gt; 로 잡으면 &lt;code&gt;y&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 이 되는 지점은 &lt;code&gt;0^T * x &amp;gt;= 0&lt;/code&gt; 인 지점, 즉 &lt;code&gt;-3 + x1 + x2 &amp;gt;= 0&lt;/code&gt; 인지점을 찾으면 된다. 이 식을 풀어서 쓰면&lt;/p&gt;

&lt;p&gt;&lt;code&gt;x1 + x2 =&amp;gt; 3&lt;/code&gt; 이므로, 위 그림에서 분홍색 선을 찾을 수 있다. 이 선을 &lt;strong&gt;Decision Boundary&lt;/strong&gt; 라 부른다. 그리고 이 &lt;em&gt;Decision Boundary&lt;/em&gt; 는 &lt;code&gt;g(z) = 0&lt;/code&gt; 즉,  &lt;code&gt;h(x) = 0.5&lt;/code&gt; 인 지점이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Non-linear dicision boundary&lt;/em&gt; 는 어떨까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://my.csdn.net/uploads/201207/05/1341471338_7289.jpg&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://blog.csdn.net/abcjennifer/&#34;&gt;http://blog.csdn.net/abcjennifer/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이 경우  &lt;code&gt;x1^2&lt;/code&gt;, &lt;code&gt;x2^2&lt;/code&gt; 이라는 새로운 &lt;em&gt;feature&lt;/em&gt; 를 도입하고, &lt;em&gt;parameter&lt;/em&gt; 인 &lt;code&gt;theta&lt;/code&gt; 를 &lt;code&gt;[-1; 0; 0; 1; 1;]&lt;/code&gt; 로 잡았다. 식을 풀면, 위와 같은 원 형태의 &lt;em&gt;Decision Boundary&lt;/em&gt; 가 나온다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;feature&lt;/em&gt; 만 잘 조합하면, 즉 &lt;em&gt;polynomial&lt;/em&gt; 만 잘 만들면 땅콩이나 하트모양 등의 &lt;em&gt;Decision boundary&lt;/em&gt; 도 만들 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;cost-function&#34;&gt;Cost Function&lt;/h3&gt;

&lt;p&gt;이제 문제는 &lt;code&gt;theta&lt;/code&gt; 를 어떻게 고르느냐 하는건데, 식을 좀 다시 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[9].png&#34; align=&#34;center&#34; /&gt;
&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[11].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Linear regression&lt;/em&gt; 에서 사용하는 &lt;em&gt;cost function&lt;/em&gt; 에 지금의 &lt;code&gt;h(x)&lt;/code&gt;, 즉 &lt;em&gt;sigmoid function&lt;/em&gt; 이 적용된 &lt;code&gt;h(x)&lt;/code&gt; 를 제곱한 &lt;code&gt;J(0)&lt;/code&gt; 는 &lt;em&gt;non-convex&lt;/em&gt; 형태가 된다. 따라서 &lt;em&gt;global optimum&lt;/em&gt; 보다는 &lt;em&gt;local optimum&lt;/em&gt; 을 찾게 된다.&lt;/p&gt;

&lt;p&gt;이를 방지하기 위해서, &lt;em&gt;convex&lt;/em&gt; 형태의 &lt;em&gt;cost function&lt;/em&gt; 을 사용해야 하는데,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[12].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이 &lt;em&gt;cost function&lt;/em&gt; 을 사용하면, &lt;code&gt;y = 1&lt;/code&gt; 일때 다음과 같은 그래프를 얻게 된다. &lt;code&gt;0 &amp;lt;= h(x) &amp;lt;= 1&lt;/code&gt; 임을 참고하자. &lt;code&gt;y = 1&lt;/code&gt; 일때, &lt;code&gt;h(x) = 0&lt;/code&gt; 으로 가면, &lt;em&gt;cost function&lt;/em&gt; 의 값, 즉 &lt;em&gt;cost&lt;/em&gt; 자체가 높아지므로, &lt;em&gt;Cost&lt;/em&gt; 를 낮추는 반대 방향으로 움직이게 된다.&lt;/p&gt;

&lt;p&gt;직관적으로 보면, &lt;code&gt;h(x)&lt;/code&gt; 자체는 &lt;code&gt;y = 1&lt;/code&gt; 일 확률인데, &lt;code&gt;y = 1&lt;/code&gt; 일때, &lt;code&gt;h(x) = 0&lt;/code&gt; 이라는 것은 말이 안 되므로 비용이 무한대로 증가하는 것이 말이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[13].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;반대로 &lt;code&gt;y = 0&lt;/code&gt; 일때의 그래프를 보면 &lt;code&gt;h(x) = 0&lt;/code&gt; 즉, &lt;code&gt;y = 0&lt;/code&gt; 일 확률이 &lt;code&gt;0&lt;/code&gt; 으로 갈때 &lt;em&gt;cost&lt;/em&gt; 가 감소한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[14].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;결국 아래의 새로운 &lt;em&gt;logistric regression cost function&lt;/em&gt; 을 이용하면, &lt;code&gt;J(0)&lt;/code&gt; 를 &lt;em&gt;convex function&lt;/em&gt; 으로 만들 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[12].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;h3 id=&#34;simplified-cost-function-and-gradient-descent&#34;&gt;Simplified Cost Function and Gradient Descent&lt;/h3&gt;

&lt;p&gt;이제 &lt;code&gt;y = 0&lt;/code&gt;, &lt;code&gt;y = 1&lt;/code&gt; 로 나누어져 있던 &lt;em&gt;cost function&lt;/em&gt; 을 좀 더 간단히 표현해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[15].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;다음과 동일하다. &lt;code&gt;y = 0&lt;/code&gt;, &lt;code&gt;y = 1&lt;/code&gt; 을 직접 넣어보면 금방 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cost(hθ(x),y) = -y * log(hθ(x)) - (1-y) * log(1 - hθ(x))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
자 이제 다시 본론으로 돌아와서, 우리는 처음에 &lt;code&gt;theta&lt;/code&gt; 를 찾길 원했고, 그래서 &lt;em&gt;gradient descent&lt;/em&gt; 를 쓰려고 했는데, 마침 보니 &lt;code&gt;h(x)&lt;/code&gt; 가 &lt;em&gt;sigmoid function&lt;/em&gt; 이 적용된 형태라서 &lt;em&gt;non-convex function&lt;/em&gt; 이므로, &lt;code&gt;h(x)&lt;/code&gt; 를 포함한 &lt;em&gt;cost-function&lt;/em&gt; 이 &lt;em&gt;convex function&lt;/em&gt; 이 되는 식을 찾아냈다. 이제 그 식을 &lt;em&gt;gradient descent&lt;/em&gt; 에 적용하면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[16].png&#34; align=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이고, 이제 이걸 &lt;em&gt;batch gradient descent&lt;/em&gt; 에 적용하면 아래와 같은데, 여기에 &lt;em&gt;partial derivative&lt;/em&gt; 를 적용하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[20].png&#34; align=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;p&gt;놀랍게도 &lt;em&gt;linear regression&lt;/em&gt; 과 같은 식이 나온다. &lt;del&gt;오오 머신러닝 오오&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[18].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;다만 다른점은 &lt;em&gt;hypothesis&lt;/em&gt; 가 &lt;em&gt;sigmoid function&lt;/em&gt; 을 적용한 형태라는 것,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[17].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;h3 id=&#34;advanced-optimization&#34;&gt;Advanced Optimization&lt;/h3&gt;

&lt;p&gt;위에서 보았겠지만, &lt;code&gt;J(0)&lt;/code&gt; 의 최소값을 찾기 위해서는 아래 두개의 값을 구해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[19].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이 값들을 이용해서 &lt;em&gt;gradient descent&lt;/em&gt; 대신 다음의 알고리즘을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;(1) Conjugate gradient&lt;br /&gt;
(2) BFGS&lt;br /&gt;
(3) L-BFGS&lt;/p&gt;

&lt;p&gt;이 알고리즘들의 장점은, &lt;em&gt;leanring rate&lt;/em&gt; 를 고를 필요가 없고, 대부분 &lt;em&gt;gradient decsent&lt;/em&gt; 보다 빠르다.&lt;/p&gt;

&lt;p&gt;그러나 더 복잡하고, 라이브러리마다 구현이 다를 수 있으며, 디버깅이 힘들수 있다. 자 이제 &lt;em&gt;advanced optimization&lt;/em&gt; 을 이용해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[21].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 식에 대해서 &lt;em&gt;cost function&lt;/em&gt; 을 &lt;code&gt;octave&lt;/code&gt; 에서 이렇게 만들 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[22].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;이제, &lt;code&gt;octave&lt;/code&gt; 에서 제공해 주는 &lt;code&gt;fminunc&lt;/code&gt; 에 우리가 만든 &lt;code&gt;costFunction&lt;/code&gt; 과 초기 &lt;code&gt;theta&lt;/code&gt; 값, 그리고 옵션을 집어 넣으면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-matlab&#34;&gt;% define the options data structure
options= optimset(&#39;GradObj&#39;, &#39;on&#39;, &#39;MaxIter&#39;, &#39;100&#39;); 

% set the initial dimensions for theta % initialize the theta values
initialTheta= zeros(2,1); 

% run the algorithm
[optTheta, funtionVal, exitFlag]= fminunc(@costFunction, initialTheta, options); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;optTheta&lt;/code&gt; 는 우리 찾길 원했던 &lt;code&gt;theta&lt;/code&gt; 값이고, &lt;code&gt;functionVal&lt;/code&gt; 은 최종 &lt;em&gt;cost&lt;/em&gt; 를 돌려준다. &lt;code&gt;exstFlag&lt;/code&gt; 는 알고리즘이 수렴했는지, 아닌지 알려준다.&lt;/p&gt;

&lt;p&gt;만약 &lt;em&gt;logistic regression&lt;/em&gt; 에 대한 &lt;code&gt;theta&lt;/code&gt; 값을 찾고 싶으면, &lt;em&gt;cost function&lt;/em&gt; 을 &lt;em&gt;logistic regression&lt;/em&gt; 에 맞게 작성하면 된다.&lt;/p&gt;

&lt;h3 id=&#34;multiclass-classification&#34;&gt;Multiclass Classification&lt;/h3&gt;

&lt;p&gt;이제 단순히 &lt;code&gt;y = 0 or 1&lt;/code&gt;(&lt;em&gt;binary classification&lt;/em&gt;) 이 아닌, 다양한 &lt;em&gt;class&lt;/em&gt; 가 있는 &lt;em&gt;classification&lt;/em&gt; 을 고려해보자, 예를 들면 날씨는 &lt;code&gt;sunny&lt;/code&gt;, &lt;code&gt;cloudy&lt;/code&gt;, &lt;code&gt;hot&lt;/code&gt;, &lt;code&gt;cold&lt;/code&gt; 등으로 분류될 수 있다.&lt;/p&gt;

&lt;h4 id=&#34;one-vs-all-one-vs-rest&#34;&gt;one-vs-all (One-vs-rest)&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;multi class&lt;/em&gt; 를 분류할 수 있는 한가지 방법은, 하나를 정하고, 그 나머지와 분류하는것이다. 이걸 &lt;em&gt;class&lt;/em&gt; 갯수만큼 진행하면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[23].png&#34; align=&#34;center&#34; /&gt;
&lt;img src=&#34;http://www.holehouse.org/mlclass/06_Logistic_Regression_files/Image%20[24].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;위 그림과 같은 경우, &lt;em&gt;class&lt;/em&gt; 가 3개기 때문에 &lt;code&gt;(i = 1, 2, 3)&lt;/code&gt; 으로 놓으면 &lt;code&gt;i&lt;/code&gt; 마다 각각의 &lt;code&gt;hθ^(i)(x)&lt;/code&gt; 값, 즉 예측 값을 얻을 수 있다. 따라서 새로운 무언가가 input 으로 들어왔을때, &lt;code&gt;hθ^(i)(x)&lt;/code&gt; 값을 최대로 해주는 &lt;code&gt;i&lt;/code&gt; 을 선택하면 분류가 된다. &lt;del&gt;참 쉽죠?&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&#34;overfitting&#34;&gt;Overfitting&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Overfitting&lt;/strong&gt; 은 너무나 많은 &lt;em&gt;feature&lt;/em&gt; 가 있을 때는 &lt;em&gt;cost function&lt;/em&gt; 이 트레이닝 셋에 잘 맞아 &lt;code&gt;0&lt;/code&gt; 에 수렴 하지만, 새로운 데이터가 들어왔을때는 예측을 잘 하지 못하는 경우를 말한다. 다시 말해 &lt;em&gt;hypothesis&lt;/em&gt; 가 너무 고차원의 다항식이어서 그렇다. &lt;em&gt;(too many parameters)&lt;/em&gt; 즉 아래 그림에서 좌측은 경향을 나타내긴 하지만 모든 트레이닝셋을 경유하는 직선은 만들어내지 못했다. (&lt;em&gt;under fit&lt;/em&gt;) 반면 가장 우측은, 트레이닝셋을 모두 경유하는 &lt;em&gt;hypothesis&lt;/em&gt; 를 만들어 냈지만, 다항식의 차수가 너무 높아 새로운 데이터가 들어왔을 때 예측하지 못할 수가 있다. &lt;em&gt;can&amp;rsquo;t apply, unable to generalize&lt;/em&gt; 교수님은 다음과 같이 슬라이드에 적으셨다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It makes accurate predictions for examples in the training set, but it does not generalize well to make accurate prediction on new, previously unseen examples&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/07_Regularization_files/Image.png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;logistic regression&lt;/em&gt; 에서도 &lt;em&gt;Overfitting&lt;/em&gt; 이 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/07_Regularization_files/Image%20[1].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;주로 &lt;em&gt;training set&lt;/em&gt; 이 부족하고 &lt;em&gt;feature&lt;/em&gt; 가 많을때 발생하는데 해결책은&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;feature&lt;/em&gt; 를 줄일 수 있다. 수동으로 사용할 &lt;em&gt;feature&lt;/em&gt; 를 선택하는 방법과 &lt;em&gt;Model selection algorithm&lt;/em&gt; 을 사용할 수도 있다.&lt;br /&gt;
(2)  &lt;em&gt;regularization&lt;/em&gt; 을 이용한다. 모든 &lt;em&gt;feature&lt;/em&gt; 를 유지하지만, 얼마나 각 &lt;em&gt;feature&lt;/em&gt; 가 &lt;em&gt;prediction&lt;/em&gt; 에 기여할지를 변경한다.&lt;/p&gt;

&lt;h3 id=&#34;regularization-cost-function&#34;&gt;Regularization, Cost function&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Regularization&lt;/em&gt; 은 원하는 파라미터가 &lt;em&gt;hypothesis&lt;/em&gt; 에 기여하는 바를 조절하는 것이다. 우리가 만약에 &lt;code&gt;0_3&lt;/code&gt; 과 &lt;code&gt;0_4&lt;/code&gt; 를 최소화 하고 싶다고 하자.  그럼 다음과 같은 식을 만들면 된다. 전체 식의 최소값을 찾는 것이기 때문에, 상수가 &lt;code&gt;1000&lt;/code&gt; 인 &lt;code&gt;0_3&lt;/code&gt;, &lt;code&gt;0_4&lt;/code&gt; 는 &lt;em&gt;0(zero)&lt;/em&gt; 에 가까운 수가 나온다. 다시 말해서 이들 두 파라미터가 기여하는 바를 줄인 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/07_Regularization_files/Image%20[2].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;parameters&lt;/em&gt; 가 작은 값을 가질수록 간단한 &lt;em&gt;hypothesis&lt;/em&gt; 가 나오고, &lt;em&gt;overfitting&lt;/em&gt; 하지 않는다. 이를 위해 &lt;code&gt;λ&lt;/code&gt; 라는 &lt;em&gt;regularization parameter&lt;/em&gt; 를 가진 식을 &lt;em&gt;cost function&lt;/em&gt; 에 더 붙여 &lt;em&gt;parameter&lt;/em&gt; 가 기여하는 바를 조절하면, 아래와 같은 식을 구할 수 있다. 참고로 뒷 부분의 식은  &lt;em&gt;regularization term&lt;/em&gt; 이라 부르는데, &lt;code&gt;j&lt;/code&gt; 가 1부터 시작하는 것에 주목하자. 이는 &lt;code&gt;0_0&lt;/code&gt; 은 &lt;em&gt;regularization&lt;/em&gt; 하지 않는다는 의미이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/07_Regularization_files/Image%20[5].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;λ&lt;/code&gt; 가 매우 크면 어떻게 될까? &lt;code&gt;0_0&lt;/code&gt; 이외의 다른 파라미터는 0에 수렴 하므로, &lt;em&gt;hypothesis&lt;/em&gt; 는 상수가 되어 트레이닝 셋에 &lt;em&gt;under fit&lt;/em&gt; 할 것이다.&lt;/p&gt;

&lt;h3 id=&#34;regularized-linear-regression&#34;&gt;Regularized Linear Regression&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;regularization term&lt;/em&gt; 으 &lt;code&gt;j&lt;/code&gt; 가 1부터 시작하므로, &lt;em&gt;cost function&lt;/em&gt; 을 쉽게 계산하기 위해 분리하면 &lt;em&gt;gradient descent&lt;/em&gt; 식은 다음과 같이 적을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/07_Regularization_files/Image%20[6].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이제 위 두 식에서 아래 식을 정리하면, 다음과 같고&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/07_Regularization_files/Image%20[8].png&#34; align=&#34;center&#34; /&gt;
&amp;lt;면 된다. 이때 이 매트릭스의 &lt;code&gt;(0, 0)&lt;/code&gt;
위 식에서 앞부분은 아래와 같다. 보통 &lt;code&gt;m&lt;/code&gt; 이 매우 크고, &lt;code&gt;a&lt;/code&gt; 가 매우 작으므로 위 값은 1보다 작다. 예를 들면 &lt;code&gt;0.99 * 0_j&lt;/code&gt; 처럼.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/07_Regularization_files/Image%20[9].png&#34; align=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;em&gt;Normal equation&lt;/em&gt; 에 어떻게 적용할지 고려해 보자, 본래 &lt;em&gt;normal equation&lt;/em&gt; 식은 아래와 같은데,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/04_Linear_Regression_with_multiple_variables_files/Image%20[13].png&#34; align=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;X^T * X&lt;/code&gt; 부분에 &lt;code&gt;λ&lt;/code&gt; 가 곱해지는 &lt;code&gt;n+1 * n+1&lt;/code&gt; 의 &lt;em&gt;matrix&lt;/em&gt; 를 곱하면 된다. 이때 이 매트릭스의 &lt;code&gt;(0, 0)&lt;/code&gt; 부분이 &lt;code&gt;0&lt;/code&gt; 인 것은 &lt;code&gt;0_0&lt;/code&gt; 에 &lt;em&gt;regularization&lt;/em&gt; 을 적용하지 않기 위한 것.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/07_Regularization_files/Image%20[10].png&#34; align=&#34;center&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그럼 만약에 &lt;code&gt;X^T * X&lt;/code&gt; 가 &lt;em&gt;non-invertible&lt;/em&gt; 이라면 어떻게 될까? 이건 지난 시간에 언급했듯이 &lt;em&gt;redundant feature&lt;/em&gt; 가 너무 많거나, &lt;code&gt;m &amp;lt;= n&lt;/code&gt;, 즉 트레이닝 셋에 비해 &lt;em&gt;feature&lt;/em&gt; 가 너무 많을 때 발생한다고 말했다.&lt;/p&gt;

&lt;p&gt;놀랍게도, &lt;code&gt;λ &amp;gt; 0&lt;/code&gt; 이면, 아래 식에서 &lt;code&gt;X^T * X + λ&lt;/code&gt; (λ&amp;rsquo;s (0, 0) = 0) 은 제대로 &lt;em&gt;invertible&lt;/em&gt; 함을 증명할 수 있다. 다시 말해서 &lt;em&gt;regularzation&lt;/em&gt; 을 통해서 &lt;em&gt;non-invertible&lt;/em&gt; 문제도 해결할 수 있다는 것.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/07_Regularization_files/Image%20[10].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;h3 id=&#34;regularized-logistic-regression&#34;&gt;Regularized Logistic Regression&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;linear regression&lt;/em&gt; 과 마찬가지로 &lt;code&gt;0(theta)&lt;/code&gt; 를 0과 1로 분리해 &lt;em&gt;regularization term&lt;/em&gt; 을 추가하면 된다. 다른점은 &lt;code&gt;h(x)&lt;/code&gt; 가 &lt;em&gt;sigmoid function&lt;/em&gt; 의 형태라는 것.&lt;/p&gt;

&lt;p&gt;그리고 &lt;em&gt;gradient descent&lt;/em&gt; 를 풀기 위해 &lt;em&gt;octave&lt;/em&gt; 에서 제공하는 알고리즘들을(&lt;em&gt;conjugate&lt;/em&gt;, &lt;em&gt;BFGS&lt;/em&gt;, &lt;em&gt;L-BFGS&lt;/em&gt; 등) 을 &lt;code&gt;fminunc&lt;/code&gt; 이용해서 사용할 수 있다. 이를 위해 언급 했듯이 &lt;code&gt;jval&lt;/code&gt; 과 &lt;code&gt;0(theta)&lt;/code&gt; 에 대한 &lt;code&gt;graident&lt;/code&gt; 를 돌려주는 &lt;em&gt;cost function&lt;/em&gt; 을 만들어야 하는데, &lt;em&gt;regularzation term&lt;/em&gt; 이 추가되었으므로 해당하는 값을 더해서 각 &lt;code&gt;0&lt;/code&gt; 에 대한 &lt;em&gt;gradient&lt;/em&gt; 를 계산하는 식을 만들어주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holehouse.org/mlclass/07_Regularization_files/Image%20[16].png&#34; align=&#34;center&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;)&lt;/p&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;3주째에는 &lt;em&gt;Classification&lt;/em&gt; 과 &lt;em&gt;Regularization&lt;/em&gt; 에 대해서 배웠다. 수업은 어렵지 않다. 과제가 문제지 ㅠㅠ 교수님. 파이썬으로 과제를 내주셨으면 좀 더 배우는 맛이 있었을텐데요!&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;a href=&#34;http://stats.stackexchange.com/questions/22381/why-not-approach-classification-through-regression&#34;&gt;why-not-approach-classification-through-regression&lt;/a&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://www.saedsayad.com/artificial_neural_network.htm&#34;&gt;http://www.saedsayad.com&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://blog.csdn.net/abcjennifer/&#34;&gt;http://blog.csdn.net/abcjennifer/&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://www.holehouse.org/&#34;&gt;http://www.holehouse.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Machine Learning&lt;/strong&gt; by Andrew Ng, &lt;em&gt;Coursera&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>