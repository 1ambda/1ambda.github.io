<!DOCTYPE html>
<html lang="en" class="js csstransforms3d">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="generator" content="Hugo 0.18-DEV" />
    <meta name="description" content="hugo content for 1ambda.github.io">
<meta name="author" content="1ambda">

    <link rel="shortcut icon" href="https://1ambda.github.io/images/favicon.png" type="image/x-icon" />

    
    <title>하스켈로 배우는 함수형 언어 4</title>
    <link href="https://1ambda.github.io/css/nucleus.css" rel="stylesheet">
    <link href="https://1ambda.github.io/css/font-awesome.min.css" rel="stylesheet">
    <link href="https://1ambda.github.io/css/hybrid.css" rel="stylesheet">
    <link href="https://1ambda.github.io/css/featherlight.min.css" rel="stylesheet">
    <link href="https://1ambda.github.io/css/perfect-scrollbar.min.css" rel="stylesheet">
    <link href="https://1ambda.github.io/css/horsey.css" rel="stylesheet">
    <link href="https://1ambda.github.io/css/theme.css" rel="stylesheet">
    <link href="https://1ambda.github.io/css/hugo-theme.css" rel="stylesheet">
    <script src="https://1ambda.github.io/js/jquery-2.x.min.js"></script>
    <style type="text/css">:root #header + #content > #left > #rlblock_left
    {display:none !important;}</style>
    <link href="https://1ambda.github.io/css/theme-1ambda.css" rel="stylesheet">

  </head>
  <body class="" data-url="/haskell/intro-to-haskell-4/">
    <nav id="sidebar">
  <div id="header-wrapper">
    <div id="header">
      <a href="https://1ambda.github.io/home" style="color: white; margin-top:10px;">
  <div> <i class="fa fa-github fa-4x"></i> </div>
</a>
<div style="margin-top:5px; font-size: 25px;">1ambda</div>

    </div>
    
</div>


  <div class="highlightable">
    <ul class="topics">
      
      
        
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
      
      
      
      

      
        
      
      
      

      <li class="dd-item  " data-nav-id="/home/">
        <a href="https://1ambda.github.io/home/">
          <span>
            
              <b>HOME</b>
            
             
            
           </span>
        </a>
        
      </li>
      
      
      

      
        
      
      
      

      <li class="dd-item  " data-nav-id="/infrastructure/">
        <a href="https://1ambda.github.io/infrastructure/">
          <span>
            
              <b>- </b>
            
             Infrastructure
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/infrastructure/container/kubernetes-intro/">
              <a href="https://1ambda.github.io/infrastructure/container/kubernetes-intro/">
                <span>Kubernetes: Intro     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      

      
        
      
      
      

      <li class="dd-item  " data-nav-id="/golang/">
        <a href="https://1ambda.github.io/golang/">
          <span>
            
              <b>- </b>
            
             Golang
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/golang/golang-tutorial/">
              <a href="https://1ambda.github.io/golang/golang-tutorial/">
                <span>Golang Tutorial     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      

      
        
      
      
      

      <li class="dd-item  " data-nav-id="/scala/">
        <a href="https://1ambda.github.io/scala/">
          <span>
            
              <b>-</b>
            
             Scala
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/scala/easy-scalaz-1/">
              <a href="https://1ambda.github.io/scala/easy-scalaz-1/">
                <span>Easy Scalaz 1     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/easy-scalaz-2/">
              <a href="https://1ambda.github.io/scala/easy-scalaz-2/">
                <span>Easy Scalaz 2     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/easy-scalaz-3/">
              <a href="https://1ambda.github.io/scala/easy-scalaz-3/">
                <span>Easy Scalaz 3     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/easy-scalaz-4/">
              <a href="https://1ambda.github.io/scala/easy-scalaz-4/">
                <span>Easy Scalaz 4     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/easy-scalaz-5/">
              <a href="https://1ambda.github.io/scala/easy-scalaz-5/">
                <span>Easy Scalaz 5     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/easy-scalaz-6/">
              <a href="https://1ambda.github.io/scala/easy-scalaz-6/">
                <span>Easy Scalaz 6     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/functional-programming-1/">
              <a href="https://1ambda.github.io/scala/functional-programming-1/">
                <span>Functional Programming 1     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/functional-programming-2/">
              <a href="https://1ambda.github.io/scala/functional-programming-2/">
                <span>Functional Programming 2     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/functional-programming-3/">
              <a href="https://1ambda.github.io/scala/functional-programming-3/">
                <span>Functional Programming 3     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/functional-programming-4/">
              <a href="https://1ambda.github.io/scala/functional-programming-4/">
                <span>Functional Programming 4     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/functional-programming-5/">
              <a href="https://1ambda.github.io/scala/functional-programming-5/">
                <span>Functional Programming 5     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/functional-programming-6/">
              <a href="https://1ambda.github.io/scala/functional-programming-6/">
                <span>Functional Programming 6     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/functional-programming-7/">
              <a href="https://1ambda.github.io/scala/functional-programming-7/">
                <span>Functional Programming 7     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/reactive-programming-1/">
              <a href="https://1ambda.github.io/scala/reactive-programming-1/">
                <span>Reactive Programming 1     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/reactive-programming-2/">
              <a href="https://1ambda.github.io/scala/reactive-programming-2/">
                <span>Reactive Programming 2     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/reactive-programming-3/">
              <a href="https://1ambda.github.io/scala/reactive-programming-3/">
                <span>Reactive Programming 3     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/reactive-programming-4/">
              <a href="https://1ambda.github.io/scala/reactive-programming-4/">
                <span>Reactive Programming 4     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/scala/reactive-programming-5/">
              <a href="https://1ambda.github.io/scala/reactive-programming-5/">
                <span>Reactive Programming 5     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      

      
        
      
      
      

      <li class="dd-item  parent" data-nav-id="/haskell/">
        <a href="https://1ambda.github.io/haskell/">
          <span>
            
              <b>- </b>
            
             Haskell
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/haskell/intro-to-haskell-1/">
              <a href="https://1ambda.github.io/haskell/intro-to-haskell-1/">
                <span>하스켈로 배우는 함수형 언어 1     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/haskell/intro-to-haskell-2/">
              <a href="https://1ambda.github.io/haskell/intro-to-haskell-2/">
                <span>하스켈로 배우는 함수형 언어 2     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/haskell/intro-to-haskell-3/">
              <a href="https://1ambda.github.io/haskell/intro-to-haskell-3/">
                <span>하스켈로 배우는 함수형 언어 3     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item active" data-nav-id="/haskell/intro-to-haskell-4/">
              <a href="https://1ambda.github.io/haskell/intro-to-haskell-4/">
                <span>하스켈로 배우는 함수형 언어 4     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/haskell/intro-to-haskell-5/">
              <a href="https://1ambda.github.io/haskell/intro-to-haskell-5/">
                <span>하스켈로 배우는 함수형 언어 5     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/haskell/intro-to-haskell-6/">
              <a href="https://1ambda.github.io/haskell/intro-to-haskell-6/">
                <span>하스켈로 배우는 함수형 언어 6     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/haskell/intro-to-haskell-7/">
              <a href="https://1ambda.github.io/haskell/intro-to-haskell-7/">
                <span>하스켈로 배우는 함수형 언어 7     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/haskell/intro-to-haskell-8/">
              <a href="https://1ambda.github.io/haskell/intro-to-haskell-8/">
                <span>하스켈로 배우는 함수형 언어 8     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/haskell/intro-to-haskell-9/">
              <a href="https://1ambda.github.io/haskell/intro-to-haskell-9/">
                <span>하스켈로 배우는 함수형 언어 9     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/haskell/poor-mans-concurrency-monad/">
              <a href="https://1ambda.github.io/haskell/poor-mans-concurrency-monad/">
                <span>Poor Man&#39;s Concurrency Monad     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      

      
        
      
      
      

      <li class="dd-item  " data-nav-id="/java/">
        <a href="https://1ambda.github.io/java/">
          <span>
            
              <b>- </b>
            
             Java
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/java/interview-questions-collection/">
              <a href="https://1ambda.github.io/java/interview-questions-collection/">
                <span>Interview Questions: Collection     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      

      
        
      
      
      

      <li class="dd-item  " data-nav-id="/javascripts/">
        <a href="https://1ambda.github.io/javascripts/">
          <span>
            
              <b>- </b>
            
             Javascript
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/javascripts/javascript-inheritance/">
              <a href="https://1ambda.github.io/javascripts/javascript-inheritance/">
                <span>Javascript Inheritance     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/javascripts/tips-for-webpack-and-redux/">
              <a href="https://1ambda.github.io/javascripts/tips-for-webpack-and-redux/">
                <span>Tips for Webpack and Redux     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/javascripts/rest-api-put-vs-post/">
              <a href="https://1ambda.github.io/javascripts/rest-api-put-vs-post/">
                <span>REST API: Put vs Post     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      

      
        
      
      
      

      <li class="dd-item  " data-nav-id="/oh-my-github/">
        <a href="https://1ambda.github.io/oh-my-github/">
          <span>
            
              <b>- </b>
            
             oh-my-github
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/oh-my-github/tutorial/">
              <a href="https://1ambda.github.io/oh-my-github/tutorial/">
                <span>10분만에 Github Profile 만들기     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      

      
        
      
      
      

      <li class="dd-item  " data-nav-id="/algorithm/">
        <a href="https://1ambda.github.io/algorithm/">
          <span>
            
              <b>- </b>
            
             Algorithm
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/design-and-analysis-part1-1/">
              <a href="https://1ambda.github.io/algorithm/design-and-analysis-part1-1/">
                <span>Design and Analysis: Divide &amp; Conquer     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/design-and-analysis-part1-2/">
              <a href="https://1ambda.github.io/algorithm/design-and-analysis-part1-2/">
                <span>Design and Analysis: Randomized Selection     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/design-and-analysis-part1-3/">
              <a href="https://1ambda.github.io/algorithm/design-and-analysis-part1-3/">
                <span>Design and Analysis: Graph Contraction Algorithm     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/design-and-analysis-part1-4/">
              <a href="https://1ambda.github.io/algorithm/design-and-analysis-part1-4/">
                <span>Design and Analysis: Graph Search and Connectivity     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/design-and-analysis-part1-5/">
              <a href="https://1ambda.github.io/algorithm/design-and-analysis-part1-5/">
                <span>Design and Analysis: Dijkstra, Heap, Red-Black Tree     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/design-and-analysis-part1-6/">
              <a href="https://1ambda.github.io/algorithm/design-and-analysis-part1-6/">
                <span>Design and Analysis: Hash Table, Universal Hashing, Bloom filters     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/algorithm-part1-1/">
              <a href="https://1ambda.github.io/algorithm/algorithm-part1-1/">
                <span>Algorithm: Union Find     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/algorithm-part1-2/">
              <a href="https://1ambda.github.io/algorithm/algorithm-part1-2/">
                <span>Algorithm: Analysis     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/algorithm-part2-1/">
              <a href="https://1ambda.github.io/algorithm/algorithm-part2-1/">
                <span>Algorithm: Spanning Tree, Shortest Paths     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/algorithm-part2-2/">
              <a href="https://1ambda.github.io/algorithm/algorithm-part2-2/">
                <span>Algorithm: Radix Sort, Suffix Sort     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/algorithm-part2-3/">
              <a href="https://1ambda.github.io/algorithm/algorithm-part2-3/">
                <span>Algorithm: R-way, Ternary Tries     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/algorithm-part2-4/">
              <a href="https://1ambda.github.io/algorithm/algorithm-part2-4/">
                <span>Algorithm: KMP, Boyer-Moore, Rabin-Karp     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/algorithm-part2-5/">
              <a href="https://1ambda.github.io/algorithm/algorithm-part2-5/">
                <span>Algorithm: Maximum Flow (Ford-Fulkerson)     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/algorithm-part2-6/">
              <a href="https://1ambda.github.io/algorithm/algorithm-part2-6/">
                <span>Algorithm: Data Compression, Huffman, LZW     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/artificial-intelligence-cs188-1/">
              <a href="https://1ambda.github.io/algorithm/artificial-intelligence-cs188-1/">
                <span>AI (CS188): Intro     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/artificial-intelligence-cs188-2/">
              <a href="https://1ambda.github.io/algorithm/artificial-intelligence-cs188-2/">
                <span>AI (CS188): Search     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/artificial-intelligence-planning-1/">
              <a href="https://1ambda.github.io/algorithm/artificial-intelligence-planning-1/">
                <span>AI Planning 1: Intro     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/artificial-intelligence-planning-2/">
              <a href="https://1ambda.github.io/algorithm/artificial-intelligence-planning-2/">
                <span>AI Planning 2: A*. STRIPS     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/artificial-intelligence-planning-3/">
              <a href="https://1ambda.github.io/algorithm/artificial-intelligence-planning-3/">
                <span>AI Planning 3: PSP, PoP     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/algorithm/artificial-intelligence-planning-4/">
              <a href="https://1ambda.github.io/algorithm/artificial-intelligence-planning-4/">
                <span>AI Planning 4: STN, HTN     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      

      
        
      
      
      

      <li class="dd-item  " data-nav-id="/data-analysis/">
        <a href="https://1ambda.github.io/data-analysis/">
          <span>
            
              <b>- </b>
            
             Data Analysis
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/machine-learning-week-1/">
              <a href="https://1ambda.github.io/data-analysis/machine-learning-week-1/">
                <span>ML 01: Linear Regression     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/machine-learning-week-2/">
              <a href="https://1ambda.github.io/data-analysis/machine-learning-week-2/">
                <span>ML 02: Gradient Descent     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/machine-learning-week-3/">
              <a href="https://1ambda.github.io/data-analysis/machine-learning-week-3/">
                <span>ML 03: Logistic Regression     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/machine-learning-week-4/">
              <a href="https://1ambda.github.io/data-analysis/machine-learning-week-4/">
                <span>ML 04: Neural Network     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/machine-learning-week-5/">
              <a href="https://1ambda.github.io/data-analysis/machine-learning-week-5/">
                <span>ML 05: Back Propagation     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/machine-learning-week-6/">
              <a href="https://1ambda.github.io/data-analysis/machine-learning-week-6/">
                <span>ML 06: Practical Advices     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/machine-learning-week-7/">
              <a href="https://1ambda.github.io/data-analysis/machine-learning-week-7/">
                <span>ML 07: Support Vector Machine     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/machine-learning-week-8/">
              <a href="https://1ambda.github.io/data-analysis/machine-learning-week-8/">
                <span>ML 08: K-means, PCA Details     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/machine-learning-week-9/">
              <a href="https://1ambda.github.io/data-analysis/machine-learning-week-9/">
                <span>ML 09: Anomaly Detection, Recommender System     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/machine-learning-week-10/">
              <a href="https://1ambda.github.io/data-analysis/machine-learning-week-10/">
                <span>ML 10: Stochastic Gradient, Synthetic Data, Ceiling Analysis     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/intro-to-data-science-1/">
              <a href="https://1ambda.github.io/data-analysis/intro-to-data-science-1/">
                <span>Intro to Data Science 1     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/intro-to-data-science-2/">
              <a href="https://1ambda.github.io/data-analysis/intro-to-data-science-2/">
                <span>Intro to Data Science 2     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/intro-to-data-science-3/">
              <a href="https://1ambda.github.io/data-analysis/intro-to-data-science-3/">
                <span>Intro to Data Science 3     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/intro-to-data-science-4/">
              <a href="https://1ambda.github.io/data-analysis/intro-to-data-science-4/">
                <span>Intro to Data Science 4     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/process-mining-1/">
              <a href="https://1ambda.github.io/data-analysis/process-mining-1/">
                <span>Process Mining 1: Intro     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/process-mining-2/">
              <a href="https://1ambda.github.io/data-analysis/process-mining-2/">
                <span>Process Mining 2: Alpha Algorithm     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/process-mining-3/">
              <a href="https://1ambda.github.io/data-analysis/process-mining-3/">
                <span>Process Mining 3: Metric, C-nets     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/process-mining-4/">
              <a href="https://1ambda.github.io/data-analysis/process-mining-4/">
                <span>Process Mining 4: Conformance Checking, Dotted Chart     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/process-mining-5/">
              <a href="https://1ambda.github.io/data-analysis/process-mining-5/">
                <span>Process Mining 5: Decision, Social, Organization Mining     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/pattern-discovery-1/">
              <a href="https://1ambda.github.io/data-analysis/pattern-discovery-1/">
                <span>Pattern Discovery 1: Apriori, FP Growth     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/pattern-discovery-2/">
              <a href="https://1ambda.github.io/data-analysis/pattern-discovery-2/">
                <span>Pattern Discovery 2: Null-invariant, Pattern-Fusion, Constaint     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/data-analysis/pattern-discovery-3/">
              <a href="https://1ambda.github.io/data-analysis/pattern-discovery-3/">
                <span>Pattern Discovery 3: Sequential Pattern Mining     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
      

      
        
      
      
      

      <li class="dd-item  " data-nav-id="/cloud-computing/">
        <a href="https://1ambda.github.io/cloud-computing/">
          <span>
            
              <b>- </b>
            
             Cloud Computing
            
           </span>
        </a>
        
        <ul>
          
          
          
          
            <li class="dd-item " data-nav-id="/cloud-computing/cloud-computing-1/">
              <a href="https://1ambda.github.io/cloud-computing/cloud-computing-1/">
                <span>CC 01: Map Reduce     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/cloud-computing/cloud-computing-2/">
              <a href="https://1ambda.github.io/cloud-computing/cloud-computing-2/">
                <span>CC 02: Gossip Protocol     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/cloud-computing/cloud-computing-3/">
              <a href="https://1ambda.github.io/cloud-computing/cloud-computing-3/">
                <span>CC 03: Membership Protocol     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/cloud-computing/cloud-computing-4/">
              <a href="https://1ambda.github.io/cloud-computing/cloud-computing-4/">
                <span>CC 04: P2P Systems     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/cloud-computing/cloud-computing-5/">
              <a href="https://1ambda.github.io/cloud-computing/cloud-computing-5/">
                <span>CC 05: Global Snapshot     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/cloud-computing/cloud-computing-6/">
              <a href="https://1ambda.github.io/cloud-computing/cloud-computing-6/">
                <span>CC 06: Multicast     </i></span>
              </a>
            </li>
          
          
          
            <li class="dd-item " data-nav-id="/cloud-computing/cloud-computing-7/">
              <a href="https://1ambda.github.io/cloud-computing/cloud-computing-7/">
                <span>CC 07: Paxos     </i></span>
              </a>
            </li>
          
          
        </ul>
        
      </li>
      
      
    </ul>
    <hr>
     
    <section id="footer">
      <p>Built with <a href="https://github.com/matcornic/hugo-theme-learn"><i class="fa fa-heart"></i></a> from <a href="http://getgrav.org">Grav</a> and <a href="http://gohugo.io/">Hugo</a></p>
    </section>
  </div>
</nav>

        <section id="body">
        <div id="overlay"></div>

        <div class="padding highlightable">

            <div id="top-bar">
              
                
                
                
              <div id="top-github-link">
                  <a class="github-link" href="https://github.com/1ambda/1ambda.github.io-hugo/edit/master/content/haskell/intro-to-haskell-4.md" target="blank">
                    <i class="fa fa-code-fork"></i>
                    Edit this page
                  </a>
              </div>
                
              
              <div id="breadcrumbs" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
                  <span id="sidebar-toggle-span">
                      <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
                        <i class="fa fa-bars"></i>
                      </a>
                  </span>
                
                <span id="toc-menu"><a href=""><i class="fa fa-list-alt"></i></a></span>
                
                
                
                
                  
                
                  
                
                  
                
                  
                
                  
                    
                    
                <a href="https://1ambda.github.io/haskell/" itemprop="url"><span itemprop="title">Haskell</span></a> <i class="fa fa-angle-right"></i>
                    
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                <span itemprop="title"> 하스켈로 배우는 함수형 언어 4</span>
              </div>
              
                  <div class="progress">
    <div class="wrapper">
<nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#what-is-a-parser">What is a Parser</a></li>
<li><a href="#the-parser-type">The Parser Type</a></li>
<li><a href="#basic-parsers">Basic Parsers</a></li>
<li><a href="#monad">Monad</a></li>
<li><a href="#sequencing">Sequencing</a></li>
<li><a href="#do">Do</a></li>
<li><a href="#monadic-axioms">Monadic Axioms</a></li>
<li><a href="#so-why-monad">So, Why Monad?</a></li>
<li><a href="#monad-again">Monad, Again</a></li>
<li><a href="#monadplus">MonadPlus</a></li>
<li><a href="#derived-primitives">Derived Primitives</a></li>
<li><a href="#arithmetic-expressions">Arithmetic Expressions</a></li>
<li><a href="#programming-with-effects">Programming With Effects</a></li>
<li><a href="#list-monad">List Monad</a></li>
<li><a href="#state-monad">State Monad</a></li>
<li><a href="#io-monad">IO Monad</a></li>
<li><a href="#derived-primitives-1">Derived Primitives</a></li>
<li><a href="#references">References</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>
</div>

              

            </div>
            
    	        <div id="body-inner">
                
                <h1>하스켈로 배우는 함수형 언어 4</h1>
                



<p>이번시간엔 모나드를 배웁니다. <del>네. 올것이 왔습니다.</del> 간단한 파서를 구현하는 것 부터 시작해 보겠습니다.</p>

<h3 id="what-is-a-parser">What is a Parser</h3>

<p><strong>Parser (파서)</strong> 란 텍스트 조각을 분석하여 <em>syntaxtic structure</em> 를 만들어 내는 프로그램(코드)를 말합니다.</p>

<p>많은 프로그램들이 자신만의 파서를 가지고 있습니다. <em>GHC</em> 는 <em>haskell</em> , <em>UNIX</em> 는 <em>shell script</em>, <em>explorer</em> 는 <em>HTML</em> 분석합니다.</p>

<h3 id="the-parser-type">The Parser Type</h3>

<pre><code class="language-haskell">type Parser = String -&gt; Tree
</code></pre>

<p>하스켈 같은 함수형 언어에서 파서는 함수라 볼 수 있습니다. 문자열을 받아서 <em>Tree (트리)</em> 를 만들어 주는 함수처럼요.</p>

<p>때때로 입력된 문자열이 이상하다면 파서가 제대로 동작하지 않을수도 있습니다. 그럴때 분석되지 않은 문자열을 돌려주려면 이런 형태여야 합니다.</p>

<pre><code class="language-haskell">type Parser = String -&gt; (Tree, String)
</code></pre>

<p>어떤 문자열들은 여러가지로 해석될 수도 있겠지요. 그럼 리스트를 돌려줘야겠네요.</p>

<pre><code class="language-haskell">type Parser = String -&gt; [(Tree, String)]
</code></pre>

<p>꼭 파서가 트리를 만들 필요는 없지 않을까요? 문자열이 <code>1 + 2</code> 라면 이 값을 더한 <code>3</code> 을 돌려줄 수도 있을겁니다.</p>

<pre><code class="language-haskell">type Parser a = String -&gt; [(a, String)]
</code></pre>

<p>이번 강의에서는 복잡한 파서를 구현하기 보다 파서가 무슨일을 하는지에 집중할 것이므로 파서의 타입을 심플하게 가져가겠습니다. 파서가 문자열을 분석하는데 실패하면 <code>[]</code>  성공하면 <em>singleton list</em> 를 돌려주겠습니다.</p>

<h3 id="basic-parsers">Basic Parsers</h3>

<p>먼저 문자열에서 첫 번째 원소를 소비하고, 나머지를 돌려주는 간단한 <code>item</code> 파서를 만들어 봅시다. 이 파서는 빈 문자열에 대해서는 <code>[]</code> 를 돌려줍니다.</p>

<pre><code class="language-haskell">module Lecture7 where

type Parser a = String -&gt; [(a, String)]

item :: Parser Char
item = \xs -&gt; case xs of
               [] -&gt; []
               (x:xs) -&gt; [(x, xs)]
</code></pre>

<p>실행하면 이런 결과를 얻습니다.</p>

<pre><code class="language-haskell">&gt; item &quot;hello world&quot;
-- [('h',&quot;ello world&quot;)]

&gt; item &quot;&quot;
-- []
</code></pre>

<p>항상 <code>[]</code> 만 돌려주는 <code>failure</code> 파서와 <code>a -&gt; Parser a</code> 타입의 <code>return</code> 도 만들어 봅시다. 하나는 항상 실패하고, 다른 하나는 항상 성공하는 파서입니다.</p>

<pre><code class="language-haskell">failure :: Parser a
failure = \xs -&gt; []

return :: a -&gt; Parser a
return v = \xs -&gt; [(v, xs)]

&gt; failure &quot;hello world!&quot;
-- []

&gt; (return &quot;hello&quot;) &quot; world&quot;
-- [(&quot;hello&quot;,&quot; world&quot;)]

&gt; (return &quot;hello&quot;) &quot;&quot;
-- [(&quot;hello&quot;,&quot;&quot;)]
</code></pre>

<p>이제 두 개의 파서를 붙이는 함수 <code>(+++)</code> 를 만들어 봅시다. <code>p +++ q</code> 에 대해 파서 <code>p</code> 가 성공하면 <code>p</code> 의 리턴값을, <code>p</code> 가 실패하면 <code>q</code> 가 처리하게 합시다. 위에서 항상 성공하는 파서 <code>return v</code> 와 항상 실패하는 파서 <code>failure</code> 를 여기다 붙이며 어떻게 될지도 한번 생각해 보는것도 좋습니다.</p>

<pre><code class="language-haskell">(+++) :: Parser a -&gt; Parser a -&gt; Parser a
p +++ q = \xs -&gt; case p xs of
                  [] -&gt; parse q xs
                  [(y, ys)] -&gt; [(y, ys)]
                  
parse :: Parser a -&gt; String -&gt; [(a, String)]
parse p xs = p xs  
</code></pre>

<p>여기서 <code>parse</code> 는 그냥 <em>readable</em> 한 코드를 만들기 위해 사용했다고 보면 됩니다. 파서와 텍스트를 받아서 그 적용한 결과를 돌려줍니다.</p>

<pre><code class="language-haskell">&gt; parse (return '1') &quot;234&quot;
-- [('1',&quot;234&quot;)]

&gt; parse failure &quot;abcd&quot;
-- []

&gt; parse (failure +++ (return '1')) &quot;abcd&quot;
-- [('1',&quot;abcd&quot;)]

&gt; parse (item +++ return 'd') &quot;abc&quot;
-- [('a', &quot;bc&quot;)]
</code></pre>

<h3 id="monad">Monad</h3>

<p>여기서 잠깐 생각해 볼 거리가 있습니다. &ldquo;<em>parser</em> 가 대체 무슨일을 하고 있는가?&rdquo;</p>

<p>파서의 타입을 잘 보면 원본 타입 <code>String</code> 을 받아, 여기서 부가적인 작업을 해서 <code>a</code> 타입을 만들고, 다시 본래 타입인 <code>String</code> 더해 튜플로 만들어 돌려줍니다. 다시 말해 파서는 <em>한 타입을 받아 부가적인 정보를 만들어 본래 타입에 붙여주는 함수</em> 라 볼 수 있습니다.</p>

<p>파서의 연결을 도와주는 함수는 <code>(+++)</code> 무엇일까요? *부가적인 정보를 붙여주는 파서 를 <strong>합성</strong>* 해 주는 역할을 합니다.</p>

<p>지금 <code>(+++)</code> 의 규칙은 <code>p</code> 가 실패하면 <code>q</code> 를 적용하지만, 파서 <code>t, u, v</code> 를 받아 모두 적용한 뒤 결과를 돌려주는 연산자도 만들 수 있습니다.</p>

<p><code>(+++)</code> 자체는 하나의 규칙을 의미하지만 자세히 보면 이외에도 다양한 규칙을 가진 합성 함수를 만들 수 있다는 것을 알 수 있습니다.</p>

<p>부가적인 정보를 만들어 내는 함수와(파서), 이 파서간의 합성이 아주 중요한 키 포인트입니다. 그리고 이 파서가 바로 <em>monad</em> 입니다. <del>두둥</del></p>

<blockquote>
<p>The parser type is a <strong>monad</strong>, a mathematical structure that has proved useful for modeling many different kinds of computations</p>
</blockquote>

<h3 id="sequencing">Sequencing</h3>

<p>위에서는 두개의 파서를 엮어 하나로 만들긴 했지만 둘 중에 하나만 사용했죠. 둘 다 사용하진 않았습니다. 그럼 둘 이상의 파서를 엮어 하나의 파서를 만들려면 어떻게 해야할까요? 일단 생각해 볼 수 있는건 타입이 좀 다릅니다.</p>

<p>서로 다른 두개의 파서 <code>Parser a</code> 와 <code>Parser b</code> 를 고려해 봅시다.</p>

<pre><code class="language-haskell">type Parser a = String -&gt; [(a, String)]

Parser a
-- String -&gt; [(a, String)]

Parser b
-- String -&gt; [(b, String)]
</code></pre>

<p><code>Parser a</code> 의 출력은 <code>[(a, String)]</code>, 이기 때문에 다른 파서 <code>Parser b</code> 의 입력 <code>String</code> 이 될 수 없습니다.</p>

<p>그리고 여기서 한 가지 더 중요한 사실은, <code>Parser a</code> 가 <code>String</code> 을 이용해 만든 타입 <code>a</code> 의 부가정보를 <code>Parser b</code> 에 손실 없이 넘겨줘야 한다는 사실입니다. 그래야만 파서를 조합한 의미가 있지요.</p>

<p>정리하자면 <code>Parser a</code> 를 받아 <code>Parser b</code> 를 돌려주는 <em>파서 조합함수</em> 를 만들 것인데,  부가정보 <code>a</code> 의 보존을 위해 이 함수 내부에서 <code>a -&gt; Parser b</code> 타입의 중간 함수가 필요합니다. <strong>이 중간 함수가 어디에서 어떤 일을 할지가 구현해야 할 부분이자, 가장 중요한 부분</strong>입니다. 파서 종류에 따라 원본 데이터 (여기서는 <code>String</code>) 을 조작하는 방법이 다르기 때문입니다. 거꾸로 말하면 <em>다양한 종류의 파서가 있다는 말</em> 입니다.</p>

<p>함수의 이름은 <code>&gt;&gt;=</code> 라 짓겠습니다. <em>bind</em> 라 읽습니다. 타입은</p>

<pre><code class="language-haskell">type Parser a = String -&gt; [(a, String)]

parse :: Parser a -&gt; String -&gt; [(a, String)]
parse p xs = p xs

(&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
</code></pre>

<p>구현은</p>

<pre><code class="language-haskell">p &gt;&gt;= q = \xs -&gt; case p xs of
                  [] -&gt; []
                  (y, ys) -&gt; parse (q y) ys
</code></pre>

<p>즉 <code>&gt;&gt;=</code> 는 <code>Parser a</code> 의 처리 결과가 <code>[]</code> 이면 <code>[]</code> 을 돌려줍니다. 올바르게 처리되었을 경우에는 <code>Parser a</code> 의 결과로 얻어진 부가정보 <code>a</code> 타입에 대해 <code>a -&gt; Parser b</code> 타입의 함수인 <code>y</code> 에게 넘겨 <code>Parser b</code> 를 받고 결과적으로는 <code>\xs -&gt; parse k ys</code> 를 돌려줍니다. (<code>k :: parser b</code>) 그런데, 여기서 <code>parse k ys</code> 의 결과가 <code>[(b, String)]</code> 이기 때문에 <code>\xs -&gt; parse k ys</code> 는 <code>Parser b</code> 라 볼 수 있습니다.</p>

<p>최종적으로는 <code>Parser a</code> 를 이용해 <code>Parser b</code> 를 만들어 냈습니다.</p>

<p>예제를 한번 보시죠. <code>Parser Char</code> 을 이용해 <code>Parser (Char, Char)</code> 을 만들어 볼 수 있습니다.</p>

<pre><code class="language-haskell">return :: a -&gt; Parser a
return v = \xs -&gt; [(v, xs)]

(&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
p &gt;&gt;= q = \xs -&gt; case p xs of
                   [] -&gt; []
                   (y, ys) -&gt; parse (q, y) ys
      
-- consume only one Char
parseTwice :: Parser (Char, Char)
parseTwice = item &gt;&gt;= \x -&gt; return (x, x)
</code></pre>

<pre><code class="language-haskell">parseTwice &quot;5BEAF&quot;
-- [((5, 5), &quot;BEAF&quot;)] 
</code></pre>

<p><code>item</code> 과 <code>return (x, x)</code> 두개의 파서를 조합해서 <code>parseTwice</code> 라는 새로운 파서를 만들었습니다. 조금 더 붙여볼까요?</p>

<pre><code class="language-haskell">ignore2 :: Parser (Char, Char)
ignore2 = item &gt;&gt;= \x -&gt; item &gt;&gt;= \y -&gt; item &gt;&gt;= \z -&gt; return (x, z)

&gt; ignore2 &quot;2A371&quot;
-- [(('2','3'),&quot;71&quot;)]
</code></pre>

<h3 id="do">Do</h3>

<p>위에서 보았듯이 같은 원본 타입 <code>String</code> 을 가지는 같은 종류의 파서(모나드)는 계속 연결할 수 있습니다. <code>p1, ..., pn</code> 을 파서라 하고 <code>v1, ..., vn</code> 을 파서가 만드는 부가정보라 할 때 다음과 같이 일반화 할 수 있습니다.</p>

<pre><code class="language-haskell">p1 &gt;&gt;= \v1 -&gt;
p2 &gt;&gt;= \v2 -&gt;
p3 &gt;&gt;= \v3 -&gt;
...
pn &gt;&gt;= \vn -&gt;
return (f v1 v2 ... vn)
</code></pre>

<p>하스켈에선 조금 더 편한 문법을 지원하는데요 바로 <code>do</code> 구문입니다.</p>

<pre><code class="language-haskell">do v1 &lt;- p1
   v2 &lt;- p2
   ...
   vn &lt;- pn
   return (f v1 v2 ... vn)
</code></pre>

<h3 id="monadic-axioms">Monadic Axioms</h3>

<p>이 때 <code>do</code> 구문을 활용하는 파서(모나드) <code>pn</code> 에 대해서는 미리 <code>&gt;&gt;=</code> 과 <code>return</code> 이 구현되어 있어야 합니다. 우리도 위에서 두 가지 함수를 사용했습니다.</p>

<p>하스켈에서는 모나드 클래스가 따로 있습니다. 그리고 모든 모나드 클래스의 인스턴스는 최소한 <code>&gt;&gt;=</code> 와 <code>return</code> 을 구현해야 합니다. 우리가 위에서 구현했던 파서를 잠깐 보면</p>

<pre><code class="language-haskell">type Parser a = String -&gt; [(a, String)]

return :: a -&gt; Parser a
return v = \xs -&gt; [(v, xs)]

(&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
p &gt;&gt;= q = \xs -&gt; case parse p xs of
                  [] -&gt; []
                  [(y, ys)] -&gt; parse (q y) ys
</code></pre>

<p><code>return</code> 은 <code>a</code> 를 받아 파서를 돌려줍니다. <code>&gt;&gt;=</code> 는 파서(모나드)를 결합하지요.</p>

<p>아까 다양한 파서(모나드)가 있을 수 있다고 말했던 것 기억 나시죠? 많은 종류의 모나드에 대해  최소한 <code>return</code> 과 <code>&gt;&gt;=</code> 를 구현해야 하는데, 이때 지켜져야 할 <em>axioms (공리)</em> 가 있습니다.</p>

<p>(1) <code>m &gt;&gt;= return</code> == <code>m</code> (<em>right unit</em>)<br />
(2) <code>return x &gt;&gt;= f</code> == <code>f x</code> (<em>left unit</em>)<br />
(3) <code>(m &gt;&gt;= f) &gt;&gt;= g</code> == <code>m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code> (<em>associativity</em>)</p>

<h3 id="so-why-monad">So, Why Monad?</h3>

<p>근데, 이런 복잡한 모나드가 왜 중요한걸까요? 바로 <em>부가정보</em> 를 만들면서 본래의 타입을 유지하기 때문입니다.</p>

<p>본래 순수 함수형 프로그래밍에선 콘솔 출력 같은 <em>side-effect</em> 를 만들 수 없습니다. 그러나 모나드를 이용하면 <strong>부가정보 (= <em>side-effect</em>)</strong> 와 <strong>연산 부분 (<em>purely functional</em>)</strong> 를 분리할 수 있습니다.</p>

<p>실제 하스켈에서도 <em>IO Monad</em> 를 통해 입출력을 할 수 있죠.</p>

<h3 id="monad-again">Monad, Again</h3>

<p>그러면 실제로 하스켈에서 제공하는 모나드를 클래스를 사용해 봅시다. 코드를 조금 변경해야합니다.</p>

<pre><code class="language-haskell">module Lecture7 where

import Control.Monad

-- ref: http://www.cs.nott.ac.uk/~gmh/Parsing.lhs
newtype Parser a = P (String -&gt; [(a, String)])

instance Monad Parser where
  return v = P $ \inp -&gt; [(v, inp)]
  p &gt;&gt;= f = P $ \inp -&gt; case parse p inp of
                         [] -&gt; []
                         [(v, out)] -&gt; parse (f v) out

item :: Parser Char
item = P $ \inp -&gt; case inp of
                    [] -&gt; []
                    (x:xs) -&gt; [(x, xs)]

parse                         :: Parser a -&gt; String -&gt; [(a,String)]
parse (P p) inp               =  p inp

ignore2 :: Parser (Char, Char)
ignore2 = do x &lt;- item
             item
             z &lt;- item
             return (x, z)
</code></pre>

<p>실제 돌려보면,</p>

<pre><code class="language-haskell">&gt; parse ignore2 &quot;7A3BCEF&quot;
-- [(('7','3'),&quot;BCEF&quot;)]
</code></pre>

<h3 id="monadplus">MonadPlus</h3>

<p>아까 작성했었던 파서 <code>failure</code>, <code>(+++)</code> 기억 나시나요? <code>failure</code> 는 항상 실패하는 파서를, <code>(+++)</code> 는 첫번째 파서와 두번째 파서를 붙여 둘 중 성공하는 하나의 파서만 선택하는 합성 파서입니다.</p>

<p>하스켈에선 이런 두 가지 특징을 구현한 모나드를 <code>MonadPlus</code> 라 부릅니다. 다시 말해 <code>MonadPlus</code> 에는 기본적인 <code>return</code> 이나 <code>&gt;&gt;=</code> 이외에도 위 두 가지가 더 구현되어 있다는 말이죠.</p>

<p><code>MonadPlus</code> 에서는 <code>failure</code> 대신 <code>mzero</code> 를 <code>(+++)</code> 대신 <code>mplus</code> 란 이름을 사용합니다.</p>

<pre><code class="language-haskell">instance MonadPlus Parser where
  mzero = P $ \_ -&gt; []
  p `mplus` q = P $ \inp -&gt; case parse p inp of
                             [] -&gt; parse q inp
                             [(v, out)] -&gt; [(v, out)]

failure :: Parser Char 
failure = mzero

(+++) :: Parser a -&gt; Parser a -&gt; Parser a
p +++ q = p `mplus` q
</code></pre>

<pre><code class="language-haskell">&gt; parse (item +++ return 'd') &quot;abc&quot;
-- [('a',&quot;bc&quot;)]

&gt; parse (item +++ return 'd') &quot;&quot;
-- [('d',&quot;&quot;)]
</code></pre>

<h3 id="derived-primitives">Derived Primitives</h3>

<p>이제 파서를 엮어서 다양한 파서를 만들어 봅시다.</p>

<pre><code class="language-haskell">import Data.Char

sat :: (Char -&gt; Bool) -&gt; Parser Char
sat p = do x &lt;- item
           if p x then return x else failure

digit :: Parser Char
digit = sat isDigit

lower :: Parser Char
lower = sat isLower

upper :: Parser Char
upper = sat isUpper 

letter :: Parser Char
letter = sat isAlpha

alphanum :: Parser Char
alphanum = sat isAlphaNum

char :: Char -&gt; Parser Char
char x = sat (== x)
</code></pre>

<p>여기서 <code>char</code> 을 이용하면 지정된 문자열이 있는지 검사하는 파서 <code>string</code> 을 만들 수 있습니다.</p>

<pre><code class="language-haskell">string :: String -&gt; Parser String
string [] = return []
string (x:xs) = do char x
                   string xs
                   return (x:xs)
</code></pre>

<p><code>string</code> 은 재귀를 이용해 작성했는데, 입력된 문자열이 모두 존재할 경우에만 <code>return</code> 하고 아니면 <code>[]</code> 를 돌려줍니다. (<code>do</code> 매크로는 중간에 <code>[]</code> 가 나오면 <code>[]</code> 를 바로 리턴합니다.)</p>

<pre><code class="language-haskell">&gt; parse (string &quot;google&quot;) &quot;naver google yahoo&quot;
-- []

&gt; parse (string &quot;google&quot;) &quot;google yahoo&quot;
-- [(&quot;google&quot;,&quot; yahoo&quot;)]

&gt; parse (string &quot;google&quot;) &quot;goo yahoo&quot;
-- []
</code></pre>

<p>그러면, <code>digit</code> 나 <code>letter</code> 같은 파서에 대해 동일한 파서를 여러번 사용하려면 어떻게 해야 할까요? <code>string</code> 처럼 재귀를 이용해 매번 파서를 만들어야 할까요?</p>

<p>그렇지 않습니다. <em>mutual recursion</em> 을 이용해서 파서를 받아 여러번 적용해 주는 <code>many</code> 란 파서를 만들어 봅시다.</p>

<pre><code class="language-haskell">many :: Parser a -&gt; Parser [a]
many p = many1 +++ return []

many1 :: parser a -&gt; Parser [a]
many1 p = do x &lt;- p
		     xs &lt;- many p
             return (x:xs)
</code></pre>

<p><code>many</code> 는 <code>p</code> 을 0번 이상, <code>many1</code> 은 적어도 1번 이상 <code>p</code> 를 적용합니다.</p>

<p><code>many</code> 를 활용하면 변수의 이름도 파싱할 수 있습니다. 변수의 이름은 첫 글자가 소문자로, 나머지는 알파벳 혹은 숫자로 구성되어 있다고 하면 이를 위한 파서 <code>ident</code> 는</p>

<pre><code class="language-haskell">ident :: Parser String
ident = do x &lt;- lower
           xs &lt;- many alphanum
           return (x:xs)

&gt; parse ident &quot;left = 3&quot;
-- [(&quot;left&quot;,&quot; = 3&quot;)]
</code></pre>

<p>이제 뭔가 파서가 좀 쓸만해 보이죠? 자연수를 파싱하는 <code>nat</code> 와 스페이스를 파싱하는 <code>space</code> 를 만들어 보겠습니다.</p>

<pre><code class="language-haskell">nat :: Parser Int
nat = do xs &lt;- many1 digit
         return (read xs)
      
space :: Parser ()
space = do many (sat isSpace)
           return ()
        
&gt; parse nat &quot;123 abc&quot;
-- [(123,&quot; abc&quot;)]

&gt; parse space &quot;   abc&quot;
-- [((),&quot;abc&quot;)]        
</code></pre>

<p>코드를 분석하는 파서를 만들때 스페이스를 주의해야 합니다. 예를 들어 <code>1+2</code> 와 <code>1 + 2</code> 는 같은 코드입니다.</p>

<p>파서를 받아 앞 뒤로 붙은 스페이스를 제거하는 기능을 덧붙인 파서를 돌려주는 <code>token</code> 이란 함수를 만들어 봅시다. 그리고 나면 <code>token</code> 을 활용해 <code>identifier</code>, <code>natural</code>, <code>symbol</code> 을 만들겁니다.</p>

<pre><code class="language-haskell">token :: Parser a -&gt; Parser a
token p = do space
             v &lt;- p
             space
             return v
             
identifier :: Parser String
identifier = token ident

natural :: Parser Int
natural = token nat

symbol :: String -&gt; Parser String
symbol xs = token (string xs)
</code></pre>

<p>이제 이걸 엮어서 숫자 리스트를 분석하는 파서를 만들어 봅시다.</p>

<pre><code class="language-haskell">nlist :: Parser [Int]
nlist = do symbol &quot;[&quot;
           n &lt;- natural
           ns &lt;- many (do symbol &quot;,&quot;
                          natural)
           symbol &quot;]&quot;
           return (n:ns)


&gt; parse nlist &quot;[1, 2, 3]&quot;
-- [([1,2,3],&quot;&quot;)]

&gt; parse nlist &quot;[1, 2]&quot;
-- [([1,2],&quot;&quot;)]

&gt; parse nlist &quot;[1, 2&quot;
-- []

&gt; parse nlist &quot;[1 2&quot;
-- []

&gt; parse nlist &quot;[1,&quot;
-- []
</code></pre>

<p><del>모나드의 세계란 참으로 놀랍죠?</del></p>

<h3 id="arithmetic-expressions">Arithmetic Expressions</h3>

<p>이제 단순한 텍스트가 아니라, 코드를 분석해 보죠. 우선 작은 수식을 분석하는 파서를 작성해 봅시다. 우리가 작성할 파서는 정수에 대한 <code>*</code> 과 <code>+</code> 만 처리할 수 있습니다. 간단히 문법을 만들어 보면</p>

<pre><code class="language-haskell">expr   ::= expr + expr | term
term   ::= term * term | factor
factor ::= (expr) | nat
nat    ::= 0 | 1 | 2 | ...
</code></pre>

<p>처음보면 난해할 수 있습니다. 이 그림과 비교해가며 보세요. 완벽히 일치하진 않지만 대략적인 설명을 해줍니다.</p>

<p><img src="http://www.csee.umbc.edu/courses/331/fall11/hw/hw2/parsetree.gif" alt="" />
<p align="center">(<a href="http://www.csee.umbc.edu">http://www.csee.umbc.edu</a>)</p></p>

<p>그런데, 실제로 <code>2 + 3 + 4</code> 에 적용해보면, <code>(2 + 3) + 4</code> 과 <code>2 + (3 + 4)</code> 두 가지 방법으로 해석될 수 있습니다. 따라서 모호함을 제거하기 위해</p>

<pre><code class="language-haskell">expr   ::= term + expr | term
term   ::= factor * term | factor
factor ::= (expr) | nat
nat    ::= 0 | 1 | 2 | ...
</code></pre>

<p>이제 <code>2 + 3 + 4</code> 는 확실히 <code>2 + (3 + 4)</code> 입니다. 괴상한 문법을 하스켈로 옮기기 위해 조금  더 다듬어 보도록 하지요.</p>

<p><code>term + expr | term</code> 은 사실 <code>term + (expr | e)</code> 과 동일합니다. (<code>e</code> 는 <strong>비었음</strong> 을 의미) <code>factor * term | factor</code> 도 <code>factor + (term | e)</code> 구요. 따라서</p>

<pre><code class="language-haskell">expr   ::= term + (expr | e)
term   ::= factor + (term | e)
factor ::= (expr) | nat
nat    ::= 0 | 1 | 2 | ...
</code></pre>

<p>이제 하스켈 코드로 옮길겁니다. 우리는 트리를 만드는 대신 바로바로 계산할 겁니다.</p>

<pre><code class="language-haskell">expr :: Parser Int
expr = do t &lt;- term
          do symbol &quot;+&quot;
             e &lt;- expr
             return (t + e)
           +++ return t

term :: Parser Int
term = do f &lt;- factor
          do symbol &quot;*&quot;
             t &lt;- term
             return (t * f)
           +++ return f

factor :: Parser Int
factor = do symbol &quot;(&quot;
            e &lt;- expr
            symbol &quot;)&quot;
            return e
          +++ natural          
</code></pre>

<p><code>return t</code> 도 하나의 파서고, <code>+++</code> 로 둘 중 올바르게 작동하는 파서만 택함으로써 문법에서의 <code>|</code> 를 구현했습니다.</p>

<p>이제 파싱된 결과를 해석하는 <code>eval</code> 함수를 만들어 봅시다.</p>

<pre><code class="language-haskell">eval :: String -&gt; Int
eval xs = case parse expr xs of
           [(n, [])] -&gt; n
           [(_, out)] -&gt; error (&quot;ununsed input: &quot; ++ out)
           [] -&gt; error (&quot;invalid input: &quot; ++ xs)


&gt; eval &quot;2 * 3 + 4&quot;
-- 10

&gt; eval &quot;2 * (3 + 4)&quot;
-- 14

&gt; eval &quot;2 * 3 +&quot;
-- *** Exception: ununsed input: +

&gt; eval &quot;2 * 3 - 4&quot;
-- *** Exception: ununsed input: - 4

&gt; eval &quot;-4&quot;
-- *** Exception: invalid input: -4
</code></pre>

<h3 id="programming-with-effects">Programming With Effects</h3>

<p><a href="http://www.cs.nott.ac.uk/~gmh/monads">Programming With Effects</a> 는 <em>Programming in Haskell</em> 의 저자인 <strong>Graham Hutton</strong> 이 작성한 글입니다. 모나드에 대해 이보다 쉽고, 간결하게 설명한 글은 찾기 힘들죠.</p>

<p><em>Programming with Effects</em> 를 참고하여 몇 가지 예제를 더 작성해 보면서 모나드에 더 익숙해져 봅시다.</p>

<pre><code class="language-haskell">data Expr = Val Int | Div Expr Expr
</code></pre>

<p>위와 같은 <code>Expr</code> 이 있다고 합시다. 평가하기 위해서 <code>eval</code> 함수를 만들고 실행해 봅시다.</p>

<pre><code class="language-haskell">eval :: Expr -&gt; Int
eval (Val n) = n
eval (Div x y) = eval x `div` eval y

&gt; eval (Val 3)
-- 3

&gt; eval (Div (Val 3) (Val 4))
-- 0

&gt; eval (Div (Val 8) (Val 4))
-- 2

&gt; eval (Div (Val 8) (Val 0))
-- *** Exception: divide by zero
</code></pre>

<p><code>0</code> 으로 나누니 에러가 발생합니다. <code>expr</code> 이 <code>Val 0</code> 인지 아닌지를 판별할 필요가 있습니다.</p>

<p>조금 더 고쳐보면</p>

<pre><code class="language-haskell">import Prelude hiding (Maybe, Just, Nothing)

data Expr = Val Int | Div Expr Expr
data Maybe a = Nothing | Just a

safediv :: Int -&gt; Int -&gt; Maybe Int
safediv n m = if m == 0 then Nothing else Just (n `div` m)

eval :: Expr -&gt; Maybe Int
eval (Val n) = Just n
eval (Div x y) = case eval x of
                  Nothing -&gt; Nothing
                  Just n -&gt; case eval y of
                             Nothing -&gt; Nothing
                             Just m -&gt; safediv n m
</code></pre>

<p>너무 복잡합니다. <code>eval</code> 에서 <code>safediv</code> 에 인자를 넘기는 부분을 추상화하면</p>

<pre><code class="language-haskell">seqn :: Maybe a -&gt; Maybe b -&gt; Maybe (a, b)
seqn _ Nothing = Nothing
seqn Nothing _ = Nothing
seqn (Just x) (Just y) = Just (x, y)

apply :: (a -&gt; Maybe b) -&gt; Maybe a -&gt; Maybe b
apply f Nothing = Nothing
apply f (Just x) = f x

eval :: Expr -&gt; Maybe Int
eval (Val n) = Just n
eval (Div x y) = apply f (eval x `seqn` eval y)
                 where f (n, m) = safediv n m
</code></pre>

<p>조금 더 간편해졌습니다. 그런데 만약 인자가 3개인 연산자에 대해 평가 방법을 정의한다면</p>

<pre><code class="language-haskell">eval (Op x y z) = 
  apply f (eval x `seqn` (eval y `seqn` eval z))
  where f (a, (b, c)) =                 
</code></pre>

<p>괄호가 점점 중첩됩니다. 모든 것을 나중에 <code>seqn</code> 로 모든 결과를 모아 <code>f</code> 에서 처리하기 보다는 <code>Maybe a</code> 를 받아 <code>a -&gt; Maybe b</code> 를 바로 적용해 <code>Maybe b</code> 를 돌려주고, 이런식으로 순차적으로 처리하는 방식으로 바꿔봅시다.</p>

<pre><code class="language-haskell">(&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
m &gt;&gt;= f = case m of
           Nothing -&gt; Nothing
           Just x -&gt; f x

eval :: Expr -&gt; Maybe Int
eval (Val x) = Just x
eval (Div x y) = eval x &gt;&gt;= \n -&gt; 
                 eval y &gt;&gt;= \m -&gt; 
                 safediv n m 
</code></pre>

<p>어디서 많이 보다싶은 식이죠? 바로 하스켈의 <code>do</code> 와 비슷합니다.</p>

<p>하스켈에서 <code>Eq</code> 의 클래스의 정의는 이렇게 되어있습니다.</p>

<pre><code class="language-haskell">class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  
  x /= y = not (x == y)
</code></pre>

<p>이 말은 <code>Eq</code> 클래스의 인스턴스가 되는 <code>a</code> 타입은 무조건 <code>==</code> 를 구현해야 한다는 뜻입니다. (<code>/=</code> 는 이미 구현되어 있는거 보이시죠?)</p>

<p>마찬가지로 타입 <code>m</code> 으로 <em>parameterized</em> 된 <code>Monad</code> 클래스의 인스턴스 또한 다음의 두 함수를 구현해야 합니다.</p>

<pre><code class="language-haskell">class Monad m where
  return :: a -&gt; m a
  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>

<p>예를 들어 <code>Maybe</code> 같은 경우</p>

<pre><code class="language-haskell">instance Monad Maybe where
  return x = Just x
  
  Nothing &gt;&gt;= _ = Nothing
  (Just x) &gt;&gt;= f = f x
</code></pre>

<h3 id="list-monad">List Monad</h3>

<p><code>Maybe</code> 모나드를 잘 보면 <code>Nothing</code> 은 실패를, <code>Just x</code> 는 성공을 나타내는 연산으로 볼 수 있습니다.</p>

<p>리스트 모나드는 이런 개념을 좀 더 일반화한 것입니다. 복수번의 성공이 있을 수 있죠.</p>

<pre><code class="language-haskell">instance Monad [] where
  return x = [x]
  xs &gt;&gt;= f = concat (map f xs)
</code></pre>

<p>이를 이용하면 <code>pairs</code> 와 같은 함수를 만들수 있습니다.</p>

<pre><code class="language-haskell">pairs :: [a] -&gt; [b] -&gt; [(a, b])
pairs xs ys = do x &lt;- xs
                 y &lt;- ys
                 return (x, y)
                 
&gt; pairs [1, 2, 3] [4, 5, 6]
-- [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]                 
</code></pre>

<p><em>list comprehension</em> 구문과 비슷합니다. 실제로 <code>do</code> 와 <em>list comprehension</em> 모두 리스트의 <code>&gt;&gt;=</code> 를 이용합니다.</p>

<h3 id="state-monad">State Monad</h3>

<p>한 상태(State) 에서 다른 상태로 변환시켜주는 <em>state transformer</em> 의 타입은 이렇게 정의할 수 있을 겁니다.</p>

<pre><code class="language-haskell">type ST = State -&gt; State
</code></pre>

<p>그리고 상태가 변하면서 어떤 정보를 남겼을때의 타입을 이렇게 만들어 볼 수 있겠죠.</p>

<pre><code class="language-haskell">type ST a = State -&gt; (a, State)
</code></pre>

<p>어디서 많이 본것 같죠? 맞습니다. 위에서 본 <code>Parser</code> 입니다. <code>String -&gt; (a, String)</code> 이였으니까, <code>State</code> 가 <code>String</code> 이었던 거죠.</p>

<pre><code class="language-haskell">instance Monad ST where
  return x = \s -&gt; (x, s)
  
  st &gt;&gt;= f = \s -&gt; let (x, s') = st s
                   in f x s'
</code></pre>

<p>누차 언급했듯이 <code>&gt;&gt;=</code> 는 모나드(연산)간 연결입니다. <code>st</code> 에 <code>s</code> 를 넣은 결과를 <code>(x, s')</code> 라 하면 다시 <code>f x</code> 에 <code>s</code> 를 넣어 연결할 수 있다는 뜻이지요.</p>

<p>위에서는 <code>type</code> 을 사용했지만 실제로 이 키워드를 사용하면 클래스의 인스턴스가 될 수 없습니다. <code>ST</code> 를 <em>monadic type</em> 클래스의 인스턴스로 만들려면 <code>data</code> 나 <code>newtype</code> 을 이용할 수 있습니다. <code>data</code> 의 경우엔 <em>dummy constructor</em> 가 필요합니다. 여기선 <code>S</code> 가 되겠습니다. <em>dummy constructor</em> 의 런타임 오버헤드를 피하려면 <em>newtype</em> 을 이용하면 됩니다.</p>

<p>그리고 이 예제에서는 <em>dummy constructor</em> 를 제거하기 위해 <code>apply</code> 함수를 만들어서 이용하겠습니다.</p>

<p><code>State</code> 는 정수로 표시할겁니다.</p>

<pre><code class="language-haskell">type State = Int
data ST a = S (State -&gt; (a, State))

apply :: ST a -&gt; State -&gt; (a, State)
apply (S f) x = f x

instance Monad ST where
  return x = S (\s -&gt; (x, s))
  st &gt;&gt;= f = S (\s -&gt; let (x, s') = apply st s in apply (f x) s')
</code></pre>

<p>이제 예제에서 활용할 간단한 이진트리를 정의해 봅시다. 이진트리의 <em>leaf</em> 는 <code>a</code> 타입의 값을 가지고 있습니다.</p>

<pre><code class="language-haskell">data Tree = Leaf a | Node (Tree a) (Tree b)

-- example
tree :: Tree Char
tree = Node (Node (Leaf 'a') (Leaf 'b')) (Leaf 'c')
</code></pre>

<p>이제 <em>State</em> 를 받아 <code>+1</code> 을 더한 다음 <em>State</em> 를 돌려주는 <code>fresh</code> 를 만들어 봅시다.</p>

<pre><code class="language-haskell">-- data ST a = S (State -&gt; (a, State))

fresh :: ST Int
fresh = S (\n -&gt; (n, n + 1))
</code></pre>

<p>즉 <code>fresh</code> 는 <em>State</em> 를 <code>1</code> 만큼 증가시키고 부가정보로 <em>current state</em> <code>n</code> 을 남깁니다. <code>fresh</code> 를 이용하면 위에서 만든 이진트리를 순회하면서 번호를 붙일 수 있습니다. 부가정보로 남는 <code>n</code> 을 <code>Leaf</code> 에다가 붙이는 것이죠.</p>

<p>다음 <code>fresh</code> 의 입력은 이전 <code>fresh</code> 의 아웃풋인 <code>n + 1</code> 이기 때문에 서로 다른 두 노드가 같은 숫자를 가질 일은 없습니다.</p>

<pre><code class="language-haskell">mlabel :: Tree a -&gt; ST (Tree (a, Int))
mlabel (Leaf x) = do n &lt;- fresh
                     return (Leaf (x, n))
mlabel (Node l r) = do l' &lt;- mlabel l
                       r' &lt;- mlabel r
                       return (Node l' r')
                       
label  :: Tree a -&gt; Tree (a,Int)
label t = fst (apply (mlabel t) 0)

&gt; label tree
-- Node (Node (Leaf ('a',0)) (Leaf ('b',1))) (Leaf ('c',2))
</code></pre>

<h3 id="io-monad">IO Monad</h3>

<p>하스켈에서 입출력은 IO 모나드를 이용합니다. 무슨말인고 하니, 다음과 같은 <em>axioms</em> 를 구현한 <strong>IO 모나드</strong> 에 대해</p>

<pre><code class="language-haskell">return  :: a -&gt; IO a
(&gt;&gt;=)   :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
getChar :: IO Char
putChar :: Char -&gt; IO ()
</code></pre>

<p>다음처럼 <code>do</code> 구문을 이용해서 프로그램을 작성할 수 있다는 뜻입니다.</p>

<pre><code class="language-haskell">getLine :: IO String
getLine = do x &lt;- getChar
             if x == '\n' then
               return []
             else
               do xs &lt;- getLine
                  return (x:xs)
</code></pre>

<p>IO 모나드는 <em>State 모나드</em> 라 볼 수 있습니다. <code>IO a</code> 는 타입 <code>a</code> 의 부가정보를 만들면서 <em>State</em> 를 변화시키는 것으로요</p>

<pre><code class="language-haskell">type World = ...
type IO a = World -&gt; (a, World)
</code></pre>

<p>여기서 입/출력이 수행되는 것은 <em>action</em> 에 의해 <code>World</code> 가 변경되는 것이라 볼 수 있습니다.</p>

<h3 id="derived-primitives-1">Derived Primitives</h3>

<p>다양한 종류의 모나드에 대해 적용할 수 있는 함수를 만들 수 있습니다.</p>

<p><code>liftM</code> 는 모나드에 대한 <code>map</code> 을 <code>join</code> 은 <code>concat</code> 을, <code>&gt;&gt;</code> 는 첫 번째 결과값을 다 버리고 두번째만 취하는 함수입니다. 마지막으로 <code>sequence</code> 는 모나드 익스프레션 리스트를  하나의 모나드 익스프레션으로 바꾸고, 그 결과를 리스트로 돌려줍니다. 타입을 보시면 이해가 빠를겁니다.</p>

<pre><code class="language-haskell">liftM :: Monad m =&gt; (a -&gt; b) -&gt; m a -&gt; m b
liftM f mx = do x &lt;- mx
             return (f x)
             
join :: Monad m =&gt; m (m a) -&gt; m a
join mmx = do mx &lt;- mmx
              x &lt;- mx
              return x
           
(&gt;&gt;) :: Monad m =&gt; m a -&gt; m b -&gt; m b
mx &gt;&gt; my = do _ &lt;- mx
              y &lt;- my
              return y
              
sequence :: Monad m =&gt; [m a] -&gt; m [a]
sequence (mx:mxs) = do x &lt;- mx
                       xs &lt;- sequence mxs
                       return (x:xs)
</code></pre>

<h3 id="references">References</h3>

<p>(1) <strong>DelftX FP 101x</strong><br />
(2) <a href="http://stackoverflow.com/questions/2607498/programming-in-haskell-error-in-sat-function">error in sat function in &ldquo;Programming in Haskell&rdquo;</a><br />
(3) <a href="http://wiki.reeseo.net/Haskell/%EA%B3%B5%EC%8B%9D%20%EC%9E%85%EB%AC%B8%EC%84%9C%20%EB%B2%88%EC%97%AD%EB%AC%B8/9.%20%EB%AA%A8%EB%82%98%EB%93%9C%20(Monads)">http://wiki.reeseo.net/Haskell</a><br />
(4) <a href="http://en.wikibooks.org/wiki/Haskell/Understanding_monads">Understanding Monads</a><br />
(5) <a href="http://www.csee.umbc.edu/courses/331/fall11/hw/hw2/">http://www.csee.umbc.edu</a><br />
(6) <a href="http://www.cs.nott.ac.uk/~gmh/monads">Programming With Effects</a> by <em>Graham Hutton</em></p>

<br/>
<br/>
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = '1ambda';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


      
      </div>
    </div>

    <div id="navigation">
        <a class="nav nav-prev" href="../intro-to-haskell-3"> <i class="fa fa-chevron-left"></i></a>
        <a class="nav nav-next" href="../intro-to-haskell-5" style="margin-right: 0px;"><i class="fa fa-chevron-right"></i></a>
    </div>

    </section>
    <div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
      <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
    </div>
    <script src="https://1ambda.github.io/js/clipboard.min.js"></script>
    <script src="https://1ambda.github.io/js/perfect-scrollbar.min.js"></script>
    <script src="https://1ambda.github.io/js/perfect-scrollbar.jquery.min.js"></script>
    <script src="https://1ambda.github.io/js/jquery.sticky-kit.min.js"></script>
    <script src="https://1ambda.github.io/js/featherlight.min.js"></script>
    <script src="https://1ambda.github.io/js/html5shiv-printshiv.min.js"></script>
    <script src="https://1ambda.github.io/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="https://1ambda.github.io/js/modernizr.custom.71422.js"></script>
    <script src="https://1ambda.github.io/js/learn.js"></script>
    <script src="https://1ambda.github.io/js/hugo-learn.js"></script>
    
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-52181619-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>


  </body>
</html>


