<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haskells on Old Lisper</title>
    <link>https://1ambda.github.io/haskell/index.xml</link>
    <description>Recent content in Haskells on Old Lisper</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Sat, 25 Jun 2016 01:21:27 +0900</lastBuildDate>
    <atom:link href="https://1ambda.github.io/haskell/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Haskell</title>
      <link>https://1ambda.github.io/haskell/</link>
      <pubDate>Sat, 25 Jun 2016 01:21:27 +0900</pubDate>
      
      <guid>https://1ambda.github.io/haskell/</guid>
      <description>

&lt;h1 id=&#34;introduction-to-functional-programming-using-haskell&#34;&gt;Introduction to Functional Programming using Haskell&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;intro-to-haskell-1&#34;&gt;Chapter 1&lt;/a&gt; - Basics&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;intro-to-haskell-2&#34;&gt;Chapter 2&lt;/a&gt; - List Comprehension&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;intro-to-haskell-3&#34;&gt;Chapter 3&lt;/a&gt; - Recursion, Higher Order Function&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;intro-to-haskell-4&#34;&gt;Chapter 4&lt;/a&gt; - Monad&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;intro-to-haskell-5&#34;&gt;Chapter 5&lt;/a&gt; - IO Monad&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;intro-to-haskell-6&#34;&gt;Chapter 6&lt;/a&gt; - Type and Class&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;intro-to-haskell-7&#34;&gt;Chapter 7&lt;/a&gt; - The Countdown Problem&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;intro-to-haskell-8&#34;&gt;Chapter 8&lt;/a&gt; - Lazy Evaluation, Strict&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;intro-to-haskell-9&#34;&gt;Chapter 9&lt;/a&gt; - Induction&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;poor-mans-concurrency-monad&#34;&gt;Poor Man&amp;rsquo;s Concurrency Monad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>하스켈로 배우는 함수형 언어 1</title>
      <link>https://1ambda.github.io/haskell/intro-to-haskell-1/</link>
      <pubDate>Sat, 25 Jun 2016 01:21:41 +0900</pubDate>
      
      <guid>https://1ambda.github.io/haskell/intro-to-haskell-1/</guid>
      <description>

&lt;p&gt;먼저 이 글은 &lt;strong&gt;edx&lt;/strong&gt; 의 &lt;em&gt;FP101.x (Introduction to Functional Programming)&lt;/em&gt; 수업을 기반으로 작성되었음을 알려드립니다.&lt;/p&gt;

&lt;p&gt;시작에 앞서서, 하스켈을 설치하려면 &lt;a href=&#34;http://www.haskell.org/platform/linux.html&#34;&gt;Haskell Platform&lt;/a&gt; 을 설치하신 후 터미널에서 &lt;code&gt;ghci&lt;/code&gt; 를 입력하면 됩니다. 하스켈 플랫폼은 하스켈 구현체로 &lt;a href=&#34;http://www.haskell.org/ghc/&#34;&gt;Glasgow Haskell Compiler, &lt;em&gt;GHC&lt;/em&gt;&lt;/a&gt; 를 포함하고 있습니다. &lt;code&gt;ghci&lt;/code&gt; 를 입력하면 하스켈 인터프리터를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;깔기 귀찮으시다면 &lt;a href=&#34;https://www.fpcomplete.com/&#34;&gt;https://www.fpcomplete.com/&lt;/a&gt; 여기서 웹으로 코드를 작성하고 컴파일 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;basics&#34;&gt;Basics&lt;/h3&gt;

&lt;p&gt;먼저 &lt;code&gt;sum [1..10]&lt;/code&gt; 을 인터프리터에 입력하면 1부터 10 까지의 합, &lt;code&gt;55&lt;/code&gt; 을 돌려줍니다. &lt;code&gt;sum&lt;/code&gt; 은 리스트의 원소를 모두 합한 값을 구하는 함수고 &lt;code&gt;[1..10]&lt;/code&gt; 은 1-10 을 포함하는 리스트를 생성합니다.&lt;/p&gt;

&lt;p&gt;이제 인터프리터를 잠깐 끈 후에 &lt;em&gt;quick-sort&lt;/em&gt; 함수를 파일에 작성한 뒤 로드해 봅시다. 아참, &lt;code&gt;ghci&lt;/code&gt; 를 종료하려면 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- quicksort.hs

f [] = []
f (x:xs) = f ys ++ [x] ++ zs
           where
             ys = [a | a &amp;lt;- xs, a &amp;lt;= x]
             zs = [b | b &amp;lt;- xs, b &amp;gt; x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;수학 표기법 같은데, 놀랍게도 잘 동작합니다. 다시 &lt;code&gt;ghci&lt;/code&gt; 실행하고 &lt;code&gt;:load quicksort.hs&lt;/code&gt; 를 입력합니다. 그러면 우리가 작성한 &lt;code&gt;f&lt;/code&gt; 함수가 인터프리터에 로드 됩니다. &lt;em&gt;퀵-소트&lt;/em&gt; 를 사용할 수 있다는 뜻이죠.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ghci &amp;gt; f [3, 2, 9, 5, 4]
[2, 3, 4, 5, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;제대로 정렬 되는걸 확인할 수 있습니다. 매번 인터프리터를 종료했다가 다시 실행시키긴 귀찮으니 파일을 다시 수정했을때 &lt;code&gt;:reload&lt;/code&gt; 명령어를 사용해서 다시 로드합니다. 이외에도 다른 명령어를 보고싶다면 &lt;code&gt;ghci&lt;/code&gt; 에 &lt;code&gt;:help&lt;/code&gt; 를 입력해보세요.&lt;/p&gt;

&lt;p&gt;이제 대충 어떻게 돌아가는지 알았으니 기본적인 함수를 좀 알아볼까요? 다른 함수형 언어처럼 하스켈도 &lt;code&gt;List&lt;/code&gt; 에 대한 기본적인 연산들이 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;head [2, 3, 4] -- 2
tail [2, 3, 4] -- [3, 4]

head [2] -- []
tail [2] -- []

init [2, 3, 4] -- [2, 3]
last [2, 3, 4] -- 4

take 2 [2, 3, 4] -- [2, 3]
drop 2 [2, 3, 4] -- [4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;리스트 원소에 접근하려면 &lt;code&gt;!!&lt;/code&gt; 를 이용합니다. 다른 언어와 마찬가지로 &lt;code&gt;0&lt;/code&gt; 부터 인덱스가 시작합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[1, 2, 3, 4] !! 1 -- 2
[1, 2, 3, 4] !! 2 -- 3
[1, 2, 3, 4, 5] !! 2 -- 3
[1, 2, 3, 4, 5] !! 0 -- 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하스켈의 리스트는 자료구조의 그것처럼, &lt;code&gt;n&lt;/code&gt; 번째 원소에 접근하려면 &lt;code&gt;O(n)&lt;/code&gt; 의 비용이 듭니다. 그런 이유에서 리스트의 원소를 구하는 &lt;code&gt;length&lt;/code&gt; 도 &lt;code&gt;O(n)&lt;/code&gt; 의 비용이 듭니다. 자바의 배열과는 좀 다르죠?&lt;/p&gt;

&lt;p&gt;이제 리스트에 대한 몇 가지 연산을 더 알아봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;product [1, 2, 3, 4, 5] -- 120
[1, 2, 3] ++ [4, 5] -- [1, 2, 3, 4, 5]
reverse [1, 2, 3, 4] -- [4, 3, 2, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;++&lt;/code&gt; 는 &lt;em&gt;append&lt;/em&gt; 연산입니다. 앞에 온 리스트에, 뒤에 온 리스트를 붙여줍니다.&lt;/p&gt;

&lt;h3 id=&#34;function-application&#34;&gt;Function Application&lt;/h3&gt;

&lt;p&gt;이제 함수를 사용하는 법을 좀 알아볼까요? 일반적으로 &lt;code&gt;f&lt;/code&gt; 라는 함수에 파라미터 &lt;code&gt;a&lt;/code&gt; 를 적용하려면 &lt;code&gt;f(a)&lt;/code&gt; 이렇게 쓸 텐데요. 하스켈에선 &lt;code&gt;f a&lt;/code&gt; 라고 작성해도 됩니다. 왜냐하면 함수의 우선순위가 다른 연산자들보다 높거든요&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Function application is assumed to have higer priority than all other operators&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이런 이유에서 &lt;code&gt;f a + b&lt;/code&gt; 는 &lt;code&gt;f(a) + b&lt;/code&gt; 입니다. &lt;code&gt;f(a + b)&lt;/code&gt; 를 의도했다면 &lt;code&gt;f(a + b)&lt;/code&gt; 라고 쓰셔야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;f x -- f(x)
f x y -- f(x, y)
f (g x) -- f(g(x))
f x (g y) -- f(x g(y))
f x * g y -- f(x) * g(y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 좀 스크립트에 다른 함수를 작성해 볼까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- test.hs

double x = x + x
quadruple x = double (double x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;double&lt;/code&gt; 은 &lt;em&gt;function&lt;/em&gt; 이고 왼쪽에 오는 &lt;code&gt;x&lt;/code&gt; 는 &lt;em&gt;argument&lt;/em&gt; 입니다. &lt;code&gt;=&lt;/code&gt; 뒤에 오는건 함수의 &lt;em&gt;body&lt;/em&gt; 로 함수가 무슨일을 하는지 기록한 것이죠.&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;:load test.hs&lt;/code&gt; 후 &lt;code&gt;take (double 2) [1, 2, 3, 4, 5, 6]&lt;/code&gt;을 입력하면 &lt;code&gt;[1, 2, 3, 4]]&lt;/code&gt; 를 돌려줄겁니다. 다른 함수를 좀 더 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- test.hs

factorial n = product [1..n]
avg ns = sum ns `div` length ns
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;factorial&lt;/code&gt; 은 별로 놀랍지 않죠? 그런데 평균을 구하는 &lt;code&gt;avg&lt;/code&gt; 는 문법이 좀 신기합니다. &lt;code&gt;ns&lt;/code&gt; 는 리스트입니다. &lt;code&gt;sum&lt;/code&gt; 을 적용해야 하니까요. 그리고 끝에 &lt;code&gt;s&lt;/code&gt; 를 붙이는건 관례인데, 일반적으로 변수 끝에 &lt;code&gt;s&lt;/code&gt; 를 붙이면 리스트란 뜻입니다. &lt;code&gt;ns&lt;/code&gt; 란 이름은 &lt;em&gt;정수 리스트&lt;/em&gt; 라고 알려주는 것이지요.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sum ns&lt;/code&gt; 는 &lt;code&gt;ns&lt;/code&gt; 의 합을 구하고, &lt;code&gt;length ns&lt;/code&gt; 는 &lt;code&gt;ns&lt;/code&gt; 의 길이를 구합니다. &lt;code&gt;div&lt;/code&gt; 함수를 &lt;em&gt;back-quote&lt;/em&gt; 감싼 것은 함수가 두개의 파라미터를 가질때 가운데 위치할 수 있도록 해 줍니다.&lt;/p&gt;

&lt;p&gt;그래서 &lt;em&gt;back quote&lt;/em&gt; 로 감싼  함수를 만나면 하스켈 컴파일러는 &lt;strong&gt;&amp;ldquo;왼쪽과 오른쪽에 있는 것들을 파라미터로 가지는 함수&amp;rdquo;&lt;/strong&gt; 임을 깨닫죠. 이런 문법은 &lt;code&gt;3 / 5&lt;/code&gt; 처럼 함수를 &lt;em&gt;operator (연산자)&lt;/em&gt; 쓰듯이 사용할 수 있게 해줍니다. 따라서 위에 나온 코드의 본래 모양은 이렇습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;avg ns = div (sum ns) (length ns)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;x &lt;code&gt;f&lt;/code&gt; y&lt;/em&gt; is just &lt;strong&gt;syntatic sugar&lt;/strong&gt; for &lt;em&gt;&lt;code&gt;f&lt;/code&gt; x y&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;아참 그리고 함수의 이름은 소문자로 시작해야 합니다. &lt;code&gt;Avg&lt;/code&gt; 는 함수 이름으로 쓸 수 없어요. 그리고 &lt;code&gt;nss&lt;/code&gt; 처럼 변수 이름이 &lt;code&gt;s&lt;/code&gt; 두개로 끝나면, 그건 리스트의 리스트라는 것을 뜻합니다. 물론 관례죠. 필수는 아닙니다. 그러나 우리가 작성하는건 남들이 볼 수도 있으니 따라주는 편이 좋습니다.&lt;/p&gt;

&lt;p&gt;그리고 변수의 정의에 대해 &lt;em&gt;layout&lt;/em&gt; 을 지키면 &lt;code&gt;{}&lt;/code&gt; 블럭을 안 사용해도 됩니다. 예를 들어 다음의 두 코드는 똑같은 코드입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;a = b + c
    where
      b = 1
      c = 2
d = a * 2

a = b + c
    where
      { b = 1
      c = 2 }
d = a * 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;boolean-tuple&#34;&gt;Boolean, Tuple&lt;/h3&gt;

&lt;p&gt;하스켈은 대 소문자를 구분하기 때문에 &lt;em&gt;Boolean false&lt;/em&gt; 를 얻을려면 &lt;code&gt;False&lt;/code&gt; 를 입력해야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;False || True -- True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;괄호로 감싼 두개의 값들을 &lt;em&gt;tuple&lt;/em&gt; 이라 부릅니다. &lt;em&gt;list&lt;/em&gt; 는 같은 종류만 담을 수 있지만 &lt;em&gt;tuple&lt;/em&gt; 은 달라도 상관 없지요. &lt;code&gt;fst&lt;/code&gt;, &lt;code&gt;snd&lt;/code&gt; 는 &lt;em&gt;tuple&lt;/em&gt; 에서 첫 번째 와 두 번째 값을 돌려주는 함수입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;fst (1, &amp;quot;Hello&amp;quot;) -- 1
snd (1, &amp;quot;Hello&amp;quot;) -- &amp;quot;Hello&amp;quot;
fst (snd (1, (2, 3))) -- 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아참, &lt;code&gt;ghci&lt;/code&gt; 에서 &lt;code&gt;:t&lt;/code&gt; 을 입력하면 &lt;em&gt;expression&lt;/em&gt; 의 타입을 알 수 있습니다. &lt;code&gt;:t False&lt;/code&gt;, &lt;code&gt;:t length&lt;/code&gt;, &lt;code&gt;:t head&lt;/code&gt;, &lt;code&gt;:t (1, &amp;quot;Hello&amp;quot;)&lt;/code&gt; 등을 입력해보세요.&lt;/p&gt;

&lt;h3 id=&#34;types&#34;&gt;Types&lt;/h3&gt;

&lt;p&gt;다른 언어처럼 하스켈도 타입이 있습니다. &lt;code&gt;False&lt;/code&gt; 와 &lt;code&gt;True&lt;/code&gt; 은 &lt;code&gt;Bool&lt;/code&gt; 타입이죠. &lt;code&gt;ghci&lt;/code&gt; 에서 &lt;code&gt;:t False&lt;/code&gt; 를 입력하면 &lt;code&gt;False :: Bool&lt;/code&gt; 이란 결과를 돌려줍니다. &lt;code&gt;e :: t&lt;/code&gt; 는 &lt;code&gt;e&lt;/code&gt; 가 &lt;code&gt;t&lt;/code&gt; 타입을 가지고 있다는 뜻입니다.&lt;/p&gt;

&lt;p&gt;모든 &lt;em&gt;expression (식)&lt;/em&gt; 은 타입을 가지고 있습니다. 하스켈 컴파일러는 컴파일 타임에 &lt;em&gt;type inference (타입 추론)&lt;/em&gt; 을 통해서 타입을 찾아냅니다. 만약 함수의 타입과 불일치하는 인자가 파라미터로 넘겨진다면 타입 에러가 발생하는 것이지요.&lt;/p&gt;

&lt;p&gt;하스켈에서 문자열을 나타내는 타입인 &lt;code&gt;String&lt;/code&gt; 은 사실 문자 하나를 의미하는 &lt;code&gt;Char&lt;/code&gt; 의 리스트입니다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;em&gt;fixed-precision integer&lt;/em&gt; 를 의미하는 &lt;code&gt;Int&lt;/code&gt; 이외에도  파이썬 처럼 &lt;em&gt;arbitrary-precision integer&lt;/em&gt; 를 위한 &lt;code&gt;Integer&lt;/code&gt; 타입이 있습니다. 실수는 &lt;code&gt;Float&lt;/code&gt; 타입을 이용해 나타냅니다.&lt;/p&gt;

&lt;p&gt;앞서 언급했듯이 &lt;em&gt;Tuple&lt;/em&gt; 과 달리 &lt;em&gt;List&lt;/em&gt; 는 같은 타입만 가질 수 있습니다. 그래서  &lt;code&gt;[False, False, True]&lt;/code&gt; 의 경우  &lt;code&gt;[Bool]&lt;/code&gt; 타입입니다. 문자열은 문자의 리스트이므로 &lt;code&gt;String&lt;/code&gt; 타입은 &lt;code&gt;[Char]&lt;/code&gt; 입니다. 스트링의 리스트는 &lt;code&gt;[String]&lt;/code&gt; 이고 더 정확히는 &lt;code&gt;[[Char]]&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;그리고 아까는 &lt;em&gt;Tuple&lt;/em&gt; 을 두개의 원소만 가질 수 있다고 했지만 사실은 두개 이상의 원소를 가질 수 있습니다 &lt;code&gt;n&lt;/code&gt; 개의 원소를 가진 &lt;em&gt;tuple&lt;/em&gt; 을 &lt;em&gt;n-tuple&lt;/em&gt; 이라 부릅니다. 예를 들어 이런 &lt;em&gt;tuple&lt;/em&gt; 도 있을 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(False, &#39;a&#39;, True) :: (Bool, Char, Bool)
(True, [&#39;a&#39;, &#39;b&#39;]) :: (Bool, [Char])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;function-type&#34;&gt;Function Type&lt;/h3&gt;

&lt;p&gt;함수는 한 타입의 값을 다른 타입의 값으로 매핑합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A &lt;em&gt;function&lt;/em&gt; is a mapping from values of one type to values of another types&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를 들어 &lt;code&gt;:t not&lt;/code&gt; 을 &lt;code&gt;ghci&lt;/code&gt; 에서 입력하면 아래처럼 출력됩니다.
&lt;code&gt;not&lt;/code&gt; 함수는 &lt;code&gt;Bool&lt;/code&gt; 타입을 받아 &lt;code&gt;Bool&lt;/code&gt; 타입을 돌려준다는 뜻입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;not :: Bool -&amp;gt; Bool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 파일에 타입까지 같이 명시해서 함수를 작성해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;add :: (Int, Int) -&amp;gt; Int
add (x, y) = x + y

zeroto :: Int -&amp;gt; [Int]
zeroto n :: [0..n]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;함수가 만약 &lt;em&gt;tuple&lt;/em&gt; 을 인자로 받으면 괄호가 필요합니다.&lt;/p&gt;

&lt;h3 id=&#34;curried-function&#34;&gt;Curried Function&lt;/h3&gt;

&lt;p&gt;여기서 잠깐 &lt;em&gt;Currying&lt;/em&gt; 을 설명할 텐데요, 하스켈에서 빠질 수 없는 부분이니 이해가 어렵다면 다른 글을 찾아서라도 이해를 하시는 편이 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Currying&lt;/em&gt; 의 기본 개념은 이렇습니다. 함수가 &lt;code&gt;(Int, Int) -&amp;gt; Int&lt;/code&gt; 타입이라면 &lt;strong&gt;계산을 끝내기 위해 두개의 정수를 받아&lt;/strong&gt; 하나의 &lt;code&gt;Int&lt;/code&gt; 를 돌려줄겁니다.&lt;/p&gt;

&lt;p&gt;다시 한번 반복하자면, 계산을 끝내기 위해서는 두개의 정수가 필요합니다. 그렇다면 하나의 정수만 받고, 나머지는 계산이 필요한 시점에 받으면 안될까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Int -&amp;gt; (Int -&amp;gt; Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;바꿔 말해서, 인자 하나를 받아서 계산을 일정부분 해 내고, 나머지는 &lt;strong&gt;인자를 하나 더 받아 계산을 마무리 해 돌려주는 함수&lt;/strong&gt; 를 리턴해도 괜찮지 않을까요? 나머지 계산은 그 함수에서 할거니까, 결국 인자 2개로 계산을 해 내는 건 똑같으니까요.&lt;/p&gt;

&lt;p&gt;이게 &lt;em&gt;Currying&lt;/em&gt; 의 기본 개념입니다. 다시 말해서 다음의 두 타입은 같은 일을 한다는 거죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(Int, Int) -&amp;gt; (Int)

-- same as
Int -&amp;gt; (Int -&amp;gt; Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이게 언제 유용할까요? 인자를 부분적으로 채운 함수가 필요할 때를 생각 해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;add :: Int -&amp;gt; (Int -&amp;gt; Int)
add x y = (x + y)

add3 = add 3
add3 4 -- 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3을 미리 더 해놓은 &lt;code&gt;add3&lt;/code&gt; 이란걸 만들어서 써먹었습니다. 이렇게 &lt;em&gt;Currying&lt;/em&gt; 을 활용할 수 있죠. &lt;code&gt;:t&lt;/code&gt; 를 입력하면 &lt;code&gt;Int -&amp;gt; Int&lt;/code&gt; 를 확인할 수 있습니다. &lt;code&gt;:take 5&lt;/code&gt; 도 &lt;em&gt;curried function&lt;/em&gt; 이죠.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;결국 &lt;em&gt;Currying&lt;/em&gt; 은 &lt;code&gt;n&lt;/code&gt; 개의 인자를 가진 함수를 &lt;code&gt;n-1&lt;/code&gt; 개의 부분적으로 계산된 함수로 바꿀 때&lt;/strong&gt; 쓸 수 있습니다. 단지 &lt;code&gt;n&lt;/code&gt; 개의 파라미터만 가진 &lt;strong&gt;하나의 함수&lt;/strong&gt; 보다 &lt;strong&gt;여러 개의 부분적인 함수&lt;/strong&gt;를 만들어 놓으면 재활용 할 수 있으므로 훨씬 좋죠. 인자에 함수를 넘길 수 있는 함수형 언어에서는 함수를 재활용 할 수 있다는 건 정말 좋은 일입니다..&lt;/p&gt;

&lt;p&gt;하스켈에서는 &lt;em&gt;Currying&lt;/em&gt; 을 아주 중요하게 여깁니다. 얼마나 중요하게 생각하는지, 함수 타입에 괄호가 없으면 자동으로 &lt;em&gt;curried function&lt;/em&gt; 이 되게끔 해 놓았지요. 아래의 두 함수는 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;add :: Int -&amp;gt; (Int -&amp;gt; Int)

-- same as

add :: Int -&amp;gt; Int -&amp;gt; Int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다시 말해 함수의 타입은 &lt;em&gt;right-associative (우측 결합)&lt;/em&gt; 입니다. 반대로 함수의 호출은 &lt;em&gt;left-associative (좌측 결합)&lt;/em&gt; 이죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;add 3 4

-- same as

(add 3) 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그래서 그냥 함수 타입에 괄호를 안쓰시고 인자의 갯수가 &lt;code&gt;n&lt;/code&gt; 개라면 이 함수를 호출 할 때 &lt;code&gt;n-1&lt;/code&gt; 개의 &lt;em&gt;curried function&lt;/em&gt; 을 호출하신다고 생각하면 됩니다.&lt;/p&gt;

&lt;h3 id=&#34;generics&#34;&gt;Generics&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;polymorphic&lt;/em&gt; 은 &lt;em&gt;of many form (다양한 형태의)&lt;/em&gt; 라는 뜻입니다. 프로그래밍에선 주로 다양한 타입을 이야기 할때 사용한 용어인데요, &lt;code&gt;length&lt;/code&gt; 같은 경우 타입을 보면 이렇습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;length :: [a] -&amp;gt; Int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;a&lt;/code&gt; 라는 타입은 없으므로 여기선 &lt;strong&gt;아무 타입이나&lt;/strong&gt; 와도 된다는 뜻입니다. 다시 말해 &lt;code&gt;length&lt;/code&gt; 는 &lt;em&gt;polymorphic function&lt;/em&gt; 입니다. 다양한 타입을 취할 수 있는 함수죠. &lt;code&gt;length&lt;/code&gt; 는 사실 무슨 타입이 오든 관심이 없습니다. 갯수를 세는데만 정신이 팔려있는 함수지요.&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;a&lt;/code&gt;는 &lt;em&gt;type variable&lt;/em&gt; 이라 부릅니다. &lt;code&gt;a&lt;/code&gt; 가 아니라 &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; 등 소문자이기만 하면 됩니다.&lt;/p&gt;

&lt;p&gt;참고로 프로그래밍에서 &lt;em&gt;polymorphism&lt;/em&gt; 은 &lt;em&gt;generics&lt;/em&gt; 와 &lt;em&gt;sub-typing&lt;/em&gt; 의 두 가지 개념을 모두 포함하는 용어입니다. &lt;em&gt;generics&lt;/em&gt; 는 &lt;em&gt;type parameterization&lt;/em&gt; 을, &lt;em&gt;sub-typing&lt;/em&gt; 은 &lt;em&gt;type-hierarchy&lt;/em&gt; 를 의미하지요.&lt;/p&gt;

&lt;p&gt;이제 몇 가지 &lt;em&gt;polymorphic function&lt;/em&gt; 을 살펴봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;*Main&amp;gt; :t fst
fst :: (a, b) -&amp;gt; a
*Main&amp;gt; :t head
head :: [a] -&amp;gt; a
*Main&amp;gt; :t take
take :: Int -&amp;gt; [a] -&amp;gt; [a]
*Main&amp;gt; :t zip
zip :: [a] -&amp;gt; [b] -&amp;gt; [(a, b)]

*Main&amp;gt; [1, 2, 3] `zip` [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
[(1,&#39;a&#39;),(2,&#39;b&#39;),(3,&#39;c&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;polymorphic function&lt;/em&gt; 이 특정 타입에 대해 제한 되었는 것을 하스켈에서는 &lt;em&gt;overloaded&lt;/em&gt; 되었다고 부릅니다. 다시 말해 특정타입에만 해당 함수를 사용할 수 있다는 거죠. 이게 &lt;em&gt;C++&lt;/em&gt; 에서의 &lt;em&gt;오버로딩&lt;/em&gt; 과는 좀 의미가 다릅니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It really means that you&amp;rsquo;re restricting the types of the parameters.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;숫자에 대해서만 사용할 수 있는 &lt;code&gt;sum&lt;/code&gt; 을 좀 살펴볼까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sum :: Num =&amp;gt; [a] -&amp;gt; a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sum&lt;/code&gt; 은 정수나 실수에 대해 모두 사용할 수 있지만 문자열에 대해서는 불가능합니다. 이게 바로 &lt;em&gt;overloaded&lt;/em&gt; 된 것이죠. 그 부분이 바로 &lt;code&gt;Num =&amp;gt;&lt;/code&gt; 이 의미하는 바입니다.&lt;/p&gt;

&lt;p&gt;하스켈은 &lt;em&gt;overloading&lt;/em&gt; 에 사용할 수 있는 다양한 타입 클래스가 있습니다. &lt;code&gt;Num&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt; 등이 그것이죠. &lt;code&gt;ghci&lt;/code&gt; 에서 &lt;code&gt;==&lt;/code&gt; 를 타입 검사 해볼까요? 아참, &lt;code&gt;==&lt;/code&gt; 은 &lt;code&gt;:t (==)&lt;/code&gt; 로 검사해야합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;*Main&amp;gt; :t (&amp;lt;) -- Ordered types
(&amp;lt;) :: Ord a =&amp;gt; a -&amp;gt; a -&amp;gt; Bool
*Main&amp;gt; :t (==) -- Equality types
(==) :: Eq a =&amp;gt; a -&amp;gt; a -&amp;gt; Bool
*Main&amp;gt; :t (+) -- Numeric types
(+) :: Num a =&amp;gt; a -&amp;gt; a -&amp;gt; a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예를 들어 다음의 &lt;code&gt;palindrome&lt;/code&gt; 함수 타입을 잘 보세요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;palindrome xs = reverse xs == xs

:t palindrome -- Eq [a] =&amp;gt; [a] -&amp;gt; Bool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다시 말해서 &lt;code&gt;[a]&lt;/code&gt; 가 비교가 가능한 &lt;code&gt;Eq&lt;/code&gt; 타입이어야 한다는 뜻입니다.&lt;/p&gt;

&lt;h3 id=&#34;basic-classes&#34;&gt;Basic Classes&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Eq&lt;/code&gt; 는 해당 클래스가 비교할 수 있음을, &lt;code&gt;Ord&lt;/code&gt; 는 순서가 있음을 나타냅니다. 기본 타입인 &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;Char&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt; 와 &lt;code&gt;Tuple&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt; 는 모두 &lt;code&gt;Ord&lt;/code&gt; 와 &lt;code&gt;Eq&lt;/code&gt; 클래스의 인스턴스입니다. 참고로 하스켈에서 &lt;em&gt;Not equal&lt;/em&gt; 은 &lt;code&gt;/=&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(&amp;gt;)&lt;/code&gt;, &lt;code&gt;(&amp;gt;=)&lt;/code&gt;, &lt;code&gt;(&amp;lt;)&lt;/code&gt;, &lt;code&gt;(&amp;lt;=)&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt; 등이 &lt;code&gt;Ord&lt;/code&gt; 클래스에 대해 적용할 수 있는 함수입니다. 그리고 &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Tuple&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt; 는 &lt;em&gt;사전 편찬 순서 (lexicographically)&lt;/em&gt; 를 기준으로 비교됩니다.&lt;/p&gt;

&lt;h3 id=&#34;showable-type&#34;&gt;Showable Type&lt;/h3&gt;

&lt;p&gt;다른 언어의 &lt;code&gt;toString&lt;/code&gt; 이 그렇듯이, &lt;code&gt;Show&lt;/code&gt; 클래스의 인스턴스들은 &lt;code&gt;show&lt;/code&gt; 함수를 이용하면 &lt;code&gt;String&lt;/code&gt; 형태로 출력됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;:t show -- Show a =&amp;gt; a -&amp;gt; String
show False -- &amp;quot;False&amp;quot;
show [1, 2, 3] -- &amp;quot;[1, 2, 3]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;readable-type&#34;&gt;Readable Type&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Read&lt;/code&gt; 타입 인스턴스들은 &lt;code&gt;read&lt;/code&gt; 함수를 이용해 &lt;code&gt;String&lt;/code&gt; 으로부터 얻어질 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;:t read -- Read a =&amp;gt; String -&amp;gt; a

read &amp;quot;False&amp;quot; :: Bool
read &amp;quot;[1, 2, 3]&amp;quot; :: [Int] -- [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;integral-fractional-rational&#34;&gt;Integral, Fractional, Rational&lt;/h3&gt;

&lt;p&gt;단순히 숫자 클래스로 &lt;code&gt;Num&lt;/code&gt; 만 있는건 아니고 정수나, 분수, 유리수 등을 나타내는 다양한 클래스가 있고 여기에 적용할 수 있는 함수가 있고, 불가능한 함수가 있습니다. 예를 들어 &lt;code&gt;mod&lt;/code&gt; 나 &lt;code&gt;div&lt;/code&gt; 는 &lt;code&gt;Integral&lt;/code&gt; 에만 적용 가능합니다. &lt;code&gt;(/)&lt;/code&gt; 는 &lt;code&gt;Fractional&lt;/code&gt; 에만 적용 가능합니다.&lt;/p&gt;

&lt;h3 id=&#34;guarded-equations&#34;&gt;Guarded Equations&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt; 대신에 더 좀 편하게 사용할 수 있는 &lt;em&gt;guarded equation&lt;/em&gt; 이 있습니다. &lt;strong&gt;다른 계산 없이&lt;/strong&gt; &lt;code&gt;if&lt;/code&gt; 만 바로 사용한다면 다음과 같이 바꿔 쓸 수 있죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;
abs n = if n &amp;gt;= 0 then n else -n
signum n = if n &amp;gt; 0 then 1 else
		     if n &amp;lt; 0 then -1 else 0

-- same as

abs n | n &amp;gt;= 0 = n
      | otherwise = -n 
       
signum n | n &amp;gt; 0 = 1
         | n &amp;lt; 0 = -1
         | otherwise = 0 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;pattern-matching&#34;&gt;Pattern Matching&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Scala&lt;/em&gt; 나 &lt;em&gt;C#&lt;/em&gt; 과는 다르게 하스켈은 패턴매칭을 바로 이용합니다. &lt;code&gt;case&lt;/code&gt; 나 &lt;code&gt;switch&lt;/code&gt; 없이요! 예를 들어&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;not :: Bool -&amp;gt; Bool
not False = True
not True = False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;패턴 매칭은 위에서 부터 순서대로 적용됩니다. 예를 들어 &lt;code&gt;not False = False&lt;/code&gt; 가 코드에 제일 위에 있다면 항상 &lt;code&gt;False&lt;/code&gt; 만 돌려줄거에요. 우울한 일이 될겁니다.&lt;/p&gt;

&lt;p&gt;이제 2개의 피 연산자를 갖는 연산자 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 를 패턴매칭을 이용해 만들어 볼까요? 좌 우에 피 연산자를 가지는 함수를 만들기 위해서는 &lt;code&gt;(*)&lt;/code&gt; 처럼 괄호로 감싸면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(&amp;amp;&amp;amp;) :: Bool -&amp;gt; Bool -&amp;gt; Bool

True &amp;amp;&amp;amp; True = True
False &amp;amp;&amp;amp; False = False 
False &amp;amp;&amp;amp; True = False
True &amp;amp;&amp;amp; False = False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 간단히는 &lt;code&gt;_&lt;/code&gt; 를 이용할 수 있죠. &lt;em&gt;wild card pattern&lt;/em&gt; 이라고 부릅니다. &lt;code&gt;_&lt;/code&gt; 는 &lt;em&gt;아무거나 (Anything)&lt;/em&gt; 이라고 생각하시면 됩니다. 스칼라를 배우셨다면 익숙하신 기호죠! $&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(&amp;amp;&amp;amp;) :: Bool -&amp;gt; Bool -&amp;gt; Bool
True &amp;amp;&amp;amp; True = True
_ &amp;amp;&amp;amp; _ = False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러나 위 정의보다 더 효율적인 &lt;code&gt;(&amp;amp;&amp;amp;)&lt;/code&gt; 를 만드는 방법이 있습니다. 위 패턴매칭에서 둘 다 &lt;code&gt;True&lt;/code&gt; 일 경우 우측 &lt;code&gt;True&lt;/code&gt; 는 사실 평가할 필요가 없습니다. 매칭 시켜봤자 어차피 &lt;code&gt;True&lt;/code&gt; 니까요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;True &amp;amp;&amp;amp; b = b
False &amp;amp;&amp;amp; _ = False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 경우 패턴매칭에서 &lt;code&gt;b&lt;/code&gt; 는 변수입니다. 왼쪽 피연산자가 &lt;code&gt;False&lt;/code&gt; 일 경우도 우측 피 연산자 &lt;code&gt;_&lt;/code&gt; 를 &lt;em&gt;evaluation (평가)&lt;/em&gt; 하지 않고 바로 &lt;code&gt;False&lt;/code&gt; 를 줍니다. 다시 말해 더 효율적이란 뜻이지요.&lt;/p&gt;

&lt;p&gt;아참 그리고 패턴매칭에서 동일한 변수를 두번 사용할수 없습니다. &lt;code&gt;b &amp;amp;&amp;amp; b = b&lt;/code&gt; 는 에러를 내뿜습니다. 주의하세요&lt;/p&gt;

&lt;h3 id=&#34;list-patterns&#34;&gt;List Patterns&lt;/h3&gt;

&lt;p&gt;함수형 언어에서는 리스트가 주된 자료구조 이기 때문에 패턴매칭에 리스트를 사용할 수 있다면 프로그래머의 삶을 편하게 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:&lt;/code&gt; 는 &lt;em&gt;Cons&lt;/em&gt; 라 부르는 연산자인데요, &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; 는 &lt;code&gt;1 : 2 : 3 : 4 : []&lt;/code&gt; 더 정확히는 &lt;code&gt;1 : (2 : ( 3: (4 : []))))&lt;/code&gt; 입니다. 즉 원소와 뒤에오는 리스트를 연결해주는 것이죠. 요로코롬 패턴매칭에 활용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;head (x : _) = x
tail (_ : xs) = xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;head&lt;/code&gt; 나 &lt;code&gt;tail&lt;/code&gt; 모두 패턴이 &lt;em&gt;비어있지 않은 리스트&lt;/em&gt; 이므로 빈 리스트가 인자로 올때는 에러가 납니다. 그리고, 함수 적용의 우선순위가 다른 연산자들 보다 높기 때문에 &lt;code&gt;head x:_&lt;/code&gt; 는 &lt;code&gt;(head x) : _&lt;/code&gt; 가 되어 에러가 납니다. 괄호를 잊지마세요.&lt;/p&gt;

&lt;h3 id=&#34;lambda-expression&#34;&gt;Lambda Expression&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;lambda (람다)&lt;/em&gt; 는 이제 유명합니다. &lt;em&gt;Java 8&lt;/em&gt; 에도 추가되었으니 인기있는 대부분의 언어는 람다를 가지고 있죠. 익명함수라고 불리기도 하는데, 하스켈에선 &lt;code&gt;\&lt;/code&gt; 를 이용해 람다를 표시합니다. 이를테면, &lt;code&gt;\x -&amp;gt; x + 1&lt;/code&gt; 처럼요. 람다가 왜 유용하나면&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;currying&lt;/em&gt; 을 이용해 정의된 함수를 좀더 의미있게 표현할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lambda expressions can be used to give a formal meaning to functions defined using &lt;em&gt;currying&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이를테면 다음의 두 함수는 동일합니다. 아래 람다를 이용해 정의한 식이 함수를 리턴하는 함수라는 의미가 더 강하죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;add x y = x + y

-- same as

add = \x -&amp;gt; (\y -&amp;gt; x + y)

const :: a -&amp;gt; b -&amp;gt; a
const x _ = x

-- same as

const :: a -&amp;gt; (b -&amp;gt; a)
const x 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2) 람다를 이용하면 컴퓨터 과학의 가장 큰 난제중 하나인 &lt;em&gt;naming (명명)&lt;/em&gt; 을 피할 수 있습니다!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;odds n = map f [0..n]
          where
	    f x = x `mod` 2 /= 0

odds1 n = map (\x -&amp;gt; x `mod` 2 /= 0) [0..n]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sections&#34;&gt;Sections&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;in-fix operator&lt;/em&gt; 는 괄호를 더해 맨 앞으로 끌어올 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An operator written between its two arguments can be converted int a curried function written before its two arguments by using parentheses.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;1 + 2 -- 3

-- same as

(+) 1 2 -- 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 연산자를 앞으로 옮길 수 있게 되면 피 연산자 하나와 괄호를 엮을 수 있습니다. &lt;code&gt;(x+)&lt;/code&gt; 또는 &lt;code&gt;(+x)&lt;/code&gt; 처럼요. 이렇게 피연산와 연산자가 괄호로 묶인 것을 &lt;em&gt;section&lt;/em&gt; 이라 부릅니다. &lt;code&gt;x + y&lt;/code&gt; 를 이용하면 두개의 섹션을 만들 수 있습니다. &lt;code&gt;(x+)&lt;/code&gt; 와 &lt;code&gt;(+y)&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;section (섹션)&lt;/em&gt; 은 언제 유용할까요? 우리는 섹션을 이용하면 람다를 만들어 주는 대신에 좀 더 의미있는 &lt;em&gt;partiall applied function (부분 함수)&lt;/em&gt; 를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;이를테면 &lt;code&gt;double (k (/2))&lt;/code&gt; 처럼요&lt;/p&gt;

&lt;p&gt;이외에도 섹션은 연산자의 타입을 기술하거나 &lt;code&gt;(&amp;amp;&amp;amp;) ::&lt;/code&gt;, 연산자가 다른 함수의 인자로 들어갈때 필요합니다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;em&gt;Programming Haskell&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>하스켈로 배우는 함수형 언어 2</title>
      <link>https://1ambda.github.io/haskell/intro-to-haskell-2/</link>
      <pubDate>Sat, 25 Jun 2016 01:21:42 +0900</pubDate>
      
      <guid>https://1ambda.github.io/haskell/intro-to-haskell-2/</guid>
      <description>

&lt;p&gt;이번시간엔 &lt;em&gt;list comprehension&lt;/em&gt; 을 배웁니다. 수학에서는 집합의 원소를 이용해 새로운 집합을 만들 때 사용하는데요,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In mathematics, the &lt;em&gt;comprehension&lt;/em&gt; notion can be used to construct new sets from old sets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;비슷하게 하스켈에선 컬렉션에다 사용 할 수 있죠.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In Haskell, a similar comprehension notion can be used to construct new lists from old lists&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[x^2 | x &amp;lt;- [1..3]] -- [1, 4, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;x &amp;lt;- [1..5]&lt;/code&gt; 같은 &lt;em&gt;expression&lt;/em&gt; 을 &lt;strong&gt;generator&lt;/strong&gt; 라 부릅니다. &lt;em&gt;comprehension&lt;/em&gt; 은 한 개 이상의 &lt;em&gt;generator&lt;/em&gt; 를 가질 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[(x, y) | x &amp;lt;- [1..3], y &amp;lt;- [4..5]]
-- [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;generator&lt;/em&gt; 의 순서를 바꿈으로써 생성되는 원소들의 순서도 바꿀 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[(x, y) | y &amp;lt;- [4..5], x &amp;lt;- [1..3]]
-- [(1,4),(2,4),(3,4),(1,5),(2,5),(3,5)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보면 알겠지만 &lt;em&gt;multiple generators&lt;/em&gt; 는 &lt;em&gt;nested loop&lt;/em&gt; 와 비슷합니다. 뒤에 오는 &lt;em&gt;generator&lt;/em&gt; 가 &lt;em&gt;inner-loop&lt;/em&gt; 처럼 동작하죠.&lt;/p&gt;

&lt;p&gt;그럼 &lt;code&gt;j = i + 1&lt;/code&gt; 과 같은 변수도 &lt;em&gt;generator&lt;/em&gt; 로 표현 가능할까요? 그럼요!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[(x, y) | x &amp;lt;- [1..3], y &amp;lt;- [x + 1]]
-- [(1,2),(2,3),(3,4)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;앞에 오는 &lt;em&gt;generator&lt;/em&gt; 의 변수를 뒤에 오는 &lt;em&gt;generator&lt;/em&gt; 에서 사용 할 수 있습니다. &lt;em&gt;dependant generator&lt;/em&gt; 라 부릅니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;em&gt;dependant generator&lt;/em&gt; 를 이용해서 &lt;code&gt;concat&lt;/code&gt; 함수를 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;concat :: [[a]] -&amp;gt; [a]
concat xss = [x | xs &amp;lt;- xss, x &amp;lt;- xs]

concat [[1, 2, 3], [4, 5], [6]]
-- [1,2,3,4,5,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;guards&#34;&gt;Guards&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;generator&lt;/em&gt; 에서 변수를 걸러내기 위해 &lt;em&gt;guards&lt;/em&gt; 를 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[x | x &amp;lt;- [1..10], even x]
-- [2, 4, 6, 8, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;약수를 골라내는 &lt;code&gt;factors&lt;/code&gt; 함수도 만들어 볼 수 있겠죠? 그리고 소수를 판별하는 &lt;code&gt;prime&lt;/code&gt; 도 같이 작성합시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;factors :: Int -&amp;gt; [Int]
factors n = [x | x &amp;lt;- [1..n], n `mod` x == 0]

factors 17 -- [1,17]
factors 15 -- [1,3,5,15]

prime :: Int -&amp;gt; Bool
prime n = factors n == [1, n]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;소수를 찾아주는 &lt;code&gt;primes&lt;/code&gt; 도 만들어볼까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;primes :: Int -&amp;gt; [Int]
primes n = [x | x &amp;lt;- [2..n], prime x]

primes 40
-- [2,3,5,7,11,13,17,19,23,29,31,37]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zip&#34;&gt;zip&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;zip&lt;/code&gt; 함수는 두 개의 리스트를 받아 하나의 리스트를 만듭니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- zip :: [a] -&amp;gt; [b] -&amp;gt; [(a, b)]

zip [1, 2, 3]  [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
[(1,&#39;a&#39;),(2,&#39;b&#39;),(3,&#39;c&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;pairs&lt;/code&gt; 와 같은 함수도 만들어 볼 수 있겠죠?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;pairs :: [a] -&amp;gt; [(a, a)]
pairs xs = zip xs (tail xs)

pairs [1, 2, 3, 4]
-- [(1,2),(2,3),(3,4)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;pairs&lt;/code&gt; 함수를 이용하면 하나의 리스트에 있는 한 원소와 그 다음 원소의 &lt;em&gt;pair&lt;/em&gt; 를 구할 수 있으므로 리스트가 정렬되었는지를 검사하는 &lt;code&gt;sorted&lt;/code&gt; 함수에 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sorted :: Ord a =&amp;gt; [a] -&amp;gt; Bool
sorted =
  and [x &amp;lt;= y | (x, y) &amp;lt;- paris xs]
  
sorted [1, 2, 3, 4] --True
sorted [1, 2, 5, 3, 4] --False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하스켈 리스트은 배열과는 달라서 인덱스가 없습니다. 리스트에서 주어진 값과 같은 값을 가지는 원소들의 리스트를 구하는 &lt;code&gt;positions&lt;/code&gt; 함수를 &lt;code&gt;zip&lt;/code&gt; 을 이용해 만들어봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;positions :: Eq a =&amp;gt; a -&amp;gt; [a] =&amp;gt; [Int]
positions x xs = 
  [i | (x&#39;, i) &amp;lt;- zip xs [0..n], x == x&#39;]
  where n = (length xs) - 1
  
positions 0 [0, 1, 0, 1, 1, 1, 1, 0]
-- [0,2,7]  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;string-comprehensions&#34;&gt;String comprehensions&lt;/h3&gt;

&lt;p&gt;하스켈에선 &lt;em&gt;스트링 (문자열)&lt;/em&gt; 이 &lt;em&gt;캐릭터&lt;/em&gt; 의 리스트라는 걸 지난시간에 이야기 했습니다. 따라서 리스트를 인자로 받는 &lt;em&gt;polymorphic&lt;/em&gt; 함수에 스트링을 적용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;zip &amp;quot;abc&amp;quot; [1, 2, 3] -- [(&#39;a&#39;,1),(&#39;b&#39;,2),(&#39;c&#39;,3)]
*Main&amp;gt; take 3 &amp;quot;asdasd&amp;quot; -- &amp;quot;asd&amp;quot;
length &amp;quot;adasd&amp;quot; -- 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그런 이유에서 &lt;em&gt;list comprehension&lt;/em&gt; 을 이용해 스트링을 조작할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Data.Char

lowers :: String -&amp;gt; Int
lowers xs = length [x | x &amp;lt;- xs, isLower x]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-caesar-cipher&#34;&gt;The Caesar cipher&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Caesar cipher (시저 암호)&lt;/em&gt; 는 간단한 치환 암호입니다. 알파벳을 특정 자리수 만큼 밀어 인코딩된 새로운 문자열을 만들어 내지요.&lt;/p&gt;

&lt;p&gt;간단하게 구현하기 위해 모든 문자가 소문자라 가정하겠습니다. 알파벳은 26개이니 &lt;code&gt;a&lt;/code&gt; 를 &lt;code&gt;0&lt;/code&gt; 에 매핑하지요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Data.Char

let2int :: Char -&amp;gt; Int
let2int c = ord c - ord &#39;a&#39;

int2let :: Int -&amp;gt; Char
int2let n = chr(n + ord &#39;a&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ord&lt;/code&gt; 함수는 캐릭터를 받아 아스키 숫자로 변환하고 &lt;code&gt;chr&lt;/code&gt; 함수는 그 반대의 역할을 합니다. 위 코드에서 &lt;code&gt;let2int&lt;/code&gt; 는 캐릭터를 받아 &lt;code&gt;0&lt;/code&gt; 부터 &lt;code&gt;25&lt;/code&gt; 사이의 숫자로 변환합니다. 물론 &lt;code&gt;c&lt;/code&gt; 가 소문자임을 가정합니다. &lt;code&gt;int2let&lt;/code&gt; 은 반대의 역할을 하고요.&lt;/p&gt;

&lt;p&gt;이제 주어진 소문자 알파벳을 &lt;code&gt;n&lt;/code&gt; 번 만큼 이동시키는 &lt;code&gt;shift&lt;/code&gt; 함수를 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;shift :: Int -&amp;gt; Char -&amp;gt; Char
shift n c | isLower c = int2let((let2int c + n) `mod` 26)
          | otherwise = c
          
shift (-1) &#39;a&#39; -- &#39;z&#39;
shift (3) &#39;a&#39; -- &#39;d&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;em&gt;list comprehension&lt;/em&gt; 을 이용해 &lt;code&gt;encode&lt;/code&gt; 함수를 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;encode :: Int -&amp;gt; String -&amp;gt; String
encode n cs = [shift n c | c &amp;lt;- cs]

encode 1 &amp;quot;abc&amp;quot;
-- &amp;quot;bcd&amp;quot;
encode 3 &amp;quot;haskell is fun&amp;quot;
-- &amp;quot;kdvnhoo lv ixq&amp;quot;
encode (-3) &amp;quot;kdvnhoo lv ixq&amp;quot;
-- &amp;quot;haskell is fun&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cracking-the-ciper&#34;&gt;Cracking the Ciper&lt;/h3&gt;

&lt;p&gt;시저 암호를 깨는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;(1) 대량의 텍스트를 분석해 각 알파벳이 문장속에서 나올 확률을 가지고 있는 &lt;em&gt;frequency table&lt;/em&gt; 을 준비합니다.&lt;br /&gt;
(2) 인코딩된 암호를 0 부터 25 까지 시프팅 해 가면서 우리가 준비한 &lt;em&gt;frequency table&lt;/em&gt; 과 같은 비율을 가지고 있는지 검사합니다.&lt;/p&gt;

&lt;p&gt;물론 이 방법은 텍스트가 너무 짧거나, 아니면 우리가 가지고 있는 &lt;em&gt;frequency table&lt;/em&gt; 과 다른 분포를 가지고 있는 텍스트를 복호화 하지 못합니다.&lt;/p&gt;

&lt;p&gt;일단 한번 해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;table :: [Float]
table = [8.2, 1.5, 2.8, 4.3, 12.7, 2.2, 2.0, 6.1, 7.0, 0.2, 0.8, 4.0, 2.4,
        6.7, 7.5, 1.9, 0.1, 6.0, 6.3, 9.1, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1]

count :: Eq a =&amp;gt; a -&amp;gt; [a] -&amp;gt; Int
count x xs = length [x&#39; | x&#39; &amp;lt;- xs, x == x&#39;]

lowers :: String -&amp;gt; Int
lowers cs = length [c | c &amp;lt;- cs, isLower c]

percent :: Int -&amp;gt; Int -&amp;gt; Float
percent n m = (fromIntegral n / fromIntegral m) * 100

freqs :: String -&amp;gt; [Float]
freqs xs = [percent (count x xs) n | x &amp;lt;- [&#39;a&#39;..&#39;z&#39;]]
           where n = lowers xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;freqs&lt;/code&gt; 함수는 주어진 문자열에 대해 &lt;em&gt;frequency table&lt;/em&gt; 을 돌려줍니다. &lt;code&gt;count&lt;/code&gt; 와 &lt;code&gt;percent&lt;/code&gt;, &lt;code&gt;lowers&lt;/code&gt; 함수를 이용해서 만들었습니다.&lt;/p&gt;

&lt;p&gt;이제 우리가 가지고 있는 &lt;code&gt;table&lt;/code&gt; (&lt;code&gt;es&lt;/code&gt;, &lt;em&gt;expected&lt;/em&gt;) 과 인코딩된 텍스트를 시프팅 해서 얻은 &lt;code&gt;os&lt;/code&gt; (&lt;em&gt;observed&lt;/em&gt;) 테이블과의 차를 구하는 &lt;code&gt;chisqr&lt;/code&gt; 함수를 만들겠습니다. 이 차이가 가장 작으면 &lt;code&gt;os&lt;/code&gt; 가 우리가 가진 테이블에 가장 근접한 &lt;em&gt;frequency table&lt;/em&gt; 을 가지는 테이블이라는 뜻이죠.&lt;/p&gt;

&lt;p&gt;카이 제곱 분포를 이용할 건데, 공식은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.maritzresearch.com/maritzstats/HelpFiles/images/ChiSquareFormula-ChiSquareValue.bmp&#34; alt=&#34;http://www.maritzresearch.com/maritzstats/HelpFiles/Formula_ChiSquareTest.htm&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;chisqr :: [Float] -&amp;gt; [Float] -&amp;gt; Float
chisqr os es = sum [(o- e)^2 / e | (o, e) &amp;lt;- zip os es]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하스켈 참 쉽죠? 이제 본래 인코딩 된 텍스트를 왼쪽으로 시프팅 하는 함수를 만들겁니다. &lt;code&gt;rotate&lt;/code&gt; 라고 부릅시다. &lt;code&gt;take&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt; 을 이용하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;rotate :: Int -&amp;gt; [a] -&amp;gt; [a]
rotate n xs = drop n xs ++ take n xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 인코딩된 텍스트에 대해 &lt;code&gt;[0..25]&lt;/code&gt; 번 &lt;code&gt;rotate&lt;/code&gt; 해 가며 &lt;code&gt;chisqr&lt;/code&gt; 을 호출한 결과 중 가장 작은 값을 가지는 &lt;code&gt;factor&lt;/code&gt; 를 찾아 &lt;code&gt;encode&lt;/code&gt; 에  &lt;code&gt;-factor&lt;/code&gt; 로 입력하면 암호가 깨집니다. 이런 일을 하는 함수를 &lt;code&gt;crack&lt;/code&gt; 이라 부르고 작성해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;positions :: Eq a =&amp;gt; a -&amp;gt; [a] -&amp;gt; [Int]
positions x xs = [i | (x&#39;, i) &amp;lt;- zip xs [0..n], x&#39; == x]
  where n = (length xs) - 1

crack :: String -&amp;gt; String
crack xs = encode (-factor) xs
  where
    factor = head (positions (minimum chiTab) chiTab)
    chiTab = [chisqr (rotate n table&#39;) table | n &amp;lt;- [0..25]]
    table&#39; = freqs xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 이 함수를 사용해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;crack &amp;quot;kdvnhoo lv ixq&amp;quot;
-- &amp;quot;haskell is fun&amp;quot;
crack &amp;quot;vscd mywzboroxcsyxs kbo esopev&amp;quot;
-- &amp;quot;list comprehensioni are uieful&amp;quot;
crack &amp;quot;vscd mywzboroxcsyxs kbo ecopev&amp;quot;
-- &amp;quot;list comprehensioni are useful&amp;quot;

crack (encode 3 &amp;quot;haskell&amp;quot;)
-- &amp;quot;piasmtt&amp;quot;
crack (encode 3 &amp;quot;boxing wizards jump quickly&amp;quot;)
-- &amp;quot;wjsdib rduvmyn ephk lpdxfgt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아래 두개의 예제는 복호화의 실패한 경우를 보여줍니다. 인코딩된 텍스트의 테이블이 우리가 가진 테이블과 많이 다르기 때문이지요.&lt;/p&gt;

&lt;h3 id=&#34;exercise&#34;&gt;Exercise&lt;/h3&gt;

&lt;p&gt;두개의 &lt;em&gt;generator&lt;/em&gt; 를 가진 하나의 &lt;em&gt;comprehension&lt;/em&gt; 은 하나의 &lt;em&gt;generator&lt;/em&gt; 를 가진 두개 이상의 &lt;em&gt;comprehension&lt;/em&gt; 으로 작성할 수 있습니다. 다음의 두 라인은 동일합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[(x, y) | x &amp;lt;- [1, 2, 3], y &amp;lt;- [4, 5, 6]]

concat [[(x, y) | y &amp;lt;- [4, 5, 6]] | x &amp;lt;- [1, 2, 3]] 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;strong&gt;DelftX FP 101x&lt;/strong&gt; in &lt;em&gt;edx&lt;/em&gt;&lt;br /&gt;
(2) Chapter 5, Programming in haskell&lt;br /&gt;
(3) &lt;a href=&#34;http://ko.wikipedia.org/wiki/%EC%B9%B4%EC%9D%B4%EC%82%AC%EB%A5%B4_%EC%95%94%ED%98%B8&#34;&gt;&lt;em&gt;Caesar cipher&lt;/em&gt;&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://www.maritzresearch.com/maritzstats/HelpFiles/Formula_ChiSquareTest.htm&#34;&gt;http://www.maritzresearch.com&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>하스켈로 배우는 함수형 언어 3</title>
      <link>https://1ambda.github.io/haskell/intro-to-haskell-3/</link>
      <pubDate>Sat, 25 Jun 2016 01:21:44 +0900</pubDate>
      
      <guid>https://1ambda.github.io/haskell/intro-to-haskell-3/</guid>
      <description>

&lt;p&gt;하스켈에서 &lt;em&gt;repetition (반복)&lt;/em&gt; 은 &lt;em&gt;recursion&lt;/em&gt; 을 통해 표현됩니다. 간단한 재귀부터 시작해서 &lt;em&gt;mutual recursion&lt;/em&gt; 까지 알아보고, &lt;em&gt;Higher order function&lt;/em&gt; (특히 &lt;code&gt;fold&lt;/code&gt;) 에 대해 배운 뒤 적용을 위해 &lt;em&gt;church numerals&lt;/em&gt; 를 구현해보고, 마지막으로 간단한 문자열 전송기를 모델링 해 보겠습니다.&lt;/p&gt;

&lt;h3 id=&#34;tail-call&#34;&gt;Tail call?&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;recursion&lt;/em&gt; 을 주로 사용한다면 &lt;em&gt;stack&lt;/em&gt; 이 많이 쌓일 수 있습니다. 이런 문제를 해결해 주는 것이 &lt;em&gt;tail call elimination&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;p&gt;간단한 재귀 함수를 만들어서 스택이 어떻게 변하나 한번 보죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;factorial 0 = 1
factorial n = n * factorial(n - 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 때 &lt;code&gt;factorial 3&lt;/code&gt; 을 평가한다면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;factorial 3
3 * factorial 2
3 * (2 * factorial 1)
3 * (2 * (1 * factorial 0))
3 * (2 * (1 * 1))
3 * (2 * 1)
3 * 2
6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 각 단계가 확장되면서 &lt;code&gt;n&lt;/code&gt; 이 매우 클 경우 마지막 단계에서 연산의 길이가 엄청나게 길어집니다. 함수 한번 호출당 스택이 하나씩 생긴다고 보면 어마어마한 스택이 생기는 것이죠.&lt;/p&gt;

&lt;p&gt;다행히도 하스켈은 &lt;em&gt;tail recursion optimization (꼬리 재귀 최적화)&lt;/em&gt; 를 가지고 있습니다. 꼬리 재귀에 대한 이야기는 나중에 더 이야기 하도록 하지요.&lt;/p&gt;

&lt;h3 id=&#34;recursion-on-lists&#34;&gt;Recursion on Lists&lt;/h3&gt;

&lt;p&gt;리스트는 같은 타입을 여러개 저장할 수 있기 때문에 &lt;em&gt;recursion&lt;/em&gt; 을 사용하기 적합하죠.&lt;/p&gt;

&lt;p&gt;리스트 내의 모든 원소의 곱을 구하는 &lt;code&gt;product&lt;/code&gt; 함수를 만들어 볼까요? 하스켈에 원래 있지만, 재미삼아 만들어 봅시다. 이름은 충돌이 안나게 &lt;code&gt;productC&lt;/code&gt; 라 부릅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;productC :: [Int] -&amp;gt; Int
productC [] = 1
productC (n : ns) = n * productC ns
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;length&lt;/code&gt; 와 &lt;code&gt;reverse&lt;/code&gt; 도 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;lengthC :: [a] -&amp;gt; Int
lengthC [] = 0
lengthC (x : xs) = 1 + length xs

reverseC :: [a] -&amp;gt; [a]
reverseC [] = []
reverseC (x : xs) = reverse(xs) ++ [x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;조금 더 복잡한 &lt;code&gt;zip&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt; 함수나 &lt;code&gt;++&lt;/code&gt; 연산자도 어렵지 않습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;zipC :: [a] -&amp;gt; [b] -&amp;gt; [(a, b)]
zipC [] _ = []
zipC _ [] = []
zipC (x:xs) (y:ys) = (x, y) : zip xs ys

dropC :: Int -&amp;gt; [a] -&amp;gt; [a]
dropC 0 xs = xs
dropC _ [] = []
dropC n (x:xs) = drop (n-1) xs

(++) :: [a] -&amp;gt; [a] -&amp;gt; [a]
[] ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;quick-sort&#34;&gt;Quick sort&lt;/h3&gt;

&lt;p&gt;퀵소트 알고리즘은 간단합니다. 매 함수 호출에서, &lt;em&gt;pivot&lt;/em&gt; 이라 불리는 리스트 내 원소를 고른 후 &lt;em&gt;pivot&lt;/em&gt; 좌측에는 그 보다 작은 수를, 우측에는 &lt;em&gt;pivot&lt;/em&gt; 보다 큰 수를 배치합니다. 그리고 &lt;em&gt;pivot&lt;/em&gt; 을 제외한 좌측 과 우측에 대해 재귀 호출을 하지요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://sadakurapati.files.wordpress.com/2013/10/qsort_2.png?w=902&amp;amp;h=617&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;https://sadakurapati.wordpress.com&#34;&gt;https://sadakurapati.wordpress.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;지난 강의에서 배운 &lt;em&gt;list comprehension&lt;/em&gt; 을 이용하면 매우 간단하게 &lt;em&gt;quick sort&lt;/em&gt; 를 만들 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;qsort :: [Int] -&amp;gt; [Int]
qsort [] = []
qsort (x:xs) = qsort smaller ++ [x] ++ qsort larger
               where
                 smaller = [a | a &amp;lt;- xs, a &amp;lt;= x]
                 larger = [b | b &amp;lt;- xs, b &amp;gt; x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 코드에서는 매 재귀마다 인자로 받는 리스트의 첫번째 원소 &lt;code&gt;x&lt;/code&gt; 를  &lt;em&gt;pivot&lt;/em&gt; 으로 사용했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://media-cache-ec0.pinimg.com/736x/11/09/78/11097867a0e6c772c36285d97d94623b.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;recursion&#34;&gt;Recursion&lt;/h3&gt;

&lt;p&gt;위의 예에서 보았듯이 자기 자신을 호출하는 함수 패턴을 &lt;em&gt;recursion (재귀)&lt;/em&gt; 라 부릅니다. 언제 유용할까요? 재귀를 이용하면 &lt;em&gt;induction (귀납법)&lt;/em&gt; 을 이용해 함수의 성질을 증명할 수 있습니다. 제대로 동작하는지, 의도 했던대로 동작하는지 등을요.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Properties of functions defined using recursion can be proved using the simple but powerful mathematical technique of &lt;strong&gt;induction&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;mutial-recursion&#34;&gt;Mutial recursion&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;mutual recursion&lt;/em&gt; 은 서로 다른 두개의 함수가 상호간 재귀를 이용해 정의되는 방식입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;odd&lt;/code&gt; 와 &lt;code&gt;even&lt;/code&gt; 함수를 &lt;em&gt;mutual recursion&lt;/em&gt; 을 이용해 정의할 수 있습니다. 일반적으로는 효율성을 위해  2로 나눈 나머지를 이용해 정의하지만, 양수에 대해서는 아래와 같이 &lt;em&gt;mutual recursion&lt;/em&gt; 으로 만들 수 있죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;even :: Int -&amp;gt; Bool
even 0 = True
even n = oddC (n-1)

odd :: Int -&amp;gt; Bool
odd 0 = False
odd n = evenC (n-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;비슷하게 리스트에서 짝수번째, 혹은 홀수번째 원소들만 돌려주는 &lt;code&gt;evens&lt;/code&gt; 와 &lt;code&gt;odds&lt;/code&gt; 함수도 &lt;em&gt;mutual recursion&lt;/em&gt; 을 이용해 정의할 수 있습니다. &lt;code&gt;evens&lt;/code&gt; 는 0번째 부터 돌려줍니다. &lt;code&gt;odds&lt;/code&gt; 는 턴을 넘기는데 쓰고 실제 작업은 &lt;code&gt;evens&lt;/code&gt; 에서 한다고 생각하면 금방 이해할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;evens :: [a] -&amp;gt; [a]
evens [] = []
evens (x:xs) = x : odds xs

odds :: [a] -&amp;gt; [a]
odds [] = []
odds (_:xs) = evens xs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;advice-on-recursion&#34;&gt;Advice on recursion&lt;/h3&gt;

&lt;p&gt;재귀는 자전거 타기와 비슷합니다. 처음엔 불가능해 보이는데 한번 시도해보면 정말 쉽게 탈 수 있죠. 여기 재귀를 만드는데 도움이 될만한 5가지 스텝이 있습니다. &lt;code&gt;init&lt;/code&gt; 함수를 예로 들어 설명하겠습니다.&lt;/p&gt;

&lt;p&gt;(1) define the type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;init :: [a] -&amp;gt; [a]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2) enumerate the cases&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;init (x:xs) =
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(3) define the simple case&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;init (x:xs) | null xs = []
            | otherwise = 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(4) define the other cases&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;init (x:xs) | null xs = []
            | otherwise = x : init xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(5) generalise and simplify&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;init :: [a] -&amp;gt; [a]
init [_] = []
init (x:xs) = x : init xs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;예제 몇 가지를 좀 더 살펴봅시다. 먼저 곱셈 연산입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(*) :: Int -&amp;gt; Int -&amp;gt; Int
m * 0 = 0
m * n = m + (m * (n - 1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;정렬된 리스트에 원소를 삽입하는 &lt;code&gt;insert&lt;/code&gt; 함수입니다. 바로 다음에 만들 &lt;code&gt;isort&lt;/code&gt; (&lt;em&gt;insertion sort&lt;/em&gt;) 를 구현한 함수에서 사용합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insert :: Ord a =&amp;gt; a -&amp;gt; [a] -&amp;gt; [a]
insert x [] = [x]
insert x (y:ys) | x &amp;lt;= y = x : y : ys
                | otherwise = y : insert x ys

isort :: Ord a =&amp;gt; [a] -&amp;gt; [a]
isort [] = []
isort (x:xs) = insert x (isort xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이번엔 &lt;em&gt;merge sort&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;merge :: Ord a =&amp;gt; [a] -&amp;gt; [a] -&amp;gt; [a]
merge [] ys = ys
merge xs [] = xs
merge (x:xs) (y:ys) =
  if x &amp;lt;= y then x : merge xs (y: ys) else y : merge (x:xs) ys

halve :: [a] -&amp;gt; ([a], [a])
halve xs = splitAt (length xs `div` 2) xs

msort :: Ord a =&amp;gt; [a] -&amp;gt; [a]
msort [] = []
msort [x] = [x]
msort xs = merge (msort ys) (msort zs)
           where (ys, zs) = halve xs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;higher-order-function&#34;&gt;Higher-order function&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;higher-order function&lt;/em&gt; 은 함수를 인자로 받아 다시 함수를 돌려주는 함수를 말합니다. &lt;del&gt;응?&lt;/del&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A function is called &lt;em&gt;higher-order&lt;/em&gt; if it takes a function as an argument or returns a function as a result&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;twice :: (a -&amp;gt; a) -&amp;gt; a -&amp;gt; a
twice f x = f (f x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;twice&lt;/code&gt; 는 인자 &lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;f&lt;/code&gt; 를 두번 적용한 뒤 값을 돌려줍니다. 더 정확히는 &lt;em&gt;curried function&lt;/em&gt; 이므로 &lt;code&gt;twice f&lt;/code&gt; 는 앞으로 뭘 인자로 받을지 모르지만 &lt;code&gt;f&lt;/code&gt; 를 두번 적용하는 함수를 돌려줍니다.&lt;/p&gt;

&lt;p&gt;이런 &lt;em&gt;higher-order function (고차함수)&lt;/em&gt; 가 언제 유용할까요?&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Common programming idioms&lt;/strong&gt; can be encoded as functions within the language itself.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Domain specific languages&lt;/strong&gt; can be defined as collections of higher-order functions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Algebraic properties&lt;/strong&gt; of higher-order functions can be used to reason about programs.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;map&#34;&gt;map&lt;/h3&gt;

&lt;p&gt;먼저 &lt;code&gt;map&lt;/code&gt; 함수를 살펴봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]

map (+1) [1, 3, 5, 7]
-- [2, 4, 6, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 &lt;code&gt;map&lt;/code&gt; 함수는 우리가 이전에 배웠던 &lt;em&gt;list comprehension&lt;/em&gt; 으로 똑같이 작성할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;map f xs = [f x | x &amp;lt;- xs]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아니면 &lt;em&gt;recursive function&lt;/em&gt; 으로 작성할 수도 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;map f [] = []
map f (x:xs) = f x : map f xs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filter&#34;&gt;filter&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;filter&lt;/code&gt; 도 고차함수입니다. &lt;code&gt;filter&lt;/code&gt; 는 &lt;em&gt;predicate&lt;/em&gt; 즉, &lt;code&gt;(a -&amp;gt; Bool)&lt;/code&gt; 을 받아 &lt;code&gt;True&lt;/code&gt; 인 원소만 모아 돌려줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;filter :: (a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; [a]

filter even [1..10]
-- [2, 4, 6, 8, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;filter&lt;/code&gt; 도 마찬가지로 &lt;em&gt;list comprehension&lt;/em&gt; 과 &lt;em&gt;recursive function&lt;/em&gt; 두 가지 버전으로 작성될 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;filter p xs = [x | x &amp;lt;- xs, p x]

filter p [] = []
filter p (x:xs)
  | p x = x : filter p xs
  | otherwise = filter p xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;단순히 &lt;em&gt;list comprehension&lt;/em&gt; 으로 작성하는 것 보다, &lt;em&gt;recursive function&lt;/em&gt; 으로 작성하면 위에서 볼 수 있듯이 공통점을 파악할 수 있습니다. 그러면 한단계 더 추상화 할 수 있지요. &lt;code&gt;filter&lt;/code&gt; 와 &lt;code&gt;map&lt;/code&gt; 의 공통점이 보이시나요?&lt;/p&gt;

&lt;h3 id=&#34;foldr&#34;&gt;foldr&lt;/h3&gt;

&lt;p&gt;위의 두 가지 예에서 &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt; 모두 빈 리스트와 그렇지 않은 리스트를 구분했습니다. 그리고 각각의 원소에 대해서 연산을 수행했지요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;f [] = v
f (x:xs) = x pred f xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빈 원소라면 특정 값 &lt;code&gt;v&lt;/code&gt; 를 돌려주고 아니라면 원소 &lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;pred&lt;/code&gt;를 적용하고, 나머지 &lt;em&gt;tail&lt;/em&gt; &lt;code&gt;xs&lt;/code&gt; 에 &lt;code&gt;f&lt;/code&gt; 를 적용합니다. 비슷한 예제를 살펴볼까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- v = 0, pred = +
sum [] = 0
sum (x:xs) = x + sum xs

-- v = 1, pred = *
product [] = 1
product (x:xs) = x * product xs

-- v = True, pred = &amp;amp;&amp;amp;
and [] = True
and (x:xs) = x &amp;amp;&amp;amp; and xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 다음과 같이 &lt;code&gt;foldr&lt;/code&gt; (&lt;em&gt;fold right&lt;/em&gt;) 을 이용해 정의할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sum = foldr (+) 0

product = foldr (*) 1

or = foldr (||) False

and = foldr (&amp;amp;&amp;amp;) True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위에서 대략적인 정의를 봤지만, 더 엄밀하게 &lt;code&gt;foldr&lt;/code&gt; 은 이렇게 정의할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;foldr :: (a -&amp;gt; b-&amp;gt; b) -&amp;gt; b -&amp;gt; [a] -&amp;gt; b
foldr f v [] = []
foldr f v (x:xs) = f x (foldr f v xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보면 알겠지만, 리스트의 &lt;em&gt;the right-most (가장 우측)&lt;/em&gt; 부터 연산합니다. 그래서 &lt;em&gt;fold right&lt;/em&gt; 라는 이름이 붙었지요. 그림으로 보자면&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.pling.org.uk/cs/funimg/foldr.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.pling.org.uk/cs/fun.html&#34;&gt;http://www.pling.org.uk/cs/fun.html&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sum [1, 2, 3]
foldr (+) 0 [1, 2, 3]
foldr (+) 0 (1:(2:(3:[])))
1 + (2 + (3 + 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;콘싱 &lt;code&gt;:&lt;/code&gt; 하고 비슷합니다. 이 부분에 연산자를 집어넣고, &lt;code&gt;[]&lt;/code&gt; 에 초기값 &lt;code&gt;v&lt;/code&gt; 를 넣는다고 생각하면 이해하기 쉽습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;length&lt;/code&gt; 도 비슷한 패턴을 가지고 있기 때문에 &lt;code&gt;foldr&lt;/code&gt; 로 바꿀 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;length :: [a] -&amp;gt; Int
length [] = 0
length (x:xs) = 1 + length xs

length = foldr (\_ n -&amp;gt; 1 + n) 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 바꿀 수 있는 이유는&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;length [1, 2, 3]
length (1: (2: (3:[])))
1 + (1 + (1 + 0)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 각 &lt;code&gt;:&lt;/code&gt; 을 &lt;code&gt;\_ n -&amp;gt; 1 + n&lt;/code&gt; 으로 바꾸면 되기 때문입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse [] = []
reverse (x:xs) reverse xs ++ [x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 위 &lt;code&gt;reverse&lt;/code&gt; 함수도 &lt;code&gt;foldr&lt;/code&gt; 을 이용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse = foldr (\x xs -&amp;gt; xs ++ [x]) []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음의 &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt; 도 이렇게 정의할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;foldr :: (a -&amp;gt; b -&amp;gt; b) -&amp;gt; b -&amp;gt; [a] -&amp;gt; b
foldr f v [] = v
foldr f v (x:xs) = f x (foldr f v xs)

filter :: (a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; [a]
filter p xs = foldr (\x acc -&amp;gt; if p x then x : acc else acc) [] xs

map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]
map p xs = foldr (\x acc -&amp;gt; p x : acc) [] xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;foldr&lt;/code&gt; 을 이용하면 몇 가지 장점이 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Some recursive functions on lists, such as sum, are &lt;strong&gt;simpler&lt;/strong&gt; to define using foldr.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Properties of functions defined using foldr can ben proved using algebraic properties of foldr, such as &lt;strong&gt;fusion&lt;/strong&gt; and the &lt;strong&gt;banana split&lt;/strong&gt; rule.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Advanced program &lt;strong&gt;optimizations&lt;/strong&gt; can be simpler if foldr is used in place of explicit recursion.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기서 &lt;em&gt;fusion&lt;/em&gt; 은, 하나의 &lt;code&gt;foldr&lt;/code&gt; 은 리스트를 순회하면서 새로운 리스트를 리턴하고, 다른 &lt;code&gt;foldr&lt;/code&gt; 을 그 결과에 사용할 때 &lt;em&gt;intermediate list&lt;/em&gt; 를 생성하는 것 없이 계산을 해 낸다는 뜻입니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In particular &lt;strong&gt;fusion&lt;/strong&gt; means that I have two functions. One that uses &lt;code&gt;foldr&lt;/code&gt; to traverse one list and return another list. And if I do another &lt;code&gt;foldr&lt;/code&gt; on the result of that I can fuse these two together, such that the &lt;strong&gt;intermediate list is never constructed&lt;/strong&gt;. So program can be optimized.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다른 고차함수들을 좀 살펴봅시다.&lt;/p&gt;

&lt;h3 id=&#34;composition&#34;&gt;composition&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;(.)&lt;/code&gt; 은 함수를 &lt;em&gt;composition (합성)&lt;/em&gt; 해 줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; (a -&amp;gt; c)
f . g = \x -&amp;gt; f(g x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예를 들어&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;odd :: Int -&amp;gt; Bool
odd = not . even
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;compoisition&lt;/em&gt; 을 사용할때는 괄호와 나머지 인자를 제거하여 함수의 정의를 간단히 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;twice f x = f (f x)

-- same as
twice f = f f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;all-any&#34;&gt;all, any&lt;/h3&gt;

&lt;p&gt;모든 원소에 대해 &lt;code&gt;p&lt;/code&gt; 를 적용한 결과가 참인지를 돌려주는 &lt;code&gt;all&lt;/code&gt; 은 다음처럼 정의할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;all :: (a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; Bool
all p xs = and [p x | x &amp;lt;- xs]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이번엔 &lt;em&gt;list comprehension&lt;/em&gt; 을 사용했습니다. &lt;code&gt;foldr&lt;/code&gt; 과의 차이는, &lt;code&gt;foldr&lt;/code&gt; 은 모든 순회 가능한 데이터 타입에 적용 가능한 반면 &lt;em&gt;list comprehension&lt;/em&gt; 은 리스트에만 사용할 수 있습니다. 위 예제를 &lt;code&gt;foldr&lt;/code&gt; 로 바꾸면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;all :: (a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; Bool
all p xs = foldr (\x acc -&amp;gt; p x &amp;amp;&amp;amp; acc) True xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;any&lt;/code&gt; 도 만들 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Data.Char

any :: (a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; Bool
any p xs = or [p x | x &amp;lt;- xs]

-- same as
any p xs = or (map p xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;takewhile-dropwhile&#34;&gt;takeWhile, dropWhile&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;takeWhile&lt;/code&gt; 은 &lt;em&gt;predicate&lt;/em&gt; 가 참인 원소까지만 돌려줍니다. 예를 들어&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;takeWhile :: (a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; [a]
takeWhile p [] = []
takeWhile p (x:xs) | p x = x : takeWhile p xs
                    | otherwise = [] 

takeWhile isAlpha &amp;quot;abc def&amp;quot;
-- &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;반면 &lt;code&gt;dropWhile&lt;/code&gt; 은 &lt;em&gt;predicate&lt;/em&gt; 를 적용한 결과가 참인 원소를 모두 버리고 나머지만 돌려줍니다. 예를 들어&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;dropWhile :: (a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; [a]
dropWhile p [] = []
dropWhile p (x:xs) | p x = dropWhile p xs
                    | otherwise = x:xs
                    
dropWhile isAlpha &amp;quot;fp 101&amp;quot;
-- &amp;quot; 101&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;church-numerals&#34;&gt;Church Numerals&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Church Numerals&lt;/strong&gt; give us a way to &lt;em&gt;abstract&lt;/em&gt; over the concrete representation of a number by means of &lt;strong&gt;functions&lt;/strong&gt; and &lt;strong&gt;unction application&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;숫자 &lt;code&gt;n&lt;/code&gt; 은 &lt;em&gt;zero&lt;/em&gt; 에 &lt;code&gt;n&lt;/code&gt; 번의 &lt;code&gt;s&lt;/code&gt; &lt;em&gt;function application&lt;/em&gt; 을 통해 정의합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;zero = \s z -&amp;gt; z
one = \s z -&amp;gt; s z
two = \s z -&amp;gt; s (s z)

-- same as
two = \s z -&amp;gt; (s . s) z

-- we can remove z
two = \s -&amp;gt; s . s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 데이터 &lt;code&gt;z&lt;/code&gt; 자체는 아무것도 정해진 것이 없습니다. 다시 말해 어떤 타입이든 가져다 쓸 수 있다는 뜻이지요.&lt;/p&gt;

&lt;p&gt;우리가 숫자 3을 표현하기 위해 &lt;code&gt;1&lt;/code&gt;을 세번 더해 &lt;code&gt;3&lt;/code&gt; 을 표시하든, 아니면 &lt;code&gt;*&lt;/code&gt; 를 세번 컨싱하든 상관 없다는 뜻 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;zero = \s z -&amp;gt; z
one = \s z -&amp;gt; s z
two = \s -&amp;gt; s . s

-- church to int
c2i x = x (+1) 0

c2i zero
-- 0

c2i one
-- 1

c2i two
-- 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;* (에스터리스크)&lt;/em&gt; 의 개수로 숫자를 정의해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- church to int
c2s x = x (&#39;*&#39; :) &amp;quot;&amp;quot;

c2s zero
-- &amp;quot;&amp;quot;

c2s one
-- &amp;quot;*&amp;quot;

c2s two
-- &amp;quot;**&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 연산자를 만들어 봅시다. 덧셈부터 시작해 보죠! &lt;code&gt;c2i&lt;/code&gt; 에 &lt;code&gt;x&lt;/code&gt; 를 넣어 만들어낸 &lt;em&gt;수 (Number)&lt;/em&gt; 를 &lt;code&gt;x&#39;&lt;/code&gt; 라 하고 &lt;code&gt;y&lt;/code&gt; 를 넣어 만든 수를 &lt;code&gt;y&#39;&lt;/code&gt; 라 합시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;x&#39; = c2i x
y&#39; = c2i y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러면 덧셈은 이렇게 정의할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;x&#39; + y&#39; = c2i (add x y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;증명해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;x&#39; + y&#39; 
= c2i x + c2i y
= x (+1) 0 + c2i y -- 0 is substituted
= x (+1) (c2i y)
= x (+1) (y (+1) 0)
= (\s z -&amp;gt; x s (y s z)) (+1) 0 -- by beta expension
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보면 알겠지만 &lt;code&gt;c2i y&lt;/code&gt; 나 &lt;code&gt;0 + c2i y&lt;/code&gt; 나 같습니다. 따라서 &lt;code&gt;0&lt;/code&gt;을 지우고 &lt;code&gt;x c2i&lt;/code&gt; 의 베이스 값으로 &lt;code&gt;(c2i y)&lt;/code&gt; 를 사용할 수 있죠.&lt;/p&gt;

&lt;p&gt;그리고 마지막 치환은 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;z&lt;/code&gt; 를 &lt;code&gt;(+1)&lt;/code&gt; 과 &lt;code&gt;0&lt;/code&gt; 으로 취하는 &lt;em&gt;lambda&lt;/em&gt; 를 구할 수 있습니다. &lt;code&gt;\s z -&amp;gt; x s (y s z)&lt;/code&gt; 를 &lt;code&gt;add&lt;/code&gt; 라 부르면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;x&#39; + y&#39; = (add x y) (+1) 0
= c2i (add x y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결국 &lt;em&gt;addtion&lt;/em&gt; 은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;add x y = \s z -&amp;gt; x s (y s z)

c2i (add one two)
-- 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*multiplication (곱셈)*은 어떻게 만들까요? 간단한 예제부터 시작해 &lt;em&gt;intuition&lt;/em&gt; 을 얻어보도록 합시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;two = \s -&amp;gt; s . s
three = \s -&amp;gt; s . s . s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결국 &lt;code&gt;n&lt;/code&gt; 번째 수란건 &lt;code&gt;s&lt;/code&gt; &lt;em&gt;successor function&lt;/em&gt; 을 &lt;code&gt;n&lt;/code&gt; 번 만큼 수행한거지요. 그럼 &lt;code&gt;a * b&lt;/code&gt; 의 곱셈은 &lt;code&gt;b&lt;/code&gt; 번 적용한 &lt;em&gt;successor&lt;/em&gt; 를 &lt;code&gt;a&lt;/code&gt; 번 적용하면 되므로&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mul = \s z -&amp;gt; x (y s) z

c2i (mul two five)
-- 10
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;examples-1&#34;&gt;Examples&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;id :: a -&amp;gt; a
id = \x -&amp;gt; x

compose :: [a -&amp;gt; a] -&amp;gt; (a -&amp;gt; a)
compose = foldr (.) id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;id&lt;/code&gt; 함수는 받은걸 그대로 돌려주기 때문에 &lt;code&gt;id . f&lt;/code&gt;, &lt;code&gt;f . id&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 입니다. 따라서 함수 리스트를 위한 &lt;code&gt;foldr&lt;/code&gt; 의 초기값으로 &lt;code&gt;id&lt;/code&gt; 를 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;string-transmitter&#34;&gt;String Transmitter&lt;/h3&gt;

&lt;p&gt;간단한 문자열 전송을 모델링한 코드를 작성해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Data.Char

type Bit = Int

bin2int :: [Bit] -&amp;gt; Int
bin2int bits = sum [w * b | (w, b) &amp;lt;- zip weights bits]
  where weights = iterate (*2) 1

-- or
-- bin2int bitis = foldr (\x acc -&amp;gt; x + acc * 2) 0

int2bin :: Int -&amp;gt; [Bit]
int2bin 0 = []
int2bin n = n `mod` 2 : int2bin(n `div` 2)

make8 :: [Bit] -&amp;gt; [Bit]
make8 bits = take 8 (bits ++ repeat 0)

encode :: String -&amp;gt; [Bit]
encode = concat . map (make8 . int2bin . ord)

chop8 :: [Bit] -&amp;gt; [[Bit]]
chop8 [] = []
chop8 bits = take 8 bits : chop8 (drop 8 bits)

decode :: [Bit] -&amp;gt; String
decode = map (chr . bin2int) . chop8

channel :: [Bit] -&amp;gt; [Bit]
channel = id

transmit :: String -&amp;gt; String
transmit = decode . channel . encode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;재밌는 부분은 마지막 &lt;code&gt;channel&lt;/code&gt; 부분인데요, &lt;code&gt;id&lt;/code&gt; 함수를 써서 인코딩된 문자열이 바로 디코딩을 위해 전송된다는 것을 표현했습니다.&lt;/p&gt;

&lt;p&gt;위 코드 중에서 &lt;code&gt;int2bin&lt;/code&gt; 과 &lt;code&gt;chop8&lt;/code&gt; 은 헤드에 특정 연산을 수행하고, &lt;code&gt;tail&lt;/code&gt; 에 나머지 연산을 수행 한 결과를 다시 재귀적으로 호출하는 패턴을 가지고 있는데요, &lt;code&gt;unfold&lt;/code&gt; 함수로 추상화 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;쉽게 말해서 &lt;code&gt;fold&lt;/code&gt; 가 리스트를 &lt;em&gt;접어 (folding)&lt;/em&gt; 원소 하나로 만든다면, &lt;code&gt;unfold&lt;/code&gt; 는 리스트를 더 한단계 펼친다고 볼 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;unfold p h t x 
  | p x = []
  | otherwise = h x : unfold p h t (t x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리하면 구현을&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Bit = Int
int2bin :: Int -&amp;gt; [Bit]
int2bin = unfold (== 0) (`mod` 2) (`div` 2)

chop8 :: [Bit] -&amp;gt; [[Bit]]
chop8 = unfold null (take 8) (drop 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 과 &lt;code&gt;iterate&lt;/code&gt; 도 구현할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;map2 f = unfold null (f . head) tail

iterate&#39; f = unfold (const False) id f -- const False is pred. always return False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;const False&lt;/code&gt; 는 항상 &lt;code&gt;False&lt;/code&gt; 만 돌려주는 &lt;em&gt;predicate&lt;/em&gt; 라 보시면 됩니다.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;strong&gt;DelftX FP 101x&lt;/strong&gt; in &lt;em&gt;edx&lt;/em&gt;&lt;br /&gt;
(2) &lt;a href=&#34;https://sadakurapati.wordpress.com&#34;&gt;https://sadakurapati.wordpress.com&lt;/a&gt;&lt;br /&gt;
(3) &lt;em&gt;Programming in Haskell, Chapter 6, 7&lt;/em&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://www.pling.org.uk/cs/fun.html&#34;&gt;http://www.pling.org.uk/cs/fun.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>하스켈로 배우는 함수형 언어 4</title>
      <link>https://1ambda.github.io/haskell/intro-to-haskell-4/</link>
      <pubDate>Sat, 25 Jun 2016 01:21:45 +0900</pubDate>
      
      <guid>https://1ambda.github.io/haskell/intro-to-haskell-4/</guid>
      <description>

&lt;p&gt;이번시간엔 모나드를 배웁니다. &lt;del&gt;네. 올것이 왔습니다.&lt;/del&gt; 간단한 파서를 구현하는 것 부터 시작해 보겠습니다.&lt;/p&gt;

&lt;h3 id=&#34;what-is-a-parser&#34;&gt;What is a Parser&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Parser (파서)&lt;/strong&gt; 란 텍스트 조각을 분석하여 &lt;em&gt;syntaxtic structure&lt;/em&gt; 를 만들어 내는 프로그램(코드)를 말합니다.&lt;/p&gt;

&lt;p&gt;많은 프로그램들이 자신만의 파서를 가지고 있습니다. &lt;em&gt;GHC&lt;/em&gt; 는 &lt;em&gt;haskell&lt;/em&gt; , &lt;em&gt;UNIX&lt;/em&gt; 는 &lt;em&gt;shell script&lt;/em&gt;, &lt;em&gt;explorer&lt;/em&gt; 는 &lt;em&gt;HTML&lt;/em&gt; 분석합니다.&lt;/p&gt;

&lt;h3 id=&#34;the-parser-type&#34;&gt;The Parser Type&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Parser = String -&amp;gt; Tree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하스켈 같은 함수형 언어에서 파서는 함수라 볼 수 있습니다. 문자열을 받아서 &lt;em&gt;Tree (트리)&lt;/em&gt; 를 만들어 주는 함수처럼요.&lt;/p&gt;

&lt;p&gt;때때로 입력된 문자열이 이상하다면 파서가 제대로 동작하지 않을수도 있습니다. 그럴때 분석되지 않은 문자열을 돌려주려면 이런 형태여야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Parser = String -&amp;gt; (Tree, String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떤 문자열들은 여러가지로 해석될 수도 있겠지요. 그럼 리스트를 돌려줘야겠네요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Parser = String -&amp;gt; [(Tree, String)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;꼭 파서가 트리를 만들 필요는 없지 않을까요? 문자열이 &lt;code&gt;1 + 2&lt;/code&gt; 라면 이 값을 더한 &lt;code&gt;3&lt;/code&gt; 을 돌려줄 수도 있을겁니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Parser a = String -&amp;gt; [(a, String)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이번 강의에서는 복잡한 파서를 구현하기 보다 파서가 무슨일을 하는지에 집중할 것이므로 파서의 타입을 심플하게 가져가겠습니다. 파서가 문자열을 분석하는데 실패하면 &lt;code&gt;[]&lt;/code&gt;  성공하면 &lt;em&gt;singleton list&lt;/em&gt; 를 돌려주겠습니다.&lt;/p&gt;

&lt;h3 id=&#34;basic-parsers&#34;&gt;Basic Parsers&lt;/h3&gt;

&lt;p&gt;먼저 문자열에서 첫 번째 원소를 소비하고, 나머지를 돌려주는 간단한 &lt;code&gt;item&lt;/code&gt; 파서를 만들어 봅시다. 이 파서는 빈 문자열에 대해서는 &lt;code&gt;[]&lt;/code&gt; 를 돌려줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module Lecture7 where

type Parser a = String -&amp;gt; [(a, String)]

item :: Parser Char
item = \xs -&amp;gt; case xs of
               [] -&amp;gt; []
               (x:xs) -&amp;gt; [(x, xs)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실행하면 이런 결과를 얻습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; item &amp;quot;hello world&amp;quot;
-- [(&#39;h&#39;,&amp;quot;ello world&amp;quot;)]

&amp;gt; item &amp;quot;&amp;quot;
-- []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;항상 &lt;code&gt;[]&lt;/code&gt; 만 돌려주는 &lt;code&gt;failure&lt;/code&gt; 파서와 &lt;code&gt;a -&amp;gt; Parser a&lt;/code&gt; 타입의 &lt;code&gt;return&lt;/code&gt; 도 만들어 봅시다. 하나는 항상 실패하고, 다른 하나는 항상 성공하는 파서입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;failure :: Parser a
failure = \xs -&amp;gt; []

return :: a -&amp;gt; Parser a
return v = \xs -&amp;gt; [(v, xs)]

&amp;gt; failure &amp;quot;hello world!&amp;quot;
-- []

&amp;gt; (return &amp;quot;hello&amp;quot;) &amp;quot; world&amp;quot;
-- [(&amp;quot;hello&amp;quot;,&amp;quot; world&amp;quot;)]

&amp;gt; (return &amp;quot;hello&amp;quot;) &amp;quot;&amp;quot;
-- [(&amp;quot;hello&amp;quot;,&amp;quot;&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 두 개의 파서를 붙이는 함수 &lt;code&gt;(+++)&lt;/code&gt; 를 만들어 봅시다. &lt;code&gt;p +++ q&lt;/code&gt; 에 대해 파서 &lt;code&gt;p&lt;/code&gt; 가 성공하면 &lt;code&gt;p&lt;/code&gt; 의 리턴값을, &lt;code&gt;p&lt;/code&gt; 가 실패하면 &lt;code&gt;q&lt;/code&gt; 가 처리하게 합시다. 위에서 항상 성공하는 파서 &lt;code&gt;return v&lt;/code&gt; 와 항상 실패하는 파서 &lt;code&gt;failure&lt;/code&gt; 를 여기다 붙이며 어떻게 될지도 한번 생각해 보는것도 좋습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(+++) :: Parser a -&amp;gt; Parser a -&amp;gt; Parser a
p +++ q = \xs -&amp;gt; case p xs of
                  [] -&amp;gt; parse q xs
                  [(y, ys)] -&amp;gt; [(y, ys)]
                  
parse :: Parser a -&amp;gt; String -&amp;gt; [(a, String)]
parse p xs = p xs  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;parse&lt;/code&gt; 는 그냥 &lt;em&gt;readable&lt;/em&gt; 한 코드를 만들기 위해 사용했다고 보면 됩니다. 파서와 텍스트를 받아서 그 적용한 결과를 돌려줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; parse (return &#39;1&#39;) &amp;quot;234&amp;quot;
-- [(&#39;1&#39;,&amp;quot;234&amp;quot;)]

&amp;gt; parse failure &amp;quot;abcd&amp;quot;
-- []

&amp;gt; parse (failure +++ (return &#39;1&#39;)) &amp;quot;abcd&amp;quot;
-- [(&#39;1&#39;,&amp;quot;abcd&amp;quot;)]

&amp;gt; parse (item +++ return &#39;d&#39;) &amp;quot;abc&amp;quot;
-- [(&#39;a&#39;, &amp;quot;bc&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;monad&#34;&gt;Monad&lt;/h3&gt;

&lt;p&gt;여기서 잠깐 생각해 볼 거리가 있습니다. &amp;ldquo;&lt;em&gt;parser&lt;/em&gt; 가 대체 무슨일을 하고 있는가?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;파서의 타입을 잘 보면 원본 타입 &lt;code&gt;String&lt;/code&gt; 을 받아, 여기서 부가적인 작업을 해서 &lt;code&gt;a&lt;/code&gt; 타입을 만들고, 다시 본래 타입인 &lt;code&gt;String&lt;/code&gt; 더해 튜플로 만들어 돌려줍니다. 다시 말해 파서는 &lt;em&gt;한 타입을 받아 부가적인 정보를 만들어 본래 타입에 붙여주는 함수&lt;/em&gt; 라 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;파서의 연결을 도와주는 함수는 &lt;code&gt;(+++)&lt;/code&gt; 무엇일까요? *부가적인 정보를 붙여주는 파서 를 &lt;strong&gt;합성&lt;/strong&gt;* 해 주는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;지금 &lt;code&gt;(+++)&lt;/code&gt; 의 규칙은 &lt;code&gt;p&lt;/code&gt; 가 실패하면 &lt;code&gt;q&lt;/code&gt; 를 적용하지만, 파서 &lt;code&gt;t, u, v&lt;/code&gt; 를 받아 모두 적용한 뒤 결과를 돌려주는 연산자도 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(+++)&lt;/code&gt; 자체는 하나의 규칙을 의미하지만 자세히 보면 이외에도 다양한 규칙을 가진 합성 함수를 만들 수 있다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;부가적인 정보를 만들어 내는 함수와(파서), 이 파서간의 합성이 아주 중요한 키 포인트입니다. 그리고 이 파서가 바로 &lt;em&gt;monad&lt;/em&gt; 입니다. &lt;del&gt;두둥&lt;/del&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The parser type is a &lt;strong&gt;monad&lt;/strong&gt;, a mathematical structure that has proved useful for modeling many different kinds of computations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;sequencing&#34;&gt;Sequencing&lt;/h3&gt;

&lt;p&gt;위에서는 두개의 파서를 엮어 하나로 만들긴 했지만 둘 중에 하나만 사용했죠. 둘 다 사용하진 않았습니다. 그럼 둘 이상의 파서를 엮어 하나의 파서를 만들려면 어떻게 해야할까요? 일단 생각해 볼 수 있는건 타입이 좀 다릅니다.&lt;/p&gt;

&lt;p&gt;서로 다른 두개의 파서 &lt;code&gt;Parser a&lt;/code&gt; 와 &lt;code&gt;Parser b&lt;/code&gt; 를 고려해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Parser a = String -&amp;gt; [(a, String)]

Parser a
-- String -&amp;gt; [(a, String)]

Parser b
-- String -&amp;gt; [(b, String)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Parser a&lt;/code&gt; 의 출력은 &lt;code&gt;[(a, String)]&lt;/code&gt;, 이기 때문에 다른 파서 &lt;code&gt;Parser b&lt;/code&gt; 의 입력 &lt;code&gt;String&lt;/code&gt; 이 될 수 없습니다.&lt;/p&gt;

&lt;p&gt;그리고 여기서 한 가지 더 중요한 사실은, &lt;code&gt;Parser a&lt;/code&gt; 가 &lt;code&gt;String&lt;/code&gt; 을 이용해 만든 타입 &lt;code&gt;a&lt;/code&gt; 의 부가정보를 &lt;code&gt;Parser b&lt;/code&gt; 에 손실 없이 넘겨줘야 한다는 사실입니다. 그래야만 파서를 조합한 의미가 있지요.&lt;/p&gt;

&lt;p&gt;정리하자면 &lt;code&gt;Parser a&lt;/code&gt; 를 받아 &lt;code&gt;Parser b&lt;/code&gt; 를 돌려주는 &lt;em&gt;파서 조합함수&lt;/em&gt; 를 만들 것인데,  부가정보 &lt;code&gt;a&lt;/code&gt; 의 보존을 위해 이 함수 내부에서 &lt;code&gt;a -&amp;gt; Parser b&lt;/code&gt; 타입의 중간 함수가 필요합니다. &lt;strong&gt;이 중간 함수가 어디에서 어떤 일을 할지가 구현해야 할 부분이자, 가장 중요한 부분&lt;/strong&gt;입니다. 파서 종류에 따라 원본 데이터 (여기서는 &lt;code&gt;String&lt;/code&gt;) 을 조작하는 방법이 다르기 때문입니다. 거꾸로 말하면 &lt;em&gt;다양한 종류의 파서가 있다는 말&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;p&gt;함수의 이름은 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 라 짓겠습니다. &lt;em&gt;bind&lt;/em&gt; 라 읽습니다. 타입은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Parser a = String -&amp;gt; [(a, String)]

parse :: Parser a -&amp;gt; String -&amp;gt; [(a, String)]
parse p xs = p xs

(&amp;gt;&amp;gt;=) :: Parser a -&amp;gt; (a -&amp;gt; Parser b) -&amp;gt; Parser b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;구현은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;p &amp;gt;&amp;gt;= q = \xs -&amp;gt; case p xs of
                  [] -&amp;gt; []
                  (y, ys) -&amp;gt; parse (q y) ys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;즉 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 는 &lt;code&gt;Parser a&lt;/code&gt; 의 처리 결과가 &lt;code&gt;[]&lt;/code&gt; 이면 &lt;code&gt;[]&lt;/code&gt; 을 돌려줍니다. 올바르게 처리되었을 경우에는 &lt;code&gt;Parser a&lt;/code&gt; 의 결과로 얻어진 부가정보 &lt;code&gt;a&lt;/code&gt; 타입에 대해 &lt;code&gt;a -&amp;gt; Parser b&lt;/code&gt; 타입의 함수인 &lt;code&gt;y&lt;/code&gt; 에게 넘겨 &lt;code&gt;Parser b&lt;/code&gt; 를 받고 결과적으로는 &lt;code&gt;\xs -&amp;gt; parse k ys&lt;/code&gt; 를 돌려줍니다. (&lt;code&gt;k :: parser b&lt;/code&gt;) 그런데, 여기서 &lt;code&gt;parse k ys&lt;/code&gt; 의 결과가 &lt;code&gt;[(b, String)]&lt;/code&gt; 이기 때문에 &lt;code&gt;\xs -&amp;gt; parse k ys&lt;/code&gt; 는 &lt;code&gt;Parser b&lt;/code&gt; 라 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;최종적으로는 &lt;code&gt;Parser a&lt;/code&gt; 를 이용해 &lt;code&gt;Parser b&lt;/code&gt; 를 만들어 냈습니다.&lt;/p&gt;

&lt;p&gt;예제를 한번 보시죠. &lt;code&gt;Parser Char&lt;/code&gt; 을 이용해 &lt;code&gt;Parser (Char, Char)&lt;/code&gt; 을 만들어 볼 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;return :: a -&amp;gt; Parser a
return v = \xs -&amp;gt; [(v, xs)]

(&amp;gt;&amp;gt;=) :: Parser a -&amp;gt; (a -&amp;gt; Parser b) -&amp;gt; Parser b
p &amp;gt;&amp;gt;= q = \xs -&amp;gt; case p xs of
                   [] -&amp;gt; []
                   (y, ys) -&amp;gt; parse (q, y) ys
      
-- consume only one Char
parseTwice :: Parser (Char, Char)
parseTwice = item &amp;gt;&amp;gt;= \x -&amp;gt; return (x, x)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;parseTwice &amp;quot;5BEAF&amp;quot;
-- [((5, 5), &amp;quot;BEAF&amp;quot;)] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;item&lt;/code&gt; 과 &lt;code&gt;return (x, x)&lt;/code&gt; 두개의 파서를 조합해서 &lt;code&gt;parseTwice&lt;/code&gt; 라는 새로운 파서를 만들었습니다. 조금 더 붙여볼까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ignore2 :: Parser (Char, Char)
ignore2 = item &amp;gt;&amp;gt;= \x -&amp;gt; item &amp;gt;&amp;gt;= \y -&amp;gt; item &amp;gt;&amp;gt;= \z -&amp;gt; return (x, z)

&amp;gt; ignore2 &amp;quot;2A371&amp;quot;
-- [((&#39;2&#39;,&#39;3&#39;),&amp;quot;71&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;do&#34;&gt;Do&lt;/h3&gt;

&lt;p&gt;위에서 보았듯이 같은 원본 타입 &lt;code&gt;String&lt;/code&gt; 을 가지는 같은 종류의 파서(모나드)는 계속 연결할 수 있습니다. &lt;code&gt;p1, ..., pn&lt;/code&gt; 을 파서라 하고 &lt;code&gt;v1, ..., vn&lt;/code&gt; 을 파서가 만드는 부가정보라 할 때 다음과 같이 일반화 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;p1 &amp;gt;&amp;gt;= \v1 -&amp;gt;
p2 &amp;gt;&amp;gt;= \v2 -&amp;gt;
p3 &amp;gt;&amp;gt;= \v3 -&amp;gt;
...
pn &amp;gt;&amp;gt;= \vn -&amp;gt;
return (f v1 v2 ... vn)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하스켈에선 조금 더 편한 문법을 지원하는데요 바로 &lt;code&gt;do&lt;/code&gt; 구문입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;do v1 &amp;lt;- p1
   v2 &amp;lt;- p2
   ...
   vn &amp;lt;- pn
   return (f v1 v2 ... vn)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;monadic-axioms&#34;&gt;Monadic Axioms&lt;/h3&gt;

&lt;p&gt;이 때 &lt;code&gt;do&lt;/code&gt; 구문을 활용하는 파서(모나드) &lt;code&gt;pn&lt;/code&gt; 에 대해서는 미리 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 과 &lt;code&gt;return&lt;/code&gt; 이 구현되어 있어야 합니다. 우리도 위에서 두 가지 함수를 사용했습니다.&lt;/p&gt;

&lt;p&gt;하스켈에서는 모나드 클래스가 따로 있습니다. 그리고 모든 모나드 클래스의 인스턴스는 최소한 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 와 &lt;code&gt;return&lt;/code&gt; 을 구현해야 합니다. 우리가 위에서 구현했던 파서를 잠깐 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Parser a = String -&amp;gt; [(a, String)]

return :: a -&amp;gt; Parser a
return v = \xs -&amp;gt; [(v, xs)]

(&amp;gt;&amp;gt;=) :: Parser a -&amp;gt; (a -&amp;gt; Parser b) -&amp;gt; Parser b
p &amp;gt;&amp;gt;= q = \xs -&amp;gt; case parse p xs of
                  [] -&amp;gt; []
                  [(y, ys)] -&amp;gt; parse (q y) ys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;return&lt;/code&gt; 은 &lt;code&gt;a&lt;/code&gt; 를 받아 파서를 돌려줍니다. &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 는 파서(모나드)를 결합하지요.&lt;/p&gt;

&lt;p&gt;아까 다양한 파서(모나드)가 있을 수 있다고 말했던 것 기억 나시죠? 많은 종류의 모나드에 대해  최소한 &lt;code&gt;return&lt;/code&gt; 과 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 를 구현해야 하는데, 이때 지켜져야 할 &lt;em&gt;axioms (공리)&lt;/em&gt; 가 있습니다.&lt;/p&gt;

&lt;p&gt;(1) &lt;code&gt;m &amp;gt;&amp;gt;= return&lt;/code&gt; == &lt;code&gt;m&lt;/code&gt; (&lt;em&gt;right unit&lt;/em&gt;)&lt;br /&gt;
(2) &lt;code&gt;return x &amp;gt;&amp;gt;= f&lt;/code&gt; == &lt;code&gt;f x&lt;/code&gt; (&lt;em&gt;left unit&lt;/em&gt;)&lt;br /&gt;
(3) &lt;code&gt;(m &amp;gt;&amp;gt;= f) &amp;gt;&amp;gt;= g&lt;/code&gt; == &lt;code&gt;m &amp;gt;&amp;gt;= (\x -&amp;gt; f x &amp;gt;&amp;gt;= g)&lt;/code&gt; (&lt;em&gt;associativity&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;so-why-monad&#34;&gt;So, Why Monad?&lt;/h3&gt;

&lt;p&gt;근데, 이런 복잡한 모나드가 왜 중요한걸까요? 바로 &lt;em&gt;부가정보&lt;/em&gt; 를 만들면서 본래의 타입을 유지하기 때문입니다.&lt;/p&gt;

&lt;p&gt;본래 순수 함수형 프로그래밍에선 콘솔 출력 같은 &lt;em&gt;side-effect&lt;/em&gt; 를 만들 수 없습니다. 그러나 모나드를 이용하면 &lt;strong&gt;부가정보 (= &lt;em&gt;side-effect&lt;/em&gt;)&lt;/strong&gt; 와 &lt;strong&gt;연산 부분 (&lt;em&gt;purely functional&lt;/em&gt;)&lt;/strong&gt; 를 분리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;실제 하스켈에서도 &lt;em&gt;IO Monad&lt;/em&gt; 를 통해 입출력을 할 수 있죠.&lt;/p&gt;

&lt;h3 id=&#34;monad-again&#34;&gt;Monad, Again&lt;/h3&gt;

&lt;p&gt;그러면 실제로 하스켈에서 제공하는 모나드를 클래스를 사용해 봅시다. 코드를 조금 변경해야합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module Lecture7 where

import Control.Monad

-- ref: http://www.cs.nott.ac.uk/~gmh/Parsing.lhs
newtype Parser a = P (String -&amp;gt; [(a, String)])

instance Monad Parser where
  return v = P $ \inp -&amp;gt; [(v, inp)]
  p &amp;gt;&amp;gt;= f = P $ \inp -&amp;gt; case parse p inp of
                         [] -&amp;gt; []
                         [(v, out)] -&amp;gt; parse (f v) out

item :: Parser Char
item = P $ \inp -&amp;gt; case inp of
                    [] -&amp;gt; []
                    (x:xs) -&amp;gt; [(x, xs)]

parse                         :: Parser a -&amp;gt; String -&amp;gt; [(a,String)]
parse (P p) inp               =  p inp

ignore2 :: Parser (Char, Char)
ignore2 = do x &amp;lt;- item
             item
             z &amp;lt;- item
             return (x, z)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실제 돌려보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; parse ignore2 &amp;quot;7A3BCEF&amp;quot;
-- [((&#39;7&#39;,&#39;3&#39;),&amp;quot;BCEF&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;monadplus&#34;&gt;MonadPlus&lt;/h3&gt;

&lt;p&gt;아까 작성했었던 파서 &lt;code&gt;failure&lt;/code&gt;, &lt;code&gt;(+++)&lt;/code&gt; 기억 나시나요? &lt;code&gt;failure&lt;/code&gt; 는 항상 실패하는 파서를, &lt;code&gt;(+++)&lt;/code&gt; 는 첫번째 파서와 두번째 파서를 붙여 둘 중 성공하는 하나의 파서만 선택하는 합성 파서입니다.&lt;/p&gt;

&lt;p&gt;하스켈에선 이런 두 가지 특징을 구현한 모나드를 &lt;code&gt;MonadPlus&lt;/code&gt; 라 부릅니다. 다시 말해 &lt;code&gt;MonadPlus&lt;/code&gt; 에는 기본적인 &lt;code&gt;return&lt;/code&gt; 이나 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 이외에도 위 두 가지가 더 구현되어 있다는 말이죠.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MonadPlus&lt;/code&gt; 에서는 &lt;code&gt;failure&lt;/code&gt; 대신 &lt;code&gt;mzero&lt;/code&gt; 를 &lt;code&gt;(+++)&lt;/code&gt; 대신 &lt;code&gt;mplus&lt;/code&gt; 란 이름을 사용합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance MonadPlus Parser where
  mzero = P $ \_ -&amp;gt; []
  p `mplus` q = P $ \inp -&amp;gt; case parse p inp of
                             [] -&amp;gt; parse q inp
                             [(v, out)] -&amp;gt; [(v, out)]

failure :: Parser Char 
failure = mzero

(+++) :: Parser a -&amp;gt; Parser a -&amp;gt; Parser a
p +++ q = p `mplus` q
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; parse (item +++ return &#39;d&#39;) &amp;quot;abc&amp;quot;
-- [(&#39;a&#39;,&amp;quot;bc&amp;quot;)]

&amp;gt; parse (item +++ return &#39;d&#39;) &amp;quot;&amp;quot;
-- [(&#39;d&#39;,&amp;quot;&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;derived-primitives&#34;&gt;Derived Primitives&lt;/h3&gt;

&lt;p&gt;이제 파서를 엮어서 다양한 파서를 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Data.Char

sat :: (Char -&amp;gt; Bool) -&amp;gt; Parser Char
sat p = do x &amp;lt;- item
           if p x then return x else failure

digit :: Parser Char
digit = sat isDigit

lower :: Parser Char
lower = sat isLower

upper :: Parser Char
upper = sat isUpper 

letter :: Parser Char
letter = sat isAlpha

alphanum :: Parser Char
alphanum = sat isAlphaNum

char :: Char -&amp;gt; Parser Char
char x = sat (== x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;char&lt;/code&gt; 을 이용하면 지정된 문자열이 있는지 검사하는 파서 &lt;code&gt;string&lt;/code&gt; 을 만들 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;string :: String -&amp;gt; Parser String
string [] = return []
string (x:xs) = do char x
                   string xs
                   return (x:xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;string&lt;/code&gt; 은 재귀를 이용해 작성했는데, 입력된 문자열이 모두 존재할 경우에만 &lt;code&gt;return&lt;/code&gt; 하고 아니면 &lt;code&gt;[]&lt;/code&gt; 를 돌려줍니다. (&lt;code&gt;do&lt;/code&gt; 매크로는 중간에 &lt;code&gt;[]&lt;/code&gt; 가 나오면 &lt;code&gt;[]&lt;/code&gt; 를 바로 리턴합니다.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; parse (string &amp;quot;google&amp;quot;) &amp;quot;naver google yahoo&amp;quot;
-- []

&amp;gt; parse (string &amp;quot;google&amp;quot;) &amp;quot;google yahoo&amp;quot;
-- [(&amp;quot;google&amp;quot;,&amp;quot; yahoo&amp;quot;)]

&amp;gt; parse (string &amp;quot;google&amp;quot;) &amp;quot;goo yahoo&amp;quot;
-- []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러면, &lt;code&gt;digit&lt;/code&gt; 나 &lt;code&gt;letter&lt;/code&gt; 같은 파서에 대해 동일한 파서를 여러번 사용하려면 어떻게 해야 할까요? &lt;code&gt;string&lt;/code&gt; 처럼 재귀를 이용해 매번 파서를 만들어야 할까요?&lt;/p&gt;

&lt;p&gt;그렇지 않습니다. &lt;em&gt;mutual recursion&lt;/em&gt; 을 이용해서 파서를 받아 여러번 적용해 주는 &lt;code&gt;many&lt;/code&gt; 란 파서를 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;many :: Parser a -&amp;gt; Parser [a]
many p = many1 +++ return []

many1 :: parser a -&amp;gt; Parser [a]
many1 p = do x &amp;lt;- p
		     xs &amp;lt;- many p
             return (x:xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;many&lt;/code&gt; 는 &lt;code&gt;p&lt;/code&gt; 을 0번 이상, &lt;code&gt;many1&lt;/code&gt; 은 적어도 1번 이상 &lt;code&gt;p&lt;/code&gt; 를 적용합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;many&lt;/code&gt; 를 활용하면 변수의 이름도 파싱할 수 있습니다. 변수의 이름은 첫 글자가 소문자로, 나머지는 알파벳 혹은 숫자로 구성되어 있다고 하면 이를 위한 파서 &lt;code&gt;ident&lt;/code&gt; 는&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ident :: Parser String
ident = do x &amp;lt;- lower
           xs &amp;lt;- many alphanum
           return (x:xs)

&amp;gt; parse ident &amp;quot;left = 3&amp;quot;
-- [(&amp;quot;left&amp;quot;,&amp;quot; = 3&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 뭔가 파서가 좀 쓸만해 보이죠? 자연수를 파싱하는 &lt;code&gt;nat&lt;/code&gt; 와 스페이스를 파싱하는 &lt;code&gt;space&lt;/code&gt; 를 만들어 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;nat :: Parser Int
nat = do xs &amp;lt;- many1 digit
         return (read xs)
      
space :: Parser ()
space = do many (sat isSpace)
           return ()
        
&amp;gt; parse nat &amp;quot;123 abc&amp;quot;
-- [(123,&amp;quot; abc&amp;quot;)]

&amp;gt; parse space &amp;quot;   abc&amp;quot;
-- [((),&amp;quot;abc&amp;quot;)]        
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;코드를 분석하는 파서를 만들때 스페이스를 주의해야 합니다. 예를 들어 &lt;code&gt;1+2&lt;/code&gt; 와 &lt;code&gt;1 + 2&lt;/code&gt; 는 같은 코드입니다.&lt;/p&gt;

&lt;p&gt;파서를 받아 앞 뒤로 붙은 스페이스를 제거하는 기능을 덧붙인 파서를 돌려주는 &lt;code&gt;token&lt;/code&gt; 이란 함수를 만들어 봅시다. 그리고 나면 &lt;code&gt;token&lt;/code&gt; 을 활용해 &lt;code&gt;identifier&lt;/code&gt;, &lt;code&gt;natural&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt; 을 만들겁니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;token :: Parser a -&amp;gt; Parser a
token p = do space
             v &amp;lt;- p
             space
             return v
             
identifier :: Parser String
identifier = token ident

natural :: Parser Int
natural = token nat

symbol :: String -&amp;gt; Parser String
symbol xs = token (string xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 이걸 엮어서 숫자 리스트를 분석하는 파서를 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;nlist :: Parser [Int]
nlist = do symbol &amp;quot;[&amp;quot;
           n &amp;lt;- natural
           ns &amp;lt;- many (do symbol &amp;quot;,&amp;quot;
                          natural)
           symbol &amp;quot;]&amp;quot;
           return (n:ns)


&amp;gt; parse nlist &amp;quot;[1, 2, 3]&amp;quot;
-- [([1,2,3],&amp;quot;&amp;quot;)]

&amp;gt; parse nlist &amp;quot;[1, 2]&amp;quot;
-- [([1,2],&amp;quot;&amp;quot;)]

&amp;gt; parse nlist &amp;quot;[1, 2&amp;quot;
-- []

&amp;gt; parse nlist &amp;quot;[1 2&amp;quot;
-- []

&amp;gt; parse nlist &amp;quot;[1,&amp;quot;
-- []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;del&gt;모나드의 세계란 참으로 놀랍죠?&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&#34;arithmetic-expressions&#34;&gt;Arithmetic Expressions&lt;/h3&gt;

&lt;p&gt;이제 단순한 텍스트가 아니라, 코드를 분석해 보죠. 우선 작은 수식을 분석하는 파서를 작성해 봅시다. 우리가 작성할 파서는 정수에 대한 &lt;code&gt;*&lt;/code&gt; 과 &lt;code&gt;+&lt;/code&gt; 만 처리할 수 있습니다. 간단히 문법을 만들어 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;expr   ::= expr + expr | term
term   ::= term * term | factor
factor ::= (expr) | nat
nat    ::= 0 | 1 | 2 | ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;처음보면 난해할 수 있습니다. 이 그림과 비교해가며 보세요. 완벽히 일치하진 않지만 대략적인 설명을 해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.csee.umbc.edu/courses/331/fall11/hw/hw2/parsetree.gif&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://www.csee.umbc.edu&#34;&gt;http://www.csee.umbc.edu&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;그런데, 실제로 &lt;code&gt;2 + 3 + 4&lt;/code&gt; 에 적용해보면, &lt;code&gt;(2 + 3) + 4&lt;/code&gt; 과 &lt;code&gt;2 + (3 + 4)&lt;/code&gt; 두 가지 방법으로 해석될 수 있습니다. 따라서 모호함을 제거하기 위해&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;expr   ::= term + expr | term
term   ::= factor * term | factor
factor ::= (expr) | nat
nat    ::= 0 | 1 | 2 | ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;2 + 3 + 4&lt;/code&gt; 는 확실히 &lt;code&gt;2 + (3 + 4)&lt;/code&gt; 입니다. 괴상한 문법을 하스켈로 옮기기 위해 조금  더 다듬어 보도록 하지요.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;term + expr | term&lt;/code&gt; 은 사실 &lt;code&gt;term + (expr | e)&lt;/code&gt; 과 동일합니다. (&lt;code&gt;e&lt;/code&gt; 는 &lt;strong&gt;비었음&lt;/strong&gt; 을 의미) &lt;code&gt;factor * term | factor&lt;/code&gt; 도 &lt;code&gt;factor + (term | e)&lt;/code&gt; 구요. 따라서&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;expr   ::= term + (expr | e)
term   ::= factor + (term | e)
factor ::= (expr) | nat
nat    ::= 0 | 1 | 2 | ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 하스켈 코드로 옮길겁니다. 우리는 트리를 만드는 대신 바로바로 계산할 겁니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;expr :: Parser Int
expr = do t &amp;lt;- term
          do symbol &amp;quot;+&amp;quot;
             e &amp;lt;- expr
             return (t + e)
           +++ return t

term :: Parser Int
term = do f &amp;lt;- factor
          do symbol &amp;quot;*&amp;quot;
             t &amp;lt;- term
             return (t * f)
           +++ return f

factor :: Parser Int
factor = do symbol &amp;quot;(&amp;quot;
            e &amp;lt;- expr
            symbol &amp;quot;)&amp;quot;
            return e
          +++ natural          
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;return t&lt;/code&gt; 도 하나의 파서고, &lt;code&gt;+++&lt;/code&gt; 로 둘 중 올바르게 작동하는 파서만 택함으로써 문법에서의 &lt;code&gt;|&lt;/code&gt; 를 구현했습니다.&lt;/p&gt;

&lt;p&gt;이제 파싱된 결과를 해석하는 &lt;code&gt;eval&lt;/code&gt; 함수를 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;eval :: String -&amp;gt; Int
eval xs = case parse expr xs of
           [(n, [])] -&amp;gt; n
           [(_, out)] -&amp;gt; error (&amp;quot;ununsed input: &amp;quot; ++ out)
           [] -&amp;gt; error (&amp;quot;invalid input: &amp;quot; ++ xs)


&amp;gt; eval &amp;quot;2 * 3 + 4&amp;quot;
-- 10

&amp;gt; eval &amp;quot;2 * (3 + 4)&amp;quot;
-- 14

&amp;gt; eval &amp;quot;2 * 3 +&amp;quot;
-- *** Exception: ununsed input: +

&amp;gt; eval &amp;quot;2 * 3 - 4&amp;quot;
-- *** Exception: ununsed input: - 4

&amp;gt; eval &amp;quot;-4&amp;quot;
-- *** Exception: invalid input: -4
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;programming-with-effects&#34;&gt;Programming With Effects&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cs.nott.ac.uk/~gmh/monads&#34;&gt;Programming With Effects&lt;/a&gt; 는 &lt;em&gt;Programming in Haskell&lt;/em&gt; 의 저자인 &lt;strong&gt;Graham Hutton&lt;/strong&gt; 이 작성한 글입니다. 모나드에 대해 이보다 쉽고, 간결하게 설명한 글은 찾기 힘들죠.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Programming with Effects&lt;/em&gt; 를 참고하여 몇 가지 예제를 더 작성해 보면서 모나드에 더 익숙해져 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Expr = Val Int | Div Expr Expr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같은 &lt;code&gt;Expr&lt;/code&gt; 이 있다고 합시다. 평가하기 위해서 &lt;code&gt;eval&lt;/code&gt; 함수를 만들고 실행해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;eval :: Expr -&amp;gt; Int
eval (Val n) = n
eval (Div x y) = eval x `div` eval y

&amp;gt; eval (Val 3)
-- 3

&amp;gt; eval (Div (Val 3) (Val 4))
-- 0

&amp;gt; eval (Div (Val 8) (Val 4))
-- 2

&amp;gt; eval (Div (Val 8) (Val 0))
-- *** Exception: divide by zero
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;0&lt;/code&gt; 으로 나누니 에러가 발생합니다. &lt;code&gt;expr&lt;/code&gt; 이 &lt;code&gt;Val 0&lt;/code&gt; 인지 아닌지를 판별할 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;조금 더 고쳐보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Prelude hiding (Maybe, Just, Nothing)

data Expr = Val Int | Div Expr Expr
data Maybe a = Nothing | Just a

safediv :: Int -&amp;gt; Int -&amp;gt; Maybe Int
safediv n m = if m == 0 then Nothing else Just (n `div` m)

eval :: Expr -&amp;gt; Maybe Int
eval (Val n) = Just n
eval (Div x y) = case eval x of
                  Nothing -&amp;gt; Nothing
                  Just n -&amp;gt; case eval y of
                             Nothing -&amp;gt; Nothing
                             Just m -&amp;gt; safediv n m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;너무 복잡합니다. &lt;code&gt;eval&lt;/code&gt; 에서 &lt;code&gt;safediv&lt;/code&gt; 에 인자를 넘기는 부분을 추상화하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;seqn :: Maybe a -&amp;gt; Maybe b -&amp;gt; Maybe (a, b)
seqn _ Nothing = Nothing
seqn Nothing _ = Nothing
seqn (Just x) (Just y) = Just (x, y)

apply :: (a -&amp;gt; Maybe b) -&amp;gt; Maybe a -&amp;gt; Maybe b
apply f Nothing = Nothing
apply f (Just x) = f x

eval :: Expr -&amp;gt; Maybe Int
eval (Val n) = Just n
eval (Div x y) = apply f (eval x `seqn` eval y)
                 where f (n, m) = safediv n m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;조금 더 간편해졌습니다. 그런데 만약 인자가 3개인 연산자에 대해 평가 방법을 정의한다면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;eval (Op x y z) = 
  apply f (eval x `seqn` (eval y `seqn` eval z))
  where f (a, (b, c)) =                 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;괄호가 점점 중첩됩니다. 모든 것을 나중에 &lt;code&gt;seqn&lt;/code&gt; 로 모든 결과를 모아 &lt;code&gt;f&lt;/code&gt; 에서 처리하기 보다는 &lt;code&gt;Maybe a&lt;/code&gt; 를 받아 &lt;code&gt;a -&amp;gt; Maybe b&lt;/code&gt; 를 바로 적용해 &lt;code&gt;Maybe b&lt;/code&gt; 를 돌려주고, 이런식으로 순차적으로 처리하는 방식으로 바꿔봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(&amp;gt;&amp;gt;=) :: Maybe a -&amp;gt; (a -&amp;gt; Maybe b) -&amp;gt; Maybe b
m &amp;gt;&amp;gt;= f = case m of
           Nothing -&amp;gt; Nothing
           Just x -&amp;gt; f x

eval :: Expr -&amp;gt; Maybe Int
eval (Val x) = Just x
eval (Div x y) = eval x &amp;gt;&amp;gt;= \n -&amp;gt; 
                 eval y &amp;gt;&amp;gt;= \m -&amp;gt; 
                 safediv n m 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어디서 많이 보다싶은 식이죠? 바로 하스켈의 &lt;code&gt;do&lt;/code&gt; 와 비슷합니다.&lt;/p&gt;

&lt;p&gt;하스켈에서 &lt;code&gt;Eq&lt;/code&gt; 의 클래스의 정의는 이렇게 되어있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class Eq a where
  (==) :: a -&amp;gt; a -&amp;gt; Bool
  (/=) :: a -&amp;gt; a -&amp;gt; Bool
  
  x /= y = not (x == y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 말은 &lt;code&gt;Eq&lt;/code&gt; 클래스의 인스턴스가 되는 &lt;code&gt;a&lt;/code&gt; 타입은 무조건 &lt;code&gt;==&lt;/code&gt; 를 구현해야 한다는 뜻입니다. (&lt;code&gt;/=&lt;/code&gt; 는 이미 구현되어 있는거 보이시죠?)&lt;/p&gt;

&lt;p&gt;마찬가지로 타입 &lt;code&gt;m&lt;/code&gt; 으로 &lt;em&gt;parameterized&lt;/em&gt; 된 &lt;code&gt;Monad&lt;/code&gt; 클래스의 인스턴스 또한 다음의 두 함수를 구현해야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class Monad m where
  return :: a -&amp;gt; m a
  (&amp;gt;&amp;gt;=) :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예를 들어 &lt;code&gt;Maybe&lt;/code&gt; 같은 경우&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance Monad Maybe where
  return x = Just x
  
  Nothing &amp;gt;&amp;gt;= _ = Nothing
  (Just x) &amp;gt;&amp;gt;= f = f x
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;list-monad&#34;&gt;List Monad&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt; 모나드를 잘 보면 &lt;code&gt;Nothing&lt;/code&gt; 은 실패를, &lt;code&gt;Just x&lt;/code&gt; 는 성공을 나타내는 연산으로 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;리스트 모나드는 이런 개념을 좀 더 일반화한 것입니다. 복수번의 성공이 있을 수 있죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance Monad [] where
  return x = [x]
  xs &amp;gt;&amp;gt;= f = concat (map f xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이를 이용하면 &lt;code&gt;pairs&lt;/code&gt; 와 같은 함수를 만들수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;pairs :: [a] -&amp;gt; [b] -&amp;gt; [(a, b])
pairs xs ys = do x &amp;lt;- xs
                 y &amp;lt;- ys
                 return (x, y)
                 
&amp;gt; pairs [1, 2, 3] [4, 5, 6]
-- [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]                 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;list comprehension&lt;/em&gt; 구문과 비슷합니다. 실제로 &lt;code&gt;do&lt;/code&gt; 와 &lt;em&gt;list comprehension&lt;/em&gt; 모두 리스트의 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 를 이용합니다.&lt;/p&gt;

&lt;h3 id=&#34;state-monad&#34;&gt;State Monad&lt;/h3&gt;

&lt;p&gt;한 상태(State) 에서 다른 상태로 변환시켜주는 &lt;em&gt;state transformer&lt;/em&gt; 의 타입은 이렇게 정의할 수 있을 겁니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type ST = State -&amp;gt; State
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 상태가 변하면서 어떤 정보를 남겼을때의 타입을 이렇게 만들어 볼 수 있겠죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type ST a = State -&amp;gt; (a, State)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어디서 많이 본것 같죠? 맞습니다. 위에서 본 &lt;code&gt;Parser&lt;/code&gt; 입니다. &lt;code&gt;String -&amp;gt; (a, String)&lt;/code&gt; 이였으니까, &lt;code&gt;State&lt;/code&gt; 가 &lt;code&gt;String&lt;/code&gt; 이었던 거죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance Monad ST where
  return x = \s -&amp;gt; (x, s)
  
  st &amp;gt;&amp;gt;= f = \s -&amp;gt; let (x, s&#39;) = st s
                   in f x s&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;누차 언급했듯이 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 는 모나드(연산)간 연결입니다. &lt;code&gt;st&lt;/code&gt; 에 &lt;code&gt;s&lt;/code&gt; 를 넣은 결과를 &lt;code&gt;(x, s&#39;)&lt;/code&gt; 라 하면 다시 &lt;code&gt;f x&lt;/code&gt; 에 &lt;code&gt;s&lt;/code&gt; 를 넣어 연결할 수 있다는 뜻이지요.&lt;/p&gt;

&lt;p&gt;위에서는 &lt;code&gt;type&lt;/code&gt; 을 사용했지만 실제로 이 키워드를 사용하면 클래스의 인스턴스가 될 수 없습니다. &lt;code&gt;ST&lt;/code&gt; 를 &lt;em&gt;monadic type&lt;/em&gt; 클래스의 인스턴스로 만들려면 &lt;code&gt;data&lt;/code&gt; 나 &lt;code&gt;newtype&lt;/code&gt; 을 이용할 수 있습니다. &lt;code&gt;data&lt;/code&gt; 의 경우엔 &lt;em&gt;dummy constructor&lt;/em&gt; 가 필요합니다. 여기선 &lt;code&gt;S&lt;/code&gt; 가 되겠습니다. &lt;em&gt;dummy constructor&lt;/em&gt; 의 런타임 오버헤드를 피하려면 &lt;em&gt;newtype&lt;/em&gt; 을 이용하면 됩니다.&lt;/p&gt;

&lt;p&gt;그리고 이 예제에서는 &lt;em&gt;dummy constructor&lt;/em&gt; 를 제거하기 위해 &lt;code&gt;apply&lt;/code&gt; 함수를 만들어서 이용하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;State&lt;/code&gt; 는 정수로 표시할겁니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type State = Int
data ST a = S (State -&amp;gt; (a, State))

apply :: ST a -&amp;gt; State -&amp;gt; (a, State)
apply (S f) x = f x

instance Monad ST where
  return x = S (\s -&amp;gt; (x, s))
  st &amp;gt;&amp;gt;= f = S (\s -&amp;gt; let (x, s&#39;) = apply st s in apply (f x) s&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 예제에서 활용할 간단한 이진트리를 정의해 봅시다. 이진트리의 &lt;em&gt;leaf&lt;/em&gt; 는 &lt;code&gt;a&lt;/code&gt; 타입의 값을 가지고 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Tree = Leaf a | Node (Tree a) (Tree b)

-- example
tree :: Tree Char
tree = Node (Node (Leaf &#39;a&#39;) (Leaf &#39;b&#39;)) (Leaf &#39;c&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;em&gt;State&lt;/em&gt; 를 받아 &lt;code&gt;+1&lt;/code&gt; 을 더한 다음 &lt;em&gt;State&lt;/em&gt; 를 돌려주는 &lt;code&gt;fresh&lt;/code&gt; 를 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- data ST a = S (State -&amp;gt; (a, State))

fresh :: ST Int
fresh = S (\n -&amp;gt; (n, n + 1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;즉 &lt;code&gt;fresh&lt;/code&gt; 는 &lt;em&gt;State&lt;/em&gt; 를 &lt;code&gt;1&lt;/code&gt; 만큼 증가시키고 부가정보로 &lt;em&gt;current state&lt;/em&gt; &lt;code&gt;n&lt;/code&gt; 을 남깁니다. &lt;code&gt;fresh&lt;/code&gt; 를 이용하면 위에서 만든 이진트리를 순회하면서 번호를 붙일 수 있습니다. 부가정보로 남는 &lt;code&gt;n&lt;/code&gt; 을 &lt;code&gt;Leaf&lt;/code&gt; 에다가 붙이는 것이죠.&lt;/p&gt;

&lt;p&gt;다음 &lt;code&gt;fresh&lt;/code&gt; 의 입력은 이전 &lt;code&gt;fresh&lt;/code&gt; 의 아웃풋인 &lt;code&gt;n + 1&lt;/code&gt; 이기 때문에 서로 다른 두 노드가 같은 숫자를 가질 일은 없습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mlabel :: Tree a -&amp;gt; ST (Tree (a, Int))
mlabel (Leaf x) = do n &amp;lt;- fresh
                     return (Leaf (x, n))
mlabel (Node l r) = do l&#39; &amp;lt;- mlabel l
                       r&#39; &amp;lt;- mlabel r
                       return (Node l&#39; r&#39;)
                       
label  :: Tree a -&amp;gt; Tree (a,Int)
label t = fst (apply (mlabel t) 0)

&amp;gt; label tree
-- Node (Node (Leaf (&#39;a&#39;,0)) (Leaf (&#39;b&#39;,1))) (Leaf (&#39;c&#39;,2))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;io-monad&#34;&gt;IO Monad&lt;/h3&gt;

&lt;p&gt;하스켈에서 입출력은 IO 모나드를 이용합니다. 무슨말인고 하니, 다음과 같은 &lt;em&gt;axioms&lt;/em&gt; 를 구현한 &lt;strong&gt;IO 모나드&lt;/strong&gt; 에 대해&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;return  :: a -&amp;gt; IO a
(&amp;gt;&amp;gt;=)   :: IO a -&amp;gt; (a -&amp;gt; IO b) -&amp;gt; IO b
getChar :: IO Char
putChar :: Char -&amp;gt; IO ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음처럼 &lt;code&gt;do&lt;/code&gt; 구문을 이용해서 프로그램을 작성할 수 있다는 뜻입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;getLine :: IO String
getLine = do x &amp;lt;- getChar
             if x == &#39;\n&#39; then
               return []
             else
               do xs &amp;lt;- getLine
                  return (x:xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IO 모나드는 &lt;em&gt;State 모나드&lt;/em&gt; 라 볼 수 있습니다. &lt;code&gt;IO a&lt;/code&gt; 는 타입 &lt;code&gt;a&lt;/code&gt; 의 부가정보를 만들면서 &lt;em&gt;State&lt;/em&gt; 를 변화시키는 것으로요&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type World = ...
type IO a = World -&amp;gt; (a, World)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 입/출력이 수행되는 것은 &lt;em&gt;action&lt;/em&gt; 에 의해 &lt;code&gt;World&lt;/code&gt; 가 변경되는 것이라 볼 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;derived-primitives-1&#34;&gt;Derived Primitives&lt;/h3&gt;

&lt;p&gt;다양한 종류의 모나드에 대해 적용할 수 있는 함수를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;liftM&lt;/code&gt; 는 모나드에 대한 &lt;code&gt;map&lt;/code&gt; 을 &lt;code&gt;join&lt;/code&gt; 은 &lt;code&gt;concat&lt;/code&gt; 을, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 는 첫 번째 결과값을 다 버리고 두번째만 취하는 함수입니다. 마지막으로 &lt;code&gt;sequence&lt;/code&gt; 는 모나드 익스프레션 리스트를  하나의 모나드 익스프레션으로 바꾸고, 그 결과를 리스트로 돌려줍니다. 타입을 보시면 이해가 빠를겁니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;liftM :: Monad m =&amp;gt; (a -&amp;gt; b) -&amp;gt; m a -&amp;gt; m b
liftM f mx = do x &amp;lt;- mx
             return (f x)
             
join :: Monad m =&amp;gt; m (m a) -&amp;gt; m a
join mmx = do mx &amp;lt;- mmx
              x &amp;lt;- mx
              return x
           
(&amp;gt;&amp;gt;) :: Monad m =&amp;gt; m a -&amp;gt; m b -&amp;gt; m b
mx &amp;gt;&amp;gt; my = do _ &amp;lt;- mx
              y &amp;lt;- my
              return y
              
sequence :: Monad m =&amp;gt; [m a] -&amp;gt; m [a]
sequence (mx:mxs) = do x &amp;lt;- mx
                       xs &amp;lt;- sequence mxs
                       return (x:xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;strong&gt;DelftX FP 101x&lt;/strong&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://stackoverflow.com/questions/2607498/programming-in-haskell-error-in-sat-function&#34;&gt;error in sat function in &amp;ldquo;Programming in Haskell&amp;rdquo;&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://wiki.reeseo.net/Haskell/%EA%B3%B5%EC%8B%9D%20%EC%9E%85%EB%AC%B8%EC%84%9C%20%EB%B2%88%EC%97%AD%EB%AC%B8/9.%20%EB%AA%A8%EB%82%98%EB%93%9C%20(Monads)&#34;&gt;http://wiki.reeseo.net/Haskell&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://en.wikibooks.org/wiki/Haskell/Understanding_monads&#34;&gt;Understanding Monads&lt;/a&gt;&lt;br /&gt;
(5) &lt;a href=&#34;http://www.csee.umbc.edu/courses/331/fall11/hw/hw2/&#34;&gt;http://www.csee.umbc.edu&lt;/a&gt;&lt;br /&gt;
(6) &lt;a href=&#34;http://www.cs.nott.ac.uk/~gmh/monads&#34;&gt;Programming With Effects&lt;/a&gt; by &lt;em&gt;Graham Hutton&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>하스켈로 배우는 함수형 언어 5</title>
      <link>https://1ambda.github.io/haskell/intro-to-haskell-5/</link>
      <pubDate>Sat, 25 Jun 2016 01:21:46 +0900</pubDate>
      
      <guid>https://1ambda.github.io/haskell/intro-to-haskell-5/</guid>
      <description>

&lt;p&gt;키보드를 읽거나 화면에 무엇인가 쓰는 &lt;em&gt;intertactive program&lt;/em&gt; 은 &lt;em&gt;side-effect&lt;/em&gt; 를 만듭니다. 그런데, 하스켈은 &lt;em&gt;side-effect&lt;/em&gt; 가 없지요. 그럼 입출력이 불가능한 것일까요?&lt;/p&gt;

&lt;p&gt;당연히 그렇지 않습니다. &lt;strong&gt;IO 모나드&lt;/strong&gt; 를 사용할겁니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;pure expression&lt;/em&gt; 부분과 &lt;em&gt;side-effect&lt;/em&gt; 를 만들어내는 &lt;em&gt;impure action&lt;/em&gt; 을 구분하여 하스켈에서 입출력을 할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Interactive program can be written in Haskell using types to distinguish pure expressions from impure actions that may involve side effects&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를 들어 &lt;code&gt;IO a&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 타입을 리턴하는 &lt;em&gt;action&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;p&gt;몇 가지 예를 보면, &lt;code&gt;IO Char&lt;/code&gt; 은 캐릭터를 리턴하는 액션입니다. &lt;code&gt;IO ()&lt;/code&gt; 는 &lt;em&gt;unit&lt;/em&gt; 을 돌려주는데 이건 절차형 언어에서의 &lt;em&gt;void&lt;/em&gt; 와 같다고 보면 됩니다. 다시 말해서 &lt;code&gt;IO ()&lt;/code&gt; 는 다른 것엔 아무것도 관심 없고 입출력에만 관심이 있다는 뜻이지요.&lt;/p&gt;

&lt;p&gt;지난 시간에 언급 했듯이 &lt;em&gt;IO 모나드&lt;/em&gt; 는 사실 &lt;em&gt;State 모나드&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;State -&amp;gt; (a, State)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;스크린이나, 키보드 버퍼등 다양한 State 를 변화시켜 가면서 &lt;code&gt;a&lt;/code&gt; 타입의 값을 리턴할 수 있죠. 위에서 본 &lt;code&gt;IO ()&lt;/code&gt; 는 &lt;em&gt;purely side-effecting action&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;h3 id=&#34;basic-actions&#34;&gt;Basic Actions&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;getChar&lt;/code&gt; 는 키보드로부터 글자를 하나 읽어 캐릭터를 리턴합니다. 다른 언어에서는 &lt;code&gt;() -&amp;gt; Char&lt;/code&gt; 처럼 정의되었겠죠?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;getChar :: IO Char
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다른 &lt;em&gt;action&lt;/em&gt; 도 좀 살펴볼까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;puChar :: Char -&amp;gt; IO ()
return :: a -&amp;gt; IO a
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sequencing&#34;&gt;Sequencing&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;action&lt;/em&gt; 들을 &lt;code&gt;do&lt;/code&gt; 로 조합할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;a :: IO (Char, Char)
a = do x &amp;lt;- getChar
    getChar
    y &amp;lt;- getChar
    return (x, y)
    
getLine :: IO String
getLine = do x &amp;lt;- getChar
             if x == &#39;\n&#39; then
               return []
             else
               do xs &amp;lt;- getLine
                  return (x:xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;몇 가지 더 볼까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;putStr :: String -&amp;gt; IO ()
putStr [] = return ()
putStr (x:xs) = do putChar x
                   putStr xs
                   
putStrLn :: String -&amp;gt; IO ()
putStrLn xs = do putStr xs
                 putChar &#39;\n&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;모나드의 산을 넘고 넘어야 IO 의 간결함이 이해가 되니, 아이러니 하죠? 본래 입출력은 정말 기초적인 부분인데 말이지요.&lt;/p&gt;

&lt;p&gt;참고로 &lt;em&gt;list comprehension&lt;/em&gt; 을 이용하면 &lt;code&gt;putStr&lt;/code&gt; 은 이렇게 정의할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;seqn :: [IO a] -&amp;gt; IO ()
seqn [] = return ()
seqn (x:xs) = do x
                 seqn xs

putStr xs = seqn [putChar x | x &amp;lt;- xs]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;조금 더 블럭을 쌓아봅시다. 문자열을 키보드로 부터 입력받아 화면에 그 길이를 띄워주는 함수를 작성해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;strlen :: IO ()
strlen = do putStr &amp;quot;Enter a string: &amp;quot;
            xs &amp;lt;- getLine
            putStr &amp;quot;The string has &amp;quot;
            putStr (show (length xs))
            putStrLn &amp;quot; characters&amp;quot;
            
&amp;gt; strlen
-- Enter a string: Hello World!
-- the string has 12 characters
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;strlen&lt;/code&gt; 은 &lt;code&gt;IO ()&lt;/code&gt; 타입이니까, 아무것도 돌려주지 않습니다. 입출력에만 관심이 있지요.&lt;/p&gt;

&lt;h3 id=&#34;hangman&#34;&gt;Hangman&lt;/h3&gt;

&lt;p&gt;이제까지 배운것을 응용해서 자그마한 행맨 게임을 만들어 봅시다. &lt;em&gt;top down&lt;/em&gt; 방식으로 접근할 겁니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;hangman :: IO ()
hangman = do putStrLn &amp;quot;Think of a word :&amp;quot;
             word &amp;lt;- sgetLine
             putStrLn &amp;quot;Try to guess it:&amp;quot;
             guess word
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;sgetLine&lt;/code&gt; 은 키보드로부터 문자를 입력받아 &lt;code&gt;-&lt;/code&gt; 를 화면에 출력합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sgetLine :: IO String
sgetLine = do x &amp;lt;- getCh
              if x == &#39;\n&#39;
                then do putChar x
                        return []
                else do putChar &#39;-&#39;
                        xs &amp;lt;- sgetLine
                        return (x:xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getCh&lt;/code&gt; 는 문자열을 키보드로 부터 읽지만 화면에 출력하진 않지요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import System.IO

getCh :: IO Char
getCh = do hSetEcho stdin False
           c &amp;lt;- getChar
           hSetCho stdin True
           return c
           
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 잘 보면 &lt;code&gt;c &amp;lt;- getChar&lt;/code&gt; 이 할당(&lt;code&gt;=&lt;/code&gt;)처럼 보일텐데, 사실은 그렇지 않습니다. 우린 어떠한 &lt;em&gt;mutable&lt;/em&gt; 도 변수도 사용하고 있지 않습니다. 비록 우리가 작성한 코드가 절차형 언어처럼 보일지라도요!&lt;/p&gt;

&lt;p&gt;이제 마지막 퍼즐인 &lt;code&gt;guess&lt;/code&gt; 함수를 작성해 볼까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;guess :: String -&amp;gt; IO ()
guess word = do putStr &amp;quot;&amp;gt; &amp;quot;
                xs &amp;lt;- getLine
                if xs == word
                  then putStrLn &amp;quot;You got it!&amp;quot;
                  else do putStrLn (diff word xs)
                          guess word

diff :: String -&amp;gt; String -&amp;gt; String
diff xs ys = [if elem x ys then x else &#39;-&#39; | x &amp;lt;- xs]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;diff&lt;/code&gt; 를 잠깐 실행해 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; diff &amp;quot;haskell&amp;quot; &amp;quot;pascal&amp;quot;
-- &amp;quot;-as--ll&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;calculator&#34;&gt;Calculator&lt;/h3&gt;

&lt;p&gt;시작 전에 몇 가지 보조 함수를 정의하면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;getCh :: IO Char
getCh =  do hSetEcho stdin False
            c &amp;lt;- getChar
            hSetEcho stdin True
            return c

beep :: IO ()
beep = putStr &amp;quot;\BEL&amp;quot;

cls :: IO ()
cls = putStr &amp;quot;\ESC[2J&amp;quot;

type Pos = (Int, Int)

goto :: Pos -&amp;gt; IO ()
goto (x, y) = putStr (&amp;quot;\ESC[&amp;quot;  ++ show y ++ &amp;quot;;&amp;quot; ++ show x ++ &amp;quot;H&amp;quot;)

writeAt :: Pos -&amp;gt; String -&amp;gt; IO ()
writeAt p xs = do goto p
                  putStr xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;콘솔 창에서 문자의 위치는 좌표 &lt;code&gt;(Int, Int)&lt;/code&gt; 에 의해 결정됩니다. &lt;code&gt;goto&lt;/code&gt; 는 그 위치로 커서를 옮기고 &lt;code&gt;writeAt&lt;/code&gt; 는 해당 좌표에 입력받은 문자열을 출력합니다.&lt;/p&gt;

&lt;p&gt;여기에 &lt;a href=&#34;http://1ambda.github.io/haskell-intro4/&#34;&gt;지난번&lt;/a&gt;에 만들었던 파서가 &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; 도 처리할 수 있게 조금 업그레이드 하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;int :: Parser Int
int =  do char &#39;-&#39;
          n &amp;lt;- nat
          return (-n)
        +++ nat

natural :: Parser Int
natural =  token nat

integer :: Parser Int
integer =  token int

expr :: Parser Int
expr = do t &amp;lt;- term
          do symbol &amp;quot;+&amp;quot;
             e &amp;lt;- expr
             return (t + e)
           +++ do symbol &amp;quot;-&amp;quot;
                  e &amp;lt;- expr
                  return (t - e)
           +++ return t

term :: Parser Int
term = do f &amp;lt;- factor
          do symbol &amp;quot;*&amp;quot;
             t &amp;lt;- term
             return (f * t)
           +++ do symbol &amp;quot;/&amp;quot;
                  t &amp;lt;- term
                  return (f `div` t)
           +++ return f

factor :: Parser Int
factor = do symbol &amp;quot;(&amp;quot;
            e &amp;lt;- expr
            symbol &amp;quot;)&amp;quot;
            return e
          +++ natural
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 간단한 계산기를 문자열로 나타내 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;box :: [String]
box =  [&amp;quot;+---------------+&amp;quot;,
       &amp;quot;|               |&amp;quot;,
       &amp;quot;+---+---+---+---+&amp;quot;,
       &amp;quot;| q | c | d | = |&amp;quot;,
       &amp;quot;+---+---+---+---+&amp;quot;,
       &amp;quot;| 1 | 2 | 3 | + |&amp;quot;,
       &amp;quot;+---+---+---+---+&amp;quot;,
       &amp;quot;| 4 | 5 | 6 | - |&amp;quot;,
       &amp;quot;+---+---+---+---+&amp;quot;,
       &amp;quot;| 7 | 8 | 9 | * |&amp;quot;,
       &amp;quot;+---+---+---+---+&amp;quot;,
       &amp;quot;| 0 | ( | ) | / |&amp;quot;,
       &amp;quot;+---+---+---+---+&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;q, c, d, =&lt;/code&gt; 는 &lt;em&gt;quit&lt;/em&gt;, &lt;em&gt;clear&lt;/em&gt;, &lt;em&gt;delete&lt;/em&gt; &lt;em&gt;evaluation&lt;/em&gt; 를 의미합니다. 나머지 버튼은 식을 입력하는데 사용하지요. 이제 박스를화면에 그려주는 &lt;code&gt;showbox&lt;/code&gt; 함수를 작성합시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;seqn :: [IO a] -&amp;gt; IO ()
seqn [] = return ()
seqn (a:as) = do a
			     seqn as
                 
buttons :: [Char]
buttons = standard ++ extra
          where
            standard = &amp;quot;qcd=123+456-789*0()/&amp;quot;
            extra = &amp;quot;QCD \ESC\BS\DEL\n&amp;quot;

showbox :: IO ()
showbox = 
  seqn [writeAt (1, y) line | (y, line) &amp;lt;- zip [1..13] box]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;buttons&lt;/code&gt; 에서 &lt;code&gt;extra&lt;/code&gt; 는 좀 더 유연한 버튼 인터페이스를 위해 사용합니다. 무슨 말인고 하니 &lt;code&gt;q&lt;/code&gt; 뿐만 아니라 &lt;code&gt;Q&lt;/code&gt; 를 눌러도 계산기가 종료되게끔요.&lt;/p&gt;

&lt;p&gt;이제 수식을 표현하는 부분을 출력해줄 &lt;code&gt;display&lt;/code&gt; 함수를 만듭시다. 입력받은 문자열을, 뒤에서부터 13개만 짤라서 &lt;code&gt;(3, 2)&lt;/code&gt; 위치에 출력해줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;display :: String -&amp;gt; IO ()
display xs = do writeAt (3, 2) &amp;quot;             &amp;quot;
                writeAt (3, 2) (reverse (take 13 (reverse xs)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 사용자로부터 문자를 입력받아 화면에 출력해주는 로직을 구현한 &lt;code&gt;calc&lt;/code&gt; 함수를 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;
calc :: String -&amp;gt; IO ()
calc xs = do display xs
             c &amp;lt;- getCh
             if elem c buttons
               then process c xs
               else do beep
                       calc xs

process :: Char -&amp;gt; String -&amp;gt; IO ()
process c xs
  | elem c &amp;quot;qQ\ESC&amp;quot; = quit
  | elem c &amp;quot;dD\BS\DEL&amp;quot; = delete xs
  | elem c &amp;quot;=\n&amp;quot; = eval xs
  | elem c &amp;quot;cC&amp;quot; = clear
  | otherwise = press c xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;calc&lt;/code&gt; 에서는 현재 수식창에 입력된 데이터 &lt;code&gt;xs&lt;/code&gt; 와, 사용자로부터 받은 &lt;code&gt;c&lt;/code&gt; 를 이용해 작업을 합니다. &lt;code&gt;c&lt;/code&gt; 가 만약 &lt;code&gt;buttons&lt;/code&gt; 내부에 없다면 다시 &lt;code&gt;calc xs&lt;/code&gt; 를 호출해서 새로운 입력을 받습니다.&lt;/p&gt;

&lt;p&gt;만약 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;buttons&lt;/code&gt; 내에 있는 문자들 중 하나라면 &lt;code&gt;process c xs&lt;/code&gt; 를 호출하는데, 여기서는 버튼의 종류에 따라 다른 &lt;code&gt;IO ()&lt;/code&gt; 를 돌려줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;quit :: IO ()
quit = goto (1, 14)

delete :: String -&amp;gt; IO ()
delete &amp;quot;&amp;quot; = calc &amp;quot;&amp;quot;
delete xs = calc (init xs)

eval :: String -&amp;gt; IO ()
eval xs = case parse expr xs of
           [(n, &amp;quot;&amp;quot;)] -&amp;gt; calc (show n)
           _ -&amp;gt; do beep
                   calc xs

clear :: IO ()
clear = calc &amp;quot;&amp;quot;

press :: Char -&amp;gt; String -&amp;gt; IO ()
press c xs = calc (xs ++ [c])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1) &lt;code&gt;quit&lt;/code&gt; 는 다시 &lt;code&gt;calc&lt;/code&gt; 호출 없이 현재 커서를 14번째 라인으로 이동해 계산기를 종료합니다.&lt;br /&gt;
(2) &lt;code&gt;delete&lt;/code&gt; 는 현재 &lt;code&gt;xs&lt;/code&gt; 에서 마지막 문자를 제거한 &lt;code&gt;init xs&lt;/code&gt; 를 &lt;code&gt;calc&lt;/code&gt; 에 넘겨줌으로써 수식 입력창에서 마지막 문자를 지웁니다.&lt;br /&gt;
(3) &lt;code&gt;eval&lt;/code&gt; 는 &lt;code&gt;parse expr xs&lt;/code&gt; 의 결과로 올바른 계산 값을 얻으면 &lt;code&gt;calc&lt;/code&gt; 에 그 숫자를 문자열로 변환한 결과를 넘겨주어 계산값을 표시합니다. (&lt;code&gt;show n&lt;/code&gt;) 아니라면, 계산이 안되므로 비프음을 뿜고 다시 &lt;code&gt;calc xs&lt;/code&gt; 를 호출해 새로운 입력을 기다립니다.&lt;br /&gt;
(4) &lt;code&gt;clear&lt;/code&gt; 는 수식 입력창에 있는 값을 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; 를 돌려줌으로써 비웁니다.&lt;br /&gt;
(5) &lt;code&gt;press&lt;/code&gt; 는 현재 수식 입력창에 있는 데이터 &lt;code&gt;xs&lt;/code&gt; 에 &lt;code&gt;c&lt;/code&gt; 를 이어 붙입니다.&lt;/p&gt;

&lt;p&gt;잘 보시면 현재 가지고 있는 데이터는 &lt;code&gt;xs&lt;/code&gt; 로 표시되고, 이외의 &lt;code&gt;IO ()&lt;/code&gt; 를 조합해 가며 화면의 상태(&lt;em&gt;State&lt;/em&gt;) 를 변화시킵니다. 이 과정에서 &lt;strong&gt;화면을 변화시키는 부분과, 데이터 &lt;code&gt;xs&lt;/code&gt; 가 변하는 부분이 서로 분리&lt;/strong&gt; 되어 있습니다.&lt;/p&gt;

&lt;p&gt;마지막으로 계산기를 실행시키는 함수 &lt;code&gt;run&lt;/code&gt; 을 만들겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;run :: IO ()
run = do cls
         showbox
         clear
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;game-of-life&#34;&gt;Game of Life&lt;/h3&gt;

&lt;p&gt;&lt;del&gt;인생게임은 아닙니다&lt;/del&gt; 세포의 생존게임이라 생각하면 이해하기 쉽습니다. &lt;code&gt;n * m&lt;/code&gt; 보드에서 각 칸마다 세포가 위치할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;a living cell survives if it has precisely two or three neighbouring squares that contain living cells, and dies (becomes empty) otherwise.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;an empty square gives birth to a living cell if it has precisely neighbours that contain living cells, and remains empty otherwise.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;각 칸마다 균등한 기회를 주기 위해 모서리에 있는 칸 또한 8개의 이웃한 칸을 가졌다고 합시다. &lt;em&gt;torus (3차원의 도넛모양 )&lt;/em&gt; 을 생각하심 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/c/c6/Simple_Torus.svg/310px-Simple_Torus.svg.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://commons.wikimedia.org/wiki/File:Simple_Torus.svg&#34;&gt;http://commons.wikimedia.org/wiki/File:Simple_Torus.svg&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;초기값에 따라 턴을 반복하면서 다양한 종류의 결과물이 나옵니다. 그 중에서 초기값이 몇번의 턴을 지나면서 지속적으로 대각선으로 움직이는 패턴을 &lt;em&gt;glider&lt;/em&gt; 라 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/f865db6a304d36aa7fef6c060729a2d635cd5c14/687474703a2f2f7777772d726f68616e2e736473752e6564752f7e72636172726574652f7465616368696e672f4d2d3539365f706174742f696d616765732f676c696465722e676966&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;https://gist.github.com/boggle/10390842&#34;&gt;https://gist.github.com/boggle/10390842&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;em&gt;row&lt;/em&gt; 를 &lt;code&gt;x&lt;/code&gt;, &lt;em&gt;column&lt;/em&gt; 을 &lt;code&gt;y&lt;/code&gt; 로 해서 1 부터 시작하는 &lt;code&gt;5 x 5&lt;/code&gt; 의 &lt;em&gt;glider&lt;/em&gt; 보드를 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;width :: Int
width = 5

height :: Int
height = 5

type Board = [Pos]

glider :: Board
glider = [(4,2),(2,3),(4,3),(3,4),(4,4)]

showCells :: Board -&amp;gt; IO ()
showCells b = seqn [writeAt p &amp;quot;O&amp;quot; | p &amp;lt;- b]

isAlive :: Board -&amp;gt; Pos -&amp;gt; Bool
isAlive b p = elem p b

isEmpty :: Board -&amp;gt; Pos -&amp;gt; Bool
isEmpty = not (isAlive b p)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기에 해당 칸의 세포가 살았는지 죽었는지 검사하는 &lt;code&gt;isAlive&lt;/code&gt;, &lt;code&gt;isEmpty&lt;/code&gt; 와 보드를 출력하는 &lt;code&gt;showCells&lt;/code&gt; 함수도 만들었습니다.&lt;/p&gt;

&lt;p&gt;이제 어떤 &lt;code&gt;(x, y)&lt;/code&gt; 를 입력 받아 그 주변 8개의 이웃 세포 좌표를 돌려주는 함수를 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;neighbs :: Pos -&amp;gt; [Pos]
neighbs (x,y) =  map wrap [(x-1,y-1), (x,y-1),
                           (x+1,y-1), (x-1,y),
                           (x+1,y)  , (x-1,y+1),
                           (x,y+1)  , (x+1,y+1)] 

wrap :: Pos -&amp;gt; Pos
wrap (x,y) =  (((x-1) `mod` width) + 1, ((y-1) `mod` height + 1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;wrap&lt;/code&gt; 은 &lt;code&gt;mod&lt;/code&gt; 연산을 이용해서, 판의 범위를 벗어난 이웃 세포의 좌표를 판 내에 있는 이웃으로 만들어 돌려줍니다. 예를 들어&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; wrap (0, 1)
-- (5,1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 살아있는 이웃 세포의 개수를 돌려주는 &lt;code&gt;liveNeighbs&lt;/code&gt; 와, 살아있는 세포들(인접한 살아있는 세포가 2, 3개인) 좌표를 돌려주는 &lt;code&gt;survivors&lt;/code&gt; 함수를 만듭시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;liveNeighbs :: Board -&amp;gt; Pos -&amp;gt; Int
liveNeighbs b = length . filter (isAlive b) . neighbs

survivors :: Board -&amp;gt; [Pos]
survivors b = [p | p &amp;lt;- b, elem (liveNeighbs b p) [2, 3]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 죽은 세포에 대해 인접한 살아있는 세포가 3개일 때만 살아있는 세포로 변경하는 &lt;code&gt;births&lt;/code&gt; 함수를 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;births :: Board
births :: Board -&amp;gt; [Pos]
births b = [p | p &amp;lt;- rmdups (concat (map neighbs b)),
            isEmpty b p,
            liveNeighbs b p == 3]

rmdups :: Eq a =&amp;gt; [a] -&amp;gt; [a]
rmdups [] = []
rmdups (x:xs) = x : filter (/= x) xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;중복을 제거하기 위해 &lt;code&gt;rmdups&lt;/code&gt; 함수를 만들어서 사용했습니다.&lt;/p&gt;

&lt;p&gt;이렇게 되면, 다음 턴에서의 &lt;em&gt;board&lt;/em&gt; 는 &lt;code&gt;survivors&lt;/code&gt; 와 &lt;code&gt;births&lt;/code&gt; 의 원소들 이므로&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;nextGen :: Board -&amp;gt; Board
nextGen b = survivors b ++ births b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 화면 출력을 위한 몇 가지 함수를 더 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;life :: Board -&amp;gt; IO ()
life b = do cls
            showCells b
            wait 5000
            life (nextGen b)

wait :: Int -&amp;gt; IO ()
wait n = seqn [return () | _ &amp;lt;- [1..n]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;strong&gt;DelftX FP 101x&lt;/strong&gt;&lt;br /&gt;
(2) &lt;em&gt;Programming in Haskell&lt;/em&gt;&lt;br /&gt;
(3) &lt;a href=&#34;https://gist.github.com/boggle/10390842&#34;&gt;gist.github.com/boggle&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>하스켈로 배우는 함수형 언어 6</title>
      <link>https://1ambda.github.io/haskell/intro-to-haskell-6/</link>
      <pubDate>Sat, 25 Jun 2016 01:21:49 +0900</pubDate>
      
      <guid>https://1ambda.github.io/haskell/intro-to-haskell-6/</guid>
      <description>

&lt;p&gt;이번시간엔 어떻게 &lt;em&gt;type&lt;/em&gt; 과 &lt;em&gt;class&lt;/em&gt; 를 정의하는지 배울겁니다. 이렇게 &lt;em&gt;commonality&lt;/em&gt; 를  추출해서 &lt;em&gt;type&lt;/em&gt; 과 &lt;em&gt;class&lt;/em&gt; 로 만듦으로써 작업의 양을 줄일 수 있습니다. 이 과정을 추상화라 부르기도 합니다.&lt;/p&gt;

&lt;p&gt;마지막엔 이제까지 배운바를 적용해 봅시다. 항상 참인 명제를 검사하는 &lt;strong&gt;tautology checker&lt;/strong&gt; 와 평가 시점을 조절하는 &lt;strong&gt;abstract machine&lt;/strong&gt; 을 만들어 보겠습니다.&lt;/p&gt;

&lt;h3 id=&#34;type-declarations&#34;&gt;Type Declarations&lt;/h3&gt;

&lt;p&gt;하스켈에선 존재하는 타입을 이용해서 새로운 타입을 만들 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type String = [Char]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;지난시간에 2차원 좌표계를 구현할 때 만들었던 &lt;code&gt;Pos&lt;/code&gt; 타입 기억 나시죠?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Pos = (Int, Int)

origin :: Pos
origin = (0, 0)

left :: Pos -&amp;gt; Pos
left (x, y) = (x-1, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;type&lt;/em&gt; 은 함수와 마찬가지로 다양한 타입을 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Pair a = (a, a)

mult :: Pair Int -&amp;gt; Int
mult (a, b) = a * b

copy :: Int -&amp;gt; Pair Int
copy a = (a, a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여러개의 타입도 사용할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Assoc k v = [(k, v)]

find :: Eq k =&amp;gt; k -&amp;gt; Assoc k v -&amp;gt; v
find k xs = head [v | (k&#39;, v) &amp;lt;- xs, k == k&#39;]

&amp;gt; find 2 [(1, &#39;a&#39;), (2, &#39;c&#39;), (3, &#39;f&#39;)]
-- &#39;c&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;em&gt;nested (중첩)&lt;/em&gt; 될 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Trans = Pos -&amp;gt; Pos

left :: Trans
left (x, y) = (x-1, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하지만 &lt;em&gt;recursive&lt;/em&gt; 로 정의될 수는 없습니다. 왜냐하면 &lt;em&gt;type&lt;/em&gt; 이 단지 &lt;em&gt;synonym&lt;/em&gt; 이기 때문입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- doesn&#39;t work
type Tree = (Int, [Tree

-- ghci

Cycle in type synonym declarations:
  lecture9.hs:22:1-25: type Tree = (Int, [Tree])
Failed, modules loaded: none.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러나 하스켈에선 재귀적으로 타입을 정의할 수 있는 방법이 있긴 있습니다! 다만 &lt;em&gt;nominal type&lt;/em&gt; 을 이용해야 합니다.(&lt;code&gt;data&lt;/code&gt; 키워드를 사용합니다.) 많은 언어들이 이와 비슷한 제약조건을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;object-oriented language&lt;/em&gt; 에서는 전형적으로 &lt;em&gt;nominal type system&lt;/em&gt; 을 사용합니다. 이는 &lt;em&gt;&amp;ldquo;두 타입이 같은지&amp;rdquo;&lt;/em&gt;, &lt;em&gt;&amp;ldquo;한 타입이 다른 타입의 서브타입인지&amp;rdquo;&lt;/em&gt; 검사하기 쉽기 때문입니다. 반면 &lt;em&gt;purely sructural type system&lt;/em&gt; 에서는 이게 조금 어려워집니다. (참고로 &lt;em&gt;nominal vs structure&lt;/em&gt; 은, &lt;em&gt;dynamic static&lt;/em&gt; 과는 다른 문제입니다.)&lt;/p&gt;

&lt;h3 id=&#34;data-declarations&#34;&gt;Data Declarations&lt;/h3&gt;

&lt;p&gt;기존타입과 관련없는 새로운 타입을 만들려면 &lt;code&gt;data&lt;/code&gt; 키워드를 사용하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Bool = False | True	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;Bool&lt;/code&gt; 은 새로운 &lt;em&gt;type&lt;/em&gt; 이고, 여기에 &lt;code&gt;False, True&lt;/code&gt; 의 &lt;em&gt;value&lt;/em&gt; 를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;여기서 &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;True&lt;/code&gt; 를 &lt;em&gt;type&lt;/em&gt; &lt;code&gt;Bool&lt;/code&gt; 을 위한 &lt;em&gt;constructor&lt;/em&gt; 라 부릅니다. &lt;em&gt;type constructor&lt;/em&gt; 의 이름은 반드시 대문자로 시작해야합니다.&lt;/p&gt;

&lt;p&gt;새로운 타입을 조금 더 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Answer = Yes | No | Unknown

answers :: [Answer]
answers = [Yes, No, Unknown]

flip :: Answer -&amp;gt; Answer
flip Yes = No
flip No = Yes
flip Unknown = Unknown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;좌표의 움직임을 추상화한 타입 &lt;code&gt;Move&lt;/code&gt; 도 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Move = Left | Right | Up | Down

move :: Move -&amp;gt; Pos -&amp;gt; Pos
move Up (x, y) = (x, y-1)
move Left (x, y) = (x-1, y)
move Down (x, y) = (x, y+1)
move Right (x, y) = (x+1, y)

moves :: [Move] -&amp;gt; Pos -&amp;gt; Pos
moves [] p = p
moves (m:ms) p = moves ms (move m p)

&amp;gt; move Left (1, 1)
-- (0,1)

&amp;gt; moves [Left, Right, Up, Down, Left] (0, 0)
--(-1,0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;data declaration&lt;/em&gt; 내에 있는 &lt;em&gt;constructor&lt;/em&gt; 는 파라미터를 가질 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Shape = Circle Float
           | Rect Float Float

square :: Float -&amp;gt; Shape
square n = Rect n n

area :: Shape -&amp;gt; Float
area (Circle r) = pi * r^2
area (Rect x y) = x * y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;em&gt;constructor&lt;/em&gt; 를 함수라 볼 수도 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Circle :: Float -&amp;gt; Shape
Rect :: Float Float -&amp;gt; Shape
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;constructor&lt;/em&gt; 뿐만 아니라 &lt;em&gt;data declaration&lt;/em&gt; 그 자체도 파라미터를 가질 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Maybe a = Nothing | Just a

safediv :: Int -&amp;gt; Int -&amp;gt; Maybe Int
safediv _ 0 = Nothing
safediv x y = Just (x `div` y)

safehead :: [a] -&amp;gt; Maybe a
safehead [] = Nothing
safehead (x:xs) = Just x
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;recursive-types&#34;&gt;Recursive Types&lt;/h3&gt;

&lt;p&gt;재귀적인 타입의 예를 한번 볼까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Nat = Zero | Succ Nat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;Zero :: Nat&lt;/code&gt;, &lt;code&gt;Succ :: Nat -&amp;gt; Nat&lt;/code&gt; 라 보면 됩니다. 따라서 다음처럼 확장이 가능하지요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Zero -- 0
Succ Zero -- 1
Succ (Succ Zero) -- 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보시면 알겠지만, 우리는 단 한 줄로 자연수를 표현하는 데이터 타입 &lt;code&gt;Nat&lt;/code&gt; 를 만들었습니다. 숫자와 &lt;code&gt;Nat&lt;/code&gt; 타입을 변환하는 함수를 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Nat = Zero | Succ Nat

nat2int :: Nat -&amp;gt; Int
nat2int Zero = 0
nat2int (Succ nat) = 1 + nat2int nat

int2nat :: Int -&amp;gt; Nat
int2nat 0 = Zero
int2nat n = Succ (int2nat (n-1))

&amp;gt; nat2int (int2nat 10)
-- 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;재귀를 이용하면 &lt;code&gt;Nat&lt;/code&gt; 간 덧셈을 위에서 만든 변환함수 없이도 만들수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;add :: Nat -&amp;gt; Nat -&amp;gt; Nat
add Zero n = n
add (Succ n) s = Succ (add n s)

&amp;gt; nat2int (add (int2nat 2) (int2nat 3))
-- 5
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;list&#34;&gt;List&lt;/h3&gt;

&lt;p&gt;임의의 타입을 갖는 리스트를 나타내는 &lt;code&gt;List&lt;/code&gt; 타입을 만들어 보죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data List a = Nil | Cons a (List a)

len :: List a -&amp;gt; Int
len Nil = 0
len (Cons h t) = 1 + len t

&amp;gt;  len (Cons 4 (Cons 3 Nil))
-- 2

&amp;gt; len Nil
-- 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;arithmetic-expressions&#34;&gt;Arithmetic Expressions&lt;/h3&gt;

&lt;p&gt;기본적인 &lt;code&gt;+, *&lt;/code&gt; 과 정수와 연산 &lt;em&gt;expression (식)&lt;/em&gt; 을 타입으로 만들면 어떻게 될까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Exp-tree-ex-11.svg/375px-Exp-tree-ex-11.svg.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://en.wikipedia.org&#34;&gt;http://en.wikipedia.org&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Expr = Val Int
          | Add Expr Expr
          | Mul Expr Expr          
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;em&gt;expression&lt;/em&gt; 의 사이즈와, 계산 결과를 돌려주는 함수 &lt;code&gt;size&lt;/code&gt;, &lt;code&gt;eval&lt;/code&gt; 을 만듭시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;size :: Expr -&amp;gt; Int
size (Val n) = 1
size (Add l r) = size l + size r
size (Mul l r) = size l + size r

eval :: Expr -&amp;gt; Int
eval (Val n) = n
eval (Add l r) = eval l + eval r
eval (Mul l r) = eval l * eval r

&amp;gt; eval (Add (Val 3) (Val 2))
-- 5

&amp;gt; size (Add (Val 3) (Val 2))
-- 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이번엔 이진트리를 표현해 볼까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Tree = Leaf Int
          | Node Tree Int Tree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 트리에서 원하는 숫자가 존재하는지 검사하는 &lt;code&gt;occurs&lt;/code&gt; 함수를 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;occurs :: Int -&amp;gt; Tree -&amp;gt; Bool
occurs n (Leaf k) = n == k
occurs n (Node l k r) =
  (n == k) 
  || occurs n l
  || occurs n r
  
&amp;gt; occurs 3 (Node (Leaf 3) 4 (Leaf 5))
-- True

&amp;gt; occurs 6 (Node (Leaf 3) 4 (Leaf 5))
-- False  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;트리의 모든 원소를 리스트로 돌려주는 &lt;code&gt;flatten&lt;/code&gt; 함수도 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;flatten :: Tree -&amp;gt; [Int]
flatten (Leaf k) = [k]
flatten (Node l k r) = flatten l ++ [k] ++ flatten 

&amp;gt; flatten (Node (Leaf 3) 4 (Leaf 5))
-- [3,4,5]

&amp;gt; flatten (Node (Leaf 6) 4 (Leaf 7))
-- [6,4,7]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 재미난 결과를 볼 수 있습니다. &lt;code&gt;flatten&lt;/code&gt; 함수는 매 재귀마다 왼쪽부터 방문하고, 현재 노드를 방문하고, 마지막으로 오른쪽 노드를 방문합니다.&lt;/p&gt;

&lt;p&gt;그래서 &lt;code&gt;flatten&lt;/code&gt; 함수의 결과가 &lt;em&gt;ordered&lt;/em&gt; 이면 트리는 한 노드를 기준으로 한쪽은 현재 노드보다 작고, 다른쪽은 큰 &lt;em&gt;search-tree&lt;/em&gt; 가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;search-tree&lt;/em&gt; 에서는 만약 찾으려는 수가 현재 노드보다 크면 &lt;em&gt;right sub-tree&lt;/em&gt; 만, 현재 노드보다 작으면 &lt;em&gt;left sub-tree&lt;/em&gt; 만 검색하면 됩니다. 따라서 &lt;code&gt;occurs&lt;/code&gt; 함수를&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- occurs for search-ree
occurs&#39; :: Int -&amp;gt; Tree -&amp;gt; Bool
occurs&#39; n (Leaf k) = k == n
occurs&#39; n (Node l k r) | n == k = True
                       | n &amp;lt; k = occurs&#39; n l
                       | otherwise = occurs&#39; n r


&amp;gt; occurs&#39; 3 (Node (Leaf 3) 4 (Leaf 5))
-- True

&amp;gt; occurs&#39; 5 (Node (Leaf 3) 4 (Leaf 5))
-- True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실제로 트리는 값을 어디에 저장하냐에 따라 다양한 형태가 될 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Tree a = Leaf a | Node (Tree a) (Tree a)
data Tree a = Leaf | Node (Tree a) a (Tree a)
data Tree a b = Leaf a | Node (Tree a b) b (Tree a b)
data Tree a = Node a [Tree a]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위에서 부터&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;leaf&lt;/em&gt; 에만 값을 저장&lt;br /&gt;
(2) &lt;em&gt;node&lt;/em&gt; 에만 값을 저장&lt;br /&gt;
(3) &lt;em&gt;leaf&lt;/em&gt;, &lt;em&gt;node&lt;/em&gt; 에 모두 값을 저장&lt;br /&gt;
(4) 한 &lt;em&gt;node&lt;/em&gt; 에 값과 복수개의 트리를 저장&lt;/p&gt;

&lt;h3 id=&#34;tautology-checker&#34;&gt;Tautology checker&lt;/h3&gt;

&lt;p&gt;항상 참인 명제를 &lt;em&gt;tautology&lt;/em&gt; 라고 합니다. 논리학에 대해서는 다음 글을 참조해주세요.&lt;/p&gt;

&lt;p&gt;(1) &lt;a href=&#34;http://imnt.tistory.com/91&#34;&gt;명제논리의 기초 1 : 소개&lt;/a&gt;&lt;br /&gt;
(2) &lt;a href=&#34;http://imnt.tistory.com/91&#34;&gt;명제논리의 기초 2 : 진리표&lt;/a&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://imnt.tistory.com/91&#34;&gt;명제논리의 기초 3 : tautology, contradiction&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;tautology&lt;/em&gt; 는 여러가지가 있습니다. 한 가지 예를 보면, 참 또는 거짓일 수 있는 명제 &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt; 에 대해 &lt;code&gt;p -&amp;gt; q ^ q -&amp;gt; p&lt;/code&gt; 는 항상 참입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://s1.hubimg.com/u/3891828_f520.jpg&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://julieburke.hubpages.com&#34;&gt;http://julieburke.hubpages.com&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;이번에 만들 프로그램에서는 논리학 연산자를 &lt;code&gt;Not&lt;/code&gt;, &lt;code&gt;And&lt;/code&gt;, &lt;code&gt;Imply&lt;/code&gt;, &lt;code&gt;Or&lt;/code&gt; 4가지로 제한하겠습니다. &lt;em&gt;proposition (명제)&lt;/em&gt; 는 &lt;code&gt;A, ..., Z&lt;/code&gt; 이고 각각 &lt;code&gt;True / False&lt;/code&gt; 일 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Prop =  Const Bool
          | Var Char
          | Not Prop
          | Or Prop
          | And Prop Prop
          | Imply Prop Porp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;검사할 4개의 명제를 만들어 보죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- A and ~A
p1 :: Prop
p1 = And (Var &#39;A&#39;) (Not (Var &#39;A&#39;))

-- A and B -&amp;gt; A
p2 :: Prop
p2 = Imply (And (Var &#39;A&#39;) (Var &#39;B&#39;)) (Var &#39;A&#39;)

-- A -&amp;gt; A and B
p3 :: Prop
p3 = Imply (Var &#39;A&#39;) (And (Var &#39;A&#39;) (Var &#39;B&#39;))

-- (A and (A -&amp;gt; B)) -&amp;gt; B
p4 :: Prop
p4 = Imply (And (Var &#39;A&#39;) (Imply (Var &#39;A&#39;) (Var &#39;B&#39;))) (Var &#39;B&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;각 명제가 참인지 거짓인지 알 수 있는 테이블을 나타내는 타입 &lt;code&gt;Subst&lt;/code&gt; 를 만듭시다. 진리표라고 생각하면 됩니다. 그리고 여기서 값을 찾는 함수 &lt;code&gt;find&lt;/code&gt; 도 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Assoc k v = [(k, v)]
type Subst = Assoc Char Bool

find :: Eq k =&amp;gt; k -&amp;gt; Assoc k v -&amp;gt; v
find k t = head [v | (k&#39;, v) &amp;lt;- t, k&#39; == k]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;Prop&lt;/code&gt; 를 평가하는 함수 &lt;code&gt;eval&lt;/code&gt; 을 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;eval :: Subst -&amp;gt; Prop -&amp;gt; Bool
eval _ (Const b) = b
eval s (Var x) = find x s
eval s (Not p) = not (eval s p)
eval s (Or p1 p2) = eval s p1 || eval s p2
eval s (And p1 p2) = eval s p1 &amp;amp;&amp;amp; eval s p2
eval s (Imply p1 p2) = eval s p2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떤 명제 &lt;code&gt;Prop&lt;/code&gt; 가 &lt;em&gt;tautologt&lt;/em&gt; 인지 검사하려면, 명제를 이루는 문장의 모든 참/거짓 경우에 대해 살펴봐야 합니다. 따라서 현재 가진 변수 &lt;code&gt;A, ..., Z&lt;/code&gt; 에 대해서 참 / 거짓의 모든 경우를 포함한 테이블이 필요합니다. 이 함수를 만들기 위해 작은 함수부터 차근차근 조립해 갑시다.&lt;/p&gt;

&lt;p&gt;먼저 현재 &lt;code&gt;Prop&lt;/code&gt; 에서 모든 변수를 찾는 함수 &lt;code&gt;vars&lt;/code&gt; 와 중복을 제거하는 함수 &lt;code&gt;uniq&lt;/code&gt; 를 만들겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskel&#34;&gt;vars :: Prop -&amp;gt; [Char]
vars (Const _) = []
vars (Var x) = [x]
vars (Not p) = vars p
vars (And p1 p2) = vars p1 ++ vars p2
vars (Or p1 p2) = vars p1 ++ vars p2
vars (Imply p1 p2) = vars p1 ++ vars p2

&amp;gt; vars p1
-- &amp;quot;AA&amp;quot;

&amp;gt; vars p2
-- &amp;quot;AA&amp;quot;

&amp;gt; vars p3
-- &amp;quot;ABA&amp;quot;

&amp;gt; vars p4
--&amp;quot;AAB&amp;quot;

uniq :: Eq a =&amp;gt; [a] -&amp;gt; [a]
uniq = foldr (\x xs-&amp;gt; if elem x xs then xs else x:xs) []

&amp;gt; uniq (vars p4)
-- &amp;quot;AB&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;길이를 받으면 해당 길이 만큼 &lt;code&gt;True, False&lt;/code&gt; 의 모든 조합을 리턴하는 &lt;code&gt;bools&lt;/code&gt; 함수도 만들죠. 조합이므로 다음 재귀 단계에, 가능한 모든 경우를 더하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;bools :: Int -&amp;gt; [[Bool]]
bools 0 = [[]]
bools n = map (False:) prev ++ map (True:) prev
  where prev = bools (n - 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 마지막 퍼즐을 완성하겠습니다. &lt;code&gt;Prop&lt;/code&gt; 를 받아, &lt;code&gt;[Subst]&lt;/code&gt; 를 돌려주는 함수 &lt;code&gt;substs&lt;/code&gt; 와, &lt;code&gt;Prop&lt;/code&gt; 를 받아 &lt;em&gt;tautology&lt;/em&gt; 인지 검사하는 함수 &lt;code&gt;isTaut&lt;/code&gt; 는&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;substs :: Prop -&amp;gt; [Subst]
substs p = map (zip vs) (bools (length vs))
  where vs = uniq (vars p)
  
isTaut :: Prop -&amp;gt; Bool
isTaut p = and [eval s p | s &amp;lt;- substs p]

&amp;gt; isTaut p1
-- True

&amp;gt; isTaut p2
--False

&amp;gt; isTaut p3
--True

&amp;gt; isTaut p4
--False

&amp;gt; isTaut p5
-- True
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;abstract-machine&#34;&gt;Abstract Machine&lt;/h3&gt;

&lt;p&gt;간단한 수식 계산을 위한 &lt;em&gt;expression&lt;/em&gt; 타입을 생각해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Expr = Val Int 
          | Add Expr Expr
          
value :: Expr -&amp;gt; Int
value (Val n) = n
value (Add l r) = value l + value r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 덧셈을 실제로 해 보면, 계산이 왼쪽부터 이루어지는걸 확인할수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- 2 + 3 + 4
value (Add (Add (Val 2) (Val 3)) (Val 4))
...
...
(2 + value (Val 3)) + value (Val 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위에서 알 수 있듯이 왼쪽 인자가 오른쪽 인자보다 먼저 평가됩니다. 이건 우리가 지정한게 아니고, 하스켈이 왼쪽 인자부터 평가하기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;expression&lt;/em&gt; 에서 평가 시점을 결정하는 &lt;em&gt;abstract machine&lt;/em&gt; 을 만들어서 해결할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If desired, however, such control information can be made explicit by defining an abstract machine for expressions,
which specifies the step-by-step process of their evaluation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;컨트롤 스택을 위한 타입을 만들고, 값을 평가하는 &lt;code&gt;eval&lt;/code&gt; 과 실제로 덧셈을 수행하는 &lt;code&gt;exec&lt;/code&gt; 함수를 만들겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskel&#34;&gt;-- expression
data Expr = Val Int
          | Add Expr Expr
            
-- control stack
type Cont = [Op]
data Op = EVAL Expr
        | ADD Int

eval :: Expr -&amp;gt; Cont -&amp;gt; Int
eval (Val n) c = exec c n -- eval n
eval (Add x y) c = eval x (EVAL y : c) -- eval x before y

exec :: Cont -&amp;gt; Int -&amp;gt; Int
exec [] n = n
exec (EVAL y : c) n = eval y (ADD n : c)
exec (ADD n : c)  m = exec c (n + m)

value :: Expr -&amp;gt; Int
value e = eval e []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;eval (Add x y)&lt;/code&gt; 에 대해서 &lt;code&gt;EVAL y&lt;/code&gt; 가 먼저 스택에 들어가고, &lt;code&gt;x&lt;/code&gt; 가 먼저 평가됩니다. 그 이후에 &lt;code&gt;exec&lt;/code&gt; 로 넘어오면서 &lt;code&gt;ADD&lt;/code&gt; 명령이 스택에 들어가고, 그 이후에야 &lt;code&gt;y&lt;/code&gt; 가 평가됩니다. 마지막으로 컨트롤 스택에 들어간 &lt;code&gt;ADD&lt;/code&gt; 명령이 끝납니다.&lt;/p&gt;

&lt;p&gt;간단한 예제를 통해 평가되는 과정을 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;eval (Add (Val 3) (Val 5)) []
eval (Val 3) [EVAL (Val 5)]
exec [EVAL (Val 5)] 3
eval (Val 5) [ADD 3]
exec [ADD 3] 5
exec [] (3 + 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;class-and-instance-declaration&#34;&gt;Class and Instance declaration&lt;/h3&gt;

&lt;p&gt;마지막으로 &lt;code&gt;class&lt;/code&gt; 대해 알아보겠습니다. 아참 시작하기 전에 먼저 아셔야 할 사실은, 하스켈에선 기술적인 이유로 &lt;code&gt;data&lt;/code&gt; 를 이용해 만든 타입만 클래스의 인스턴스가 될 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For technical reasons, only types declared using the data mechanism can be made into instances of classes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;하스켈에선 &lt;code&gt;Eq&lt;/code&gt; 클래스가 있는데요, 이렇게 정의되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class Eq where
 (==), (/=) :: a -&amp;gt; a -&amp;gt; Bool
 x /= y = not (x == y) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 말은 &lt;code&gt;Eq&lt;/code&gt; 의 인스턴스가 되는 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;(==)&lt;/code&gt; 연산을 지원해야 한다는 뜻입니다. (&lt;code&gt;/=&lt;/code&gt; 연산은 디폴트로 정의되어 있습니다.)&lt;/p&gt;

&lt;p&gt;그래서 &lt;code&gt;Eq&lt;/code&gt; 의 인스턴스인 &lt;code&gt;Bool&lt;/code&gt; 의 경우&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance Eq Bool where
  False == False = True
  True == True = True
  _ == _ = False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;물론 기본 연산은 &lt;em&gt;overrided&lt;/em&gt; 될 수 있습니다. 어떤 인스턴스의 경우 비교를 위해 &lt;code&gt;==&lt;/code&gt; 를 재정의해서 사용할 수 있을겁니다.&lt;/p&gt;

&lt;p&gt;클래스는 확장될 수 있습니다. 다른언어의 상속처럼요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class Eq a =&amp;gt; Ord a where
  (&amp;lt;), (&amp;lt;=), (&amp;gt;), (&amp;gt;=) :: a -&amp;gt; a -&amp;gt; Bool
  min, max :: a -&amp;gt; a -&amp;gt; a

  min x y | x &amp;lt;= y = x
          | otherwise = y

  max x y | x &amp;lt;= y = y
          | otherwise = x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;상대적인 크고 작음을 의미하는 &lt;code&gt;Ord&lt;/code&gt; 클래스의 경우 &lt;code&gt;Eq&lt;/code&gt; 의 연산에 추가적으로 크기 비교를 위한 연산을 가지고 있습니다. &lt;code&gt;&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/code&gt; 4개의 연산을 &lt;code&gt;Ord&lt;/code&gt; 의 인스턴스는 정의해야 하는데요, 이것만 정의하면 디폴트로 정의된 &lt;code&gt;min, max&lt;/code&gt; 도 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;아까 &lt;code&gt;Imply&lt;/code&gt; 구현할 때 &lt;code&gt;p &amp;lt;= q&lt;/code&gt; 연산 보셨죠? &lt;code&gt;Bool&lt;/code&gt; 은 &lt;code&gt;Ord&lt;/code&gt; 의 인스턴스이기도 한데요&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance Ord Bool where
  False &amp;lt; True = True
  _ &amp;lt; _ = False

  b &amp;gt; c = c &amp;lt; b
  b &amp;lt;= c = (b &amp;lt; c) || (b == c)
  b &amp;gt;= c = c &amp;lt;= b
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;derived-instances&#34;&gt;Derived instances&lt;/h3&gt;

&lt;p&gt;타입을 만들때 &lt;em&gt;built-in&lt;/em&gt; 클래스의 인스턴스로 만들기 위해 &lt;code&gt;deriving&lt;/code&gt; 키워드를 사용할 수 있습니다. 그래서 &lt;code&gt;Bool&lt;/code&gt; 같은 경우 콘솔에 출력도 되고, 문자열에서 변경도 가능하고, 비교도 가능하죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Bool = False | True
          deriving (Eq, Ord, Show, Read)
          
&amp;gt; False == False
--True

&amp;gt; False &amp;lt; True
-- True

&amp;gt; show False
-- &amp;quot;False&amp;quot;

&amp;gt; read &amp;quot;False&amp;quot;::Bool
--False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;한가지 재밌는 사실은 &lt;code&gt;Bool&lt;/code&gt; 의 &lt;em&gt;constructor&lt;/em&gt; 중에서 &lt;code&gt;False&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 보다 먼저 나오기 때문에 &lt;code&gt;False &amp;lt; True&lt;/code&gt; 라는 사실입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Shape = Circle Float | Rect Float Float
data Maybe a = Nothing | Just a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;Float&lt;/code&gt; 가 &lt;code&gt;Eq&lt;/code&gt; 의 인스턴스이기 때문에 결과적으로 이것을 파라미터로 가지는 &lt;em&gt;constructor&lt;/em&gt; &lt;code&gt;Circle&lt;/code&gt;, &lt;code&gt;Rect&lt;/code&gt; 도 &lt;code&gt;Eq&lt;/code&gt; 의 인스턴스입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; Rect 1.0 4.0 &amp;lt; Rect 2.0 3.0
True

&amp;gt; Rect 1.0 4.0 &amp;lt; Rect 1.0 3.0
False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;마찬가지로 &lt;code&gt;Maybe a&lt;/code&gt; 가 &lt;code&gt;Eq&lt;/code&gt; 의 인스턴스가 되려면 &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;Eq&lt;/code&gt; 의 인스턴스여야 합니다.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;몇개의 예제들입니다. 참고해보세요&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Data.List
import Data.Char
import Unsafe.Coerce

data Nat = Zero
         | Succ Nat
         deriving Show

nat2int :: Nat -&amp;gt; Integer
nat2int = \n -&amp;gt; genericLength [c | c &amp;lt;- show n, c == &#39;S&#39;]

int2nat 0 = Zero
int2nat n = Succ (int2nat (n-1))

add :: Nat -&amp;gt; Nat -&amp;gt; Nat
add n Zero = n
add n (Succ m) = Succ (add m n)

mult m Zero = Zero
mult m (Succ n) = add m (mult m n)

-- tree
data Tree1 = Leaf Integer
          | Node Tree Tree

leaves (Leaf _) = 1
leaves (Node l r) = leaves l + leaves r
balanced :: Tree -&amp;gt; Bool
balanced (Leaf _) = True
balanced (Node l r) = abs (leaves l - leaves r) &amp;lt;= 1 &amp;amp;&amp;amp; balanced l &amp;amp;&amp;amp; balanced r

balance :: [Integer] -&amp;gt; Tree
halve xs = splitAt (length xs `div` 2) xs
balance [x] = Leaf x
balance xs = Node (balance ys) (balance zs)
  where (ys, zs) = halve xs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;strong&gt;DelftX FP 101x&lt;/strong&gt;&lt;br /&gt;
(2) &lt;em&gt;Programming in Haskell&lt;/em&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://en.wikipedia.org/wiki/Binary_expression_tree&#34;&gt;Wiki - Binary Expression&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://imnt.tistory.com&#34;&gt;http://imnt.tistory.com&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>하스켈로 배우는 함수형 언어 7</title>
      <link>https://1ambda.github.io/haskell/intro-to-haskell-7/</link>
      <pubDate>Sat, 25 Jun 2016 01:21:50 +0900</pubDate>
      
      <guid>https://1ambda.github.io/haskell/intro-to-haskell-7/</guid>
      <description>

&lt;p&gt;&lt;em&gt;the countdown problem&lt;/em&gt; 은 프랑스 퀴즈 프로그램에서 유래한 문제입니다. 주어진 양수를 단 한번씩만 이용하여 특정 숫자를 만드는 문제입니다. 사용가능한 연산자는 &lt;code&gt;+, *, -, /&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;예를 들어 &lt;code&gt;(25 - 10) * (50 + 1) = 765&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;사람이 풀기엔 &lt;em&gt;search space&lt;/em&gt; 가 좀 넓어서 답을 한번에 찾기 어렵지만, 컴퓨터는 무한한 인내심을 가지고 있기 때문에 풀기에 적합한 문제입니다.&lt;/p&gt;

&lt;h3 id=&#34;evaluating-expressions&#34;&gt;Evaluating Expressions&lt;/h3&gt;

&lt;p&gt;이번시간엔 &lt;em&gt;bottom-up&lt;/em&gt; 으로 접근해 볼까요? 먼저 연산자타입과 이를 적용하는 함수 &lt;code&gt;apply&lt;/code&gt; 를 만들어보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Op = Add | Sub | Mul | Div

apply :: Op -&amp;gt; Int -&amp;gt; Int -&amp;gt; Int
apply Add x y = x + y
apply Sub x y = x - y
apply Mul x y = x * y
apply Div x y = x `div` y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 우리가 가진건 양수이기 때문에, 연산의 결과가 양수인지 체크하기 위한 &lt;code&gt;valid&lt;/code&gt; 함수를 만들어 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;valid :: Op -&amp;gt; Int -&amp;gt; Int -&amp;gt; Bool
valid Add _ _ = True
valid Sub x y = x &amp;gt; y
valid Mul _ _ = True
valid Div x y = x `mod` y == 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 수식을 나타내는 &lt;code&gt;Expr&lt;/code&gt; 타입과 평가하기 위한 &lt;code&gt;eval&lt;/code&gt; 함수를 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Expr = Val Int = App Op Expr Expr

eval :: Expr -&amp;gt; [Int]
eval (Val n) = [n | n &amp;gt; 0]
eval (App o l r) = [apply o x y | x &amp;lt;- eval l,
                                  y &amp;lt;- eval r,
                                  valid o x y]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기선 연산이 실패했음을 나타내기 위해 &lt;code&gt;[]&lt;/code&gt; 를 사용했습니다. &lt;code&gt;Maybe&lt;/code&gt; 타입 대신 리스트를 쓸 때의 장점은, &lt;em&gt;list comprehension&lt;/em&gt; 을 이용할 수 있다는 점이지요!&lt;/p&gt;

&lt;h3 id=&#34;formalizing-the-problem&#34;&gt;Formalizing The Problem&lt;/h3&gt;

&lt;p&gt;우리가 풀어야할 문제는 가능한 모든 조합을 탐색해야하기 때문에 다양한 조합을 만들기 위한 &lt;code&gt;choices&lt;/code&gt; 함수를 만들겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- subs [1, 2] -&amp;gt; [[], [1], [2], [1, 2]]
subs :: [a] -&amp;gt; [[a]]
subs [] = [[]]
subs (x:xs) = yss ++ map (x:) yss
  where yss = subs xs

-- interleave 1 [2, 3] -&amp;gt; [[1, 2, 3], [2, 1, 3], [2, 3, 1]]
interleave :: a -&amp;gt; [a] -&amp;gt; [[a]]
interleave x [] = [[x]]
interleave x (y:ys) = (x:y:ys) : map (y:) (interleave x ys)

-- perm [1, 2, 3] = [[1, 2, 3], [1, 3, 2], [2, 3, 1], ..]
perm :: [a] -&amp;gt; [[a]]
perm [] = [[]]
perm (x:xs) = concat (map (interleave x) (perm xs))

-- choices [1, 2] -&amp;gt; [[], [1], [2], [1, 2], [2, 1]]
choices :: [a] -&amp;gt; [[a]]
choices xs = concat (map (perm) (subs xs))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;subs&lt;/code&gt; 함수는 순서를 고려하지 않은 부분집합을, &lt;code&gt;perm&lt;/code&gt; 는 순열을 돌려줍니다. &lt;code&gt;choices&lt;/code&gt; 는 이 두 함수를 조합하여 부분집합의 순열리스트를 돌려줍니다.&lt;/p&gt;

&lt;p&gt;이제 입력한 수식이 정답인지 알려주는 &lt;code&gt;solution&lt;/code&gt; 함수를 볼까요? 입력한 수식의 결과가 주어진 수 &lt;code&gt;n&lt;/code&gt; 과 같아야 하고, 수식에 있는 숫자가 주어진 숫자들의 나열 &lt;code&gt;ns&lt;/code&gt; 와 같아야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;values :: Expr -&amp;gt; [Int]
values (Val n) = [n]
values (App _ l r) = values l ++ values r

solution :: Expr -&amp;gt; [Int] -&amp;gt; Int -&amp;gt; Bool
solution e ns n = elem (values e) (choices ns) &amp;amp;&amp;amp; eval e == [n]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force&#34;&gt;Brute Force&lt;/h3&gt;

&lt;p&gt;브루트 포스 방법으로 풀려면, 사용가능한 수들을 받아, 가능한 모든 수식을 돌려주면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- brute force
split :: [a] -&amp;gt; [([a], [a])]
split xs = [splitAt i xs | i &amp;lt;- [1..(n-1)]]
  where n = length xs

exprs :: [Int] -&amp;gt; [Expr]
exprs [] = []
exprs [n] = [Val n]
exprs ns = [e | (ls, rs) &amp;lt;- split ns
              , l &amp;lt;- exprs ls
              , r &amp;lt;- exprs rs
              , e &amp;lt;- combine l r]

combine :: Expr -&amp;gt; Expr -&amp;gt; [Expr]
combine l r = [App o l r | o &amp;lt;- [Add, Sub, Mul, Div]]

-- brute force solutions
bSolutions :: [Int] -&amp;gt; Int -&amp;gt; [Expr]
bSolutions ns n = [e | ns&#39; &amp;lt;- choices ns
                     , e &amp;lt;- exprs ns&#39;
                     , eval e == [n]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아주아주아주아주 느립니다. 제 컴퓨터에서는 2분이 지나도 답이 안나오네요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; length (Bolutions [1, 3, 7, 10, 25, 50] 765)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fast-version&#34;&gt;Fast version&lt;/h3&gt;

&lt;p&gt;어느부분을 고쳐야 더 빨라질까요? 한가지 개선할 부분은, &lt;code&gt;valid&lt;/code&gt; 가 너무 늦게 호출된다는 점입니다. 우리가 어마어마한 식을 만드는 반면, 답이 780개란 사실은 대부분의 식이 값보다는 형태에 의해 필터링 된다는 뜻입니다. 따라서 &lt;code&gt;valid&lt;/code&gt; 를 좀 더 땡길 수 있다면 계산이 훨씬 빨라질겁니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;eval :: Expr -&amp;gt; [Int]
eval (Val n) = [n | n &amp;gt; 0]
eval (App o l r) = [apply o x y | x &amp;lt;- eval l,
                                  y &amp;lt;- eval r,
                                  valid o x y]

exprs :: [Int] -&amp;gt; [Expr]
exprs [] = []
exprs [n] = [Val n]
exprs ns = [e | (ls, rs) &amp;lt;- split ns
              , l &amp;lt;- exprs ls
              , r &amp;lt;- exprs rs
              , e &amp;lt;- combine l r]

bSolutions :: [Int] -&amp;gt; Int -&amp;gt; [Expr]
bSolutions ns n = [e | ns&#39; &amp;lt;- choices ns
                     , e &amp;lt;- exprs ns&#39;
                     , eval e == [n]]


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 부분을 좀 고쳐보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;results :: [Int] -&amp;gt; [Result]
results [] = []
results [n] = [(Val n, n) | n &amp;gt; 0]
results ns = [res | (ls, rs) &amp;lt;- split ns
                  , lx &amp;lt;- results ls
                  , ry &amp;lt;- results rs
                  , res &amp;lt;- combine&#39; lx ry]

combine&#39; :: Result -&amp;gt; Result -&amp;gt; [Result]
combine&#39; (l,x) (r, y) =
  [(App o l r, apply o x y) | o &amp;lt;- [Add, Sub, Mul, Div]
                            , valid o x y]

fastSolutions :: [Int] -&amp;gt; Int -&amp;gt; [Expr]
fastSolutions ns n = [e | ns&#39; &amp;lt;- choices ns
                       , (e, m) &amp;lt;- results ns&#39;
                       , m == n]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;값을 평가하기 전에 먼저 &lt;code&gt;valid&lt;/code&gt; 를 호출하고 계산된 값을 튜플에 저장해 놓았다가 나중에 비교합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; length (Bolutions [1, 3, 7, 10, 25, 50] 765)
-- 780
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;더 개선할 수 있을까요? 음.. 생각해보니 &lt;code&gt;x * y = y * x&lt;/code&gt; 이기도 하고 &lt;code&gt;x * 1&lt;/code&gt; 은 &lt;code&gt;x&lt;/code&gt; 이기도 하네요. 이런것들을 좀 줄일수 있을겁니다. &lt;code&gt;valid&lt;/code&gt; 함수를 고쳐보도록 하지요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;valid :: Op -&amp;gt; Int -&amp;gt; Int -&amp;gt; Bool
valid Add _ _ = True
valid Sub x y = x &amp;gt; y
valid Mul _ _ = True
valid Div x y = x `mod` y == 0

-- modified
valid :: Op -&amp;gt; Int -&amp;gt; Int -&amp;gt; Bool
valid Add x y = x &amp;lt;= y 
valid Sub x y = x &amp;gt; y
valid Mul x y = x &amp;lt;= y &amp;amp;&amp;amp; x /= 1 &amp;amp;&amp;amp; y /= 1
valid Div x y = x `mod` y == 0 &amp;amp;&amp;amp; y /= 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;x &amp;lt;= y&lt;/code&gt; 로 만들어 중복을 제거하고 &lt;code&gt;x /= 1&lt;/code&gt; 을 이용해 1을 곱한 수식을 제거했습니다. 결과가 정말 빠르게 나옵니다.&lt;/p&gt;

&lt;p&gt;책에서 말하기를 브루트 포스 방법은 44초, 그 다음버전은 4초, 마지막 버전은 0.44 초 만에 계산이 끝난다고 합니다. 연산 시간이 어마어마하게 줄어들었죠?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; length (Bolutions [1, 3, 7, 10, 25, 50] 765)
-- 49
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;strong&gt;DelftX FP 101x&lt;/strong&gt;&lt;br /&gt;
(2) &lt;em&gt;Programming in Haskell&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>하스켈로 배우는 함수형 언어 8</title>
      <link>https://1ambda.github.io/haskell/intro-to-haskell-8/</link>
      <pubDate>Sat, 25 Jun 2016 01:21:52 +0900</pubDate>
      
      <guid>https://1ambda.github.io/haskell/intro-to-haskell-8/</guid>
      <description>

&lt;p&gt;고차함수가 있는 다른언어와 비교했을 때 하스켈은 무슨 특징이 있을까요? 하스켈은 &lt;em&gt;expression&lt;/em&gt; 을 평가하기 위해 디폴트로 &lt;em&gt;lazy evaluation&lt;/em&gt; 을 사용한다는 점에서 다른 언어들과 다릅니다.&lt;/p&gt;

&lt;p&gt;이번시간엔 &lt;em&gt;evaluation&lt;/em&gt; 의 개념부터 시작해서, 다양한 종류의 &lt;em&gt;evaluation&lt;/em&gt; 전략들을 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&#34;evaluation&#34;&gt;Evaluation&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Avoid doing &lt;strong&gt;unnecessay evaluation&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Allows programs to be &lt;strong&gt;more modular&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Allows us to program with &lt;strong&gt;infinite lists&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하스켈은 &lt;em&gt;lazy evaluation&lt;/em&gt; 을 이용해 위에 나열한 것들을 제공합니다. &lt;em&gt;lazy evaluation&lt;/em&gt; 을 이야기 하기 전에 먼저 &lt;em&gt;evaluation&lt;/em&gt; 이 무엇인지 살펴봅시다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Basically, expressions are evaluated or reduced by successively applying definitions until no further simplification is possible&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를 들어서 &lt;code&gt;square n = n * n&lt;/code&gt; 이란 &lt;em&gt;definition&lt;/em&gt; 이 있을때, &lt;em&gt;expression&lt;/em&gt; &lt;code&gt;square(3 + 4)&lt;/code&gt; 는 이렇게 두 가지 방식으로 평가될 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;square (3 + 4)
square 7
7 * 7
49

-- bad
square (3 + 4)
(3 + 4) * (3 + 4)
7 * (3 + 4)
7 * 7
49
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약에 아래 버전처럼 &lt;code&gt;(3 + 4) * (3 + 4)&lt;/code&gt; 로 평가된다면, 똑같은 계산을 두번이나 하게 될 겁니다. 더 심각한 문제는 &lt;em&gt;side effect&lt;/em&gt; 가 발생한다면 값이 달라질 수도 있다는 것이지요!&lt;/p&gt;

&lt;p&gt;아래 예제를 한번 봅시다. &lt;em&gt;evaluation&lt;/em&gt; 전략에 따라 값이 달라지는 것을 보여줍니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- initially, n := 0

-- left first
n + (n := 1)
0 + (n := 1)
0 + 1
1

-- right first
n + (n := 1)
n + 1
1 + 1
2
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;FACT:&lt;/strong&gt; In Haskell, two diffrent (but terminating) ways of evaluating the same expression will always give the same final result.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다행히도 하스켈은 어떤 전략을 사용하든 &lt;em&gt;terminating expression&lt;/em&gt; 에 대해서는 항상 같은 결과를 돌려줍니다.&lt;/p&gt;

&lt;h3 id=&#34;reduction-strategies&#34;&gt;Reduction Strategies&lt;/h3&gt;

&lt;p&gt;일반적으로 평가방법은 크게 두 가지로 나눌 수 있습니다. 어떤 &lt;em&gt;reducible subexpression (redex)&lt;/em&gt; 를 선택하냐에 따라&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Innermost reduction:&lt;/strong&gt; An inner most redex is always reduced&lt;br /&gt;
(2) &lt;strong&gt;Outermost reduction:&lt;/strong&gt; An outermost redex is always reduced&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;loop = tail loop

// innermost reduction
fst (1, loop)
fst (1, tail loop)
fst (1, tail (tail loop))
...

// outermost reduction
fst (1, lop)
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 결과를 보면 &lt;em&gt;innermost&lt;/em&gt; 가 종료되지 않는 경우에도, &lt;em&gt;outermost&lt;/em&gt; 는 결과를 돌려줄 수 있다는 사실을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;또한 어느 하나의 &lt;em&gt;reduction sequence&lt;/em&gt; 라도 종료된다면 &lt;em&gt;outermost reduction&lt;/em&gt; 도 종료됩니다. 같은 결과를 돌려주면서요. 원문을 첨부하면,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For a given expression if there exists any reduction sequence that terminates, then outermost reduction &lt;strong&gt;also&lt;/strong&gt; terminates, with the same result&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;innermost&lt;/em&gt; 에 비해 더 많은 경우에 종료되므로 &lt;em&gt;outermost&lt;/em&gt; 가 좋다고 볼 수도 있겠습니다. 그러나, &lt;em&gt;outermost reduction&lt;/em&gt; 은 좀 비효율적입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;// innermost
square (3 + 4)
square 7
7 * 7
49

// outermost
square (3 + 4)
(3 + 4) * (3 + 4)
7 * (3 + 4)
7 * 7
49
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 하스켈에서는 &lt;em&gt;outermost&lt;/em&gt; 에 &lt;em&gt;sharing&lt;/em&gt; 을 더해 &lt;em&gt;lazy evalution&lt;/em&gt; 이라 부르고 이 방법을 &lt;em&gt;evalution&lt;/em&gt; 에 이용합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;square (3 + 4) -- sharing, n = (3 + 4)
= n * n -- reduced shared expression `n` into 7
= 7 * 7
= 49
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;innermost, outermost&lt;/em&gt; 예제를 좀 더 살펴봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mult :: (Int, Int) -&amp;gt; Int
mult (x, y) = x * y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;mult(1 + 2, 3 + 4)&lt;/code&gt; 를 &lt;em&gt;innermost&lt;/em&gt; 로 평가한다고 한다면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mult(1 + 2, 3 + 4)
mult(3, 3 + 4) -- conventionally, we select left innermost
mult(3, 7)
3 * 7 -- apply outermost
24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;innermost&lt;/em&gt; 는 &lt;em&gt;argument (인자)&lt;/em&gt; 가 먼저 평가 되어야 하기 때문에, 인자가 &lt;em&gt;value&lt;/em&gt; 인 경우 사용할 수 있습니다. 반대로 &lt;em&gt;outermost&lt;/em&gt; 전략을 사용한다고 결정하려면 인자가 &lt;em&gt;name&lt;/em&gt; 이어야 합니다.&lt;/p&gt;

&lt;p&gt;어떤 함수들의 경우는 &lt;em&gt;outermost&lt;/em&gt; 를 사용함에도 먼저 인자가 평가되어야 합니다. 예를 들어 &lt;code&gt;*, +&lt;/code&gt; 같은 &lt;em&gt;built-in operator&lt;/em&gt; 는 무조건 인자가 먼저 평가되야 합니다. 이런 함수들을 &lt;em&gt;strict&lt;/em&gt; 하다고 말 합니다.&lt;/p&gt;

&lt;p&gt;좀 더 엄밀한 정의는&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A function f is said to be strict if, when applied to a nonterminating expression, it also fails to terminate.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;mult&lt;/code&gt; 를 &lt;em&gt;curried function&lt;/em&gt; 으로 재 작성해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;mult :: Int -&amp;gt; Int -&amp;gt; Int
mult x = \y -&amp;gt; x * y

-- evaluation
mult (1 + 2) (3 + 4)
mult 3 (3 + 4)
(\y -&amp;gt; 3 * y)(3 + 4)
(\y -&amp;gt; 3 * y)(7)
3 * 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 인자가 한턴에 하나씩 계산됩니다. 이는 &lt;code&gt;mult 3 (3 + 4)&lt;/code&gt; 에서 &lt;em&gt;left, innermost redex&lt;/em&gt; 가 &lt;code&gt;mult 3&lt;/code&gt; 이기 때문입니다. &lt;code&gt;mult (3, 3 + 4)&lt;/code&gt; 에선 &lt;code&gt;3 + 4&lt;/code&gt; 가 &lt;em&gt;left, innermost redex&lt;/em&gt; 였지만요.&lt;/p&gt;

&lt;p&gt;참고로 하스켈에서 &lt;em&gt;lambda expression&lt;/em&gt; 내부의 &lt;em&gt;redex&lt;/em&gt; 를 선택하는건 불가능합니다. 이는 람다도 함수이고, 함수 내부는 볼 수 없는 &lt;em&gt;black box&lt;/em&gt; 이기 때문입니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that in Haskell, the selection of redexes within lambda expressions
is prohibited. The rational for not “reducing under lambdas” is that functions are viewed as black boxes that we are not permitted to look inside.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;일반적으로 &lt;em&gt;innermost&lt;/em&gt; 전략을 &lt;em&gt;call by value&lt;/em&gt;, &lt;em&gt;outermost&lt;/em&gt; 전략을 &lt;em&gt;call by name&lt;/em&gt; 이라 부릅니다.&lt;/p&gt;

&lt;h3 id=&#34;infinite-list&#34;&gt;Infinite List&lt;/h3&gt;

&lt;p&gt;여기 &lt;code&gt;1&lt;/code&gt; 의 무한한 나열을 표현하는 &lt;code&gt;ones&lt;/code&gt; 에 대해 &lt;em&gt;expression&lt;/em&gt; &lt;code&gt;head ones&lt;/code&gt; 가 어떻게 평가되는지 &lt;em&gt;innermost&lt;/em&gt; 와 &lt;em&gt;lazy evaluation&lt;/em&gt; 의 두 가지 방법을 비교해 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ones :: [Int]
ones = 1 : ones

-- innermost
head one
head (1 : one)
head (1 : 1 : one)
...

-- lazy evaluation
head one
head (1: ones)
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;innermost&lt;/em&gt; 의 경우에는 &lt;em&gt;evaluation&lt;/em&gt; 이 끝나지 않습니다. 반면 &lt;em&gt;lazy evaluation&lt;/em&gt; 은 식이 끝나면서 결과를 얻을 수 있죠.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Using &lt;strong&gt;lazy evaluation&lt;/strong&gt;, expressions are only evaluated as much as required to produce the final result&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉 필요한 만큼만 평가됩니다. 따라서 &lt;em&gt;lazy evaluation&lt;/em&gt; 을 이용한 평가방법이 있으므로 &lt;code&gt;ones = 1 : ones&lt;/code&gt; 처럼 무한할 &lt;strong&gt;가능성이 있는&lt;/strong&gt; 데이터를 표현할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;modular-programming&#34;&gt;Modular Programming&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;take 5 ones
-- [1, 1, 1, 1, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제에서 볼 수 있듯이 &lt;em&gt;lazy evaluation&lt;/em&gt; 을 이용하면 &lt;em&gt;expression&lt;/em&gt; 을 두 부분으로 나눕니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Control Part:&lt;/strong&gt; &lt;code&gt;take 5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data:&lt;/strong&gt; &lt;code&gt;ones&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인자를 받아 주어진 숫자만큼 복사하는 &lt;code&gt;replicate&lt;/code&gt; 함수도 만들어 볼까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;replicate&#39; :: Int -&amp;gt; a -&amp;gt; [a]
replicate&#39; 0 _ = []
replicate&#39; n x = x : replicate&#39; (n - 1) x
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;generate-primes&#34;&gt;Generate Primes&lt;/h3&gt;

&lt;p&gt;무한한 길이의 원소를 표현할 수 있다는 법을 배웠습니다. 이 방법을 이용해 존재하는 모든 소수의 집합을 표현하는 리스트를 만들어 볼까요?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Sieve of Eratosthenes (에라토스테네스의 체)&lt;/em&gt; 란 방법을 사용하겠습니다. 알고리즘은 &lt;a href=&#34;http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&#34;&gt;여기&lt;/a&gt; 를 참조하세요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;primes :: [Int]
primes = seive [2..]

seive :: [Int] -&amp;gt; [Int]
seive (p : xs) = p : [x | x &amp;lt;- xs, x `mod` p /= 0]

take 10 primes
-- [2,3,5,7,9,11,13,15,17,19]

takeWhile (&amp;lt;15) primes
-- [2, 3, 5, 7, 11, 13]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;strict-application&#34;&gt;Strict Application&lt;/h3&gt;

&lt;p&gt;하스켈에선 &lt;em&gt;lazy evaluation&lt;/em&gt; 이 기본이지만, &lt;em&gt;strict&lt;/em&gt; 버전으로 함수를 적용할 수 있는 방법도 제공합니다. &lt;code&gt;$!&lt;/code&gt; 키워드를 이용하면 되는데요, &lt;code&gt;f $! x&lt;/code&gt; 같은 경우 &lt;code&gt;f&lt;/code&gt; 를 적용하기 전에 &lt;code&gt;x&lt;/code&gt; 가 모두 평가되야 합니다.&lt;/p&gt;

&lt;p&gt;더 엄밀히 말하면 &lt;em&gt;top-level of evaluation&lt;/em&gt; 이 이루어지는데요, 인자 &lt;code&gt;x&lt;/code&gt; 의 타입이 &lt;code&gt;Int&lt;/code&gt; 나 &lt;code&gt;Bool&lt;/code&gt; 같은 &lt;em&gt;basic type&lt;/em&gt; 일 경우는 &lt;em&gt;complete evaluation&lt;/em&gt; 이 이루어집니다.&lt;/p&gt;

&lt;p&gt;반대로, &lt;code&gt;(Int, Bool)&lt;/code&gt; 같은 복합타입이라면 &lt;em&gt;pair of expression&lt;/em&gt; 이 얻어질 때 까지만 평가가 이루어집니다. 유사하게 타입이 리스트라면 &lt;code&gt;[]&lt;/code&gt; 나 &lt;code&gt;a : b&lt;/code&gt; 같은 컨싱이 얻어질때까지만 평가가 이루어집니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;More formally, an expression of the form &lt;code&gt;f $! x&lt;/code&gt; is only a redex once evaluation of the argument x, using lay evaluaion as normal, has reached the point where it is known that the result is not an undefined value, at which point the expression can be reduced to the normal application &lt;code&gt;f x&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;예를 들어 &lt;code&gt;square $! (1 + 2)&lt;/code&gt; 의 경우&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;square $! (1 + 2)
square $! 3
square 3
3 * 3
9 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다수개의 인자를 갖는 &lt;em&gt;curried function&lt;/em&gt; 과 &lt;code&gt;$!&lt;/code&gt; 가 쓰일 경우에는 다양한 형태가 될 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;(f $! x) y    -- forces top-level evaluation of x
(f x) $! y    -- forces top-level evaluation of y
(f $! x) $! y -- forces top-level evaluation of x and y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;하스켈에서 &lt;em&gt;strict application&lt;/em&gt; 은 주로 프로그램의 &lt;em&gt;space performance&lt;/em&gt; 을 개선하기 위해 사용됩니다. 예를 들어 다음과 같은 &lt;code&gt;sumWith&lt;/code&gt; 함수가 있다고 합시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sumWith :: Int -&amp;gt; [Int] -&amp;gt; Int
sumWith v [] = v
sumWith v (x:xs) sumWith (v + x) xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;lazy evaluation&lt;/em&gt; 에서는&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sumWith 0 [1, 2, 3]
sumWith (0 + 1) [2, 3]
sumWith ((0 + 1) + 2) [3]
sumWith (((0 + 1) + 2) + 3) []
(((0 + 1) + 2) + 3)
...
...
6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;계산 전에 &lt;code&gt;(((0 + 1) + 2) + 3)&lt;/code&gt; 가 만들어 지는걸 볼 수 있습니다. &lt;code&gt;sumWith 0 [1.. 10000]&lt;/code&gt; 같은 큰 수의 계산일 경우 공간이 좀 아까울 수 있지요.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code&gt;sumWith&lt;/code&gt; 에 &lt;code&gt;$!&lt;/code&gt; 를 이용하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sumWith v [] = v
sumWith v (x:xs) = (sumWith $! (v + x)) xs

sumWith 0 [1, 2, 3]
sumWtih $! (0 + 1) [2, 3]
sumWith $! 1 [2, 3]
sumWith 1 [2, 3]
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sumWith&lt;/code&gt; 뿐만 아니라 고차함수인 &lt;code&gt;foldl&lt;/code&gt; 등에도 적용해 볼 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;foldl&#39; :: (a -&amp;gt; b -&amp;gt; a) -&amp;gt; a -&amp;gt; [b] -&amp;gt; a
foldl&#39; f v [] = v
foldl&#39; f v (x:xs) ((foldl&#39; f) $! (f v x)) xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이러면, &lt;code&gt;sumWith&lt;/code&gt; 를 &lt;code&gt;foldl&#39; (+)&lt;/code&gt; 로 정의할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;p&gt;(1) &lt;strong&gt;DelftX FP 101x&lt;/strong&gt;&lt;br /&gt;
(2) &lt;em&gt;Programming in Haskell&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>하스켈로 배우는 함수형 언어 9</title>
      <link>https://1ambda.github.io/haskell/intro-to-haskell-9/</link>
      <pubDate>Sat, 25 Jun 2016 01:21:53 +0900</pubDate>
      
      <guid>https://1ambda.github.io/haskell/intro-to-haskell-9/</guid>
      <description>

&lt;h3 id=&#34;intro&#34;&gt;Intro&lt;/h3&gt;

&lt;p&gt;이번시간엔 함수형 프로그래밍에서 &lt;em&gt;property&lt;/em&gt; 를 증명하는 방법인 &lt;em&gt;induction&lt;/em&gt; 에 대해 배워보고, 하스켈에서 알고리즘의 성능이 어떨까에 대해 좀 논의해 보겠습니다. 마지막엔 &lt;em&gt;Rose Tree&lt;/em&gt; 를 구현하면서 &lt;em&gt;Functor, Monoid, Foldable&lt;/em&gt; 등에 대해 좀 알아봅시다.&lt;/p&gt;

&lt;p&gt;수학에서 다음 두 식은 똑같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xz + yz = (x + y)z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;근데, 잘 보면 연산의 수가 다릅니다. 좌측은 3개고, 우측은 2개면 되지요. 하스켈에서도 이런 생각들을 좀 해봅시다. &lt;em&gt;built-in&lt;/em&gt; 연산자에 대해서뿐만 아니라, &lt;em&gt;user-defined&lt;/em&gt; 연산자 (함수) 에 대해서도 생각할 수 있으니까, 좀 다양하겠네요.&lt;/p&gt;

&lt;h3 id=&#34;reasoning-about-haskell&#34;&gt;Reasoning about Haskell&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;double :: Int -&amp;gt; Int
double x = x + x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 모든 &lt;code&gt;x + x&lt;/code&gt; 는 &lt;code&gt;double x&lt;/code&gt; 로, 바꿀 수 있죠. 그 반대도 가능하고요. 근데, &lt;em&gt;multiple equations&lt;/em&gt; 를 쓰면 좀 얘기가 다릅니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;isZero :: Int -&amp;gt; Bool
isZero 0 = True
isZero n = False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;첫번째 식 &lt;code&gt;isZero 0 = True&lt;/code&gt; 는 어느 방향으로든 자유롭게 적용가능하지만, 두번째는 아닙니다. 사실은 이런 뜻이거든요&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;isZero 0          = True
isZero n | n /= 0 = False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 좌우를 쉽게 치환할 수 있습니다. 이렇게 식의 순서에 의존하지 않는 패턴을 &lt;em&gt;disjoint&lt;/em&gt; 혹은 &lt;em&gt;non-overlapping&lt;/em&gt; 이라 부릅니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Patterns that do not rely on the order in which the are matched are called &lt;em&gt;disjoint&lt;/em&gt; or &lt;em&gt;non-overlapping&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로그램에 대해서 &lt;em&gt;reasoning&lt;/em&gt; 할 땐 가능하면 &lt;em&gt;non-overlapping&lt;/em&gt; 패턴을 사용하는게 좋습니다. &lt;em&gt;standard library&lt;/em&gt; 에 있는 대부분의 함수들은 이런식으로 작성 되어있습니다.&lt;/p&gt;

&lt;h3 id=&#34;simple-examples&#34;&gt;Simple examples&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse :: [a] -&amp;gt; [a]
reverse [] = []
reverse (x:xs) reverse xs ++ [x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 구현을 보면 &lt;code&gt;reverse [x] = [x]&lt;/code&gt; 입니다. 근데, 이걸 연산하려면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse [x]
reverse (x:[])
reverse [] ++ [x]
[] ++ [x]
[x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;code&gt;reverse [x] = [x]&lt;/code&gt; 를 추가해서 효율적인 구현을 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;induction-on-numbers&#34;&gt;Induction on numbers&lt;/h3&gt;

&lt;p&gt;함수형 프로그램은 종종 재귀를 이용해 작성되는데, 여기에 &lt;em&gt;induction&lt;/em&gt; 을 이용할 수 있습니다. 예전에 본 자연수 타입 &lt;code&gt;Nat&lt;/code&gt; 의 정의를 떠올려 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Nat = Zero | Succ Nat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떤 유한한 수에 대해서 어떤 &lt;em&gt;property&lt;/em&gt; &lt;code&gt;p&lt;/code&gt; 를 증명하려고 할 때, 먼저 &lt;em&gt;base case&lt;/em&gt; 인 &lt;code&gt;Zero&lt;/code&gt; 에 대해 보이고, &lt;em&gt;inductive case&lt;/em&gt; &lt;code&gt;Succ&lt;/code&gt; 에 대해서 보이면 됩니다. 더 자세히는, 어떤 자연수 &lt;code&gt;n&lt;/code&gt; 에 대해서 &lt;code&gt;p&lt;/code&gt; 가 참일때 (&lt;em&gt;induction hypothesis&lt;/em&gt;), &lt;code&gt;Succ n&lt;/code&gt; 에 대해서도 참임을 보이면 됩니다.&lt;/p&gt;

&lt;p&gt;구체적인 예제를 보도록 하죠. 두 &lt;code&gt;Nat&lt;/code&gt; 를 더해 &lt;code&gt;Nat&lt;/code&gt; 를 만드는 &lt;code&gt;add&lt;/code&gt; 함수를 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;add :: Nat -&amp;gt; Nat -&amp;gt; Nat
add Zero m = m
add (Succ n) m = Succ (add n m)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;첫 번째씩 &lt;code&gt;add Zero m = m&lt;/code&gt; 은 모든 자연수 &lt;code&gt;m&lt;/code&gt; 에 대해 참이기 때문에, &lt;code&gt;add n Zero = n&lt;/code&gt; 을 증명하겠습니다. 이걸 가설 &lt;code&gt;p&lt;/code&gt; 라 부릅시다.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;base case&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;add Zero Zero
Zero
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2) &lt;em&gt;inductive case&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이 단계에서는 &lt;code&gt;p&lt;/code&gt; 가 자연수 &lt;code&gt;n&lt;/code&gt; 에 대해 참일때 &lt;code&gt;p (Succ n)&lt;/code&gt; 이 참임을 보이면 됩니다. 다시 말해 가설 &lt;code&gt;p&lt;/code&gt; &lt;code&gt;add n Zero = n&lt;/code&gt; 을 이용해 &lt;code&gt;add (Succ n) Zero = Succ n&lt;/code&gt; 임을 보여야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;add (Succ n) Zero -- should be `Succ n`

= Succ (add n Zero) 

= Succ n -- by induction hypothesis
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다른 속성으로 &lt;em&gt;associativity&lt;/em&gt; 를 증명할 수도 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;add x (add y z) = add (add x y) z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;인자가 3개인데 무엇부터 시작해야 할까요? &lt;code&gt;add&lt;/code&gt; 는 패턴매칭을 이용해 작성되었고, 재귀 부분이  첫번째 인자를 주로 이용하므로 &lt;code&gt;x&lt;/code&gt; 를 선택하는게 자연스러울 겁니다. &lt;code&gt;y&lt;/code&gt;는 1 번 쓰이고, &lt;code&gt;z&lt;/code&gt;는 첫번째 인자로 한번도 안쓰이네요.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;base case&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;add Zero (y z) -- should be `add (add Zero y) z`

= add y z
= add (add Zero y) z -- unapplying add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2) &lt;em&gt;inductive case&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;p&lt;/code&gt; 는 `add x (add y z) = add (add x y) z&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;add (Succ x) (add y z) -- should be &#39;add (add (Succ x) y) z`

= Succ (add x (add y z)) -- apply outer add
= Succ (add (add x y) z) -- induction hypothesis
= add (Succ (add x y) z) -- unapply outer add
= add (add (Succ x) y) z -- unapply inner add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 &lt;em&gt;unapply, apply&lt;/em&gt; 를 편하게 할 수 있는 이유는 위에서 &lt;code&gt;add&lt;/code&gt; 를 &lt;em&gt;non-overlapping&lt;/em&gt; 패턴으로 작성했기 때문이지요.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;induction&lt;/em&gt; 을 &lt;em&gt;recursive type&lt;/em&gt; 인 &lt;code&gt;Nat&lt;/code&gt; 에 적용했지만, &lt;code&gt;Integer&lt;/code&gt; 타입에도 적용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;어떤 &lt;em&gt;property&lt;/em&gt; &lt;code&gt;p&lt;/code&gt; 를 &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; 에 대해 증명하려고 할 때는 먼저 &lt;em&gt;base case&lt;/em&gt; 인 &lt;code&gt;0&lt;/code&gt; 에 대해 참임을 보이고, &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; 일때, &lt;code&gt;n + 1&lt;/code&gt; 에 대해서도 참임을 보이면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;replicate :: Int -&amp;gt; a -&amp;gt; [a]
replicate 0 _       = []
replicate (n + 1) x = x : replicate n x
-- replicate n x = x : replicate (n - 1) x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;요즘 컴파일러는 &lt;code&gt;n + 1&lt;/code&gt; 패턴을 막아서 아마 주석처리부분처럼 작성해야 합니다. 무튼 저 정의대로만 보면, &lt;code&gt;n&lt;/code&gt; 에 대해 참일때 &lt;code&gt;n + 1&lt;/code&gt; 일때도 참임을 보이는건 정말 쉽습니다. 정의 그 자체가 &lt;em&gt;induction&lt;/em&gt; 이니까요.&lt;/p&gt;

&lt;h3 id=&#34;induction-on-lists&#34;&gt;Induction on lists&lt;/h3&gt;

&lt;p&gt;재귀는 자연수에만 쓸 수 있는건 아니고, 리스트와 같은 다양한 재귀적인 타입에 사용할 수 있습니다. &lt;em&gt;base case&lt;/em&gt; 는 &lt;code&gt;[]&lt;/code&gt; 이 되겠고, &lt;em&gt;successor function&lt;/em&gt; 은 &lt;code&gt;:&lt;/code&gt; 이 되겠네요.&lt;/p&gt;

&lt;p&gt;그러므로 리스트에 대해 어떤 &lt;em&gt;property&lt;/em&gt; &lt;code&gt;p&lt;/code&gt; 를 증명하려면, 먼저 &lt;code&gt;[]&lt;/code&gt; 에 대해 참임을 보이고 &lt;code&gt;p xs&lt;/code&gt; 가 참일때 &lt;code&gt;p x:xs&lt;/code&gt; 가 참임을 보이면 됩니다. &lt;del&gt;참 쉽죠?&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;reverse&lt;/em&gt; 연산에 대해 &lt;code&gt;reverse (reverse xs) = xs&lt;/code&gt; 를 증명해 봅시다.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;base case&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse (reverse []) -- should be &#39;[]&#39;

= reverse []
= []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2) &lt;em&gt;inductive case&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- induction hypothesis

reverse (reverse xs) = xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;증명은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse (reverse x:xs) -- = x:xs

= reverse (reverse xs ++ [x])
= reverse [x] ++ reverse (reverse xs) -- by distributivity
= [x] ++ xs -- induction hypothesis
= x:xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 사용한 성질중에 하나가 &lt;em&gt;distributivity&lt;/em&gt; 인데,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- induction hypothesis
reverse (xs ++ ys) = reverse ys ++ reverse xs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1) &lt;em&gt;base-case&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse ([] ++ ys) -- reverse ys ++ reverse [] 

= reverse ys
= [] ++ reverse ys -- unapply ++
= reverse [] ++ reverse ys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2) &lt;em&gt;inductive case&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse ((x:xs) ++ ys) -- reverse ys ++ reverse (x:xs)

= reverse (x:(xs ++ ys))
= reverse (xs ++ ys) ++ [x]
= reverse ys ++ (reverse xs ++ [x])
= reverse ys ++ (reverse (x:xs)) -- unapply second reverse
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 증명은 &lt;code&gt;++&lt;/code&gt; 가 &lt;em&gt;associative&lt;/em&gt; 라는 사실을 이용해 증명했는데, 이것도 마찬가지로 증명할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;marking-append-vanish&#34;&gt;Marking append vanish&lt;/h3&gt;

&lt;p&gt;많은 재귀 함수들이 &lt;code&gt;++&lt;/code&gt; 연산을 이용해 작성되었는데, 편하긴 하지만 재귀적으로 사용되면 비용이 좀 듭니다. 따라서 이번에는 &lt;code&gt;++&lt;/code&gt; 를 제거 해서 좀 더 효율적으로 함수를 작성해봅시다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reverse&lt;/code&gt; 함수부터 해 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse :: [a] -&amp;gt; [a]
reverse [] = []
reverse (x:xs) = reverse xs ++ [x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 작성된 &lt;code&gt;reverse&lt;/code&gt; 함수의 성능은 어떨까요? 먼저 생각해 볼 것은 &lt;code&gt;xs ++ ys&lt;/code&gt; 을 &lt;em&gt;evaluation&lt;/em&gt; 하기 위해 얼마의 스텝이 필요할까? 입니다. &lt;code&gt;xs ++ ys&lt;/code&gt; 는 &lt;code&gt;xs&lt;/code&gt; 를 쪼개가면서 &lt;code&gt;xs&lt;/code&gt; 에 붙이기 때문에, &lt;code&gt;xs + 1&lt;/code&gt; 만큼의 스텝이 필요하죠.&lt;/p&gt;

&lt;p&gt;참고로 &lt;code&gt;append&lt;/code&gt; 의 정의는&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;append :: [a] -&amp;gt; [a] -&amp;gt; [a] 
append [ ] xs    = xs
append (x:xs) ys = x : append xs ys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;좀 간단히 생각하기 위해 &lt;code&gt;xs, ys&lt;/code&gt; 가 &lt;em&gt;fully evaluated&lt;/em&gt; 되었다 합시다. 그 결과로 &lt;code&gt;++&lt;/code&gt; 는 첫 번째 인자 &lt;code&gt;xs&lt;/code&gt; 의 길이에 비례하는 &lt;em&gt;linear time&lt;/em&gt; 퍼포먼스를 보여줍니다.&lt;/p&gt;

&lt;p&gt;결과적으로 &lt;code&gt;reverse xs&lt;/code&gt; 의 성능은, 길이를 &lt;code&gt;n&lt;/code&gt; 이라 했을 때 &lt;code&gt;1 + 2 + ... + n + 1&lt;/code&gt; 입니다. &lt;code&gt;(n^2 + 3n + 2) / 2&lt;/code&gt; 겠네요. 이는 &lt;code&gt;reverse&lt;/code&gt; 함수가 &lt;em&gt;quadratic time&lt;/em&gt; 의 함수라는걸 말해줍니다. 1000 개를 뒤집으려면, 10000000 번만큼 연산을 해야한다는 소리지요.&lt;/p&gt;

&lt;p&gt;다행히도 &lt;em&gt;induction&lt;/em&gt; 을 이용해 쓸모없는 &lt;code&gt;++&lt;/code&gt; 부분을 제거하고, 성능을 개선할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reverse&lt;/code&gt; 와 &lt;code&gt;++&lt;/code&gt; 를 합친 좀 더 &lt;em&gt;general&lt;/em&gt; 한 함수를 만듭시다. &lt;code&gt;reverse&#39;&lt;/code&gt; 라 부를건데, &lt;code&gt;reverse xs += ys&lt;/code&gt; 와 같은 일을 할겁니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse&#39; xs ys -- = reverse xs ++ ys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 만들면 &lt;code&gt;reverse&lt;/code&gt; 자체는 이렇게 정의할 수 있습니다. &lt;code&gt;[]&lt;/code&gt; 가 &lt;em&gt;append&lt;/em&gt; 를 위한 &lt;em&gt;identity&lt;/em&gt; 라는 점을 이용한 것이지요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse xs = reverse&#39; xs []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;신기하게도 이 속성을 증명하면서, 이 &lt;code&gt;reverse&#39;&lt;/code&gt; 의 정의 자체를 얻을 수 있습니다.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;base case&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse&#39; [] ys 

= reverse [] ++ ys 
= [] ++ ys
= ys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2) &lt;em&gt;inductive case&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse&#39; (x:xs) ys

= reverse (x:xs) ++ ys
= (reverse xs ++ [x]) ++ ys
= reverse xs ++ ([x] ++ ys]) -- by associativity of ++
= reverse&#39; xs ([x] ++ ys) -- by induction hypothesis
= reverse&#39; xs (x:ys)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;code&gt;reverse&#39;&lt;/code&gt; 의 정의는&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse&#39; [a] -&amp;gt; [a] -&amp;gt; [a]
reverse&#39; [] y = ys
reverse&#39; (x:xs) ys = reverse&#39; xs (x:ys)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아까 언급했던대로 &lt;code&gt;reverse&lt;/code&gt; 를 다시 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;reverse :: [a] -&amp;gt; [a]
reverse xs = reverse&#39; xs []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제는 &lt;code&gt;x:ys&lt;/code&gt; 처럼, 하나씩 분리해 나가면서 붙기때문에 성능이더 빠릅니다. 정확히는 &lt;code&gt;n + 2&lt;/code&gt;  연산이 필요하지요. &lt;em&gt;linear time&lt;/em&gt; 입니다.&lt;/p&gt;

&lt;p&gt;사실은 7장 에서 이미 개선된 &lt;em&gt;reverse&lt;/em&gt; 를 봤었습니다. &lt;code&gt;reverse = foldl (:) []&lt;/code&gt; 기억 나시나요?&lt;/p&gt;

&lt;h4 id=&#34;flatten&#34;&gt;flatten&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Tree = Leaf Int | Node Tree Tree
flatten :: Tree -&amp;gt; [Int]
flatten (Leaf n) = [n]
flatten (Node l r) = flatten l ++ flatten r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 &lt;code&gt;flatten&lt;/code&gt; 도 &lt;code&gt;++&lt;/code&gt; 때문에 느립니다. 위 &lt;code&gt;reverse&lt;/code&gt; 처럼 개선해 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;flatten&#39; t ns = flatten t ++ [ns]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1) &lt;em&gt;base case&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;flatten&#39; (Leaf n) ns

= flatten (Leaf n) ++ ns
= [n] ++ ns
n:ns
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2) &lt;em&gt;inductive case&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;flatten&#39; (Node l r) ns

= (flatten l ++ flatten r) ++ ns
= flatten l ++ (flatten r ++ ns) -- associativity
= flatten&#39; l ++ (faltten r ++ ns) -- hypothesis
= flatten&#39; l (flatten&#39; r ns)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;따라서 &lt;code&gt;flatten&#39;&lt;/code&gt;, &lt;code&gt;flatten&lt;/code&gt; 은&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;flatten&#39; :: Tree -&amp;gt; [Int] -&amp;gt; [Int]
flatten&#39; (Leaf n) ns = n:ns
flatten&#39; (Node l r) ns = flatten&#39; l (flatten&#39; r ns)

flatten :: Tree -&amp;gt; [Int]
flatten t = flatten&#39; t []
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;compiler-correctness&#34;&gt;Compiler Correctness&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Expr = Val Int | Add Expr Expr

eval :: Expr -&amp;gt; Int
eval (Val n) = n
eval (Add x y) = eval x + eval y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;지난번에 만들었던 이 계산 기계를 잘 보면, &lt;em&gt;expression&lt;/em&gt; 이 간접적으로 &lt;em&gt;evaluated&lt;/em&gt; 됩니다. 스택을 이용해 실행되는 코드의 도움을 받아서요.&lt;/p&gt;

&lt;p&gt;자세히 보면 스택은 &lt;em&gt;integer list&lt;/em&gt; 고, 코드는 &lt;em&gt;push, add&lt;/em&gt; 연산의 리스트입니다. 따라서&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;type Stack = [Int]
type Code = [Op]
data Op = PUSH Int | ADD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결국 코드를 실행한다는 말은 초기 스택을 받아, 이걸 이용해 계산을 하고 다시 스택을 돌려준다는 뜻입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;exec :: Code -&amp;gt; Stack -&amp;gt; Stack
exec []         s       = s
exec (PUSH n:c) s       = exec c (n:s)
exec (ADD:c)    (m:n:s) = exec c (m+n:s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;Expr&lt;/code&gt; 을 &lt;code&gt;Code&lt;/code&gt; 로 변경하는 함수 &lt;code&gt;compile&lt;/code&gt; 를 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;compile&#39; :: Expr -&amp;gt; Code
compile&#39; (Val n) = [PUSH n]
compile&#39; (Add x y) = compile x ++ compile y ++ [ADD]

compile :: Expr -&amp;gt; Code
compile e = compile&#39; e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 화면에 출력을 위해 &lt;code&gt;Show&lt;/code&gt; 를 구현하고 샘플식 &lt;code&gt;e&lt;/code&gt; 를 만들면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance Show Expr where
  show (Val n) = &amp;quot;(Val &amp;quot; ++ show n ++ &amp;quot;)&amp;quot;
  show (Add x y) = &amp;quot;(Add &amp;quot; ++ show x ++ &amp;quot; &amp;quot; ++ show y ++ &amp;quot;)&amp;quot;

instance Show Op where
  show (PUSH n) = &amp;quot;(PUSH &amp;quot; ++ show n ++ &amp;quot;)&amp;quot;
  show (ADD) = &amp;quot;(ADD)&amp;quot;

e :: Expr
e = (Add (Add (Val 2) (Val 3)) (Val 4))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; e
-- (Add (Add (Val 2) (Val 3)) (Val 4))

&amp;gt; eval e
-- 9

&amp;gt; compile e
-- [(PUSH 2),(PUSH 3),(ADD),(PUSH 4),(ADD)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;잘 보면, 식을 컴파일해서 초기스택 &lt;code&gt;[]&lt;/code&gt; 와 함께 실행시킨 것은, &lt;code&gt;[eval e]&lt;/code&gt; 와 같다는 것을 알 수 있지요. &lt;code&gt;[]&lt;/code&gt; 대신 임의의 스택 &lt;code&gt;s&lt;/code&gt; 를 이용하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;exec (compile e) s = eval e:s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1) &lt;em&gt;base-case:&lt;/em&gt; &lt;code&gt;(Val n)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;exec (compile (Val n)) s

= exec [PUSH n] s
= n : s
eval (Val n) : s -- unapply eval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2) &lt;em&gt;inductive case:&lt;/em&gt; &lt;code&gt;(Add x y)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;exec (compile (Add x y)) s

= exec (compile x ++ compile y ++ [ADD]) s
= exec (compile x ++ (compile y ++ [ADD])) s -- associativity
= exec (compile y ++ [ADD]) (exec (compile x) s) -- distributivity of exec
= exec (compile y ++ [ADD]) (eval x:s) -- induction hypothesis for x
= exec [ADD] (exec (compile y) (eval x:s)) -- distributivity
= exec [ADD] (eval y : eval x : s)
= (eval x + eval y) : s -- apply exec
= eval (Add x y) : s -- unapply eval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위에서 쓴 &lt;code&gt;exec&lt;/code&gt; 의 &lt;em&gt;distributivity&lt;/em&gt; 를 보이면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;exec (c ++ d) s = exec d (exec c s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;PUSH&lt;/code&gt; 일때, 그리고 &lt;code&gt;ADD&lt;/code&gt; 일때로 나눠서 증명하면 되죠.&lt;/p&gt;

&lt;p&gt;(1) &lt;em&gt;base case&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;exec ([] ++ d) s 

= exec d s
= exec d (exec [] s) -- unapply exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2-1) &lt;em&gt;inductive case:&lt;/em&gt; &lt;code&gt;PUSH n&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;exec ((PUSH n : c) ++ d) s

= exec (PUSH n : (c ++ d)) s
= exec (c ++ d) (n:s)
= exec d (exec c (n:s)) -- induction hypothesis
= exec d (exec (PUSH n:c) s) -- unapply exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2-2) &lt;em&gt;inductive case:&lt;/em&gt; &lt;code&gt;ADD&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;exec ((ADD : c) ++ d) s
= exec (ADD : (c ++ d)) s
= exec (ADD : (c ++ d)) (m:n:s&#39;) -- assume s == m:n:s&#39;
= exec (c ++ d) (m+n:s&#39;) -- apply exec
= exec d (exec c (m+n:s&#39;)) -- induction hypothesis
= exec d (exec (ADD : c) (m:n:s&#39;)) -- unapply exec
= exec d (exec (ADD : c) s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;s&lt;/code&gt; 를 &lt;code&gt;m:n:s&#39;&lt;/code&gt; 로 의 가정은 &lt;em&gt;underflow error&lt;/em&gt; 를 겪을 수 있는것처럼 보이지만, 실제로는 그렇지 않습니다. 왜냐하면 &lt;code&gt;ADD&lt;/code&gt; 연산이 들어있다는 자체가 최소한 두개의 숫자는 스택에 포함한다는 뜻이기 때문입니다. (&lt;code&gt;exec&lt;/code&gt; 의 정의를 보세요)&lt;/p&gt;

&lt;p&gt;그리고 이전 장에서 &lt;em&gt;append&lt;/em&gt; 연산에 적용했던 테크닉을 다시 가져와서, &lt;em&gt;distributivity property&lt;/em&gt; 의 &lt;em&gt;underflow&lt;/em&gt; 이슈를 예방할 수 있습니다. 이 속성을 유지하도록 하면요&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;compile&#39; e c = compile e ++ c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 속성을 &lt;em&gt;induction&lt;/em&gt; 을 이용해서 차근차근 풀면, 아래와 같은 정의를 얻을 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;compile&#39; :: Expr -&amp;gt; Code -&amp;gt; Code
compile&#39; (Val n) c = PUSH n : c
compile&#39; (Add x y) = compile&#39; x (compile&#39; y (ADD : c))

compile e = compile&#39; e []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러면 &lt;em&gt;compiler correctness&lt;/em&gt; 는&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;exec (compiler&#39; e c) s = exec c (eval e : s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;해석은 원문을 첨부하겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;That is, compiling an expression and then executing the resulting code together with arbitrary additional code gives the same result as executing the additional code with the value of the expression on top of the original stack&lt;/p&gt;

&lt;p&gt;Note that with &lt;code&gt;s = c = [ ]&lt;/code&gt;, this new result simplifies to &lt;code&gt;exec (compile e) [] = [eval e]&lt;/code&gt;, our original statement of correctness.&lt;/p&gt;

&lt;p&gt;In addition to avoiding the problem of stack underflow in the correctness proof, the accumulator version of the compiler has two further benefits.&lt;/p&gt;

&lt;p&gt;First of all, &lt;strong&gt;it avoids the use of ++,&lt;/strong&gt; and is hence more efficient. And,&lt;/p&gt;

&lt;p&gt;secondly, &lt;strong&gt;the new proof is less than half the combined length of our previous two proofs.&lt;/strong&gt; As is often the case in formal reasoning, generalising a result in the appropriate manner can considerably simplify its proof. Mathematics is an excellent tool for guiding the development of efficient programs with simple proofs!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;rose-tree&#34;&gt;Rose Tree&lt;/h3&gt;

&lt;p&gt;로즈 트리는 원소의 개수가 &lt;em&gt;unbounded&lt;/em&gt; 인 트리입니다. 이렇게 정의할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data a = a :&amp;gt; [Rose a] deriving Show
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 &lt;code&gt;:&amp;gt;&lt;/code&gt; 는 &lt;em&gt;constructor&lt;/em&gt; 입니다. 생성자가 &lt;em&gt;infix&lt;/em&gt; 연산자로 올때는 &lt;code&gt;:&lt;/code&gt; 로 시작해야 합니다. &lt;code&gt;deriving Show&lt;/code&gt; 는 좀 디버깅 쉬우라고, 화면에 출력하기 위해 사용했습니다.&lt;/p&gt;

&lt;p&gt;몇 가지 헬퍼 함수를 만들면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;root :: Rose a -&amp;gt; a
root (x :&amp;gt; xs) = x

children :: Rose a -&amp;gt; [Rose a]
children (x :&amp;gt; xs) = r

size :: Rose a -&amp;gt; Int
size (x :&amp;gt; xs) = 1 + sum (map size xs)

leaves :: Rose a -&amp;gt; Int
leaves (_ :&amp;gt; []) = 1
leaves (_ :&amp;gt; xs) = 1 + sum (map leaves xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;샘플 로즈 트리를 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;tree = &#39;x&#39; :&amp;gt; map (flip (:&amp;gt;) []) [&#39;a&#39;..&#39;z&#39;]

-- same as
tree = &#39;x&#39; :&amp;gt; map (\c -&amp;gt; c :&amp;gt; []) [&#39;a&#39;..&#39;z&#39;] 

&amp;gt; tree
-- &#39;x&#39; :&amp;gt; [&#39;a&#39; :&amp;gt; [],&#39;b&#39; :&amp;gt; [],&#39;c&#39; :&amp;gt; [],&#39;d&#39; :&amp;gt; [],&#39;e&#39; :&amp;gt; [],&#39;f&#39; :&amp;gt; [],&#39;g&#39; :&amp;gt; [],&#39;h&#39; :&amp;gt; [],&#39;i&#39; :&amp;gt; [],&#39;j&#39; :&amp;gt; [],&#39;k&#39; :&amp;gt; [],&#39;l&#39; :&amp;gt; [],&#39;m&#39; :&amp;gt; [],&#39;n&#39; :&amp;gt; [],&#39;o&#39; :&amp;gt; [],&#39;p&#39; :&amp;gt; [],&#39;q&#39; :&amp;gt; [],&#39;r&#39; :&amp;gt; [],&#39;s&#39; :&amp;gt; [],&#39;t&#39; :&amp;gt; [],&#39;u&#39; :&amp;gt; [],&#39;v&#39; :&amp;gt; [],&#39;w&#39; :&amp;gt; [],&#39;x&#39; :&amp;gt; [],&#39;y&#39; :&amp;gt; [],&#39;z&#39; :&amp;gt; []]

&amp;gt; size tree
-- 27

&amp;gt; leaves tree
-- 26
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;functor&#34;&gt;Functor&lt;/h3&gt;

&lt;p&gt;좀 삼삼하죠? 할게 별로 없으니. &lt;em&gt;rose tree&lt;/em&gt; 를 &lt;em&gt;functor&lt;/em&gt; 로 만들어 봅시다. 아래 짤방이 아마 세상에서 펑터를 가장 쉽게 설명할겁니다. &lt;code&gt;fmap (+3) (Just 2)&lt;/code&gt; 에 대해&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://adit.io/imgs/functors/fmap_just.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;http://adit.io&#34;&gt;http://adit.io&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;즉, &lt;code&gt;Just&lt;/code&gt; 는 펑터이므로 &lt;code&gt;2&lt;/code&gt; 를 꺼내 &lt;code&gt;+3&lt;/code&gt; 을 적용하고, 다시 &lt;code&gt;Just&lt;/code&gt; 를 씌워 &lt;code&gt;Just 5&lt;/code&gt;로 만들어 줍니다. 그게 &lt;code&gt;fmap&lt;/code&gt; 이 하는 일이고, 모든 &lt;em&gt;functor&lt;/em&gt; 는 &lt;code&gt;fmap&lt;/code&gt; 이 적용 가능합니다. &lt;em&gt;functor&lt;/em&gt; 의 정의를 보면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class  Functor f  where
    fmap        :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;타입이 직관적이죠? &lt;code&gt;a -&amp;gt; b&lt;/code&gt; 함수를 받아, &lt;code&gt;f a&lt;/code&gt; 에 함수를 적용해서 &lt;code&gt;f b&lt;/code&gt; 를 만듭니다. &lt;code&gt;f&lt;/code&gt; 는 컨테이너라고 보시면 됩니다. &lt;code&gt;Maybe&lt;/code&gt; 같은 것들요 대표적인 &lt;code&gt;Functor&lt;/code&gt; 로&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance  Functor Maybe  where
    fmap f Nothing = Nothing
    fmap f (Just x) = Just (f x)
    

instance  Functor []  where
    fmap = map 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그럼 우리가 만든 &lt;code&gt;Rose&lt;/code&gt; 는 어떻게 해야 &lt;code&gt;Functor&lt;/code&gt; 로 만들 수 있을까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance Functor Rose  where
    fmap g (x :&amp;gt; xs) = g x :&amp;gt; map (fmap g) xs  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;직관적으로 보면 됩니다. 루트에 &lt;code&gt;g&lt;/code&gt; 를 적용하고, &lt;code&gt;xs&lt;/code&gt; 는 &lt;code&gt;[Rose]&lt;/code&gt; 이므로 &lt;code&gt;x :&amp;gt; xs&lt;/code&gt; 와 똑같이 취급해서 &lt;code&gt;fmap g&lt;/code&gt; 를 적용하면 됩니다. 이 때 지켜줘야 하는 &lt;em&gt;functor laws&lt;/em&gt; 는&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;fmap id  ==  id
fmap (f . g)  ==  fmap f . fmap g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그럼 이제, 좀 재미난걸 할 수 있습니다. 이젠 &lt;code&gt;Rose&lt;/code&gt; 가 &lt;em&gt;functor&lt;/em&gt; 니까요. 다양한 함수를 적용할 수 있죠.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;tree&#39; = 1 :&amp;gt; map (flip (:&amp;gt;) []) [1..5]

&amp;gt; tree&#39;
-- 1 :&amp;gt; [1 :&amp;gt; [],2 :&amp;gt; [],3 :&amp;gt; [],4 :&amp;gt; [],5 :&amp;gt; []]

&amp;gt; fmap (+1) tree&#39;
-- 2 :&amp;gt; [2 :&amp;gt; [],3 :&amp;gt; [],4 :&amp;gt; [],5 :&amp;gt; [],6 :&amp;gt; []]

&amp;gt; fmap (*10) tree&#39;
-- 10 :&amp;gt; [10 :&amp;gt; [],20 :&amp;gt; [],30 :&amp;gt; [],40 :&amp;gt; [],50 :&amp;gt; []]

&amp;gt; fmap (:&amp;gt; []) tree&#39;
-- (1 :&amp;gt; []) :&amp;gt; [(1 :&amp;gt; []) :&amp;gt; [],(2 :&amp;gt; []) :&amp;gt; [],(3 :&amp;gt; []) :&amp;gt; [],(4 :&amp;gt; []) :&amp;gt; [],(5 :&amp;gt; []) :&amp;gt; []]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;monoid&#34;&gt;Monoid&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;monoid&lt;/em&gt; 는 &lt;code&gt;mempty&lt;/code&gt;, &lt;code&gt;mappend&lt;/code&gt; 두개의 함수를 가지고 있는 &lt;code&gt;m&lt;/code&gt; 타입의 인스턴스입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mappend :: m -&amp;gt; m -&amp;gt; m&lt;/code&gt; 은 &lt;em&gt;associative&lt;/em&gt; 한 연산자로, 두 &lt;code&gt;m&lt;/code&gt; 을 받아서, 하나의 &lt;code&gt;m&lt;/code&gt; 으로 합칩니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mempty :: m&lt;/code&gt; 은 &lt;code&gt;mappend&lt;/code&gt; 의 &lt;em&gt;neutral element&lt;/em&gt; 를 표현합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;뭔소리야 하실텐데, 우리 주변의 많은 것들이 &lt;em&gt;monoid&lt;/em&gt; 입니다. 예제를 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; (5 + 6) + 10 == 5 + (6 + 10)
True

&amp;gt; (5 * 6) * 10 == 5 * (6 * 10)
True

&amp;gt; (&amp;quot;Hello&amp;quot; ++ &amp;quot; &amp;quot;) ++ &amp;quot;world!&amp;quot; == &amp;quot;Hello&amp;quot; ++ (&amp;quot; &amp;quot; ++ &amp;quot;world!&amp;quot;)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;[Char]&lt;/code&gt; 에서 &lt;code&gt;mempty&lt;/code&gt; 는 &lt;code&gt;[]&lt;/code&gt; &lt;code&gt;mappend&lt;/code&gt; 는 &lt;code&gt;++&lt;/code&gt; 입니다. &lt;code&gt;Integer&lt;/code&gt; 의 &lt;code&gt;mappend&lt;/code&gt; 는 다양한데, &lt;code&gt;+&lt;/code&gt; 라면 &lt;code&gt;mempty&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 이고, &lt;code&gt;*&lt;/code&gt; 라면 &lt;code&gt;mempty&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 일 겁니다. 항등원 기억나시죠? 그거랑 비슷합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class  Monoid a  where
    mappend :: a -&amp;gt; a -&amp;gt; a
    mempty  :: m
    mconcat :: [a] -&amp;gt; a
    mconcat :: foldr mappend mempty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mconcat&lt;/code&gt; 은 &lt;code&gt;foldr (++) []&lt;/code&gt; 를 생각하시면 이해가 쉽습니다. 네! 리스트도 모노이듭니다!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance  Monoid [a]  where
    mempty = []
    mappend = (++)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;모노이드를 일종의 연산과 그에 대한 항등원이 구현된 클래스라 보셔도 됩니다. 그러면 &lt;code&gt;Sum&lt;/code&gt;, &lt;code&gt;Product&lt;/code&gt; 모노이드를 만들어 보죠. &lt;code&gt;Rose&lt;/code&gt; 에 적용할 수 있을 것 같아요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;newtype Sum a = Sum { getSum :: a } deriving Show
newtype Product a = Product a deriving Show

unProduct :: Product a -&amp;gt; a
unProduct (Product x) = x

instance Num a =&amp;gt; Monoid (Sum a) where
  mempty = Sum 0
  Sum x `mappend` Sum y = Sum (x + y)
  
instance Num a =&amp;gt; Monoid (Product a) where
  mempty = Product 1
  Product x `mappend` Product y = Product (x * y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;중간에 보면 &lt;code&gt;unProduct&lt;/code&gt; 란게 있는데, 생성자에서 &lt;code&gt;getSum&lt;/code&gt; 처럼 &lt;em&gt;accessor&lt;/em&gt; 를 만들어 주면 필요 없고, 안만들어 주면 저렇게 만들어서 써야 합니다. 차이점을 보여드리기 위해 두 방법을 모두 사용 해봤어요. 근데, &lt;em&gt;accessor&lt;/em&gt; 가 있으면 출력때 같이 나와서 좀 불편합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;-- 6 * (3 + 4)
&amp;gt; unProduct (Product 6 `mappend` (Product . getSum $ Sum 3 `mappend` Sum 4))

-- 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;무튼, 이제 모노이드도 있겠다, &lt;code&gt;Rose&lt;/code&gt; 에 적용할 수 있습니다. 이게 무슨 뜻이냐면, &lt;code&gt;Rose&lt;/code&gt; 컨테이너가 가진 &lt;em&gt;value&lt;/em&gt; 가 &lt;code&gt;Product&lt;/code&gt;, &lt;code&gt;Sum&lt;/code&gt; 연산이 가능하게끔 바꿀 수 있다는 뜻입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; tree&#39;
-- 1 :&amp;gt; [1 :&amp;gt; [],2 :&amp;gt; [],3 :&amp;gt; [],4 :&amp;gt; [],5 :&amp;gt; []]

&amp;gt; fmap Sum tree&#39;
-- Sum 1 :&amp;gt; [Sum 1 :&amp;gt; [],Sum 2 :&amp;gt; [],Sum 3 :&amp;gt; [],Sum 4 :&amp;gt; [],Sum 5 :&amp;gt; []]

&amp;gt; fmap Product tree&#39;
-- Product 1 :&amp;gt; [Product 1 :&amp;gt; [],Product 2 :&amp;gt; [],Product 3 :&amp;gt; [],Product 4 :&amp;gt; [],Product 5 :&amp;gt; []]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;foldable&#34;&gt;Foldable&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://www.haskell.org/wikiupload/thumb/3/39/FunctorHierarchy.svg/558px-FunctorHierarchy.svg.png&#34; alt=&#34;&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;(&lt;a href=&#34;https://www.haskell.org&#34;&gt;https://www.haskell.org&lt;/a&gt;)&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;foldable&lt;/em&gt; 은 진짜 말 그대로 접을 수 있는 연산 &lt;code&gt;fold&lt;/code&gt; 를 지원하는 인스턴스를 말합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class Foldable t where
    fold    :: Monoid m =&amp;gt; t m -&amp;gt; m
    foldMap :: Monoid m =&amp;gt; (a -&amp;gt; m) -&amp;gt; t a -&amp;gt; m

    foldr   :: (a -&amp;gt; b -&amp;gt; b) -&amp;gt; b -&amp;gt; t a -&amp;gt; b
    foldr&#39;  :: (a -&amp;gt; b -&amp;gt; b) -&amp;gt; b -&amp;gt; t a -&amp;gt; b

    foldl   :: (b -&amp;gt; a -&amp;gt; b) -&amp;gt; b -&amp;gt; t a -&amp;gt; b
    foldl&#39;  :: (b -&amp;gt; a -&amp;gt; b) -&amp;gt; b -&amp;gt; t a -&amp;gt; b

    foldr1  :: (a -&amp;gt; a -&amp;gt; a) -&amp;gt; t a -&amp;gt; a
    foldl1  :: (a -&amp;gt; a -&amp;gt; a) -&amp;gt; t a -&amp;gt; a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기선 &lt;code&gt;fold, foldMap&lt;/code&gt; 만 다루도록 하죠. &lt;code&gt;fold&lt;/code&gt; 의 타입을 보면 아시겠지만, &lt;code&gt;Monoid  m&lt;/code&gt; 의 컨테이너인 &lt;code&gt;Foldable t&lt;/code&gt; 를 접어서 단일 &lt;code&gt;m&lt;/code&gt; 으로 만듭니다.&lt;/p&gt;

&lt;p&gt;따라서 복수개의 &lt;code&gt;Sum, Product&lt;/code&gt; 를 접어 하나로 만들수 있지요. 어차피 이 두 모노이드에 대해 연산 자체는 정해져 있기 때문에 접는법만 알려주면 됩니다.&lt;/p&gt;

&lt;p&gt;그리고 더 중요한 사실은, &lt;code&gt;Rose&lt;/code&gt; 가 &lt;code&gt;Foldable&lt;/code&gt; 이 되면 &lt;code&gt;Sum&lt;/code&gt; 등이 적용된 &lt;code&gt;Rose&lt;/code&gt; 를 접어 계산할 수 있습니다. 다시 말해 컨테이너에, 연산을 추가하고, &lt;code&gt;fold&lt;/code&gt; 할 수 있다는 이야기지요.&lt;/p&gt;

&lt;p&gt;아참! &lt;code&gt;foldMap&lt;/code&gt; 은 이름에서 볼 수 있듯이 &lt;code&gt;fmap&lt;/code&gt; 후 &lt;code&gt;fold&lt;/code&gt; 한다고 생각하면 쉽습니다. &lt;code&gt;fold . fmap&lt;/code&gt; 처럼요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class Functor f =&amp;gt; Foldable f where
  fold :: Monoid m    =&amp;gt; f m -&amp;gt; m
  foldMap :: Monoid m =&amp;gt; (a -&amp;gt; m) -&amp;gt; (f a -&amp;gt; m)
  foldMap = fold $ fmap g a
  
instance Foldable Rose where
  fold (x :&amp;gt; xs) = (h.g) xs `mappend` x
    where g = map (fold)
          h = foldr (mappend) mempty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;직관적으로 보면 쉽습니다. &lt;code&gt;h&lt;/code&gt; 는 모노이드 &lt;code&gt;m&lt;/code&gt; 을 펼치는 역할을 합니다. &lt;code&gt;g&lt;/code&gt; 는 &lt;code&gt;f m&lt;/code&gt; 을  재귀적으로 펼치구요. 이는 로즈 트리가, 복수개의 자식 노드를 가질 수 있기 때문에 그런건데, 어찌 되었든 펼치면서 노드를 끝에다 붙여 나갑니다.&lt;/p&gt;

&lt;p&gt;먼저 로즈 트리를 펼친 후에 모노이드를 합칠거니까, 순서는 &lt;code&gt;(g.h)&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;이제 그러면, 로즈트리가 &lt;em&gt;functor&lt;/em&gt; 이므로 모노이드로 감쌀 수 있고 (연산을 지정할 수 있고)    게다가 &lt;em&gt;foldable&lt;/em&gt; 이므로 그 연산을 이용해 하나로 접을 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;&amp;gt; tree&#39;
-- 1 :&amp;gt; [1 :&amp;gt; [],2 :&amp;gt; [],3 :&amp;gt; [],4 :&amp;gt; [],5 :&amp;gt; []]

&amp;gt; fmap Sum tree&#39;
-- Sum 1 :&amp;gt; [Sum 1 :&amp;gt; [],Sum 2 :&amp;gt; [],Sum 3 :&amp;gt; [],Sum 4 :&amp;gt; [],Sum 5 :&amp;gt; []]

&amp;gt; fold $ fmap Sum tree&#39;
-- Sum 16

&amp;gt; unSum $ fold $ fmap Sum tree&#39;
-- 16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;del&gt;갓스켈&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;(1) &lt;strong&gt;DelftX FP 101x&lt;/strong&gt;&lt;br /&gt;
(2) &lt;em&gt;Programming in Haskell&lt;/em&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&#34;&gt;Functor, Monad, Applicative&lt;/a&gt;&lt;br /&gt;
(4) &lt;a href=&#34;http://en.wikibooks.org/wiki/Haskell/Monoids&#34;&gt;Haskell WikiBooks - Monoids&lt;/a&gt;&lt;br /&gt;
(5) &lt;a href=&#34;https://www.haskell.org/haskellwiki/Foldable_and_Traversable&#34;&gt;Foldable, Traversable&lt;/a&gt;&lt;br /&gt;
(6) &lt;a href=&#34;http://blog.jakubarnold.cz/2014/07/30/foldable-and-traversable.html&#34;&gt;foldable and traversable&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Poor Man&#39;s Concurrency Monad</title>
      <link>https://1ambda.github.io/haskell/poor-mans-concurrency-monad/</link>
      <pubDate>Sat, 25 Jun 2016 01:22:05 +0900</pubDate>
      
      <guid>https://1ambda.github.io/haskell/poor-mans-concurrency-monad/</guid>
      <description>

&lt;p&gt;&lt;em&gt;FP 101x&lt;/em&gt; 의 최종 보스입니다. &lt;del&gt;Rose Tree 는 거들뿐&lt;/del&gt; &lt;em&gt;Koen Claessen&lt;/em&gt; 가 1999년에 발표한 &lt;a href=&#34;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.8039&#34;&gt;&lt;em&gt;Poor Man&amp;rsquo;s Concurrenc Monad&lt;/em&gt;&lt;/a&gt; 를 배경으로 하는 과제인데, 언어에 &lt;em&gt;primitive&lt;/em&gt; 추가 없이 &lt;em&gt;concurrency&lt;/em&gt; 를 모델링 하는 방법을 보여줍니다.&lt;/p&gt;

&lt;h3 id=&#34;continuation&#34;&gt;Continuation&lt;/h3&gt;

&lt;p&gt;먼저 용어부터 정의하고 가면, &lt;em&gt;continuation&lt;/em&gt; 은 실행 가능한 &lt;em&gt;computation&lt;/em&gt; 입니다. 필요할 때 사용할려고 미뤄둔 계산인데, 이게 프로세스를 모델링 하기에 적당합니다. 왜냐하면 프로세스도 멈추었다가, 나중에 다시 실행을 해야 하니까요!&lt;/p&gt;

&lt;p&gt;나중에 쓰려고 미뤄둔 계산, 즉 &lt;em&gt;continuation&lt;/em&gt; 을 지속적으로 넘겨가면서 사용하는 방식을 &lt;em&gt;continuation passing style&lt;/em&gt; 이라 부릅니다. &lt;em&gt;CPS&lt;/em&gt; 로 작성된 함수는 리턴하는 법이 없습니다. 다만 자신의 계산을 &lt;em&gt;continuation&lt;/em&gt; 으로 만들어 넘겨줄 뿐이지요.&lt;/p&gt;

&lt;p&gt;코드를 먼저 보시지요. 피타고라스 계산을 하스켈에서 &lt;em&gt;CPS&lt;/em&gt; 로 작성하는 방법입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;square :: Int -&amp;gt; Int
square x = x * x

add :: Int -&amp;gt; Int -&amp;gt; Int
add x y = x + y

square_cps :: Int -&amp;gt; (Int -&amp;gt; r) -&amp;gt; r
square_cps x = \cont -&amp;gt; cont (square x)

add_cps :: Int -&amp;gt; Int -&amp;gt; (Int -&amp;gt; r) -&amp;gt; r
add_cps x y = \cont -&amp;gt; cont (add x y)

pythagoras_cps :: Int -&amp;gt; Int -&amp;gt; (Int -&amp;gt; r) -&amp;gt; r
pythagoras_cps x y = \cont -&amp;gt;
  square_cps x $ \squared_x -&amp;gt;
  square_cps y $ \squared_y -&amp;gt;
  add_cps squared_x squared_y cont
  
&amp;gt; square_cps 3 print
-- &amp;quot;9&amp;quot;

&amp;gt; add_cps 3 4 print
-- &amp;quot;7&amp;quot;

&amp;gt; pythagoras_cps 3 4 print
-- &amp;quot;25&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 예제에서는 &lt;code&gt;print&lt;/code&gt; 가 나중에 쓸려고 모셔둔 계산, 즉 &lt;em&gt;continuation&lt;/em&gt; 입니다. 이 타입 &lt;code&gt;(Int -&amp;gt; r) -&amp;gt; r&lt;/code&gt; 을 잘 기억해 두세요.&lt;/p&gt;

&lt;h3 id=&#34;process-modeling&#34;&gt;Process Modeling&lt;/h3&gt;

&lt;p&gt;프로세스를 모델링 하려면 상태와 작업 두 가지를 나타내야 합니다. 먼저 프로세스가 하는 작업에 대해서 모델링을 해 보겠습니다. 프로세스는 의 작업은 &lt;code&gt;Action&lt;/code&gt; 이라 부르겠습니다. &lt;code&gt;Action&lt;/code&gt; 은 &lt;code&gt;Atom&lt;/code&gt; 이라 부르는 &lt;code&gt;IO&lt;/code&gt; 연산일 수도 있고, 자식을 만드는 &lt;code&gt;Fork&lt;/code&gt; 나, 프로세스를 멈추는 &lt;code&gt;Stop&lt;/code&gt; 이 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Atom&lt;/code&gt; 은 &lt;em&gt;side-effect&lt;/em&gt; 를 만드는 &lt;em&gt;atomic&lt;/em&gt; 연산이라 보면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Action = 
   = Atom (IO Action)
   | Fork Action Action
   | Stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;프로세스는 상태를 모델링 하기 위해 프로세스의 동작에 대해서 조금 논의해 봅시다. 프로세스는 자신의 작업이 있습니다. 우리는 &lt;code&gt;Action&lt;/code&gt; 으로 표현했지요. 프로세스가 어떤 이유에서든지 중단된다면, 나중을 위해서 이 &lt;code&gt;Action&lt;/code&gt; 을 기억해 둬야 합니다. 다시 작업을 해야하니까요!&lt;/p&gt;

&lt;p&gt;아까 위에서 보았던 &lt;code&gt;(Int -&amp;gt; r) -&amp;gt; r&lt;/code&gt; 기억 나시나요? &lt;em&gt;continuation&lt;/em&gt; &lt;code&gt;Int - r&lt;/code&gt; 을 이용해 결과 &lt;code&gt;r&lt;/code&gt; 을 만들어 냈던 타입이지요. 이 타입을 잘 보면, &lt;em&gt;continuation&lt;/em&gt; 이 공급될 때 &lt;em&gt;result &lt;code&gt;r&lt;/code&gt;&lt;/em&gt;  을 얻을 수 있습니다. 여기서 결과인 &lt;code&gt;r&lt;/code&gt; 은 다른 프로세스에게 밀려 중단된 작업 &lt;code&gt;Action&lt;/code&gt; 이라 보시면 되고, 공급되는 &lt;em&gt;continuation&lt;/em&gt; 은 &lt;em&gt;CPU&lt;/em&gt; 와 같은 리소스라 보시면 됩니다. (그렇게 생각하는 편이 &lt;del&gt;정신건강에&lt;/del&gt; 좋습니다.)&lt;/p&gt;

&lt;p&gt;그러면, 비슷하게, 이런 타입을 생각해 볼 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Concurrent a = ((a -&amp;gt; Action) -&amp;gt; Action)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 타입은 &lt;code&gt;a -&amp;gt; Action&lt;/code&gt; &lt;em&gt;continuation&lt;/em&gt; 을 받아, 결과 &lt;code&gt;Action&lt;/code&gt; 을 돌려줍니다.&lt;/p&gt;

&lt;p&gt;그러면 프로세스의 &lt;strong&gt;미뤄진 작업의 상태&lt;/strong&gt;를 표현하는 &lt;code&gt;Concurrent&lt;/code&gt; 에 &lt;em&gt;continuation&lt;/em&gt; 을 공급해 &lt;strong&gt;미뤄진 작업&lt;/strong&gt; &lt;code&gt;Action&lt;/code&gt; 을 얻어내는 &lt;code&gt;action&lt;/code&gt; 이란 함수를 만들 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;action :: Concurrent a -&amp;gt; Action
action (Concurrent concur) = concur (\a -&amp;gt; Stop)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또한 어떤 &lt;em&gt;continuation&lt;/em&gt; 을 받던 무조건 멈추는 &lt;code&gt;Action&lt;/code&gt; 을 돌려주는 &lt;code&gt;stop&lt;/code&gt; 함수도 생각해 볼 수 있겠죠. 이건 &lt;strong&gt;멈춰진 작업의 상태&lt;/strong&gt; 를 표현하는 &lt;code&gt;Concurrent&lt;/code&gt; 라 보셔도 좋습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stop :: Concurrent 
stop = Concurrent (\cont -&amp;gt; Stop)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;IO&lt;/code&gt; 를 &lt;code&gt;Concurrent&lt;/code&gt; 로 표현하기 위해 &lt;code&gt;IO a -&amp;gt; Concurrent a&lt;/code&gt; 로 변환해주는 &lt;code&gt;atom&lt;/code&gt; 을 만들겁니다. 다시 말해서 이 함수는 &lt;strong&gt;멈춰진 &lt;code&gt;IO&lt;/code&gt; 연산&lt;/strong&gt; 을 돌려줘 하므로 &lt;code&gt;Concurrent&lt;/code&gt; 내에 &lt;code&gt;Atom (IO Action)&lt;/code&gt; 을 담아야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cont a&lt;/code&gt; 가 &lt;code&gt;Action&lt;/code&gt; 이므로, &lt;code&gt;do&lt;/code&gt; 내에서 &lt;code&gt;return (cont a)&lt;/code&gt; 이면 &lt;code&gt;IO Action&lt;/code&gt; 타입을 얻을 수 있겠죠? 쉽게 생각해서 &lt;em&gt;continuation&lt;/em&gt; 인 &lt;code&gt;cont&lt;/code&gt; 가 공급될 때 &lt;code&gt;IO&lt;/code&gt; 를 수행한다 보면 되겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;atom :: IO a -&amp;gt; Concurrent a
atom \io -&amp;gt; Concurrent $ \cont -&amp;gt; Atom $ do a &amp;lt;- io
                                            return (cont a)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 프로세스를 분할하는 &lt;code&gt;Fork&lt;/code&gt; 작업을 생각해 봅시다. 타입만 보면 &lt;code&gt;Fork Action Aciton&lt;/code&gt;  입니다. 즉 두개의 &lt;code&gt;Action&lt;/code&gt; 을 &lt;code&gt;Concurrent&lt;/code&gt; 내에 담아야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;fork :: Concurrent a -&amp;gt; Concurrent ()
fork concur = Concurrent $ \cont -&amp;gt; Fork (action concur) (cont ())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보면, &lt;code&gt;action concur&lt;/code&gt; 로 현재 미뤄진 작업에 대한 &lt;code&gt;Action&lt;/code&gt; 을 추출하고, &lt;em&gt;continuation&lt;/em&gt; 를 받아 &lt;code&gt;cont ()&lt;/code&gt; 로 &lt;em&gt;continuation&lt;/em&gt; 에 있는 다음 &lt;code&gt;Action&lt;/code&gt; 을 뽑아냅니다. &lt;em&gt;continuation&lt;/em&gt; 의 타입이 &lt;code&gt;a -&amp;gt; Action&lt;/code&gt; 인거 기억 나시죠?&lt;/p&gt;

&lt;p&gt;비슷하게, 두개의 미루어진 작업을 받아 &lt;code&gt;Fork&lt;/code&gt; 로 만드는 &lt;code&gt;par&lt;/code&gt; 함수도 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;par :: Concurrent a -&amp;gt; Concurrent a -&amp;gt; Concurrent a
par (Concurrent a) (Concurrent b) = Concurrent $ \cont -&amp;gt; Fork (a cont) (b con))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;Concurrent&lt;/code&gt; 간 &lt;em&gt;composition&lt;/em&gt; 을 위해 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt; 을 구현하면&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;instance Monad Concurrent where
    -- g :: \a -&amp;gt; Concurrent b
    (Concurrent A) &amp;gt;&amp;gt;= g = 
      \contB -&amp;gt; A (\contA -&amp;gt; case g a of (Concurrent B) -&amp;gt; B contB  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;직관적인 이해는, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 자체는 두 &lt;code&gt;Concurrent&lt;/code&gt; 간 연결입니다. 서로 다른 타입 &lt;code&gt;a, b&lt;/code&gt; 에 대해서 &lt;code&gt;Concurrent&lt;/code&gt; 가 어떻게 연결되야 하는지 생각해 보면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Concurrent a&lt;/code&gt; 의 &lt;code&gt;Action&lt;/code&gt; 을 얻기 위한  &lt;em&gt;continuation&lt;/em&gt; 은, 다음 작업을 의미하는데 이 &lt;em&gt;continuation&lt;/em&gt; &lt;code&gt;a&#39; -&amp;gt; Action&lt;/code&gt; 에서의 &lt;code&gt;Action&lt;/code&gt; 이 &lt;code&gt;Concurrent b&lt;/code&gt; 의 &lt;code&gt;Action&lt;/code&gt; 이라 보면 됩니다.&lt;/p&gt;

&lt;p&gt;다시 말해서, &lt;code&gt;Concurrent a&lt;/code&gt; 의 &lt;code&gt;Action&lt;/code&gt; 의 다음 작업이 &lt;code&gt;Concurrent b&lt;/code&gt; 의 &lt;code&gt;Action&lt;/code&gt; 이란 뜻이지요.&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;code&gt;Action&lt;/code&gt; 을 라운드 로빈 방식으로 스케쥴링하는 &lt;code&gt;roundRobin&lt;/code&gt; 함수와, 실제로 &lt;code&gt;Concurrent a&lt;/code&gt; 을 이용해 &lt;code&gt;roundRobin&lt;/code&gt; 함수를 이용하는 &lt;code&gt;run&lt;/code&gt; 함수를 보면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;roundRobin :: [Action] -&amp;gt; IO ()
roundRobin [] = return ()
roundRobin (Atom x:xs) = x &amp;gt;&amp;gt;= \ac -&amp;gt; roundRobin (xs ++ [ac])
roundRobin (Fork x y : xs) = roundRobin (xs ++ [x, y])
roundRobin (Stop : xs) = roundRobin xs

run :: Concurrent a -&amp;gt; IO ()
run x = roundRobin [action x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;몇개의 헬퍼 함수와 테스트 코드도 좀 보겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;genRandom :: Int -&amp;gt; [Int]
genRandom 1337 = [1, 96, 36, 11, 42, 47, 9, 1, 62, 73]
genRandom 7331 = [17, 73, 92, 36, 22, 72, 19, 35, 6, 74]
genRandom 2600 = [83, 98, 35, 84, 44, 61, 54, 35, 83, 9]
genRandom 42   = [71, 71, 17, 14, 16, 91, 18, 71, 58, 75]

loop :: [Int] -&amp;gt; Concurrent ()
loop xs = mapM_ (atom . putStr . show) xs

ex0 :: Concurrent ()
ex0 = par (loop (genRandom 1337)) (loop (genRandom 2600) &amp;gt;&amp;gt; atom (putStrLn &amp;quot;&amp;quot;))

ex1 :: Concurrent ()
ex1 = do atom (putStr &amp;quot;Haskell&amp;quot;)
         fork (loop $ genRandom 7331) 
         loop $ genRandom 42
         atom (putStrLn &amp;quot;&amp;quot;)

myex0 = run $ (ho &amp;gt;&amp;gt; ho &amp;gt;&amp;gt; ho) &amp;gt;&amp;gt;
              (hi &amp;gt;&amp;gt; hi &amp;gt;&amp;gt; hi) &amp;gt;&amp;gt; atom (putStr &amp;quot;\n&amp;quot;)
  where ho = atom (putStr &amp;quot;ho&amp;quot;)
        hi = atom (putStr &amp;quot;hi&amp;quot;)

myex1 = run $ fork (ho &amp;gt;&amp;gt; ho &amp;gt;&amp;gt; ho) &amp;gt;&amp;gt;
              (hi &amp;gt;&amp;gt; hi &amp;gt;&amp;gt; hi) &amp;gt;&amp;gt; atom (putStr &amp;quot;\n&amp;quot;)
  where ho = atom (putStr &amp;quot;ho&amp;quot;)
        hi = atom (putStr &amp;quot;hi&amp;quot;)
        
myex2 = run $ fork (put3 &amp;quot;ba&amp;quot;) &amp;gt;&amp;gt; fork (put3 &amp;quot;di&amp;quot;) &amp;gt;&amp;gt;
        put3 &amp;quot;bu&amp;quot; &amp;gt;&amp;gt; atom (putStr &amp;quot;\n&amp;quot;)
  where put3 = sequence . take 3 . repeat . atom . putStr
        
myex3 = run $ par (put3 &amp;quot;ba&amp;quot;) (put3 &amp;quot;di&amp;quot; &amp;gt;&amp;gt; stop) &amp;gt;&amp;gt;
        atom (putStr &amp;quot;\n&amp;quot;)
  where put3 = sequence . take 3 . repeat . atom . putStr
        
myex4 = run $ (par (put3 &amp;quot;ba&amp;quot;) (put3 &amp;quot;di&amp;quot;)) &amp;gt;&amp;gt;
        atom (putStr &amp;quot;\n&amp;quot;)
  where put3 = sequence . take 3 . repeat . atom . putStr

myex5 :: Concurrent ()
myex5 = do fork (atom $ putStrLn &amp;quot;test&amp;quot;)
           atom $ putStrLn &amp;quot;hello&amp;quot;

myex6 :: Concurrent ()
myex6 = do val &amp;lt;- par (atom $ return &amp;quot;hi&amp;quot;) (atom $ return &amp;quot;hello&amp;quot;)
           atom $ putStrLn val
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;p&gt;(1) &lt;strong&gt;DelftX FP 101x&lt;/strong&gt;&lt;br /&gt;
(2) &lt;em&gt;Programming in Haskell&lt;/em&gt;&lt;br /&gt;
(3) &lt;a href=&#34;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.8039&#34;&gt;A Poor Man&amp;rsquo;s Concurrency Monad&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>