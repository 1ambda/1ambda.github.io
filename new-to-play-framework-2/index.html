
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>new to Play Framework 2</title>
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="new to Play Framework 2">
  <meta name="twitter:description" content="Play Framework 를 배우기로 마음먹었다. 새로운 무언가를 마주쳤을때, 어떻게 해결할까를 위주로 서술했다. Installation 우선 설치를 해야했다. Play 를 배포하는 Typesafe 의 Getting Started 에 들어가서, 확인해보니 activator 라는 제품으로 Play 를 감싸 편하게 개발할 수 있도록 해주는 플랫폼을 만들어 놨다.  Installing Play 를  참조해서 activator 설치 후에, PATH 에 추가했다.">
  <meta name="twitter:creator" content="@yourTwitterUsername">
  <meta name="twitter:image" content="">
  <meta name="twitter:url" content="http://1ambda.github.io/new-to-play-framework-2/">
  <meta name="twitter:domain" content="http://1ambda.github.io">


  <link rel="author" href="https://plus.google.com/101105410053351451441?rel=author">

  <link rel="shortcut icon" href="../favicon.ico">

  <link rel="stylesheet" type="text/css" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Droid+Serif">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:600,300">
  <link rel="stylesheet" type="text/css" href="../assets/stylesheets/xpressio.css">
  <link rel="stylesheet" type="text/css" href="../assets/1ambda/1ambda.css">
  <script type="text/javascript" src="../assets/1ambda/modernizr.js">
  </script>
  <script type="text/javascript" src="../assets/1ambda/detectizr.min.js">
  </script>

  <!--load css if windows -->
  <script type="text/javascript">
    if (Modernizr.windows) {
      file = location.pathname.split( "/" ).pop();
      link = document.createElement( "link" );
      link.href = "/assets/1ambda/1ambda_windows.css";
      link.type = "text/css";
      link.rel = "stylesheet";
      link.media = "screen,print";
      document.getElementsByTagName("head")[0].appendChild( link );
    }
  </script>


  <link rel="stylesheet" href="../assets/highlight/styles/github.css">
<script src="../assets/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  <link rel="canonical" href="http://1ambda.github.io/new-to-play-framework-2/">
    <meta name="referrer" content="origin">
    
    <meta property="og:site_name" content="Old Lisper">
    <meta property="og:type" content="article">
    <meta property="og:title" content="new to Play Framework 2">
    <meta property="og:description" content="Play Framework 를 배우기로 마음먹었다. 새로운 무언가를 마주쳤을때, 어떻게 해결할까를 위주로 서술했다. Installation 우선 설치를 해야했다. Play 를 배포하는 Typesafe 의 Getting Started 에 들어가서, 확인해보니 activator 라는 제품으로 Play 를 감싸 편하게 개발할 수 있도록 해주는 플랫폼을 만들어 놨다....">
    <meta property="og:url" content="http://1ambda.github.io/new-to-play-framework-2/">
    <meta property="article:published_time" content="2014-10-02T12:50:48.098Z">
    <meta property="article:modified_time" content="2014-10-03T11:20:52.234Z">
    <meta property="article:tag" content="scala">
    <meta property="article:tag" content="play framework">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="new to Play Framework 2">
    <meta name="twitter:description" content="Play Framework 를 배우기로 마음먹었다. 새로운 무언가를 마주쳤을때, 어떻게 해결할까를 위주로 서술했다. Installation 우선 설치를 해야했다. Play 를 배포하는 Typesafe 의 Getting Started 에 들어가서, 확인해보니 activator 라는 제품으로 Play 를 감싸 편하게 개발할 수 있도록 해주는 플랫폼을 만들어 놨다....">
    <meta name="twitter:url" content="http://1ambda.github.io/new-to-play-framework-2/">
    
    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Article",
    "publisher": "Old Lisper",
    "author": {
        "@type": "Person",
        "name": "1ambda",
        "image": "//www.gravatar.com/avatar/aa2032ba2302419e3c2ede54f1fbf687?d=404&s=250",
        "url": "http://1ambda.github.io/author/1ambda",
        "sameAs": "http://1ambda.github.io",
        "description": "Functional, Scala, Akka, Rx and Haskell"
    },
    "headline": "new to Play Framework 2",
    "url": "http://1ambda.github.io/new-to-play-framework-2/",
    "datePublished": "2014-10-02T12:50:48.098Z",
    "dateModified": "2014-10-03T11:20:52.234Z",
    "keywords": "scala, play framework",
    "description": "Play Framework 를 배우기로 마음먹었다. 새로운 무언가를 마주쳤을때, 어떻게 해결할까를 위주로 서술했다. Installation 우선 설치를 해야했다. Play 를 배포하는 Typesafe 의 Getting Started 에 들어가서, 확인해보니 activator 라는 제품으로 Play 를 감싸 편하게 개발할 수 있도록 해주는 플랫폼을 만들어 놨다...."
}
    </script>

    <meta name="generator" content="Ghost 0.6">
    <link rel="alternate" type="application/rss+xml" title="Old Lisper" href="http://1ambda.github.io/rss/">

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52181619-1', '1ambda.github.io');
  ga('send', 'pageview');
</script>
  
</head>
<body>

  <script src="../public/jquery.js?v=1e25303174"></script>

  
<header class="site_width text center padding_top_big margin_bottom_big">
  
  <h1 class="blog_title margin_bottom_small"><a href="http://1ambda.github.io">Old Lisper</a></h1>
  <h4 class="text book">Functional Programming World</h4>
  <div class="social border solid top_small bottom_small padding_medium">
  <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="../articles.1"><i class="fa fa-columns"></i> <span class="margin_left_small desktop">Article</span></a></h6>
  <h6 class="text book color c_black_medium without_margin padding_right_big"><a href="http://kr.linkedin.com/in/1ambda" target="_blank"><i class="fa fa-linkedin-square"></i> <span class="margin_left_small desktop">Linkedin</span></a></h6>
  <h6 class="text book color c_black_medium without_margin"><a href="http://github.com/1ambda" target="_blank"><i class="fa fa-github"></i> <span class="margin_left_small desktop">GitHub</span></a></h6>
</div>
</header>

<main class="site_width" role="main">
  <article class="post tag-scala tag-play-framework">


    <header class="text center margin_bottom_medium">
      <h5 class="text book small uppercase color c_black_light margin_bottom_small">Posted in <a href="../tag/scala/">scala</a>, <a href="http://127.0.0.1:2368/tag/play-framework/">play framework</a></h5>
      <h1 class="margin_bottom_medium">new to Play Framework 2</h1>
      <h5 class="text book small uppercase color c_black_light margin_bottom_small"><time datetime="2014-10-02">Thursday, October 02, 2014</time>
      <br><br>
       <a href="http://1ambda.github.io/new-to-play-framework-2/#disqus_thread">Comment</a>
      </h5>
    </header>

    <section>
      <p><em>Play Framework</em> 를 배우기로 마음먹었다. 새로운 무언가를 마주쳤을때, 어떻게 해결할까를 위주로 서술했다.</p>

<h3 id="installation">Installation</h3>

<p>우선 설치를 해야했다. <em>Play</em> 를 배포하는 Typesafe 의 <a href="https://typesafe.com/platform/getstarted">Getting Started</a> 에 들어가서, 확인해보니 <strong>activator</strong> 라는 제품으로 <em>Play</em> 를 감싸 편하게 개발할 수 있도록 해주는 플랫폼을 만들어 놨다. </p>

<p><a href="https://www.playframework.com/documentation/2.3.x/Installing">Installing Play</a> 를  참조해서 <strong>activator</strong> 설치 후에, <strong>PATH</strong> 에 추가했다. <a href="https://www.playframework.com/documentation/2.3.x/NewApplication">Creating New Application</a> 와 <a href="https://www.playframework.com/documentation/2.3.x/PlayConsole">Activator Console Usage</a> 을 참조해서 새 프로젝트를 생성하고, <strong>activator</strong> 의 기본적인 사용법을 익혔다.</p>

<pre><code class="scala">$ activator new example-app play-scala
$ cd example-app
$ ./activator run
</code></pre>

<p><strong>activator</strong> 는 <strong>sbt</strong> 위에서 돌아가는 또 다른 콘솔이기 때문에, 이렇게도 쓸 수 있다.</p>

<pre><code class="scala">$ sbt
[example-app] $ compile
[example-app] $ test
[example-app] $ run
</code></pre>

<p>IDE intergration 을 하려고 <a href="https://www.playframework.com/documentation/2.3.x/PlayConsole">https://www.playframework.com/documentation/2.3.x/PlayConsole</a> 를 따라했는데 잘 안됀다. 나는 emacs 를 쓰는데 <code>ensime</code> 과 <code>activator</code> 가 디펜던시 충돌이 있는 것 같다. <code>ensime</code> 을 쓰지 않기로 결정했다. 구글링 해보니 <code>ensime-sbt</code> 0.17 에서 해결한단다. 지금은 0.15-SNAPSHOT 인데 1-2 달 걸린다고 하고 자세한건 <a href="https://github.com/sbt/sbt/issues/1592">https://github.com/sbt/sbt/issues/1592</a> 여기 참조.</p>

<h3 id="directorystructure">Directory Structure</h3>

<p>이제 뭘 하려면 파일을 수정해야 하는데, <strong>activator</strong> 가 생성해주는 파일이 생각보다 많아서 무엇을 수정해야하는지 좀 난감했다. <a href="https://www.playframework.com/documentation/2.3.x/NewApplication">Anatomy of a Play Application</a> 을 참조해서 디렉토리 구조를 살펴봤다.</p>

<pre><code>app                      → Application sources  
 └ assets                → Compiled asset sources
    └ stylesheets        → Typically LESS CSS sources
    └ javascripts        → Typically CoffeeScript sources
 └ controllers           → Application controllers
 └ models                → Application business layer
 └ views                 → Templates
build.sbt                → Application build script  
conf                     → Configurations files and other non-compiled resources (on classpath)  
 └ application.conf      → Main configuration file
 └ routes                → Routes definition
public                   → Public assets  
 └ stylesheets           → CSS files
 └ javascripts           → Javascript files
 └ images                → Image files
project                  → sbt configuration files  
 └ build.properties      → Marker for sbt project
 └ plugins.sbt           → sbt plugins including the declaration for Play itself
lib                      → Unmanaged libraries dependencies  
logs                     → Standard logs folder  
 └ application.log       → Default log file
target                   → Generated stuff  
 └ scala-2.10.0            
    └ cache              
    └ classes            → Compiled class files
    └ classes_managed    → Managed class files (templates, ...)
    └ resource_managed   → Managed resources (less, ...)
    └ src_managed        → Generated sources (templates, ...)
test                     → source folder for unit or functional tests  
</code></pre>

<p><code>build.sbt</code> 에 빌드 스크립트가, <code>project/plugins.sbt</code> 에 디펜던시가 나열되어 있었고 <code>lib</code> 폴더 내에 unmanaged 디펜던시를 넣게끔 되어 있었다. <code>build.properties</code> 는 <strong>sbt</strong> 버전이 기록되어있다. </p>

<p>로그같은 경우는 <code>logs</code> 폴더가 따로 있고, 여기 내에 <code>application.log</code> 파일에 디폴트로 로그가 쌓인다. </p>

<p><code>conf</code> 밑에는 <code>application.conf</code> 에 데이터베이스 커넥션이나, 로거 세팅등 <em>Play</em> 에서 사용하는 세팅이 적게끔 되어있다. <code>routes</code> 는 URL 세팅이 담겨있다. 새로운 API를 추가하면, 아마 여기에도 추가해야 할 것 같다.</p>

<p><code>app</code> 은 다른 웹 프레임워크처럼 <code>views</code>, <code>controllers</code>, <code>models</code> 와 같은 디렉터리가 있다. <code>views</code> 밑에 템플릿 파일들을 보면 파일 이름이 <code>main.scala.html</code>, <code>index.scala.html</code> 과 같은데, 이건 조금 더 살펴봐야겠다.</p>

<p><em>Play</em> 는 LESS 나 Stylus, Coffee 처럼 pre-processor 의 소스코드를 <code>app/assets</code> 하위에 놓고, 빌드 스크립트를 이용해서 <code>public</code> 으로 컴파일 되도록 해 놓았다.</p>

<h3 id="helloworld">Hello World</h3>

<p>이제 준비는 다 되었으니, <strong>Hello Wolrd</strong> 를 찍을 차례다. 다 됐고, <code>views</code> 폴더 밑에 있는 파일을 수정해야겠다. <code>localhost:9000</code> 를 입력했을때 나오는 컨트롤러와 뷰를 찾기 위해서 <code>conf/routes</code> 를 확인하니, 아래와 같았다.</p>

<pre><code class="scala"># Routes
# This file defines all application routes (Higher priority routes first)
# ~~~~

# Home page
GET     /                           controllers.Application.index

# Map static resources from the /public folder to the /assets URL path
GET     /assets/*file               controllers.Assets.at(path="/public", file)  
</code></pre>

<p><code>GET /</code> 했을때, <code>controllers/Application.scala</code> 파일로 간다.</p>

<pre><code class="scala">// controllers/Application.scala

package controllers

import play.api._  
import play.api.mvc._

object Application extends Controller {

  def index = Action {
    Ok(views.html.index("Your new application is ready."))
  }
}
</code></pre>

<p><code>views/index.scala.html</code> 에 <code>"Your new application is ready."</code> 를 전달한다. <code>Action</code> 과 <code>Ok</code> 은 무엇인지 몰라서 구글링 해보니 <a href="https://www.playframework.com/documentation/2.3.x/ScalaActions">What is Action</a> 이라는 문서가 있다. 이 문서에 의하면 <code>Action</code> 은 <code>play.api.mvc.Request</code> 를 받아 <code>play.api.mvc.Response</code> 를 만드는 함수다.</p>

<pre><code class="scala">Action {  
  Ok("Hello world")
}
</code></pre>

<p>이 경우 <code>Ok</code> 는 <strong>HTTP Status 200</strong> 과 <code>text/plain</code> 컨텐츠를 담고있는 <code>play.api.mvc.Response</code> 를 만들어 낸다. 그리고 <code>play.api.mvc.Action</code> 의 컴패니온 오브젝트는 다양한 헬퍼를 제공하는데, 아래가 그 예다.</p>

<pre><code class="scala">Action { request =&gt;  
  Ok("Got request [" + request + "]")
}

Action(parse.json) { implicit request =&gt;  
  Ok("Got request [" + request + "]")
}
</code></pre>

<p>근데 그 전에, <code>implicit</code> 에 대해서 이해가 안됀다. <a href="http://stackoverflow.com/questions/10375633/understanding-implicit-in-scala">Understanding implicit in Scala</a> 라는 SO(Stackoverflow) 질문에서 <a href="http://pietrowski.info/2009/07/scala-implicit-conversion/">Scala Implicit Conversion</a> 이라는 블로그도 찾아냈다. </p>

<p><strong>Implicit conversion</strong> 은, 쉽게 말해서 <code>A</code> 가 필요할때 <code>B</code> 가 있고, 타입이 맞지 않는다면, <code>A -&gt; B</code> 를 해줄 수 있는 <code>implicit function value</code> 을 찾는다. (물론 <code>A</code> 와 <code>B</code>에 대한 컴패니온 오브젝트도 찾아서, 변환할 수 있으면 변환도 할거고). <code>function</code> 대신 <code>def</code> 를 사용해도 <strong>eta-expanded</strong> 될 것이므로 문제 없다. SO 의 원문도 첨부하면</p>

<blockquote>
  <p>When the compiler finds an expression of the wrong type for the context, it will look for an implicit Function value of a type that will allow it to typecheck. So if an A is required and it finds a B, it will look for an implicit value of type B =&gt; A in scope (it also checks some other places like in the B and A companion objects, if they exist). Since defs can be "eta-expanded" into Function objects, an implicit def xyz(arg: B): A will do as well.</p>
</blockquote>

<p><br> <br>
이제, 컨트롤러를 일단 해결 했으니 <code>views/index.scala.html</code> 로 넘어가자.</p>

<pre><code class="scala">@(message: String)

@main("Welcome to Play") {

    @play20.welcome(message)

}
</code></pre>

<p><code>controlers/Application.scala</code> 컨트롤러에서 넘어온 문자열 값 <code>"Your new application is ready"</code> 가 <code>message</code> 변수에 들어가고 <code>@</code> 가 <em>Play</em> 템플릿 엔진에서 사용하는 문법 인것 같다. <code>@main</code> 은 아마 <code>views/main.scala.html</code> 을 <em>include</em> 하는 문법 같다. <code>main.scala.html</code> 의 내용은 아래와 같다.</p>

<pre><code class="html">@(title: String)(content: Html)

&lt;!DOCTYPE html&gt;

&lt;html&gt;  
    &lt;head&gt;
        &lt;title&gt;@title&lt;/title&gt;
        &lt;link rel="stylesheet" media="screen" href="@routes.Assets.at("stylesheets/main.css")"&gt;
        &lt;link rel="shortcut icon" type="image/png" href="@routes.Assets.at("images/favicon.png")"&gt;
        &lt;script src="@routes.Assets.at("javascripts/hello.js")" type="text/javascript"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        @content
    &lt;/body&gt;
&lt;/html&gt;  
</code></pre>

<p>조금 난해하긴 한데, <code>@main</code> 이 <code>main.scala.html</code> 를 부르는거라 생각하면, 두개의 인자를 <code>main.scala.html</code> 에서 받으므로 <code>index.scala.html</code> 의 <code>@main</code> 부분 에서도 두개를 넘겨줘야 한다. 하나는 컨트롤러에서 받은 <code>message</code> 고 두번째 인자는 <code>main(message)</code> 가 리턴하는 함수에 넘겨줄 <code>content</code> 변수를 <code>play20.welcome</code> 를 통해서 만들어 낸다. 아직 왜 커링을 이용하는진 모르겠다.</p>

<p>찾아보니 <code>target/scala-2.11/twirl/main/views/html/index.template.scala</code> 에서 <code>play20.welcome</code> 을 호출한다. 아마 빌트인 라이브러리인가 보다. </p>

<p>템플릿 엔진에 대해 이해하기 전에, 일단 <code>welcome</code> API 부터 만들어 보자. 구글에서 검색하니 <a href="https://github.com/playforscala/sample-applications/">Play for Scala, Sample Application</a> 라는 프로젝트가 있어서 참고했다.</p>

<p>결국 내가 <code>GET /welcome</code> 를 만들려면, <code>controllers/Application.scala</code> 에 메소드를 아래와 같이 추가한 뒤 </p>

<pre><code class="scala">def welcome(name: String) = Action {  
  Ok("welcome " + name)
}
</code></pre>

<p>해당 API 를 <code>conf/routes</code> 에 추가한다.</p>

<pre><code>GET    /welcome            controllers.Application.welcome(name: String)  
</code></pre>

<p>만약 <em>HTML</em> 을 렌더링하고 싶다면 <code>welcome.scala.html</code> 을 아래처럼 만들고</p>

<pre><code class="html">@(name: String)

&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
  &lt;title&gt;Welcome Page&lt;/title&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome, &lt;em&gt;name&lt;/em&gt;&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;  
</code></pre>

<p>컨트롤러의 <code>welcome</code> 메소드를 다음과 같이 수정한다.</p>

<pre><code class="scala">// Application.scala

def welcome(name: String) = Action {  
  Ok(views.html.welcome(name))
}
</code></pre>

<h3 id="templateengine">Template Engine</h3>

<p><a href="https://www.playframework.com/documentation/2.3.x/ScalaTemplates">Scala Tempaltes</a> 링크에서 <em>Play</em> 템플릿 엔진에 대한 기본적인 이해를 할 수 있었다. 다른 언어와 다른점은, 템플릿 엔진 문법을 열고 닫고 할 필요 없이 스칼라는 <code>@</code> 한번만 이용해도 <code>if</code> 블럭같은 멀티라인 코드를 처리할 수 있다는 것.</p>

<pre><code class="html">@if(items.isEmpty) {
  &lt;h1&gt;Nothing to display&lt;/h1&gt;
} else {
  &lt;h1&gt;@items.size items!&lt;/h1&gt;
}
</code></pre>

<h3 id="restapiget">REST API : GET</h3>

<p>이제 기본적인 무언가를 만들 준비가 됐다. 구글에서 <em>scala play example github</em> 을 검색해서 나온 <a href="https://github.com/playforscala/sample-applications/blob/master/ch02-your-first-play-application/first-sample/">예제 프로젝트</a>를 참고해서 만들어 보자.</p>

<p><code>conf/routes</code> 에 API 를 정의하고,</p>

<pre><code class="scala">GET /phones/:model.json controllers.Phones.show(model String)  
</code></pre>

<p><strong>Model</strong> 을 정의하자.</p>

<pre><code class="scala">// app/models/Phone.scala

case class Phone(model: String, brand: String, price: Int)  
</code></pre>

<p>이제 <code>app/controllers/Phones.scala</code> 컨트롤러를 만들면 된다. </p>

<pre><code class="scala">package controllers

import play.api._  
import play.api.mvc._

import models.Phone

object Phones extends Controller {

  def show(model: String) = Action {
    Ok(s"{ Model : ${model} }")
  }
}
</code></pre>

<p>근데, 잠깐! 어떻게 <em>Model</em> 을 <em>Json</em> 으로 변환하는지 모른다. <em>scala play json</em> 이라고 검색해보니 <a href="https://www.playframework.com/documentation/2.3.x/ScalaJson">Scala Json</a> 이라는 문서가 나오긴 한다.</p>

<p><code>play.api.lib.json</code> 패키지에 있는 <code>JsValue</code> 를 만들면, <code>Ok</code> 를 이용해서 날릴 수 있다. <code>JsValue</code> 를 만들기 위해선 <code>Json.toJson</code> 을 사용하면 되는데, <strong>Primitive Type</strong> 이나 <strong>Collection</strong> 은 디폴트로 지원해 준다. 따라서 <code>Json.toJson("Fiver")</code> 혹은 <code>Json.toJson(Seq(1, 2, 3, 4))</code> 와 같이 사용할 수 있다.</p>

<p>그런데 문제는 우리가 만든 클래스는 디폴트로 <code>JsValue</code> 로 바꿀수 없다. <code>Json.toJson</code> 은 인자로 받은 것을 <code>JsValue</code> 로 변환하기 위해 <code>Json.toJson[T](T)(implicit writes: Writes[T])</code> 를 사용하는데, 우리가 만든 <code>Phone</code> 을 위한 <code>Writes[Phone]</code> 은 없기 때문에 만들어 줘야 한다.</p>

<pre><code class="scala">// controllers.Phones.scala

...
  def show(model: String) = Action {
    Ok(Json.toJson(Phone(model, "Samsung", 4900)))
  }

  implicit val phoneWrites = new Writes[Phone] {
    def writes(phone: Phone) = Json.obj(
      "model" -&gt; phone.model,
      "brand" -&gt; phone.brand,
      "price" -&gt; phone.price
    )
  }
...
</code></pre>

<p><code>Phones</code> 컨트롤러 내부에 위와 같이 작성하면, <code>/phones/samsung.json</code> 과 입력했을때 <code>{"model":"samsung","brand":"Samsung","price":4900}</code> 와 같은 <code>application/json</code> response 가 돌아온다. 코드는 간단하다, <code>Writes[Phone]</code> 을 만드는데, 여기 내부에 <code>Phone</code> 을 받아 <code>JsValue</code> 를 돌려줄수 있는 <code>writes</code> 함수를 <code>Json.obj</code> 를 이용해서 만들면 된다. </p>

<p>컨트롤러에 <code>Writes[Phone]</code> 이 있어야되는지 의문이다 모델에 있어야만 할 것 같다. 그리고 구글링 해서 나온 <a href="https://gist.github.com/ayush/2428013">Gist: Play 2.0 Marshalling</a>를 따라가면 더 나은 버전이 있는데, 일단은 이걸로 족하다. 나중에 더 고치자.</p>

<p>이제 단순히 컨트롤러에서 직접 생성하는 대신, <em>Repository</em> 역할을 해줄 <code>Phone</code> 의 <em>Companion Object</em> 를 <code>models/Phone.scala</code> 에 만들자.</p>

<pre><code class="scala">object Phone {  
  var phones = Set(
    Phone("Nexus5", "Google", 459000),
    Phone("Galaxy Note4", "SamSung", 996000),
    Phone("G3 Pro", "LG", 681000)
  )
}
</code></pre>

<p>이제 컨트롤러에서 호출할 메소드를 만들면 되는데, 이름을 짓는법이 걱정이다. <code>getAll</code> 과 같은 이름도 나쁘진 않을텐데, 정해진 스탠다드가 있지 않을까? <em>DAO method name convention</em> 을 검색해 보았다. <a href="http://stackoverflow.com/questions/20447582/standard-naming-convention-for-dao-methods">SO 답변</a> 을 보니, <strong>Spring Data JPA</strong> 의 메소드 컨벤션을 따르는것도 괜찮다고 해서 그러기로 했다. </p>

<p><code>find*</code> 는 <em>Select</em> 를 수행하는 메소드의 이름이다. <code>get</code> 은 보통 getter 와 혼동할 여지가 있기 때문에 <code>find</code> 가 더 나은것 같다. 나머지는 직관적인 <code>create</code>, <code>update</code>, <code>delete</code> 를 사용하기로 했다. </p>

<p>이제 <code>models/Phone.scala</code> 을 다시 작성해 보면</p>

<pre><code class="scala">package models

case class Phone(model: String, brand: String, price: Int) {  
  override def toString = "[%s : ], - %s".format(model, brand, price)
}

object Phone {  
  var phones = Set(
    Phone("nexus5", "Google", 459000),
    Phone("note4", "SamSung", 996000),
    Phone("g3", "LG", 681000)


  def findByModel(model: String) = phones.find(_.model == model)
}
</code></pre>

<p>컨트롤러는, </p>

<pre><code class="scala">  def get(model: String) = Action {
    Ok(Json.toJson(Phone.findByModel(model)))
  }
</code></pre>

<p>잘 동작한다. 있으면 뿌려주고, 없으면 <code>null</code> 을 Response 에 담아 보낸다. 난 <code>null</code> 대신 <em>HTTP status 404</em> 가 왔으면 좋겠다. 컨트롤러의 <code>get</code> 메소드를 다음처럼 고친다.</p>

<pre><code class="scala">  def get(model: String) = Action {
    Phone.findByModel(model).map { model =&gt;
      Ok(Json.toJson(model))
    }.getOrElse(NotFound)
  }
</code></pre>

<p>이제 <code>/phones.json</code> API 를 만들어 보자. 컨트롤러 내에 <code>list</code> 메소드를, <em>Phone</em> 컴패니언 오브젝트 내에 <code>findAll</code> 메소드를 추가한다.</p>

<pre><code class="scala">// models/Phone.scala

object Phone {  
  var phones = Set[Phone]()

  def findByModel(model: String) = phones.find(_.model == model)
  def findAll = phones.toList
}


// controllers/Phones.scala

  def list = Action {
    Ok(Json.toJson(Phone.findAll))
  }
</code></pre>

<p>갑자기 궁금해진게 있다. 내가 <code>var phones = Set[Phone]()</code> 처럼 empty <em>Repository</em> 를 만들면, <code>GET /phones.json</code> 을 요청했을때 <code>200 OK</code> 와  <code>[]</code>, 즉 빈 배열이 돌아오는데 이게 <em>REST API</em> 에서 적절한 응답일까? <em>REST get all resources empty</em> 라고 검색하니 SO 에서 <a href="http://stackoverflow.com/questions/13366730/proper-rest-response-for-empty-table">Proper response for empty table?</a> 이라는 질문이 있다.</p>

<p><em>204 (No Content)</em> 와 <em>404 (Not Found)</em> 중 어떤걸 응답 코드로 사용해야 하냐는 질문에 <em>200 (OK)</em> 가 더 적절하다고 말한다. 왜냐하면, 요청된 리소스인 Collection 은 존재하나, 그 내부가 비었기 때문이다. </p>

<p>유저 몇명을 삭제해서 Collection 이 <em>비었을때</em> <strong>404</strong> 를 보낸다면 <strong>/users</strong> 라는 API 가 삭제된 것으로 오인할 수 있다.</p>

<p><strong>204</strong> 같은 경우, request 는 처리 되었으나 응답할 필요가 없는 <em>delete</em> 같은 요청의 응답코드로 사용되는 것이 적절하다. 원문을 첨부하면,</p>

<blockquote>
  <p><strong>Why not 404 (Not Found)?</strong> <br><br>
  The 404 status code should be reserved for situations, in which a resource is not found. In this case, your resource is a collection of users. This collection exists but it's currently empty. Personally, I'd be very confused as an author of a client for your application if I got a 200 one day and a 404 the next day just because someone happened to remove a couple of users. What am I supposed to do? Is my URL wrong? Did someone change the API and neglect to leave a redirection. <br><br>
  <strong>Why not 202 (No Content)?</strong> <br><br>
  A 204 is supposed to indicate that some operation was executed successfully and no data needs to be returned. This is perfect as a response to a DELETE request or perhaps firing some script that does not need to return data. In case of api/users, you usually expect to receive a representation of your collection of users. Sending a response body one time and not sending it the other time is inconsistent and potentially misleading.</p>
</blockquote>

<h3 id="restapipost">REST API : POST</h3>

<p>이제 <em>POST</em> 요청을 처리하기 위해 컨트롤러에 <code>add</code> 메소드를, 레포지터리에 <code>create</code> 메소드를 추가해 보자.</p>

<p>일단 <code>conf/routes</code> 에 라우팅을, 컨트롤러에 메소드를 추가한다.</p>

<pre><code>// conf/routes

`POST    /phones/:model.json         controllers.Phones.add(model: String)

// controllers/Phones.scala

  def add(model: String) = Action { request =&gt;

  }
</code></pre>

<p>이 <em>POST</em> 요청 핸들러를 작성하려면 내가 모르는것은 2가지다.</p>

<p><em>(1) Request body 에서 파라미터 추출</em> <br>
<em>(2) 추출한 파라미터를 암시적으로 <code>Phone</code> 인스턴스로 변경</em>  </p>

<p>일단, 검색을 해보니 여러 문서를 찾았다.</p>

<p>(1) <a href="https://www.playframework.com/documentation/2.3.x/ScalaJson">ScalaJson</a> <br>
(2) <a href="https://www.playframework.com/documentation/2.3.x/ScalaJsonHttp">ScalaJsonHttp</a> <br>
(3) <a href="https://www.playframework.com/documentation/2.3.x/ScalaJsonCombinators">ScalaJsonCombinators</a>  </p>

<p>놀랍게도 이걸 다 이해해야 한다. 스칼라의 JSON 처리는, 아니 <em>Play</em> 의 JSON 처리는 <em>직관적이지 못한 것 같다.</em> 일단 예제 코드를 보면</p>

<pre><code class="scala">  def add() = Action(BodyParsers.parse.json) { request =&gt;
    val phoneRes = request.body.validate[Phone]
    phoneRes.fold(
      errors =&gt; {
        BadReques
      },
      phone =&gt; {
        Phone.create(phone)
      }
    )
  }

  implicit val phoneReads: Reads[Phone] = (
    (JsPath \ "model").read[String] and
    (JsPath \ "brand").read[String] and
    (JsPath \ "price").read[Int]
  )(Phone.apply _)
</code></pre>

<p>요약하자면, <code>Action(BodyParsers.parse.json</code> 을 이용하면, <em>Content-Type</em> 으로 <code>application/json</code> 혹은 <code>text/json</code> 을 받아들이고, Request Body 에 있는 값들을 파싱해서 <code>JsValue</code> 를 만들어 낸다.</p>

<p>그리고 <code>validate[Phone]</code> 를 이용해서 <code>implicit Reads[Phone]</code> 을 호출하여, validation 한 결과값을 얻는다. </p>

<p>그리고 이 값을 처리하기 위해 <code>fold</code> 메소드를 사용하는데, 첫 인자는 validation 에 실패했을 경우, 후자는 성공했을 경우의 로직을 적으면 된다.</p>

<p>정정하겠다. <em>Play</em> 의 JSON 처리는 처음보면 난해하지만, Static Typing 에서 필요한 instance converting 과 validation 을 잘 섞은 <em>깔끔한 방법</em> 이다.</p>

<p><code>phoneReads</code> 를 만드는 과정이 좀 난해하긴 한데, <a href="https://www.playframework.com/documentation/2.3.x/ScalaJsonCombinators">여기</a> 를 좀더 참고하면 <code>JsPath</code> 와 <code>and</code> 를 이용해서 만드는건 사실 <code>FunctionalBuilder[Reads]#CanBuild3[String, String, Int]</code> 다. 이것 자체가 중요한것은 아니고, 이건 사실 바디파서로부터 뽑혀 나온 것들을 스칼라 타입으로 바꾼 것들을 담고 있는 통이고, 여기에 <code>Phone.apply</code> 를 호출해서 <code>Phone</code> 을 하나 만들 수 있다. </p>

<p><code>Writes[Phone]</code> 도 <code>JsPath</code> 를 이용해서 만들 수 있다.</p>

<pre><code class="scala">  implicit val phoneWirtes: Writes[Phone] = (
    (JsPath \ "model").write[String] and
    (JsPath \ "brand").write[String] and
    (JsPath \ "price").write[Int]
  )(unlift(Phone.unapply))
</code></pre>

<p>이 두개의 <code>Reads[T]</code> 와 <code>Writes[T]</code> 를 mixin 하면 <code>Format[T]</code> 가 된다. </p>

<pre><code class="scala">  val phoneWirtes: Writes[Phone] = (
    (JsPath \ "model").write[String] and
    (JsPath \ "brand").write[String] and
    (JsPath \ "price").write[Int]
  )(unlift(Phone.unapply))

  val phoneReads: Reads[Phone] = (
    (JsPath \ "model").read[String] and
    (JsPath \ "brand").read[String] and
    (JsPath \ "price").read[Int]
  )(Phone.apply _)

  implicit val phoneFormat: Format[Phone] =
    Format(phoneReads, phoneWirtes)
</code></pre>

<p>더 나아가서, 우리의 조그만 어플리케이션의 경우에는 <code>Reads</code> 와 <code>Writes</code> 가 다르지 않으므로 <code>Combinator</code> 를 이용해서 바로 <code>Format</code> 을 만들 수 있다.</p>

<pre><code class="scala">  implicit val phoneFormat: Format[Phone] = (
    (JsPath \ "model").format[String] and 
    (JsPath \ "brand").format[String] and
    (JsPath \ "price").format[Int]
  ) (Phone.apply, unlift(Phone.unapply))
</code></pre>

<p><code>Writes[Phone]</code> 이 <code>Phone</code> 을 이용해서 <code>Js.Value</code> 를 만들어준다는건 알겠는데, <code>unlift</code> 가 무엇인지 궁금하다. Scala Doc 에서 <a href="http://docs.scala-lang.org/overviews/quasiquotes/unlifting.html">unlifting</a> 과 <a href="http://docs.scala-lang.org/overviews/quasiquotes/lifting.html">lifting</a> 에 관한 링크를 찾아냈다. </p>

<p>쉽게 말해서 <strong>lifting</strong> 은 함수가 리턴해주는 타입에 대해 <code>Option</code> 을 씌워주는 것이고, <strong>unlifting</strong> 은 벗겨주는 것이다. <code>Phone.unapply</code> 는 <code>Phone =&gt; Option[(String, String, Int)]</code> 이므로, <code>unlift</code> 를 적용하면 <code>Phone =&gt; (String, String, Int)</code> 가 됀다. </p>

<p><strong>lifting</strong> 과 <strong>partial function</strong> 에 관한건 <a href="http://stackoverflow.com/questions/17965059/what-is-lifting-in-scala">SO: What is lifting in Scala</a> 으로, <em>Play</em> 의 <strong>JSON API</strong> 에 관한건 <a href="http://mandubian.com/2012/10/01/unveiling-play-2-dot-1-json-api-part2-writes-format-combinators/">Unveiling Play2 JSON API</a> 로</p>

<p>이제 구현을 요약하자면, <code>models/Phone.scala</code> 의 <code>create</code> 메소드는</p>

<pre><code class="scala">  def create(phone: Phone) = {
    phones = phones + phone
  }
</code></pre>

<p><code>controllers/Phones.scala</code> 의 <code>add</code> 메소드는</p>

<pre><code class="scala">  def add() = Action(BodyParsers.parse.json) { request =&gt;
    val phoneRes = request.body.validate[Phone]
    phoneRes.fold(
      errors =&gt; {
        BadRequest(Json.obj("status" -&gt;"404", "message" -&gt; JsError.toFlatJson(errors)))
      },
      phone =&gt; {
        Phone.create(phone)
        Created
      }
    )
  }
</code></pre>

<h3 id="summary">Summary</h3>

<p><em>Play</em> 에 대해 아무것도 모르는 상태에서, 간단한 엔티티를 하나 만들고 <em>POST</em>, <em>GET</em> API 를 만들어 보았다. 에러 핸들링도 없고, 부족한게 많지만 차차 붙여 나가면 될테다. </p>
    </section>

    <footer>
      <section class="author_info margin_top_big">
        <div class="alignleft border rad_circle" style="height: 87px; width: 87px; background-image: url(http://www.gravatar.com/avatar/aa2032ba2302419e3c2ede54f1fbf687?d=404&amp;s=250); background-size: cover;"></div>
        <p class="margin_left_medium text small">Author</p>
        <p class="margin_left_medium text bold"><a href="http://1ambda.github.io">1ambda</a></p>
        <p class="margin_left_medium text small">Functional, Scala, Akka, Rx and Haskell</p>
      </section>
    </footer>


    <div id="disqus_thread" class="margin_top_big"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = '1ambda'; // required: replace example with your forum shortname
  var disqus_identifier = '33';
  var disqus_url = 'http://1ambda.github.io/new-to-play-framework-2/';

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
    </article>
</main>


  <script src="../assets/fitvids/jquery.fitvids.js"></script>
<script>
$(document).ready(function(){
  // Target your .container, .wrapper, .post, etc.
  $("section").fitVids();
});
</script>

  <footer class="blog_info margin_top_big padding_medium text center">
    <h5 class="text book small">© 2015 <a href="../">Old Lisper</a>. All rights reserved.</h5>
    <h5 class="text book small"><a href="https://github.com/dreyacosta/velox" target="_blank" class="text bold">Velox theme</a> by <a href="http://dreyacosta.com/">David Rey</a></h5>
    <h5 class="text book small">Proudly published with <a href="http://ghost.org"><span>Ghost</span></a></h5>

  </footer>

  <script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = '1ambda'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function () {
 var s = document.createElement('script'); s.async = true;
 s.type = 'text/javascript';
 s.src = '//' + disqus_shortname + '.disqus.com/count.js';
 (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
 }());
</script>


  </body>
  